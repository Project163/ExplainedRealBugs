diff --git a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
index 8a6f8f35c9..78b54d3c67 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
@@ -6,6 +6,7 @@
 using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.Design.Internal;
 using Microsoft.EntityFrameworkCore.Internal;
+using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Query.Internal;
 
@@ -1179,18 +1180,7 @@ private void Create(IEntityType entityType, CSharpRuntimeAnnotationCodeGenerator
         var valueComparerType = (Type?)property[CoreAnnotationNames.ValueComparerType];
         if (valueComparerType != null)
         {
-            AddNamespace(valueComparerType, parameters.Namespaces);
-
-            var valueComparerString = $"new {_code.Reference(valueComparerType)}()";
-            if (property.ClrType.IsNullableValueType())
-            {
-                var valueComparerElementType = ((ValueComparer)Activator.CreateInstance(valueComparerType)!).Type;
-                if (!valueComparerElementType.IsNullableValueType())
-                {
-                    AddNamespace(typeof(NullableValueComparer<>), parameters.Namespaces);
-                    valueComparerString = $"new NullableValueComparer<{_code.Reference(valueComparerType)}>({valueComparerString})";
-                }
-            }
+            var valueComparerString = CreateValueComparerType(valueComparerType, property.ClrType, parameters);
 
             mainBuilder.AppendLine(",")
                 .Append("valueComparer: ")
@@ -1240,11 +1230,13 @@ private void Create(IEntityType entityType, CSharpRuntimeAnnotationCodeGenerator
             && converter != null
             && property[CoreAnnotationNames.ValueConverter] != null
             && !parameters.ForNativeAot;
+        var typeMappingSet = false;
 
         if (parameters.ForNativeAot
             || (shouldSetConverter && converter!.MappingHints != null))
         {
             shouldSetConverter = false;
+            typeMappingSet = true;
             mainBuilder.Append(variableName).Append(".TypeMapping = ");
             _annotationCodeGenerator.Create(property.GetTypeMapping(), property, propertyParameters);
             mainBuilder.AppendLine(";");
@@ -1311,14 +1303,151 @@ private void Create(IEntityType entityType, CSharpRuntimeAnnotationCodeGenerator
                 .AppendLine(");");
         }
 
+        var elementType = property.GetElementType();
+        if (elementType != null)
+        {
+            Check.DebugAssert(property.IsPrimitiveCollection, $"{property.Name} has an element type, but it's not a primitive collection.");
+            Create(elementType, typeMappingSet, propertyParameters);
+        }
+
         CreateAnnotations(
             property,
             _annotationCodeGenerator.Generate,
-            parameters with { TargetName = variableName });
+            propertyParameters);
 
         mainBuilder.AppendLine();
     }
 
+    private void Create(IElementType elementType, bool typeMappingSet, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    {
+        var mainBuilder = parameters.MainBuilder;
+        var elementVariableName = _code.Identifier(parameters.TargetName + "ElementType", elementType, parameters.ScopeObjects, capitalize: false);
+        var elementParameters = parameters with { TargetName = elementVariableName };
+
+        mainBuilder
+            .Append("var ").Append(elementVariableName).Append(" = ")
+            .Append(parameters.TargetName).Append(".SetElementType(").IncrementIndent()
+            .Append(_code.Literal(elementType.ClrType));
+
+        if (elementType.IsNullable)
+        {
+            mainBuilder.AppendLine(",")
+                .Append("nullable: ")
+                .Append(_code.Literal(elementType.IsNullable));
+        }
+
+        if (elementType.GetMaxLength() != null)
+        {
+            mainBuilder.AppendLine(",")
+                .Append("maxLength: ")
+                .Append(_code.Literal(elementType.GetMaxLength()));
+        }
+
+        if (elementType.IsUnicode() != null)
+        {
+            mainBuilder.AppendLine(",")
+                .Append("unicode: ")
+                .Append(_code.Literal(elementType.IsUnicode()));
+        }
+
+        if (elementType.GetPrecision() != null)
+        {
+            mainBuilder.AppendLine(",")
+                .Append("precision: ")
+                .Append(_code.Literal(elementType.GetPrecision()));
+        }
+
+        if (elementType.GetScale() != null)
+        {
+            mainBuilder.AppendLine(",")
+                .Append("scale: ")
+                .Append(_code.Literal(elementType.GetScale()));
+        }
+
+        var providerClrType = elementType.GetProviderClrType();
+        if (providerClrType != null)
+        {
+            AddNamespace(providerClrType, parameters.Namespaces);
+            mainBuilder.AppendLine(",")
+                .Append("providerClrType: ")
+                .Append(_code.Literal(providerClrType));
+        }
+
+        var jsonValueReaderWriterType = (Type?)elementType[CoreAnnotationNames.JsonValueReaderWriterType];
+        if (jsonValueReaderWriterType != null)
+        {
+            mainBuilder.AppendLine(",")
+                .Append("jsonValueReaderWriter: ");
+            CSharpRuntimeAnnotationCodeGenerator.CreateJsonValueReaderWriter(jsonValueReaderWriterType, parameters, _code);
+        }
+
+        mainBuilder
+            .AppendLine(");")
+            .DecrementIndent();
+
+        var converter = elementType.FindTypeMapping()?.Converter;
+        var shouldSetConverter = providerClrType == null
+            && converter != null
+            && elementType[CoreAnnotationNames.ValueConverter] != null
+            && !parameters.ForNativeAot;
+
+        if (parameters.ForNativeAot
+            || (shouldSetConverter && converter!.MappingHints != null))
+        {
+            shouldSetConverter = false;
+            mainBuilder.Append(elementVariableName).Append(".TypeMapping = ");
+
+            if (typeMappingSet)
+            {
+                mainBuilder.Append(parameters.TargetName).Append(".TypeMapping.ElementTypeMapping");
+            }
+            else
+            {
+                _annotationCodeGenerator.Create(elementType.GetTypeMapping(), elementParameters);
+            }
+
+            mainBuilder.AppendLine(";");
+        }
+
+        if (shouldSetConverter)
+        {
+            mainBuilder.Append(elementVariableName).Append(".SetValueConverter(");
+            _annotationCodeGenerator.Create(converter!, parameters);
+            mainBuilder.AppendLine(");");
+        }
+
+        var valueComparer = elementType.GetValueComparer();
+        var typeMappingComparer = elementType.GetTypeMapping().Comparer;
+        if ((!parameters.ForNativeAot || valueComparer != typeMappingComparer)
+            && (parameters.ForNativeAot || elementType[CoreAnnotationNames.ValueComparer] != null))
+        {
+            SetValueComparer(valueComparer, typeMappingComparer, nameof(CoreTypeMapping.Comparer), elementParameters);
+        }
+
+        CreateAnnotations(
+            elementType,
+            _annotationCodeGenerator.Generate,
+            elementParameters);
+    }
+
+    private string CreateValueComparerType(Type valueComparerType, Type clrType, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    {
+        AddNamespace(valueComparerType, parameters.Namespaces);
+
+        var valueComparerString = $"new {_code.Reference(valueComparerType)}()";
+        if (clrType.IsNullableValueType())
+        {
+            var valueComparerElementType = ((ValueComparer)Activator.CreateInstance(valueComparerType)!).Type;
+            if (!valueComparerElementType.IsNullableValueType())
+            {
+                AddNamespace(typeof(NullableValueComparer<>), parameters.Namespaces);
+                valueComparerString = $"new NullableValueComparer<{_code.Reference(valueComparerType)}>({valueComparerString})";
+            }
+        }
+
+        return valueComparerString;
+    }
+
     private void SetValueComparer(
         ValueComparer valueComparer,
         ValueComparer typeMappingComparer,
diff --git a/src/EFCore.Relational/Storage/RelationalTypeMapping.cs b/src/EFCore.Relational/Storage/RelationalTypeMapping.cs
index f2081c607f..d2db50c574 100644
--- a/src/EFCore.Relational/Storage/RelationalTypeMapping.cs
+++ b/src/EFCore.Relational/Storage/RelationalTypeMapping.cs
@@ -572,12 +572,6 @@ public virtual RelationalTypeMapping WithPrecisionAndScale(int? precision, int?
 
         if (nullable.HasValue)
         {
-            Check.DebugAssert(
-                nullable.Value
-                || !direction.HasFlag(ParameterDirection.Input)
-                || value != null,
-                "Null value in a non-nullable input parameter");
-
             parameter.IsNullable = nullable.Value;
         }
 
diff --git a/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs b/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs
index 81b989d204..0e0611667b 100644
--- a/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs
+++ b/src/EFCore.Relational/Update/ReaderModificationCommandBatch.cs
@@ -393,7 +393,7 @@ public override void Execute(IRelationalConnection connection)
 
             await ConsumeAsync(dataReader, cancellationToken).ConfigureAwait(false);
         }
-        catch (Exception ex) when (ex is not DbUpdateException and not OperationCanceledException)
+        catch (Exception ex) when (ex is not DbUpdateException and not OperationCanceledException and not UnreachableException)
         {
             throw new DbUpdateException(
                 RelationalStrings.UpdateStoreException,
diff --git a/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
index eba19a7ea4..ee574cc4aa 100644
--- a/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
@@ -140,6 +140,24 @@ public virtual void Generate(IServiceProperty property, CSharpRuntimeAnnotationC
         GenerateSimpleAnnotations(parameters);
     }
 
+    /// <inheritdoc />
+    public virtual void Generate(IElementType elementType, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+    {
+        if (!parameters.IsRuntime)
+        {
+            var annotations = parameters.Annotations;
+            foreach (var (key, _) in annotations)
+            {
+                if (CoreAnnotationNames.AllNames.Contains(key))
+                {
+                    annotations.Remove(key);
+                }
+            }
+        }
+
+        GenerateSimpleAnnotations(parameters);
+    }
+
     /// <inheritdoc />
     public virtual void Generate(IKey key, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
     {
diff --git a/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs
index 82a6e67bcb..66f5a7b630 100644
--- a/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore/Design/Internal/ICSharpRuntimeAnnotationCodeGenerator.cs
@@ -55,6 +55,13 @@ public interface ICSharpRuntimeAnnotationCodeGenerator
     /// <param name="parameters">Additional parameters used during code generation.</param>
     void Generate(IServiceProperty property, CSharpRuntimeAnnotationCodeGeneratorParameters parameters);
 
+    /// <summary>
+    ///     Generates code to create the given annotations.
+    /// </summary>
+    /// <param name="elementType">The element type to which the annotations are applied.</param>
+    /// <param name="parameters">Additional parameters used during code generation.</param>
+    void Generate(IElementType elementType, CSharpRuntimeAnnotationCodeGeneratorParameters parameters);
+
     /// <summary>
     ///     Generates code to create the given annotations.
     /// </summary>
diff --git a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
index 110d239f07..3e4c032235 100644
--- a/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
+++ b/src/EFCore/Metadata/Conventions/RuntimeModelConvention.cs
@@ -63,7 +63,8 @@ protected virtual RuntimeModel Create(IModel model)
                 var elementType = property.GetElementType();
                 if (elementType != null)
                 {
-                    var runtimeElementType = Create(runtimeProperty, elementType, property.IsPrimitiveCollection);
+                    Check.DebugAssert(property.IsPrimitiveCollection, $"{property.Name} has an element type, but it's not a primitive collection.");
+                    var runtimeElementType = Create(runtimeProperty, elementType);
                     CreateAnnotations(
                         elementType, runtimeElementType, static (convention, annotations, source, target, runtime) =>
                             convention.ProcessElementTypeAnnotations(annotations, source, target, runtime));
@@ -410,7 +411,7 @@ private static RuntimeProperty Create(IProperty property, RuntimeTypeBase runtim
                 typeMapping: property.GetTypeMapping(),
                 sentinel: property.Sentinel);
 
-    private static RuntimeElementType Create(RuntimeProperty runtimeProperty, IElementType element, bool primitiveCollection)
+    private static RuntimeElementType Create(RuntimeProperty runtimeProperty, IElementType element)
         => runtimeProperty.SetElementType(
             element.ClrType,
             element.IsNullable,
@@ -422,8 +423,7 @@ private static RuntimeElementType Create(RuntimeProperty runtimeProperty, IEleme
             element.GetValueConverter(),
             element.GetValueComparer(),
             element.GetJsonValueReaderWriter(),
-            element.GetTypeMapping(),
-            primitiveCollection);
+            element.GetTypeMapping());
 
     /// <summary>
     ///     Updates the property annotations that will be set on the read-only object.
@@ -539,7 +539,8 @@ private RuntimeComplexProperty Create(IComplexProperty complexProperty, RuntimeT
             var elementType = property.GetElementType();
             if (elementType != null)
             {
-                var runtimeElementType = Create(runtimeProperty, elementType, property.IsPrimitiveCollection);
+                Check.DebugAssert(property.IsPrimitiveCollection, $"{property.Name} has an element type, but it's not a primitive collection.");
+                var runtimeElementType = Create(runtimeProperty, elementType);
                 CreateAnnotations(
                     elementType, runtimeElementType, static (convention, annotations, source, target, runtime) =>
                         convention.ProcessElementTypeAnnotations(annotations, source, target, runtime));
diff --git a/src/EFCore/Metadata/IElementType.cs b/src/EFCore/Metadata/IElementType.cs
index e4e6637257..b74d6740d0 100644
--- a/src/EFCore/Metadata/IElementType.cs
+++ b/src/EFCore/Metadata/IElementType.cs
@@ -19,4 +19,10 @@ public interface IElementType : IReadOnlyElementType, IAnnotatable
         [DebuggerStepThrough]
         get => (IProperty)((IReadOnlyElementType)this).CollectionProperty;
     }
+
+    /// <summary>
+    ///     Gets the <see cref="ValueComparer" /> for this property.
+    /// </summary>
+    /// <returns>The comparer.</returns>
+    new ValueComparer GetValueComparer();
 }
diff --git a/src/EFCore/Metadata/Internal/ElementType.cs b/src/EFCore/Metadata/Internal/ElementType.cs
index 1cc3e90642..0b05492bdf 100644
--- a/src/EFCore/Metadata/Internal/ElementType.cs
+++ b/src/EFCore/Metadata/Internal/ElementType.cs
@@ -895,6 +895,16 @@ void IMutableElementType.SetProviderClrType(Type? providerClrType)
             providerClrType,
             fromDataAnnotation ? ConfigurationSource.DataAnnotation : ConfigurationSource.Convention);
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [DebuggerStepThrough]
+    ValueComparer IElementType.GetValueComparer()
+        => GetValueComparer()!;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore/Metadata/RuntimeElementType.cs b/src/EFCore/Metadata/RuntimeElementType.cs
index 74a78f2d22..3ccbc731ea 100644
--- a/src/EFCore/Metadata/RuntimeElementType.cs
+++ b/src/EFCore/Metadata/RuntimeElementType.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.Runtime.CompilerServices;
+using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Storage.Json;
 
@@ -15,10 +17,10 @@ namespace Microsoft.EntityFrameworkCore.Metadata;
 public class RuntimeElementType : RuntimeAnnotatableBase, IElementType
 {
     private readonly bool _isNullable;
-    private readonly ValueConverter? _valueConverter;
-    private readonly ValueComparer? _valueComparer;
+    private ValueConverter? _valueConverter;
+    private ValueComparer? _valueComparer;
     private readonly JsonValueReaderWriter? _jsonValueReaderWriter;
-    private readonly CoreTypeMapping? _typeMapping;
+    private CoreTypeMapping? _typeMapping;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -90,12 +92,27 @@ public class RuntimeElementType : RuntimeAnnotatableBase, IElementType
     public virtual bool IsNullable
         => _isNullable;
 
+    /// <summary>
+    ///     Gets or sets the type mapping for this element type.
+    /// </summary>
+    /// <returns>The type mapping.</returns>
+    public virtual CoreTypeMapping TypeMapping
+    {
+        get => NonCapturingLazyInitializer.EnsureInitialized(
+            ref _typeMapping, (IElementType)this,
+            static elementType =>
+                RuntimeFeature.IsDynamicCodeSupported
+                    ? elementType.CollectionProperty.DeclaringType.Model.GetModelDependencies().TypeMappingSource.FindMapping(elementType)!
+                    : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
+        set => _typeMapping = value;
+    }
+
     /// <summary>
     ///     Returns the type mapping for elements of the collection.
     /// </summary>
     /// <returns>The type mapping, or <see langword="null" /> if none was found.</returns>
     public virtual CoreTypeMapping? FindTypeMapping()
-        => _typeMapping;
+        => TypeMapping;
 
     /// <summary>
     ///     Gets the maximum length of data that is allowed in elements of the collection. For example, if the element type is
@@ -143,13 +160,33 @@ public virtual bool IsNullable
     public virtual ValueConverter? GetValueConverter()
         => _valueConverter;
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual void SetValueConverter(ValueConverter converter)
+        => _valueConverter = converter;
+
     /// <summary>
     ///     Gets the custom <see cref="ValueComparer" /> for elements of the collection.
     /// </summary>
     /// <returns>The comparer, or <see langword="null" /> if none has been set.</returns>
     [DebuggerStepThrough]
     public virtual ValueComparer? GetValueComparer()
-        => _valueComparer;
+        => _valueComparer ?? _typeMapping?.Comparer;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public virtual ValueComparer SetComparer(ValueComparer valueComparer)
+        => _valueComparer = valueComparer;
 
     /// <summary>
     ///     Gets the type that the elements of the collection will be converted to before being sent to the database provider.
@@ -213,11 +250,6 @@ bool IReadOnlyElementType.IsNullable
     int? IReadOnlyElementType.GetScale()
         => (int?)this[CoreAnnotationNames.Scale];
 
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    ValueConverter? IReadOnlyElementType.GetValueConverter()
-        => _valueConverter;
-
     /// <inheritdoc />
     [DebuggerStepThrough]
     Type? IReadOnlyElementType.GetProviderClrType()
@@ -227,4 +259,9 @@ bool IReadOnlyElementType.IsNullable
     [DebuggerStepThrough]
     CoreTypeMapping IReadOnlyElementType.FindTypeMapping()
         => FindTypeMapping()!;
+
+    /// <inheritdoc />
+    [DebuggerStepThrough]
+    ValueComparer IElementType.GetValueComparer()
+        => GetValueComparer()!;
 }
diff --git a/src/EFCore/Metadata/RuntimeProperty.cs b/src/EFCore/Metadata/RuntimeProperty.cs
index 52f382e4e5..5d97685914 100644
--- a/src/EFCore/Metadata/RuntimeProperty.cs
+++ b/src/EFCore/Metadata/RuntimeProperty.cs
@@ -128,14 +128,13 @@ public virtual void SetSentinelFromProviderValue(object? providerValue)
     /// <param name="unicode">A value indicating whether or not the property can persist Unicode characters.</param>
     /// <param name="precision">The precision of data that is allowed in this property.</param>
     /// <param name="scale">The scale of data that is allowed in this property.</param>
-    /// <param name="providerPropertyType">
+    /// <param name="providerClrType">
     ///     The type that the property value will be converted to before being sent to the database provider.
     /// </param>
     /// <param name="valueConverter">The custom <see cref="ValueConverter" /> set for this property.</param>
     /// <param name="valueComparer">The <see cref="ValueComparer" /> for this property.</param>
     /// <param name="jsonValueReaderWriter">The <see cref="JsonValueReaderWriter" /> for this property.</param>
     /// <param name="typeMapping">The <see cref="CoreTypeMapping" /> for this property.</param>
-    /// <param name="primitiveCollection">A value indicating whether this property represents a primitive collection.</param>
     /// <returns>The newly created property.</returns>
     public virtual RuntimeElementType SetElementType(
         Type clrType,
@@ -144,12 +143,11 @@ public virtual void SetSentinelFromProviderValue(object? providerValue)
         bool? unicode = null,
         int? precision = null,
         int? scale = null,
-        Type? providerPropertyType = null,
+        Type? providerClrType = null,
         ValueConverter? valueConverter = null,
         ValueComparer? valueComparer = null,
         JsonValueReaderWriter? jsonValueReaderWriter = null,
-        CoreTypeMapping? typeMapping = null,
-        bool primitiveCollection = false)
+        CoreTypeMapping? typeMapping = null)
     {
         var elementType = new RuntimeElementType(
             clrType,
@@ -159,7 +157,7 @@ public virtual void SetSentinelFromProviderValue(object? providerValue)
             unicode,
             precision,
             scale,
-            providerPropertyType,
+            providerClrType,
             valueConverter,
             valueComparer,
             jsonValueReaderWriter,
@@ -167,7 +165,7 @@ public virtual void SetSentinelFromProviderValue(object? providerValue)
 
         SetAnnotation(CoreAnnotationNames.ElementType, elementType);
 
-        IsPrimitiveCollection = primitiveCollection;
+        IsPrimitiveCollection = true;
 
         return elementType;
     }
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs
index 8342415b1e..e4222fae46 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs
@@ -244,6 +244,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                     clrType: typeof(Dictionary<string, int>),
                     jsonValueReaderWriter: new CosmosTypeMappingSource.PlaceholderJsonStringKeyedDictionaryReaderWriter<int>(
                         JsonInt32ReaderWriter.Instance)));
+            var listElementType = list.SetElementType(typeof(Dictionary<string, int>),
+                nullable: true);
+            listElementType.TypeMapping = list.TypeMapping.ElementTypeMapping;
 
             var map = runtimeEntityType.AddProperty(
                 "Map",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
index 794f2eb799..76b11e5a54 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
@@ -47,7 +47,6 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.ManyTypesId),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
-                valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueConverter: new CompiledModelTestBase.ManyTypesIdConverter());
             id.SetGetter(
@@ -60,7 +59,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
             id.SetMaterializationSetter(
                 (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.ManyTypesId value) => ManyTypesUnsafeAccessors.Id(entity) = value);
             id.SetAccessors(
-                CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<CompiledModelTestBase.ManyTypesId>(0) : (entry.FlaggedAsTemporary(0) && ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))).Equals(default(CompiledModelTestBase.ManyTypesId)) ? entry.ReadTemporaryValue<CompiledModelTestBase.ManyTypesId>(0) : ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                 CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
                 CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.ManyTypesId>(id, 0),
                 CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<CompiledModelTestBase.ManyTypesId>(id, 0),
@@ -70,7 +69,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 originalValueIndex: 0,
                 shadowIndex: -1,
                 relationshipIndex: 0,
-                storeGenerationIndex: 0);
+                storeGenerationIndex: -1);
             id.TypeMapping = CosmosTypeMapping.Default.Clone(
                 comparer: new ValueComparer<CompiledModelTestBase.ManyTypesId>(
                     bool (CompiledModelTestBase.ManyTypesId v1, CompiledModelTestBase.ManyTypesId v2) => v1.Equals(v2),
@@ -228,6 +227,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     clrType: typeof(bool),
                     jsonValueReaderWriter: JsonBoolReaderWriter.Instance));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
+            boolArrayElementType.TypeMapping = boolArray.TypeMapping.ElementTypeMapping;
 
             var boolNestedCollection = runtimeEntityType.AddProperty(
                 "BoolNestedCollection",
@@ -303,6 +304,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                             bool (bool v) => v),
                         clrType: typeof(bool),
                         jsonValueReaderWriter: JsonBoolReaderWriter.Instance)));
+            var boolNestedCollectionElementType = boolNestedCollection.SetElementType(typeof(bool[]));
+            boolNestedCollectionElementType.TypeMapping = boolNestedCollection.TypeMapping.ElementTypeMapping;
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
                 "BoolReadOnlyCollection",
@@ -361,6 +364,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     clrType: typeof(bool),
                     jsonValueReaderWriter: JsonBoolReaderWriter.Instance));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
+            boolReadOnlyCollectionElementType.TypeMapping = boolReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BoolToStringConverterProperty",
@@ -758,6 +763,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         char (char v) => v),
                     clrType: typeof(char),
                     jsonValueReaderWriter: JsonCharReaderWriter.Instance));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
+            charArrayElementType.TypeMapping = charArray.TypeMapping.ElementTypeMapping;
 
             var charNestedCollection = runtimeEntityType.AddProperty(
                 "CharNestedCollection",
@@ -833,6 +840,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                             char (char v) => v),
                         clrType: typeof(char),
                         jsonValueReaderWriter: JsonCharReaderWriter.Instance)));
+            var charNestedCollectionElementType = charNestedCollection.SetElementType(typeof(char[]));
+            charNestedCollectionElementType.TypeMapping = charNestedCollection.TypeMapping.ElementTypeMapping;
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
                 "CharToStringConverterProperty",
@@ -1413,6 +1422,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         decimal (decimal v) => v),
                     clrType: typeof(decimal),
                     jsonValueReaderWriter: JsonDecimalReaderWriter.Instance));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
+            decimalArrayElementType.TypeMapping = decimalArray.TypeMapping.ElementTypeMapping;
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DecimalNumberToBytesConverterProperty",
@@ -1614,6 +1625,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         double (double v) => v),
                     clrType: typeof(double),
                     jsonValueReaderWriter: JsonDoubleReaderWriter.Instance));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
+            doubleArrayElementType.TypeMapping = doubleArray.TypeMapping.ElementTypeMapping;
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DoubleNumberToBytesConverterProperty",
@@ -2707,6 +2720,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         float (float v) => v),
                     clrType: typeof(float),
                     jsonValueReaderWriter: JsonFloatReaderWriter.Instance));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
+            floatArrayElementType.TypeMapping = floatArray.TypeMapping.ElementTypeMapping;
 
             var guid = runtimeEntityType.AddProperty(
                 "Guid",
@@ -3103,6 +3118,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
+            int16ArrayElementType.TypeMapping = int16Array.TypeMapping.ElementTypeMapping;
 
             var int32 = runtimeEntityType.AddProperty(
                 "Int32",
@@ -3204,6 +3221,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     clrType: typeof(int),
                     jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
+            int32ArrayElementType.TypeMapping = int32Array.TypeMapping.ElementTypeMapping;
 
             var int32NestedCollection = runtimeEntityType.AddProperty(
                 "Int32NestedCollection",
@@ -3279,6 +3298,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                             int (int v) => v),
                         clrType: typeof(int),
                         jsonValueReaderWriter: JsonInt32ReaderWriter.Instance)));
+            var int32NestedCollectionElementType = int32NestedCollection.SetElementType(typeof(int[]));
+            int32NestedCollectionElementType.TypeMapping = int32NestedCollection.TypeMapping.ElementTypeMapping;
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
                 "Int32ReadOnlyCollection",
@@ -3337,6 +3358,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     clrType: typeof(int),
                     jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
+            int32ReadOnlyCollectionElementType.TypeMapping = int32ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var int64 = runtimeEntityType.AddProperty(
                 "Int64",
@@ -3438,6 +3461,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         long (long v) => v),
                     clrType: typeof(long),
                     jsonValueReaderWriter: JsonInt64ReaderWriter.Instance));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
+            int64ArrayElementType.TypeMapping = int64Array.TypeMapping.ElementTypeMapping;
 
             var int64NestedCollection = runtimeEntityType.AddProperty(
                 "Int64NestedCollection",
@@ -3531,6 +3556,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                                 long (long v) => v),
                             clrType: typeof(long),
                             jsonValueReaderWriter: JsonInt64ReaderWriter.Instance))));
+            var int64NestedCollectionElementType = int64NestedCollection.SetElementType(typeof(IList<long[]>));
+            int64NestedCollectionElementType.TypeMapping = int64NestedCollection.TypeMapping.ElementTypeMapping;
 
             var int8 = runtimeEntityType.AddProperty(
                 "Int8",
@@ -3632,6 +3659,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         sbyte (sbyte v) => v),
                     clrType: typeof(sbyte),
                     jsonValueReaderWriter: JsonSByteReaderWriter.Instance));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
+            int8ArrayElementType.TypeMapping = int8Array.TypeMapping.ElementTypeMapping;
 
             var int8NestedCollection = runtimeEntityType.AddProperty(
                 "Int8NestedCollection",
@@ -3725,6 +3754,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                                 sbyte (sbyte v) => v),
                             clrType: typeof(sbyte),
                             jsonValueReaderWriter: JsonSByteReaderWriter.Instance))));
+            var int8NestedCollectionElementType = int8NestedCollection.SetElementType(typeof(sbyte[][]));
+            int8NestedCollectionElementType.TypeMapping = int8NestedCollection.TypeMapping.ElementTypeMapping;
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IntNumberToBytesConverterProperty",
@@ -3980,6 +4011,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     clrType: typeof(bool),
                     jsonValueReaderWriter: JsonBoolReaderWriter.Instance));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
+            nullableBoolArrayElementType.TypeMapping = nullableBoolArray.TypeMapping.ElementTypeMapping;
+            nullableBoolArrayElementType.SetComparer(new NullableValueComparer<bool>(nullableBoolArrayElementType.TypeMapping.Comparer));
 
             var nullableBytes = runtimeEntityType.AddProperty(
                 "NullableBytes",
@@ -4132,6 +4167,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         char (char v) => v),
                     clrType: typeof(char),
                     jsonValueReaderWriter: JsonCharReaderWriter.Instance));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
+            nullableCharArrayElementType.TypeMapping = nullableCharArray.TypeMapping.ElementTypeMapping;
+            nullableCharArrayElementType.SetComparer(new NullableValueComparer<char>(nullableCharArrayElementType.TypeMapping.Comparer));
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
                 "NullableDateOnly",
@@ -4325,6 +4364,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         decimal (decimal v) => v),
                     clrType: typeof(decimal),
                     jsonValueReaderWriter: JsonDecimalReaderWriter.Instance));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
+            nullableDecimalArrayElementType.TypeMapping = nullableDecimalArray.TypeMapping.ElementTypeMapping;
+            nullableDecimalArrayElementType.SetComparer(new NullableValueComparer<decimal>(nullableDecimalArrayElementType.TypeMapping.Comparer));
 
             var nullableDouble = runtimeEntityType.AddProperty(
                 "NullableDouble",
@@ -4428,6 +4471,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         double (double v) => v),
                     clrType: typeof(double),
                     jsonValueReaderWriter: JsonDoubleReaderWriter.Instance));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
+            nullableDoubleArrayElementType.TypeMapping = nullableDoubleArray.TypeMapping.ElementTypeMapping;
+            nullableDoubleArrayElementType.SetComparer(new NullableValueComparer<double>(nullableDoubleArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
                 "NullableEnum16",
@@ -5347,6 +5394,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         float (float v) => v),
                     clrType: typeof(float),
                     jsonValueReaderWriter: JsonFloatReaderWriter.Instance));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
+            nullableFloatArrayElementType.TypeMapping = nullableFloatArray.TypeMapping.ElementTypeMapping;
+            nullableFloatArrayElementType.SetComparer(new NullableValueComparer<float>(nullableFloatArrayElementType.TypeMapping.Comparer));
 
             var nullableGuid = runtimeEntityType.AddProperty(
                 "NullableGuid",
@@ -5550,6 +5601,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
+            nullableInt16ArrayElementType.TypeMapping = nullableInt16Array.TypeMapping.ElementTypeMapping;
+            nullableInt16ArrayElementType.SetComparer(new NullableValueComparer<short>(nullableInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt32 = runtimeEntityType.AddProperty(
                 "NullableInt32",
@@ -5653,6 +5708,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     clrType: typeof(int),
                     jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
+            nullableInt32ArrayElementType.TypeMapping = nullableInt32Array.TypeMapping.ElementTypeMapping;
+            nullableInt32ArrayElementType.SetComparer(new NullableValueComparer<int>(nullableInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt32NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt32NestedCollection",
@@ -5728,6 +5787,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                             int (int v) => v),
                         clrType: typeof(int),
                         jsonValueReaderWriter: JsonInt32ReaderWriter.Instance)));
+            var nullableInt32NestedCollectionElementType = nullableInt32NestedCollection.SetElementType(typeof(int?[]));
+            nullableInt32NestedCollectionElementType.TypeMapping = nullableInt32NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableInt64 = runtimeEntityType.AddProperty(
                 "NullableInt64",
@@ -5831,6 +5892,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         long (long v) => v),
                     clrType: typeof(long),
                     jsonValueReaderWriter: JsonInt64ReaderWriter.Instance));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
+            nullableInt64ArrayElementType.TypeMapping = nullableInt64Array.TypeMapping.ElementTypeMapping;
+            nullableInt64ArrayElementType.SetComparer(new NullableValueComparer<long>(nullableInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt64NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt64NestedCollection",
@@ -5924,6 +5989,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                                 long (long v) => v),
                             clrType: typeof(long),
                             jsonValueReaderWriter: JsonInt64ReaderWriter.Instance))));
+            var nullableInt64NestedCollectionElementType = nullableInt64NestedCollection.SetElementType(typeof(long?[][]));
+            nullableInt64NestedCollectionElementType.TypeMapping = nullableInt64NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableInt8 = runtimeEntityType.AddProperty(
                 "NullableInt8",
@@ -6027,6 +6094,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         sbyte (sbyte v) => v),
                     clrType: typeof(sbyte),
                     jsonValueReaderWriter: JsonSByteReaderWriter.Instance));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
+            nullableInt8ArrayElementType.TypeMapping = nullableInt8Array.TypeMapping.ElementTypeMapping;
+            nullableInt8ArrayElementType.SetComparer(new NullableValueComparer<sbyte>(nullableInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddress",
@@ -6177,6 +6248,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
+            nullableStringArrayElementType.TypeMapping = nullableStringArray.TypeMapping.ElementTypeMapping;
 
             var nullableStringNestedCollection = runtimeEntityType.AddProperty(
                 "NullableStringNestedCollection",
@@ -6252,6 +6326,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                             string (string v) => v),
                         clrType: typeof(string),
                         jsonValueReaderWriter: JsonStringReaderWriter.Instance)));
+            var nullableStringNestedCollectionElementType = nullableStringNestedCollection.SetElementType(typeof(string[]));
+            nullableStringNestedCollectionElementType.TypeMapping = nullableStringNestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
                 "NullableTimeOnly",
@@ -6445,6 +6521,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ushort (ushort v) => v),
                     clrType: typeof(ushort),
                     jsonValueReaderWriter: JsonUInt16ReaderWriter.Instance));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
+            nullableUInt16ArrayElementType.TypeMapping = nullableUInt16Array.TypeMapping.ElementTypeMapping;
+            nullableUInt16ArrayElementType.SetComparer(new NullableValueComparer<ushort>(nullableUInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
                 "NullableUInt32",
@@ -6548,6 +6628,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         uint (uint v) => v),
                     clrType: typeof(uint),
                     jsonValueReaderWriter: JsonUInt32ReaderWriter.Instance));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
+            nullableUInt32ArrayElementType.TypeMapping = nullableUInt32Array.TypeMapping.ElementTypeMapping;
+            nullableUInt32ArrayElementType.SetComparer(new NullableValueComparer<uint>(nullableUInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
                 "NullableUInt64",
@@ -6651,6 +6735,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ulong (ulong v) => v),
                     clrType: typeof(ulong),
                     jsonValueReaderWriter: JsonUInt64ReaderWriter.Instance));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
+            nullableUInt64ArrayElementType.TypeMapping = nullableUInt64Array.TypeMapping.ElementTypeMapping;
+            nullableUInt64ArrayElementType.SetComparer(new NullableValueComparer<ulong>(nullableUInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
                 "NullableUInt8",
@@ -6754,6 +6842,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
+            nullableUInt8ArrayElementType.TypeMapping = nullableUInt8Array.TypeMapping.ElementTypeMapping;
+            nullableUInt8ArrayElementType.SetComparer(new NullableValueComparer<byte>(nullableUInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullableUri = runtimeEntityType.AddProperty(
                 "NullableUri",
@@ -7049,6 +7141,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
+            stringArrayElementType.TypeMapping = stringArray.TypeMapping.ElementTypeMapping;
 
             var stringNestedCollection = runtimeEntityType.AddProperty(
                 "StringNestedCollection",
@@ -7124,6 +7218,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                             string (string v) => v),
                         clrType: typeof(string),
                         jsonValueReaderWriter: JsonStringReaderWriter.Instance)));
+            var stringNestedCollectionElementType = stringNestedCollection.SetElementType(typeof(string[]));
+            stringNestedCollectionElementType.TypeMapping = stringNestedCollection.TypeMapping.ElementTypeMapping;
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
                 "StringReadOnlyCollection",
@@ -7182,6 +7278,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
+            stringReadOnlyCollectionElementType.TypeMapping = stringReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBoolConverterProperty",
@@ -8248,6 +8346,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ushort (ushort v) => v),
                     clrType: typeof(ushort),
                     jsonValueReaderWriter: JsonUInt16ReaderWriter.Instance));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
+            uInt16ArrayElementType.TypeMapping = uInt16Array.TypeMapping.ElementTypeMapping;
 
             var uInt32 = runtimeEntityType.AddProperty(
                 "UInt32",
@@ -8349,6 +8449,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         uint (uint v) => v),
                     clrType: typeof(uint),
                     jsonValueReaderWriter: JsonUInt32ReaderWriter.Instance));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
+            uInt32ArrayElementType.TypeMapping = uInt32Array.TypeMapping.ElementTypeMapping;
 
             var uInt64 = runtimeEntityType.AddProperty(
                 "UInt64",
@@ -8450,6 +8552,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ulong (ulong v) => v),
                     clrType: typeof(ulong),
                     jsonValueReaderWriter: JsonUInt64ReaderWriter.Instance));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
+            uInt64ArrayElementType.TypeMapping = uInt64Array.TypeMapping.ElementTypeMapping;
 
             var uInt8 = runtimeEntityType.AddProperty(
                 "UInt8",
@@ -8599,6 +8703,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
+            uInt8ReadOnlyCollectionElementType.TypeMapping = uInt8ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var uri = runtimeEntityType.AddProperty(
                 "Uri",
@@ -8739,7 +8845,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 beforeSaveBehavior: PropertySaveBehavior.Ignore,
                 afterSaveBehavior: PropertySaveBehavior.Ignore);
             __jObject.SetAccessors(
-                JObject (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(169) ? entry.ReadStoreGeneratedValue<JObject>(1) : (entry.FlaggedAsTemporary(169) && entry.ReadShadowValue<JObject>(2) == null ? entry.ReadTemporaryValue<JObject>(1) : entry.ReadShadowValue<JObject>(2))),
+                JObject (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(169) ? entry.ReadStoreGeneratedValue<JObject>(0) : (entry.FlaggedAsTemporary(169) && entry.ReadShadowValue<JObject>(2) == null ? entry.ReadTemporaryValue<JObject>(0) : entry.ReadShadowValue<JObject>(2))),
                 JObject (InternalEntityEntry entry) => entry.ReadShadowValue<JObject>(2),
                 JObject (InternalEntityEntry entry) => entry.ReadOriginalValue<JObject>(__jObject, 169),
                 JObject (InternalEntityEntry entry) => entry.GetCurrentValue<JObject>(__jObject),
@@ -8749,7 +8855,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 originalValueIndex: 169,
                 shadowIndex: 2,
                 relationshipIndex: -1,
-                storeGenerationIndex: 1);
+                storeGenerationIndex: 0);
             __jObject.TypeMapping = CosmosTypeMapping.Default.Clone(
                 comparer: new ValueComparer<JObject>(
                     bool (JObject v1, JObject v2) => object.Equals(v1, v2),
@@ -8965,9 +9071,9 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
                     return ((ISnapshot)(new MultiSnapshot(new ISnapshot[] { liftedArg, liftedArg0, liftedArg1, liftedArg2, liftedArg3, ((ISnapshot)(new Snapshot<string, TimeOnly, TimeOnly, TimeOnly, TimeSpan, TimeSpan, TimeSpan, ushort, ushort[], uint, uint[], ulong, ulong[], byte, byte[], IReadOnlyCollection<byte>, Uri, Uri, string, JObject>((source.GetCurrentValue<string>(stringToUriConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToUriConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToUriConverterProperty))), ((ValueComparer<TimeOnly>)(((IProperty)timeOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnly)), ((ValueComparer<TimeOnly>)(((IProperty)timeOnlyToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnlyToStringConverterProperty)), ((ValueComparer<TimeOnly>)(((IProperty)timeOnlyToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnlyToTicksConverterProperty)), ((ValueComparer<TimeSpan>)(((IProperty)timeSpan).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpan)), ((ValueComparer<TimeSpan>)(((IProperty)timeSpanToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpanToStringConverterProperty)), ((ValueComparer<TimeSpan>)(((IProperty)timeSpanToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpanToTicksConverterProperty)), ((ValueComparer<ushort>)(((IProperty)uInt16).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(uInt16)), (((IEnumerable<ushort>)(source.GetCurrentValue<ushort[]>(uInt16Array))) == null ? null : ((ushort[])(((ValueComparer<IEnumerable<ushort>>)(((IProperty)uInt16Array).GetValueComparer())).Snapshot(((IEnumerable<ushort>)(source.GetCurrentValue<ushort[]>(uInt16Array))))))), ((ValueComparer<uint>)(((IProperty)uInt32).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(uInt32)), (((IEnumerable<uint>)(source.GetCurrentValue<uint[]>(uInt32Array))) == null ? null : ((uint[])(((ValueComparer<IEnumerable<uint>>)(((IProperty)uInt32Array).GetValueComparer())).Snapshot(((IEnumerable<uint>)(source.GetCurrentValue<uint[]>(uInt32Array))))))), ((ValueComparer<ulong>)(((IProperty)uInt64).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong>(uInt64)), (((IEnumerable<ulong>)(source.GetCurrentValue<ulong[]>(uInt64Array))) == null ? null : ((ulong[])(((ValueComparer<IEnumerable<ulong>>)(((IProperty)uInt64Array).GetValueComparer())).Snapshot(((IEnumerable<ulong>)(source.GetCurrentValue<ulong[]>(uInt64Array))))))), ((ValueComparer<byte>)(((IProperty)uInt8).GetValueComparer())).Snapshot(source.GetCurrentValue<byte>(uInt8)), (source.GetCurrentValue<byte[]>(uInt8Array) == null ? null : ((ValueComparer<byte[]>)(((IProperty)uInt8Array).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(uInt8Array))), (((IEnumerable<byte>)(source.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<byte>)(((ValueComparer<IEnumerable<byte>>)(((IProperty)uInt8ReadOnlyCollection).GetValueComparer())).Snapshot(((IEnumerable<byte>)(source.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection))))))), (source.GetCurrentValue<Uri>(uri) == null ? null : ((ValueComparer<Uri>)(((IProperty)uri).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(uri))), (source.GetCurrentValue<Uri>(uriToStringConverterProperty) == null ? null : ((ValueComparer<Uri>)(((IProperty)uriToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(uriToStringConverterProperty))), (source.GetCurrentValue<string>(__id) == null ? null : ((ValueComparer<string>)(((IProperty)__id).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(__id))), (source.GetCurrentValue<JObject>(__jObject) == null ? null : ((ValueComparer<JObject>)(((IProperty)__jObject).GetValueComparer())).Snapshot(source.GetCurrentValue<JObject>(__jObject)))))) })));
                 });
             runtimeEntityType.SetStoreGeneratedValuesFactory(
-                ISnapshot () => ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId, JObject>(((ValueComparer<CompiledModelTestBase.ManyTypesId>)(((IProperty)id).GetValueComparer())).Snapshot(default(CompiledModelTestBase.ManyTypesId)), (default(JObject) == null ? null : ((ValueComparer<JObject>)(((IProperty)__jObject).GetValueComparer())).Snapshot(default(JObject)))))));
+                ISnapshot () => ((ISnapshot)(new Snapshot<JObject>((default(JObject) == null ? null : ((ValueComparer<JObject>)(((IProperty)__jObject).GetValueComparer())).Snapshot(default(JObject)))))));
             runtimeEntityType.SetTemporaryValuesFactory(
-                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId, JObject>(default(CompiledModelTestBase.ManyTypesId), default(JObject)))));
+                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<JObject>(default(JObject)))));
             runtimeEntityType.SetShadowValuesFactory(
                 ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<string, string, JObject>((source.ContainsKey("$type") ? ((string)(source["$type"])) : null), (source.ContainsKey("__id") ? ((string)(source["__id"])) : null), (source.ContainsKey("__jObject") ? ((JObject)(source["__jObject"])) : null)))));
             runtimeEntityType.SetEmptyShadowValuesFactory(
@@ -8985,7 +9091,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
                 originalValueCount: 170,
                 shadowCount: 3,
                 relationshipCount: 1,
-                storeGeneratedCount: 2);
+                storeGeneratedCount: 1);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
index bbb9a7fee8..32042329ca 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
@@ -291,6 +291,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -350,6 +352,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -409,6 +413,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         DateTime (DateTime v) => v),
                     clrType: typeof(DateTime),
                     jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -468,6 +474,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -527,6 +535,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -586,6 +596,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var __jObject = runtimeEntityType.AddProperty(
                 "__jObject",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
index 163d430ba7..21b7f3843a 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
@@ -261,6 +261,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -321,6 +323,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -381,6 +385,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         DateTime (DateTime v) => v),
                     clrType: typeof(DateTime),
                     jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -441,6 +447,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -501,6 +509,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -561,6 +571,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var __jObject = runtimeEntityType.AddProperty(
                 "__jObject",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
index 5ffd77d0bb..34fd7e9a64 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
@@ -425,6 +425,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -484,6 +486,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -543,6 +547,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         DateTime (DateTime v) => v),
                     clrType: typeof(DateTime),
                     jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -602,6 +608,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -661,6 +669,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -720,6 +730,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var __id = runtimeEntityType.AddProperty(
                 "__id",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
index 2313b2c570..a623bbfedd 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
@@ -412,6 +412,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -471,6 +473,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -530,6 +534,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         DateTime (DateTime v) => v),
                     clrType: typeof(DateTime),
                     jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -589,6 +595,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -648,6 +656,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -707,6 +717,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var __id = runtimeEntityType.AddProperty(
                 "__id",
@@ -994,6 +1006,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             string (string v) => v),
                         clrType: typeof(string),
                         jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+                refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                 var refTypeIList = complexType.AddProperty(
                     "RefTypeIList",
@@ -1061,6 +1075,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             string (string v) => v),
                         clrType: typeof(string),
                         jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+                refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
                 var valueTypeArray = complexType.AddProperty(
                     "ValueTypeArray",
@@ -1128,6 +1144,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             DateTime (DateTime v) => v),
                         clrType: typeof(DateTime),
                         jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+                var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+                valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
                 var valueTypeEnumerable = complexType.AddProperty(
                     "ValueTypeEnumerable",
@@ -1195,6 +1213,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             byte (byte v) => v),
                         clrType: typeof(byte),
                         jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+                valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                 var valueTypeIList = complexType.AddProperty(
                     "ValueTypeIList",
@@ -1262,6 +1282,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             byte (byte v) => v),
                         clrType: typeof(byte),
                         jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+                valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
                 var valueTypeList = complexType.AddProperty(
                     "ValueTypeList",
@@ -1329,6 +1351,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             short (short v) => v),
                         clrType: typeof(short),
                         jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+                var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+                valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
                 PrincipalComplexProperty.Create(complexType);
                 complexType.AddAnnotation("go", "brr");
@@ -1797,6 +1821,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 string (string v) => v),
                             clrType: typeof(string),
                             jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                    var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+                    refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                     var refTypeIList = complexType.AddProperty(
                         "RefTypeIList",
@@ -1866,6 +1892,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 string (string v) => v),
                             clrType: typeof(string),
                             jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                    var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+                    refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
                     var valueTypeArray = complexType.AddProperty(
                         "ValueTypeArray",
@@ -1935,6 +1963,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 DateTime (DateTime v) => v),
                             clrType: typeof(DateTime),
                             jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+                    var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+                    valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
                     var valueTypeEnumerable = complexType.AddProperty(
                         "ValueTypeEnumerable",
@@ -2004,6 +2034,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 byte (byte v) => v),
                             clrType: typeof(byte),
                             jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                    var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+                    valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                     var valueTypeIList = complexType.AddProperty(
                         "ValueTypeIList",
@@ -2073,6 +2105,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 byte (byte v) => v),
                             clrType: typeof(byte),
                             jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                    var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+                    valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
                     var valueTypeList = complexType.AddProperty(
                         "ValueTypeList",
@@ -2142,6 +2176,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 short (short v) => v),
                             clrType: typeof(short),
                             jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+                    var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+                    valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
                     return complexProperty;
                 }
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
index f0619692a3..a2b24d7e35 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
@@ -40,7 +40,6 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.ManyTypesId),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
-                valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueConverter: new CompiledModelTestBase.ManyTypesIdConverter());
             id.SetSentinelFromProviderValue(0);
@@ -63,18 +62,21 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
 
             var boolNestedCollection = runtimeEntityType.AddProperty(
                 "BoolNestedCollection",
                 typeof(bool[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolNestedCollectionElementType = boolNestedCollection.SetElementType(typeof(bool[]));
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
                 "BoolReadOnlyCollection",
                 typeof(IReadOnlyCollection<bool>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_boolReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BoolToStringConverterProperty",
@@ -156,12 +158,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
 
             var charNestedCollection = runtimeEntityType.AddProperty(
                 "CharNestedCollection",
                 typeof(char[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var charNestedCollectionElementType = charNestedCollection.SetElementType(typeof(char[]));
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
                 "CharToStringConverterProperty",
@@ -252,6 +256,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DecimalNumberToBytesConverterProperty",
@@ -281,6 +286,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DoubleNumberToBytesConverterProperty",
@@ -446,6 +452,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
 
             var guid = runtimeEntityType.AddProperty(
                 "Guid",
@@ -502,6 +509,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
 
             var int32 = runtimeEntityType.AddProperty(
                 "Int32",
@@ -515,18 +523,21 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
 
             var int32NestedCollection = runtimeEntityType.AddProperty(
                 "Int32NestedCollection",
                 typeof(int[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32NestedCollectionElementType = int32NestedCollection.SetElementType(typeof(int[]));
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
                 "Int32ReadOnlyCollection",
                 typeof(IReadOnlyCollection<int>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_int32ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
 
             var int64 = runtimeEntityType.AddProperty(
                 "Int64",
@@ -540,12 +551,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
 
             var int64NestedCollection = runtimeEntityType.AddProperty(
                 "Int64NestedCollection",
                 typeof(IList<long[]>[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int64NestedCollectionElementType = int64NestedCollection.SetElementType(typeof(IList<long[]>));
 
             var int8 = runtimeEntityType.AddProperty(
                 "Int8",
@@ -559,12 +572,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
 
             var int8NestedCollection = runtimeEntityType.AddProperty(
                 "Int8NestedCollection",
                 typeof(sbyte[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int8NestedCollectionElementType = int8NestedCollection.SetElementType(typeof(sbyte[][]));
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IntNumberToBytesConverterProperty",
@@ -602,6 +617,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
 
             var nullableBytes = runtimeEntityType.AddProperty(
                 "NullableBytes",
@@ -622,6 +639,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
                 "NullableDateOnly",
@@ -649,6 +668,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
 
             var nullableDouble = runtimeEntityType.AddProperty(
                 "NullableDouble",
@@ -662,6 +683,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
                 "NullableEnum16",
@@ -787,6 +810,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
 
             var nullableGuid = runtimeEntityType.AddProperty(
                 "NullableGuid",
@@ -814,6 +839,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
 
             var nullableInt32 = runtimeEntityType.AddProperty(
                 "NullableInt32",
@@ -827,12 +854,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
 
             var nullableInt32NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt32NestedCollection",
                 typeof(int?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt32NestedCollectionElementType = nullableInt32NestedCollection.SetElementType(typeof(int?[]));
 
             var nullableInt64 = runtimeEntityType.AddProperty(
                 "NullableInt64",
@@ -846,12 +876,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
 
             var nullableInt64NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt64NestedCollection",
                 typeof(List<long?[][]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt64NestedCollectionElementType = nullableInt64NestedCollection.SetElementType(typeof(long?[][]));
 
             var nullableInt8 = runtimeEntityType.AddProperty(
                 "NullableInt8",
@@ -865,6 +898,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddress",
@@ -885,12 +920,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
 
             var nullableStringNestedCollection = runtimeEntityType.AddProperty(
                 "NullableStringNestedCollection",
                 typeof(string[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableStringNestedCollectionElementType = nullableStringNestedCollection.SetElementType(typeof(string[]));
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
                 "NullableTimeOnly",
@@ -918,6 +956,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
                 "NullableUInt32",
@@ -931,6 +971,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
                 "NullableUInt64",
@@ -944,6 +986,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
                 "NullableUInt8",
@@ -957,6 +1001,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
 
             var nullableUri = runtimeEntityType.AddProperty(
                 "NullableUri",
@@ -996,18 +1042,21 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
 
             var stringNestedCollection = runtimeEntityType.AddProperty(
                 "StringNestedCollection",
                 typeof(string[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringNestedCollectionElementType = stringNestedCollection.SetElementType(typeof(string[]));
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
                 "StringReadOnlyCollection",
                 typeof(IReadOnlyCollection<string>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_stringReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBoolConverterProperty",
@@ -1167,6 +1216,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
 
             var uInt32 = runtimeEntityType.AddProperty(
                 "UInt32",
@@ -1180,6 +1230,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
 
             var uInt64 = runtimeEntityType.AddProperty(
                 "UInt64",
@@ -1193,6 +1244,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
 
             var uInt8 = runtimeEntityType.AddProperty(
                 "UInt8",
@@ -1212,6 +1264,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IReadOnlyCollection<byte>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_uInt8ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
 
             var uri = runtimeEntityType.AddProperty(
                 "Uri",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
index b3f5ad457b..17909e832f 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
@@ -68,6 +68,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -75,6 +76,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -82,6 +84,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -89,6 +92,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -96,6 +100,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -103,6 +108,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var __jObject = runtimeEntityType.AddProperty(
                 "__jObject",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
index a06446aa7d..e73531546d 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
@@ -66,6 +66,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -74,6 +75,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -82,6 +84,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -90,6 +93,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -98,6 +102,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -106,6 +111,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var __jObject = runtimeEntityType.AddProperty(
                 "__jObject",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
index a685bcc3f8..1f721e9e20 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
@@ -90,6 +90,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -97,6 +98,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -104,6 +106,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -111,6 +114,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -118,6 +122,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -125,6 +130,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var __id = runtimeEntityType.AddProperty(
                 "__id",
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/CompiledModelCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/CompiledModelCosmosTest.cs
index e38f8fdeb8..77a0ebcbab 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/CompiledModelCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/CompiledModelCosmosTest.cs
@@ -3,6 +3,8 @@
 
 // ReSharper disable InconsistentNaming
 
+using System.Net;
+using System.Net.NetworkInformation;
 using System.Runtime.CompilerServices;
 using Microsoft.EntityFrameworkCore.Cosmos.ValueGeneration.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
@@ -119,7 +121,7 @@ public virtual Task Basic_cosmos_model()
                 Assert.Null(list.FieldInfo);
                 Assert.True(list.IsNullable);
                 Assert.False(list.IsConcurrencyToken);
-                Assert.False(list.IsPrimitiveCollection);
+                Assert.True(list.IsPrimitiveCollection);
                 Assert.Equal(ValueGenerated.Never, list.ValueGenerated);
                 Assert.Equal(PropertySaveBehavior.Save, list.GetAfterSaveBehavior());
                 Assert.Equal(PropertySaveBehavior.Save, list.GetBeforeSaveBehavior());
@@ -232,9 +234,11 @@ protected override void BuildBigModel(ModelBuilder modelBuilder, bool jsonColumn
                     });
             });
 
+
         modelBuilder.Entity<ManyTypes>(
             b =>
             {
+                b.Property(e => e.Id).HasConversion<ManyTypesIdConverter>().ValueGeneratedNever();
                 // Cosmos provider cannot map collections of elements with converters. See Issue #34026.
                 b.Ignore(e => e.GuidArray);
                 b.Ignore(e => e.DateTimeArray);
@@ -335,6 +339,303 @@ protected override void BuildBigModel(ModelBuilder modelBuilder, bool jsonColumn
             });
     }
 
+    protected override async Task UseBigModel(DbContext context, bool jsonColumns)
+    {
+        var principalDerived = new PrincipalDerived<DependentBase<byte?>>
+        {
+            AlternateId = new Guid(),
+            Dependent = new DependentDerived<byte?>(1, "one"),
+            Owned = new OwnedType(context)
+        };
+
+        var principalId = context.Model.FindEntityType(typeof(PrincipalBase))!.FindProperty(nameof(PrincipalBase.Id))!;
+        if (principalId.ValueGenerated == ValueGenerated.Never)
+        {
+            principalDerived.Id = 10;
+        }
+
+        context.Add(principalDerived);
+
+        var types = new ManyTypes()
+        {
+            Bool = true,
+            UInt8 = 1,
+            Int16 = 2,
+            Int32 = 3,
+            Int64 = 4,
+            UInt16 = 5,
+            UInt32 = 6,
+            UInt64 = 7,
+            Char = 'a',
+            Float = 8.0f,
+            Double = 9.0,
+            Decimal = 10.0m,
+            String = "11",
+            Guid = Guid.NewGuid(),
+            DateTime = new DateTime(2023, 10, 10, 10, 10, 10),
+            DateOnly = new DateOnly(2023, 10, 10),
+            TimeOnly = new TimeOnly(10, 10),
+            TimeSpan = new TimeSpan(1),
+            Bytes = [1, 2, 3],
+            Uri = new Uri("https://www.example.com"),
+            PhysicalAddress = PhysicalAddress.Parse("00-00-00-00-00-01"),
+            IPAddress = IPAddress.Parse("127.0.0.1"),
+
+            NullableBool = true,
+            NullableUInt8 = 1,
+            NullableInt16 = 2,
+            NullableInt32 = 3,
+            NullableInt64 = 4,
+            NullableUInt16 = 5,
+            NullableUInt32 = 6,
+            NullableUInt64 = 7,
+            NullableChar = 'a',
+            NullableFloat = 8.0f,
+            NullableDouble = 9.0,
+            NullableDecimal = 10.0m,
+            NullableString = "11",
+            NullableGuid = Guid.NewGuid(),
+            NullableDateTime = new DateTime(2023, 10, 10, 10, 10, 10),
+            NullableDateOnly = new DateOnly(2023, 10, 10),
+            NullableTimeOnly = new TimeOnly(10, 10),
+            NullableTimeSpan = new TimeSpan(1),
+            NullableBytes = [1, 2, 3],
+            NullableUri = new Uri("https://www.example.com"),
+
+            BoolArray = [true],
+            Int8Array = [1],
+            Int16Array = [2],
+            Int32Array = [3],
+            Int64Array = [4],
+            UInt8Array = [1],
+            UInt16Array = [5],
+            UInt32Array = [6],
+            UInt64Array = [7],
+            CharArray = ['a'],
+            FloatArray = [8.0f],
+            DoubleArray = [9.0],
+            DecimalArray = [10.0m],
+            StringArray = ["11"],
+            GuidArray = [Guid.NewGuid()],
+            DateTimeArray = [new DateTime(2023, 10, 10, 10, 10, 10)],
+            DateOnlyArray = [new DateOnly(2023, 10, 10)],
+            TimeOnlyArray = [new TimeOnly(10, 10)],
+            TimeSpanArray = [new TimeSpan(1)],
+            BytesArray = [[1, 2, 3]],
+            UriArray = [new Uri("https://www.example.com")],
+            IPAddressArray = [IPAddress.Parse("127.0.0.1")],
+            PhysicalAddressArray = [PhysicalAddress.Parse("00-00-00-00-00-01")],
+
+            NullableBoolArray = [true],
+            NullableInt8Array = [1],
+            NullableInt16Array = [2],
+            NullableInt32Array = [3],
+            NullableInt64Array = [4],
+            NullableUInt8Array = [1],
+            NullableUInt16Array = [5],
+            NullableUInt32Array = [6],
+            NullableUInt64Array = [7],
+            NullableCharArray = ['a'],
+            NullableFloatArray = [8.0f],
+            NullableDoubleArray = [9.0],
+            NullableDecimalArray = [10.0m],
+            NullableStringArray = ["11"],
+            NullableGuidArray = [Guid.NewGuid()],
+            NullableDateTimeArray = [new DateTime(2023, 10, 10, 10, 10, 10)],
+            NullableDateOnlyArray = [new DateOnly(2023, 10, 10)],
+            NullableTimeOnlyArray = [new TimeOnly(10, 10)],
+            NullableTimeSpanArray = [new TimeSpan(1)],
+            NullableBytesArray = [[1, 2, 3]],
+            NullableUriArray = [new Uri("https://www.example.com")],
+            NullableIPAddressArray = [IPAddress.Parse("127.0.0.1")],
+            NullablePhysicalAddressArray = [PhysicalAddress.Parse("00-00-00-00-00-01")],
+
+            BoolReadOnlyCollection = [true],
+            UInt8ReadOnlyCollection = [1],
+            Int32ReadOnlyCollection = [2],
+            StringReadOnlyCollection = ["3"],
+            IPAddressReadOnlyCollection = [IPAddress.Parse("127.0.0.1")],
+
+            Enum8 = Enum8.One,
+            Enum16 = Enum16.One,
+            Enum32 = Enum32.One,
+            Enum64 = Enum64.One,
+            EnumU8 = EnumU8.One,
+            EnumU16 = EnumU16.One,
+            EnumU32 = EnumU32.One,
+            EnumU64 = EnumU64.One,
+
+            Enum8AsString = Enum8.One,
+            Enum16AsString = Enum16.One,
+            Enum32AsString = Enum32.One,
+            Enum64AsString = Enum64.One,
+            EnumU8AsString = EnumU8.One,
+            EnumU16AsString = EnumU16.One,
+            EnumU32AsString = EnumU32.One,
+            EnumU64AsString = EnumU64.One,
+
+            Enum8Collection = [Enum8.One],
+            Enum16Collection = [Enum16.One],
+            Enum32Collection = [Enum32.One],
+            Enum64Collection = [Enum64.One],
+            EnumU8Collection = [EnumU8.One],
+            EnumU16Collection = [EnumU16.One],
+            EnumU32Collection = [EnumU32.One],
+            EnumU64Collection = [EnumU64.One],
+
+            Enum8AsStringCollection = [Enum8.One],
+            Enum16AsStringCollection = [Enum16.One],
+            Enum32AsStringCollection = [Enum32.One],
+            Enum64AsStringCollection = [Enum64.One],
+            EnumU8AsStringCollection = [EnumU8.One],
+            EnumU16AsStringCollection = [EnumU16.One],
+            EnumU32AsStringCollection = [EnumU32.One],
+            EnumU64AsStringCollection = [EnumU64.One],
+
+            NullableEnum8Collection = [Enum8.One],
+            NullableEnum16Collection = [Enum16.One],
+            NullableEnum32Collection = [Enum32.One],
+            NullableEnum64Collection = [Enum64.One],
+            NullableEnumU8Collection = [EnumU8.One],
+            NullableEnumU16Collection = [EnumU16.One],
+            NullableEnumU32Collection = [EnumU32.One],
+            NullableEnumU64Collection = [EnumU64.One],
+
+            NullableEnum8AsStringCollection = [Enum8.One],
+            NullableEnum16AsStringCollection = [Enum16.One],
+            NullableEnum32AsStringCollection = [Enum32.One],
+            NullableEnum64AsStringCollection = [Enum64.One],
+            NullableEnumU8AsStringCollection = [EnumU8.One],
+            NullableEnumU16AsStringCollection = [EnumU16.One],
+            NullableEnumU32AsStringCollection = [EnumU32.One],
+            NullableEnumU64AsStringCollection = [EnumU64.One],
+
+            Enum8Array = [Enum8.One],
+            Enum16Array = [Enum16.One],
+            Enum32Array = [Enum32.One],
+            Enum64Array = [Enum64.One],
+            EnumU8Array = [EnumU8.One],
+            EnumU16Array = [EnumU16.One],
+            EnumU32Array = [EnumU32.One],
+            EnumU64Array = [EnumU64.One],
+
+            Enum8AsStringArray = [Enum8.One],
+            Enum16AsStringArray = [Enum16.One],
+            Enum32AsStringArray = [Enum32.One],
+            Enum64AsStringArray = [Enum64.One],
+            EnumU8AsStringArray = [EnumU8.One],
+            EnumU16AsStringArray = [EnumU16.One],
+            EnumU32AsStringArray = [EnumU32.One],
+            EnumU64AsStringArray = [EnumU64.One],
+
+            NullableEnum8Array = [Enum8.One],
+            NullableEnum16Array = [Enum16.One],
+            NullableEnum32Array = [Enum32.One],
+            NullableEnum64Array = [Enum64.One],
+            NullableEnumU8Array = [EnumU8.One],
+            NullableEnumU16Array = [EnumU16.One],
+            NullableEnumU32Array = [EnumU32.One],
+            NullableEnumU64Array = [EnumU64.One],
+
+            NullableEnum8AsStringArray = [Enum8.One],
+            NullableEnum16AsStringArray = [Enum16.One],
+            NullableEnum32AsStringArray = [Enum32.One],
+            NullableEnum64AsStringArray = [Enum64.One],
+            NullableEnumU8AsStringArray = [EnumU8.One],
+            NullableEnumU16AsStringArray = [EnumU16.One],
+            NullableEnumU32AsStringArray = [EnumU32.One],
+            NullableEnumU64AsStringArray = [EnumU64.One],
+
+            BoolNestedCollection = [[true]],
+            UInt8NestedCollection = [[9]],
+            Int8NestedCollection = [[[9]]],
+            Int32NestedCollection = [[9]],
+            Int64NestedCollection = [[[9L]]],
+            CharNestedCollection = [['a']],
+            StringNestedCollection = [["11"]],
+            GuidNestedCollection = [[[Guid.NewGuid()]]],
+            BytesNestedCollection = [[[1, 2, 3]]],
+            NullableUInt8NestedCollection = [[9]],
+            NullableInt32NestedCollection = [[9]],
+            NullableInt64NestedCollection = [[[9L]]],
+            NullableStringNestedCollection = [["11"]],
+            NullableGuidNestedCollection = [[Guid.NewGuid()]],
+            NullableBytesNestedCollection = [[[1, 2, 3]]],
+            NullablePhysicalAddressNestedCollection = [[[PhysicalAddress.Parse("00-00-00-00-00-01")]]],
+
+            Enum8NestedCollection = [[Enum8.One]],
+            Enum32NestedCollection = [[[Enum32.One]]],
+            EnumU64NestedCollection = [[EnumU64.One]],
+            NullableEnum8NestedCollection = [[Enum8.One]],
+            NullableEnum32NestedCollection = [[[Enum32.One]]],
+            NullableEnumU64NestedCollection = [[EnumU64.One]],
+
+            BoolToStringConverterProperty = true,
+            BoolToTwoValuesConverterProperty = true,
+            BoolToZeroOneConverterProperty = true,
+            BytesToStringConverterProperty = [1, 2, 3],
+            CastingConverterProperty = 1,
+            CharToStringConverterProperty = 'a',
+            DateOnlyToStringConverterProperty = new DateOnly(2023, 10, 10),
+            DateTimeOffsetToBinaryConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.Zero),
+            DateTimeOffsetToBytesConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.Zero),
+            DateTimeOffsetToStringConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.Zero),
+            DateTimeToBinaryConverterProperty = new DateTime(2023, 10, 10, 10, 10, 10),
+            DateTimeToStringConverterProperty = new DateTime(2023, 10, 10, 10, 10, 10),
+            EnumToNumberConverterProperty = Enum32.One,
+            EnumToStringConverterProperty = Enum32.One,
+            GuidToBytesConverterProperty = Guid.NewGuid(),
+            GuidToStringConverterProperty = Guid.NewGuid(),
+            IPAddressToBytesConverterProperty = IPAddress.Parse("127.0.0.1"),
+            IPAddressToStringConverterProperty = IPAddress.Parse("127.0.0.1"),
+            IntNumberToBytesConverterProperty = 1,
+            DecimalNumberToBytesConverterProperty = 1.0m,
+            DoubleNumberToBytesConverterProperty = 1.0,
+            IntNumberToStringConverterProperty = 1,
+            DecimalNumberToStringConverterProperty = 1.0m,
+            DoubleNumberToStringConverterProperty = 1.0,
+            PhysicalAddressToBytesConverterProperty = PhysicalAddress.Parse("00-00-00-00-00-01"),
+            PhysicalAddressToStringConverterProperty = PhysicalAddress.Parse("00-00-00-00-00-01"),
+            StringToBoolConverterProperty = "true",
+            StringToBytesConverterProperty = "1",
+            StringToCharConverterProperty = "a",
+            StringToDateOnlyConverterProperty = new DateOnly(2023, 10, 10).ToString(@"yyyy\-MM\-dd"),
+            StringToDateTimeConverterProperty = new DateTime(2023, 10, 10, 10, 10, 10).ToString(@"yyyy\-MM\-dd HH\:mm\:ss.FFFFFFF"),
+            StringToDateTimeOffsetConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.FromHours(1))
+                .ToString(@"yyyy\-MM\-dd HH\:mm\:ss.FFFFFFFzzz"),
+            StringToEnumConverterProperty = "One",
+            StringToGuidConverterProperty = Guid.NewGuid().ToString(),
+            StringToIntNumberConverterProperty = "1",
+            StringToDecimalNumberConverterProperty = "1.0",
+            StringToDoubleNumberConverterProperty = "1.0",
+            StringToTimeOnlyConverterProperty = new TimeOnly(10, 10).ToString("o"),
+            StringToTimeSpanConverterProperty = new TimeSpan(1).ToString("c"),
+            StringToUriConverterProperty = "https://www.example.com/",
+            TimeOnlyToStringConverterProperty = new TimeOnly(10, 10),
+            TimeOnlyToTicksConverterProperty = new TimeOnly(10, 10),
+            TimeSpanToStringConverterProperty = new TimeSpan(1),
+            TimeSpanToTicksConverterProperty = new TimeSpan(1),
+            UriToStringConverterProperty = new Uri("https://www.example.com/"),
+            NullIntToNullStringConverterProperty = null
+        };
+
+        var manyTypesId = context.Model.FindEntityType(typeof(ManyTypes))!.FindProperty(nameof(ManyTypes.Id))!;
+        if (manyTypesId.ValueGenerated == ValueGenerated.Never)
+        {
+            types.Id = new ManyTypesId(17);
+        }
+
+        context.Add(types);
+
+        await context.SaveChangesAsync();
+
+        var principalDerivedFromStore = await context.Set<PrincipalDerived<DependentBase<byte?>>>().IgnoreAutoIncludes().SingleAsync();
+        Assert.Equal(principalDerived.AlternateId, principalDerivedFromStore.AlternateId);
+
+        var typesFromStore = await context.Set<ManyTypes>().OrderBy(m => m.Id).FirstAsync();
+        AssertEqual(types, typesFromStore, jsonColumns);
+    }
+
     protected override void BuildComplexTypesModel(ModelBuilder modelBuilder)
     {
         base.BuildComplexTypesModel(modelBuilder);
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
index dc8d863b40..87d40f2982 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
@@ -1,10 +1,17 @@
 // <auto-generated />
 using System;
+using System.Collections.Generic;
 using System.Reflection;
 using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
+using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding;
+using Microsoft.EntityFrameworkCore.Storage;
+using Microsoft.EntityFrameworkCore.Storage.Json;
 using Microsoft.EntityFrameworkCore.ValueGeneration;
 
 #pragma warning disable 219, 612, 618
@@ -34,12 +41,68 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalId.SetAccessors(
+                long (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : (entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0))),
+                long (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                long (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalId, 0),
+                long (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalId, 0),
+                object (ValueBuffer valueBuffer) => valueBuffer[0]);
+            principalId.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: 0,
+                shadowIndex: 0,
+                relationshipIndex: 0,
+                storeGenerationIndex: 0);
+            principalId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
+            principalId.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(principalId));
 
             var principalAlternateId = runtimeEntityType.AddProperty(
                 "PrincipalAlternateId",
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalAlternateId.SetAccessors(
+                Guid (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : (entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1))),
+                Guid (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalAlternateId, 1),
+                Guid (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalAlternateId, 1),
+                object (ValueBuffer valueBuffer) => valueBuffer[1]);
+            principalAlternateId.SetPropertyIndexes(
+                index: 1,
+                originalValueIndex: 1,
+                shadowIndex: 1,
+                relationshipIndex: 1,
+                storeGenerationIndex: 1);
+            principalAlternateId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            principalAlternateId.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(principalAlternateId));
 
             var enumDiscriminator = runtimeEntityType.AddProperty(
                 "EnumDiscriminator",
@@ -47,6 +110,33 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create,
                 sentinel: CompiledModelTestBase.Enum1.Default);
+            enumDiscriminator.SetAccessors(
+                CompiledModelTestBase.Enum1 (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                CompiledModelTestBase.Enum1 (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                CompiledModelTestBase.Enum1 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum1>(enumDiscriminator, 2),
+                CompiledModelTestBase.Enum1 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum1>(enumDiscriminator),
+                object (ValueBuffer valueBuffer) => valueBuffer[2]);
+            enumDiscriminator.SetPropertyIndexes(
+                index: 2,
+                originalValueIndex: 2,
+                shadowIndex: 2,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumDiscriminator.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum1>(
+                    bool (CompiledModelTestBase.Enum1 v1, CompiledModelTestBase.Enum1 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum1 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum1 (CompiledModelTestBase.Enum1 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum1>(
+                    bool (CompiledModelTestBase.Enum1 v1, CompiledModelTestBase.Enum1 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum1 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum1 (CompiledModelTestBase.Enum1 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum1>(
+                    bool (CompiledModelTestBase.Enum1 v1, CompiledModelTestBase.Enum1 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum1 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum1 (CompiledModelTestBase.Enum1 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum1),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum1>.Instance);
 
             var id = runtimeEntityType.AddProperty(
                 "Id",
@@ -54,6 +144,44 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetProperty("Id", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            id.SetGetter(
+                byte? (CompiledModelTestBase.DependentBase<byte?> entity) => DependentBaseUnsafeAccessors<byte?>.Id(entity),
+                bool (CompiledModelTestBase.DependentBase<byte?> entity) => !(DependentBaseUnsafeAccessors<byte?>.Id(entity).HasValue),
+                byte? (CompiledModelTestBase.DependentBase<byte?> instance) => DependentBaseUnsafeAccessors<byte?>.Id(instance),
+                bool (CompiledModelTestBase.DependentBase<byte?> instance) => !(DependentBaseUnsafeAccessors<byte?>.Id(instance).HasValue));
+            id.SetSetter(
+                (CompiledModelTestBase.DependentBase<byte?> entity, byte? value) => DependentBaseUnsafeAccessors<byte?>.Id(entity) = value);
+            id.SetMaterializationSetter(
+                (CompiledModelTestBase.DependentBase<byte?> entity, byte? value) => DependentBaseUnsafeAccessors<byte?>.Id(entity) = value);
+            id.SetAccessors(
+                byte? (InternalEntityEntry entry) => DependentBaseUnsafeAccessors<byte?>.Id(((CompiledModelTestBase.DependentBase<byte?>)(entry.Entity))),
+                byte? (InternalEntityEntry entry) => DependentBaseUnsafeAccessors<byte?>.Id(((CompiledModelTestBase.DependentBase<byte?>)(entry.Entity))),
+                byte? (InternalEntityEntry entry) => entry.ReadOriginalValue<byte?>(id, 3),
+                byte? (InternalEntityEntry entry) => entry.GetCurrentValue<byte?>(id),
+                object (ValueBuffer valueBuffer) => valueBuffer[3]);
+            id.SetPropertyIndexes(
+                index: 3,
+                originalValueIndex: 3,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                keyComparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                providerValueComparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                clrType: typeof(byte),
+                jsonValueReaderWriter: JsonByteReaderWriter.Instance);
+            id.SetComparer(new NullableValueComparer<byte>(id.TypeMapping.Comparer));
+            id.SetKeyComparer(new NullableValueComparer<byte>(id.TypeMapping.KeyComparer));
 
             var key = runtimeEntityType.AddKey(
                 new[] { principalId, principalAlternateId });
@@ -90,6 +218,27 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 propertyInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetProperty("Principal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
+            principal.SetGetter(
+                CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> (CompiledModelTestBase.DependentBase<byte?> entity) => DependentBaseUnsafeAccessors<byte?>.Principal(entity),
+                bool (CompiledModelTestBase.DependentBase<byte?> entity) => DependentBaseUnsafeAccessors<byte?>.Principal(entity) == null,
+                CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> (CompiledModelTestBase.DependentBase<byte?> instance) => DependentBaseUnsafeAccessors<byte?>.Principal(instance),
+                bool (CompiledModelTestBase.DependentBase<byte?> instance) => DependentBaseUnsafeAccessors<byte?>.Principal(instance) == null);
+            principal.SetSetter(
+                (CompiledModelTestBase.DependentBase<byte?> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> value) => DependentBaseUnsafeAccessors<byte?>.Principal(entity) = value);
+            principal.SetMaterializationSetter(
+                (CompiledModelTestBase.DependentBase<byte?> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> value) => DependentBaseUnsafeAccessors<byte?>.Principal(entity) = value);
+            principal.SetAccessors(
+                CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> (InternalEntityEntry entry) => DependentBaseUnsafeAccessors<byte?>.Principal(((CompiledModelTestBase.DependentBase<byte?>)(entry.Entity))),
+                CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> (InternalEntityEntry entry) => DependentBaseUnsafeAccessors<byte?>.Principal(((CompiledModelTestBase.DependentBase<byte?>)(entry.Entity))),
+                null,
+                CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>>(principal),
+                null);
+            principal.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: 2,
+                storeGenerationIndex: -1);
             var dependent = principalEntityType.AddNavigation("Dependent",
                 runtimeForeignKey,
                 onDependent: false,
@@ -99,11 +248,68 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 eagerLoaded: true,
                 lazyLoadingEnabled: false);
 
+            dependent.SetGetter(
+                CompiledModelTestBase.DependentBase<byte?> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(entity),
+                bool (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(entity) == null,
+                CompiledModelTestBase.DependentBase<byte?> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> instance) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(instance),
+                bool (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> instance) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(instance) == null);
+            dependent.SetSetter(
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, CompiledModelTestBase.DependentBase<byte?> value) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(entity) = value);
+            dependent.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, CompiledModelTestBase.DependentBase<byte?> value) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(entity) = value);
+            dependent.SetAccessors(
+                CompiledModelTestBase.DependentBase<byte?> (InternalEntityEntry entry) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(entry.Entity))),
+                CompiledModelTestBase.DependentBase<byte?> (InternalEntityEntry entry) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(entry.Entity))),
+                null,
+                CompiledModelTestBase.DependentBase<byte?> (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.DependentBase<byte?>>(dependent),
+                null);
+            dependent.SetPropertyIndexes(
+                index: 2,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: 4,
+                storeGenerationIndex: -1);
             return runtimeForeignKey;
         }
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var principalId = runtimeEntityType.FindProperty("PrincipalId");
+            var principalAlternateId = runtimeEntityType.FindProperty("PrincipalAlternateId");
+            var enumDiscriminator = runtimeEntityType.FindProperty("EnumDiscriminator");
+            var id = runtimeEntityType.FindProperty("Id");
+            var key = runtimeEntityType.FindKey(new[] { principalId, principalAlternateId });
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
+            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
+            var principal = runtimeEntityType.FindNavigation("Principal");
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity = ((CompiledModelTestBase.DependentBase<byte?>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, CompiledModelTestBase.Enum1, byte?>(((ValueComparer<long>)(((IProperty)principalId).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(principalId)), ((ValueComparer<Guid>)(((IProperty)principalAlternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalAlternateId)), ((ValueComparer<CompiledModelTestBase.Enum1>)(((IProperty)enumDiscriminator).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum1>(enumDiscriminator)), (source.GetCurrentValue<byte?>(id) == null ? null : ((ValueComparer<byte?>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<byte?>(id))))));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid>(((ValueComparer<long>)(((IProperty)principalId).GetValueComparer())).Snapshot(default(long)), ((ValueComparer<Guid>)(((IProperty)principalAlternateId).GetValueComparer())).Snapshot(default(Guid))))));
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<long, Guid>(default(long), default(Guid)))));
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<long, Guid, CompiledModelTestBase.Enum1>((source.ContainsKey("PrincipalId") ? ((long)(source["PrincipalId"])) : 0L), (source.ContainsKey("PrincipalAlternateId") ? ((Guid)(source["PrincipalAlternateId"])) : new Guid("00000000-0000-0000-0000-000000000000")), (source.ContainsKey("EnumDiscriminator") ? ((CompiledModelTestBase.Enum1)(source["EnumDiscriminator"])) : CompiledModelTestBase.Enum1.Default)))));
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid, CompiledModelTestBase.Enum1>(default(long), default(Guid), default(CompiledModelTestBase.Enum1)))));
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity = ((CompiledModelTestBase.DependentBase<byte?>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, object>(((ValueComparer<long>)(((IProperty)principalId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(principalId)), ((ValueComparer<Guid>)(((IProperty)principalAlternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalAlternateId)), DependentBaseUnsafeAccessors<byte?>.Principal(entity))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 4,
+                navigationCount: 1,
+                complexPropertyCount: 0,
+                originalValueCount: 4,
+                shadowCount: 3,
+                relationshipCount: 3,
+                storeGeneratedCount: 2);
             runtimeEntityType.AddAnnotation("DiscriminatorMappingComplete", false);
 
             Customize(runtimeEntityType);
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseUnsafeAccessors.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseUnsafeAccessors.cs
new file mode 100644
index 0000000000..d7a27e947b
--- /dev/null
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseUnsafeAccessors.cs
@@ -0,0 +1,18 @@
+// <auto-generated />
+using System.Runtime.CompilerServices;
+using Microsoft.EntityFrameworkCore.Scaffolding;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    public static class DependentBaseUnsafeAccessors<TKey>
+    {
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
+        public static extern ref TKey Id(CompiledModelTestBase.DependentBase<TKey> @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principal>k__BackingField")]
+        public static extern ref CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<TKey>> Principal(CompiledModelTestBase.DependentBase<TKey> @this);
+    }
+}
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
index 74ff4f82ea..e2335e47aa 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
@@ -1,9 +1,16 @@
 // <auto-generated />
 using System;
+using System.Collections.Generic;
 using System.Reflection;
+using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
+using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding;
+using Microsoft.EntityFrameworkCore.Storage;
+using Microsoft.EntityFrameworkCore.Storage.Json;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -31,6 +38,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 nullable: true,
                 maxLength: 20,
                 unicode: false);
+            data.SetGetter(
+                string (CompiledModelTestBase.DependentDerived<byte?> entity) => DependentDerivedUnsafeAccessors<byte?>.Data(entity),
+                bool (CompiledModelTestBase.DependentDerived<byte?> entity) => DependentDerivedUnsafeAccessors<byte?>.Data(entity) == null,
+                string (CompiledModelTestBase.DependentDerived<byte?> instance) => DependentDerivedUnsafeAccessors<byte?>.Data(instance),
+                bool (CompiledModelTestBase.DependentDerived<byte?> instance) => DependentDerivedUnsafeAccessors<byte?>.Data(instance) == null);
+            data.SetSetter(
+                (CompiledModelTestBase.DependentDerived<byte?> entity, string value) => DependentDerivedUnsafeAccessors<byte?>.Data(entity) = value);
+            data.SetMaterializationSetter(
+                (CompiledModelTestBase.DependentDerived<byte?> entity, string value) => DependentDerivedUnsafeAccessors<byte?>.Data(entity) = value);
+            data.SetAccessors(
+                string (InternalEntityEntry entry) => DependentDerivedUnsafeAccessors<byte?>.Data(((CompiledModelTestBase.DependentDerived<byte?>)(entry.Entity))),
+                string (InternalEntityEntry entry) => DependentDerivedUnsafeAccessors<byte?>.Data(((CompiledModelTestBase.DependentDerived<byte?>)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(data, 4),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(data),
+                object (ValueBuffer valueBuffer) => valueBuffer[4]);
+            data.SetPropertyIndexes(
+                index: 4,
+                originalValueIndex: 4,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            data.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                clrType: typeof(string),
+                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
 
             var money = runtimeEntityType.AddProperty(
                 "Money",
@@ -38,12 +81,74 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 precision: 9,
                 scale: 3,
                 sentinel: 0m);
+            money.SetAccessors(
+                decimal (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                decimal (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                decimal (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(money, 5),
+                decimal (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(money),
+                object (ValueBuffer valueBuffer) => valueBuffer[5]);
+            money.SetPropertyIndexes(
+                index: 5,
+                originalValueIndex: 5,
+                shadowIndex: 3,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            money.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                keyComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                providerValueComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                clrType: typeof(decimal),
+                jsonValueReaderWriter: JsonDecimalReaderWriter.Instance);
 
             return runtimeEntityType;
         }
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var principalId = runtimeEntityType.FindProperty("PrincipalId");
+            var principalAlternateId = runtimeEntityType.FindProperty("PrincipalAlternateId");
+            var enumDiscriminator = runtimeEntityType.FindProperty("EnumDiscriminator");
+            var id = runtimeEntityType.FindProperty("Id");
+            var data = runtimeEntityType.FindProperty("Data");
+            var money = runtimeEntityType.FindProperty("Money");
+            var principal = runtimeEntityType.FindNavigation("Principal");
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.DependentDerived<byte?>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, CompiledModelTestBase.Enum1, byte?, string, decimal>(((ValueComparer<long>)(((IProperty)principalId).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(principalId)), ((ValueComparer<Guid>)(((IProperty)principalAlternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalAlternateId)), ((ValueComparer<CompiledModelTestBase.Enum1>)(((IProperty)enumDiscriminator).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum1>(enumDiscriminator)), (source.GetCurrentValue<byte?>(id) == null ? null : ((ValueComparer<byte?>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<byte?>(id))), (source.GetCurrentValue<string>(data) == null ? null : ((ValueComparer<string>)(((IProperty)data).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(data))), ((ValueComparer<decimal>)(((IProperty)money).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal>(money)))));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid>(((ValueComparer<long>)(((IProperty)principalId).GetValueComparer())).Snapshot(default(long)), ((ValueComparer<Guid>)(((IProperty)principalAlternateId).GetValueComparer())).Snapshot(default(Guid))))));
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<long, Guid>(default(long), default(Guid)))));
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<long, Guid, CompiledModelTestBase.Enum1, decimal>((source.ContainsKey("PrincipalId") ? ((long)(source["PrincipalId"])) : 0L), (source.ContainsKey("PrincipalAlternateId") ? ((Guid)(source["PrincipalAlternateId"])) : new Guid("00000000-0000-0000-0000-000000000000")), (source.ContainsKey("EnumDiscriminator") ? ((CompiledModelTestBase.Enum1)(source["EnumDiscriminator"])) : CompiledModelTestBase.Enum1.Default), (source.ContainsKey("Money") ? ((decimal)(source["Money"])) : 0M)))));
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid, CompiledModelTestBase.Enum1, decimal>(default(long), default(Guid), default(CompiledModelTestBase.Enum1), default(decimal)))));
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.DependentDerived<byte?>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, object>(((ValueComparer<long>)(((IProperty)principalId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(principalId)), ((ValueComparer<Guid>)(((IProperty)principalAlternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalAlternateId)), DependentBaseUnsafeAccessors<byte?>.Principal(entity8))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 6,
+                navigationCount: 1,
+                complexPropertyCount: 0,
+                originalValueCount: 6,
+                shadowCount: 4,
+                relationshipCount: 3,
+                storeGeneratedCount: 2);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedUnsafeAccessors.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedUnsafeAccessors.cs
new file mode 100644
index 0000000000..8847446bfe
--- /dev/null
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedUnsafeAccessors.cs
@@ -0,0 +1,16 @@
+// <auto-generated />
+using System;
+using System.Runtime.CompilerServices;
+using Microsoft.EntityFrameworkCore.Scaffolding;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    public static class DependentDerivedUnsafeAccessors<TKey>
+    {
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Data>k__BackingField")]
+        public static extern ref string Data(CompiledModelTestBase.DependentDerived<TKey> @this);
+    }
+}
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
index 1af80a9af8..3bc539bb25 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
@@ -1,17 +1,24 @@
 // <auto-generated />
 using System;
+using System.Collections;
 using System.Collections.Generic;
+using System.Globalization;
+using System.Linq;
 using System.Net;
 using System.Net.NetworkInformation;
 using System.Reflection;
 using System.Text;
 using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding;
+using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Storage.Json;
 using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
+using Microsoft.EntityFrameworkCore.Storage.ValueConversion.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -27,7 +34,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
                 typeof(CompiledModelTestBase.ManyTypes),
                 baseEntityType,
-                propertyCount: 258,
+                propertyCount: 263,
                 keyCount: 1);
 
             var id = runtimeEntityType.AddProperty(
@@ -38,6 +45,49 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueConverter: new CompiledModelTestBase.ManyTypesIdConverter());
+            id.SetGetter(
+                CompiledModelTestBase.ManyTypesId (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Id(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Id(entity).Equals(default(CompiledModelTestBase.ManyTypesId)),
+                CompiledModelTestBase.ManyTypesId (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Id(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Id(instance).Equals(default(CompiledModelTestBase.ManyTypesId)));
+            id.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.ManyTypesId value) => ManyTypesUnsafeAccessors.Id(entity) = value);
+            id.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.ManyTypesId value) => ManyTypesUnsafeAccessors.Id(entity) = value);
+            id.SetAccessors(
+                CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<CompiledModelTestBase.ManyTypesId>(0) : (entry.FlaggedAsTemporary(0) && ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))).Equals(default(CompiledModelTestBase.ManyTypesId)) ? entry.ReadTemporaryValue<CompiledModelTestBase.ManyTypesId>(0) : ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Id(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.ManyTypesId>(id, 0),
+                CompiledModelTestBase.ManyTypesId (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<CompiledModelTestBase.ManyTypesId>(id, 0),
+                object (ValueBuffer valueBuffer) => valueBuffer[0]);
+            id.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: 0,
+                shadowIndex: -1,
+                relationshipIndex: 0,
+                storeGenerationIndex: 0);
+            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.ManyTypesId>(
+                    bool (CompiledModelTestBase.ManyTypesId v1, CompiledModelTestBase.ManyTypesId v2) => v1.Equals(v2),
+                    int (CompiledModelTestBase.ManyTypesId v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.ManyTypesId (CompiledModelTestBase.ManyTypesId v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.ManyTypesId>(
+                    bool (CompiledModelTestBase.ManyTypesId v1, CompiledModelTestBase.ManyTypesId v2) => v1.Equals(v2),
+                    int (CompiledModelTestBase.ManyTypesId v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.ManyTypesId (CompiledModelTestBase.ManyTypesId v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.ManyTypesId, int>(
+                    int (CompiledModelTestBase.ManyTypesId v) => v.Id,
+                    CompiledModelTestBase.ManyTypesId (int v) => new CompiledModelTestBase.ManyTypesId(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.ManyTypesId, int>(
+                    JsonInt32ReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.ManyTypesId, int>(
+                        int (CompiledModelTestBase.ManyTypesId v) => v.Id,
+                        CompiledModelTestBase.ManyTypesId (int v) => new CompiledModelTestBase.ManyTypesId(v))));
+            id.SetCurrentValueComparer(new CurrentProviderValueComparer<CompiledModelTestBase.ManyTypesId, int>(id));
             id.SetSentinelFromProviderValue(0);
 
             var @bool = runtimeEntityType.AddProperty(
@@ -46,24 +96,271 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Bool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Bool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: false);
+            @bool.SetGetter(
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Bool(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Bool(entity) == false,
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bool(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bool(instance) == false);
+            @bool.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.Bool(entity) = value);
+            @bool.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.Bool(entity) = value);
+            @bool.SetAccessors(
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Bool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Bool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => entry.ReadOriginalValue<bool>(@bool, 1),
+                bool (InternalEntityEntry entry) => entry.GetCurrentValue<bool>(@bool),
+                object (ValueBuffer valueBuffer) => valueBuffer[1]);
+            @bool.SetPropertyIndexes(
+                index: 1,
+                originalValueIndex: 1,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            @bool.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                keyComparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                providerValueComparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                clrType: typeof(bool),
+                jsonValueReaderWriter: JsonBoolReaderWriter.Instance);
 
             var boolArray = runtimeEntityType.AddProperty(
                 "BoolArray",
                 typeof(bool[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            boolArray.SetGetter(
+                bool[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolArray(entity) == null,
+                bool[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolArray(instance) == null);
+            boolArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool[] value) => ManyTypesUnsafeAccessors.BoolArray(entity) = value);
+            boolArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool[] value) => ManyTypesUnsafeAccessors.BoolArray(entity) = value);
+            boolArray.SetAccessors(
+                bool[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool[] (InternalEntityEntry entry) => entry.ReadOriginalValue<bool[]>(boolArray, 2),
+                bool[] (InternalEntityEntry entry) => entry.GetCurrentValue<bool[]>(boolArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[2]);
+            boolArray.SetPropertyIndexes(
+                index: 2,
+                originalValueIndex: 2,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            boolArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v)),
+                keyComparer: new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionOfStructsReaderWriter<bool[], bool>(
+                    JsonBoolReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<bool[], bool>(
+                    JsonBoolReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    keyComparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    providerValueComparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    clrType: typeof(bool),
+                    jsonValueReaderWriter: JsonBoolReaderWriter.Instance));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
+            boolArrayElementType.TypeMapping = boolArray.TypeMapping.ElementTypeMapping;
 
             var boolNestedCollection = runtimeEntityType.AddProperty(
                 "BoolNestedCollection",
                 typeof(bool[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            boolNestedCollection.SetGetter(
+                bool[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolNestedCollection(entity) == null,
+                bool[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolNestedCollection(instance) == null);
+            boolNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool[][] value) => ManyTypesUnsafeAccessors.BoolNestedCollection(entity) = value);
+            boolNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool[][] value) => ManyTypesUnsafeAccessors.BoolNestedCollection(entity) = value);
+            boolNestedCollection.SetAccessors(
+                bool[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<bool[][]>(boolNestedCollection, 3),
+                bool[][] (InternalEntityEntry entry) => entry.GetCurrentValue<bool[][]>(boolNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[3]);
+            boolNestedCollection.SetPropertyIndexes(
+                index: 3,
+                originalValueIndex: 3,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            boolNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<bool[][], bool[]>(new ConvertingValueComparer<bool[], IEnumerable<bool>>(new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<bool[][], bool[]>(new ConvertingValueComparer<bool[], IEnumerable<bool>>(new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<bool[]>(new JsonCollectionOfReferencesReaderWriter<bool[][], bool[]>(
+                    new JsonCollectionOfStructsReaderWriter<bool[], bool>(
+                        JsonBoolReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<bool[][], bool[]>(
+                    new JsonCollectionOfStructsReaderWriter<bool[], bool>(
+                        JsonBoolReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v)),
+                    keyComparer: new ListOfValueTypesComparer<bool[], bool>(new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionOfStructsReaderWriter<bool[], bool>(
+                        JsonBoolReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<bool[], bool>(
+                        JsonBoolReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<bool>(
+                            bool (bool v1, bool v2) => v1 == v2,
+                            int (bool v) => ((object)v).GetHashCode(),
+                            bool (bool v) => v),
+                        keyComparer: new ValueComparer<bool>(
+                            bool (bool v1, bool v2) => v1 == v2,
+                            int (bool v) => ((object)v).GetHashCode(),
+                            bool (bool v) => v),
+                        providerValueComparer: new ValueComparer<bool>(
+                            bool (bool v1, bool v2) => v1 == v2,
+                            int (bool v) => ((object)v).GetHashCode(),
+                            bool (bool v) => v),
+                        clrType: typeof(bool),
+                        jsonValueReaderWriter: JsonBoolReaderWriter.Instance)));
+            var boolNestedCollectionElementType = boolNestedCollection.SetElementType(typeof(bool[]));
+            boolNestedCollectionElementType.TypeMapping = boolNestedCollection.TypeMapping.ElementTypeMapping;
+
+            var boolReadOnlyCollection = runtimeEntityType.AddProperty(
+                "BoolReadOnlyCollection",
+                typeof(IReadOnlyCollection<bool>),
+                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
+                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_boolReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            boolReadOnlyCollection.SetGetter(
+                IReadOnlyCollection<bool> (CompiledModelTestBase.ManyTypes entity) => (ManyTypesUnsafeAccessors._boolReadOnlyCollection(entity) == null ? null : ((IReadOnlyCollection<bool>)(ManyTypesUnsafeAccessors._boolReadOnlyCollection(entity)))),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors._boolReadOnlyCollection(entity) == null,
+                IReadOnlyCollection<bool> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<bool>)(ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance)))),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._boolReadOnlyCollection(instance) == null);
+            boolReadOnlyCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<bool> value) => ManyTypesUnsafeAccessors._boolReadOnlyCollection(entity) = ((List<bool>)(value)));
+            boolReadOnlyCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<bool> value) => ManyTypesUnsafeAccessors._boolReadOnlyCollection(entity) = ((List<bool>)(value)));
+            boolReadOnlyCollection.SetAccessors(
+                IReadOnlyCollection<bool> (InternalEntityEntry entry) => ((IReadOnlyCollection<bool>)(ManyTypesUnsafeAccessors._boolReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<bool> (InternalEntityEntry entry) => ((IReadOnlyCollection<bool>)(ManyTypesUnsafeAccessors._boolReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<bool> (InternalEntityEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection, 4),
+                IReadOnlyCollection<bool> (InternalEntityEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[4]);
+            boolReadOnlyCollection.SetPropertyIndexes(
+                index: 4,
+                originalValueIndex: 4,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            boolReadOnlyCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<bool>, bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<bool>, bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<bool>(new JsonCollectionOfStructsReaderWriter<List<bool>, bool>(
+                    JsonBoolReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<bool>, bool>(
+                    JsonBoolReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    keyComparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    providerValueComparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    clrType: typeof(bool),
+                    jsonValueReaderWriter: JsonBoolReaderWriter.Instance));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
+            boolReadOnlyCollectionElementType.TypeMapping = boolReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BoolToStringConverterProperty",
                 typeof(bool),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            boolToStringConverterProperty.SetGetter(
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(entity) == false,
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(instance) == false);
+            boolToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(entity) = value);
+            boolToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(entity) = value);
+            boolToStringConverterProperty.SetAccessors(
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => entry.ReadOriginalValue<bool>(boolToStringConverterProperty, 5),
+                bool (InternalEntityEntry entry) => entry.GetCurrentValue<bool>(boolToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[5]);
+            boolToStringConverterProperty.SetPropertyIndexes(
+                index: 5,
+                originalValueIndex: 5,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
             boolToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
                 comparer: new ValueComparer<bool>(
                     bool (bool v1, bool v2) => v1 == v2,
@@ -92,9 +389,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToTwoValuesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToTwoValuesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
-            boolToTwoValuesConverterProperty.SetValueConverter(new ValueConverter<bool, byte>(
-                byte (bool v) => ((byte)((v ? 1 : 0))),
-                bool (byte v) => v == 1));
+            boolToTwoValuesConverterProperty.SetGetter(
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(entity) == false,
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(instance) == false);
+            boolToTwoValuesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(entity) = value);
+            boolToTwoValuesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(entity) = value);
+            boolToTwoValuesConverterProperty.SetAccessors(
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolToTwoValuesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => entry.ReadOriginalValue<bool>(boolToTwoValuesConverterProperty, 6),
+                bool (InternalEntityEntry entry) => entry.GetCurrentValue<bool>(boolToTwoValuesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[6]);
+            boolToTwoValuesConverterProperty.SetPropertyIndexes(
+                index: 6,
+                originalValueIndex: 6,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            boolToTwoValuesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                keyComparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                providerValueComparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                converter: new ValueConverter<bool, byte>(
+                    byte (bool v) => ((byte)((v ? 1 : 0))),
+                    bool (byte v) => v == 1),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, byte>(
+                    JsonByteReaderWriter.Instance,
+                    new ValueConverter<bool, byte>(
+                        byte (bool v) => ((byte)((v ? 1 : 0))),
+                        bool (byte v) => v == 1)));
             boolToTwoValuesConverterProperty.SetSentinelFromProviderValue((byte)0);
 
             var boolToZeroOneConverterProperty = runtimeEntityType.AddProperty(
@@ -103,6 +439,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolToZeroOneConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolToZeroOneConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new BoolToZeroOneConverter<short>());
+            boolToZeroOneConverterProperty.SetGetter(
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(entity) == false,
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(instance) == false);
+            boolToZeroOneConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(entity) = value);
+            boolToZeroOneConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool value) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(entity) = value);
+            boolToZeroOneConverterProperty.SetAccessors(
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BoolToZeroOneConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool (InternalEntityEntry entry) => entry.ReadOriginalValue<bool>(boolToZeroOneConverterProperty, 7),
+                bool (InternalEntityEntry entry) => entry.GetCurrentValue<bool>(boolToZeroOneConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[7]);
+            boolToZeroOneConverterProperty.SetPropertyIndexes(
+                index: 7,
+                originalValueIndex: 7,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            boolToZeroOneConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                keyComparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                providerValueComparer: new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v),
+                converter: new ValueConverter<bool, short>(
+                    short (bool v) => ((short)((v ? 1 : 0))),
+                    bool (short v) => v == 1),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<bool, short>(
+                    JsonInt16ReaderWriter.Instance,
+                    new ValueConverter<bool, short>(
+                        short (bool v) => ((short)((v ? 1 : 0))),
+                        bool (short v) => v == 1)));
             boolToZeroOneConverterProperty.SetSentinelFromProviderValue((short)0);
 
             var bytes = runtimeEntityType.AddProperty(
@@ -110,18 +488,183 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Bytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Bytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            bytes.SetGetter(
+                byte[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Bytes(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Bytes(entity) == null,
+                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bytes(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Bytes(instance) == null);
+            bytes.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.Bytes(entity) = value);
+            bytes.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.Bytes(entity) = value);
+            bytes.SetAccessors(
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Bytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Bytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[]>(bytes, 8),
+                byte[] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[]>(bytes),
+                object (ValueBuffer valueBuffer) => valueBuffer[8]);
+            bytes.SetPropertyIndexes(
+                index: 8,
+                originalValueIndex: 8,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            bytes.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v),
+                keyComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                clrType: typeof(byte[]),
+                jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance);
 
             var bytesArray = runtimeEntityType.AddProperty(
                 "BytesArray",
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            bytesArray.SetGetter(
+                byte[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BytesArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BytesArray(entity) == null,
+                byte[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesArray(instance) == null);
+            bytesArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][] value) => ManyTypesUnsafeAccessors.BytesArray(entity) = value);
+            bytesArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][] value) => ManyTypesUnsafeAccessors.BytesArray(entity) = value);
+            bytesArray.SetAccessors(
+                byte[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[][]>(bytesArray, 9),
+                byte[][] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[][]>(bytesArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[9]);
+            bytesArray.SetPropertyIndexes(
+                index: 9,
+                originalValueIndex: 9,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            bytesArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                    JsonByteArrayReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                    JsonByteArrayReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => ((object)v).GetHashCode(),
+                        byte[] (byte[] v) => v),
+                    keyComparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                        byte[] (byte[] source) => source.ToArray()),
+                    providerValueComparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                        byte[] (byte[] source) => source.ToArray()),
+                    clrType: typeof(byte[]),
+                    jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
+            bytesArrayElementType.TypeMapping = bytesArray.TypeMapping.ElementTypeMapping;
 
             var bytesNestedCollection = runtimeEntityType.AddProperty(
                 "BytesNestedCollection",
                 typeof(byte[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            bytesNestedCollection.SetGetter(
+                byte[][][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BytesNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BytesNestedCollection(entity) == null,
+                byte[][][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesNestedCollection(instance) == null);
+            bytesNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][][] value) => ManyTypesUnsafeAccessors.BytesNestedCollection(entity) = value);
+            bytesNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][][] value) => ManyTypesUnsafeAccessors.BytesNestedCollection(entity) = value);
+            bytesNestedCollection.SetAccessors(
+                byte[][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BytesNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BytesNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][][] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[][][]>(bytesNestedCollection, 10),
+                byte[][][] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[][][]>(bytesNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[10]);
+            bytesNestedCollection.SetPropertyIndexes(
+                index: 10,
+                originalValueIndex: 10,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            bytesNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<byte[][][], byte[][]>(new ConvertingValueComparer<byte[][], object>(new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<byte[][][], byte[][]>(new ConvertingValueComparer<byte[][], object>(new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte[][]>(new JsonCollectionOfReferencesReaderWriter<byte[][][], byte[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][][], byte[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => ((object)v).GetHashCode(),
+                        byte[] (byte[] v) => v)),
+                    keyComparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => ((object)v).GetHashCode(),
+                        byte[] (byte[] v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<byte[]>(
+                            bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                            int (byte[] v) => ((object)v).GetHashCode(),
+                            byte[] (byte[] v) => v),
+                        keyComparer: new ValueComparer<byte[]>(
+                            bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                            int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                            byte[] (byte[] source) => source.ToArray()),
+                        providerValueComparer: new ValueComparer<byte[]>(
+                            bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                            int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                            byte[] (byte[] source) => source.ToArray()),
+                        clrType: typeof(byte[]),
+                        jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance)));
+            var bytesNestedCollectionElementType = bytesNestedCollection.SetElementType(typeof(byte[][]));
+            bytesNestedCollectionElementType.TypeMapping = bytesNestedCollection.TypeMapping.ElementTypeMapping;
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BytesToStringConverterProperty",
@@ -130,6 +673,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new BytesToStringConverter(),
                 valueComparer: new ArrayStructuralComparer<byte>());
+            bytesToStringConverterProperty.SetGetter(
+                byte[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(entity) == null,
+                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(instance) == null);
+            bytesToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(entity) = value);
+            bytesToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(entity) = value);
+            bytesToStringConverterProperty.SetAccessors(
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.BytesToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[]>(bytesToStringConverterProperty, 11),
+                byte[] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[]>(bytesToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[11]);
+            bytesToStringConverterProperty.SetPropertyIndexes(
+                index: 11,
+                originalValueIndex: 11,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            bytesToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v),
+                keyComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<byte[], string>(
+                    string (byte[] v) => Convert.ToBase64String(v),
+                    byte[] (string v) => Convert.FromBase64String(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<byte[], string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<byte[], string>(
+                        string (byte[] v) => Convert.ToBase64String(v),
+                        byte[] (string v) => Convert.FromBase64String(v))));
 
             var castingConverterProperty = runtimeEntityType.AddProperty(
                 "CastingConverterProperty",
@@ -137,6 +722,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CastingConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CastingConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new CastingConverter<int, decimal>());
+            castingConverterProperty.SetGetter(
+                int (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CastingConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CastingConverterProperty(entity) == 0,
+                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CastingConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CastingConverterProperty(instance) == 0);
+            castingConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.CastingConverterProperty(entity) = value);
+            castingConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.CastingConverterProperty(entity) = value);
+            castingConverterProperty.SetAccessors(
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CastingConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CastingConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(castingConverterProperty, 12),
+                int (InternalEntityEntry entry) => entry.GetCurrentValue<int>(castingConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[12]);
+            castingConverterProperty.SetPropertyIndexes(
+                index: 12,
+                originalValueIndex: 12,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            castingConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                converter: new ValueConverter<int, decimal>(
+                    decimal (int v) => ((decimal)(v)),
+                    int (decimal v) => ((int)(v))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, decimal>(
+                    JsonDecimalReaderWriter.Instance,
+                    new ValueConverter<int, decimal>(
+                        decimal (int v) => ((decimal)(v)),
+                        int (decimal v) => ((int)(v)))));
             castingConverterProperty.SetSentinelFromProviderValue(0m);
 
             var @char = runtimeEntityType.AddProperty(
@@ -145,18 +772,183 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Char", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Char>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: '\0');
+            @char.SetGetter(
+                char (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Char(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Char(entity) == '\0',
+                char (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Char(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Char(instance) == '\0');
+            @char.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, char value) => ManyTypesUnsafeAccessors.Char(entity) = value);
+            @char.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, char value) => ManyTypesUnsafeAccessors.Char(entity) = value);
+            @char.SetAccessors(
+                char (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Char(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Char(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char (InternalEntityEntry entry) => entry.ReadOriginalValue<char>(@char, 13),
+                char (InternalEntityEntry entry) => entry.GetCurrentValue<char>(@char),
+                object (ValueBuffer valueBuffer) => valueBuffer[13]);
+            @char.SetPropertyIndexes(
+                index: 13,
+                originalValueIndex: 13,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            @char.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                keyComparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                providerValueComparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                clrType: typeof(char),
+                jsonValueReaderWriter: JsonCharReaderWriter.Instance);
 
             var charArray = runtimeEntityType.AddProperty(
                 "CharArray",
                 typeof(char[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            charArray.SetGetter(
+                char[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CharArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CharArray(entity) == null,
+                char[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharArray(instance) == null);
+            charArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, char[] value) => ManyTypesUnsafeAccessors.CharArray(entity) = value);
+            charArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, char[] value) => ManyTypesUnsafeAccessors.CharArray(entity) = value);
+            charArray.SetAccessors(
+                char[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char[] (InternalEntityEntry entry) => entry.ReadOriginalValue<char[]>(charArray, 14),
+                char[] (InternalEntityEntry entry) => entry.GetCurrentValue<char[]>(charArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[14]);
+            charArray.SetPropertyIndexes(
+                index: 14,
+                originalValueIndex: 14,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            charArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v)),
+                keyComparer: new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<char>(new JsonCollectionOfStructsReaderWriter<char[], char>(
+                    JsonCharReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<char[], char>(
+                    JsonCharReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v),
+                    keyComparer: new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v),
+                    providerValueComparer: new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v),
+                    clrType: typeof(char),
+                    jsonValueReaderWriter: JsonCharReaderWriter.Instance));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
+            charArrayElementType.TypeMapping = charArray.TypeMapping.ElementTypeMapping;
 
             var charNestedCollection = runtimeEntityType.AddProperty(
                 "CharNestedCollection",
                 typeof(char[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            charNestedCollection.SetGetter(
+                char[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CharNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CharNestedCollection(entity) == null,
+                char[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharNestedCollection(instance) == null);
+            charNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, char[][] value) => ManyTypesUnsafeAccessors.CharNestedCollection(entity) = value);
+            charNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, char[][] value) => ManyTypesUnsafeAccessors.CharNestedCollection(entity) = value);
+            charNestedCollection.SetAccessors(
+                char[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CharNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CharNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<char[][]>(charNestedCollection, 15),
+                char[][] (InternalEntityEntry entry) => entry.GetCurrentValue<char[][]>(charNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[15]);
+            charNestedCollection.SetPropertyIndexes(
+                index: 15,
+                originalValueIndex: 15,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            charNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<char[][], char[]>(new ConvertingValueComparer<char[], IEnumerable<char>>(new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<char[][], char[]>(new ConvertingValueComparer<char[], IEnumerable<char>>(new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<char[]>(new JsonCollectionOfReferencesReaderWriter<char[][], char[]>(
+                    new JsonCollectionOfStructsReaderWriter<char[], char>(
+                        JsonCharReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<char[][], char[]>(
+                    new JsonCollectionOfStructsReaderWriter<char[], char>(
+                        JsonCharReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v)),
+                    keyComparer: new ListOfValueTypesComparer<char[], char>(new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<char>(new JsonCollectionOfStructsReaderWriter<char[], char>(
+                        JsonCharReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<char[], char>(
+                        JsonCharReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<char>(
+                            bool (char v1, char v2) => v1 == v2,
+                            int (char v) => ((int)(v)),
+                            char (char v) => v),
+                        keyComparer: new ValueComparer<char>(
+                            bool (char v1, char v2) => v1 == v2,
+                            int (char v) => ((int)(v)),
+                            char (char v) => v),
+                        providerValueComparer: new ValueComparer<char>(
+                            bool (char v1, char v2) => v1 == v2,
+                            int (char v) => ((int)(v)),
+                            char (char v) => v),
+                        clrType: typeof(char),
+                        jsonValueReaderWriter: JsonCharReaderWriter.Instance)));
+            var charNestedCollectionElementType = charNestedCollection.SetElementType(typeof(char[]));
+            charNestedCollectionElementType.TypeMapping = charNestedCollection.TypeMapping.ElementTypeMapping;
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
                 "CharToStringConverterProperty",
@@ -164,6 +956,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new CharToStringConverter());
+            charToStringConverterProperty.SetGetter(
+                char (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(entity) == '\0',
+                char (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(instance) == '\0');
+            charToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, char value) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(entity) = value);
+            charToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, char value) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(entity) = value);
+            charToStringConverterProperty.SetAccessors(
+                char (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.CharToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char (InternalEntityEntry entry) => entry.ReadOriginalValue<char>(charToStringConverterProperty, 16),
+                char (InternalEntityEntry entry) => entry.GetCurrentValue<char>(charToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[16]);
+            charToStringConverterProperty.SetPropertyIndexes(
+                index: 16,
+                originalValueIndex: 16,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            charToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                keyComparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<char, string>(
+                    string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
+                    char (string v) => (v.Length < 1 ? '\0' : v[0])),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<char, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<char, string>(
+                        string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
+                        char (string v) => (v.Length < 1 ? '\0' : v[0]))));
             charToStringConverterProperty.SetSentinelFromProviderValue("\0");
 
             var dateOnly = runtimeEntityType.AddProperty(
@@ -172,12 +1006,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: new DateOnly(1, 1, 1));
+            dateOnly.SetGetter(
+                DateOnly (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateOnly(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateOnly(entity) == default(DateOnly),
+                DateOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnly(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnly(instance) == default(DateOnly));
+            dateOnly.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly value) => ManyTypesUnsafeAccessors.DateOnly(entity) = value);
+            dateOnly.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly value) => ManyTypesUnsafeAccessors.DateOnly(entity) = value);
+            dateOnly.SetAccessors(
+                DateOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly (InternalEntityEntry entry) => entry.ReadOriginalValue<DateOnly>(dateOnly, 17),
+                DateOnly (InternalEntityEntry entry) => entry.GetCurrentValue<DateOnly>(dateOnly),
+                object (ValueBuffer valueBuffer) => valueBuffer[17]);
+            dateOnly.SetPropertyIndexes(
+                index: 17,
+                originalValueIndex: 17,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateOnly.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                keyComparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                providerValueComparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                clrType: typeof(DateOnly),
+                jsonValueReaderWriter: JsonDateOnlyReaderWriter.Instance);
 
             var dateOnlyArray = runtimeEntityType.AddProperty(
                 "DateOnlyArray",
                 typeof(DateOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            dateOnlyArray.SetGetter(
+                DateOnly[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateOnlyArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateOnlyArray(entity) == null,
+                DateOnly[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyArray(instance) == null);
+            dateOnlyArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly[] value) => ManyTypesUnsafeAccessors.DateOnlyArray(entity) = value);
+            dateOnlyArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly[] value) => ManyTypesUnsafeAccessors.DateOnlyArray(entity) = value);
+            dateOnlyArray.SetAccessors(
+                DateOnly[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly[] (InternalEntityEntry entry) => entry.ReadOriginalValue<DateOnly[]>(dateOnlyArray, 18),
+                DateOnly[] (InternalEntityEntry entry) => entry.GetCurrentValue<DateOnly[]>(dateOnlyArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[18]);
+            dateOnlyArray.SetPropertyIndexes(
+                index: 18,
+                originalValueIndex: 18,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateOnlyArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<DateOnly[], DateOnly>(new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v)),
+                keyComparer: new ListOfValueTypesComparer<DateOnly[], DateOnly>(new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<DateOnly>(new JsonCollectionOfStructsReaderWriter<DateOnly[], DateOnly>(
+                    JsonDateOnlyReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateOnly[], DateOnly>(
+                    JsonDateOnlyReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<DateOnly>(
+                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                        int (DateOnly v) => ((object)v).GetHashCode(),
+                        DateOnly (DateOnly v) => v),
+                    keyComparer: new ValueComparer<DateOnly>(
+                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                        int (DateOnly v) => ((object)v).GetHashCode(),
+                        DateOnly (DateOnly v) => v),
+                    providerValueComparer: new ValueComparer<DateOnly>(
+                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                        int (DateOnly v) => ((object)v).GetHashCode(),
+                        DateOnly (DateOnly v) => v),
+                    clrType: typeof(DateOnly),
+                    jsonValueReaderWriter: JsonDateOnlyReaderWriter.Instance));
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
+            dateOnlyArrayElementType.TypeMapping = dateOnlyArray.TypeMapping.ElementTypeMapping;
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "DateOnlyToStringConverterProperty",
@@ -185,6 +1110,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new DateOnlyToStringConverter());
+            dateOnlyToStringConverterProperty.SetGetter(
+                DateOnly (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(entity) == default(DateOnly),
+                DateOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(instance) == default(DateOnly));
+            dateOnlyToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly value) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(entity) = value);
+            dateOnlyToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly value) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(entity) = value);
+            dateOnlyToStringConverterProperty.SetAccessors(
+                DateOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly (InternalEntityEntry entry) => entry.ReadOriginalValue<DateOnly>(dateOnlyToStringConverterProperty, 19),
+                DateOnly (InternalEntityEntry entry) => entry.GetCurrentValue<DateOnly>(dateOnlyToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[19]);
+            dateOnlyToStringConverterProperty.SetPropertyIndexes(
+                index: 19,
+                originalValueIndex: 19,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateOnlyToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                keyComparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<DateOnly, string>(
+                    string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
+                    DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateOnly, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<DateOnly, string>(
+                        string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"),
+                        DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
             dateOnlyToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01");
 
             var dateTime = runtimeEntityType.AddProperty(
@@ -193,12 +1160,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
+            dateTime.SetGetter(
+                DateTime (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTime(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTime(entity) == default(DateTime),
+                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTime(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTime(instance) == default(DateTime));
+            dateTime.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTime(entity) = value);
+            dateTime.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTime(entity) = value);
+            dateTime.SetAccessors(
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime>(dateTime, 20),
+                DateTime (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime>(dateTime),
+                object (ValueBuffer valueBuffer) => valueBuffer[20]);
+            dateTime.SetPropertyIndexes(
+                index: 20,
+                originalValueIndex: 20,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTime.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                keyComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                providerValueComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                clrType: typeof(DateTime),
+                jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance);
 
             var dateTimeArray = runtimeEntityType.AddProperty(
                 "DateTimeArray",
                 typeof(DateTime[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            dateTimeArray.SetGetter(
+                DateTime[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeArray(entity) == null,
+                DateTime[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeArray(instance) == null);
+            dateTimeArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime[] value) => ManyTypesUnsafeAccessors.DateTimeArray(entity) = value);
+            dateTimeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime[] value) => ManyTypesUnsafeAccessors.DateTimeArray(entity) = value);
+            dateTimeArray.SetAccessors(
+                DateTime[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime[]>(dateTimeArray, 21),
+                DateTime[] (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime[]>(dateTimeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[21]);
+            dateTimeArray.SetPropertyIndexes(
+                index: 21,
+                originalValueIndex: 21,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTimeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                keyComparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    keyComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    providerValueComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    clrType: typeof(DateTime),
+                    jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
+            dateTimeArrayElementType.TypeMapping = dateTimeArray.TypeMapping.ElementTypeMapping;
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                 "DateTimeOffsetToBinaryConverterProperty",
@@ -206,6 +1264,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new DateTimeOffsetToBinaryConverter());
+            dateTimeOffsetToBinaryConverterProperty.SetGetter(
+                DateTimeOffset (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(entity).EqualsExact(default(DateTimeOffset)),
+                DateTimeOffset (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(instance).EqualsExact(default(DateTimeOffset)));
+            dateTimeOffsetToBinaryConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTimeOffset value) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(entity) = value);
+            dateTimeOffsetToBinaryConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTimeOffset value) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(entity) = value);
+            dateTimeOffsetToBinaryConverterProperty.SetAccessors(
+                DateTimeOffset (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTimeOffset (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTimeOffset (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(dateTimeOffsetToBinaryConverterProperty, 22),
+                DateTimeOffset (InternalEntityEntry entry) => entry.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBinaryConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[22]);
+            dateTimeOffsetToBinaryConverterProperty.SetPropertyIndexes(
+                index: 22,
+                originalValueIndex: 22,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTimeOffsetToBinaryConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTimeOffset>(
+                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
+                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
+                    DateTimeOffset (DateTimeOffset v) => v),
+                keyComparer: new ValueComparer<DateTimeOffset>(
+                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
+                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
+                    DateTimeOffset (DateTimeOffset v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                converter: new ValueConverter<DateTimeOffset, long>(
+                    long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
+                    DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, long>(
+                    JsonInt64ReaderWriter.Instance,
+                    new ValueConverter<DateTimeOffset, long>(
+                        long (DateTimeOffset v) => DateTimeOffsetToBinaryConverter.ToLong(v),
+                        DateTimeOffset (long v) => DateTimeOffsetToBinaryConverter.ToDateTimeOffset(v))));
             dateTimeOffsetToBinaryConverterProperty.SetSentinelFromProviderValue(0L);
 
             var dateTimeOffsetToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -214,6 +1314,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new DateTimeOffsetToBytesConverter());
+            dateTimeOffsetToBytesConverterProperty.SetGetter(
+                DateTimeOffset (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(entity).EqualsExact(default(DateTimeOffset)),
+                DateTimeOffset (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(instance).EqualsExact(default(DateTimeOffset)));
+            dateTimeOffsetToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTimeOffset value) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(entity) = value);
+            dateTimeOffsetToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTimeOffset value) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(entity) = value);
+            dateTimeOffsetToBytesConverterProperty.SetAccessors(
+                DateTimeOffset (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTimeOffset (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTimeOffset (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(dateTimeOffsetToBytesConverterProperty, 23),
+                DateTimeOffset (InternalEntityEntry entry) => entry.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[23]);
+            dateTimeOffsetToBytesConverterProperty.SetPropertyIndexes(
+                index: 23,
+                originalValueIndex: 23,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTimeOffsetToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTimeOffset>(
+                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
+                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
+                    DateTimeOffset (DateTimeOffset v) => v),
+                keyComparer: new ValueComparer<DateTimeOffset>(
+                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
+                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
+                    DateTimeOffset (DateTimeOffset v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<DateTimeOffset, byte[]>(
+                    byte[] (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
+                    DateTimeOffset (byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<DateTimeOffset, byte[]>(
+                        byte[] (DateTimeOffset v) => DateTimeOffsetToBytesConverter.ToBytes(v),
+                        DateTimeOffset (byte[] v) => DateTimeOffsetToBytesConverter.FromBytes(v))));
             dateTimeOffsetToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
 
             var dateTimeOffsetToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -222,6 +1364,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeOffsetToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeOffsetToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new DateTimeOffsetToStringConverter());
+            dateTimeOffsetToStringConverterProperty.SetGetter(
+                DateTimeOffset (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(entity).EqualsExact(default(DateTimeOffset)),
+                DateTimeOffset (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(instance).EqualsExact(default(DateTimeOffset)));
+            dateTimeOffsetToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTimeOffset value) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(entity) = value);
+            dateTimeOffsetToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTimeOffset value) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(entity) = value);
+            dateTimeOffsetToStringConverterProperty.SetAccessors(
+                DateTimeOffset (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTimeOffset (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeOffsetToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTimeOffset (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTimeOffset>(dateTimeOffsetToStringConverterProperty, 24),
+                DateTimeOffset (InternalEntityEntry entry) => entry.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[24]);
+            dateTimeOffsetToStringConverterProperty.SetPropertyIndexes(
+                index: 24,
+                originalValueIndex: 24,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTimeOffsetToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTimeOffset>(
+                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
+                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
+                    DateTimeOffset (DateTimeOffset v) => v),
+                keyComparer: new ValueComparer<DateTimeOffset>(
+                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
+                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
+                    DateTimeOffset (DateTimeOffset v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<DateTimeOffset, string>(
+                    string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
+                    DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTimeOffset, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<DateTimeOffset, string>(
+                        string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"),
+                        DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture))));
             dateTimeOffsetToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00+00:00");
 
             var dateTimeToBinaryConverterProperty = runtimeEntityType.AddProperty(
@@ -230,6 +1414,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToBinaryConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToBinaryConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new DateTimeToBinaryConverter());
+            dateTimeToBinaryConverterProperty.SetGetter(
+                DateTime (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(entity) == default(DateTime),
+                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(instance) == default(DateTime));
+            dateTimeToBinaryConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(entity) = value);
+            dateTimeToBinaryConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(entity) = value);
+            dateTimeToBinaryConverterProperty.SetAccessors(
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeToBinaryConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime>(dateTimeToBinaryConverterProperty, 25),
+                DateTime (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime>(dateTimeToBinaryConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[25]);
+            dateTimeToBinaryConverterProperty.SetPropertyIndexes(
+                index: 25,
+                originalValueIndex: 25,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTimeToBinaryConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                keyComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                converter: new ValueConverter<DateTime, long>(
+                    long (DateTime v) => v.ToBinary(),
+                    DateTime (long v) => DateTime.FromBinary(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, long>(
+                    JsonInt64ReaderWriter.Instance,
+                    new ValueConverter<DateTime, long>(
+                        long (DateTime v) => v.ToBinary(),
+                        DateTime (long v) => DateTime.FromBinary(v))));
             dateTimeToBinaryConverterProperty.SetSentinelFromProviderValue(0L);
 
             var dateTimeToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -238,6 +1464,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new DateTimeToStringConverter());
+            dateTimeToStringConverterProperty.SetGetter(
+                DateTime (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(entity) == default(DateTime),
+                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(instance) == default(DateTime));
+            dateTimeToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(entity) = value);
+            dateTimeToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(entity) = value);
+            dateTimeToStringConverterProperty.SetAccessors(
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime>(dateTimeToStringConverterProperty, 26),
+                DateTime (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime>(dateTimeToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[26]);
+            dateTimeToStringConverterProperty.SetPropertyIndexes(
+                index: 26,
+                originalValueIndex: 26,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTimeToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                keyComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<DateTime, string>(
+                    string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
+                    DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<DateTime, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<DateTime, string>(
+                        string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"),
+                        DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture))));
             dateTimeToStringConverterProperty.SetSentinelFromProviderValue("0001-01-01 00:00:00");
 
             var dateTimeToTicksConverterProperty = runtimeEntityType.AddProperty(
@@ -246,6 +1514,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
+            dateTimeToTicksConverterProperty.SetGetter(
+                DateTime (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(entity) == default(DateTime),
+                DateTime (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(instance) == default(DateTime));
+            dateTimeToTicksConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(entity) = value);
+            dateTimeToTicksConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime value) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(entity) = value);
+            dateTimeToTicksConverterProperty.SetAccessors(
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DateTimeToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime>(dateTimeToTicksConverterProperty, 27),
+                DateTime (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime>(dateTimeToTicksConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[27]);
+            dateTimeToTicksConverterProperty.SetPropertyIndexes(
+                index: 27,
+                originalValueIndex: 27,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            dateTimeToTicksConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                keyComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                providerValueComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                clrType: typeof(DateTime),
+                jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance);
 
             var @decimal = runtimeEntityType.AddProperty(
                 "Decimal",
@@ -253,12 +1557,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Decimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Decimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0m);
+            @decimal.SetGetter(
+                decimal (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Decimal(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Decimal(entity) == 0M,
+                decimal (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Decimal(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Decimal(instance) == 0M);
+            @decimal.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal value) => ManyTypesUnsafeAccessors.Decimal(entity) = value);
+            @decimal.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal value) => ManyTypesUnsafeAccessors.Decimal(entity) = value);
+            @decimal.SetAccessors(
+                decimal (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Decimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Decimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(@decimal, 28),
+                decimal (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(@decimal),
+                object (ValueBuffer valueBuffer) => valueBuffer[28]);
+            @decimal.SetPropertyIndexes(
+                index: 28,
+                originalValueIndex: 28,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            @decimal.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                keyComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                providerValueComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                clrType: typeof(decimal),
+                jsonValueReaderWriter: JsonDecimalReaderWriter.Instance);
 
             var decimalArray = runtimeEntityType.AddProperty(
                 "DecimalArray",
                 typeof(decimal[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            decimalArray.SetGetter(
+                decimal[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DecimalArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DecimalArray(entity) == null,
+                decimal[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalArray(instance) == null);
+            decimalArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal[] value) => ManyTypesUnsafeAccessors.DecimalArray(entity) = value);
+            decimalArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal[] value) => ManyTypesUnsafeAccessors.DecimalArray(entity) = value);
+            decimalArray.SetAccessors(
+                decimal[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal[] (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal[]>(decimalArray, 29),
+                decimal[] (InternalEntityEntry entry) => entry.GetCurrentValue<decimal[]>(decimalArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[29]);
+            decimalArray.SetPropertyIndexes(
+                index: 29,
+                originalValueIndex: 29,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            decimalArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<decimal[], decimal>(new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v)),
+                keyComparer: new ListOfValueTypesComparer<decimal[], decimal>(new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<decimal>(new JsonCollectionOfStructsReaderWriter<decimal[], decimal>(
+                    JsonDecimalReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<decimal[], decimal>(
+                    JsonDecimalReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<decimal>(
+                        bool (decimal v1, decimal v2) => v1 == v2,
+                        int (decimal v) => ((object)v).GetHashCode(),
+                        decimal (decimal v) => v),
+                    keyComparer: new ValueComparer<decimal>(
+                        bool (decimal v1, decimal v2) => v1 == v2,
+                        int (decimal v) => ((object)v).GetHashCode(),
+                        decimal (decimal v) => v),
+                    providerValueComparer: new ValueComparer<decimal>(
+                        bool (decimal v1, decimal v2) => v1 == v2,
+                        int (decimal v) => ((object)v).GetHashCode(),
+                        decimal (decimal v) => v),
+                    clrType: typeof(decimal),
+                    jsonValueReaderWriter: JsonDecimalReaderWriter.Instance));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
+            decimalArrayElementType.TypeMapping = decimalArray.TypeMapping.ElementTypeMapping;
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DecimalNumberToBytesConverterProperty",
@@ -266,6 +1661,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new NumberToBytesConverter<decimal>());
+            decimalNumberToBytesConverterProperty.SetGetter(
+                decimal (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(entity) == 0M,
+                decimal (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(instance) == 0M);
+            decimalNumberToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal value) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(entity) = value);
+            decimalNumberToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal value) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(entity) = value);
+            decimalNumberToBytesConverterProperty.SetAccessors(
+                decimal (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(decimalNumberToBytesConverterProperty, 30),
+                decimal (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(decimalNumberToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[30]);
+            decimalNumberToBytesConverterProperty.SetPropertyIndexes(
+                index: 30,
+                originalValueIndex: 30,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            decimalNumberToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                keyComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<decimal, byte[]>(
+                    byte[] (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
+                    decimal (byte[] v) => (v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<decimal, byte[]>(
+                        byte[] (decimal v) => NumberToBytesConverter<decimal>.DecimalToBytes(v),
+                        decimal (byte[] v) => (v == null ? 0M : NumberToBytesConverter<decimal>.BytesToDecimal(v)))));
             decimalNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
 
             var decimalNumberToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -274,6 +1711,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new NumberToStringConverter<decimal>());
+            decimalNumberToStringConverterProperty.SetGetter(
+                decimal (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(entity) == 0M,
+                decimal (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(instance) == 0M);
+            decimalNumberToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal value) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(entity) = value);
+            decimalNumberToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal value) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(entity) = value);
+            decimalNumberToStringConverterProperty.SetAccessors(
+                decimal (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DecimalNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(decimalNumberToStringConverterProperty, 31),
+                decimal (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(decimalNumberToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[31]);
+            decimalNumberToStringConverterProperty.SetPropertyIndexes(
+                index: 31,
+                originalValueIndex: 31,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            decimalNumberToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                keyComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<decimal, string>(
+                    string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
+                    decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<decimal, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<decimal, string>(
+                        string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
+                        decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
             decimalNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
 
             var @double = runtimeEntityType.AddProperty(
@@ -282,12 +1761,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Double", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Double>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0.0);
+            @double.SetGetter(
+                double (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Double(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Double(entity).Equals(0D),
+                double (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Double(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Double(instance).Equals(0D));
+            @double.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, double value) => ManyTypesUnsafeAccessors.Double(entity) = value);
+            @double.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, double value) => ManyTypesUnsafeAccessors.Double(entity) = value);
+            @double.SetAccessors(
+                double (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Double(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Double(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double (InternalEntityEntry entry) => entry.ReadOriginalValue<double>(@double, 32),
+                double (InternalEntityEntry entry) => entry.GetCurrentValue<double>(@double),
+                object (ValueBuffer valueBuffer) => valueBuffer[32]);
+            @double.SetPropertyIndexes(
+                index: 32,
+                originalValueIndex: 32,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            @double.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                keyComparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                providerValueComparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                clrType: typeof(double),
+                jsonValueReaderWriter: JsonDoubleReaderWriter.Instance);
 
             var doubleArray = runtimeEntityType.AddProperty(
                 "DoubleArray",
                 typeof(double[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            doubleArray.SetGetter(
+                double[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DoubleArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DoubleArray(entity) == null,
+                double[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleArray(instance) == null);
+            doubleArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, double[] value) => ManyTypesUnsafeAccessors.DoubleArray(entity) = value);
+            doubleArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, double[] value) => ManyTypesUnsafeAccessors.DoubleArray(entity) = value);
+            doubleArray.SetAccessors(
+                double[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double[] (InternalEntityEntry entry) => entry.ReadOriginalValue<double[]>(doubleArray, 33),
+                double[] (InternalEntityEntry entry) => entry.GetCurrentValue<double[]>(doubleArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[33]);
+            doubleArray.SetPropertyIndexes(
+                index: 33,
+                originalValueIndex: 33,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            doubleArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<double[], double>(new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v)),
+                keyComparer: new ListOfValueTypesComparer<double[], double>(new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<double>(new JsonCollectionOfStructsReaderWriter<double[], double>(
+                    JsonDoubleReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<double[], double>(
+                    JsonDoubleReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<double>(
+                        bool (double v1, double v2) => v1.Equals(v2),
+                        int (double v) => ((object)v).GetHashCode(),
+                        double (double v) => v),
+                    keyComparer: new ValueComparer<double>(
+                        bool (double v1, double v2) => v1.Equals(v2),
+                        int (double v) => ((object)v).GetHashCode(),
+                        double (double v) => v),
+                    providerValueComparer: new ValueComparer<double>(
+                        bool (double v1, double v2) => v1.Equals(v2),
+                        int (double v) => ((object)v).GetHashCode(),
+                        double (double v) => v),
+                    clrType: typeof(double),
+                    jsonValueReaderWriter: JsonDoubleReaderWriter.Instance));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
+            doubleArrayElementType.TypeMapping = doubleArray.TypeMapping.ElementTypeMapping;
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DoubleNumberToBytesConverterProperty",
@@ -295,6 +1865,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new NumberToBytesConverter<double>());
+            doubleNumberToBytesConverterProperty.SetGetter(
+                double (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(entity).Equals(0D),
+                double (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(instance).Equals(0D));
+            doubleNumberToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, double value) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(entity) = value);
+            doubleNumberToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, double value) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(entity) = value);
+            doubleNumberToBytesConverterProperty.SetAccessors(
+                double (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double (InternalEntityEntry entry) => entry.ReadOriginalValue<double>(doubleNumberToBytesConverterProperty, 34),
+                double (InternalEntityEntry entry) => entry.GetCurrentValue<double>(doubleNumberToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[34]);
+            doubleNumberToBytesConverterProperty.SetPropertyIndexes(
+                index: 34,
+                originalValueIndex: 34,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            doubleNumberToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                keyComparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<double, byte[]>(
+                    byte[] (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
+                    double (byte[] v) => (v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<double, byte[]>(
+                        byte[] (double v) => NumberToBytesConverter<double>.ReverseLong(BitConverter.GetBytes(v)),
+                        double (byte[] v) => (v == null ? 0D : BitConverter.ToDouble(NumberToBytesConverter<double>.ReverseLong(v), 0)))));
             doubleNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });
 
             var doubleNumberToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -303,6 +1915,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new NumberToStringConverter<double>());
+            doubleNumberToStringConverterProperty.SetGetter(
+                double (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(entity).Equals(0D),
+                double (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(instance).Equals(0D));
+            doubleNumberToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, double value) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(entity) = value);
+            doubleNumberToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, double value) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(entity) = value);
+            doubleNumberToStringConverterProperty.SetAccessors(
+                double (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.DoubleNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double (InternalEntityEntry entry) => entry.ReadOriginalValue<double>(doubleNumberToStringConverterProperty, 35),
+                double (InternalEntityEntry entry) => entry.GetCurrentValue<double>(doubleNumberToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[35]);
+            doubleNumberToStringConverterProperty.SetPropertyIndexes(
+                index: 35,
+                originalValueIndex: 35,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            doubleNumberToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                keyComparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<double, string>(
+                    string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v))),
+                    double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<double, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<double, string>(
+                        string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v))),
+                        double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
             doubleNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
 
             var enum16 = runtimeEntityType.AddProperty(
@@ -311,12 +1965,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.Enum16.Default);
+            enum16.SetGetter(
+                CompiledModelTestBase.Enum16 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum16(entity))), ((object)(CompiledModelTestBase.Enum16.Default))),
+                CompiledModelTestBase.Enum16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum16(instance))), ((object)(CompiledModelTestBase.Enum16.Default))));
+            enum16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16 value) => ManyTypesUnsafeAccessors.Enum16(entity) = value);
+            enum16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16 value) => ManyTypesUnsafeAccessors.Enum16(entity) = value);
+            enum16.SetAccessors(
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16>(enum16, 36),
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16),
+                object (ValueBuffer valueBuffer) => valueBuffer[36]);
+            enum16.SetPropertyIndexes(
+                index: 36,
+                originalValueIndex: 36,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum16),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance);
 
             var enum16Array = runtimeEntityType.AddProperty(
                 "Enum16Array",
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum16Array.SetGetter(
+                CompiledModelTestBase.Enum16[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16Array(entity) == null,
+                CompiledModelTestBase.Enum16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Array(instance) == null);
+            enum16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16[] value) => ManyTypesUnsafeAccessors.Enum16Array(entity) = value);
+            enum16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16[] value) => ManyTypesUnsafeAccessors.Enum16Array(entity) = value);
+            enum16Array.SetAccessors(
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16[]>(enum16Array, 37),
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[37]);
+            enum16Array.SetPropertyIndexes(
+                index: 37,
+                originalValueIndex: 37,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum16),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16ArrayElementType.TypeMapping = enum16Array.TypeMapping.ElementTypeMapping;
 
             var enum16AsString = runtimeEntityType.AddProperty(
                 "Enum16AsString",
@@ -324,6 +2069,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enum16AsString.SetGetter(
+                CompiledModelTestBase.Enum16 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum16AsString(entity))), ((object)(CompiledModelTestBase.Enum16.Default))),
+                CompiledModelTestBase.Enum16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum16AsString(instance))), ((object)(CompiledModelTestBase.Enum16.Default))));
+            enum16AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16 value) => ManyTypesUnsafeAccessors.Enum16AsString(entity) = value);
+            enum16AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16 value) => ManyTypesUnsafeAccessors.Enum16AsString(entity) = value);
+            enum16AsString.SetAccessors(
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16>(enum16AsString, 38),
+                CompiledModelTestBase.Enum16 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[38]);
+            enum16AsString.SetPropertyIndexes(
+                index: 38,
+                originalValueIndex: 38,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum16AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                    string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                        string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))));
             enum16AsString.SetSentinelFromProviderValue("Default");
 
             var enum16AsStringArray = runtimeEntityType.AddProperty(
@@ -331,18 +2118,213 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum16AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum16[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringArray(instance) == null);
+            enum16AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16[] value) => ManyTypesUnsafeAccessors.Enum16AsStringArray(entity) = value);
+            enum16AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16[] value) => ManyTypesUnsafeAccessors.Enum16AsStringArray(entity) = value);
+            enum16AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray, 39),
+                CompiledModelTestBase.Enum16[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[39]);
+            enum16AsStringArray.SetPropertyIndexes(
+                index: 39,
+                originalValueIndex: 39,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum16AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                        string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringArrayElementType.TypeMapping = enum16AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum16AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum16AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum16> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(instance) == null);
+            enum16AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16> value) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(entity) = value);
+            enum16AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16> value) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(entity) = value);
+            enum16AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection, 40),
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[40]);
+            enum16AsStringCollection.SetPropertyIndexes(
+                index: 40,
+                originalValueIndex: 40,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum16AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                        string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum16, string>(
+                            string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringCollectionElementType.TypeMapping = enum16AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum16Collection = runtimeEntityType.AddProperty(
                 "Enum16Collection",
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum16Collection.SetGetter(
+                List<CompiledModelTestBase.Enum16> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum16Collection(entity) == null,
+                List<CompiledModelTestBase.Enum16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum16Collection(instance) == null);
+            enum16Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16> value) => ManyTypesUnsafeAccessors.Enum16Collection(entity) = value);
+            enum16Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16> value) => ManyTypesUnsafeAccessors.Enum16Collection(entity) = value);
+            enum16Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16>>(enum16Collection, 41),
+                List<CompiledModelTestBase.Enum16> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[41]);
+            enum16Collection.SetPropertyIndexes(
+                index: 41,
+                originalValueIndex: 41,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum16Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum16),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16CollectionElementType.TypeMapping = enum16Collection.TypeMapping.ElementTypeMapping;
 
             var enum32 = runtimeEntityType.AddProperty(
                 "Enum32",
@@ -350,12 +2332,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.Enum32.Default);
+            enum32.SetGetter(
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum32(entity))), ((object)(CompiledModelTestBase.Enum32.Default))),
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum32(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
+            enum32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.Enum32(entity) = value);
+            enum32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.Enum32(entity) = value);
+            enum32.SetAccessors(
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enum32, 42),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32),
+                object (ValueBuffer valueBuffer) => valueBuffer[42]);
+            enum32.SetPropertyIndexes(
+                index: 42,
+                originalValueIndex: 42,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum32),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance);
 
             var enum32Array = runtimeEntityType.AddProperty(
                 "Enum32Array",
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum32Array.SetGetter(
+                CompiledModelTestBase.Enum32[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32Array(entity) == null,
+                CompiledModelTestBase.Enum32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Array(instance) == null);
+            enum32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32[] value) => ManyTypesUnsafeAccessors.Enum32Array(entity) = value);
+            enum32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32[] value) => ManyTypesUnsafeAccessors.Enum32Array(entity) = value);
+            enum32Array.SetAccessors(
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32[]>(enum32Array, 43),
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[43]);
+            enum32Array.SetPropertyIndexes(
+                index: 43,
+                originalValueIndex: 43,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum32),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32ArrayElementType.TypeMapping = enum32Array.TypeMapping.ElementTypeMapping;
 
             var enum32AsString = runtimeEntityType.AddProperty(
                 "Enum32AsString",
@@ -363,6 +2436,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enum32AsString.SetGetter(
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum32AsString(entity))), ((object)(CompiledModelTestBase.Enum32.Default))),
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum32AsString(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
+            enum32AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.Enum32AsString(entity) = value);
+            enum32AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.Enum32AsString(entity) = value);
+            enum32AsString.SetAccessors(
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enum32AsString, 44),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[44]);
+            enum32AsString.SetPropertyIndexes(
+                index: 44,
+                originalValueIndex: 44,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum32AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                    string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))));
             enum32AsString.SetSentinelFromProviderValue("Default");
 
             var enum32AsStringArray = runtimeEntityType.AddProperty(
@@ -370,24 +2485,314 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum32AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum32[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringArray(instance) == null);
+            enum32AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32[] value) => ManyTypesUnsafeAccessors.Enum32AsStringArray(entity) = value);
+            enum32AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32[] value) => ManyTypesUnsafeAccessors.Enum32AsStringArray(entity) = value);
+            enum32AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray, 45),
+                CompiledModelTestBase.Enum32[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[45]);
+            enum32AsStringArray.SetPropertyIndexes(
+                index: 45,
+                originalValueIndex: 45,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum32AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringArrayElementType.TypeMapping = enum32AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum32AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum32AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum32> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(instance) == null);
+            enum32AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32> value) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(entity) = value);
+            enum32AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32> value) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(entity) = value);
+            enum32AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection, 46),
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[46]);
+            enum32AsStringCollection.SetPropertyIndexes(
+                index: 46,
+                originalValueIndex: 46,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum32AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                            string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringCollectionElementType.TypeMapping = enum32AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum32Collection = runtimeEntityType.AddProperty(
                 "Enum32Collection",
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum32Collection.SetGetter(
+                List<CompiledModelTestBase.Enum32> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32Collection(entity) == null,
+                List<CompiledModelTestBase.Enum32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32Collection(instance) == null);
+            enum32Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32> value) => ManyTypesUnsafeAccessors.Enum32Collection(entity) = value);
+            enum32Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32> value) => ManyTypesUnsafeAccessors.Enum32Collection(entity) = value);
+            enum32Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32>>(enum32Collection, 47),
+                List<CompiledModelTestBase.Enum32> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[47]);
+            enum32Collection.SetPropertyIndexes(
+                index: 47,
+                originalValueIndex: 47,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum32Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum32),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32CollectionElementType.TypeMapping = enum32Collection.TypeMapping.ElementTypeMapping;
 
             var enum32NestedCollection = runtimeEntityType.AddProperty(
                 "Enum32NestedCollection",
                 typeof(List<CompiledModelTestBase.Enum32>[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum32NestedCollection.SetGetter(
+                List<CompiledModelTestBase.Enum32>[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum32NestedCollection(entity) == null,
+                List<CompiledModelTestBase.Enum32>[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum32NestedCollection(instance) == null);
+            enum32NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32>[][] value) => ManyTypesUnsafeAccessors.Enum32NestedCollection(entity) = value);
+            enum32NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32>[][] value) => ManyTypesUnsafeAccessors.Enum32NestedCollection(entity) = value);
+            enum32NestedCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum32>[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32>[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32>[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32>[][]>(enum32NestedCollection, 48),
+                List<CompiledModelTestBase.Enum32>[][] (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32>[][]>(enum32NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[48]);
+            enum32NestedCollection.SetPropertyIndexes(
+                index: 48,
+                originalValueIndex: 48,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum32NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<CompiledModelTestBase.Enum32>[][], List<CompiledModelTestBase.Enum32>[]>(new ConvertingValueComparer<List<CompiledModelTestBase.Enum32>[], object>(new ListOfReferenceTypesComparer<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(new ConvertingValueComparer<List<CompiledModelTestBase.Enum32>, IEnumerable<CompiledModelTestBase.Enum32>>(new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)))))),
+                keyComparer: new ListOfReferenceTypesComparer<List<CompiledModelTestBase.Enum32>[][], List<CompiledModelTestBase.Enum32>[]>(new ConvertingValueComparer<List<CompiledModelTestBase.Enum32>[], object>(new ListOfReferenceTypesComparer<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(new ConvertingValueComparer<List<CompiledModelTestBase.Enum32>, IEnumerable<CompiledModelTestBase.Enum32>>(new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<List<CompiledModelTestBase.Enum32>[]>(new JsonCollectionOfReferencesReaderWriter<List<CompiledModelTestBase.Enum32>[][], List<CompiledModelTestBase.Enum32>[]>(
+                    new JsonCollectionOfReferencesReaderWriter<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(
+                        new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<CompiledModelTestBase.Enum32>[][], List<CompiledModelTestBase.Enum32>[]>(
+                    new JsonCollectionOfReferencesReaderWriter<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(
+                        new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(new ConvertingValueComparer<List<CompiledModelTestBase.Enum32>, IEnumerable<CompiledModelTestBase.Enum32>>(new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)))),
+                    keyComparer: new ListOfReferenceTypesComparer<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(new ConvertingValueComparer<List<CompiledModelTestBase.Enum32>, IEnumerable<CompiledModelTestBase.Enum32>>(new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<List<CompiledModelTestBase.Enum32>>(new JsonCollectionOfReferencesReaderWriter<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(
+                        new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance))),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<CompiledModelTestBase.Enum32>[], List<CompiledModelTestBase.Enum32>>(
+                        new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                            bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                        keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                            bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v)),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                        jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum32>, CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                        elementMapping: InMemoryTypeMapping.Default.Clone(
+                            comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                                bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                                int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                                CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                            keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                                bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                                int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                                CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                            providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                                bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                                int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                                CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                            clrType: typeof(CompiledModelTestBase.Enum32),
+                            jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance))));
+            var enum32NestedCollectionElementType = enum32NestedCollection.SetElementType(typeof(List<CompiledModelTestBase.Enum32>[]));
+            enum32NestedCollectionElementType.TypeMapping = enum32NestedCollection.TypeMapping.ElementTypeMapping;
 
             var enum64 = runtimeEntityType.AddProperty(
                 "Enum64",
@@ -395,12 +2800,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.Enum64.Default);
+            enum64.SetGetter(
+                CompiledModelTestBase.Enum64 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum64(entity))), ((object)(CompiledModelTestBase.Enum64.Default))),
+                CompiledModelTestBase.Enum64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum64(instance))), ((object)(CompiledModelTestBase.Enum64.Default))));
+            enum64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64 value) => ManyTypesUnsafeAccessors.Enum64(entity) = value);
+            enum64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64 value) => ManyTypesUnsafeAccessors.Enum64(entity) = value);
+            enum64.SetAccessors(
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64>(enum64, 49),
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64),
+                object (ValueBuffer valueBuffer) => valueBuffer[49]);
+            enum64.SetPropertyIndexes(
+                index: 49,
+                originalValueIndex: 49,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum64),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance);
 
             var enum64Array = runtimeEntityType.AddProperty(
                 "Enum64Array",
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum64Array.SetGetter(
+                CompiledModelTestBase.Enum64[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64Array(entity) == null,
+                CompiledModelTestBase.Enum64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Array(instance) == null);
+            enum64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64[] value) => ManyTypesUnsafeAccessors.Enum64Array(entity) = value);
+            enum64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64[] value) => ManyTypesUnsafeAccessors.Enum64Array(entity) = value);
+            enum64Array.SetAccessors(
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64[]>(enum64Array, 50),
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[50]);
+            enum64Array.SetPropertyIndexes(
+                index: 50,
+                originalValueIndex: 50,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum64),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64ArrayElementType.TypeMapping = enum64Array.TypeMapping.ElementTypeMapping;
 
             var enum64AsString = runtimeEntityType.AddProperty(
                 "Enum64AsString",
@@ -408,6 +2904,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enum64AsString.SetGetter(
+                CompiledModelTestBase.Enum64 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum64AsString(entity))), ((object)(CompiledModelTestBase.Enum64.Default))),
+                CompiledModelTestBase.Enum64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum64AsString(instance))), ((object)(CompiledModelTestBase.Enum64.Default))));
+            enum64AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64 value) => ManyTypesUnsafeAccessors.Enum64AsString(entity) = value);
+            enum64AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64 value) => ManyTypesUnsafeAccessors.Enum64AsString(entity) = value);
+            enum64AsString.SetAccessors(
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64>(enum64AsString, 51),
+                CompiledModelTestBase.Enum64 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[51]);
+            enum64AsString.SetPropertyIndexes(
+                index: 51,
+                originalValueIndex: 51,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum64AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                    string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                        string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))));
             enum64AsString.SetSentinelFromProviderValue("Default");
 
             var enum64AsStringArray = runtimeEntityType.AddProperty(
@@ -415,18 +2953,213 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum64AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum64[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringArray(instance) == null);
+            enum64AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64[] value) => ManyTypesUnsafeAccessors.Enum64AsStringArray(entity) = value);
+            enum64AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64[] value) => ManyTypesUnsafeAccessors.Enum64AsStringArray(entity) = value);
+            enum64AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray, 52),
+                CompiledModelTestBase.Enum64[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[52]);
+            enum64AsStringArray.SetPropertyIndexes(
+                index: 52,
+                originalValueIndex: 52,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum64AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                        string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringArrayElementType.TypeMapping = enum64AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum64AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum64AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum64> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(instance) == null);
+            enum64AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64> value) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(entity) = value);
+            enum64AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64> value) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(entity) = value);
+            enum64AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection, 53),
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[53]);
+            enum64AsStringCollection.SetPropertyIndexes(
+                index: 53,
+                originalValueIndex: 53,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum64AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                        string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum64, string>(
+                            string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringCollectionElementType.TypeMapping = enum64AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum64Collection = runtimeEntityType.AddProperty(
                 "Enum64Collection",
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum64Collection.SetGetter(
+                List<CompiledModelTestBase.Enum64> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum64Collection(entity) == null,
+                List<CompiledModelTestBase.Enum64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum64Collection(instance) == null);
+            enum64Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64> value) => ManyTypesUnsafeAccessors.Enum64Collection(entity) = value);
+            enum64Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64> value) => ManyTypesUnsafeAccessors.Enum64Collection(entity) = value);
+            enum64Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64>>(enum64Collection, 54),
+                List<CompiledModelTestBase.Enum64> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[54]);
+            enum64Collection.SetPropertyIndexes(
+                index: 54,
+                originalValueIndex: 54,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum64Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum64),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64CollectionElementType.TypeMapping = enum64Collection.TypeMapping.ElementTypeMapping;
 
             var enum8 = runtimeEntityType.AddProperty(
                 "Enum8",
@@ -434,12 +3167,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.Enum8.Default);
+            enum8.SetGetter(
+                CompiledModelTestBase.Enum8 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum8(entity))), ((object)(CompiledModelTestBase.Enum8.Default))),
+                CompiledModelTestBase.Enum8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum8(instance))), ((object)(CompiledModelTestBase.Enum8.Default))));
+            enum8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8 value) => ManyTypesUnsafeAccessors.Enum8(entity) = value);
+            enum8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8 value) => ManyTypesUnsafeAccessors.Enum8(entity) = value);
+            enum8.SetAccessors(
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8>(enum8, 55),
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8),
+                object (ValueBuffer valueBuffer) => valueBuffer[55]);
+            enum8.SetPropertyIndexes(
+                index: 55,
+                originalValueIndex: 55,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum8),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance);
 
             var enum8Array = runtimeEntityType.AddProperty(
                 "Enum8Array",
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum8Array.SetGetter(
+                CompiledModelTestBase.Enum8[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8Array(entity) == null,
+                CompiledModelTestBase.Enum8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Array(instance) == null);
+            enum8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8[] value) => ManyTypesUnsafeAccessors.Enum8Array(entity) = value);
+            enum8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8[] value) => ManyTypesUnsafeAccessors.Enum8Array(entity) = value);
+            enum8Array.SetAccessors(
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8[]>(enum8Array, 56),
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[56]);
+            enum8Array.SetPropertyIndexes(
+                index: 56,
+                originalValueIndex: 56,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum8),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8ArrayElementType.TypeMapping = enum8Array.TypeMapping.ElementTypeMapping;
 
             var enum8AsString = runtimeEntityType.AddProperty(
                 "Enum8AsString",
@@ -447,6 +3271,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enum8AsString.SetGetter(
+                CompiledModelTestBase.Enum8 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum8AsString(entity))), ((object)(CompiledModelTestBase.Enum8.Default))),
+                CompiledModelTestBase.Enum8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.Enum8AsString(instance))), ((object)(CompiledModelTestBase.Enum8.Default))));
+            enum8AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8 value) => ManyTypesUnsafeAccessors.Enum8AsString(entity) = value);
+            enum8AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8 value) => ManyTypesUnsafeAccessors.Enum8AsString(entity) = value);
+            enum8AsString.SetAccessors(
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8>(enum8AsString, 57),
+                CompiledModelTestBase.Enum8 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[57]);
+            enum8AsString.SetPropertyIndexes(
+                index: 57,
+                originalValueIndex: 57,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum8AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                    string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                        string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))));
             enum8AsString.SetSentinelFromProviderValue("Default");
 
             var enum8AsStringArray = runtimeEntityType.AddProperty(
@@ -454,24 +3320,293 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum8AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum8[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringArray(instance) == null);
+            enum8AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8[] value) => ManyTypesUnsafeAccessors.Enum8AsStringArray(entity) = value);
+            enum8AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8[] value) => ManyTypesUnsafeAccessors.Enum8AsStringArray(entity) = value);
+            enum8AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray, 58),
+                CompiledModelTestBase.Enum8[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[58]);
+            enum8AsStringArray.SetPropertyIndexes(
+                index: 58,
+                originalValueIndex: 58,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum8AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                        string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringArrayElementType.TypeMapping = enum8AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum8AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum8AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum8> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(instance) == null);
+            enum8AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8> value) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(entity) = value);
+            enum8AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8> value) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(entity) = value);
+            enum8AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection, 59),
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[59]);
+            enum8AsStringCollection.SetPropertyIndexes(
+                index: 59,
+                originalValueIndex: 59,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum8AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                        string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.Enum8, string>(
+                            string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringCollectionElementType.TypeMapping = enum8AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum8Collection = runtimeEntityType.AddProperty(
                 "Enum8Collection",
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum8Collection.SetGetter(
+                List<CompiledModelTestBase.Enum8> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8Collection(entity) == null,
+                List<CompiledModelTestBase.Enum8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8Collection(instance) == null);
+            enum8Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8> value) => ManyTypesUnsafeAccessors.Enum8Collection(entity) = value);
+            enum8Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8> value) => ManyTypesUnsafeAccessors.Enum8Collection(entity) = value);
+            enum8Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8>>(enum8Collection, 60),
+                List<CompiledModelTestBase.Enum8> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[60]);
+            enum8Collection.SetPropertyIndexes(
+                index: 60,
+                originalValueIndex: 60,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum8Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum8),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8CollectionElementType.TypeMapping = enum8Collection.TypeMapping.ElementTypeMapping;
 
             var enum8NestedCollection = runtimeEntityType.AddProperty(
                 "Enum8NestedCollection",
                 typeof(CompiledModelTestBase.Enum8[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enum8NestedCollection.SetGetter(
+                CompiledModelTestBase.Enum8[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Enum8NestedCollection(entity) == null,
+                CompiledModelTestBase.Enum8[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Enum8NestedCollection(instance) == null);
+            enum8NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8[][] value) => ManyTypesUnsafeAccessors.Enum8NestedCollection(entity) = value);
+            enum8NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8[][] value) => ManyTypesUnsafeAccessors.Enum8NestedCollection(entity) = value);
+            enum8NestedCollection.SetAccessors(
+                CompiledModelTestBase.Enum8[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Enum8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8[][]>(enum8NestedCollection, 61),
+                CompiledModelTestBase.Enum8[][] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8[][]>(enum8NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[61]);
+            enum8NestedCollection.SetPropertyIndexes(
+                index: 61,
+                originalValueIndex: 61,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum8NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum8[][], CompiledModelTestBase.Enum8[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum8[], IEnumerable<CompiledModelTestBase.Enum8>>(new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum8[][], CompiledModelTestBase.Enum8[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum8[], IEnumerable<CompiledModelTestBase.Enum8>>(new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8[]>(new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum8[][], CompiledModelTestBase.Enum8[]>(
+                    new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum8[][], CompiledModelTestBase.Enum8[]>(
+                    new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                    keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                            bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                        keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                            bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                        providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                            bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                        clrType: typeof(CompiledModelTestBase.Enum8),
+                        jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)));
+            var enum8NestedCollectionElementType = enum8NestedCollection.SetElementType(typeof(CompiledModelTestBase.Enum8[]));
+            enum8NestedCollectionElementType.TypeMapping = enum8NestedCollection.TypeMapping.ElementTypeMapping;
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                 "EnumToNumberConverterProperty",
@@ -479,6 +3614,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumToNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumToNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new EnumToNumberConverter<CompiledModelTestBase.Enum32, int>());
+            enumToNumberConverterProperty.SetGetter(
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(entity))), ((object)(CompiledModelTestBase.Enum32.Default))),
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
+            enumToNumberConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(entity) = value);
+            enumToNumberConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(entity) = value);
+            enumToNumberConverterProperty.SetAccessors(
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumToNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enumToNumberConverterProperty, 62),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToNumberConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[62]);
+            enumToNumberConverterProperty.SetPropertyIndexes(
+                index: 62,
+                originalValueIndex: 62,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumToNumberConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.Enum32, int>(
+                    int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
+                    CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, int>(
+                    JsonInt32ReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.Enum32, int>(
+                        int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
+                        CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value)))));
             enumToNumberConverterProperty.SetSentinelFromProviderValue(0);
 
             var enumToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -487,6 +3664,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new EnumToStringConverter<CompiledModelTestBase.Enum32>());
+            enumToStringConverterProperty.SetGetter(
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumToStringConverterProperty(entity))), ((object)(CompiledModelTestBase.Enum32.Default))),
+                CompiledModelTestBase.Enum32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumToStringConverterProperty(instance))), ((object)(CompiledModelTestBase.Enum32.Default))));
+            enumToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(entity) = value);
+            enumToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32 value) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(entity) = value);
+            enumToStringConverterProperty.SetAccessors(
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32>(enumToStringConverterProperty, 63),
+                CompiledModelTestBase.Enum32 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[63]);
+            enumToStringConverterProperty.SetPropertyIndexes(
+                index: 63,
+                originalValueIndex: 63,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                    string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.Enum32, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.Enum32, string>(
+                        string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v))));
             enumToStringConverterProperty.SetSentinelFromProviderValue("Default");
 
             var enumU16 = runtimeEntityType.AddProperty(
@@ -495,12 +3714,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.EnumU16.Min);
+            enumU16.SetGetter(
+                CompiledModelTestBase.EnumU16 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU16(entity))), ((object)(CompiledModelTestBase.EnumU16.Min))),
+                CompiledModelTestBase.EnumU16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU16(instance))), ((object)(CompiledModelTestBase.EnumU16.Min))));
+            enumU16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16 value) => ManyTypesUnsafeAccessors.EnumU16(entity) = value);
+            enumU16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16 value) => ManyTypesUnsafeAccessors.EnumU16(entity) = value);
+            enumU16.SetAccessors(
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16>(enumU16, 64),
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16),
+                object (ValueBuffer valueBuffer) => valueBuffer[64]);
+            enumU16.SetPropertyIndexes(
+                index: 64,
+                originalValueIndex: 64,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU16),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance);
 
             var enumU16Array = runtimeEntityType.AddProperty(
                 "EnumU16Array",
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU16Array.SetGetter(
+                CompiledModelTestBase.EnumU16[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16Array(entity) == null,
+                CompiledModelTestBase.EnumU16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Array(instance) == null);
+            enumU16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16[] value) => ManyTypesUnsafeAccessors.EnumU16Array(entity) = value);
+            enumU16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16[] value) => ManyTypesUnsafeAccessors.EnumU16Array(entity) = value);
+            enumU16Array.SetAccessors(
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16[]>(enumU16Array, 65),
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[65]);
+            enumU16Array.SetPropertyIndexes(
+                index: 65,
+                originalValueIndex: 65,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU16),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16ArrayElementType.TypeMapping = enumU16Array.TypeMapping.ElementTypeMapping;
 
             var enumU16AsString = runtimeEntityType.AddProperty(
                 "EnumU16AsString",
@@ -508,6 +3818,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enumU16AsString.SetGetter(
+                CompiledModelTestBase.EnumU16 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU16AsString(entity))), ((object)(CompiledModelTestBase.EnumU16.Min))),
+                CompiledModelTestBase.EnumU16 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU16AsString(instance))), ((object)(CompiledModelTestBase.EnumU16.Min))));
+            enumU16AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16 value) => ManyTypesUnsafeAccessors.EnumU16AsString(entity) = value);
+            enumU16AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16 value) => ManyTypesUnsafeAccessors.EnumU16AsString(entity) = value);
+            enumU16AsString.SetAccessors(
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16>(enumU16AsString, 66),
+                CompiledModelTestBase.EnumU16 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[66]);
+            enumU16AsString.SetPropertyIndexes(
+                index: 66,
+                originalValueIndex: 66,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU16AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                    string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                        string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))));
             enumU16AsString.SetSentinelFromProviderValue("Min");
 
             var enumU16AsStringArray = runtimeEntityType.AddProperty(
@@ -515,18 +3867,213 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU16AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU16[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU16[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(instance) == null);
+            enumU16AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16[] value) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(entity) = value);
+            enumU16AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16[] value) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(entity) = value);
+            enumU16AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray, 67),
+                CompiledModelTestBase.EnumU16[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[67]);
+            enumU16AsStringArray.SetPropertyIndexes(
+                index: 67,
+                originalValueIndex: 67,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU16AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                        string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringArrayElementType.TypeMapping = enumU16AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU16AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU16AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU16> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(instance) == null);
+            enumU16AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16> value) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(entity) = value);
+            enumU16AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16> value) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(entity) = value);
+            enumU16AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection, 68),
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[68]);
+            enumU16AsStringCollection.SetPropertyIndexes(
+                index: 68,
+                originalValueIndex: 68,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU16AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                        string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU16, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU16, string>(
+                            string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringCollectionElementType.TypeMapping = enumU16AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU16Collection = runtimeEntityType.AddProperty(
                 "EnumU16Collection",
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU16Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU16> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU16Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU16> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU16Collection(instance) == null);
+            enumU16Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16> value) => ManyTypesUnsafeAccessors.EnumU16Collection(entity) = value);
+            enumU16Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16> value) => ManyTypesUnsafeAccessors.EnumU16Collection(entity) = value);
+            enumU16Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection, 69),
+                List<CompiledModelTestBase.EnumU16> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[69]);
+            enumU16Collection.SetPropertyIndexes(
+                index: 69,
+                originalValueIndex: 69,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU16Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU16),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16CollectionElementType.TypeMapping = enumU16Collection.TypeMapping.ElementTypeMapping;
 
             var enumU32 = runtimeEntityType.AddProperty(
                 "EnumU32",
@@ -534,12 +4081,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.EnumU32.Min);
+            enumU32.SetGetter(
+                CompiledModelTestBase.EnumU32 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU32(entity))), ((object)(CompiledModelTestBase.EnumU32.Min))),
+                CompiledModelTestBase.EnumU32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU32(instance))), ((object)(CompiledModelTestBase.EnumU32.Min))));
+            enumU32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32 value) => ManyTypesUnsafeAccessors.EnumU32(entity) = value);
+            enumU32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32 value) => ManyTypesUnsafeAccessors.EnumU32(entity) = value);
+            enumU32.SetAccessors(
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32>(enumU32, 70),
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32),
+                object (ValueBuffer valueBuffer) => valueBuffer[70]);
+            enumU32.SetPropertyIndexes(
+                index: 70,
+                originalValueIndex: 70,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU32),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance);
 
             var enumU32Array = runtimeEntityType.AddProperty(
                 "EnumU32Array",
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU32Array.SetGetter(
+                CompiledModelTestBase.EnumU32[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32Array(entity) == null,
+                CompiledModelTestBase.EnumU32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Array(instance) == null);
+            enumU32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32[] value) => ManyTypesUnsafeAccessors.EnumU32Array(entity) = value);
+            enumU32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32[] value) => ManyTypesUnsafeAccessors.EnumU32Array(entity) = value);
+            enumU32Array.SetAccessors(
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32[]>(enumU32Array, 71),
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[71]);
+            enumU32Array.SetPropertyIndexes(
+                index: 71,
+                originalValueIndex: 71,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU32),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32ArrayElementType.TypeMapping = enumU32Array.TypeMapping.ElementTypeMapping;
 
             var enumU32AsString = runtimeEntityType.AddProperty(
                 "EnumU32AsString",
@@ -547,6 +4185,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enumU32AsString.SetGetter(
+                CompiledModelTestBase.EnumU32 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU32AsString(entity))), ((object)(CompiledModelTestBase.EnumU32.Min))),
+                CompiledModelTestBase.EnumU32 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU32AsString(instance))), ((object)(CompiledModelTestBase.EnumU32.Min))));
+            enumU32AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32 value) => ManyTypesUnsafeAccessors.EnumU32AsString(entity) = value);
+            enumU32AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32 value) => ManyTypesUnsafeAccessors.EnumU32AsString(entity) = value);
+            enumU32AsString.SetAccessors(
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32>(enumU32AsString, 72),
+                CompiledModelTestBase.EnumU32 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[72]);
+            enumU32AsString.SetPropertyIndexes(
+                index: 72,
+                originalValueIndex: 72,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU32AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                    string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                        string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))));
             enumU32AsString.SetSentinelFromProviderValue("Min");
 
             var enumU32AsStringArray = runtimeEntityType.AddProperty(
@@ -554,31 +4234,317 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU32AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU32[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU32[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(instance) == null);
+            enumU32AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32[] value) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(entity) = value);
+            enumU32AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32[] value) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(entity) = value);
+            enumU32AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray, 73),
+                CompiledModelTestBase.EnumU32[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[73]);
+            enumU32AsStringArray.SetPropertyIndexes(
+                index: 73,
+                originalValueIndex: 73,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU32AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                        string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringArrayElementType.TypeMapping = enumU32AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU32AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU32AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU32> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(instance) == null);
+            enumU32AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32> value) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(entity) = value);
+            enumU32AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32> value) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(entity) = value);
+            enumU32AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection, 74),
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[74]);
+            enumU32AsStringCollection.SetPropertyIndexes(
+                index: 74,
+                originalValueIndex: 74,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU32AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                        string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU32, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU32, string>(
+                            string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringCollectionElementType.TypeMapping = enumU32AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU32Collection = runtimeEntityType.AddProperty(
                 "EnumU32Collection",
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
-
-            var enumU64 = runtimeEntityType.AddProperty(
-                "EnumU64",
+            enumU32Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU32> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU32Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU32> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU32Collection(instance) == null);
+            enumU32Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32> value) => ManyTypesUnsafeAccessors.EnumU32Collection(entity) = value);
+            enumU32Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32> value) => ManyTypesUnsafeAccessors.EnumU32Collection(entity) = value);
+            enumU32Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection, 75),
+                List<CompiledModelTestBase.EnumU32> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[75]);
+            enumU32Collection.SetPropertyIndexes(
+                index: 75,
+                originalValueIndex: 75,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU32Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU32),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32CollectionElementType.TypeMapping = enumU32Collection.TypeMapping.ElementTypeMapping;
+
+            var enumU64 = runtimeEntityType.AddProperty(
+                "EnumU64",
                 typeof(CompiledModelTestBase.EnumU64),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.EnumU64.Min);
+            enumU64.SetGetter(
+                CompiledModelTestBase.EnumU64 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU64(entity))), ((object)(CompiledModelTestBase.EnumU64.Min))),
+                CompiledModelTestBase.EnumU64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU64(instance))), ((object)(CompiledModelTestBase.EnumU64.Min))));
+            enumU64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64 value) => ManyTypesUnsafeAccessors.EnumU64(entity) = value);
+            enumU64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64 value) => ManyTypesUnsafeAccessors.EnumU64(entity) = value);
+            enumU64.SetAccessors(
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64>(enumU64, 76),
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64),
+                object (ValueBuffer valueBuffer) => valueBuffer[76]);
+            enumU64.SetPropertyIndexes(
+                index: 76,
+                originalValueIndex: 76,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU64),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance);
 
             var enumU64Array = runtimeEntityType.AddProperty(
                 "EnumU64Array",
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU64Array.SetGetter(
+                CompiledModelTestBase.EnumU64[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64Array(entity) == null,
+                CompiledModelTestBase.EnumU64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Array(instance) == null);
+            enumU64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64[] value) => ManyTypesUnsafeAccessors.EnumU64Array(entity) = value);
+            enumU64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64[] value) => ManyTypesUnsafeAccessors.EnumU64Array(entity) = value);
+            enumU64Array.SetAccessors(
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64[]>(enumU64Array, 77),
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[77]);
+            enumU64Array.SetPropertyIndexes(
+                index: 77,
+                originalValueIndex: 77,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU64),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64ArrayElementType.TypeMapping = enumU64Array.TypeMapping.ElementTypeMapping;
 
             var enumU64AsString = runtimeEntityType.AddProperty(
                 "EnumU64AsString",
@@ -586,6 +4552,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enumU64AsString.SetGetter(
+                CompiledModelTestBase.EnumU64 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU64AsString(entity))), ((object)(CompiledModelTestBase.EnumU64.Min))),
+                CompiledModelTestBase.EnumU64 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU64AsString(instance))), ((object)(CompiledModelTestBase.EnumU64.Min))));
+            enumU64AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64 value) => ManyTypesUnsafeAccessors.EnumU64AsString(entity) = value);
+            enumU64AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64 value) => ManyTypesUnsafeAccessors.EnumU64AsString(entity) = value);
+            enumU64AsString.SetAccessors(
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64>(enumU64AsString, 78),
+                CompiledModelTestBase.EnumU64 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[78]);
+            enumU64AsString.SetPropertyIndexes(
+                index: 78,
+                originalValueIndex: 78,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU64AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                    string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                        string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))));
             enumU64AsString.SetSentinelFromProviderValue("Min");
 
             var enumU64AsStringArray = runtimeEntityType.AddProperty(
@@ -593,24 +4601,293 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU64AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU64[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU64[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(instance) == null);
+            enumU64AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64[] value) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(entity) = value);
+            enumU64AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64[] value) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(entity) = value);
+            enumU64AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray, 79),
+                CompiledModelTestBase.EnumU64[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[79]);
+            enumU64AsStringArray.SetPropertyIndexes(
+                index: 79,
+                originalValueIndex: 79,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU64AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                        string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringArrayElementType.TypeMapping = enumU64AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU64AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU64AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU64> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(instance) == null);
+            enumU64AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64> value) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(entity) = value);
+            enumU64AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64> value) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(entity) = value);
+            enumU64AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection, 80),
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[80]);
+            enumU64AsStringCollection.SetPropertyIndexes(
+                index: 80,
+                originalValueIndex: 80,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU64AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                        string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU64, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU64, string>(
+                            string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringCollectionElementType.TypeMapping = enumU64AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU64Collection = runtimeEntityType.AddProperty(
                 "EnumU64Collection",
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU64Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU64> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU64> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64Collection(instance) == null);
+            enumU64Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64> value) => ManyTypesUnsafeAccessors.EnumU64Collection(entity) = value);
+            enumU64Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64> value) => ManyTypesUnsafeAccessors.EnumU64Collection(entity) = value);
+            enumU64Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection, 81),
+                List<CompiledModelTestBase.EnumU64> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[81]);
+            enumU64Collection.SetPropertyIndexes(
+                index: 81,
+                originalValueIndex: 81,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU64Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU64),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64CollectionElementType.TypeMapping = enumU64Collection.TypeMapping.ElementTypeMapping;
 
             var enumU64NestedCollection = runtimeEntityType.AddProperty(
                 "EnumU64NestedCollection",
                 typeof(CompiledModelTestBase.EnumU64[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU64NestedCollection.SetGetter(
+                CompiledModelTestBase.EnumU64[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(entity) == null,
+                CompiledModelTestBase.EnumU64[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(instance) == null);
+            enumU64NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64[][] value) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(entity) = value);
+            enumU64NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64[][] value) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(entity) = value);
+            enumU64NestedCollection.SetAccessors(
+                CompiledModelTestBase.EnumU64[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64[][]>(enumU64NestedCollection, 82),
+                CompiledModelTestBase.EnumU64[][] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64[][]>(enumU64NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[82]);
+            enumU64NestedCollection.SetPropertyIndexes(
+                index: 82,
+                originalValueIndex: 82,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU64NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.EnumU64[][], CompiledModelTestBase.EnumU64[]>(new ConvertingValueComparer<CompiledModelTestBase.EnumU64[], IEnumerable<CompiledModelTestBase.EnumU64>>(new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.EnumU64[][], CompiledModelTestBase.EnumU64[]>(new ConvertingValueComparer<CompiledModelTestBase.EnumU64[], IEnumerable<CompiledModelTestBase.EnumU64>>(new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64[]>(new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.EnumU64[][], CompiledModelTestBase.EnumU64[]>(
+                    new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.EnumU64[][], CompiledModelTestBase.EnumU64[]>(
+                    new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                    keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                            bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                        keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                            bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                        providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                            bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                        clrType: typeof(CompiledModelTestBase.EnumU64),
+                        jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)));
+            var enumU64NestedCollectionElementType = enumU64NestedCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64[]));
+            enumU64NestedCollectionElementType.TypeMapping = enumU64NestedCollection.TypeMapping.ElementTypeMapping;
 
             var enumU8 = runtimeEntityType.AddProperty(
                 "EnumU8",
@@ -618,12 +4895,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: CompiledModelTestBase.EnumU8.Min);
+            enumU8.SetGetter(
+                CompiledModelTestBase.EnumU8 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU8(entity))), ((object)(CompiledModelTestBase.EnumU8.Min))),
+                CompiledModelTestBase.EnumU8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU8(instance))), ((object)(CompiledModelTestBase.EnumU8.Min))));
+            enumU8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8 value) => ManyTypesUnsafeAccessors.EnumU8(entity) = value);
+            enumU8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8 value) => ManyTypesUnsafeAccessors.EnumU8(entity) = value);
+            enumU8.SetAccessors(
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8>(enumU8, 83),
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8),
+                object (ValueBuffer valueBuffer) => valueBuffer[83]);
+            enumU8.SetPropertyIndexes(
+                index: 83,
+                originalValueIndex: 83,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU8),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance);
 
             var enumU8Array = runtimeEntityType.AddProperty(
                 "EnumU8Array",
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU8Array.SetGetter(
+                CompiledModelTestBase.EnumU8[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8Array(entity) == null,
+                CompiledModelTestBase.EnumU8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Array(instance) == null);
+            enumU8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8[] value) => ManyTypesUnsafeAccessors.EnumU8Array(entity) = value);
+            enumU8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8[] value) => ManyTypesUnsafeAccessors.EnumU8Array(entity) = value);
+            enumU8Array.SetAccessors(
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8[]>(enumU8Array, 84),
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[84]);
+            enumU8Array.SetPropertyIndexes(
+                index: 84,
+                originalValueIndex: 84,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU8),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8ArrayElementType.TypeMapping = enumU8Array.TypeMapping.ElementTypeMapping;
 
             var enumU8AsString = runtimeEntityType.AddProperty(
                 "EnumU8AsString",
@@ -631,6 +4999,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 providerPropertyType: typeof(string));
+            enumU8AsString.SetGetter(
+                CompiledModelTestBase.EnumU8 (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU8AsString(entity))), ((object)(CompiledModelTestBase.EnumU8.Min))),
+                CompiledModelTestBase.EnumU8 (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => object.Equals(((object)(ManyTypesUnsafeAccessors.EnumU8AsString(instance))), ((object)(CompiledModelTestBase.EnumU8.Min))));
+            enumU8AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8 value) => ManyTypesUnsafeAccessors.EnumU8AsString(entity) = value);
+            enumU8AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8 value) => ManyTypesUnsafeAccessors.EnumU8AsString(entity) = value);
+            enumU8AsString.SetAccessors(
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8>(enumU8AsString, 85),
+                CompiledModelTestBase.EnumU8 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[85]);
+            enumU8AsString.SetPropertyIndexes(
+                index: 85,
+                originalValueIndex: 85,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU8AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                    string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                    CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                        string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))));
             enumU8AsString.SetSentinelFromProviderValue("Min");
 
             var enumU8AsStringArray = runtimeEntityType.AddProperty(
@@ -638,18 +5048,213 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU8AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU8[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU8[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(instance) == null);
+            enumU8AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8[] value) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(entity) = value);
+            enumU8AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8[] value) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(entity) = value);
+            enumU8AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray, 86),
+                CompiledModelTestBase.EnumU8[] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[86]);
+            enumU8AsStringArray.SetPropertyIndexes(
+                index: 86,
+                originalValueIndex: 86,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU8AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                        string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringArrayElementType.TypeMapping = enumU8AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU8AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU8AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU8> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(instance) == null);
+            enumU8AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8> value) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(entity) = value);
+            enumU8AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8> value) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(entity) = value);
+            enumU8AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection, 87),
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[87]);
+            enumU8AsStringCollection.SetPropertyIndexes(
+                index: 87,
+                originalValueIndex: 87,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU8AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
+                    new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                        string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                        CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CompiledModelTestBase.EnumU8, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<CompiledModelTestBase.EnumU8, string>(
+                            string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
+                            CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringCollectionElementType.TypeMapping = enumU8AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU8Collection = runtimeEntityType.AddProperty(
                 "EnumU8Collection",
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            enumU8Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU8> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.EnumU8Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU8> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.EnumU8Collection(instance) == null);
+            enumU8Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8> value) => ManyTypesUnsafeAccessors.EnumU8Collection(entity) = value);
+            enumU8Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8> value) => ManyTypesUnsafeAccessors.EnumU8Collection(entity) = value);
+            enumU8Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.EnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection, 88),
+                List<CompiledModelTestBase.EnumU8> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[88]);
+            enumU8Collection.SetPropertyIndexes(
+                index: 88,
+                originalValueIndex: 88,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enumU8Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8>(new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<CompiledModelTestBase.EnumU8>, CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU8),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8CollectionElementType.TypeMapping = enumU8Collection.TypeMapping.ElementTypeMapping;
 
             var @float = runtimeEntityType.AddProperty(
                 "Float",
@@ -657,12 +5262,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Float", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Float>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0f);
+            @float.SetGetter(
+                float (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Float(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Float(entity).Equals(0F),
+                float (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Float(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Float(instance).Equals(0F));
+            @float.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, float value) => ManyTypesUnsafeAccessors.Float(entity) = value);
+            @float.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, float value) => ManyTypesUnsafeAccessors.Float(entity) = value);
+            @float.SetAccessors(
+                float (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Float(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Float(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float (InternalEntityEntry entry) => entry.ReadOriginalValue<float>(@float, 89),
+                float (InternalEntityEntry entry) => entry.GetCurrentValue<float>(@float),
+                object (ValueBuffer valueBuffer) => valueBuffer[89]);
+            @float.SetPropertyIndexes(
+                index: 89,
+                originalValueIndex: 89,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            @float.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v),
+                keyComparer: new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v),
+                providerValueComparer: new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v),
+                clrType: typeof(float),
+                jsonValueReaderWriter: JsonFloatReaderWriter.Instance);
 
             var floatArray = runtimeEntityType.AddProperty(
                 "FloatArray",
                 typeof(float[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            floatArray.SetGetter(
+                float[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.FloatArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.FloatArray(entity) == null,
+                float[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.FloatArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.FloatArray(instance) == null);
+            floatArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, float[] value) => ManyTypesUnsafeAccessors.FloatArray(entity) = value);
+            floatArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, float[] value) => ManyTypesUnsafeAccessors.FloatArray(entity) = value);
+            floatArray.SetAccessors(
+                float[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.FloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.FloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float[] (InternalEntityEntry entry) => entry.ReadOriginalValue<float[]>(floatArray, 90),
+                float[] (InternalEntityEntry entry) => entry.GetCurrentValue<float[]>(floatArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[90]);
+            floatArray.SetPropertyIndexes(
+                index: 90,
+                originalValueIndex: 90,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            floatArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<float[], float>(new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v)),
+                keyComparer: new ListOfValueTypesComparer<float[], float>(new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<float>(new JsonCollectionOfStructsReaderWriter<float[], float>(
+                    JsonFloatReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<float[], float>(
+                    JsonFloatReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<float>(
+                        bool (float v1, float v2) => v1.Equals(v2),
+                        int (float v) => ((object)v).GetHashCode(),
+                        float (float v) => v),
+                    keyComparer: new ValueComparer<float>(
+                        bool (float v1, float v2) => v1.Equals(v2),
+                        int (float v) => ((object)v).GetHashCode(),
+                        float (float v) => v),
+                    providerValueComparer: new ValueComparer<float>(
+                        bool (float v1, float v2) => v1.Equals(v2),
+                        int (float v) => ((object)v).GetHashCode(),
+                        float (float v) => v),
+                    clrType: typeof(float),
+                    jsonValueReaderWriter: JsonFloatReaderWriter.Instance));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
+            floatArrayElementType.TypeMapping = floatArray.TypeMapping.ElementTypeMapping;
 
             var guid = runtimeEntityType.AddProperty(
                 "Guid",
@@ -670,18 +5366,204 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Guid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Guid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            guid.SetGetter(
+                Guid (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Guid(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Guid(entity) == new Guid("00000000-0000-0000-0000-000000000000"),
+                Guid (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Guid(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Guid(instance) == new Guid("00000000-0000-0000-0000-000000000000"));
+            guid.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid value) => ManyTypesUnsafeAccessors.Guid(entity) = value);
+            guid.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid value) => ManyTypesUnsafeAccessors.Guid(entity) = value);
+            guid.SetAccessors(
+                Guid (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Guid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Guid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(guid, 91),
+                Guid (InternalEntityEntry entry) => entry.GetCurrentValue<Guid>(guid),
+                object (ValueBuffer valueBuffer) => valueBuffer[91]);
+            guid.SetPropertyIndexes(
+                index: 91,
+                originalValueIndex: 91,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            guid.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
 
             var guidArray = runtimeEntityType.AddProperty(
                 "GuidArray",
                 typeof(Guid[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            guidArray.SetGetter(
+                Guid[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidArray(entity) == null,
+                Guid[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidArray(instance) == null);
+            guidArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid[] value) => ManyTypesUnsafeAccessors.GuidArray(entity) = value);
+            guidArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid[] value) => ManyTypesUnsafeAccessors.GuidArray(entity) = value);
+            guidArray.SetAccessors(
+                Guid[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid[] (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid[]>(guidArray, 92),
+                Guid[] (InternalEntityEntry entry) => entry.GetCurrentValue<Guid[]>(guidArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[92]);
+            guidArray.SetPropertyIndexes(
+                index: 92,
+                originalValueIndex: 92,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            guidArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v)),
+                keyComparer: new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                    JsonGuidReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                    JsonGuidReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v),
+                    keyComparer: new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v),
+                    providerValueComparer: new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v),
+                    clrType: typeof(Guid),
+                    jsonValueReaderWriter: JsonGuidReaderWriter.Instance));
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
+            guidArrayElementType.TypeMapping = guidArray.TypeMapping.ElementTypeMapping;
 
             var guidNestedCollection = runtimeEntityType.AddProperty(
                 "GuidNestedCollection",
                 typeof(ICollection<Guid[][]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            guidNestedCollection.SetGetter(
+                ICollection<Guid[][]> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidNestedCollection(entity) == null,
+                ICollection<Guid[][]> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidNestedCollection(instance) == null);
+            guidNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ICollection<Guid[][]> value) => ManyTypesUnsafeAccessors.GuidNestedCollection(entity) = value);
+            guidNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ICollection<Guid[][]> value) => ManyTypesUnsafeAccessors.GuidNestedCollection(entity) = value);
+            guidNestedCollection.SetAccessors(
+                ICollection<Guid[][]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ICollection<Guid[][]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ICollection<Guid[][]> (InternalEntityEntry entry) => entry.ReadOriginalValue<ICollection<Guid[][]>>(guidNestedCollection, 93),
+                ICollection<Guid[][]> (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<Guid[][]>>(guidNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[93]);
+            guidNestedCollection.SetPropertyIndexes(
+                index: 93,
+                originalValueIndex: 93,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            guidNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<Guid[][]>, Guid[][]>(new ConvertingValueComparer<Guid[][], object>(new ListOfReferenceTypesComparer<Guid[][], Guid[]>(new ConvertingValueComparer<Guid[], IEnumerable<Guid>>(new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v)))))),
+                keyComparer: new ListOfReferenceTypesComparer<List<Guid[][]>, Guid[][]>(new ConvertingValueComparer<Guid[][], object>(new ListOfReferenceTypesComparer<Guid[][], Guid[]>(new ConvertingValueComparer<Guid[], IEnumerable<Guid>>(new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v)))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<Guid[][]>(new JsonCollectionOfReferencesReaderWriter<List<Guid[][]>, Guid[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<Guid[][], Guid[]>(
+                        new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                            JsonGuidReaderWriter.Instance)))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<Guid[][]>, Guid[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<Guid[][], Guid[]>(
+                        new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                            JsonGuidReaderWriter.Instance))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<Guid[][], Guid[]>(new ConvertingValueComparer<Guid[], IEnumerable<Guid>>(new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v)))),
+                    keyComparer: new ListOfReferenceTypesComparer<Guid[][], Guid[]>(new ConvertingValueComparer<Guid[], IEnumerable<Guid>>(new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v)))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<Guid[]>(new JsonCollectionOfReferencesReaderWriter<Guid[][], Guid[]>(
+                        new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                            JsonGuidReaderWriter.Instance))),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<Guid[][], Guid[]>(
+                        new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                            JsonGuidReaderWriter.Instance)),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                            bool (Guid v1, Guid v2) => v1 == v2,
+                            int (Guid v) => ((object)v).GetHashCode(),
+                            Guid (Guid v) => v)),
+                        keyComparer: new ListOfValueTypesComparer<Guid[], Guid>(new ValueComparer<Guid>(
+                            bool (Guid v1, Guid v2) => v1 == v2,
+                            int (Guid v) => ((object)v).GetHashCode(),
+                            Guid (Guid v) => v)),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        converter: new CollectionToJsonStringConverter<Guid>(new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                            JsonGuidReaderWriter.Instance)),
+                        jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
+                            JsonGuidReaderWriter.Instance),
+                        elementMapping: InMemoryTypeMapping.Default.Clone(
+                            comparer: new ValueComparer<Guid>(
+                                bool (Guid v1, Guid v2) => v1 == v2,
+                                int (Guid v) => ((object)v).GetHashCode(),
+                                Guid (Guid v) => v),
+                            keyComparer: new ValueComparer<Guid>(
+                                bool (Guid v1, Guid v2) => v1 == v2,
+                                int (Guid v) => ((object)v).GetHashCode(),
+                                Guid (Guid v) => v),
+                            providerValueComparer: new ValueComparer<Guid>(
+                                bool (Guid v1, Guid v2) => v1 == v2,
+                                int (Guid v) => ((object)v).GetHashCode(),
+                                Guid (Guid v) => v),
+                            clrType: typeof(Guid),
+                            jsonValueReaderWriter: JsonGuidReaderWriter.Instance))));
+            var guidNestedCollectionElementType = guidNestedCollection.SetElementType(typeof(Guid[][]));
+            guidNestedCollectionElementType.TypeMapping = guidNestedCollection.TypeMapping.ElementTypeMapping;
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "GuidToBytesConverterProperty",
@@ -689,6 +5571,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new GuidToBytesConverter());
+            guidToBytesConverterProperty.SetGetter(
+                Guid (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(entity) == new Guid("00000000-0000-0000-0000-000000000000"),
+                Guid (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(instance) == new Guid("00000000-0000-0000-0000-000000000000"));
+            guidToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid value) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(entity) = value);
+            guidToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid value) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(entity) = value);
+            guidToBytesConverterProperty.SetAccessors(
+                Guid (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(guidToBytesConverterProperty, 94),
+                Guid (InternalEntityEntry entry) => entry.GetCurrentValue<Guid>(guidToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[94]);
+            guidToBytesConverterProperty.SetPropertyIndexes(
+                index: 94,
+                originalValueIndex: 94,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            guidToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<Guid, byte[]>(
+                    byte[] (Guid v) => v.ToByteArray(),
+                    Guid (byte[] v) => new Guid(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<Guid, byte[]>(
+                        byte[] (Guid v) => v.ToByteArray(),
+                        Guid (byte[] v) => new Guid(v))));
             guidToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
 
             var guidToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -697,6 +5621,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new GuidToStringConverter());
+            guidToStringConverterProperty.SetGetter(
+                Guid (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(entity) == new Guid("00000000-0000-0000-0000-000000000000"),
+                Guid (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(instance) == new Guid("00000000-0000-0000-0000-000000000000"));
+            guidToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid value) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(entity) = value);
+            guidToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid value) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(entity) = value);
+            guidToStringConverterProperty.SetAccessors(
+                Guid (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.GuidToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(guidToStringConverterProperty, 95),
+                Guid (InternalEntityEntry entry) => entry.GetCurrentValue<Guid>(guidToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[95]);
+            guidToStringConverterProperty.SetPropertyIndexes(
+                index: 95,
+                originalValueIndex: 95,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            guidToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<Guid, string>(
+                    string (Guid v) => v.ToString("D"),
+                    Guid (string v) => new Guid(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Guid, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<Guid, string>(
+                        string (Guid v) => v.ToString("D"),
+                        Guid (string v) => new Guid(v))));
             guidToStringConverterProperty.SetSentinelFromProviderValue("00000000-0000-0000-0000-000000000000");
 
             var iPAddress = runtimeEntityType.AddProperty(
@@ -704,12 +5670,199 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IPAddress),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            iPAddress.SetGetter(
+                IPAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddress(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddress(entity) == null,
+                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddress(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddress(instance) == null);
+            iPAddress.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.IPAddress(entity) = value);
+            iPAddress.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.IPAddress(entity) = value);
+            iPAddress.SetAccessors(
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress>(iPAddress, 96),
+                IPAddress (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress>(iPAddress),
+                object (ValueBuffer valueBuffer) => valueBuffer[96]);
+            iPAddress.SetPropertyIndexes(
+                index: 96,
+                originalValueIndex: 96,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            iPAddress.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                keyComparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<IPAddress, string>(
+                    string (IPAddress v) => ((object)v).ToString(),
+                    IPAddress (string v) => IPAddress.Parse(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v))));
 
             var iPAddressArray = runtimeEntityType.AddProperty(
                 "IPAddressArray",
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            iPAddressArray.SetGetter(
+                IPAddress[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddressArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddressArray(entity) == null,
+                IPAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressArray(instance) == null);
+            iPAddressArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress[] value) => ManyTypesUnsafeAccessors.IPAddressArray(entity) = value);
+            iPAddressArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress[] value) => ManyTypesUnsafeAccessors.IPAddressArray(entity) = value);
+            iPAddressArray.SetAccessors(
+                IPAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress[]>(iPAddressArray, 97),
+                IPAddress[] (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress[]>(iPAddressArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[97]);
+            iPAddressArray.SetPropertyIndexes(
+                index: 97,
+                originalValueIndex: 97,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            iPAddressArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
+            iPAddressArrayElementType.TypeMapping = iPAddressArray.TypeMapping.ElementTypeMapping;
+
+            var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
+                "IPAddressReadOnlyCollection",
+                typeof(IReadOnlyCollection<IPAddress>),
+                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
+                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_ipAddressReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            iPAddressReadOnlyCollection.SetGetter(
+                IReadOnlyCollection<IPAddress> (CompiledModelTestBase.ManyTypes entity) => (ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(entity) == null ? null : ((IReadOnlyCollection<IPAddress>)(ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(entity)))),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(entity) == null,
+                IReadOnlyCollection<IPAddress> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<IPAddress>)(ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance)))),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(instance) == null);
+            iPAddressReadOnlyCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<IPAddress> value) => ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(entity) = ((List<IPAddress>)(value)));
+            iPAddressReadOnlyCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<IPAddress> value) => ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(entity) = ((List<IPAddress>)(value)));
+            iPAddressReadOnlyCollection.SetAccessors(
+                IReadOnlyCollection<IPAddress> (InternalEntityEntry entry) => ((IReadOnlyCollection<IPAddress>)(ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<IPAddress> (InternalEntityEntry entry) => ((IReadOnlyCollection<IPAddress>)(ManyTypesUnsafeAccessors._ipAddressReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<IPAddress> (InternalEntityEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection, 98),
+                IReadOnlyCollection<IPAddress> (InternalEntityEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[98]);
+            iPAddressReadOnlyCollection.SetPropertyIndexes(
+                index: 98,
+                originalValueIndex: 98,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            iPAddressReadOnlyCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
+            iPAddressReadOnlyCollectionElementType.TypeMapping = iPAddressReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IPAddressToBytesConverterProperty",
@@ -717,6 +5870,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new IPAddressToBytesConverter());
+            iPAddressToBytesConverterProperty.SetGetter(
+                IPAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(entity) == null,
+                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(instance) == null);
+            iPAddressToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(entity) = value);
+            iPAddressToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(entity) = value);
+            iPAddressToBytesConverterProperty.SetAccessors(
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress>(iPAddressToBytesConverterProperty, 99),
+                IPAddress (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress>(iPAddressToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[99]);
+            iPAddressToBytesConverterProperty.SetPropertyIndexes(
+                index: 99,
+                originalValueIndex: 99,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            iPAddressToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                keyComparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<IPAddress, byte[]>(
+                    byte[] (IPAddress v) => v.GetAddressBytes(),
+                    IPAddress (byte[] v) => new IPAddress(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<IPAddress, byte[]>(
+                        byte[] (IPAddress v) => v.GetAddressBytes(),
+                        IPAddress (byte[] v) => new IPAddress(v))));
 
             var iPAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                 "IPAddressToStringConverterProperty",
@@ -724,6 +5919,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new IPAddressToStringConverter());
+            iPAddressToStringConverterProperty.SetGetter(
+                IPAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(entity) == null,
+                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(instance) == null);
+            iPAddressToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(entity) = value);
+            iPAddressToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(entity) = value);
+            iPAddressToStringConverterProperty.SetAccessors(
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IPAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress>(iPAddressToStringConverterProperty, 100),
+                IPAddress (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress>(iPAddressToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[100]);
+            iPAddressToStringConverterProperty.SetPropertyIndexes(
+                index: 100,
+                originalValueIndex: 100,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            iPAddressToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                keyComparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<IPAddress, string>(
+                    string (IPAddress v) => ((object)v).ToString(),
+                    IPAddress (string v) => IPAddress.Parse(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v))));
 
             var int16 = runtimeEntityType.AddProperty(
                 "Int16",
@@ -731,12 +5968,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: (short)0);
+            int16.SetGetter(
+                short (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int16(entity) == 0,
+                short (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16(instance) == 0);
+            int16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, short value) => ManyTypesUnsafeAccessors.Int16(entity) = value);
+            int16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, short value) => ManyTypesUnsafeAccessors.Int16(entity) = value);
+            int16.SetAccessors(
+                short (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short (InternalEntityEntry entry) => entry.ReadOriginalValue<short>(int16, 101),
+                short (InternalEntityEntry entry) => entry.GetCurrentValue<short>(int16),
+                object (ValueBuffer valueBuffer) => valueBuffer[101]);
+            int16.SetPropertyIndexes(
+                index: 101,
+                originalValueIndex: 101,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v),
+                keyComparer: new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v),
+                providerValueComparer: new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v),
+                clrType: typeof(short),
+                jsonValueReaderWriter: JsonInt16ReaderWriter.Instance);
 
             var int16Array = runtimeEntityType.AddProperty(
                 "Int16Array",
                 typeof(short[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int16Array.SetGetter(
+                short[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int16Array(entity) == null,
+                short[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int16Array(instance) == null);
+            int16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, short[] value) => ManyTypesUnsafeAccessors.Int16Array(entity) = value);
+            int16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, short[] value) => ManyTypesUnsafeAccessors.Int16Array(entity) = value);
+            int16Array.SetAccessors(
+                short[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short[] (InternalEntityEntry entry) => entry.ReadOriginalValue<short[]>(int16Array, 102),
+                short[] (InternalEntityEntry entry) => entry.GetCurrentValue<short[]>(int16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[102]);
+            int16Array.SetPropertyIndexes(
+                index: 102,
+                originalValueIndex: 102,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<short[], short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                keyComparer: new ListOfValueTypesComparer<short[], short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionOfStructsReaderWriter<short[], short>(
+                    JsonInt16ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<short[], short>(
+                    JsonInt16ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    keyComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    providerValueComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    clrType: typeof(short),
+                    jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
+            int16ArrayElementType.TypeMapping = int16Array.TypeMapping.ElementTypeMapping;
 
             var int32 = runtimeEntityType.AddProperty(
                 "Int32",
@@ -744,18 +6072,244 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0);
+            int32.SetGetter(
+                int (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int32(entity) == 0,
+                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32(instance) == 0);
+            int32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.Int32(entity) = value);
+            int32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.Int32(entity) = value);
+            int32.SetAccessors(
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(int32, 103),
+                int (InternalEntityEntry entry) => entry.GetCurrentValue<int>(int32),
+                object (ValueBuffer valueBuffer) => valueBuffer[103]);
+            int32.SetPropertyIndexes(
+                index: 103,
+                originalValueIndex: 103,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                clrType: typeof(int),
+                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);
 
             var int32Array = runtimeEntityType.AddProperty(
                 "Int32Array",
                 typeof(int[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int32Array.SetGetter(
+                int[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int32Array(entity) == null,
+                int[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32Array(instance) == null);
+            int32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int[] value) => ManyTypesUnsafeAccessors.Int32Array(entity) = value);
+            int32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int[] value) => ManyTypesUnsafeAccessors.Int32Array(entity) = value);
+            int32Array.SetAccessors(
+                int[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int[] (InternalEntityEntry entry) => entry.ReadOriginalValue<int[]>(int32Array, 104),
+                int[] (InternalEntityEntry entry) => entry.GetCurrentValue<int[]>(int32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[104]);
+            int32Array.SetPropertyIndexes(
+                index: 104,
+                originalValueIndex: 104,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v)),
+                keyComparer: new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionOfStructsReaderWriter<int[], int>(
+                    JsonInt32ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<int[], int>(
+                    JsonInt32ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    keyComparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    providerValueComparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    clrType: typeof(int),
+                    jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
+            int32ArrayElementType.TypeMapping = int32Array.TypeMapping.ElementTypeMapping;
 
             var int32NestedCollection = runtimeEntityType.AddProperty(
                 "Int32NestedCollection",
                 typeof(int[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int32NestedCollection.SetGetter(
+                int[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int32NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int32NestedCollection(entity) == null,
+                int[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int32NestedCollection(instance) == null);
+            int32NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int[][] value) => ManyTypesUnsafeAccessors.Int32NestedCollection(entity) = value);
+            int32NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int[][] value) => ManyTypesUnsafeAccessors.Int32NestedCollection(entity) = value);
+            int32NestedCollection.SetAccessors(
+                int[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<int[][]>(int32NestedCollection, 105),
+                int[][] (InternalEntityEntry entry) => entry.GetCurrentValue<int[][]>(int32NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[105]);
+            int32NestedCollection.SetPropertyIndexes(
+                index: 105,
+                originalValueIndex: 105,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int32NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<int[][], int[]>(new ConvertingValueComparer<int[], IEnumerable<int>>(new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<int[][], int[]>(new ConvertingValueComparer<int[], IEnumerable<int>>(new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<int[]>(new JsonCollectionOfReferencesReaderWriter<int[][], int[]>(
+                    new JsonCollectionOfStructsReaderWriter<int[], int>(
+                        JsonInt32ReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<int[][], int[]>(
+                    new JsonCollectionOfStructsReaderWriter<int[], int>(
+                        JsonInt32ReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v)),
+                    keyComparer: new ListOfValueTypesComparer<int[], int>(new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<int>(new JsonCollectionOfStructsReaderWriter<int[], int>(
+                        JsonInt32ReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<int[], int>(
+                        JsonInt32ReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<int>(
+                            bool (int v1, int v2) => v1 == v2,
+                            int (int v) => v,
+                            int (int v) => v),
+                        keyComparer: new ValueComparer<int>(
+                            bool (int v1, int v2) => v1 == v2,
+                            int (int v) => v,
+                            int (int v) => v),
+                        providerValueComparer: new ValueComparer<int>(
+                            bool (int v1, int v2) => v1 == v2,
+                            int (int v) => v,
+                            int (int v) => v),
+                        clrType: typeof(int),
+                        jsonValueReaderWriter: JsonInt32ReaderWriter.Instance)));
+            var int32NestedCollectionElementType = int32NestedCollection.SetElementType(typeof(int[]));
+            int32NestedCollectionElementType.TypeMapping = int32NestedCollection.TypeMapping.ElementTypeMapping;
+
+            var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
+                "Int32ReadOnlyCollection",
+                typeof(IReadOnlyCollection<int>),
+                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
+                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_int32ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int32ReadOnlyCollection.SetGetter(
+                IReadOnlyCollection<int> (CompiledModelTestBase.ManyTypes entity) => (ManyTypesUnsafeAccessors._int32ReadOnlyCollection(entity) == null ? null : ((IReadOnlyCollection<int>)(ManyTypesUnsafeAccessors._int32ReadOnlyCollection(entity)))),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors._int32ReadOnlyCollection(entity) == null,
+                IReadOnlyCollection<int> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<int>)(ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance)))),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._int32ReadOnlyCollection(instance) == null);
+            int32ReadOnlyCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<int> value) => ManyTypesUnsafeAccessors._int32ReadOnlyCollection(entity) = ((List<int>)(value)));
+            int32ReadOnlyCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<int> value) => ManyTypesUnsafeAccessors._int32ReadOnlyCollection(entity) = ((List<int>)(value)));
+            int32ReadOnlyCollection.SetAccessors(
+                IReadOnlyCollection<int> (InternalEntityEntry entry) => ((IReadOnlyCollection<int>)(ManyTypesUnsafeAccessors._int32ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<int> (InternalEntityEntry entry) => ((IReadOnlyCollection<int>)(ManyTypesUnsafeAccessors._int32ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<int> (InternalEntityEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection, 106),
+                IReadOnlyCollection<int> (InternalEntityEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[106]);
+            int32ReadOnlyCollection.SetPropertyIndexes(
+                index: 106,
+                originalValueIndex: 106,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int32ReadOnlyCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<int>, int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<int>, int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<int>(new JsonCollectionOfStructsReaderWriter<List<int>, int>(
+                    JsonInt32ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<int>, int>(
+                    JsonInt32ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    keyComparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    providerValueComparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    clrType: typeof(int),
+                    jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
+            int32ReadOnlyCollectionElementType.TypeMapping = int32ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var int64 = runtimeEntityType.AddProperty(
                 "Int64",
@@ -763,18 +6317,204 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0L);
+            int64.SetGetter(
+                long (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int64(entity) == 0L,
+                long (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64(instance) == 0L);
+            int64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, long value) => ManyTypesUnsafeAccessors.Int64(entity) = value);
+            int64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, long value) => ManyTypesUnsafeAccessors.Int64(entity) = value);
+            int64.SetAccessors(
+                long (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(int64, 107),
+                long (InternalEntityEntry entry) => entry.GetCurrentValue<long>(int64),
+                object (ValueBuffer valueBuffer) => valueBuffer[107]);
+            int64.SetPropertyIndexes(
+                index: 107,
+                originalValueIndex: 107,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
 
             var int64Array = runtimeEntityType.AddProperty(
                 "Int64Array",
                 typeof(long[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int64Array.SetGetter(
+                long[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int64Array(entity) == null,
+                long[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64Array(instance) == null);
+            int64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, long[] value) => ManyTypesUnsafeAccessors.Int64Array(entity) = value);
+            int64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, long[] value) => ManyTypesUnsafeAccessors.Int64Array(entity) = value);
+            int64Array.SetAccessors(
+                long[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long[] (InternalEntityEntry entry) => entry.ReadOriginalValue<long[]>(int64Array, 108),
+                long[] (InternalEntityEntry entry) => entry.GetCurrentValue<long[]>(int64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[108]);
+            int64Array.SetPropertyIndexes(
+                index: 108,
+                originalValueIndex: 108,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v)),
+                keyComparer: new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<long>(new JsonCollectionOfStructsReaderWriter<long[], long>(
+                    JsonInt64ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<long[], long>(
+                    JsonInt64ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v),
+                    keyComparer: new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v),
+                    providerValueComparer: new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v),
+                    clrType: typeof(long),
+                    jsonValueReaderWriter: JsonInt64ReaderWriter.Instance));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
+            int64ArrayElementType.TypeMapping = int64Array.TypeMapping.ElementTypeMapping;
 
             var int64NestedCollection = runtimeEntityType.AddProperty(
                 "Int64NestedCollection",
                 typeof(IList<long[]>[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int64NestedCollection.SetGetter(
+                IList<long[]>[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int64NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int64NestedCollection(entity) == null,
+                IList<long[]>[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int64NestedCollection(instance) == null);
+            int64NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IList<long[]>[] value) => ManyTypesUnsafeAccessors.Int64NestedCollection(entity) = value);
+            int64NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IList<long[]>[] value) => ManyTypesUnsafeAccessors.Int64NestedCollection(entity) = value);
+            int64NestedCollection.SetAccessors(
+                IList<long[]>[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IList<long[]>[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IList<long[]>[] (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<long[]>[]>(int64NestedCollection, 109),
+                IList<long[]>[] (InternalEntityEntry entry) => entry.GetCurrentValue<IList<long[]>[]>(int64NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[109]);
+            int64NestedCollection.SetPropertyIndexes(
+                index: 109,
+                originalValueIndex: 109,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int64NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<IList<long[]>[], IList<long[]>>(new ConvertingValueComparer<IList<long[]>, object>(new ListOfReferenceTypesComparer<List<long[]>, long[]>(new ConvertingValueComparer<long[], IEnumerable<long>>(new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v)))))),
+                keyComparer: new ListOfReferenceTypesComparer<IList<long[]>[], IList<long[]>>(new ConvertingValueComparer<IList<long[]>, object>(new ListOfReferenceTypesComparer<List<long[]>, long[]>(new ConvertingValueComparer<long[], IEnumerable<long>>(new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v)))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IList<long[]>>(new JsonCollectionOfReferencesReaderWriter<IList<long[]>[], IList<long[]>>(
+                    new JsonCollectionOfReferencesReaderWriter<List<long[]>, long[]>(
+                        new JsonCollectionOfStructsReaderWriter<long[], long>(
+                            JsonInt64ReaderWriter.Instance)))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IList<long[]>[], IList<long[]>>(
+                    new JsonCollectionOfReferencesReaderWriter<List<long[]>, long[]>(
+                        new JsonCollectionOfStructsReaderWriter<long[], long>(
+                            JsonInt64ReaderWriter.Instance))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<List<long[]>, long[]>(new ConvertingValueComparer<long[], IEnumerable<long>>(new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v)))),
+                    keyComparer: new ListOfReferenceTypesComparer<List<long[]>, long[]>(new ConvertingValueComparer<long[], IEnumerable<long>>(new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v)))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<long[]>(new JsonCollectionOfReferencesReaderWriter<List<long[]>, long[]>(
+                        new JsonCollectionOfStructsReaderWriter<long[], long>(
+                            JsonInt64ReaderWriter.Instance))),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<long[]>, long[]>(
+                        new JsonCollectionOfStructsReaderWriter<long[], long>(
+                            JsonInt64ReaderWriter.Instance)),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                            bool (long v1, long v2) => v1 == v2,
+                            int (long v) => ((object)v).GetHashCode(),
+                            long (long v) => v)),
+                        keyComparer: new ListOfValueTypesComparer<long[], long>(new ValueComparer<long>(
+                            bool (long v1, long v2) => v1 == v2,
+                            int (long v) => ((object)v).GetHashCode(),
+                            long (long v) => v)),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        converter: new CollectionToJsonStringConverter<long>(new JsonCollectionOfStructsReaderWriter<long[], long>(
+                            JsonInt64ReaderWriter.Instance)),
+                        jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<long[], long>(
+                            JsonInt64ReaderWriter.Instance),
+                        elementMapping: InMemoryTypeMapping.Default.Clone(
+                            comparer: new ValueComparer<long>(
+                                bool (long v1, long v2) => v1 == v2,
+                                int (long v) => ((object)v).GetHashCode(),
+                                long (long v) => v),
+                            keyComparer: new ValueComparer<long>(
+                                bool (long v1, long v2) => v1 == v2,
+                                int (long v) => ((object)v).GetHashCode(),
+                                long (long v) => v),
+                            providerValueComparer: new ValueComparer<long>(
+                                bool (long v1, long v2) => v1 == v2,
+                                int (long v) => ((object)v).GetHashCode(),
+                                long (long v) => v),
+                            clrType: typeof(long),
+                            jsonValueReaderWriter: JsonInt64ReaderWriter.Instance))));
+            var int64NestedCollectionElementType = int64NestedCollection.SetElementType(typeof(IList<long[]>));
+            int64NestedCollectionElementType.TypeMapping = int64NestedCollection.TypeMapping.ElementTypeMapping;
 
             var int8 = runtimeEntityType.AddProperty(
                 "Int8",
@@ -782,18 +6522,204 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: (sbyte)0);
+            int8.SetGetter(
+                sbyte (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int8(entity) == 0,
+                sbyte (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8(instance) == 0);
+            int8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte value) => ManyTypesUnsafeAccessors.Int8(entity) = value);
+            int8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte value) => ManyTypesUnsafeAccessors.Int8(entity) = value);
+            int8.SetAccessors(
+                sbyte (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte (InternalEntityEntry entry) => entry.ReadOriginalValue<sbyte>(int8, 110),
+                sbyte (InternalEntityEntry entry) => entry.GetCurrentValue<sbyte>(int8),
+                object (ValueBuffer valueBuffer) => valueBuffer[110]);
+            int8.SetPropertyIndexes(
+                index: 110,
+                originalValueIndex: 110,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v),
+                keyComparer: new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v),
+                providerValueComparer: new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v),
+                clrType: typeof(sbyte),
+                jsonValueReaderWriter: JsonSByteReaderWriter.Instance);
 
             var int8Array = runtimeEntityType.AddProperty(
                 "Int8Array",
                 typeof(sbyte[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int8Array.SetGetter(
+                sbyte[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int8Array(entity) == null,
+                sbyte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8Array(instance) == null);
+            int8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte[] value) => ManyTypesUnsafeAccessors.Int8Array(entity) = value);
+            int8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte[] value) => ManyTypesUnsafeAccessors.Int8Array(entity) = value);
+            int8Array.SetAccessors(
+                sbyte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte[] (InternalEntityEntry entry) => entry.ReadOriginalValue<sbyte[]>(int8Array, 111),
+                sbyte[] (InternalEntityEntry entry) => entry.GetCurrentValue<sbyte[]>(int8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[111]);
+            int8Array.SetPropertyIndexes(
+                index: 111,
+                originalValueIndex: 111,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                    JsonSByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                    JsonSByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v),
+                    keyComparer: new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v),
+                    providerValueComparer: new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v),
+                    clrType: typeof(sbyte),
+                    jsonValueReaderWriter: JsonSByteReaderWriter.Instance));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
+            int8ArrayElementType.TypeMapping = int8Array.TypeMapping.ElementTypeMapping;
 
             var int8NestedCollection = runtimeEntityType.AddProperty(
                 "Int8NestedCollection",
                 typeof(sbyte[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            int8NestedCollection.SetGetter(
+                sbyte[][][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int8NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Int8NestedCollection(entity) == null,
+                sbyte[][][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Int8NestedCollection(instance) == null);
+            int8NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte[][][] value) => ManyTypesUnsafeAccessors.Int8NestedCollection(entity) = value);
+            int8NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte[][][] value) => ManyTypesUnsafeAccessors.Int8NestedCollection(entity) = value);
+            int8NestedCollection.SetAccessors(
+                sbyte[][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte[][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Int8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte[][][] (InternalEntityEntry entry) => entry.ReadOriginalValue<sbyte[][][]>(int8NestedCollection, 112),
+                sbyte[][][] (InternalEntityEntry entry) => entry.GetCurrentValue<sbyte[][][]>(int8NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[112]);
+            int8NestedCollection.SetPropertyIndexes(
+                index: 112,
+                originalValueIndex: 112,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            int8NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<sbyte[][][], sbyte[][]>(new ConvertingValueComparer<sbyte[][], object>(new ListOfReferenceTypesComparer<sbyte[][], sbyte[]>(new ConvertingValueComparer<sbyte[], IEnumerable<sbyte>>(new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v)))))),
+                keyComparer: new ListOfReferenceTypesComparer<sbyte[][][], sbyte[][]>(new ConvertingValueComparer<sbyte[][], object>(new ListOfReferenceTypesComparer<sbyte[][], sbyte[]>(new ConvertingValueComparer<sbyte[], IEnumerable<sbyte>>(new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v)))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<sbyte[][]>(new JsonCollectionOfReferencesReaderWriter<sbyte[][][], sbyte[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<sbyte[][], sbyte[]>(
+                        new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                            JsonSByteReaderWriter.Instance)))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<sbyte[][][], sbyte[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<sbyte[][], sbyte[]>(
+                        new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                            JsonSByteReaderWriter.Instance))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<sbyte[][], sbyte[]>(new ConvertingValueComparer<sbyte[], IEnumerable<sbyte>>(new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v)))),
+                    keyComparer: new ListOfReferenceTypesComparer<sbyte[][], sbyte[]>(new ConvertingValueComparer<sbyte[], IEnumerable<sbyte>>(new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v)))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<sbyte[]>(new JsonCollectionOfReferencesReaderWriter<sbyte[][], sbyte[]>(
+                        new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                            JsonSByteReaderWriter.Instance))),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<sbyte[][], sbyte[]>(
+                        new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                            JsonSByteReaderWriter.Instance)),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                            bool (sbyte v1, sbyte v2) => v1 == v2,
+                            int (sbyte v) => ((int)(v)),
+                            sbyte (sbyte v) => v)),
+                        keyComparer: new ListOfValueTypesComparer<sbyte[], sbyte>(new ValueComparer<sbyte>(
+                            bool (sbyte v1, sbyte v2) => v1 == v2,
+                            int (sbyte v) => ((int)(v)),
+                            sbyte (sbyte v) => v)),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        converter: new CollectionToJsonStringConverter<sbyte>(new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                            JsonSByteReaderWriter.Instance)),
+                        jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<sbyte[], sbyte>(
+                            JsonSByteReaderWriter.Instance),
+                        elementMapping: InMemoryTypeMapping.Default.Clone(
+                            comparer: new ValueComparer<sbyte>(
+                                bool (sbyte v1, sbyte v2) => v1 == v2,
+                                int (sbyte v) => ((int)(v)),
+                                sbyte (sbyte v) => v),
+                            keyComparer: new ValueComparer<sbyte>(
+                                bool (sbyte v1, sbyte v2) => v1 == v2,
+                                int (sbyte v) => ((int)(v)),
+                                sbyte (sbyte v) => v),
+                            providerValueComparer: new ValueComparer<sbyte>(
+                                bool (sbyte v1, sbyte v2) => v1 == v2,
+                                int (sbyte v) => ((int)(v)),
+                                sbyte (sbyte v) => v),
+                            clrType: typeof(sbyte),
+                            jsonValueReaderWriter: JsonSByteReaderWriter.Instance))));
+            var int8NestedCollectionElementType = int8NestedCollection.SetElementType(typeof(sbyte[][]));
+            int8NestedCollectionElementType.TypeMapping = int8NestedCollection.TypeMapping.ElementTypeMapping;
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IntNumberToBytesConverterProperty",
@@ -801,6 +6727,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IntNumberToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IntNumberToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new NumberToBytesConverter<int>());
+            intNumberToBytesConverterProperty.SetGetter(
+                int (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(entity) == 0,
+                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(instance) == 0);
+            intNumberToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(entity) = value);
+            intNumberToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(entity) = value);
+            intNumberToBytesConverterProperty.SetAccessors(
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IntNumberToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(intNumberToBytesConverterProperty, 113),
+                int (InternalEntityEntry entry) => entry.GetCurrentValue<int>(intNumberToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[113]);
+            intNumberToBytesConverterProperty.SetPropertyIndexes(
+                index: 113,
+                originalValueIndex: 113,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            intNumberToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<int, byte[]>(
+                    byte[] (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
+                    int (byte[] v) => (v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt((v.Length == 0 ? new byte[4] : v)), 0))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<int, byte[]>(
+                        byte[] (int v) => NumberToBytesConverter<int>.ReverseInt(BitConverter.GetBytes(v)),
+                        int (byte[] v) => (v == null ? 0 : BitConverter.ToInt32(NumberToBytesConverter<int>.ReverseInt((v.Length == 0 ? new byte[4] : v)), 0)))));
             intNumberToBytesConverterProperty.SetSentinelFromProviderValue(new byte[] { 0, 0, 0, 0 });
 
             var intNumberToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -809,6 +6777,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IntNumberToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IntNumberToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new NumberToStringConverter<int>());
+            intNumberToStringConverterProperty.SetGetter(
+                int (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(entity) == 0,
+                int (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(instance) == 0);
+            intNumberToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(entity) = value);
+            intNumberToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int value) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(entity) = value);
+            intNumberToStringConverterProperty.SetAccessors(
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.IntNumberToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(intNumberToStringConverterProperty, 114),
+                int (InternalEntityEntry entry) => entry.GetCurrentValue<int>(intNumberToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[114]);
+            intNumberToStringConverterProperty.SetPropertyIndexes(
+                index: 114,
+                originalValueIndex: 114,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            intNumberToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<int, string>(
+                    string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
+                    int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<int, string>(
+                        string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
+                        int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture))));
             intNumberToStringConverterProperty.SetSentinelFromProviderValue("0");
 
             var nullIntToNullStringConverterProperty = runtimeEntityType.AddProperty(
@@ -818,6 +6828,50 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullIntToNullStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true,
                 valueConverter: new CompiledModelTestBase.NullIntToNullStringConverter());
+            nullIntToNullStringConverterProperty.SetGetter(
+                int? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(entity).HasValue),
+                int? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(instance).HasValue));
+            nullIntToNullStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? value) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(entity) = value);
+            nullIntToNullStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? value) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(entity) = value);
+            nullIntToNullStringConverterProperty.SetAccessors(
+                int? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullIntToNullStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? (InternalEntityEntry entry) => entry.ReadOriginalValue<int?>(nullIntToNullStringConverterProperty, 115),
+                int? (InternalEntityEntry entry) => entry.GetCurrentValue<int?>(nullIntToNullStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[115]);
+            nullIntToNullStringConverterProperty.SetPropertyIndexes(
+                index: 115,
+                originalValueIndex: 115,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullIntToNullStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int?>(
+                    bool (int? v1, int? v2) => v1 == v2,
+                    int (int? v) => ((int)(v)),
+                    int? (int? v) => v),
+                keyComparer: new ValueComparer<int?>(
+                    bool (int? v1, int? v2) => v1 == v2,
+                    int (int? v) => ((int)(v)),
+                    int? (int? v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<int?, string>(
+                    string (int? v) => (v == null ? null : ((object)v).ToString()),
+                    int? (string v) => (v == null || v == "<null>" ? null : ((int? )(int.Parse(v)))),
+                    convertsNulls: true),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<int?, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<int?, string>(
+                        string (int? v) => (v == null ? null : ((object)v).ToString()),
+                        int? (string v) => (v == null || v == "<null>" ? null : ((int? )(int.Parse(v)))),
+                        convertsNulls: true)));
 
             var nullableBool = runtimeEntityType.AddProperty(
                 "NullableBool",
@@ -825,12 +6879,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableBool.SetGetter(
+                bool? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBool(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableBool(entity).HasValue),
+                bool? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBool(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableBool(instance).HasValue));
+            nullableBool.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool? value) => ManyTypesUnsafeAccessors.NullableBool(entity) = value);
+            nullableBool.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool? value) => ManyTypesUnsafeAccessors.NullableBool(entity) = value);
+            nullableBool.SetAccessors(
+                bool? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBool(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool? (InternalEntityEntry entry) => entry.ReadOriginalValue<bool?>(nullableBool, 116),
+                bool? (InternalEntityEntry entry) => entry.GetCurrentValue<bool?>(nullableBool),
+                object (ValueBuffer valueBuffer) => valueBuffer[116]);
+            nullableBool.SetPropertyIndexes(
+                index: 116,
+                originalValueIndex: 116,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableBool.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                keyComparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                providerValueComparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                clrType: typeof(bool),
+                jsonValueReaderWriter: JsonBoolReaderWriter.Instance);
+            nullableBool.SetComparer(new NullableValueComparer<bool>(nullableBool.TypeMapping.Comparer));
+            nullableBool.SetKeyComparer(new NullableValueComparer<bool>(nullableBool.TypeMapping.KeyComparer));
 
             var nullableBoolArray = runtimeEntityType.AddProperty(
                 "NullableBoolArray",
                 typeof(bool?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableBoolArray.SetGetter(
+                bool? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBoolArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBoolArray(entity) == null,
+                bool? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBoolArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBoolArray(instance) == null);
+            nullableBoolArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool? [] value) => ManyTypesUnsafeAccessors.NullableBoolArray(entity) = value);
+            nullableBoolArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, bool? [] value) => ManyTypesUnsafeAccessors.NullableBoolArray(entity) = value);
+            nullableBoolArray.SetAccessors(
+                bool? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBoolArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                bool? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<bool? []>(nullableBoolArray, 117),
+                bool? [] (InternalEntityEntry entry) => entry.GetCurrentValue<bool? []>(nullableBoolArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[117]);
+            nullableBoolArray.SetPropertyIndexes(
+                index: 117,
+                originalValueIndex: 117,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableBoolArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<bool?[], bool>(new NullableValueComparer<bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<bool?[], bool>(new NullableValueComparer<bool>(new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<bool?>(new JsonCollectionOfNullableStructsReaderWriter<bool?[], bool>(
+                    JsonBoolReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<bool?[], bool>(
+                    JsonBoolReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    keyComparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    providerValueComparer: new ValueComparer<bool>(
+                        bool (bool v1, bool v2) => v1 == v2,
+                        int (bool v) => ((object)v).GetHashCode(),
+                        bool (bool v) => v),
+                    clrType: typeof(bool),
+                    jsonValueReaderWriter: JsonBoolReaderWriter.Instance));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
+            nullableBoolArrayElementType.TypeMapping = nullableBoolArray.TypeMapping.ElementTypeMapping;
+            nullableBoolArrayElementType.SetComparer(new NullableValueComparer<bool>(nullableBoolArrayElementType.TypeMapping.Comparer));
 
             var nullableBytes = runtimeEntityType.AddProperty(
                 "NullableBytes",
@@ -838,18 +6987,184 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytes", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytes>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableBytes.SetGetter(
+                byte[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBytes(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBytes(entity) == null,
+                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytes(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytes(instance) == null);
+            nullableBytes.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.NullableBytes(entity) = value);
+            nullableBytes.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.NullableBytes(entity) = value);
+            nullableBytes.SetAccessors(
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBytes(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[]>(nullableBytes, 118),
+                byte[] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[]>(nullableBytes),
+                object (ValueBuffer valueBuffer) => valueBuffer[118]);
+            nullableBytes.SetPropertyIndexes(
+                index: 118,
+                originalValueIndex: 118,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableBytes.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v),
+                keyComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                clrType: typeof(byte[]),
+                jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance);
 
             var nullableBytesArray = runtimeEntityType.AddProperty(
                 "NullableBytesArray",
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableBytesArray.SetGetter(
+                byte[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBytesArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBytesArray(entity) == null,
+                byte[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytesArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytesArray(instance) == null);
+            nullableBytesArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][] value) => ManyTypesUnsafeAccessors.NullableBytesArray(entity) = value);
+            nullableBytesArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][] value) => ManyTypesUnsafeAccessors.NullableBytesArray(entity) = value);
+            nullableBytesArray.SetAccessors(
+                byte[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBytesArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[][]>(nullableBytesArray, 119),
+                byte[][] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[][]>(nullableBytesArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[119]);
+            nullableBytesArray.SetPropertyIndexes(
+                index: 119,
+                originalValueIndex: 119,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableBytesArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                    JsonByteArrayReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                    JsonByteArrayReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => ((object)v).GetHashCode(),
+                        byte[] (byte[] v) => v),
+                    keyComparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                        byte[] (byte[] source) => source.ToArray()),
+                    providerValueComparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                        byte[] (byte[] source) => source.ToArray()),
+                    clrType: typeof(byte[]),
+                    jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
+            nullableBytesArrayElementType.TypeMapping = nullableBytesArray.TypeMapping.ElementTypeMapping;
 
             var nullableBytesNestedCollection = runtimeEntityType.AddProperty(
                 "NullableBytesNestedCollection",
                 typeof(byte[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableBytesNestedCollection.SetGetter(
+                byte[][][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(entity) == null,
+                byte[][][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(instance) == null);
+            nullableBytesNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][][] value) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(entity) = value);
+            nullableBytesNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[][][] value) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(entity) = value);
+            nullableBytesNestedCollection.SetAccessors(
+                byte[][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableBytesNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[][][] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[][][]>(nullableBytesNestedCollection, 120),
+                byte[][][] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[][][]>(nullableBytesNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[120]);
+            nullableBytesNestedCollection.SetPropertyIndexes(
+                index: 120,
+                originalValueIndex: 120,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableBytesNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<byte[][][], byte[][]>(new ConvertingValueComparer<byte[][], object>(new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<byte[][][], byte[][]>(new ConvertingValueComparer<byte[][], object>(new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte[][]>(new JsonCollectionOfReferencesReaderWriter<byte[][][], byte[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][][], byte[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => ((object)v).GetHashCode(),
+                        byte[] (byte[] v) => v)),
+                    keyComparer: new ListOfReferenceTypesComparer<byte[][], byte[]>(new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => ((object)v).GetHashCode(),
+                        byte[] (byte[] v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte[][], byte[]>(
+                        JsonByteArrayReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<byte[]>(
+                            bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                            int (byte[] v) => ((object)v).GetHashCode(),
+                            byte[] (byte[] v) => v),
+                        keyComparer: new ValueComparer<byte[]>(
+                            bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                            int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                            byte[] (byte[] source) => source.ToArray()),
+                        providerValueComparer: new ValueComparer<byte[]>(
+                            bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                            int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                            byte[] (byte[] source) => source.ToArray()),
+                        clrType: typeof(byte[]),
+                        jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance)));
+            var nullableBytesNestedCollectionElementType = nullableBytesNestedCollection.SetElementType(typeof(byte[][]));
+            nullableBytesNestedCollectionElementType.TypeMapping = nullableBytesNestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableChar = runtimeEntityType.AddProperty(
                 "NullableChar",
@@ -857,12 +7172,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableChar", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableChar>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableChar.SetGetter(
+                char? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableChar(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableChar(entity).HasValue),
+                char? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableChar(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableChar(instance).HasValue));
+            nullableChar.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, char? value) => ManyTypesUnsafeAccessors.NullableChar(entity) = value);
+            nullableChar.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, char? value) => ManyTypesUnsafeAccessors.NullableChar(entity) = value);
+            nullableChar.SetAccessors(
+                char? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableChar(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableChar(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char? (InternalEntityEntry entry) => entry.ReadOriginalValue<char?>(nullableChar, 121),
+                char? (InternalEntityEntry entry) => entry.GetCurrentValue<char?>(nullableChar),
+                object (ValueBuffer valueBuffer) => valueBuffer[121]);
+            nullableChar.SetPropertyIndexes(
+                index: 121,
+                originalValueIndex: 121,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableChar.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                keyComparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                providerValueComparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                clrType: typeof(char),
+                jsonValueReaderWriter: JsonCharReaderWriter.Instance);
+            nullableChar.SetComparer(new NullableValueComparer<char>(nullableChar.TypeMapping.Comparer));
+            nullableChar.SetKeyComparer(new NullableValueComparer<char>(nullableChar.TypeMapping.KeyComparer));
 
             var nullableCharArray = runtimeEntityType.AddProperty(
                 "NullableCharArray",
                 typeof(char?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableCharArray.SetGetter(
+                char? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableCharArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableCharArray(entity) == null,
+                char? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableCharArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableCharArray(instance) == null);
+            nullableCharArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, char? [] value) => ManyTypesUnsafeAccessors.NullableCharArray(entity) = value);
+            nullableCharArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, char? [] value) => ManyTypesUnsafeAccessors.NullableCharArray(entity) = value);
+            nullableCharArray.SetAccessors(
+                char? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableCharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableCharArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                char? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<char? []>(nullableCharArray, 122),
+                char? [] (InternalEntityEntry entry) => entry.GetCurrentValue<char? []>(nullableCharArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[122]);
+            nullableCharArray.SetPropertyIndexes(
+                index: 122,
+                originalValueIndex: 122,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableCharArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<char?[], char>(new NullableValueComparer<char>(new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<char?[], char>(new NullableValueComparer<char>(new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<char?>(new JsonCollectionOfNullableStructsReaderWriter<char?[], char>(
+                    JsonCharReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<char?[], char>(
+                    JsonCharReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v),
+                    keyComparer: new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v),
+                    providerValueComparer: new ValueComparer<char>(
+                        bool (char v1, char v2) => v1 == v2,
+                        int (char v) => ((int)(v)),
+                        char (char v) => v),
+                    clrType: typeof(char),
+                    jsonValueReaderWriter: JsonCharReaderWriter.Instance));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
+            nullableCharArrayElementType.TypeMapping = nullableCharArray.TypeMapping.ElementTypeMapping;
+            nullableCharArrayElementType.SetComparer(new NullableValueComparer<char>(nullableCharArrayElementType.TypeMapping.Comparer));
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
                 "NullableDateOnly",
@@ -870,12 +7280,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableDateOnly.SetGetter(
+                DateOnly? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDateOnly(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableDateOnly(entity).HasValue),
+                DateOnly? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateOnly(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDateOnly(instance).HasValue));
+            nullableDateOnly.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly? value) => ManyTypesUnsafeAccessors.NullableDateOnly(entity) = value);
+            nullableDateOnly.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly? value) => ManyTypesUnsafeAccessors.NullableDateOnly(entity) = value);
+            nullableDateOnly.SetAccessors(
+                DateOnly? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly? (InternalEntityEntry entry) => entry.ReadOriginalValue<DateOnly?>(nullableDateOnly, 123),
+                DateOnly? (InternalEntityEntry entry) => entry.GetCurrentValue<DateOnly?>(nullableDateOnly),
+                object (ValueBuffer valueBuffer) => valueBuffer[123]);
+            nullableDateOnly.SetPropertyIndexes(
+                index: 123,
+                originalValueIndex: 123,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDateOnly.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                keyComparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                providerValueComparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                clrType: typeof(DateOnly),
+                jsonValueReaderWriter: JsonDateOnlyReaderWriter.Instance);
+            nullableDateOnly.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnly.TypeMapping.Comparer));
+            nullableDateOnly.SetKeyComparer(new NullableValueComparer<DateOnly>(nullableDateOnly.TypeMapping.KeyComparer));
 
             var nullableDateOnlyArray = runtimeEntityType.AddProperty(
                 "NullableDateOnlyArray",
                 typeof(DateOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableDateOnlyArray.SetGetter(
+                DateOnly? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(entity) == null,
+                DateOnly? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(instance) == null);
+            nullableDateOnlyArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly? [] value) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(entity) = value);
+            nullableDateOnlyArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateOnly? [] value) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(entity) = value);
+            nullableDateOnlyArray.SetAccessors(
+                DateOnly? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateOnly? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<DateOnly? []>(nullableDateOnlyArray, 124),
+                DateOnly? [] (InternalEntityEntry entry) => entry.GetCurrentValue<DateOnly? []>(nullableDateOnlyArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[124]);
+            nullableDateOnlyArray.SetPropertyIndexes(
+                index: 124,
+                originalValueIndex: 124,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDateOnlyArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<DateOnly?[], DateOnly>(new NullableValueComparer<DateOnly>(new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<DateOnly?[], DateOnly>(new NullableValueComparer<DateOnly>(new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<DateOnly?>(new JsonCollectionOfNullableStructsReaderWriter<DateOnly?[], DateOnly>(
+                    JsonDateOnlyReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateOnly?[], DateOnly>(
+                    JsonDateOnlyReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<DateOnly>(
+                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                        int (DateOnly v) => ((object)v).GetHashCode(),
+                        DateOnly (DateOnly v) => v),
+                    keyComparer: new ValueComparer<DateOnly>(
+                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                        int (DateOnly v) => ((object)v).GetHashCode(),
+                        DateOnly (DateOnly v) => v),
+                    providerValueComparer: new ValueComparer<DateOnly>(
+                        bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                        int (DateOnly v) => ((object)v).GetHashCode(),
+                        DateOnly (DateOnly v) => v),
+                    clrType: typeof(DateOnly),
+                    jsonValueReaderWriter: JsonDateOnlyReaderWriter.Instance));
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
+            nullableDateOnlyArrayElementType.TypeMapping = nullableDateOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableDateOnlyArrayElementType.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnlyArrayElementType.TypeMapping.Comparer));
 
             var nullableDateTime = runtimeEntityType.AddProperty(
                 "NullableDateTime",
@@ -883,12 +7388,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableDateTime.SetGetter(
+                DateTime? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDateTime(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableDateTime(entity).HasValue),
+                DateTime? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateTime(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDateTime(instance).HasValue));
+            nullableDateTime.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime? value) => ManyTypesUnsafeAccessors.NullableDateTime(entity) = value);
+            nullableDateTime.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime? value) => ManyTypesUnsafeAccessors.NullableDateTime(entity) = value);
+            nullableDateTime.SetAccessors(
+                DateTime? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateTime(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime? (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime?>(nullableDateTime, 125),
+                DateTime? (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime?>(nullableDateTime),
+                object (ValueBuffer valueBuffer) => valueBuffer[125]);
+            nullableDateTime.SetPropertyIndexes(
+                index: 125,
+                originalValueIndex: 125,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDateTime.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                keyComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                providerValueComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                clrType: typeof(DateTime),
+                jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance);
+            nullableDateTime.SetComparer(new NullableValueComparer<DateTime>(nullableDateTime.TypeMapping.Comparer));
+            nullableDateTime.SetKeyComparer(new NullableValueComparer<DateTime>(nullableDateTime.TypeMapping.KeyComparer));
 
             var nullableDateTimeArray = runtimeEntityType.AddProperty(
                 "NullableDateTimeArray",
                 typeof(DateTime?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableDateTimeArray.SetGetter(
+                DateTime? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDateTimeArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDateTimeArray(entity) == null,
+                DateTime? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateTimeArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDateTimeArray(instance) == null);
+            nullableDateTimeArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime? [] value) => ManyTypesUnsafeAccessors.NullableDateTimeArray(entity) = value);
+            nullableDateTimeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, DateTime? [] value) => ManyTypesUnsafeAccessors.NullableDateTimeArray(entity) = value);
+            nullableDateTimeArray.SetAccessors(
+                DateTime? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDateTimeArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                DateTime? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime? []>(nullableDateTimeArray, 126),
+                DateTime? [] (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime? []>(nullableDateTimeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[126]);
+            nullableDateTimeArray.SetPropertyIndexes(
+                index: 126,
+                originalValueIndex: 126,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDateTimeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<DateTime?[], DateTime>(new NullableValueComparer<DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<DateTime?[], DateTime>(new NullableValueComparer<DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<DateTime?>(new JsonCollectionOfNullableStructsReaderWriter<DateTime?[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateTime?[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    keyComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    providerValueComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    clrType: typeof(DateTime),
+                    jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
+            nullableDateTimeArrayElementType.TypeMapping = nullableDateTimeArray.TypeMapping.ElementTypeMapping;
+            nullableDateTimeArrayElementType.SetComparer(new NullableValueComparer<DateTime>(nullableDateTimeArrayElementType.TypeMapping.Comparer));
 
             var nullableDecimal = runtimeEntityType.AddProperty(
                 "NullableDecimal",
@@ -896,12 +7496,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableDecimal.SetGetter(
+                decimal? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDecimal(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableDecimal(entity).HasValue),
+                decimal? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDecimal(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDecimal(instance).HasValue));
+            nullableDecimal.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal? value) => ManyTypesUnsafeAccessors.NullableDecimal(entity) = value);
+            nullableDecimal.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal? value) => ManyTypesUnsafeAccessors.NullableDecimal(entity) = value);
+            nullableDecimal.SetAccessors(
+                decimal? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDecimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDecimal(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal? (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal?>(nullableDecimal, 127),
+                decimal? (InternalEntityEntry entry) => entry.GetCurrentValue<decimal?>(nullableDecimal),
+                object (ValueBuffer valueBuffer) => valueBuffer[127]);
+            nullableDecimal.SetPropertyIndexes(
+                index: 127,
+                originalValueIndex: 127,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDecimal.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                keyComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                providerValueComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                clrType: typeof(decimal),
+                jsonValueReaderWriter: JsonDecimalReaderWriter.Instance);
+            nullableDecimal.SetComparer(new NullableValueComparer<decimal>(nullableDecimal.TypeMapping.Comparer));
+            nullableDecimal.SetKeyComparer(new NullableValueComparer<decimal>(nullableDecimal.TypeMapping.KeyComparer));
 
             var nullableDecimalArray = runtimeEntityType.AddProperty(
                 "NullableDecimalArray",
                 typeof(decimal?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableDecimalArray.SetGetter(
+                decimal? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDecimalArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDecimalArray(entity) == null,
+                decimal? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDecimalArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDecimalArray(instance) == null);
+            nullableDecimalArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal? [] value) => ManyTypesUnsafeAccessors.NullableDecimalArray(entity) = value);
+            nullableDecimalArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, decimal? [] value) => ManyTypesUnsafeAccessors.NullableDecimalArray(entity) = value);
+            nullableDecimalArray.SetAccessors(
+                decimal? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDecimalArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                decimal? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal? []>(nullableDecimalArray, 128),
+                decimal? [] (InternalEntityEntry entry) => entry.GetCurrentValue<decimal? []>(nullableDecimalArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[128]);
+            nullableDecimalArray.SetPropertyIndexes(
+                index: 128,
+                originalValueIndex: 128,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDecimalArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<decimal?[], decimal>(new NullableValueComparer<decimal>(new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<decimal?[], decimal>(new NullableValueComparer<decimal>(new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<decimal?>(new JsonCollectionOfNullableStructsReaderWriter<decimal?[], decimal>(
+                    JsonDecimalReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<decimal?[], decimal>(
+                    JsonDecimalReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<decimal>(
+                        bool (decimal v1, decimal v2) => v1 == v2,
+                        int (decimal v) => ((object)v).GetHashCode(),
+                        decimal (decimal v) => v),
+                    keyComparer: new ValueComparer<decimal>(
+                        bool (decimal v1, decimal v2) => v1 == v2,
+                        int (decimal v) => ((object)v).GetHashCode(),
+                        decimal (decimal v) => v),
+                    providerValueComparer: new ValueComparer<decimal>(
+                        bool (decimal v1, decimal v2) => v1 == v2,
+                        int (decimal v) => ((object)v).GetHashCode(),
+                        decimal (decimal v) => v),
+                    clrType: typeof(decimal),
+                    jsonValueReaderWriter: JsonDecimalReaderWriter.Instance));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
+            nullableDecimalArrayElementType.TypeMapping = nullableDecimalArray.TypeMapping.ElementTypeMapping;
+            nullableDecimalArrayElementType.SetComparer(new NullableValueComparer<decimal>(nullableDecimalArrayElementType.TypeMapping.Comparer));
 
             var nullableDouble = runtimeEntityType.AddProperty(
                 "NullableDouble",
@@ -909,12 +7604,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDouble", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDouble>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableDouble.SetGetter(
+                double? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDouble(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableDouble(entity).HasValue),
+                double? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDouble(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableDouble(instance).HasValue));
+            nullableDouble.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, double? value) => ManyTypesUnsafeAccessors.NullableDouble(entity) = value);
+            nullableDouble.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, double? value) => ManyTypesUnsafeAccessors.NullableDouble(entity) = value);
+            nullableDouble.SetAccessors(
+                double? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDouble(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDouble(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double? (InternalEntityEntry entry) => entry.ReadOriginalValue<double?>(nullableDouble, 129),
+                double? (InternalEntityEntry entry) => entry.GetCurrentValue<double?>(nullableDouble),
+                object (ValueBuffer valueBuffer) => valueBuffer[129]);
+            nullableDouble.SetPropertyIndexes(
+                index: 129,
+                originalValueIndex: 129,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDouble.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                keyComparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                providerValueComparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                clrType: typeof(double),
+                jsonValueReaderWriter: JsonDoubleReaderWriter.Instance);
+            nullableDouble.SetComparer(new NullableValueComparer<double>(nullableDouble.TypeMapping.Comparer));
+            nullableDouble.SetKeyComparer(new NullableValueComparer<double>(nullableDouble.TypeMapping.KeyComparer));
 
             var nullableDoubleArray = runtimeEntityType.AddProperty(
                 "NullableDoubleArray",
                 typeof(double?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableDoubleArray.SetGetter(
+                double? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDoubleArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableDoubleArray(entity) == null,
+                double? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDoubleArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableDoubleArray(instance) == null);
+            nullableDoubleArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, double? [] value) => ManyTypesUnsafeAccessors.NullableDoubleArray(entity) = value);
+            nullableDoubleArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, double? [] value) => ManyTypesUnsafeAccessors.NullableDoubleArray(entity) = value);
+            nullableDoubleArray.SetAccessors(
+                double? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableDoubleArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                double? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<double? []>(nullableDoubleArray, 130),
+                double? [] (InternalEntityEntry entry) => entry.GetCurrentValue<double? []>(nullableDoubleArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[130]);
+            nullableDoubleArray.SetPropertyIndexes(
+                index: 130,
+                originalValueIndex: 130,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableDoubleArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<double?[], double>(new NullableValueComparer<double>(new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<double?[], double>(new NullableValueComparer<double>(new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<double?>(new JsonCollectionOfNullableStructsReaderWriter<double?[], double>(
+                    JsonDoubleReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<double?[], double>(
+                    JsonDoubleReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<double>(
+                        bool (double v1, double v2) => v1.Equals(v2),
+                        int (double v) => ((object)v).GetHashCode(),
+                        double (double v) => v),
+                    keyComparer: new ValueComparer<double>(
+                        bool (double v1, double v2) => v1.Equals(v2),
+                        int (double v) => ((object)v).GetHashCode(),
+                        double (double v) => v),
+                    providerValueComparer: new ValueComparer<double>(
+                        bool (double v1, double v2) => v1.Equals(v2),
+                        int (double v) => ((object)v).GetHashCode(),
+                        double (double v) => v),
+                    clrType: typeof(double),
+                    jsonValueReaderWriter: JsonDoubleReaderWriter.Instance));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
+            nullableDoubleArrayElementType.TypeMapping = nullableDoubleArray.TypeMapping.ElementTypeMapping;
+            nullableDoubleArrayElementType.SetComparer(new NullableValueComparer<double>(nullableDoubleArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
                 "NullableEnum16",
@@ -922,12 +7712,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum16.SetGetter(
+                CompiledModelTestBase.Enum16? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum16(entity).HasValue),
+                CompiledModelTestBase.Enum16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum16(instance).HasValue));
+            nullableEnum16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? value) => ManyTypesUnsafeAccessors.NullableEnum16(entity) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value))))));
+            nullableEnum16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? value) => ManyTypesUnsafeAccessors.NullableEnum16(entity) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value))))));
+            nullableEnum16.SetAccessors(
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16?>(nullableEnum16, 131),
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16),
+                object (ValueBuffer valueBuffer) => valueBuffer[131]);
+            nullableEnum16.SetPropertyIndexes(
+                index: 131,
+                originalValueIndex: 131,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum16),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance);
+            nullableEnum16.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16.TypeMapping.Comparer));
+            nullableEnum16.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16.TypeMapping.KeyComparer));
 
             var nullableEnum16Array = runtimeEntityType.AddProperty(
                 "NullableEnum16Array",
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum16Array.SetGetter(
+                CompiledModelTestBase.Enum16? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16Array(entity) == null,
+                CompiledModelTestBase.Enum16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Array(instance) == null);
+            nullableEnum16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? [] value) => ManyTypesUnsafeAccessors.NullableEnum16Array(entity) = value);
+            nullableEnum16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? [] value) => ManyTypesUnsafeAccessors.NullableEnum16Array(entity) = value);
+            nullableEnum16Array.SetAccessors(
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array, 132),
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[132]);
+            nullableEnum16Array.SetPropertyIndexes(
+                index: 132,
+                originalValueIndex: 132,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum16),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16ArrayElementType.TypeMapping = nullableEnum16Array.TypeMapping.ElementTypeMapping;
+            nullableEnum16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
                 "NullableEnum16AsString",
@@ -935,24 +7820,233 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum16AsString.SetGetter(
+                CompiledModelTestBase.Enum16? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum16AsString(entity).HasValue),
+                CompiledModelTestBase.Enum16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum16AsString(instance).HasValue));
+            nullableEnum16AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? value) => ManyTypesUnsafeAccessors.NullableEnum16AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value))))));
+            nullableEnum16AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? value) => ManyTypesUnsafeAccessors.NullableEnum16AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum16? )(((CompiledModelTestBase.Enum16)(value))))));
+            nullableEnum16AsString.SetAccessors(
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString, 133),
+                CompiledModelTestBase.Enum16? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[133]);
+            nullableEnum16AsString.SetPropertyIndexes(
+                index: 133,
+                originalValueIndex: 133,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum16AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum16),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance);
+            nullableEnum16AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsString.TypeMapping.Comparer));
+            nullableEnum16AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsString.TypeMapping.KeyComparer));
 
             var nullableEnum16AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnum16AsStringArray",
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum16AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum16? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(instance) == null);
+            nullableEnum16AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? [] value) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(entity) = value);
+            nullableEnum16AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum16? [] value) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(entity) = value);
+            nullableEnum16AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray, 134),
+                CompiledModelTestBase.Enum16? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[134]);
+            nullableEnum16AsStringArray.SetPropertyIndexes(
+                index: 134,
+                originalValueIndex: 134,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum16AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum16?[], CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum16),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringArrayElementType.TypeMapping = nullableEnum16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum16AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum16AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum16?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(instance) == null);
+            nullableEnum16AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16?> value) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(entity) = value);
+            nullableEnum16AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16?> value) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(entity) = value);
+            nullableEnum16AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection, 135),
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[135]);
+            nullableEnum16AsStringCollection.SetPropertyIndexes(
+                index: 135,
+                originalValueIndex: 135,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum16AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum16),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringCollectionElementType.TypeMapping = nullableEnum16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
                 "NullableEnum16Collection",
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum16Collection.SetGetter(
+                List<CompiledModelTestBase.Enum16?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum16Collection(entity) == null,
+                List<CompiledModelTestBase.Enum16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum16Collection(instance) == null);
+            nullableEnum16Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16?> value) => ManyTypesUnsafeAccessors.NullableEnum16Collection(entity) = value);
+            nullableEnum16Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum16?> value) => ManyTypesUnsafeAccessors.NullableEnum16Collection(entity) = value);
+            nullableEnum16Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection, 136),
+                List<CompiledModelTestBase.Enum16?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[136]);
+            nullableEnum16Collection.SetPropertyIndexes(
+                index: 136,
+                originalValueIndex: 136,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum16Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(new NullableValueComparer<CompiledModelTestBase.Enum16>(new ValueComparer<CompiledModelTestBase.Enum16>(
+                    bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum16>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum16>(
+                        bool (CompiledModelTestBase.Enum16 v1, CompiledModelTestBase.Enum16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum16 (CompiledModelTestBase.Enum16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum16),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum16>.Instance));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16CollectionElementType.TypeMapping = nullableEnum16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
                 "NullableEnum32",
@@ -960,12 +8054,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum32.SetGetter(
+                CompiledModelTestBase.Enum32? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum32(entity).HasValue),
+                CompiledModelTestBase.Enum32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum32(instance).HasValue));
+            nullableEnum32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? value) => ManyTypesUnsafeAccessors.NullableEnum32(entity) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value))))));
+            nullableEnum32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? value) => ManyTypesUnsafeAccessors.NullableEnum32(entity) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value))))));
+            nullableEnum32.SetAccessors(
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32?>(nullableEnum32, 137),
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32),
+                object (ValueBuffer valueBuffer) => valueBuffer[137]);
+            nullableEnum32.SetPropertyIndexes(
+                index: 137,
+                originalValueIndex: 137,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum32),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance);
+            nullableEnum32.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32.TypeMapping.Comparer));
+            nullableEnum32.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32.TypeMapping.KeyComparer));
 
             var nullableEnum32Array = runtimeEntityType.AddProperty(
                 "NullableEnum32Array",
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum32Array.SetGetter(
+                CompiledModelTestBase.Enum32? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32Array(entity) == null,
+                CompiledModelTestBase.Enum32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Array(instance) == null);
+            nullableEnum32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? [] value) => ManyTypesUnsafeAccessors.NullableEnum32Array(entity) = value);
+            nullableEnum32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? [] value) => ManyTypesUnsafeAccessors.NullableEnum32Array(entity) = value);
+            nullableEnum32Array.SetAccessors(
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array, 138),
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[138]);
+            nullableEnum32Array.SetPropertyIndexes(
+                index: 138,
+                originalValueIndex: 138,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum32),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32ArrayElementType.TypeMapping = nullableEnum32Array.TypeMapping.ElementTypeMapping;
+            nullableEnum32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
                 "NullableEnum32AsString",
@@ -973,30 +8162,334 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum32AsString.SetGetter(
+                CompiledModelTestBase.Enum32? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum32AsString(entity).HasValue),
+                CompiledModelTestBase.Enum32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum32AsString(instance).HasValue));
+            nullableEnum32AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? value) => ManyTypesUnsafeAccessors.NullableEnum32AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value))))));
+            nullableEnum32AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? value) => ManyTypesUnsafeAccessors.NullableEnum32AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum32? )(((CompiledModelTestBase.Enum32)(value))))));
+            nullableEnum32AsString.SetAccessors(
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString, 139),
+                CompiledModelTestBase.Enum32? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[139]);
+            nullableEnum32AsString.SetPropertyIndexes(
+                index: 139,
+                originalValueIndex: 139,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum32AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum32),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance);
+            nullableEnum32AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsString.TypeMapping.Comparer));
+            nullableEnum32AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsString.TypeMapping.KeyComparer));
 
             var nullableEnum32AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnum32AsStringArray",
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum32AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum32? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(instance) == null);
+            nullableEnum32AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? [] value) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(entity) = value);
+            nullableEnum32AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? [] value) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(entity) = value);
+            nullableEnum32AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray, 140),
+                CompiledModelTestBase.Enum32? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[140]);
+            nullableEnum32AsStringArray.SetPropertyIndexes(
+                index: 140,
+                originalValueIndex: 140,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum32AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum32),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringArrayElementType.TypeMapping = nullableEnum32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum32AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum32AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum32?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(instance) == null);
+            nullableEnum32AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32?> value) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(entity) = value);
+            nullableEnum32AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32?> value) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(entity) = value);
+            nullableEnum32AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection, 141),
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[141]);
+            nullableEnum32AsStringCollection.SetPropertyIndexes(
+                index: 141,
+                originalValueIndex: 141,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum32AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum32),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringCollectionElementType.TypeMapping = nullableEnum32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
                 "NullableEnum32Collection",
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum32Collection.SetGetter(
+                List<CompiledModelTestBase.Enum32?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32Collection(entity) == null,
+                List<CompiledModelTestBase.Enum32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32Collection(instance) == null);
+            nullableEnum32Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32?> value) => ManyTypesUnsafeAccessors.NullableEnum32Collection(entity) = value);
+            nullableEnum32Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum32?> value) => ManyTypesUnsafeAccessors.NullableEnum32Collection(entity) = value);
+            nullableEnum32Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection, 142),
+                List<CompiledModelTestBase.Enum32?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[142]);
+            nullableEnum32Collection.SetPropertyIndexes(
+                index: 142,
+                originalValueIndex: 142,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum32Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum32),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32CollectionElementType.TypeMapping = nullableEnum32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum32NestedCollection = runtimeEntityType.AddProperty(
                 "NullableEnum32NestedCollection",
                 typeof(CompiledModelTestBase.Enum32?[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum32NestedCollection.SetGetter(
+                CompiledModelTestBase.Enum32? [][][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(entity) == null,
+                CompiledModelTestBase.Enum32? [][][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(instance) == null);
+            nullableEnum32NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? [][][] value) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(entity) = value);
+            nullableEnum32NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum32? [][][] value) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(entity) = value);
+            nullableEnum32NestedCollection.SetAccessors(
+                CompiledModelTestBase.Enum32? [][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? [][][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum32? [][][] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum32? [][][]>(nullableEnum32NestedCollection, 143),
+                CompiledModelTestBase.Enum32? [][][] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum32? [][][]>(nullableEnum32NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[143]);
+            nullableEnum32NestedCollection.SetPropertyIndexes(
+                index: 143,
+                originalValueIndex: 143,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum32NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum32?[][][], CompiledModelTestBase.Enum32?[][]>(new ConvertingValueComparer<CompiledModelTestBase.Enum32?[][], object>(new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum32?[], IEnumerable<CompiledModelTestBase.Enum32?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))))))),
+                keyComparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum32?[][][], CompiledModelTestBase.Enum32?[][]>(new ConvertingValueComparer<CompiledModelTestBase.Enum32?[][], object>(new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum32?[], IEnumerable<CompiledModelTestBase.Enum32?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                    bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?[][]>(new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum32?[][][], CompiledModelTestBase.Enum32?[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum32?[][][], CompiledModelTestBase.Enum32?[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum32?[], IEnumerable<CompiledModelTestBase.Enum32?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))))),
+                    keyComparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum32?[], IEnumerable<CompiledModelTestBase.Enum32?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                        bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?[]>(new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance))),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum32?[][], CompiledModelTestBase.Enum32?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                            bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                        keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(new NullableValueComparer<CompiledModelTestBase.Enum32>(new ValueComparer<CompiledModelTestBase.Enum32>(
+                            bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v))),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance)),
+                        jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum32?[], CompiledModelTestBase.Enum32>(
+                            JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance),
+                        elementMapping: InMemoryTypeMapping.Default.Clone(
+                            comparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                                bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                                int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                                CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                            keyComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                                bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                                int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                                CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                            providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum32>(
+                                bool (CompiledModelTestBase.Enum32 v1, CompiledModelTestBase.Enum32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                                int (CompiledModelTestBase.Enum32 v) => ((object)v).GetHashCode(),
+                                CompiledModelTestBase.Enum32 (CompiledModelTestBase.Enum32 v) => v),
+                            clrType: typeof(CompiledModelTestBase.Enum32),
+                            jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum32>.Instance))));
+            var nullableEnum32NestedCollectionElementType = nullableEnum32NestedCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?[][]));
+            nullableEnum32NestedCollectionElementType.TypeMapping = nullableEnum32NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
                 "NullableEnum64",
@@ -1004,12 +8497,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum64.SetGetter(
+                CompiledModelTestBase.Enum64? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum64(entity).HasValue),
+                CompiledModelTestBase.Enum64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum64(instance).HasValue));
+            nullableEnum64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? value) => ManyTypesUnsafeAccessors.NullableEnum64(entity) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value))))));
+            nullableEnum64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? value) => ManyTypesUnsafeAccessors.NullableEnum64(entity) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value))))));
+            nullableEnum64.SetAccessors(
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64?>(nullableEnum64, 144),
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64),
+                object (ValueBuffer valueBuffer) => valueBuffer[144]);
+            nullableEnum64.SetPropertyIndexes(
+                index: 144,
+                originalValueIndex: 144,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum64),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance);
+            nullableEnum64.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64.TypeMapping.Comparer));
+            nullableEnum64.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64.TypeMapping.KeyComparer));
 
             var nullableEnum64Array = runtimeEntityType.AddProperty(
                 "NullableEnum64Array",
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum64Array.SetGetter(
+                CompiledModelTestBase.Enum64? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64Array(entity) == null,
+                CompiledModelTestBase.Enum64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Array(instance) == null);
+            nullableEnum64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? [] value) => ManyTypesUnsafeAccessors.NullableEnum64Array(entity) = value);
+            nullableEnum64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? [] value) => ManyTypesUnsafeAccessors.NullableEnum64Array(entity) = value);
+            nullableEnum64Array.SetAccessors(
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array, 145),
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[145]);
+            nullableEnum64Array.SetPropertyIndexes(
+                index: 145,
+                originalValueIndex: 145,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum64),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64ArrayElementType.TypeMapping = nullableEnum64Array.TypeMapping.ElementTypeMapping;
+            nullableEnum64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
                 "NullableEnum64AsString",
@@ -1017,24 +8605,233 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum64AsString.SetGetter(
+                CompiledModelTestBase.Enum64? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum64AsString(entity).HasValue),
+                CompiledModelTestBase.Enum64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum64AsString(instance).HasValue));
+            nullableEnum64AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? value) => ManyTypesUnsafeAccessors.NullableEnum64AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value))))));
+            nullableEnum64AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? value) => ManyTypesUnsafeAccessors.NullableEnum64AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum64? )(((CompiledModelTestBase.Enum64)(value))))));
+            nullableEnum64AsString.SetAccessors(
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString, 146),
+                CompiledModelTestBase.Enum64? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[146]);
+            nullableEnum64AsString.SetPropertyIndexes(
+                index: 146,
+                originalValueIndex: 146,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum64AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum64),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance);
+            nullableEnum64AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsString.TypeMapping.Comparer));
+            nullableEnum64AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsString.TypeMapping.KeyComparer));
 
             var nullableEnum64AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnum64AsStringArray",
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum64AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum64? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(instance) == null);
+            nullableEnum64AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? [] value) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(entity) = value);
+            nullableEnum64AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum64? [] value) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(entity) = value);
+            nullableEnum64AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray, 147),
+                CompiledModelTestBase.Enum64? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[147]);
+            nullableEnum64AsStringArray.SetPropertyIndexes(
+                index: 147,
+                originalValueIndex: 147,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum64AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum64?[], CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum64),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringArrayElementType.TypeMapping = nullableEnum64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum64AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum64AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum64?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(instance) == null);
+            nullableEnum64AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64?> value) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(entity) = value);
+            nullableEnum64AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64?> value) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(entity) = value);
+            nullableEnum64AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection, 148),
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[148]);
+            nullableEnum64AsStringCollection.SetPropertyIndexes(
+                index: 148,
+                originalValueIndex: 148,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum64AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum64),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringCollectionElementType.TypeMapping = nullableEnum64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
                 "NullableEnum64Collection",
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum64Collection.SetGetter(
+                List<CompiledModelTestBase.Enum64?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum64Collection(entity) == null,
+                List<CompiledModelTestBase.Enum64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum64Collection(instance) == null);
+            nullableEnum64Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64?> value) => ManyTypesUnsafeAccessors.NullableEnum64Collection(entity) = value);
+            nullableEnum64Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum64?> value) => ManyTypesUnsafeAccessors.NullableEnum64Collection(entity) = value);
+            nullableEnum64Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection, 149),
+                List<CompiledModelTestBase.Enum64?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[149]);
+            nullableEnum64Collection.SetPropertyIndexes(
+                index: 149,
+                originalValueIndex: 149,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum64Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(new NullableValueComparer<CompiledModelTestBase.Enum64>(new ValueComparer<CompiledModelTestBase.Enum64>(
+                    bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum64?>, CompiledModelTestBase.Enum64>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum64>(
+                        bool (CompiledModelTestBase.Enum64 v1, CompiledModelTestBase.Enum64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum64 (CompiledModelTestBase.Enum64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum64),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum64>.Instance));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64CollectionElementType.TypeMapping = nullableEnum64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
                 "NullableEnum8",
@@ -1042,12 +8839,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum8.SetGetter(
+                CompiledModelTestBase.Enum8? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum8(entity).HasValue),
+                CompiledModelTestBase.Enum8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum8(instance).HasValue));
+            nullableEnum8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? value) => ManyTypesUnsafeAccessors.NullableEnum8(entity) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value))))));
+            nullableEnum8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? value) => ManyTypesUnsafeAccessors.NullableEnum8(entity) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value))))));
+            nullableEnum8.SetAccessors(
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8?>(nullableEnum8, 150),
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8),
+                object (ValueBuffer valueBuffer) => valueBuffer[150]);
+            nullableEnum8.SetPropertyIndexes(
+                index: 150,
+                originalValueIndex: 150,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum8),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance);
+            nullableEnum8.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8.TypeMapping.Comparer));
+            nullableEnum8.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8.TypeMapping.KeyComparer));
 
             var nullableEnum8Array = runtimeEntityType.AddProperty(
                 "NullableEnum8Array",
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum8Array.SetGetter(
+                CompiledModelTestBase.Enum8? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8Array(entity) == null,
+                CompiledModelTestBase.Enum8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Array(instance) == null);
+            nullableEnum8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? [] value) => ManyTypesUnsafeAccessors.NullableEnum8Array(entity) = value);
+            nullableEnum8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? [] value) => ManyTypesUnsafeAccessors.NullableEnum8Array(entity) = value);
+            nullableEnum8Array.SetAccessors(
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array, 151),
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[151]);
+            nullableEnum8Array.SetPropertyIndexes(
+                index: 151,
+                originalValueIndex: 151,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum8),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8ArrayElementType.TypeMapping = nullableEnum8Array.TypeMapping.ElementTypeMapping;
+            nullableEnum8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
                 "NullableEnum8AsString",
@@ -1055,30 +8947,313 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnum8AsString.SetGetter(
+                CompiledModelTestBase.Enum8? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnum8AsString(entity).HasValue),
+                CompiledModelTestBase.Enum8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnum8AsString(instance).HasValue));
+            nullableEnum8AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? value) => ManyTypesUnsafeAccessors.NullableEnum8AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value))))));
+            nullableEnum8AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? value) => ManyTypesUnsafeAccessors.NullableEnum8AsString(entity) = (value == null ? value : ((CompiledModelTestBase.Enum8? )(((CompiledModelTestBase.Enum8)(value))))));
+            nullableEnum8AsString.SetAccessors(
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString, 152),
+                CompiledModelTestBase.Enum8? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[152]);
+            nullableEnum8AsString.SetPropertyIndexes(
+                index: 152,
+                originalValueIndex: 152,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum8AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                clrType: typeof(CompiledModelTestBase.Enum8),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance);
+            nullableEnum8AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsString.TypeMapping.Comparer));
+            nullableEnum8AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsString.TypeMapping.KeyComparer));
 
             var nullableEnum8AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnum8AsStringArray",
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
-
-            var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
-                "NullableEnum8AsStringCollection",
+            nullableEnum8AsStringArray.SetGetter(
+                CompiledModelTestBase.Enum8? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(entity) == null,
+                CompiledModelTestBase.Enum8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(instance) == null);
+            nullableEnum8AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? [] value) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(entity) = value);
+            nullableEnum8AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? [] value) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(entity) = value);
+            nullableEnum8AsStringArray.SetAccessors(
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray, 153),
+                CompiledModelTestBase.Enum8? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[153]);
+            nullableEnum8AsStringArray.SetPropertyIndexes(
+                index: 153,
+                originalValueIndex: 153,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum8AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum8),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringArrayElementType.TypeMapping = nullableEnum8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringArrayElementType.TypeMapping.Comparer));
+
+            var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
+                "NullableEnum8AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum8AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.Enum8?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.Enum8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(instance) == null);
+            nullableEnum8AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8?> value) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(entity) = value);
+            nullableEnum8AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8?> value) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(entity) = value);
+            nullableEnum8AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection, 154),
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[154]);
+            nullableEnum8AsStringCollection.SetPropertyIndexes(
+                index: 154,
+                originalValueIndex: 154,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum8AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum8),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringCollectionElementType.TypeMapping = nullableEnum8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
                 "NullableEnum8Collection",
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum8Collection.SetGetter(
+                List<CompiledModelTestBase.Enum8?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8Collection(entity) == null,
+                List<CompiledModelTestBase.Enum8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8Collection(instance) == null);
+            nullableEnum8Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8?> value) => ManyTypesUnsafeAccessors.NullableEnum8Collection(entity) = value);
+            nullableEnum8Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.Enum8?> value) => ManyTypesUnsafeAccessors.NullableEnum8Collection(entity) = value);
+            nullableEnum8Collection.SetAccessors(
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection, 155),
+                List<CompiledModelTestBase.Enum8?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[155]);
+            nullableEnum8Collection.SetPropertyIndexes(
+                index: 155,
+                originalValueIndex: 155,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum8Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8>(
+                    JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.Enum8),
+                    jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8CollectionElementType.TypeMapping = nullableEnum8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum8NestedCollection = runtimeEntityType.AddProperty(
                 "NullableEnum8NestedCollection",
                 typeof(CompiledModelTestBase.Enum8?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnum8NestedCollection.SetGetter(
+                CompiledModelTestBase.Enum8? [][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(entity) == null,
+                CompiledModelTestBase.Enum8? [][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(instance) == null);
+            nullableEnum8NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? [][] value) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(entity) = value);
+            nullableEnum8NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.Enum8? [][] value) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(entity) = value);
+            nullableEnum8NestedCollection.SetAccessors(
+                CompiledModelTestBase.Enum8? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnum8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.Enum8? [][] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum8? [][]>(nullableEnum8NestedCollection, 156),
+                CompiledModelTestBase.Enum8? [][] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum8? [][]>(nullableEnum8NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[156]);
+            nullableEnum8NestedCollection.SetPropertyIndexes(
+                index: 156,
+                originalValueIndex: 156,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnum8NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum8?[][], CompiledModelTestBase.Enum8?[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum8?[], IEnumerable<CompiledModelTestBase.Enum8?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))))),
+                keyComparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.Enum8?[][], CompiledModelTestBase.Enum8?[]>(new ConvertingValueComparer<CompiledModelTestBase.Enum8?[], IEnumerable<CompiledModelTestBase.Enum8?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                    bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?[]>(new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum8?[][], CompiledModelTestBase.Enum8?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.Enum8?[][], CompiledModelTestBase.Enum8?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                    keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(new NullableValueComparer<CompiledModelTestBase.Enum8>(new ValueComparer<CompiledModelTestBase.Enum8>(
+                        bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<CompiledModelTestBase.Enum8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.Enum8?[], CompiledModelTestBase.Enum8>(
+                        JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                            bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                        keyComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                            bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                        providerValueComparer: new ValueComparer<CompiledModelTestBase.Enum8>(
+                            bool (CompiledModelTestBase.Enum8 v1, CompiledModelTestBase.Enum8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.Enum8 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.Enum8 (CompiledModelTestBase.Enum8 v) => v),
+                        clrType: typeof(CompiledModelTestBase.Enum8),
+                        jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.Enum8>.Instance)));
+            var nullableEnum8NestedCollectionElementType = nullableEnum8NestedCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?[]));
+            nullableEnum8NestedCollectionElementType.TypeMapping = nullableEnum8NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
                 "NullableEnumU16",
@@ -1086,12 +9261,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU16.SetGetter(
+                CompiledModelTestBase.EnumU16? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU16(entity).HasValue),
+                CompiledModelTestBase.EnumU16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU16(instance).HasValue));
+            nullableEnumU16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? value) => ManyTypesUnsafeAccessors.NullableEnumU16(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value))))));
+            nullableEnumU16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? value) => ManyTypesUnsafeAccessors.NullableEnumU16(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value))))));
+            nullableEnumU16.SetAccessors(
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16, 157),
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16),
+                object (ValueBuffer valueBuffer) => valueBuffer[157]);
+            nullableEnumU16.SetPropertyIndexes(
+                index: 157,
+                originalValueIndex: 157,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU16),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance);
+            nullableEnumU16.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16.TypeMapping.Comparer));
+            nullableEnumU16.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16.TypeMapping.KeyComparer));
 
             var nullableEnumU16Array = runtimeEntityType.AddProperty(
                 "NullableEnumU16Array",
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU16Array.SetGetter(
+                CompiledModelTestBase.EnumU16? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16Array(entity) == null,
+                CompiledModelTestBase.EnumU16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Array(instance) == null);
+            nullableEnumU16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? [] value) => ManyTypesUnsafeAccessors.NullableEnumU16Array(entity) = value);
+            nullableEnumU16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? [] value) => ManyTypesUnsafeAccessors.NullableEnumU16Array(entity) = value);
+            nullableEnumU16Array.SetAccessors(
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array, 158),
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[158]);
+            nullableEnumU16Array.SetPropertyIndexes(
+                index: 158,
+                originalValueIndex: 158,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU16),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16ArrayElementType.TypeMapping = nullableEnumU16Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsString",
@@ -1099,24 +9369,233 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU16AsString.SetGetter(
+                CompiledModelTestBase.EnumU16? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU16AsString(entity).HasValue),
+                CompiledModelTestBase.EnumU16? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU16AsString(instance).HasValue));
+            nullableEnumU16AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? value) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value))))));
+            nullableEnumU16AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? value) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU16? )(((CompiledModelTestBase.EnumU16)(value))))));
+            nullableEnumU16AsString.SetAccessors(
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString, 159),
+                CompiledModelTestBase.EnumU16? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[159]);
+            nullableEnumU16AsString.SetPropertyIndexes(
+                index: 159,
+                originalValueIndex: 159,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU16AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU16),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance);
+            nullableEnumU16AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsString.TypeMapping.Comparer));
+            nullableEnumU16AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsString.TypeMapping.KeyComparer));
 
             var nullableEnumU16AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsStringArray",
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU16AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU16? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU16? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(instance) == null);
+            nullableEnumU16AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? [] value) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(entity) = value);
+            nullableEnumU16AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU16? [] value) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(entity) = value);
+            nullableEnumU16AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray, 160),
+                CompiledModelTestBase.EnumU16? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[160]);
+            nullableEnumU16AsStringArray.SetPropertyIndexes(
+                index: 160,
+                originalValueIndex: 160,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU16AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU16?[], CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU16),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringArrayElementType.TypeMapping = nullableEnumU16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU16AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU16?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(instance) == null);
+            nullableEnumU16AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16?> value) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(entity) = value);
+            nullableEnumU16AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16?> value) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(entity) = value);
+            nullableEnumU16AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection, 161),
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[161]);
+            nullableEnumU16AsStringCollection.SetPropertyIndexes(
+                index: 161,
+                originalValueIndex: 161,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU16AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU16),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringCollectionElementType.TypeMapping = nullableEnumU16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU16Collection",
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU16Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU16?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU16?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(instance) == null);
+            nullableEnumU16Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16?> value) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(entity) = value);
+            nullableEnumU16Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU16?> value) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(entity) = value);
+            nullableEnumU16Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU16Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection, 162),
+                List<CompiledModelTestBase.EnumU16?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[162]);
+            nullableEnumU16Collection.SetPropertyIndexes(
+                index: 162,
+                originalValueIndex: 162,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU16Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(new NullableValueComparer<CompiledModelTestBase.EnumU16>(new ValueComparer<CompiledModelTestBase.EnumU16>(
+                    bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU16?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU16>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU16>(
+                        bool (CompiledModelTestBase.EnumU16 v1, CompiledModelTestBase.EnumU16 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU16 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU16 (CompiledModelTestBase.EnumU16 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU16),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU16>.Instance));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16CollectionElementType.TypeMapping = nullableEnumU16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
                 "NullableEnumU32",
@@ -1124,12 +9603,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU32.SetGetter(
+                CompiledModelTestBase.EnumU32? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU32(entity).HasValue),
+                CompiledModelTestBase.EnumU32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU32(instance).HasValue));
+            nullableEnumU32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? value) => ManyTypesUnsafeAccessors.NullableEnumU32(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value))))));
+            nullableEnumU32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? value) => ManyTypesUnsafeAccessors.NullableEnumU32(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value))))));
+            nullableEnumU32.SetAccessors(
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32, 163),
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32),
+                object (ValueBuffer valueBuffer) => valueBuffer[163]);
+            nullableEnumU32.SetPropertyIndexes(
+                index: 163,
+                originalValueIndex: 163,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU32),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance);
+            nullableEnumU32.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32.TypeMapping.Comparer));
+            nullableEnumU32.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32.TypeMapping.KeyComparer));
 
             var nullableEnumU32Array = runtimeEntityType.AddProperty(
                 "NullableEnumU32Array",
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU32Array.SetGetter(
+                CompiledModelTestBase.EnumU32? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32Array(entity) == null,
+                CompiledModelTestBase.EnumU32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Array(instance) == null);
+            nullableEnumU32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? [] value) => ManyTypesUnsafeAccessors.NullableEnumU32Array(entity) = value);
+            nullableEnumU32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? [] value) => ManyTypesUnsafeAccessors.NullableEnumU32Array(entity) = value);
+            nullableEnumU32Array.SetAccessors(
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array, 164),
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[164]);
+            nullableEnumU32Array.SetPropertyIndexes(
+                index: 164,
+                originalValueIndex: 164,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU32),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32ArrayElementType.TypeMapping = nullableEnumU32Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsString",
@@ -1137,24 +9711,233 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU32AsString.SetGetter(
+                CompiledModelTestBase.EnumU32? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU32AsString(entity).HasValue),
+                CompiledModelTestBase.EnumU32? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU32AsString(instance).HasValue));
+            nullableEnumU32AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? value) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value))))));
+            nullableEnumU32AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? value) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU32? )(((CompiledModelTestBase.EnumU32)(value))))));
+            nullableEnumU32AsString.SetAccessors(
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString, 165),
+                CompiledModelTestBase.EnumU32? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[165]);
+            nullableEnumU32AsString.SetPropertyIndexes(
+                index: 165,
+                originalValueIndex: 165,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU32AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU32),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance);
+            nullableEnumU32AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsString.TypeMapping.Comparer));
+            nullableEnumU32AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsString.TypeMapping.KeyComparer));
 
             var nullableEnumU32AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsStringArray",
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU32AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU32? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU32? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(instance) == null);
+            nullableEnumU32AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? [] value) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(entity) = value);
+            nullableEnumU32AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU32? [] value) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(entity) = value);
+            nullableEnumU32AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray, 166),
+                CompiledModelTestBase.EnumU32? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[166]);
+            nullableEnumU32AsStringArray.SetPropertyIndexes(
+                index: 166,
+                originalValueIndex: 166,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU32AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU32?[], CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU32),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringArrayElementType.TypeMapping = nullableEnumU32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU32AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU32?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(instance) == null);
+            nullableEnumU32AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32?> value) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(entity) = value);
+            nullableEnumU32AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32?> value) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(entity) = value);
+            nullableEnumU32AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection, 167),
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[167]);
+            nullableEnumU32AsStringCollection.SetPropertyIndexes(
+                index: 167,
+                originalValueIndex: 167,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU32AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU32),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringCollectionElementType.TypeMapping = nullableEnumU32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU32Collection",
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU32Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU32?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU32?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(instance) == null);
+            nullableEnumU32Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32?> value) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(entity) = value);
+            nullableEnumU32Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU32?> value) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(entity) = value);
+            nullableEnumU32Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU32Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection, 168),
+                List<CompiledModelTestBase.EnumU32?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[168]);
+            nullableEnumU32Collection.SetPropertyIndexes(
+                index: 168,
+                originalValueIndex: 168,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU32Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(new NullableValueComparer<CompiledModelTestBase.EnumU32>(new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU32?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                        bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU32),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32CollectionElementType.TypeMapping = nullableEnumU32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
                 "NullableEnumU64",
@@ -1162,12 +9945,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU64.SetGetter(
+                CompiledModelTestBase.EnumU64? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU64(entity).HasValue),
+                CompiledModelTestBase.EnumU64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU64(instance).HasValue));
+            nullableEnumU64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? value) => ManyTypesUnsafeAccessors.NullableEnumU64(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value))))));
+            nullableEnumU64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? value) => ManyTypesUnsafeAccessors.NullableEnumU64(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value))))));
+            nullableEnumU64.SetAccessors(
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64, 169),
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64),
+                object (ValueBuffer valueBuffer) => valueBuffer[169]);
+            nullableEnumU64.SetPropertyIndexes(
+                index: 169,
+                originalValueIndex: 169,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU64),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance);
+            nullableEnumU64.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64.TypeMapping.Comparer));
+            nullableEnumU64.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64.TypeMapping.KeyComparer));
 
             var nullableEnumU64Array = runtimeEntityType.AddProperty(
                 "NullableEnumU64Array",
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU64Array.SetGetter(
+                CompiledModelTestBase.EnumU64? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64Array(entity) == null,
+                CompiledModelTestBase.EnumU64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Array(instance) == null);
+            nullableEnumU64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? [] value) => ManyTypesUnsafeAccessors.NullableEnumU64Array(entity) = value);
+            nullableEnumU64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? [] value) => ManyTypesUnsafeAccessors.NullableEnumU64Array(entity) = value);
+            nullableEnumU64Array.SetAccessors(
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array, 170),
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[170]);
+            nullableEnumU64Array.SetPropertyIndexes(
+                index: 170,
+                originalValueIndex: 170,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU64),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64ArrayElementType.TypeMapping = nullableEnumU64Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsString",
@@ -1175,30 +10053,313 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU64AsString.SetGetter(
+                CompiledModelTestBase.EnumU64? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU64AsString(entity).HasValue),
+                CompiledModelTestBase.EnumU64? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU64AsString(instance).HasValue));
+            nullableEnumU64AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? value) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value))))));
+            nullableEnumU64AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? value) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU64? )(((CompiledModelTestBase.EnumU64)(value))))));
+            nullableEnumU64AsString.SetAccessors(
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString, 171),
+                CompiledModelTestBase.EnumU64? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[171]);
+            nullableEnumU64AsString.SetPropertyIndexes(
+                index: 171,
+                originalValueIndex: 171,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU64AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU64),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance);
+            nullableEnumU64AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsString.TypeMapping.Comparer));
+            nullableEnumU64AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsString.TypeMapping.KeyComparer));
 
             var nullableEnumU64AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsStringArray",
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU64AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU64? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU64? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(instance) == null);
+            nullableEnumU64AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? [] value) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(entity) = value);
+            nullableEnumU64AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? [] value) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(entity) = value);
+            nullableEnumU64AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray, 172),
+                CompiledModelTestBase.EnumU64? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[172]);
+            nullableEnumU64AsStringArray.SetPropertyIndexes(
+                index: 172,
+                originalValueIndex: 172,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU64AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU64),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringArrayElementType.TypeMapping = nullableEnumU64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU64AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU64?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(instance) == null);
+            nullableEnumU64AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64?> value) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(entity) = value);
+            nullableEnumU64AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64?> value) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(entity) = value);
+            nullableEnumU64AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection, 173),
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[173]);
+            nullableEnumU64AsStringCollection.SetPropertyIndexes(
+                index: 173,
+                originalValueIndex: 173,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU64AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU64),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringCollectionElementType.TypeMapping = nullableEnumU64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU64Collection",
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU64Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU64?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU64?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(instance) == null);
+            nullableEnumU64Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64?> value) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(entity) = value);
+            nullableEnumU64Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU64?> value) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(entity) = value);
+            nullableEnumU64Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection, 174),
+                List<CompiledModelTestBase.EnumU64?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[174]);
+            nullableEnumU64Collection.SetPropertyIndexes(
+                index: 174,
+                originalValueIndex: 174,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU64Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU64),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64CollectionElementType.TypeMapping = nullableEnumU64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU64NestedCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU64NestedCollection",
                 typeof(CompiledModelTestBase.EnumU64?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU64NestedCollection.SetGetter(
+                CompiledModelTestBase.EnumU64? [][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(entity) == null,
+                CompiledModelTestBase.EnumU64? [][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(instance) == null);
+            nullableEnumU64NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? [][] value) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(entity) = value);
+            nullableEnumU64NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU64? [][] value) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(entity) = value);
+            nullableEnumU64NestedCollection.SetAccessors(
+                CompiledModelTestBase.EnumU64? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU64? [][] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU64? [][]>(nullableEnumU64NestedCollection, 175),
+                CompiledModelTestBase.EnumU64? [][] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU64? [][]>(nullableEnumU64NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[175]);
+            nullableEnumU64NestedCollection.SetPropertyIndexes(
+                index: 175,
+                originalValueIndex: 175,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU64NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.EnumU64?[][], CompiledModelTestBase.EnumU64?[]>(new ConvertingValueComparer<CompiledModelTestBase.EnumU64?[], IEnumerable<CompiledModelTestBase.EnumU64?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))))),
+                keyComparer: new ListOfReferenceTypesComparer<CompiledModelTestBase.EnumU64?[][], CompiledModelTestBase.EnumU64?[]>(new ConvertingValueComparer<CompiledModelTestBase.EnumU64?[], IEnumerable<CompiledModelTestBase.EnumU64?>>(new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                    bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?[]>(new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.EnumU64?[][], CompiledModelTestBase.EnumU64?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<CompiledModelTestBase.EnumU64?[][], CompiledModelTestBase.EnumU64?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                    keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(new NullableValueComparer<CompiledModelTestBase.EnumU64>(new ValueComparer<CompiledModelTestBase.EnumU64>(
+                        bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU64?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU64?[], CompiledModelTestBase.EnumU64>(
+                        JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                            bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                        keyComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                            bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                        providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU64>(
+                            bool (CompiledModelTestBase.EnumU64 v1, CompiledModelTestBase.EnumU64 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                            int (CompiledModelTestBase.EnumU64 v) => ((object)v).GetHashCode(),
+                            CompiledModelTestBase.EnumU64 (CompiledModelTestBase.EnumU64 v) => v),
+                        clrType: typeof(CompiledModelTestBase.EnumU64),
+                        jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU64>.Instance)));
+            var nullableEnumU64NestedCollectionElementType = nullableEnumU64NestedCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?[]));
+            nullableEnumU64NestedCollectionElementType.TypeMapping = nullableEnumU64NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
                 "NullableEnumU8",
@@ -1206,12 +10367,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU8.SetGetter(
+                CompiledModelTestBase.EnumU8? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU8(entity).HasValue),
+                CompiledModelTestBase.EnumU8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU8(instance).HasValue));
+            nullableEnumU8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? value) => ManyTypesUnsafeAccessors.NullableEnumU8(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value))))));
+            nullableEnumU8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? value) => ManyTypesUnsafeAccessors.NullableEnumU8(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value))))));
+            nullableEnumU8.SetAccessors(
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8, 176),
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8),
+                object (ValueBuffer valueBuffer) => valueBuffer[176]);
+            nullableEnumU8.SetPropertyIndexes(
+                index: 176,
+                originalValueIndex: 176,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU8),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance);
+            nullableEnumU8.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8.TypeMapping.Comparer));
+            nullableEnumU8.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8.TypeMapping.KeyComparer));
 
             var nullableEnumU8Array = runtimeEntityType.AddProperty(
                 "NullableEnumU8Array",
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU8Array.SetGetter(
+                CompiledModelTestBase.EnumU8? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8Array(entity) == null,
+                CompiledModelTestBase.EnumU8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Array(instance) == null);
+            nullableEnumU8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? [] value) => ManyTypesUnsafeAccessors.NullableEnumU8Array(entity) = value);
+            nullableEnumU8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? [] value) => ManyTypesUnsafeAccessors.NullableEnumU8Array(entity) = value);
+            nullableEnumU8Array.SetAccessors(
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array, 177),
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[177]);
+            nullableEnumU8Array.SetPropertyIndexes(
+                index: 177,
+                originalValueIndex: 177,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU8),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8ArrayElementType.TypeMapping = nullableEnumU8Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsString",
@@ -1219,24 +10475,233 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableEnumU8AsString.SetGetter(
+                CompiledModelTestBase.EnumU8? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableEnumU8AsString(entity).HasValue),
+                CompiledModelTestBase.EnumU8? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableEnumU8AsString(instance).HasValue));
+            nullableEnumU8AsString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? value) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value))))));
+            nullableEnumU8AsString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? value) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(entity) = (value == null ? value : ((CompiledModelTestBase.EnumU8? )(((CompiledModelTestBase.EnumU8)(value))))));
+            nullableEnumU8AsString.SetAccessors(
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString, 178),
+                CompiledModelTestBase.EnumU8? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString),
+                object (ValueBuffer valueBuffer) => valueBuffer[178]);
+            nullableEnumU8AsString.SetPropertyIndexes(
+                index: 178,
+                originalValueIndex: 178,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU8AsString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                clrType: typeof(CompiledModelTestBase.EnumU8),
+                jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance);
+            nullableEnumU8AsString.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsString.TypeMapping.Comparer));
+            nullableEnumU8AsString.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsString.TypeMapping.KeyComparer));
 
             var nullableEnumU8AsStringArray = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsStringArray",
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU8AsStringArray.SetGetter(
+                CompiledModelTestBase.EnumU8? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(entity) == null,
+                CompiledModelTestBase.EnumU8? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(instance) == null);
+            nullableEnumU8AsStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? [] value) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(entity) = value);
+            nullableEnumU8AsStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, CompiledModelTestBase.EnumU8? [] value) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(entity) = value);
+            nullableEnumU8AsStringArray.SetAccessors(
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray, 179),
+                CompiledModelTestBase.EnumU8? [] (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[179]);
+            nullableEnumU8AsStringArray.SetPropertyIndexes(
+                index: 179,
+                originalValueIndex: 179,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU8AsStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<CompiledModelTestBase.EnumU8?[], CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU8),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringArrayElementType.TypeMapping = nullableEnumU8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU8AsStringCollection.SetGetter(
+                List<CompiledModelTestBase.EnumU8?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(entity) == null,
+                List<CompiledModelTestBase.EnumU8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(instance) == null);
+            nullableEnumU8AsStringCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8?> value) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(entity) = value);
+            nullableEnumU8AsStringCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8?> value) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(entity) = value);
+            nullableEnumU8AsStringCollection.SetAccessors(
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8AsStringCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection, 180),
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[180]);
+            nullableEnumU8AsStringCollection.SetPropertyIndexes(
+                index: 180,
+                originalValueIndex: 180,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU8AsStringCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU8),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringCollectionElementType.TypeMapping = nullableEnumU8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU8Collection",
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableEnumU8Collection.SetGetter(
+                List<CompiledModelTestBase.EnumU8?> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(entity) == null,
+                List<CompiledModelTestBase.EnumU8?> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(instance) == null);
+            nullableEnumU8Collection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8?> value) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(entity) = value);
+            nullableEnumU8Collection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<CompiledModelTestBase.EnumU8?> value) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(entity) = value);
+            nullableEnumU8Collection.SetAccessors(
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableEnumU8Collection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection, 181),
+                List<CompiledModelTestBase.EnumU8?> (InternalEntityEntry entry) => entry.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection),
+                object (ValueBuffer valueBuffer) => valueBuffer[181]);
+            nullableEnumU8Collection.SetPropertyIndexes(
+                index: 181,
+                originalValueIndex: 181,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableEnumU8Collection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(new NullableValueComparer<CompiledModelTestBase.EnumU8>(new ValueComparer<CompiledModelTestBase.EnumU8>(
+                    bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<CompiledModelTestBase.EnumU8?>(new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<List<CompiledModelTestBase.EnumU8?>, CompiledModelTestBase.EnumU8>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    keyComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU8>(
+                        bool (CompiledModelTestBase.EnumU8 v1, CompiledModelTestBase.EnumU8 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                        int (CompiledModelTestBase.EnumU8 v) => ((object)v).GetHashCode(),
+                        CompiledModelTestBase.EnumU8 (CompiledModelTestBase.EnumU8 v) => v),
+                    clrType: typeof(CompiledModelTestBase.EnumU8),
+                    jsonValueReaderWriter: JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU8>.Instance));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8CollectionElementType.TypeMapping = nullableEnumU8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8CollectionElementType.TypeMapping.Comparer));
 
             var nullableFloat = runtimeEntityType.AddProperty(
                 "NullableFloat",
@@ -1244,12 +10709,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableFloat.SetGetter(
+                float? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableFloat(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableFloat(entity).HasValue),
+                float? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableFloat(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableFloat(instance).HasValue));
+            nullableFloat.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, float? value) => ManyTypesUnsafeAccessors.NullableFloat(entity) = value);
+            nullableFloat.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, float? value) => ManyTypesUnsafeAccessors.NullableFloat(entity) = value);
+            nullableFloat.SetAccessors(
+                float? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableFloat(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableFloat(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float? (InternalEntityEntry entry) => entry.ReadOriginalValue<float?>(nullableFloat, 182),
+                float? (InternalEntityEntry entry) => entry.GetCurrentValue<float?>(nullableFloat),
+                object (ValueBuffer valueBuffer) => valueBuffer[182]);
+            nullableFloat.SetPropertyIndexes(
+                index: 182,
+                originalValueIndex: 182,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableFloat.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v),
+                keyComparer: new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v),
+                providerValueComparer: new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v),
+                clrType: typeof(float),
+                jsonValueReaderWriter: JsonFloatReaderWriter.Instance);
+            nullableFloat.SetComparer(new NullableValueComparer<float>(nullableFloat.TypeMapping.Comparer));
+            nullableFloat.SetKeyComparer(new NullableValueComparer<float>(nullableFloat.TypeMapping.KeyComparer));
 
             var nullableFloatArray = runtimeEntityType.AddProperty(
                 "NullableFloatArray",
                 typeof(float?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableFloatArray.SetGetter(
+                float? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableFloatArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableFloatArray(entity) == null,
+                float? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableFloatArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableFloatArray(instance) == null);
+            nullableFloatArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, float? [] value) => ManyTypesUnsafeAccessors.NullableFloatArray(entity) = value);
+            nullableFloatArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, float? [] value) => ManyTypesUnsafeAccessors.NullableFloatArray(entity) = value);
+            nullableFloatArray.SetAccessors(
+                float? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableFloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableFloatArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                float? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<float? []>(nullableFloatArray, 183),
+                float? [] (InternalEntityEntry entry) => entry.GetCurrentValue<float? []>(nullableFloatArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[183]);
+            nullableFloatArray.SetPropertyIndexes(
+                index: 183,
+                originalValueIndex: 183,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableFloatArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<float?[], float>(new NullableValueComparer<float>(new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<float?[], float>(new NullableValueComparer<float>(new ValueComparer<float>(
+                    bool (float v1, float v2) => v1.Equals(v2),
+                    int (float v) => ((object)v).GetHashCode(),
+                    float (float v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<float?>(new JsonCollectionOfNullableStructsReaderWriter<float?[], float>(
+                    JsonFloatReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<float?[], float>(
+                    JsonFloatReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<float>(
+                        bool (float v1, float v2) => v1.Equals(v2),
+                        int (float v) => ((object)v).GetHashCode(),
+                        float (float v) => v),
+                    keyComparer: new ValueComparer<float>(
+                        bool (float v1, float v2) => v1.Equals(v2),
+                        int (float v) => ((object)v).GetHashCode(),
+                        float (float v) => v),
+                    providerValueComparer: new ValueComparer<float>(
+                        bool (float v1, float v2) => v1.Equals(v2),
+                        int (float v) => ((object)v).GetHashCode(),
+                        float (float v) => v),
+                    clrType: typeof(float),
+                    jsonValueReaderWriter: JsonFloatReaderWriter.Instance));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
+            nullableFloatArrayElementType.TypeMapping = nullableFloatArray.TypeMapping.ElementTypeMapping;
+            nullableFloatArrayElementType.SetComparer(new NullableValueComparer<float>(nullableFloatArrayElementType.TypeMapping.Comparer));
 
             var nullableGuid = runtimeEntityType.AddProperty(
                 "NullableGuid",
@@ -1257,18 +10817,187 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableGuid.SetGetter(
+                Guid? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableGuid(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableGuid(entity).HasValue),
+                Guid? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuid(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableGuid(instance).HasValue));
+            nullableGuid.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid? value) => ManyTypesUnsafeAccessors.NullableGuid(entity) = value);
+            nullableGuid.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid? value) => ManyTypesUnsafeAccessors.NullableGuid(entity) = value);
+            nullableGuid.SetAccessors(
+                Guid? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableGuid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableGuid(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid? (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid?>(nullableGuid, 184),
+                Guid? (InternalEntityEntry entry) => entry.GetCurrentValue<Guid?>(nullableGuid),
+                object (ValueBuffer valueBuffer) => valueBuffer[184]);
+            nullableGuid.SetPropertyIndexes(
+                index: 184,
+                originalValueIndex: 184,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableGuid.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            nullableGuid.SetComparer(new NullableValueComparer<Guid>(nullableGuid.TypeMapping.Comparer));
+            nullableGuid.SetKeyComparer(new NullableValueComparer<Guid>(nullableGuid.TypeMapping.KeyComparer));
 
             var nullableGuidArray = runtimeEntityType.AddProperty(
                 "NullableGuidArray",
                 typeof(Guid?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableGuidArray.SetGetter(
+                Guid? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableGuidArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableGuidArray(entity) == null,
+                Guid? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuidArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuidArray(instance) == null);
+            nullableGuidArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid? [] value) => ManyTypesUnsafeAccessors.NullableGuidArray(entity) = value);
+            nullableGuidArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid? [] value) => ManyTypesUnsafeAccessors.NullableGuidArray(entity) = value);
+            nullableGuidArray.SetAccessors(
+                Guid? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableGuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableGuidArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid? []>(nullableGuidArray, 185),
+                Guid? [] (InternalEntityEntry entry) => entry.GetCurrentValue<Guid? []>(nullableGuidArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[185]);
+            nullableGuidArray.SetPropertyIndexes(
+                index: 185,
+                originalValueIndex: 185,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableGuidArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<Guid?>(new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
+                    JsonGuidReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
+                    JsonGuidReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v),
+                    keyComparer: new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v),
+                    providerValueComparer: new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v),
+                    clrType: typeof(Guid),
+                    jsonValueReaderWriter: JsonGuidReaderWriter.Instance));
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
+            nullableGuidArrayElementType.TypeMapping = nullableGuidArray.TypeMapping.ElementTypeMapping;
+            nullableGuidArrayElementType.SetComparer(new NullableValueComparer<Guid>(nullableGuidArrayElementType.TypeMapping.Comparer));
 
             var nullableGuidNestedCollection = runtimeEntityType.AddProperty(
                 "NullableGuidNestedCollection",
                 typeof(Guid?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableGuidNestedCollection.SetGetter(
+                Guid? [][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(entity) == null,
+                Guid? [][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(instance) == null);
+            nullableGuidNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid? [][] value) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(entity) = value);
+            nullableGuidNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Guid? [][] value) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(entity) = value);
+            nullableGuidNestedCollection.SetAccessors(
+                Guid? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableGuidNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Guid? [][] (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid? [][]>(nullableGuidNestedCollection, 186),
+                Guid? [][] (InternalEntityEntry entry) => entry.GetCurrentValue<Guid? [][]>(nullableGuidNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[186]);
+            nullableGuidNestedCollection.SetPropertyIndexes(
+                index: 186,
+                originalValueIndex: 186,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableGuidNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<Guid?[][], Guid?[]>(new ConvertingValueComparer<Guid?[], IEnumerable<Guid?>>(new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v))))),
+                keyComparer: new ListOfReferenceTypesComparer<Guid?[][], Guid?[]>(new ConvertingValueComparer<Guid?[], IEnumerable<Guid?>>(new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<Guid?[]>(new JsonCollectionOfReferencesReaderWriter<Guid?[][], Guid?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
+                        JsonGuidReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<Guid?[][], Guid?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
+                        JsonGuidReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v))),
+                    keyComparer: new ListOfNullableValueTypesComparer<Guid?[], Guid>(new NullableValueComparer<Guid>(new ValueComparer<Guid>(
+                        bool (Guid v1, Guid v2) => v1 == v2,
+                        int (Guid v) => ((object)v).GetHashCode(),
+                        Guid (Guid v) => v))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<Guid?>(new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
+                        JsonGuidReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
+                        JsonGuidReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<Guid>(
+                            bool (Guid v1, Guid v2) => v1 == v2,
+                            int (Guid v) => ((object)v).GetHashCode(),
+                            Guid (Guid v) => v),
+                        keyComparer: new ValueComparer<Guid>(
+                            bool (Guid v1, Guid v2) => v1 == v2,
+                            int (Guid v) => ((object)v).GetHashCode(),
+                            Guid (Guid v) => v),
+                        providerValueComparer: new ValueComparer<Guid>(
+                            bool (Guid v1, Guid v2) => v1 == v2,
+                            int (Guid v) => ((object)v).GetHashCode(),
+                            Guid (Guid v) => v),
+                        clrType: typeof(Guid),
+                        jsonValueReaderWriter: JsonGuidReaderWriter.Instance)));
+            var nullableGuidNestedCollectionElementType = nullableGuidNestedCollection.SetElementType(typeof(Guid?[]));
+            nullableGuidNestedCollectionElementType.TypeMapping = nullableGuidNestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
                 "NullableIPAddress",
@@ -1276,12 +11005,124 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableIPAddress.SetGetter(
+                IPAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableIPAddress(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableIPAddress(entity) == null,
+                IPAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddress(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddress(instance) == null);
+            nullableIPAddress.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.NullableIPAddress(entity) = value);
+            nullableIPAddress.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress value) => ManyTypesUnsafeAccessors.NullableIPAddress(entity) = value);
+            nullableIPAddress.SetAccessors(
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress>(nullableIPAddress, 187),
+                IPAddress (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress>(nullableIPAddress),
+                object (ValueBuffer valueBuffer) => valueBuffer[187]);
+            nullableIPAddress.SetPropertyIndexes(
+                index: 187,
+                originalValueIndex: 187,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableIPAddress.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                keyComparer: new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<IPAddress, string>(
+                    string (IPAddress v) => ((object)v).ToString(),
+                    IPAddress (string v) => IPAddress.Parse(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v))));
 
             var nullableIPAddressArray = runtimeEntityType.AddProperty(
                 "NullableIPAddressArray",
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableIPAddressArray.SetGetter(
+                IPAddress[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableIPAddressArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableIPAddressArray(entity) == null,
+                IPAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddressArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableIPAddressArray(instance) == null);
+            nullableIPAddressArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress[] value) => ManyTypesUnsafeAccessors.NullableIPAddressArray(entity) = value);
+            nullableIPAddressArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IPAddress[] value) => ManyTypesUnsafeAccessors.NullableIPAddressArray(entity) = value);
+            nullableIPAddressArray.SetAccessors(
+                IPAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableIPAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress[]>(nullableIPAddressArray, 188),
+                IPAddress[] (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress[]>(nullableIPAddressArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[188]);
+            nullableIPAddressArray.SetPropertyIndexes(
+                index: 188,
+                originalValueIndex: 188,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableIPAddressArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
+            nullableIPAddressArrayElementType.TypeMapping = nullableIPAddressArray.TypeMapping.ElementTypeMapping;
 
             var nullableInt16 = runtimeEntityType.AddProperty(
                 "NullableInt16",
@@ -1289,12 +11130,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableInt16.SetGetter(
+                short? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableInt16(entity).HasValue),
+                short? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt16(instance).HasValue));
+            nullableInt16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, short? value) => ManyTypesUnsafeAccessors.NullableInt16(entity) = value);
+            nullableInt16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, short? value) => ManyTypesUnsafeAccessors.NullableInt16(entity) = value);
+            nullableInt16.SetAccessors(
+                short? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short? (InternalEntityEntry entry) => entry.ReadOriginalValue<short?>(nullableInt16, 189),
+                short? (InternalEntityEntry entry) => entry.GetCurrentValue<short?>(nullableInt16),
+                object (ValueBuffer valueBuffer) => valueBuffer[189]);
+            nullableInt16.SetPropertyIndexes(
+                index: 189,
+                originalValueIndex: 189,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v),
+                keyComparer: new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v),
+                providerValueComparer: new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v),
+                clrType: typeof(short),
+                jsonValueReaderWriter: JsonInt16ReaderWriter.Instance);
+            nullableInt16.SetComparer(new NullableValueComparer<short>(nullableInt16.TypeMapping.Comparer));
+            nullableInt16.SetKeyComparer(new NullableValueComparer<short>(nullableInt16.TypeMapping.KeyComparer));
 
             var nullableInt16Array = runtimeEntityType.AddProperty(
                 "NullableInt16Array",
                 typeof(short?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableInt16Array.SetGetter(
+                short? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt16Array(entity) == null,
+                short? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt16Array(instance) == null);
+            nullableInt16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, short? [] value) => ManyTypesUnsafeAccessors.NullableInt16Array(entity) = value);
+            nullableInt16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, short? [] value) => ManyTypesUnsafeAccessors.NullableInt16Array(entity) = value);
+            nullableInt16Array.SetAccessors(
+                short? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                short? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<short? []>(nullableInt16Array, 190),
+                short? [] (InternalEntityEntry entry) => entry.GetCurrentValue<short? []>(nullableInt16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[190]);
+            nullableInt16Array.SetPropertyIndexes(
+                index: 190,
+                originalValueIndex: 190,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<short?[], short>(new NullableValueComparer<short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<short?[], short>(new NullableValueComparer<short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<short?>(new JsonCollectionOfNullableStructsReaderWriter<short?[], short>(
+                    JsonInt16ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<short?[], short>(
+                    JsonInt16ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    keyComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    providerValueComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    clrType: typeof(short),
+                    jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
+            nullableInt16ArrayElementType.TypeMapping = nullableInt16Array.TypeMapping.ElementTypeMapping;
+            nullableInt16ArrayElementType.SetComparer(new NullableValueComparer<short>(nullableInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt32 = runtimeEntityType.AddProperty(
                 "NullableInt32",
@@ -1302,18 +11238,187 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableInt32.SetGetter(
+                int? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableInt32(entity).HasValue),
+                int? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt32(instance).HasValue));
+            nullableInt32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? value) => ManyTypesUnsafeAccessors.NullableInt32(entity) = value);
+            nullableInt32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? value) => ManyTypesUnsafeAccessors.NullableInt32(entity) = value);
+            nullableInt32.SetAccessors(
+                int? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? (InternalEntityEntry entry) => entry.ReadOriginalValue<int?>(nullableInt32, 191),
+                int? (InternalEntityEntry entry) => entry.GetCurrentValue<int?>(nullableInt32),
+                object (ValueBuffer valueBuffer) => valueBuffer[191]);
+            nullableInt32.SetPropertyIndexes(
+                index: 191,
+                originalValueIndex: 191,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                clrType: typeof(int),
+                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);
+            nullableInt32.SetComparer(new NullableValueComparer<int>(nullableInt32.TypeMapping.Comparer));
+            nullableInt32.SetKeyComparer(new NullableValueComparer<int>(nullableInt32.TypeMapping.KeyComparer));
 
             var nullableInt32Array = runtimeEntityType.AddProperty(
                 "NullableInt32Array",
                 typeof(int?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableInt32Array.SetGetter(
+                int? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt32Array(entity) == null,
+                int? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32Array(instance) == null);
+            nullableInt32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? [] value) => ManyTypesUnsafeAccessors.NullableInt32Array(entity) = value);
+            nullableInt32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? [] value) => ManyTypesUnsafeAccessors.NullableInt32Array(entity) = value);
+            nullableInt32Array.SetAccessors(
+                int? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<int? []>(nullableInt32Array, 192),
+                int? [] (InternalEntityEntry entry) => entry.GetCurrentValue<int? []>(nullableInt32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[192]);
+            nullableInt32Array.SetPropertyIndexes(
+                index: 192,
+                originalValueIndex: 192,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<int?>(new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
+                    JsonInt32ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
+                    JsonInt32ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    keyComparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    providerValueComparer: new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v),
+                    clrType: typeof(int),
+                    jsonValueReaderWriter: JsonInt32ReaderWriter.Instance));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
+            nullableInt32ArrayElementType.TypeMapping = nullableInt32Array.TypeMapping.ElementTypeMapping;
+            nullableInt32ArrayElementType.SetComparer(new NullableValueComparer<int>(nullableInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt32NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt32NestedCollection",
                 typeof(int?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableInt32NestedCollection.SetGetter(
+                int? [][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(entity) == null,
+                int? [][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(instance) == null);
+            nullableInt32NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? [][] value) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(entity) = value);
+            nullableInt32NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, int? [][] value) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(entity) = value);
+            nullableInt32NestedCollection.SetAccessors(
+                int? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt32NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                int? [][] (InternalEntityEntry entry) => entry.ReadOriginalValue<int? [][]>(nullableInt32NestedCollection, 193),
+                int? [][] (InternalEntityEntry entry) => entry.GetCurrentValue<int? [][]>(nullableInt32NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[193]);
+            nullableInt32NestedCollection.SetPropertyIndexes(
+                index: 193,
+                originalValueIndex: 193,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt32NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<int?[][], int?[]>(new ConvertingValueComparer<int?[], IEnumerable<int?>>(new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v))))),
+                keyComparer: new ListOfReferenceTypesComparer<int?[][], int?[]>(new ConvertingValueComparer<int?[], IEnumerable<int?>>(new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<int?[]>(new JsonCollectionOfReferencesReaderWriter<int?[][], int?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
+                        JsonInt32ReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<int?[][], int?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
+                        JsonInt32ReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v))),
+                    keyComparer: new ListOfNullableValueTypesComparer<int?[], int>(new NullableValueComparer<int>(new ValueComparer<int>(
+                        bool (int v1, int v2) => v1 == v2,
+                        int (int v) => v,
+                        int (int v) => v))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<int?>(new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
+                        JsonInt32ReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<int?[], int>(
+                        JsonInt32ReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<int>(
+                            bool (int v1, int v2) => v1 == v2,
+                            int (int v) => v,
+                            int (int v) => v),
+                        keyComparer: new ValueComparer<int>(
+                            bool (int v1, int v2) => v1 == v2,
+                            int (int v) => v,
+                            int (int v) => v),
+                        providerValueComparer: new ValueComparer<int>(
+                            bool (int v1, int v2) => v1 == v2,
+                            int (int v) => v,
+                            int (int v) => v),
+                        clrType: typeof(int),
+                        jsonValueReaderWriter: JsonInt32ReaderWriter.Instance)));
+            var nullableInt32NestedCollectionElementType = nullableInt32NestedCollection.SetElementType(typeof(int?[]));
+            nullableInt32NestedCollectionElementType.TypeMapping = nullableInt32NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableInt64 = runtimeEntityType.AddProperty(
                 "NullableInt64",
@@ -1321,18 +11426,208 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableInt64.SetGetter(
+                long? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableInt64(entity).HasValue),
+                long? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt64(instance).HasValue));
+            nullableInt64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, long? value) => ManyTypesUnsafeAccessors.NullableInt64(entity) = value);
+            nullableInt64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, long? value) => ManyTypesUnsafeAccessors.NullableInt64(entity) = value);
+            nullableInt64.SetAccessors(
+                long? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long? (InternalEntityEntry entry) => entry.ReadOriginalValue<long?>(nullableInt64, 194),
+                long? (InternalEntityEntry entry) => entry.GetCurrentValue<long?>(nullableInt64),
+                object (ValueBuffer valueBuffer) => valueBuffer[194]);
+            nullableInt64.SetPropertyIndexes(
+                index: 194,
+                originalValueIndex: 194,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
+            nullableInt64.SetComparer(new NullableValueComparer<long>(nullableInt64.TypeMapping.Comparer));
+            nullableInt64.SetKeyComparer(new NullableValueComparer<long>(nullableInt64.TypeMapping.KeyComparer));
 
             var nullableInt64Array = runtimeEntityType.AddProperty(
                 "NullableInt64Array",
                 typeof(long?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableInt64Array.SetGetter(
+                long? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt64Array(entity) == null,
+                long? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64Array(instance) == null);
+            nullableInt64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, long? [] value) => ManyTypesUnsafeAccessors.NullableInt64Array(entity) = value);
+            nullableInt64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, long? [] value) => ManyTypesUnsafeAccessors.NullableInt64Array(entity) = value);
+            nullableInt64Array.SetAccessors(
+                long? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                long? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<long? []>(nullableInt64Array, 195),
+                long? [] (InternalEntityEntry entry) => entry.GetCurrentValue<long? []>(nullableInt64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[195]);
+            nullableInt64Array.SetPropertyIndexes(
+                index: 195,
+                originalValueIndex: 195,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<long?>(new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                    JsonInt64ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                    JsonInt64ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v),
+                    keyComparer: new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v),
+                    providerValueComparer: new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v),
+                    clrType: typeof(long),
+                    jsonValueReaderWriter: JsonInt64ReaderWriter.Instance));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
+            nullableInt64ArrayElementType.TypeMapping = nullableInt64Array.TypeMapping.ElementTypeMapping;
+            nullableInt64ArrayElementType.SetComparer(new NullableValueComparer<long>(nullableInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt64NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt64NestedCollection",
                 typeof(List<long?[][]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableInt64NestedCollection.SetGetter(
+                List<long? [][]> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(entity) == null,
+                List<long? [][]> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(instance) == null);
+            nullableInt64NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<long? [][]> value) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(entity) = value);
+            nullableInt64NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<long? [][]> value) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(entity) = value);
+            nullableInt64NestedCollection.SetAccessors(
+                List<long? [][]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<long? [][]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt64NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<long? [][]> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<long? [][]>>(nullableInt64NestedCollection, 196),
+                List<long? [][]> (InternalEntityEntry entry) => entry.GetCurrentValue<List<long? [][]>>(nullableInt64NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[196]);
+            nullableInt64NestedCollection.SetPropertyIndexes(
+                index: 196,
+                originalValueIndex: 196,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt64NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<long?[][]>, long?[][]>(new ConvertingValueComparer<long?[][], object>(new ListOfReferenceTypesComparer<long?[][], long?[]>(new ConvertingValueComparer<long?[], IEnumerable<long?>>(new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v))))))),
+                keyComparer: new ListOfReferenceTypesComparer<List<long?[][]>, long?[][]>(new ConvertingValueComparer<long?[][], object>(new ListOfReferenceTypesComparer<long?[][], long?[]>(new ConvertingValueComparer<long?[], IEnumerable<long?>>(new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v))))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<long?[][]>(new JsonCollectionOfReferencesReaderWriter<List<long?[][]>, long?[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<long?[][], long?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                            JsonInt64ReaderWriter.Instance)))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<long?[][]>, long?[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<long?[][], long?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                            JsonInt64ReaderWriter.Instance))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<long?[][], long?[]>(new ConvertingValueComparer<long?[], IEnumerable<long?>>(new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v))))),
+                    keyComparer: new ListOfReferenceTypesComparer<long?[][], long?[]>(new ConvertingValueComparer<long?[], IEnumerable<long?>>(new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                        bool (long v1, long v2) => v1 == v2,
+                        int (long v) => ((object)v).GetHashCode(),
+                        long (long v) => v))))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<long?[]>(new JsonCollectionOfReferencesReaderWriter<long?[][], long?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                            JsonInt64ReaderWriter.Instance))),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<long?[][], long?[]>(
+                        new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                            JsonInt64ReaderWriter.Instance)),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                            bool (long v1, long v2) => v1 == v2,
+                            int (long v) => ((object)v).GetHashCode(),
+                            long (long v) => v))),
+                        keyComparer: new ListOfNullableValueTypesComparer<long?[], long>(new NullableValueComparer<long>(new ValueComparer<long>(
+                            bool (long v1, long v2) => v1 == v2,
+                            int (long v) => ((object)v).GetHashCode(),
+                            long (long v) => v))),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        converter: new CollectionToJsonStringConverter<long?>(new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                            JsonInt64ReaderWriter.Instance)),
+                        jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<long?[], long>(
+                            JsonInt64ReaderWriter.Instance),
+                        elementMapping: InMemoryTypeMapping.Default.Clone(
+                            comparer: new ValueComparer<long>(
+                                bool (long v1, long v2) => v1 == v2,
+                                int (long v) => ((object)v).GetHashCode(),
+                                long (long v) => v),
+                            keyComparer: new ValueComparer<long>(
+                                bool (long v1, long v2) => v1 == v2,
+                                int (long v) => ((object)v).GetHashCode(),
+                                long (long v) => v),
+                            providerValueComparer: new ValueComparer<long>(
+                                bool (long v1, long v2) => v1 == v2,
+                                int (long v) => ((object)v).GetHashCode(),
+                                long (long v) => v),
+                            clrType: typeof(long),
+                            jsonValueReaderWriter: JsonInt64ReaderWriter.Instance))));
+            var nullableInt64NestedCollectionElementType = nullableInt64NestedCollection.SetElementType(typeof(long?[][]));
+            nullableInt64NestedCollectionElementType.TypeMapping = nullableInt64NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableInt8 = runtimeEntityType.AddProperty(
                 "NullableInt8",
@@ -1340,12 +11635,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableInt8.SetGetter(
+                sbyte? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableInt8(entity).HasValue),
+                sbyte? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableInt8(instance).HasValue));
+            nullableInt8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte? value) => ManyTypesUnsafeAccessors.NullableInt8(entity) = value);
+            nullableInt8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte? value) => ManyTypesUnsafeAccessors.NullableInt8(entity) = value);
+            nullableInt8.SetAccessors(
+                sbyte? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte? (InternalEntityEntry entry) => entry.ReadOriginalValue<sbyte?>(nullableInt8, 197),
+                sbyte? (InternalEntityEntry entry) => entry.GetCurrentValue<sbyte?>(nullableInt8),
+                object (ValueBuffer valueBuffer) => valueBuffer[197]);
+            nullableInt8.SetPropertyIndexes(
+                index: 197,
+                originalValueIndex: 197,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v),
+                keyComparer: new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v),
+                providerValueComparer: new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v),
+                clrType: typeof(sbyte),
+                jsonValueReaderWriter: JsonSByteReaderWriter.Instance);
+            nullableInt8.SetComparer(new NullableValueComparer<sbyte>(nullableInt8.TypeMapping.Comparer));
+            nullableInt8.SetKeyComparer(new NullableValueComparer<sbyte>(nullableInt8.TypeMapping.KeyComparer));
 
             var nullableInt8Array = runtimeEntityType.AddProperty(
                 "NullableInt8Array",
                 typeof(sbyte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableInt8Array.SetGetter(
+                sbyte? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableInt8Array(entity) == null,
+                sbyte? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableInt8Array(instance) == null);
+            nullableInt8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte? [] value) => ManyTypesUnsafeAccessors.NullableInt8Array(entity) = value);
+            nullableInt8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, sbyte? [] value) => ManyTypesUnsafeAccessors.NullableInt8Array(entity) = value);
+            nullableInt8Array.SetAccessors(
+                sbyte? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                sbyte? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<sbyte? []>(nullableInt8Array, 198),
+                sbyte? [] (InternalEntityEntry entry) => entry.GetCurrentValue<sbyte? []>(nullableInt8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[198]);
+            nullableInt8Array.SetPropertyIndexes(
+                index: 198,
+                originalValueIndex: 198,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableInt8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<sbyte?[], sbyte>(new NullableValueComparer<sbyte>(new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<sbyte?[], sbyte>(new NullableValueComparer<sbyte>(new ValueComparer<sbyte>(
+                    bool (sbyte v1, sbyte v2) => v1 == v2,
+                    int (sbyte v) => ((int)(v)),
+                    sbyte (sbyte v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<sbyte?>(new JsonCollectionOfNullableStructsReaderWriter<sbyte?[], sbyte>(
+                    JsonSByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<sbyte?[], sbyte>(
+                    JsonSByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v),
+                    keyComparer: new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v),
+                    providerValueComparer: new ValueComparer<sbyte>(
+                        bool (sbyte v1, sbyte v2) => v1 == v2,
+                        int (sbyte v) => ((int)(v)),
+                        sbyte (sbyte v) => v),
+                    clrType: typeof(sbyte),
+                    jsonValueReaderWriter: JsonSByteReaderWriter.Instance));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
+            nullableInt8ArrayElementType.TypeMapping = nullableInt8Array.TypeMapping.ElementTypeMapping;
+            nullableInt8ArrayElementType.SetComparer(new NullableValueComparer<sbyte>(nullableInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddress",
@@ -1353,18 +11743,255 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullablePhysicalAddress.SetGetter(
+                PhysicalAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(entity) == null,
+                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(instance) == null);
+            nullablePhysicalAddress.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(entity) = value);
+            nullablePhysicalAddress.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(entity) = value);
+            nullablePhysicalAddress.SetAccessors(
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(nullablePhysicalAddress, 199),
+                PhysicalAddress (InternalEntityEntry entry) => entry.GetCurrentValue<PhysicalAddress>(nullablePhysicalAddress),
+                object (ValueBuffer valueBuffer) => valueBuffer[199]);
+            nullablePhysicalAddress.SetPropertyIndexes(
+                index: 199,
+                originalValueIndex: 199,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullablePhysicalAddress.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                keyComparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<PhysicalAddress, string>(
+                    string (PhysicalAddress v) => ((object)v).ToString(),
+                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<PhysicalAddress, string>(
+                        string (PhysicalAddress v) => ((object)v).ToString(),
+                        PhysicalAddress (string v) => PhysicalAddress.Parse(v))));
 
             var nullablePhysicalAddressArray = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddressArray",
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullablePhysicalAddressArray.SetGetter(
+                PhysicalAddress[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(entity) == null,
+                PhysicalAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(instance) == null);
+            nullablePhysicalAddressArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress[] value) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(entity) = value);
+            nullablePhysicalAddressArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress[] value) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(entity) = value);
+            nullablePhysicalAddressArray.SetAccessors(
+                PhysicalAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress[] (InternalEntityEntry entry) => entry.ReadOriginalValue<PhysicalAddress[]>(nullablePhysicalAddressArray, 200),
+                PhysicalAddress[] (InternalEntityEntry entry) => entry.GetCurrentValue<PhysicalAddress[]>(nullablePhysicalAddressArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[200]);
+            nullablePhysicalAddressArray.SetPropertyIndexes(
+                index: 200,
+                originalValueIndex: 200,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullablePhysicalAddressArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<PhysicalAddress, string>(
+                            string (PhysicalAddress v) => ((object)v).ToString(),
+                            PhysicalAddress (string v) => PhysicalAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<PhysicalAddress, string>(
+                            string (PhysicalAddress v) => ((object)v).ToString(),
+                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<PhysicalAddress>(
+                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                        PhysicalAddress (PhysicalAddress v) => v),
+                    keyComparer: new ValueComparer<PhysicalAddress>(
+                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                        PhysicalAddress (PhysicalAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<PhysicalAddress, string>(
+                        string (PhysicalAddress v) => ((object)v).ToString(),
+                        PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<PhysicalAddress, string>(
+                            string (PhysicalAddress v) => ((object)v).ToString(),
+                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
+            nullablePhysicalAddressArrayElementType.TypeMapping = nullablePhysicalAddressArray.TypeMapping.ElementTypeMapping;
 
             var nullablePhysicalAddressNestedCollection = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddressNestedCollection",
                 typeof(IEnumerable<PhysicalAddress[][]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullablePhysicalAddressNestedCollection.SetGetter(
+                IEnumerable<PhysicalAddress[][]> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(entity) == null,
+                IEnumerable<PhysicalAddress[][]> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(instance) == null);
+            nullablePhysicalAddressNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IEnumerable<PhysicalAddress[][]> value) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(entity) = value);
+            nullablePhysicalAddressNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IEnumerable<PhysicalAddress[][]> value) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(entity) = value);
+            nullablePhysicalAddressNestedCollection.SetAccessors(
+                IEnumerable<PhysicalAddress[][]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IEnumerable<PhysicalAddress[][]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullablePhysicalAddressNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                IEnumerable<PhysicalAddress[][]> (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<PhysicalAddress[][]>>(nullablePhysicalAddressNestedCollection, 201),
+                IEnumerable<PhysicalAddress[][]> (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<PhysicalAddress[][]>>(nullablePhysicalAddressNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[201]);
+            nullablePhysicalAddressNestedCollection.SetPropertyIndexes(
+                index: 201,
+                originalValueIndex: 201,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullablePhysicalAddressNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<PhysicalAddress[][]>, PhysicalAddress[][]>(new ConvertingValueComparer<PhysicalAddress[][], object>(new ListOfReferenceTypesComparer<PhysicalAddress[][], PhysicalAddress[]>(new ConvertingValueComparer<PhysicalAddress[], object>(new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v)))))),
+                keyComparer: new ListOfReferenceTypesComparer<List<PhysicalAddress[][]>, PhysicalAddress[][]>(new ConvertingValueComparer<PhysicalAddress[][], object>(new ListOfReferenceTypesComparer<PhysicalAddress[][], PhysicalAddress[]>(new ConvertingValueComparer<PhysicalAddress[], object>(new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v)))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<PhysicalAddress[][]>(new JsonCollectionOfReferencesReaderWriter<List<PhysicalAddress[][]>, PhysicalAddress[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[][], PhysicalAddress[]>(
+                        new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                            new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                                JsonStringReaderWriter.Instance,
+                                new ValueConverter<PhysicalAddress, string>(
+                                    string (PhysicalAddress v) => ((object)v).ToString(),
+                                    PhysicalAddress (string v) => PhysicalAddress.Parse(v))))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<PhysicalAddress[][]>, PhysicalAddress[][]>(
+                    new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[][], PhysicalAddress[]>(
+                        new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                            new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                                JsonStringReaderWriter.Instance,
+                                new ValueConverter<PhysicalAddress, string>(
+                                    string (PhysicalAddress v) => ((object)v).ToString(),
+                                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)))))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<PhysicalAddress[][], PhysicalAddress[]>(new ConvertingValueComparer<PhysicalAddress[], object>(new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                        PhysicalAddress (PhysicalAddress v) => v)))),
+                    keyComparer: new ListOfReferenceTypesComparer<PhysicalAddress[][], PhysicalAddress[]>(new ConvertingValueComparer<PhysicalAddress[], object>(new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                        PhysicalAddress (PhysicalAddress v) => v)))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<PhysicalAddress[]>(new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[][], PhysicalAddress[]>(
+                        new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                            new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                                JsonStringReaderWriter.Instance,
+                                new ValueConverter<PhysicalAddress, string>(
+                                    string (PhysicalAddress v) => ((object)v).ToString(),
+                                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)))))),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[][], PhysicalAddress[]>(
+                        new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                            new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                                JsonStringReaderWriter.Instance,
+                                new ValueConverter<PhysicalAddress, string>(
+                                    string (PhysicalAddress v) => ((object)v).ToString(),
+                                    PhysicalAddress (string v) => PhysicalAddress.Parse(v))))),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                            bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                            int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                            PhysicalAddress (PhysicalAddress v) => v)),
+                        keyComparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                            bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                            int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                            PhysicalAddress (PhysicalAddress v) => v)),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                            new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                                JsonStringReaderWriter.Instance,
+                                new ValueConverter<PhysicalAddress, string>(
+                                    string (PhysicalAddress v) => ((object)v).ToString(),
+                                    PhysicalAddress (string v) => PhysicalAddress.Parse(v))))),
+                        jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                            new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                                JsonStringReaderWriter.Instance,
+                                new ValueConverter<PhysicalAddress, string>(
+                                    string (PhysicalAddress v) => ((object)v).ToString(),
+                                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)))),
+                        elementMapping: InMemoryTypeMapping.Default.Clone(
+                            comparer: new ValueComparer<PhysicalAddress>(
+                                bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                                int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                                PhysicalAddress (PhysicalAddress v) => v),
+                            keyComparer: new ValueComparer<PhysicalAddress>(
+                                bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                                int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                                PhysicalAddress (PhysicalAddress v) => v),
+                            providerValueComparer: new ValueComparer<string>(
+                                bool (string v1, string v2) => v1 == v2,
+                                int (string v) => ((object)v).GetHashCode(),
+                                string (string v) => v),
+                            converter: new ValueConverter<PhysicalAddress, string>(
+                                string (PhysicalAddress v) => ((object)v).ToString(),
+                                PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
+                            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                                JsonStringReaderWriter.Instance,
+                                new ValueConverter<PhysicalAddress, string>(
+                                    string (PhysicalAddress v) => ((object)v).ToString(),
+                                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)))))));
+            var nullablePhysicalAddressNestedCollectionElementType = nullablePhysicalAddressNestedCollection.SetElementType(typeof(PhysicalAddress[][]));
+            nullablePhysicalAddressNestedCollectionElementType.TypeMapping = nullablePhysicalAddressNestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableString = runtimeEntityType.AddProperty(
                 "NullableString",
@@ -1372,18 +11999,184 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableString.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableString(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableString(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableString(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableString(instance) == null);
+            nullableString.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.NullableString(entity) = value);
+            nullableString.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.NullableString(entity) = value);
+            nullableString.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableString(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(nullableString, 202),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(nullableString),
+                object (ValueBuffer valueBuffer) => valueBuffer[202]);
+            nullableString.SetPropertyIndexes(
+                index: 202,
+                originalValueIndex: 202,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableString.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                clrType: typeof(string),
+                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
 
             var nullableStringArray = runtimeEntityType.AddProperty(
                 "NullableStringArray",
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableStringArray.SetGetter(
+                string[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableStringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableStringArray(entity) == null,
+                string[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableStringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableStringArray(instance) == null);
+            nullableStringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[] value) => ManyTypesUnsafeAccessors.NullableStringArray(entity) = value);
+            nullableStringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[] value) => ManyTypesUnsafeAccessors.NullableStringArray(entity) = value);
+            nullableStringArray.SetAccessors(
+                string[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableStringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[] (InternalEntityEntry entry) => entry.ReadOriginalValue<string[]>(nullableStringArray, 203),
+                string[] (InternalEntityEntry entry) => entry.GetCurrentValue<string[]>(nullableStringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[203]);
+            nullableStringArray.SetPropertyIndexes(
+                index: 203,
+                originalValueIndex: 203,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableStringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
+            nullableStringArrayElementType.TypeMapping = nullableStringArray.TypeMapping.ElementTypeMapping;
 
             var nullableStringNestedCollection = runtimeEntityType.AddProperty(
                 "NullableStringNestedCollection",
                 typeof(string[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableStringNestedCollection.SetGetter(
+                string[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(entity) == null,
+                string[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(instance) == null);
+            nullableStringNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[][] value) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(entity) = value);
+            nullableStringNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[][] value) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(entity) = value);
+            nullableStringNestedCollection.SetAccessors(
+                string[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableStringNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<string[][]>(nullableStringNestedCollection, 204),
+                string[][] (InternalEntityEntry entry) => entry.GetCurrentValue<string[][]>(nullableStringNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[204]);
+            nullableStringNestedCollection.SetPropertyIndexes(
+                index: 204,
+                originalValueIndex: 204,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableStringNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<string[][], string[]>(new ConvertingValueComparer<string[], object>(new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<string[][], string[]>(new ConvertingValueComparer<string[], object>(new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string[]>(new JsonCollectionOfReferencesReaderWriter<string[][], string[]>(
+                    new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[][], string[]>(
+                    new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v)),
+                    keyComparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        keyComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        clrType: typeof(string),
+                        jsonValueReaderWriter: JsonStringReaderWriter.Instance)));
+            var nullableStringNestedCollectionElementType = nullableStringNestedCollection.SetElementType(typeof(string[]));
+            nullableStringNestedCollectionElementType.TypeMapping = nullableStringNestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
                 "NullableTimeOnly",
@@ -1391,12 +12184,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableTimeOnly.SetGetter(
+                TimeOnly? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableTimeOnly(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableTimeOnly(entity).HasValue),
+                TimeOnly? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeOnly(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableTimeOnly(instance).HasValue));
+            nullableTimeOnly.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly? value) => ManyTypesUnsafeAccessors.NullableTimeOnly(entity) = value);
+            nullableTimeOnly.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly? value) => ManyTypesUnsafeAccessors.NullableTimeOnly(entity) = value);
+            nullableTimeOnly.SetAccessors(
+                TimeOnly? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly? (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeOnly?>(nullableTimeOnly, 205),
+                TimeOnly? (InternalEntityEntry entry) => entry.GetCurrentValue<TimeOnly?>(nullableTimeOnly),
+                object (ValueBuffer valueBuffer) => valueBuffer[205]);
+            nullableTimeOnly.SetPropertyIndexes(
+                index: 205,
+                originalValueIndex: 205,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableTimeOnly.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                keyComparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                providerValueComparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                clrType: typeof(TimeOnly),
+                jsonValueReaderWriter: JsonTimeOnlyReaderWriter.Instance);
+            nullableTimeOnly.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnly.TypeMapping.Comparer));
+            nullableTimeOnly.SetKeyComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnly.TypeMapping.KeyComparer));
 
             var nullableTimeOnlyArray = runtimeEntityType.AddProperty(
                 "NullableTimeOnlyArray",
                 typeof(TimeOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableTimeOnlyArray.SetGetter(
+                TimeOnly? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(entity) == null,
+                TimeOnly? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(instance) == null);
+            nullableTimeOnlyArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly? [] value) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(entity) = value);
+            nullableTimeOnlyArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly? [] value) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(entity) = value);
+            nullableTimeOnlyArray.SetAccessors(
+                TimeOnly? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeOnly? []>(nullableTimeOnlyArray, 206),
+                TimeOnly? [] (InternalEntityEntry entry) => entry.GetCurrentValue<TimeOnly? []>(nullableTimeOnlyArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[206]);
+            nullableTimeOnlyArray.SetPropertyIndexes(
+                index: 206,
+                originalValueIndex: 206,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableTimeOnlyArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<TimeOnly?[], TimeOnly>(new NullableValueComparer<TimeOnly>(new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<TimeOnly?[], TimeOnly>(new NullableValueComparer<TimeOnly>(new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<TimeOnly?>(new JsonCollectionOfNullableStructsReaderWriter<TimeOnly?[], TimeOnly>(
+                    JsonTimeOnlyReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<TimeOnly?[], TimeOnly>(
+                    JsonTimeOnlyReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<TimeOnly>(
+                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                        int (TimeOnly v) => ((object)v).GetHashCode(),
+                        TimeOnly (TimeOnly v) => v),
+                    keyComparer: new ValueComparer<TimeOnly>(
+                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                        int (TimeOnly v) => ((object)v).GetHashCode(),
+                        TimeOnly (TimeOnly v) => v),
+                    providerValueComparer: new ValueComparer<TimeOnly>(
+                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                        int (TimeOnly v) => ((object)v).GetHashCode(),
+                        TimeOnly (TimeOnly v) => v),
+                    clrType: typeof(TimeOnly),
+                    jsonValueReaderWriter: JsonTimeOnlyReaderWriter.Instance));
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
+            nullableTimeOnlyArrayElementType.TypeMapping = nullableTimeOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableTimeOnlyArrayElementType.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnlyArrayElementType.TypeMapping.Comparer));
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
                 "NullableTimeSpan",
@@ -1404,12 +12292,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableTimeSpan.SetGetter(
+                TimeSpan? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableTimeSpan(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableTimeSpan(entity).HasValue),
+                TimeSpan? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeSpan(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableTimeSpan(instance).HasValue));
+            nullableTimeSpan.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan? value) => ManyTypesUnsafeAccessors.NullableTimeSpan(entity) = value);
+            nullableTimeSpan.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan? value) => ManyTypesUnsafeAccessors.NullableTimeSpan(entity) = value);
+            nullableTimeSpan.SetAccessors(
+                TimeSpan? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan? (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeSpan?>(nullableTimeSpan, 207),
+                TimeSpan? (InternalEntityEntry entry) => entry.GetCurrentValue<TimeSpan?>(nullableTimeSpan),
+                object (ValueBuffer valueBuffer) => valueBuffer[207]);
+            nullableTimeSpan.SetPropertyIndexes(
+                index: 207,
+                originalValueIndex: 207,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableTimeSpan.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                keyComparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                providerValueComparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                clrType: typeof(TimeSpan),
+                jsonValueReaderWriter: JsonTimeSpanReaderWriter.Instance);
+            nullableTimeSpan.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpan.TypeMapping.Comparer));
+            nullableTimeSpan.SetKeyComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpan.TypeMapping.KeyComparer));
 
             var nullableTimeSpanArray = runtimeEntityType.AddProperty(
                 "NullableTimeSpanArray",
                 typeof(TimeSpan?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableTimeSpanArray.SetGetter(
+                TimeSpan? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(entity) == null,
+                TimeSpan? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(instance) == null);
+            nullableTimeSpanArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan? [] value) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(entity) = value);
+            nullableTimeSpanArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan? [] value) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(entity) = value);
+            nullableTimeSpanArray.SetAccessors(
+                TimeSpan? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableTimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeSpan? []>(nullableTimeSpanArray, 208),
+                TimeSpan? [] (InternalEntityEntry entry) => entry.GetCurrentValue<TimeSpan? []>(nullableTimeSpanArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[208]);
+            nullableTimeSpanArray.SetPropertyIndexes(
+                index: 208,
+                originalValueIndex: 208,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableTimeSpanArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<TimeSpan?[], TimeSpan>(new NullableValueComparer<TimeSpan>(new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<TimeSpan?[], TimeSpan>(new NullableValueComparer<TimeSpan>(new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<TimeSpan?>(new JsonCollectionOfNullableStructsReaderWriter<TimeSpan?[], TimeSpan>(
+                    JsonTimeSpanReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<TimeSpan?[], TimeSpan>(
+                    JsonTimeSpanReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<TimeSpan>(
+                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                        int (TimeSpan v) => ((object)v).GetHashCode(),
+                        TimeSpan (TimeSpan v) => v),
+                    keyComparer: new ValueComparer<TimeSpan>(
+                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                        int (TimeSpan v) => ((object)v).GetHashCode(),
+                        TimeSpan (TimeSpan v) => v),
+                    providerValueComparer: new ValueComparer<TimeSpan>(
+                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                        int (TimeSpan v) => ((object)v).GetHashCode(),
+                        TimeSpan (TimeSpan v) => v),
+                    clrType: typeof(TimeSpan),
+                    jsonValueReaderWriter: JsonTimeSpanReaderWriter.Instance));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
+            nullableTimeSpanArrayElementType.TypeMapping = nullableTimeSpanArray.TypeMapping.ElementTypeMapping;
+            nullableTimeSpanArrayElementType.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpanArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
                 "NullableUInt16",
@@ -1417,12 +12400,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableUInt16.SetGetter(
+                ushort? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableUInt16(entity).HasValue),
+                ushort? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt16(instance).HasValue));
+            nullableUInt16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort? value) => ManyTypesUnsafeAccessors.NullableUInt16(entity) = value);
+            nullableUInt16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort? value) => ManyTypesUnsafeAccessors.NullableUInt16(entity) = value);
+            nullableUInt16.SetAccessors(
+                ushort? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort? (InternalEntityEntry entry) => entry.ReadOriginalValue<ushort?>(nullableUInt16, 209),
+                ushort? (InternalEntityEntry entry) => entry.GetCurrentValue<ushort?>(nullableUInt16),
+                object (ValueBuffer valueBuffer) => valueBuffer[209]);
+            nullableUInt16.SetPropertyIndexes(
+                index: 209,
+                originalValueIndex: 209,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v),
+                keyComparer: new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v),
+                providerValueComparer: new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v),
+                clrType: typeof(ushort),
+                jsonValueReaderWriter: JsonUInt16ReaderWriter.Instance);
+            nullableUInt16.SetComparer(new NullableValueComparer<ushort>(nullableUInt16.TypeMapping.Comparer));
+            nullableUInt16.SetKeyComparer(new NullableValueComparer<ushort>(nullableUInt16.TypeMapping.KeyComparer));
 
             var nullableUInt16Array = runtimeEntityType.AddProperty(
                 "NullableUInt16Array",
                 typeof(ushort?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableUInt16Array.SetGetter(
+                ushort? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt16Array(entity) == null,
+                ushort? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt16Array(instance) == null);
+            nullableUInt16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort? [] value) => ManyTypesUnsafeAccessors.NullableUInt16Array(entity) = value);
+            nullableUInt16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort? [] value) => ManyTypesUnsafeAccessors.NullableUInt16Array(entity) = value);
+            nullableUInt16Array.SetAccessors(
+                ushort? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<ushort? []>(nullableUInt16Array, 210),
+                ushort? [] (InternalEntityEntry entry) => entry.GetCurrentValue<ushort? []>(nullableUInt16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[210]);
+            nullableUInt16Array.SetPropertyIndexes(
+                index: 210,
+                originalValueIndex: 210,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<ushort?[], ushort>(new NullableValueComparer<ushort>(new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<ushort?[], ushort>(new NullableValueComparer<ushort>(new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<ushort?>(new JsonCollectionOfNullableStructsReaderWriter<ushort?[], ushort>(
+                    JsonUInt16ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<ushort?[], ushort>(
+                    JsonUInt16ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<ushort>(
+                        bool (ushort v1, ushort v2) => v1 == v2,
+                        int (ushort v) => ((int)(v)),
+                        ushort (ushort v) => v),
+                    keyComparer: new ValueComparer<ushort>(
+                        bool (ushort v1, ushort v2) => v1 == v2,
+                        int (ushort v) => ((int)(v)),
+                        ushort (ushort v) => v),
+                    providerValueComparer: new ValueComparer<ushort>(
+                        bool (ushort v1, ushort v2) => v1 == v2,
+                        int (ushort v) => ((int)(v)),
+                        ushort (ushort v) => v),
+                    clrType: typeof(ushort),
+                    jsonValueReaderWriter: JsonUInt16ReaderWriter.Instance));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
+            nullableUInt16ArrayElementType.TypeMapping = nullableUInt16Array.TypeMapping.ElementTypeMapping;
+            nullableUInt16ArrayElementType.SetComparer(new NullableValueComparer<ushort>(nullableUInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
                 "NullableUInt32",
@@ -1430,12 +12508,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableUInt32.SetGetter(
+                uint? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableUInt32(entity).HasValue),
+                uint? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt32(instance).HasValue));
+            nullableUInt32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint? value) => ManyTypesUnsafeAccessors.NullableUInt32(entity) = value);
+            nullableUInt32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint? value) => ManyTypesUnsafeAccessors.NullableUInt32(entity) = value);
+            nullableUInt32.SetAccessors(
+                uint? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint? (InternalEntityEntry entry) => entry.ReadOriginalValue<uint?>(nullableUInt32, 211),
+                uint? (InternalEntityEntry entry) => entry.GetCurrentValue<uint?>(nullableUInt32),
+                object (ValueBuffer valueBuffer) => valueBuffer[211]);
+            nullableUInt32.SetPropertyIndexes(
+                index: 211,
+                originalValueIndex: 211,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v),
+                keyComparer: new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v),
+                providerValueComparer: new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v),
+                clrType: typeof(uint),
+                jsonValueReaderWriter: JsonUInt32ReaderWriter.Instance);
+            nullableUInt32.SetComparer(new NullableValueComparer<uint>(nullableUInt32.TypeMapping.Comparer));
+            nullableUInt32.SetKeyComparer(new NullableValueComparer<uint>(nullableUInt32.TypeMapping.KeyComparer));
 
             var nullableUInt32Array = runtimeEntityType.AddProperty(
                 "NullableUInt32Array",
                 typeof(uint?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableUInt32Array.SetGetter(
+                uint? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt32Array(entity) == null,
+                uint? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt32Array(instance) == null);
+            nullableUInt32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint? [] value) => ManyTypesUnsafeAccessors.NullableUInt32Array(entity) = value);
+            nullableUInt32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint? [] value) => ManyTypesUnsafeAccessors.NullableUInt32Array(entity) = value);
+            nullableUInt32Array.SetAccessors(
+                uint? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<uint? []>(nullableUInt32Array, 212),
+                uint? [] (InternalEntityEntry entry) => entry.GetCurrentValue<uint? []>(nullableUInt32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[212]);
+            nullableUInt32Array.SetPropertyIndexes(
+                index: 212,
+                originalValueIndex: 212,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<uint?[], uint>(new NullableValueComparer<uint>(new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<uint?[], uint>(new NullableValueComparer<uint>(new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<uint?>(new JsonCollectionOfNullableStructsReaderWriter<uint?[], uint>(
+                    JsonUInt32ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<uint?[], uint>(
+                    JsonUInt32ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<uint>(
+                        bool (uint v1, uint v2) => v1 == v2,
+                        int (uint v) => ((int)(v)),
+                        uint (uint v) => v),
+                    keyComparer: new ValueComparer<uint>(
+                        bool (uint v1, uint v2) => v1 == v2,
+                        int (uint v) => ((int)(v)),
+                        uint (uint v) => v),
+                    providerValueComparer: new ValueComparer<uint>(
+                        bool (uint v1, uint v2) => v1 == v2,
+                        int (uint v) => ((int)(v)),
+                        uint (uint v) => v),
+                    clrType: typeof(uint),
+                    jsonValueReaderWriter: JsonUInt32ReaderWriter.Instance));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
+            nullableUInt32ArrayElementType.TypeMapping = nullableUInt32Array.TypeMapping.ElementTypeMapping;
+            nullableUInt32ArrayElementType.SetComparer(new NullableValueComparer<uint>(nullableUInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
                 "NullableUInt64",
@@ -1443,12 +12616,107 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableUInt64.SetGetter(
+                ulong? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableUInt64(entity).HasValue),
+                ulong? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt64(instance).HasValue));
+            nullableUInt64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong? value) => ManyTypesUnsafeAccessors.NullableUInt64(entity) = value);
+            nullableUInt64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong? value) => ManyTypesUnsafeAccessors.NullableUInt64(entity) = value);
+            nullableUInt64.SetAccessors(
+                ulong? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong? (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong?>(nullableUInt64, 213),
+                ulong? (InternalEntityEntry entry) => entry.GetCurrentValue<ulong?>(nullableUInt64),
+                object (ValueBuffer valueBuffer) => valueBuffer[213]);
+            nullableUInt64.SetPropertyIndexes(
+                index: 213,
+                originalValueIndex: 213,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v),
+                keyComparer: new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v),
+                providerValueComparer: new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v),
+                clrType: typeof(ulong),
+                jsonValueReaderWriter: JsonUInt64ReaderWriter.Instance);
+            nullableUInt64.SetComparer(new NullableValueComparer<ulong>(nullableUInt64.TypeMapping.Comparer));
+            nullableUInt64.SetKeyComparer(new NullableValueComparer<ulong>(nullableUInt64.TypeMapping.KeyComparer));
 
             var nullableUInt64Array = runtimeEntityType.AddProperty(
                 "NullableUInt64Array",
                 typeof(ulong?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableUInt64Array.SetGetter(
+                ulong? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt64Array(entity) == null,
+                ulong? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt64Array(instance) == null);
+            nullableUInt64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong? [] value) => ManyTypesUnsafeAccessors.NullableUInt64Array(entity) = value);
+            nullableUInt64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong? [] value) => ManyTypesUnsafeAccessors.NullableUInt64Array(entity) = value);
+            nullableUInt64Array.SetAccessors(
+                ulong? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong? []>(nullableUInt64Array, 214),
+                ulong? [] (InternalEntityEntry entry) => entry.GetCurrentValue<ulong? []>(nullableUInt64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[214]);
+            nullableUInt64Array.SetPropertyIndexes(
+                index: 214,
+                originalValueIndex: 214,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<ulong?[], ulong>(new NullableValueComparer<ulong>(new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<ulong?[], ulong>(new NullableValueComparer<ulong>(new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<ulong?>(new JsonCollectionOfNullableStructsReaderWriter<ulong?[], ulong>(
+                    JsonUInt64ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<ulong?[], ulong>(
+                    JsonUInt64ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<ulong>(
+                        bool (ulong v1, ulong v2) => v1 == v2,
+                        int (ulong v) => ((object)v).GetHashCode(),
+                        ulong (ulong v) => v),
+                    keyComparer: new ValueComparer<ulong>(
+                        bool (ulong v1, ulong v2) => v1 == v2,
+                        int (ulong v) => ((object)v).GetHashCode(),
+                        ulong (ulong v) => v),
+                    providerValueComparer: new ValueComparer<ulong>(
+                        bool (ulong v1, ulong v2) => v1 == v2,
+                        int (ulong v) => ((object)v).GetHashCode(),
+                        ulong (ulong v) => v),
+                    clrType: typeof(ulong),
+                    jsonValueReaderWriter: JsonUInt64ReaderWriter.Instance));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
+            nullableUInt64ArrayElementType.TypeMapping = nullableUInt64Array.TypeMapping.ElementTypeMapping;
+            nullableUInt64ArrayElementType.SetComparer(new NullableValueComparer<ulong>(nullableUInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
                 "NullableUInt8",
@@ -1456,18 +12724,187 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableUInt8.SetGetter(
+                byte? (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => !(ManyTypesUnsafeAccessors.NullableUInt8(entity).HasValue),
+                byte? (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => !(ManyTypesUnsafeAccessors.NullableUInt8(instance).HasValue));
+            nullableUInt8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte? value) => ManyTypesUnsafeAccessors.NullableUInt8(entity) = value);
+            nullableUInt8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte? value) => ManyTypesUnsafeAccessors.NullableUInt8(entity) = value);
+            nullableUInt8.SetAccessors(
+                byte? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte? (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte? (InternalEntityEntry entry) => entry.ReadOriginalValue<byte?>(nullableUInt8, 215),
+                byte? (InternalEntityEntry entry) => entry.GetCurrentValue<byte?>(nullableUInt8),
+                object (ValueBuffer valueBuffer) => valueBuffer[215]);
+            nullableUInt8.SetPropertyIndexes(
+                index: 215,
+                originalValueIndex: 215,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                keyComparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                providerValueComparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                clrType: typeof(byte),
+                jsonValueReaderWriter: JsonByteReaderWriter.Instance);
+            nullableUInt8.SetComparer(new NullableValueComparer<byte>(nullableUInt8.TypeMapping.Comparer));
+            nullableUInt8.SetKeyComparer(new NullableValueComparer<byte>(nullableUInt8.TypeMapping.KeyComparer));
 
             var nullableUInt8Array = runtimeEntityType.AddProperty(
                 "NullableUInt8Array",
                 typeof(byte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableUInt8Array.SetGetter(
+                byte? [] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt8Array(entity) == null,
+                byte? [] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8Array(instance) == null);
+            nullableUInt8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte? [] value) => ManyTypesUnsafeAccessors.NullableUInt8Array(entity) = value);
+            nullableUInt8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte? [] value) => ManyTypesUnsafeAccessors.NullableUInt8Array(entity) = value);
+            nullableUInt8Array.SetAccessors(
+                byte? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte? [] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte? [] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte? []>(nullableUInt8Array, 216),
+                byte? [] (InternalEntityEntry entry) => entry.GetCurrentValue<byte? []>(nullableUInt8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[216]);
+            nullableUInt8Array.SetPropertyIndexes(
+                index: 216,
+                originalValueIndex: 216,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v))),
+                keyComparer: new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte?>(new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
+            nullableUInt8ArrayElementType.TypeMapping = nullableUInt8Array.TypeMapping.ElementTypeMapping;
+            nullableUInt8ArrayElementType.SetComparer(new NullableValueComparer<byte>(nullableUInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt8NestedCollection = runtimeEntityType.AddProperty(
                 "NullableUInt8NestedCollection",
                 typeof(byte?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableUInt8NestedCollection.SetGetter(
+                byte? [][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(entity) == null,
+                byte? [][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(instance) == null);
+            nullableUInt8NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte? [][] value) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(entity) = value);
+            nullableUInt8NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte? [][] value) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(entity) = value);
+            nullableUInt8NestedCollection.SetAccessors(
+                byte? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte? [][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUInt8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte? [][] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte? [][]>(nullableUInt8NestedCollection, 217),
+                byte? [][] (InternalEntityEntry entry) => entry.GetCurrentValue<byte? [][]>(nullableUInt8NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[217]);
+            nullableUInt8NestedCollection.SetPropertyIndexes(
+                index: 217,
+                originalValueIndex: 217,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUInt8NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<byte?[][], byte?[]>(new ConvertingValueComparer<byte?[], IEnumerable<byte?>>(new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v))))),
+                keyComparer: new ListOfReferenceTypesComparer<byte?[][], byte?[]>(new ConvertingValueComparer<byte?[], IEnumerable<byte?>>(new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v))))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte?[]>(new JsonCollectionOfReferencesReaderWriter<byte?[][], byte?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
+                        JsonByteReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<byte?[][], byte?[]>(
+                    new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
+                        JsonByteReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v))),
+                    keyComparer: new ListOfNullableValueTypesComparer<byte?[], byte>(new NullableValueComparer<byte>(new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v))),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<byte?>(new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
+                        JsonByteReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<byte?[], byte>(
+                        JsonByteReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<byte>(
+                            bool (byte v1, byte v2) => v1 == v2,
+                            int (byte v) => ((int)(v)),
+                            byte (byte v) => v),
+                        keyComparer: new ValueComparer<byte>(
+                            bool (byte v1, byte v2) => v1 == v2,
+                            int (byte v) => ((int)(v)),
+                            byte (byte v) => v),
+                        providerValueComparer: new ValueComparer<byte>(
+                            bool (byte v1, byte v2) => v1 == v2,
+                            int (byte v) => ((int)(v)),
+                            byte (byte v) => v),
+                        clrType: typeof(byte),
+                        jsonValueReaderWriter: JsonByteReaderWriter.Instance)));
+            var nullableUInt8NestedCollectionElementType = nullableUInt8NestedCollection.SetElementType(typeof(byte?[]));
+            nullableUInt8NestedCollectionElementType.TypeMapping = nullableUInt8NestedCollection.TypeMapping.ElementTypeMapping;
 
             var nullableUri = runtimeEntityType.AddProperty(
                 "NullableUri",
@@ -1475,24 +12912,247 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            nullableUri.SetGetter(
+                Uri (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUri(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUri(entity) == null,
+                Uri (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUri(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUri(instance) == null);
+            nullableUri.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri value) => ManyTypesUnsafeAccessors.NullableUri(entity) = value);
+            nullableUri.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri value) => ManyTypesUnsafeAccessors.NullableUri(entity) = value);
+            nullableUri.SetAccessors(
+                Uri (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri (InternalEntityEntry entry) => entry.ReadOriginalValue<Uri>(nullableUri, 218),
+                Uri (InternalEntityEntry entry) => entry.GetCurrentValue<Uri>(nullableUri),
+                object (ValueBuffer valueBuffer) => valueBuffer[218]);
+            nullableUri.SetPropertyIndexes(
+                index: 218,
+                originalValueIndex: 218,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUri.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v),
+                keyComparer: new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<Uri, string>(
+                    string (Uri v) => ((object)v).ToString(),
+                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<Uri, string>(
+                        string (Uri v) => ((object)v).ToString(),
+                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
 
             var nullableUriArray = runtimeEntityType.AddProperty(
                 "NullableUriArray",
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            nullableUriArray.SetGetter(
+                Uri[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUriArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.NullableUriArray(entity) == null,
+                Uri[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUriArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.NullableUriArray(instance) == null);
+            nullableUriArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri[] value) => ManyTypesUnsafeAccessors.NullableUriArray(entity) = value);
+            nullableUriArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri[] value) => ManyTypesUnsafeAccessors.NullableUriArray(entity) = value);
+            nullableUriArray.SetAccessors(
+                Uri[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.NullableUriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri[] (InternalEntityEntry entry) => entry.ReadOriginalValue<Uri[]>(nullableUriArray, 219),
+                Uri[] (InternalEntityEntry entry) => entry.GetCurrentValue<Uri[]>(nullableUriArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[219]);
+            nullableUriArray.SetPropertyIndexes(
+                index: 219,
+                originalValueIndex: 219,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            nullableUriArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
+                    new JsonConvertedValueReaderWriter<Uri, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<Uri, string>(
+                            string (Uri v) => ((object)v).ToString(),
+                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
+                    new JsonConvertedValueReaderWriter<Uri, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<Uri, string>(
+                            string (Uri v) => ((object)v).ToString(),
+                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<Uri>(
+                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (Uri v) => ((object)v).GetHashCode(),
+                        Uri (Uri v) => v),
+                    keyComparer: new ValueComparer<Uri>(
+                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (Uri v) => ((object)v).GetHashCode(),
+                        Uri (Uri v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<Uri, string>(
+                        string (Uri v) => ((object)v).ToString(),
+                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<Uri, string>(
+                            string (Uri v) => ((object)v).ToString(),
+                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
+            nullableUriArrayElementType.TypeMapping = nullableUriArray.TypeMapping.ElementTypeMapping;
 
             var physicalAddress = runtimeEntityType.AddProperty(
                 "PhysicalAddress",
                 typeof(PhysicalAddress),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddress", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddress>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            physicalAddress.SetGetter(
+                PhysicalAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddress(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddress(entity) == null,
+                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddress(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddress(instance) == null);
+            physicalAddress.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.PhysicalAddress(entity) = value);
+            physicalAddress.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.PhysicalAddress(entity) = value);
+            physicalAddress.SetAccessors(
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddress(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(physicalAddress, 220),
+                PhysicalAddress (InternalEntityEntry entry) => entry.GetCurrentValue<PhysicalAddress>(physicalAddress),
+                object (ValueBuffer valueBuffer) => valueBuffer[220]);
+            physicalAddress.SetPropertyIndexes(
+                index: 220,
+                originalValueIndex: 220,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            physicalAddress.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                keyComparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<PhysicalAddress, string>(
+                    string (PhysicalAddress v) => ((object)v).ToString(),
+                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<PhysicalAddress, string>(
+                        string (PhysicalAddress v) => ((object)v).ToString(),
+                        PhysicalAddress (string v) => PhysicalAddress.Parse(v))));
 
             var physicalAddressArray = runtimeEntityType.AddProperty(
                 "PhysicalAddressArray",
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            physicalAddressArray.SetGetter(
+                PhysicalAddress[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddressArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddressArray(entity) == null,
+                PhysicalAddress[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressArray(instance) == null);
+            physicalAddressArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress[] value) => ManyTypesUnsafeAccessors.PhysicalAddressArray(entity) = value);
+            physicalAddressArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress[] value) => ManyTypesUnsafeAccessors.PhysicalAddressArray(entity) = value);
+            physicalAddressArray.SetAccessors(
+                PhysicalAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress[] (InternalEntityEntry entry) => entry.ReadOriginalValue<PhysicalAddress[]>(physicalAddressArray, 221),
+                PhysicalAddress[] (InternalEntityEntry entry) => entry.GetCurrentValue<PhysicalAddress[]>(physicalAddressArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[221]);
+            physicalAddressArray.SetPropertyIndexes(
+                index: 221,
+                originalValueIndex: 221,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            physicalAddressArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<PhysicalAddress[], PhysicalAddress>(new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<PhysicalAddress>(new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<PhysicalAddress, string>(
+                            string (PhysicalAddress v) => ((object)v).ToString(),
+                            PhysicalAddress (string v) => PhysicalAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<PhysicalAddress[], PhysicalAddress>(
+                    new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<PhysicalAddress, string>(
+                            string (PhysicalAddress v) => ((object)v).ToString(),
+                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<PhysicalAddress>(
+                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                        PhysicalAddress (PhysicalAddress v) => v),
+                    keyComparer: new ValueComparer<PhysicalAddress>(
+                        bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                        int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                        PhysicalAddress (PhysicalAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<PhysicalAddress, string>(
+                        string (PhysicalAddress v) => ((object)v).ToString(),
+                        PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<PhysicalAddress, string>(
+                            string (PhysicalAddress v) => ((object)v).ToString(),
+                            PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
+            physicalAddressArrayElementType.TypeMapping = physicalAddressArray.TypeMapping.ElementTypeMapping;
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "PhysicalAddressToBytesConverterProperty",
@@ -1500,6 +13160,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new PhysicalAddressToBytesConverter());
+            physicalAddressToBytesConverterProperty.SetGetter(
+                PhysicalAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(entity) == null,
+                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(instance) == null);
+            physicalAddressToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(entity) = value);
+            physicalAddressToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(entity) = value);
+            physicalAddressToBytesConverterProperty.SetAccessors(
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(physicalAddressToBytesConverterProperty, 222),
+                PhysicalAddress (InternalEntityEntry entry) => entry.GetCurrentValue<PhysicalAddress>(physicalAddressToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[222]);
+            physicalAddressToBytesConverterProperty.SetPropertyIndexes(
+                index: 222,
+                originalValueIndex: 222,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            physicalAddressToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                keyComparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<PhysicalAddress, byte[]>(
+                    byte[] (PhysicalAddress v) => v.GetAddressBytes(),
+                    PhysicalAddress (byte[] v) => new PhysicalAddress(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<PhysicalAddress, byte[]>(
+                        byte[] (PhysicalAddress v) => v.GetAddressBytes(),
+                        PhysicalAddress (byte[] v) => new PhysicalAddress(v))));
 
             var physicalAddressToStringConverterProperty = runtimeEntityType.AddProperty(
                 "PhysicalAddressToStringConverterProperty",
@@ -1507,24 +13209,292 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new PhysicalAddressToStringConverter());
+            physicalAddressToStringConverterProperty.SetGetter(
+                PhysicalAddress (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(entity) == null,
+                PhysicalAddress (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(instance) == null);
+            physicalAddressToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(entity) = value);
+            physicalAddressToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, PhysicalAddress value) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(entity) = value);
+            physicalAddressToStringConverterProperty.SetAccessors(
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.PhysicalAddressToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                PhysicalAddress (InternalEntityEntry entry) => entry.ReadOriginalValue<PhysicalAddress>(physicalAddressToStringConverterProperty, 223),
+                PhysicalAddress (InternalEntityEntry entry) => entry.GetCurrentValue<PhysicalAddress>(physicalAddressToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[223]);
+            physicalAddressToStringConverterProperty.SetPropertyIndexes(
+                index: 223,
+                originalValueIndex: 223,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            physicalAddressToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                keyComparer: new ValueComparer<PhysicalAddress>(
+                    bool (PhysicalAddress v1, PhysicalAddress v2) => object.Equals(v1, v2),
+                    int (PhysicalAddress v) => ((object)v).GetHashCode(),
+                    PhysicalAddress (PhysicalAddress v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<PhysicalAddress, string>(
+                    string (PhysicalAddress v) => ((object)v).ToString(),
+                    PhysicalAddress (string v) => PhysicalAddress.Parse(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<PhysicalAddress, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<PhysicalAddress, string>(
+                        string (PhysicalAddress v) => ((object)v).ToString(),
+                        PhysicalAddress (string v) => PhysicalAddress.Parse(v))));
 
             var @string = runtimeEntityType.AddProperty(
                 "String",
                 typeof(string),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("String", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<String>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            @string.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.String(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.String(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.String(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.String(instance) == null);
+            @string.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.String(entity) = value);
+            @string.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.String(entity) = value);
+            @string.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.String(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.String(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(@string, 224),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(@string),
+                object (ValueBuffer valueBuffer) => valueBuffer[224]);
+            @string.SetPropertyIndexes(
+                index: 224,
+                originalValueIndex: 224,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            @string.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                clrType: typeof(string),
+                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
 
             var stringArray = runtimeEntityType.AddProperty(
                 "StringArray",
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            stringArray.SetGetter(
+                string[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringArray(entity) == null,
+                string[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringArray(instance) == null);
+            stringArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[] value) => ManyTypesUnsafeAccessors.StringArray(entity) = value);
+            stringArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[] value) => ManyTypesUnsafeAccessors.StringArray(entity) = value);
+            stringArray.SetAccessors(
+                string[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[] (InternalEntityEntry entry) => entry.ReadOriginalValue<string[]>(stringArray, 225),
+                string[] (InternalEntityEntry entry) => entry.GetCurrentValue<string[]>(stringArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[225]);
+            stringArray.SetPropertyIndexes(
+                index: 225,
+                originalValueIndex: 225,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
+            stringArrayElementType.TypeMapping = stringArray.TypeMapping.ElementTypeMapping;
 
             var stringNestedCollection = runtimeEntityType.AddProperty(
                 "StringNestedCollection",
                 typeof(string[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            stringNestedCollection.SetGetter(
+                string[][] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringNestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringNestedCollection(entity) == null,
+                string[][] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringNestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringNestedCollection(instance) == null);
+            stringNestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[][] value) => ManyTypesUnsafeAccessors.StringNestedCollection(entity) = value);
+            stringNestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string[][] value) => ManyTypesUnsafeAccessors.StringNestedCollection(entity) = value);
+            stringNestedCollection.SetAccessors(
+                string[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[][] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringNestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string[][] (InternalEntityEntry entry) => entry.ReadOriginalValue<string[][]>(stringNestedCollection, 226),
+                string[][] (InternalEntityEntry entry) => entry.GetCurrentValue<string[][]>(stringNestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[226]);
+            stringNestedCollection.SetPropertyIndexes(
+                index: 226,
+                originalValueIndex: 226,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringNestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<string[][], string[]>(new ConvertingValueComparer<string[], object>(new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)))),
+                keyComparer: new ListOfReferenceTypesComparer<string[][], string[]>(new ConvertingValueComparer<string[], object>(new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)))),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string[]>(new JsonCollectionOfReferencesReaderWriter<string[][], string[]>(
+                    new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[][], string[]>(
+                    new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance)),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v)),
+                    keyComparer: new ListOfReferenceTypesComparer<string[], string>(new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v)),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance)),
+                    jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
+                        JsonStringReaderWriter.Instance),
+                    elementMapping: InMemoryTypeMapping.Default.Clone(
+                        comparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        keyComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        providerValueComparer: new ValueComparer<string>(
+                            bool (string v1, string v2) => v1 == v2,
+                            int (string v) => ((object)v).GetHashCode(),
+                            string (string v) => v),
+                        clrType: typeof(string),
+                        jsonValueReaderWriter: JsonStringReaderWriter.Instance)));
+            var stringNestedCollectionElementType = stringNestedCollection.SetElementType(typeof(string[]));
+            stringNestedCollectionElementType.TypeMapping = stringNestedCollection.TypeMapping.ElementTypeMapping;
+
+            var stringReadOnlyCollection = runtimeEntityType.AddProperty(
+                "StringReadOnlyCollection",
+                typeof(IReadOnlyCollection<string>),
+                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
+                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_stringReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            stringReadOnlyCollection.SetGetter(
+                IReadOnlyCollection<string> (CompiledModelTestBase.ManyTypes entity) => (ManyTypesUnsafeAccessors._stringReadOnlyCollection(entity) == null ? null : ((IReadOnlyCollection<string>)(ManyTypesUnsafeAccessors._stringReadOnlyCollection(entity)))),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors._stringReadOnlyCollection(entity) == null,
+                IReadOnlyCollection<string> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<string>)(ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance)))),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._stringReadOnlyCollection(instance) == null);
+            stringReadOnlyCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<string> value) => ManyTypesUnsafeAccessors._stringReadOnlyCollection(entity) = ((List<string>)(value)));
+            stringReadOnlyCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<string> value) => ManyTypesUnsafeAccessors._stringReadOnlyCollection(entity) = ((List<string>)(value)));
+            stringReadOnlyCollection.SetAccessors(
+                IReadOnlyCollection<string> (InternalEntityEntry entry) => ((IReadOnlyCollection<string>)(ManyTypesUnsafeAccessors._stringReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<string> (InternalEntityEntry entry) => ((IReadOnlyCollection<string>)(ManyTypesUnsafeAccessors._stringReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<string> (InternalEntityEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<string>>(stringReadOnlyCollection, 227),
+                IReadOnlyCollection<string> (InternalEntityEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<string>>(stringReadOnlyCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[227]);
+            stringReadOnlyCollection.SetPropertyIndexes(
+                index: 227,
+                originalValueIndex: 227,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringReadOnlyCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
+            stringReadOnlyCollectionElementType.TypeMapping = stringReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBoolConverterProperty",
@@ -1532,6 +13502,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToBoolConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToBoolConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToBoolConverter());
+            stringToBoolConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(instance) == null);
+            stringToBoolConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(entity) = value);
+            stringToBoolConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(entity) = value);
+            stringToBoolConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToBoolConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToBoolConverterProperty, 228),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToBoolConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[228]);
+            stringToBoolConverterProperty.SetPropertyIndexes(
+                index: 228,
+                originalValueIndex: 228,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToBoolConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<bool>(
+                    bool (bool v1, bool v2) => v1 == v2,
+                    int (bool v) => ((object)v).GetHashCode(),
+                    bool (bool v) => v),
+                converter: new ValueConverter<string, bool>(
+                    bool (string v) => Convert.ToBoolean(v),
+                    string (bool v) => Convert.ToString(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, bool>(
+                    JsonBoolReaderWriter.Instance,
+                    new ValueConverter<string, bool>(
+                        bool (string v) => Convert.ToBoolean(v),
+                        string (bool v) => Convert.ToString(v))));
 
             var stringToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBytesConverterProperty",
@@ -1539,9 +13551,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToBytesConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToBytesConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
-            stringToBytesConverterProperty.SetValueConverter(new ValueConverter<string, byte[]>(
-                byte[] (string v) => Encoding.GetEncoding(12000).GetBytes(v),
-                string (byte[] v) => Encoding.GetEncoding(12000).GetString(v)));
+            stringToBytesConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(instance) == null);
+            stringToBytesConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(entity) = value);
+            stringToBytesConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(entity) = value);
+            stringToBytesConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToBytesConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToBytesConverterProperty, 229),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToBytesConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[229]);
+            stringToBytesConverterProperty.SetPropertyIndexes(
+                index: 229,
+                originalValueIndex: 229,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToBytesConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                converter: new ValueConverter<string, byte[]>(
+                    byte[] (string v) => Encoding.GetEncoding(12000).GetBytes(v),
+                    string (byte[] v) => Encoding.GetEncoding(12000).GetString(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, byte[]>(
+                    JsonByteArrayReaderWriter.Instance,
+                    new ValueConverter<string, byte[]>(
+                        byte[] (string v) => Encoding.GetEncoding(12000).GetBytes(v),
+                        string (byte[] v) => Encoding.GetEncoding(12000).GetString(v))));
 
             var stringToCharConverterProperty = runtimeEntityType.AddProperty(
                 "StringToCharConverterProperty",
@@ -1549,6 +13600,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToCharConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToCharConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToCharConverter());
+            stringToCharConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(instance) == null);
+            stringToCharConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(entity) = value);
+            stringToCharConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(entity) = value);
+            stringToCharConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToCharConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToCharConverterProperty, 230),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToCharConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[230]);
+            stringToCharConverterProperty.SetPropertyIndexes(
+                index: 230,
+                originalValueIndex: 230,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToCharConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<char>(
+                    bool (char v1, char v2) => v1 == v2,
+                    int (char v) => ((int)(v)),
+                    char (char v) => v),
+                converter: new ValueConverter<string, char>(
+                    char (string v) => (v.Length < 1 ? '\0' : v[0]),
+                    string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v)))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, char>(
+                    JsonCharReaderWriter.Instance,
+                    new ValueConverter<string, char>(
+                        char (string v) => (v.Length < 1 ? '\0' : v[0]),
+                        string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))))));
 
             var stringToDateOnlyConverterProperty = runtimeEntityType.AddProperty(
                 "StringToDateOnlyConverterProperty",
@@ -1556,6 +13649,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToDateOnlyConverter());
+            stringToDateOnlyConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(instance) == null);
+            stringToDateOnlyConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(entity) = value);
+            stringToDateOnlyConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(entity) = value);
+            stringToDateOnlyConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDateOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToDateOnlyConverterProperty, 231),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToDateOnlyConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[231]);
+            stringToDateOnlyConverterProperty.SetPropertyIndexes(
+                index: 231,
+                originalValueIndex: 231,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToDateOnlyConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<DateOnly>(
+                    bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
+                    int (DateOnly v) => ((object)v).GetHashCode(),
+                    DateOnly (DateOnly v) => v),
+                converter: new ValueConverter<string, DateOnly>(
+                    DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
+                    string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd")),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateOnly>(
+                    JsonDateOnlyReaderWriter.Instance,
+                    new ValueConverter<string, DateOnly>(
+                        DateOnly (string v) => DateOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
+                        string (DateOnly v) => v.ToString("yyyy\\-MM\\-dd"))));
 
             var stringToDateTimeConverterProperty = runtimeEntityType.AddProperty(
                 "StringToDateTimeConverterProperty",
@@ -1563,6 +13698,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateTimeConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateTimeConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToDateTimeConverter());
+            stringToDateTimeConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(instance) == null);
+            stringToDateTimeConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(entity) = value);
+            stringToDateTimeConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(entity) = value);
+            stringToDateTimeConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToDateTimeConverterProperty, 232),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToDateTimeConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[232]);
+            stringToDateTimeConverterProperty.SetPropertyIndexes(
+                index: 232,
+                originalValueIndex: 232,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToDateTimeConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v),
+                converter: new ValueConverter<string, DateTime>(
+                    DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
+                    string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF")),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTime>(
+                    JsonDateTimeReaderWriter.Instance,
+                    new ValueConverter<string, DateTime>(
+                        DateTime (string v) => DateTime.Parse(v, CultureInfo.InvariantCulture),
+                        string (DateTime v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFF"))));
 
             var stringToDateTimeOffsetConverterProperty = runtimeEntityType.AddProperty(
                 "StringToDateTimeOffsetConverterProperty",
@@ -1570,6 +13747,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDateTimeOffsetConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDateTimeOffsetConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToDateTimeOffsetConverter());
+            stringToDateTimeOffsetConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(instance) == null);
+            stringToDateTimeOffsetConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(entity) = value);
+            stringToDateTimeOffsetConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(entity) = value);
+            stringToDateTimeOffsetConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDateTimeOffsetConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToDateTimeOffsetConverterProperty, 233),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToDateTimeOffsetConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[233]);
+            stringToDateTimeOffsetConverterProperty.SetPropertyIndexes(
+                index: 233,
+                originalValueIndex: 233,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToDateTimeOffsetConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<DateTimeOffset>(
+                    bool (DateTimeOffset v1, DateTimeOffset v2) => v1.EqualsExact(v2),
+                    int (DateTimeOffset v) => ((object)v).GetHashCode(),
+                    DateTimeOffset (DateTimeOffset v) => v),
+                converter: new ValueConverter<string, DateTimeOffset>(
+                    DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
+                    string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz")),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, DateTimeOffset>(
+                    JsonDateTimeOffsetReaderWriter.Instance,
+                    new ValueConverter<string, DateTimeOffset>(
+                        DateTimeOffset (string v) => DateTimeOffset.Parse(v, CultureInfo.InvariantCulture),
+                        string (DateTimeOffset v) => v.ToString("yyyy\\-MM\\-dd HH\\:mm\\:ss.FFFFFFFzzz"))));
 
             var stringToDecimalNumberConverterProperty = runtimeEntityType.AddProperty(
                 "StringToDecimalNumberConverterProperty",
@@ -1577,6 +13796,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDecimalNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDecimalNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToNumberConverter<decimal>());
+            stringToDecimalNumberConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(instance) == null);
+            stringToDecimalNumberConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(entity) = value);
+            stringToDecimalNumberConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(entity) = value);
+            stringToDecimalNumberConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDecimalNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToDecimalNumberConverterProperty, 234),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToDecimalNumberConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[234]);
+            stringToDecimalNumberConverterProperty.SetPropertyIndexes(
+                index: 234,
+                originalValueIndex: 234,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToDecimalNumberConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<decimal>(
+                    bool (decimal v1, decimal v2) => v1 == v2,
+                    int (decimal v) => ((object)v).GetHashCode(),
+                    decimal (decimal v) => v),
+                converter: new ValueConverter<string, decimal>(
+                    decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
+                    string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v)))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, decimal>(
+                    JsonDecimalReaderWriter.Instance,
+                    new ValueConverter<string, decimal>(
+                        decimal (string v) => decimal.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
+                        string (decimal v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))))));
 
             var stringToDoubleNumberConverterProperty = runtimeEntityType.AddProperty(
                 "StringToDoubleNumberConverterProperty",
@@ -1584,6 +13845,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToDoubleNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToDoubleNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToNumberConverter<double>());
+            stringToDoubleNumberConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(instance) == null);
+            stringToDoubleNumberConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(entity) = value);
+            stringToDoubleNumberConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(entity) = value);
+            stringToDoubleNumberConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToDoubleNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToDoubleNumberConverterProperty, 235),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToDoubleNumberConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[235]);
+            stringToDoubleNumberConverterProperty.SetPropertyIndexes(
+                index: 235,
+                originalValueIndex: 235,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToDoubleNumberConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<double>(
+                    bool (double v1, double v2) => v1.Equals(v2),
+                    int (double v) => ((object)v).GetHashCode(),
+                    double (double v) => v),
+                converter: new ValueConverter<string, double>(
+                    double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
+                    string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v)))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, double>(
+                    JsonDoubleReaderWriter.Instance,
+                    new ValueConverter<string, double>(
+                        double (string v) => double.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
+                        string (double v) => string.Format(CultureInfo.InvariantCulture, "{0:R}", ((object)(v))))));
 
             var stringToEnumConverterProperty = runtimeEntityType.AddProperty(
                 "StringToEnumConverterProperty",
@@ -1591,12 +13894,90 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToEnumConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToEnumConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToEnumConverter<CompiledModelTestBase.EnumU32>());
+            stringToEnumConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(instance) == null);
+            stringToEnumConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(entity) = value);
+            stringToEnumConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(entity) = value);
+            stringToEnumConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToEnumConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToEnumConverterProperty, 236),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToEnumConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[236]);
+            stringToEnumConverterProperty.SetPropertyIndexes(
+                index: 236,
+                originalValueIndex: 236,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToEnumConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.EnumU32>(
+                    bool (CompiledModelTestBase.EnumU32 v1, CompiledModelTestBase.EnumU32 v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.EnumU32 v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.EnumU32 (CompiledModelTestBase.EnumU32 v) => v),
+                converter: new ValueConverter<string, CompiledModelTestBase.EnumU32>(
+                    CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<string, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32>.ConvertToEnum(v),
+                    string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString()),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, CompiledModelTestBase.EnumU32>(
+                    JsonUnsignedEnumReaderWriter<CompiledModelTestBase.EnumU32>.Instance,
+                    new ValueConverter<string, CompiledModelTestBase.EnumU32>(
+                        CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<string, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32>.ConvertToEnum(v),
+                        string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString())));
 
             var stringToGuidConverterProperty = runtimeEntityType.AddProperty(
                 "StringToGuidConverterProperty",
                 typeof(string),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToGuidConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToGuidConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            stringToGuidConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(instance) == null);
+            stringToGuidConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(entity) = value);
+            stringToGuidConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(entity) = value);
+            stringToGuidConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToGuidConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToGuidConverterProperty, 237),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToGuidConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[237]);
+            stringToGuidConverterProperty.SetPropertyIndexes(
+                index: 237,
+                originalValueIndex: 237,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToGuidConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                clrType: typeof(string),
+                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
 
             var stringToIntNumberConverterProperty = runtimeEntityType.AddProperty(
                 "StringToIntNumberConverterProperty",
@@ -1604,6 +13985,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToIntNumberConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToIntNumberConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToNumberConverter<int>());
+            stringToIntNumberConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(instance) == null);
+            stringToIntNumberConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(entity) = value);
+            stringToIntNumberConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(entity) = value);
+            stringToIntNumberConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToIntNumberConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToIntNumberConverterProperty, 238),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToIntNumberConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[238]);
+            stringToIntNumberConverterProperty.SetPropertyIndexes(
+                index: 238,
+                originalValueIndex: 238,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToIntNumberConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                converter: new ValueConverter<string, int>(
+                    int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
+                    string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v)))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, int>(
+                    JsonInt32ReaderWriter.Instance,
+                    new ValueConverter<string, int>(
+                        int (string v) => int.Parse(v, NumberStyles.Any, CultureInfo.InvariantCulture),
+                        string (int v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))))));
 
             var stringToTimeOnlyConverterProperty = runtimeEntityType.AddProperty(
                 "StringToTimeOnlyConverterProperty",
@@ -1611,6 +14034,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToTimeOnlyConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToTimeOnlyConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToTimeOnlyConverter());
+            stringToTimeOnlyConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(instance) == null);
+            stringToTimeOnlyConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(entity) = value);
+            stringToTimeOnlyConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(entity) = value);
+            stringToTimeOnlyConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToTimeOnlyConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToTimeOnlyConverterProperty, 239),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToTimeOnlyConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[239]);
+            stringToTimeOnlyConverterProperty.SetPropertyIndexes(
+                index: 239,
+                originalValueIndex: 239,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToTimeOnlyConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                converter: new ValueConverter<string, TimeOnly>(
+                    TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
+                    string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o"))),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeOnly>(
+                    JsonTimeOnlyReaderWriter.Instance,
+                    new ValueConverter<string, TimeOnly>(
+                        TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None),
+                        string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o")))));
 
             var stringToTimeSpanConverterProperty = runtimeEntityType.AddProperty(
                 "StringToTimeSpanConverterProperty",
@@ -1618,6 +14083,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToTimeSpanConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToTimeSpanConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToTimeSpanConverter());
+            stringToTimeSpanConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(instance) == null);
+            stringToTimeSpanConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(entity) = value);
+            stringToTimeSpanConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(entity) = value);
+            stringToTimeSpanConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToTimeSpanConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToTimeSpanConverterProperty, 240),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToTimeSpanConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[240]);
+            stringToTimeSpanConverterProperty.SetPropertyIndexes(
+                index: 240,
+                originalValueIndex: 240,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToTimeSpanConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                converter: new ValueConverter<string, TimeSpan>(
+                    TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
+                    string (TimeSpan v) => v.ToString("c")),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, TimeSpan>(
+                    JsonTimeSpanReaderWriter.Instance,
+                    new ValueConverter<string, TimeSpan>(
+                        TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture),
+                        string (TimeSpan v) => v.ToString("c"))));
 
             var stringToUriConverterProperty = runtimeEntityType.AddProperty(
                 "StringToUriConverterProperty",
@@ -1625,6 +14132,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringToUriConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringToUriConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new StringToUriConverter());
+            stringToUriConverterProperty.SetGetter(
+                string (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(entity) == null,
+                string (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(instance) == null);
+            stringToUriConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(entity) = value);
+            stringToUriConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, string value) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(entity) = value);
+            stringToUriConverterProperty.SetAccessors(
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.StringToUriConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(stringToUriConverterProperty, 241),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(stringToUriConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[241]);
+            stringToUriConverterProperty.SetPropertyIndexes(
+                index: 241,
+                originalValueIndex: 241,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            stringToUriConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<string, string>(
+                    string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString(),
+                    string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString()),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<string, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<string, string>(
+                        string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString(),
+                        string (string v) => ((object)new Uri(v, UriKind.RelativeOrAbsolute)).ToString())));
 
             var timeOnly = runtimeEntityType.AddProperty(
                 "TimeOnly",
@@ -1632,12 +14181,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnly", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnly>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: new TimeOnly(0, 0, 0));
+            timeOnly.SetGetter(
+                TimeOnly (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnly(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnly(entity) == default(TimeOnly),
+                TimeOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnly(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnly(instance) == default(TimeOnly));
+            timeOnly.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly value) => ManyTypesUnsafeAccessors.TimeOnly(entity) = value);
+            timeOnly.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly value) => ManyTypesUnsafeAccessors.TimeOnly(entity) = value);
+            timeOnly.SetAccessors(
+                TimeOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnly(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeOnly>(timeOnly, 242),
+                TimeOnly (InternalEntityEntry entry) => entry.GetCurrentValue<TimeOnly>(timeOnly),
+                object (ValueBuffer valueBuffer) => valueBuffer[242]);
+            timeOnly.SetPropertyIndexes(
+                index: 242,
+                originalValueIndex: 242,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeOnly.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                keyComparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                providerValueComparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                clrType: typeof(TimeOnly),
+                jsonValueReaderWriter: JsonTimeOnlyReaderWriter.Instance);
 
             var timeOnlyArray = runtimeEntityType.AddProperty(
                 "TimeOnlyArray",
                 typeof(TimeOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            timeOnlyArray.SetGetter(
+                TimeOnly[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnlyArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnlyArray(entity) == null,
+                TimeOnly[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyArray(instance) == null);
+            timeOnlyArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly[] value) => ManyTypesUnsafeAccessors.TimeOnlyArray(entity) = value);
+            timeOnlyArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly[] value) => ManyTypesUnsafeAccessors.TimeOnlyArray(entity) = value);
+            timeOnlyArray.SetAccessors(
+                TimeOnly[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly[] (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeOnly[]>(timeOnlyArray, 243),
+                TimeOnly[] (InternalEntityEntry entry) => entry.GetCurrentValue<TimeOnly[]>(timeOnlyArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[243]);
+            timeOnlyArray.SetPropertyIndexes(
+                index: 243,
+                originalValueIndex: 243,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeOnlyArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<TimeOnly[], TimeOnly>(new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v)),
+                keyComparer: new ListOfValueTypesComparer<TimeOnly[], TimeOnly>(new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<TimeOnly>(new JsonCollectionOfStructsReaderWriter<TimeOnly[], TimeOnly>(
+                    JsonTimeOnlyReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<TimeOnly[], TimeOnly>(
+                    JsonTimeOnlyReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<TimeOnly>(
+                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                        int (TimeOnly v) => ((object)v).GetHashCode(),
+                        TimeOnly (TimeOnly v) => v),
+                    keyComparer: new ValueComparer<TimeOnly>(
+                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                        int (TimeOnly v) => ((object)v).GetHashCode(),
+                        TimeOnly (TimeOnly v) => v),
+                    providerValueComparer: new ValueComparer<TimeOnly>(
+                        bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                        int (TimeOnly v) => ((object)v).GetHashCode(),
+                        TimeOnly (TimeOnly v) => v),
+                    clrType: typeof(TimeOnly),
+                    jsonValueReaderWriter: JsonTimeOnlyReaderWriter.Instance));
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
+            timeOnlyArrayElementType.TypeMapping = timeOnlyArray.TypeMapping.ElementTypeMapping;
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeOnlyToStringConverterProperty",
@@ -1645,6 +14285,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new TimeOnlyToStringConverter());
+            timeOnlyToStringConverterProperty.SetGetter(
+                TimeOnly (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(entity) == default(TimeOnly),
+                TimeOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(instance) == default(TimeOnly));
+            timeOnlyToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly value) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(entity) = value);
+            timeOnlyToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly value) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(entity) = value);
+            timeOnlyToStringConverterProperty.SetAccessors(
+                TimeOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeOnly>(timeOnlyToStringConverterProperty, 244),
+                TimeOnly (InternalEntityEntry entry) => entry.GetCurrentValue<TimeOnly>(timeOnlyToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[244]);
+            timeOnlyToStringConverterProperty.SetPropertyIndexes(
+                index: 244,
+                originalValueIndex: 244,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeOnlyToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                keyComparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<TimeOnly, string>(
+                    string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o")),
+                    TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<TimeOnly, string>(
+                        string (TimeOnly v) => (v.Ticks % 10000000L == 0L ? string.Format(CultureInfo.InvariantCulture, "{0:HH\\:mm\\:ss}", ((object)(v))) : v.ToString("o")),
+                        TimeOnly (string v) => TimeOnly.Parse(v, CultureInfo.InvariantCulture, DateTimeStyles.None))));
             timeOnlyToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");
 
             var timeOnlyToTicksConverterProperty = runtimeEntityType.AddProperty(
@@ -1653,6 +14335,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new TimeOnlyToTicksConverter());
+            timeOnlyToTicksConverterProperty.SetGetter(
+                TimeOnly (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(entity) == default(TimeOnly),
+                TimeOnly (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(instance) == default(TimeOnly));
+            timeOnlyToTicksConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly value) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(entity) = value);
+            timeOnlyToTicksConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeOnly value) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(entity) = value);
+            timeOnlyToTicksConverterProperty.SetAccessors(
+                TimeOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeOnlyToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeOnly (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeOnly>(timeOnlyToTicksConverterProperty, 245),
+                TimeOnly (InternalEntityEntry entry) => entry.GetCurrentValue<TimeOnly>(timeOnlyToTicksConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[245]);
+            timeOnlyToTicksConverterProperty.SetPropertyIndexes(
+                index: 245,
+                originalValueIndex: 245,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeOnlyToTicksConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                keyComparer: new ValueComparer<TimeOnly>(
+                    bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
+                    int (TimeOnly v) => ((object)v).GetHashCode(),
+                    TimeOnly (TimeOnly v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                converter: new ValueConverter<TimeOnly, long>(
+                    long (TimeOnly v) => v.Ticks,
+                    TimeOnly (long v) => new TimeOnly(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeOnly, long>(
+                    JsonInt64ReaderWriter.Instance,
+                    new ValueConverter<TimeOnly, long>(
+                        long (TimeOnly v) => v.Ticks,
+                        TimeOnly (long v) => new TimeOnly(v))));
             timeOnlyToTicksConverterProperty.SetSentinelFromProviderValue(0L);
 
             var timeSpan = runtimeEntityType.AddProperty(
@@ -1661,12 +14385,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpan", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpan>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: new TimeSpan(0, 0, 0, 0, 0));
+            timeSpan.SetGetter(
+                TimeSpan (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpan(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpan(entity) == default(TimeSpan),
+                TimeSpan (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpan(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpan(instance) == default(TimeSpan));
+            timeSpan.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan value) => ManyTypesUnsafeAccessors.TimeSpan(entity) = value);
+            timeSpan.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan value) => ManyTypesUnsafeAccessors.TimeSpan(entity) = value);
+            timeSpan.SetAccessors(
+                TimeSpan (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpan(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeSpan>(timeSpan, 246),
+                TimeSpan (InternalEntityEntry entry) => entry.GetCurrentValue<TimeSpan>(timeSpan),
+                object (ValueBuffer valueBuffer) => valueBuffer[246]);
+            timeSpan.SetPropertyIndexes(
+                index: 246,
+                originalValueIndex: 246,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeSpan.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                keyComparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                providerValueComparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                clrType: typeof(TimeSpan),
+                jsonValueReaderWriter: JsonTimeSpanReaderWriter.Instance);
 
             var timeSpanArray = runtimeEntityType.AddProperty(
                 "TimeSpanArray",
                 typeof(TimeSpan[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            timeSpanArray.SetGetter(
+                TimeSpan[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpanArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpanArray(entity) == null,
+                TimeSpan[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanArray(instance) == null);
+            timeSpanArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan[] value) => ManyTypesUnsafeAccessors.TimeSpanArray(entity) = value);
+            timeSpanArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan[] value) => ManyTypesUnsafeAccessors.TimeSpanArray(entity) = value);
+            timeSpanArray.SetAccessors(
+                TimeSpan[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpanArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan[] (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeSpan[]>(timeSpanArray, 247),
+                TimeSpan[] (InternalEntityEntry entry) => entry.GetCurrentValue<TimeSpan[]>(timeSpanArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[247]);
+            timeSpanArray.SetPropertyIndexes(
+                index: 247,
+                originalValueIndex: 247,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeSpanArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<TimeSpan[], TimeSpan>(new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v)),
+                keyComparer: new ListOfValueTypesComparer<TimeSpan[], TimeSpan>(new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<TimeSpan>(new JsonCollectionOfStructsReaderWriter<TimeSpan[], TimeSpan>(
+                    JsonTimeSpanReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<TimeSpan[], TimeSpan>(
+                    JsonTimeSpanReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<TimeSpan>(
+                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                        int (TimeSpan v) => ((object)v).GetHashCode(),
+                        TimeSpan (TimeSpan v) => v),
+                    keyComparer: new ValueComparer<TimeSpan>(
+                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                        int (TimeSpan v) => ((object)v).GetHashCode(),
+                        TimeSpan (TimeSpan v) => v),
+                    providerValueComparer: new ValueComparer<TimeSpan>(
+                        bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                        int (TimeSpan v) => ((object)v).GetHashCode(),
+                        TimeSpan (TimeSpan v) => v),
+                    clrType: typeof(TimeSpan),
+                    jsonValueReaderWriter: JsonTimeSpanReaderWriter.Instance));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
+            timeSpanArrayElementType.TypeMapping = timeSpanArray.TypeMapping.ElementTypeMapping;
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeSpanToStringConverterProperty",
@@ -1674,6 +14489,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new TimeSpanToStringConverter());
+            timeSpanToStringConverterProperty.SetGetter(
+                TimeSpan (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(entity) == default(TimeSpan),
+                TimeSpan (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(instance) == default(TimeSpan));
+            timeSpanToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan value) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(entity) = value);
+            timeSpanToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan value) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(entity) = value);
+            timeSpanToStringConverterProperty.SetAccessors(
+                TimeSpan (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeSpan>(timeSpanToStringConverterProperty, 248),
+                TimeSpan (InternalEntityEntry entry) => entry.GetCurrentValue<TimeSpan>(timeSpanToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[248]);
+            timeSpanToStringConverterProperty.SetPropertyIndexes(
+                index: 248,
+                originalValueIndex: 248,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeSpanToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                keyComparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<TimeSpan, string>(
+                    string (TimeSpan v) => v.ToString("c"),
+                    TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<TimeSpan, string>(
+                        string (TimeSpan v) => v.ToString("c"),
+                        TimeSpan (string v) => TimeSpan.Parse(v, CultureInfo.InvariantCulture))));
             timeSpanToStringConverterProperty.SetSentinelFromProviderValue("00:00:00");
 
             var timeSpanToTicksConverterProperty = runtimeEntityType.AddProperty(
@@ -1682,6 +14539,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanToTicksConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanToTicksConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new TimeSpanToTicksConverter());
+            timeSpanToTicksConverterProperty.SetGetter(
+                TimeSpan (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(entity) == default(TimeSpan),
+                TimeSpan (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(instance) == default(TimeSpan));
+            timeSpanToTicksConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan value) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(entity) = value);
+            timeSpanToTicksConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, TimeSpan value) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(entity) = value);
+            timeSpanToTicksConverterProperty.SetAccessors(
+                TimeSpan (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.TimeSpanToTicksConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                TimeSpan (InternalEntityEntry entry) => entry.ReadOriginalValue<TimeSpan>(timeSpanToTicksConverterProperty, 249),
+                TimeSpan (InternalEntityEntry entry) => entry.GetCurrentValue<TimeSpan>(timeSpanToTicksConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[249]);
+            timeSpanToTicksConverterProperty.SetPropertyIndexes(
+                index: 249,
+                originalValueIndex: 249,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            timeSpanToTicksConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                keyComparer: new ValueComparer<TimeSpan>(
+                    bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
+                    int (TimeSpan v) => ((object)v).GetHashCode(),
+                    TimeSpan (TimeSpan v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                converter: new ValueConverter<TimeSpan, long>(
+                    long (TimeSpan v) => v.Ticks,
+                    TimeSpan (long v) => new TimeSpan(v)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<TimeSpan, long>(
+                    JsonInt64ReaderWriter.Instance,
+                    new ValueConverter<TimeSpan, long>(
+                        long (TimeSpan v) => v.Ticks,
+                        TimeSpan (long v) => new TimeSpan(v))));
             timeSpanToTicksConverterProperty.SetSentinelFromProviderValue(0L);
 
             var uInt16 = runtimeEntityType.AddProperty(
@@ -1690,12 +14589,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: (ushort)0);
+            uInt16.SetGetter(
+                ushort (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt16(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt16(entity) == 0,
+                ushort (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16(instance) == 0);
+            uInt16.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort value) => ManyTypesUnsafeAccessors.UInt16(entity) = value);
+            uInt16.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort value) => ManyTypesUnsafeAccessors.UInt16(entity) = value);
+            uInt16.SetAccessors(
+                ushort (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt16(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort (InternalEntityEntry entry) => entry.ReadOriginalValue<ushort>(uInt16, 250),
+                ushort (InternalEntityEntry entry) => entry.GetCurrentValue<ushort>(uInt16),
+                object (ValueBuffer valueBuffer) => valueBuffer[250]);
+            uInt16.SetPropertyIndexes(
+                index: 250,
+                originalValueIndex: 250,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt16.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v),
+                keyComparer: new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v),
+                providerValueComparer: new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v),
+                clrType: typeof(ushort),
+                jsonValueReaderWriter: JsonUInt16ReaderWriter.Instance);
 
             var uInt16Array = runtimeEntityType.AddProperty(
                 "UInt16Array",
                 typeof(ushort[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uInt16Array.SetGetter(
+                ushort[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt16Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt16Array(entity) == null,
+                ushort[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt16Array(instance) == null);
+            uInt16Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort[] value) => ManyTypesUnsafeAccessors.UInt16Array(entity) = value);
+            uInt16Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ushort[] value) => ManyTypesUnsafeAccessors.UInt16Array(entity) = value);
+            uInt16Array.SetAccessors(
+                ushort[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt16Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ushort[] (InternalEntityEntry entry) => entry.ReadOriginalValue<ushort[]>(uInt16Array, 251),
+                ushort[] (InternalEntityEntry entry) => entry.GetCurrentValue<ushort[]>(uInt16Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[251]);
+            uInt16Array.SetPropertyIndexes(
+                index: 251,
+                originalValueIndex: 251,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt16Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<ushort[], ushort>(new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v)),
+                keyComparer: new ListOfValueTypesComparer<ushort[], ushort>(new ValueComparer<ushort>(
+                    bool (ushort v1, ushort v2) => v1 == v2,
+                    int (ushort v) => ((int)(v)),
+                    ushort (ushort v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<ushort>(new JsonCollectionOfStructsReaderWriter<ushort[], ushort>(
+                    JsonUInt16ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<ushort[], ushort>(
+                    JsonUInt16ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<ushort>(
+                        bool (ushort v1, ushort v2) => v1 == v2,
+                        int (ushort v) => ((int)(v)),
+                        ushort (ushort v) => v),
+                    keyComparer: new ValueComparer<ushort>(
+                        bool (ushort v1, ushort v2) => v1 == v2,
+                        int (ushort v) => ((int)(v)),
+                        ushort (ushort v) => v),
+                    providerValueComparer: new ValueComparer<ushort>(
+                        bool (ushort v1, ushort v2) => v1 == v2,
+                        int (ushort v) => ((int)(v)),
+                        ushort (ushort v) => v),
+                    clrType: typeof(ushort),
+                    jsonValueReaderWriter: JsonUInt16ReaderWriter.Instance));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
+            uInt16ArrayElementType.TypeMapping = uInt16Array.TypeMapping.ElementTypeMapping;
 
             var uInt32 = runtimeEntityType.AddProperty(
                 "UInt32",
@@ -1703,12 +14693,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0u);
+            uInt32.SetGetter(
+                uint (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt32(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt32(entity) == 0U,
+                uint (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32(instance) == 0U);
+            uInt32.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint value) => ManyTypesUnsafeAccessors.UInt32(entity) = value);
+            uInt32.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint value) => ManyTypesUnsafeAccessors.UInt32(entity) = value);
+            uInt32.SetAccessors(
+                uint (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt32(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint (InternalEntityEntry entry) => entry.ReadOriginalValue<uint>(uInt32, 252),
+                uint (InternalEntityEntry entry) => entry.GetCurrentValue<uint>(uInt32),
+                object (ValueBuffer valueBuffer) => valueBuffer[252]);
+            uInt32.SetPropertyIndexes(
+                index: 252,
+                originalValueIndex: 252,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt32.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v),
+                keyComparer: new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v),
+                providerValueComparer: new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v),
+                clrType: typeof(uint),
+                jsonValueReaderWriter: JsonUInt32ReaderWriter.Instance);
 
             var uInt32Array = runtimeEntityType.AddProperty(
                 "UInt32Array",
                 typeof(uint[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uInt32Array.SetGetter(
+                uint[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt32Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt32Array(entity) == null,
+                uint[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt32Array(instance) == null);
+            uInt32Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint[] value) => ManyTypesUnsafeAccessors.UInt32Array(entity) = value);
+            uInt32Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, uint[] value) => ManyTypesUnsafeAccessors.UInt32Array(entity) = value);
+            uInt32Array.SetAccessors(
+                uint[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt32Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                uint[] (InternalEntityEntry entry) => entry.ReadOriginalValue<uint[]>(uInt32Array, 253),
+                uint[] (InternalEntityEntry entry) => entry.GetCurrentValue<uint[]>(uInt32Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[253]);
+            uInt32Array.SetPropertyIndexes(
+                index: 253,
+                originalValueIndex: 253,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt32Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<uint[], uint>(new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v)),
+                keyComparer: new ListOfValueTypesComparer<uint[], uint>(new ValueComparer<uint>(
+                    bool (uint v1, uint v2) => v1 == v2,
+                    int (uint v) => ((int)(v)),
+                    uint (uint v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<uint>(new JsonCollectionOfStructsReaderWriter<uint[], uint>(
+                    JsonUInt32ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<uint[], uint>(
+                    JsonUInt32ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<uint>(
+                        bool (uint v1, uint v2) => v1 == v2,
+                        int (uint v) => ((int)(v)),
+                        uint (uint v) => v),
+                    keyComparer: new ValueComparer<uint>(
+                        bool (uint v1, uint v2) => v1 == v2,
+                        int (uint v) => ((int)(v)),
+                        uint (uint v) => v),
+                    providerValueComparer: new ValueComparer<uint>(
+                        bool (uint v1, uint v2) => v1 == v2,
+                        int (uint v) => ((int)(v)),
+                        uint (uint v) => v),
+                    clrType: typeof(uint),
+                    jsonValueReaderWriter: JsonUInt32ReaderWriter.Instance));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
+            uInt32ArrayElementType.TypeMapping = uInt32Array.TypeMapping.ElementTypeMapping;
 
             var uInt64 = runtimeEntityType.AddProperty(
                 "UInt64",
@@ -1716,12 +14797,103 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0ul);
+            uInt64.SetGetter(
+                ulong (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt64(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt64(entity) == 0UL,
+                ulong (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64(instance) == 0UL);
+            uInt64.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong value) => ManyTypesUnsafeAccessors.UInt64(entity) = value);
+            uInt64.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong value) => ManyTypesUnsafeAccessors.UInt64(entity) = value);
+            uInt64.SetAccessors(
+                ulong (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt64(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong>(uInt64, 254),
+                ulong (InternalEntityEntry entry) => entry.GetCurrentValue<ulong>(uInt64),
+                object (ValueBuffer valueBuffer) => valueBuffer[254]);
+            uInt64.SetPropertyIndexes(
+                index: 254,
+                originalValueIndex: 254,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt64.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v),
+                keyComparer: new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v),
+                providerValueComparer: new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v),
+                clrType: typeof(ulong),
+                jsonValueReaderWriter: JsonUInt64ReaderWriter.Instance);
 
             var uInt64Array = runtimeEntityType.AddProperty(
                 "UInt64Array",
                 typeof(ulong[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uInt64Array.SetGetter(
+                ulong[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt64Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt64Array(entity) == null,
+                ulong[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt64Array(instance) == null);
+            uInt64Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong[] value) => ManyTypesUnsafeAccessors.UInt64Array(entity) = value);
+            uInt64Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, ulong[] value) => ManyTypesUnsafeAccessors.UInt64Array(entity) = value);
+            uInt64Array.SetAccessors(
+                ulong[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt64Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                ulong[] (InternalEntityEntry entry) => entry.ReadOriginalValue<ulong[]>(uInt64Array, 255),
+                ulong[] (InternalEntityEntry entry) => entry.GetCurrentValue<ulong[]>(uInt64Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[255]);
+            uInt64Array.SetPropertyIndexes(
+                index: 255,
+                originalValueIndex: 255,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt64Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<ulong[], ulong>(new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v)),
+                keyComparer: new ListOfValueTypesComparer<ulong[], ulong>(new ValueComparer<ulong>(
+                    bool (ulong v1, ulong v2) => v1 == v2,
+                    int (ulong v) => ((object)v).GetHashCode(),
+                    ulong (ulong v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<ulong>(new JsonCollectionOfStructsReaderWriter<ulong[], ulong>(
+                    JsonUInt64ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<ulong[], ulong>(
+                    JsonUInt64ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<ulong>(
+                        bool (ulong v1, ulong v2) => v1 == v2,
+                        int (ulong v) => ((object)v).GetHashCode(),
+                        ulong (ulong v) => v),
+                    keyComparer: new ValueComparer<ulong>(
+                        bool (ulong v1, ulong v2) => v1 == v2,
+                        int (ulong v) => ((object)v).GetHashCode(),
+                        ulong (ulong v) => v),
+                    providerValueComparer: new ValueComparer<ulong>(
+                        bool (ulong v1, ulong v2) => v1 == v2,
+                        int (ulong v) => ((object)v).GetHashCode(),
+                        ulong (ulong v) => v),
+                    clrType: typeof(ulong),
+                    jsonValueReaderWriter: JsonUInt64ReaderWriter.Instance));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
+            uInt64ArrayElementType.TypeMapping = uInt64Array.TypeMapping.ElementTypeMapping;
 
             var uInt8 = runtimeEntityType.AddProperty(
                 "UInt8",
@@ -1729,30 +14901,329 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: (byte)0);
+            uInt8.SetGetter(
+                byte (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt8(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt8(entity) == 0,
+                byte (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8(instance) == 0);
+            uInt8.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte value) => ManyTypesUnsafeAccessors.UInt8(entity) = value);
+            uInt8.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte value) => ManyTypesUnsafeAccessors.UInt8(entity) = value);
+            uInt8.SetAccessors(
+                byte (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt8(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte (InternalEntityEntry entry) => entry.ReadOriginalValue<byte>(uInt8, 256),
+                byte (InternalEntityEntry entry) => entry.GetCurrentValue<byte>(uInt8),
+                object (ValueBuffer valueBuffer) => valueBuffer[256]);
+            uInt8.SetPropertyIndexes(
+                index: 256,
+                originalValueIndex: 256,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt8.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                keyComparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                providerValueComparer: new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v),
+                clrType: typeof(byte),
+                jsonValueReaderWriter: JsonByteReaderWriter.Instance);
 
             var uInt8Array = runtimeEntityType.AddProperty(
                 "UInt8Array",
                 typeof(byte[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uInt8Array.SetGetter(
+                byte[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt8Array(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt8Array(entity) == null,
+                byte[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8Array(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8Array(instance) == null);
+            uInt8Array.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.UInt8Array(entity) = value);
+            uInt8Array.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, byte[] value) => ManyTypesUnsafeAccessors.UInt8Array(entity) = value);
+            uInt8Array.SetAccessors(
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt8Array(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                byte[] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[]>(uInt8Array, 257),
+                byte[] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[]>(uInt8Array),
+                object (ValueBuffer valueBuffer) => valueBuffer[257]);
+            uInt8Array.SetPropertyIndexes(
+                index: 257,
+                originalValueIndex: 257,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt8Array.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v),
+                keyComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                clrType: typeof(byte[]),
+                jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance);
 
             var uInt8NestedCollection = runtimeEntityType.AddProperty(
                 "UInt8NestedCollection",
                 typeof(List<byte[]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uInt8NestedCollection.SetGetter(
+                List<byte[]> (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt8NestedCollection(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UInt8NestedCollection(entity) == null,
+                List<byte[]> (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8NestedCollection(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UInt8NestedCollection(instance) == null);
+            uInt8NestedCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<byte[]> value) => ManyTypesUnsafeAccessors.UInt8NestedCollection(entity) = value);
+            uInt8NestedCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, List<byte[]> value) => ManyTypesUnsafeAccessors.UInt8NestedCollection(entity) = value);
+            uInt8NestedCollection.SetAccessors(
+                List<byte[]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<byte[]> (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UInt8NestedCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                List<byte[]> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<byte[]>>(uInt8NestedCollection, 258),
+                List<byte[]> (InternalEntityEntry entry) => entry.GetCurrentValue<List<byte[]>>(uInt8NestedCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[258]);
+            uInt8NestedCollection.SetPropertyIndexes(
+                index: 258,
+                originalValueIndex: 258,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt8NestedCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<byte[]>, byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<byte[]>, byte[]>(new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte[]>(new JsonCollectionOfReferencesReaderWriter<List<byte[]>, byte[]>(
+                    JsonByteArrayReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<byte[]>, byte[]>(
+                    JsonByteArrayReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => ((object)v).GetHashCode(),
+                        byte[] (byte[] v) => v),
+                    keyComparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                        byte[] (byte[] source) => source.ToArray()),
+                    providerValueComparer: new ValueComparer<byte[]>(
+                        bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                        int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                        byte[] (byte[] source) => source.ToArray()),
+                    clrType: typeof(byte[]),
+                    jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance));
+            var uInt8NestedCollectionElementType = uInt8NestedCollection.SetElementType(typeof(byte[]));
+            uInt8NestedCollectionElementType.TypeMapping = uInt8NestedCollection.TypeMapping.ElementTypeMapping;
+
+            var uInt8ReadOnlyCollection = runtimeEntityType.AddProperty(
+                "UInt8ReadOnlyCollection",
+                typeof(IReadOnlyCollection<byte>),
+                propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
+                fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_uInt8ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uInt8ReadOnlyCollection.SetGetter(
+                IReadOnlyCollection<byte> (CompiledModelTestBase.ManyTypes entity) => (ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(entity) == null ? null : ((IReadOnlyCollection<byte>)(ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(entity)))),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(entity) == null,
+                IReadOnlyCollection<byte> (CompiledModelTestBase.ManyTypes instance) => (ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance) == null ? null : ((IReadOnlyCollection<byte>)(ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance)))),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(instance) == null);
+            uInt8ReadOnlyCollection.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<byte> value) => ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(entity) = ((List<byte>)(value)));
+            uInt8ReadOnlyCollection.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, IReadOnlyCollection<byte> value) => ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(entity) = ((List<byte>)(value)));
+            uInt8ReadOnlyCollection.SetAccessors(
+                IReadOnlyCollection<byte> (InternalEntityEntry entry) => ((IReadOnlyCollection<byte>)(ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<byte> (InternalEntityEntry entry) => ((IReadOnlyCollection<byte>)(ManyTypesUnsafeAccessors._uInt8ReadOnlyCollection(((CompiledModelTestBase.ManyTypes)(entry.Entity))))),
+                IReadOnlyCollection<byte> (InternalEntityEntry entry) => entry.ReadOriginalValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection, 259),
+                IReadOnlyCollection<byte> (InternalEntityEntry entry) => entry.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection),
+                object (ValueBuffer valueBuffer) => valueBuffer[259]);
+            uInt8ReadOnlyCollection.SetPropertyIndexes(
+                index: 259,
+                originalValueIndex: 259,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uInt8ReadOnlyCollection.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
+            uInt8ReadOnlyCollectionElementType.TypeMapping = uInt8ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var uri = runtimeEntityType.AddProperty(
                 "Uri",
                 typeof(Uri),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Uri", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Uri>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uri.SetGetter(
+                Uri (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Uri(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.Uri(entity) == null,
+                Uri (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Uri(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.Uri(instance) == null);
+            uri.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri value) => ManyTypesUnsafeAccessors.Uri(entity) = value);
+            uri.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri value) => ManyTypesUnsafeAccessors.Uri(entity) = value);
+            uri.SetAccessors(
+                Uri (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Uri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.Uri(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri (InternalEntityEntry entry) => entry.ReadOriginalValue<Uri>(uri, 260),
+                Uri (InternalEntityEntry entry) => entry.GetCurrentValue<Uri>(uri),
+                object (ValueBuffer valueBuffer) => valueBuffer[260]);
+            uri.SetPropertyIndexes(
+                index: 260,
+                originalValueIndex: 260,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uri.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v),
+                keyComparer: new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<Uri, string>(
+                    string (Uri v) => ((object)v).ToString(),
+                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<Uri, string>(
+                        string (Uri v) => ((object)v).ToString(),
+                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
 
             var uriArray = runtimeEntityType.AddProperty(
                 "UriArray",
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            uriArray.SetGetter(
+                Uri[] (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UriArray(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UriArray(entity) == null,
+                Uri[] (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriArray(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriArray(instance) == null);
+            uriArray.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri[] value) => ManyTypesUnsafeAccessors.UriArray(entity) = value);
+            uriArray.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri[] value) => ManyTypesUnsafeAccessors.UriArray(entity) = value);
+            uriArray.SetAccessors(
+                Uri[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri[] (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UriArray(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri[] (InternalEntityEntry entry) => entry.ReadOriginalValue<Uri[]>(uriArray, 261),
+                Uri[] (InternalEntityEntry entry) => entry.GetCurrentValue<Uri[]>(uriArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[261]);
+            uriArray.SetPropertyIndexes(
+                index: 261,
+                originalValueIndex: 261,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uriArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<Uri[], Uri>(new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<Uri>(new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
+                    new JsonConvertedValueReaderWriter<Uri, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<Uri, string>(
+                            string (Uri v) => ((object)v).ToString(),
+                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<Uri[], Uri>(
+                    new JsonConvertedValueReaderWriter<Uri, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<Uri, string>(
+                            string (Uri v) => ((object)v).ToString(),
+                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<Uri>(
+                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (Uri v) => ((object)v).GetHashCode(),
+                        Uri (Uri v) => v),
+                    keyComparer: new ValueComparer<Uri>(
+                        bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (Uri v) => ((object)v).GetHashCode(),
+                        Uri (Uri v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<Uri, string>(
+                        string (Uri v) => ((object)v).ToString(),
+                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<Uri, string>(
+                            string (Uri v) => ((object)v).ToString(),
+                            Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
+            uriArrayElementType.TypeMapping = uriArray.TypeMapping.ElementTypeMapping;
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                 "UriToStringConverterProperty",
@@ -1760,6 +15231,48 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriToStringConverterProperty", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriToStringConverterProperty>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 valueConverter: new UriToStringConverter());
+            uriToStringConverterProperty.SetGetter(
+                Uri (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(entity),
+                bool (CompiledModelTestBase.ManyTypes entity) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(entity) == null,
+                Uri (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(instance),
+                bool (CompiledModelTestBase.ManyTypes instance) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(instance) == null);
+            uriToStringConverterProperty.SetSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri value) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(entity) = value);
+            uriToStringConverterProperty.SetMaterializationSetter(
+                (CompiledModelTestBase.ManyTypes entity, Uri value) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(entity) = value);
+            uriToStringConverterProperty.SetAccessors(
+                Uri (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri (InternalEntityEntry entry) => ManyTypesUnsafeAccessors.UriToStringConverterProperty(((CompiledModelTestBase.ManyTypes)(entry.Entity))),
+                Uri (InternalEntityEntry entry) => entry.ReadOriginalValue<Uri>(uriToStringConverterProperty, 262),
+                Uri (InternalEntityEntry entry) => entry.GetCurrentValue<Uri>(uriToStringConverterProperty),
+                object (ValueBuffer valueBuffer) => valueBuffer[262]);
+            uriToStringConverterProperty.SetPropertyIndexes(
+                index: 262,
+                originalValueIndex: 262,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            uriToStringConverterProperty.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v),
+                keyComparer: new ValueComparer<Uri>(
+                    bool (Uri v1, Uri v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (Uri v) => ((object)v).GetHashCode(),
+                    Uri (Uri v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new ValueConverter<Uri, string>(
+                    string (Uri v) => ((object)v).ToString(),
+                    Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)),
+                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Uri, string>(
+                    JsonStringReaderWriter.Instance,
+                    new ValueConverter<Uri, string>(
+                        string (Uri v) => ((object)v).ToString(),
+                        Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute))));
 
             var key = runtimeEntityType.AddKey(
                 new[] { id });
@@ -1770,6 +15283,316 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var id = runtimeEntityType.FindProperty("Id");
+            var @bool = runtimeEntityType.FindProperty("Bool");
+            var boolArray = runtimeEntityType.FindProperty("BoolArray");
+            var boolNestedCollection = runtimeEntityType.FindProperty("BoolNestedCollection");
+            var boolReadOnlyCollection = runtimeEntityType.FindProperty("BoolReadOnlyCollection");
+            var boolToStringConverterProperty = runtimeEntityType.FindProperty("BoolToStringConverterProperty");
+            var boolToTwoValuesConverterProperty = runtimeEntityType.FindProperty("BoolToTwoValuesConverterProperty");
+            var boolToZeroOneConverterProperty = runtimeEntityType.FindProperty("BoolToZeroOneConverterProperty");
+            var bytes = runtimeEntityType.FindProperty("Bytes");
+            var bytesArray = runtimeEntityType.FindProperty("BytesArray");
+            var bytesNestedCollection = runtimeEntityType.FindProperty("BytesNestedCollection");
+            var bytesToStringConverterProperty = runtimeEntityType.FindProperty("BytesToStringConverterProperty");
+            var castingConverterProperty = runtimeEntityType.FindProperty("CastingConverterProperty");
+            var @char = runtimeEntityType.FindProperty("Char");
+            var charArray = runtimeEntityType.FindProperty("CharArray");
+            var charNestedCollection = runtimeEntityType.FindProperty("CharNestedCollection");
+            var charToStringConverterProperty = runtimeEntityType.FindProperty("CharToStringConverterProperty");
+            var dateOnly = runtimeEntityType.FindProperty("DateOnly");
+            var dateOnlyArray = runtimeEntityType.FindProperty("DateOnlyArray");
+            var dateOnlyToStringConverterProperty = runtimeEntityType.FindProperty("DateOnlyToStringConverterProperty");
+            var dateTime = runtimeEntityType.FindProperty("DateTime");
+            var dateTimeArray = runtimeEntityType.FindProperty("DateTimeArray");
+            var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.FindProperty("DateTimeOffsetToBinaryConverterProperty");
+            var dateTimeOffsetToBytesConverterProperty = runtimeEntityType.FindProperty("DateTimeOffsetToBytesConverterProperty");
+            var dateTimeOffsetToStringConverterProperty = runtimeEntityType.FindProperty("DateTimeOffsetToStringConverterProperty");
+            var dateTimeToBinaryConverterProperty = runtimeEntityType.FindProperty("DateTimeToBinaryConverterProperty");
+            var dateTimeToStringConverterProperty = runtimeEntityType.FindProperty("DateTimeToStringConverterProperty");
+            var dateTimeToTicksConverterProperty = runtimeEntityType.FindProperty("DateTimeToTicksConverterProperty");
+            var @decimal = runtimeEntityType.FindProperty("Decimal");
+            var decimalArray = runtimeEntityType.FindProperty("DecimalArray");
+            var decimalNumberToBytesConverterProperty = runtimeEntityType.FindProperty("DecimalNumberToBytesConverterProperty");
+            var decimalNumberToStringConverterProperty = runtimeEntityType.FindProperty("DecimalNumberToStringConverterProperty");
+            var @double = runtimeEntityType.FindProperty("Double");
+            var doubleArray = runtimeEntityType.FindProperty("DoubleArray");
+            var doubleNumberToBytesConverterProperty = runtimeEntityType.FindProperty("DoubleNumberToBytesConverterProperty");
+            var doubleNumberToStringConverterProperty = runtimeEntityType.FindProperty("DoubleNumberToStringConverterProperty");
+            var enum16 = runtimeEntityType.FindProperty("Enum16");
+            var enum16Array = runtimeEntityType.FindProperty("Enum16Array");
+            var enum16AsString = runtimeEntityType.FindProperty("Enum16AsString");
+            var enum16AsStringArray = runtimeEntityType.FindProperty("Enum16AsStringArray");
+            var enum16AsStringCollection = runtimeEntityType.FindProperty("Enum16AsStringCollection");
+            var enum16Collection = runtimeEntityType.FindProperty("Enum16Collection");
+            var enum32 = runtimeEntityType.FindProperty("Enum32");
+            var enum32Array = runtimeEntityType.FindProperty("Enum32Array");
+            var enum32AsString = runtimeEntityType.FindProperty("Enum32AsString");
+            var enum32AsStringArray = runtimeEntityType.FindProperty("Enum32AsStringArray");
+            var enum32AsStringCollection = runtimeEntityType.FindProperty("Enum32AsStringCollection");
+            var enum32Collection = runtimeEntityType.FindProperty("Enum32Collection");
+            var enum32NestedCollection = runtimeEntityType.FindProperty("Enum32NestedCollection");
+            var enum64 = runtimeEntityType.FindProperty("Enum64");
+            var enum64Array = runtimeEntityType.FindProperty("Enum64Array");
+            var enum64AsString = runtimeEntityType.FindProperty("Enum64AsString");
+            var enum64AsStringArray = runtimeEntityType.FindProperty("Enum64AsStringArray");
+            var enum64AsStringCollection = runtimeEntityType.FindProperty("Enum64AsStringCollection");
+            var enum64Collection = runtimeEntityType.FindProperty("Enum64Collection");
+            var enum8 = runtimeEntityType.FindProperty("Enum8");
+            var enum8Array = runtimeEntityType.FindProperty("Enum8Array");
+            var enum8AsString = runtimeEntityType.FindProperty("Enum8AsString");
+            var enum8AsStringArray = runtimeEntityType.FindProperty("Enum8AsStringArray");
+            var enum8AsStringCollection = runtimeEntityType.FindProperty("Enum8AsStringCollection");
+            var enum8Collection = runtimeEntityType.FindProperty("Enum8Collection");
+            var enum8NestedCollection = runtimeEntityType.FindProperty("Enum8NestedCollection");
+            var enumToNumberConverterProperty = runtimeEntityType.FindProperty("EnumToNumberConverterProperty");
+            var enumToStringConverterProperty = runtimeEntityType.FindProperty("EnumToStringConverterProperty");
+            var enumU16 = runtimeEntityType.FindProperty("EnumU16");
+            var enumU16Array = runtimeEntityType.FindProperty("EnumU16Array");
+            var enumU16AsString = runtimeEntityType.FindProperty("EnumU16AsString");
+            var enumU16AsStringArray = runtimeEntityType.FindProperty("EnumU16AsStringArray");
+            var enumU16AsStringCollection = runtimeEntityType.FindProperty("EnumU16AsStringCollection");
+            var enumU16Collection = runtimeEntityType.FindProperty("EnumU16Collection");
+            var enumU32 = runtimeEntityType.FindProperty("EnumU32");
+            var enumU32Array = runtimeEntityType.FindProperty("EnumU32Array");
+            var enumU32AsString = runtimeEntityType.FindProperty("EnumU32AsString");
+            var enumU32AsStringArray = runtimeEntityType.FindProperty("EnumU32AsStringArray");
+            var enumU32AsStringCollection = runtimeEntityType.FindProperty("EnumU32AsStringCollection");
+            var enumU32Collection = runtimeEntityType.FindProperty("EnumU32Collection");
+            var enumU64 = runtimeEntityType.FindProperty("EnumU64");
+            var enumU64Array = runtimeEntityType.FindProperty("EnumU64Array");
+            var enumU64AsString = runtimeEntityType.FindProperty("EnumU64AsString");
+            var enumU64AsStringArray = runtimeEntityType.FindProperty("EnumU64AsStringArray");
+            var enumU64AsStringCollection = runtimeEntityType.FindProperty("EnumU64AsStringCollection");
+            var enumU64Collection = runtimeEntityType.FindProperty("EnumU64Collection");
+            var enumU64NestedCollection = runtimeEntityType.FindProperty("EnumU64NestedCollection");
+            var enumU8 = runtimeEntityType.FindProperty("EnumU8");
+            var enumU8Array = runtimeEntityType.FindProperty("EnumU8Array");
+            var enumU8AsString = runtimeEntityType.FindProperty("EnumU8AsString");
+            var enumU8AsStringArray = runtimeEntityType.FindProperty("EnumU8AsStringArray");
+            var enumU8AsStringCollection = runtimeEntityType.FindProperty("EnumU8AsStringCollection");
+            var enumU8Collection = runtimeEntityType.FindProperty("EnumU8Collection");
+            var @float = runtimeEntityType.FindProperty("Float");
+            var floatArray = runtimeEntityType.FindProperty("FloatArray");
+            var guid = runtimeEntityType.FindProperty("Guid");
+            var guidArray = runtimeEntityType.FindProperty("GuidArray");
+            var guidNestedCollection = runtimeEntityType.FindProperty("GuidNestedCollection");
+            var guidToBytesConverterProperty = runtimeEntityType.FindProperty("GuidToBytesConverterProperty");
+            var guidToStringConverterProperty = runtimeEntityType.FindProperty("GuidToStringConverterProperty");
+            var iPAddress = runtimeEntityType.FindProperty("IPAddress");
+            var iPAddressArray = runtimeEntityType.FindProperty("IPAddressArray");
+            var iPAddressReadOnlyCollection = runtimeEntityType.FindProperty("IPAddressReadOnlyCollection");
+            var iPAddressToBytesConverterProperty = runtimeEntityType.FindProperty("IPAddressToBytesConverterProperty");
+            var iPAddressToStringConverterProperty = runtimeEntityType.FindProperty("IPAddressToStringConverterProperty");
+            var int16 = runtimeEntityType.FindProperty("Int16");
+            var int16Array = runtimeEntityType.FindProperty("Int16Array");
+            var int32 = runtimeEntityType.FindProperty("Int32");
+            var int32Array = runtimeEntityType.FindProperty("Int32Array");
+            var int32NestedCollection = runtimeEntityType.FindProperty("Int32NestedCollection");
+            var int32ReadOnlyCollection = runtimeEntityType.FindProperty("Int32ReadOnlyCollection");
+            var int64 = runtimeEntityType.FindProperty("Int64");
+            var int64Array = runtimeEntityType.FindProperty("Int64Array");
+            var int64NestedCollection = runtimeEntityType.FindProperty("Int64NestedCollection");
+            var int8 = runtimeEntityType.FindProperty("Int8");
+            var int8Array = runtimeEntityType.FindProperty("Int8Array");
+            var int8NestedCollection = runtimeEntityType.FindProperty("Int8NestedCollection");
+            var intNumberToBytesConverterProperty = runtimeEntityType.FindProperty("IntNumberToBytesConverterProperty");
+            var intNumberToStringConverterProperty = runtimeEntityType.FindProperty("IntNumberToStringConverterProperty");
+            var nullIntToNullStringConverterProperty = runtimeEntityType.FindProperty("NullIntToNullStringConverterProperty");
+            var nullableBool = runtimeEntityType.FindProperty("NullableBool");
+            var nullableBoolArray = runtimeEntityType.FindProperty("NullableBoolArray");
+            var nullableBytes = runtimeEntityType.FindProperty("NullableBytes");
+            var nullableBytesArray = runtimeEntityType.FindProperty("NullableBytesArray");
+            var nullableBytesNestedCollection = runtimeEntityType.FindProperty("NullableBytesNestedCollection");
+            var nullableChar = runtimeEntityType.FindProperty("NullableChar");
+            var nullableCharArray = runtimeEntityType.FindProperty("NullableCharArray");
+            var nullableDateOnly = runtimeEntityType.FindProperty("NullableDateOnly");
+            var nullableDateOnlyArray = runtimeEntityType.FindProperty("NullableDateOnlyArray");
+            var nullableDateTime = runtimeEntityType.FindProperty("NullableDateTime");
+            var nullableDateTimeArray = runtimeEntityType.FindProperty("NullableDateTimeArray");
+            var nullableDecimal = runtimeEntityType.FindProperty("NullableDecimal");
+            var nullableDecimalArray = runtimeEntityType.FindProperty("NullableDecimalArray");
+            var nullableDouble = runtimeEntityType.FindProperty("NullableDouble");
+            var nullableDoubleArray = runtimeEntityType.FindProperty("NullableDoubleArray");
+            var nullableEnum16 = runtimeEntityType.FindProperty("NullableEnum16");
+            var nullableEnum16Array = runtimeEntityType.FindProperty("NullableEnum16Array");
+            var nullableEnum16AsString = runtimeEntityType.FindProperty("NullableEnum16AsString");
+            var nullableEnum16AsStringArray = runtimeEntityType.FindProperty("NullableEnum16AsStringArray");
+            var nullableEnum16AsStringCollection = runtimeEntityType.FindProperty("NullableEnum16AsStringCollection");
+            var nullableEnum16Collection = runtimeEntityType.FindProperty("NullableEnum16Collection");
+            var nullableEnum32 = runtimeEntityType.FindProperty("NullableEnum32");
+            var nullableEnum32Array = runtimeEntityType.FindProperty("NullableEnum32Array");
+            var nullableEnum32AsString = runtimeEntityType.FindProperty("NullableEnum32AsString");
+            var nullableEnum32AsStringArray = runtimeEntityType.FindProperty("NullableEnum32AsStringArray");
+            var nullableEnum32AsStringCollection = runtimeEntityType.FindProperty("NullableEnum32AsStringCollection");
+            var nullableEnum32Collection = runtimeEntityType.FindProperty("NullableEnum32Collection");
+            var nullableEnum32NestedCollection = runtimeEntityType.FindProperty("NullableEnum32NestedCollection");
+            var nullableEnum64 = runtimeEntityType.FindProperty("NullableEnum64");
+            var nullableEnum64Array = runtimeEntityType.FindProperty("NullableEnum64Array");
+            var nullableEnum64AsString = runtimeEntityType.FindProperty("NullableEnum64AsString");
+            var nullableEnum64AsStringArray = runtimeEntityType.FindProperty("NullableEnum64AsStringArray");
+            var nullableEnum64AsStringCollection = runtimeEntityType.FindProperty("NullableEnum64AsStringCollection");
+            var nullableEnum64Collection = runtimeEntityType.FindProperty("NullableEnum64Collection");
+            var nullableEnum8 = runtimeEntityType.FindProperty("NullableEnum8");
+            var nullableEnum8Array = runtimeEntityType.FindProperty("NullableEnum8Array");
+            var nullableEnum8AsString = runtimeEntityType.FindProperty("NullableEnum8AsString");
+            var nullableEnum8AsStringArray = runtimeEntityType.FindProperty("NullableEnum8AsStringArray");
+            var nullableEnum8AsStringCollection = runtimeEntityType.FindProperty("NullableEnum8AsStringCollection");
+            var nullableEnum8Collection = runtimeEntityType.FindProperty("NullableEnum8Collection");
+            var nullableEnum8NestedCollection = runtimeEntityType.FindProperty("NullableEnum8NestedCollection");
+            var nullableEnumU16 = runtimeEntityType.FindProperty("NullableEnumU16");
+            var nullableEnumU16Array = runtimeEntityType.FindProperty("NullableEnumU16Array");
+            var nullableEnumU16AsString = runtimeEntityType.FindProperty("NullableEnumU16AsString");
+            var nullableEnumU16AsStringArray = runtimeEntityType.FindProperty("NullableEnumU16AsStringArray");
+            var nullableEnumU16AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU16AsStringCollection");
+            var nullableEnumU16Collection = runtimeEntityType.FindProperty("NullableEnumU16Collection");
+            var nullableEnumU32 = runtimeEntityType.FindProperty("NullableEnumU32");
+            var nullableEnumU32Array = runtimeEntityType.FindProperty("NullableEnumU32Array");
+            var nullableEnumU32AsString = runtimeEntityType.FindProperty("NullableEnumU32AsString");
+            var nullableEnumU32AsStringArray = runtimeEntityType.FindProperty("NullableEnumU32AsStringArray");
+            var nullableEnumU32AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU32AsStringCollection");
+            var nullableEnumU32Collection = runtimeEntityType.FindProperty("NullableEnumU32Collection");
+            var nullableEnumU64 = runtimeEntityType.FindProperty("NullableEnumU64");
+            var nullableEnumU64Array = runtimeEntityType.FindProperty("NullableEnumU64Array");
+            var nullableEnumU64AsString = runtimeEntityType.FindProperty("NullableEnumU64AsString");
+            var nullableEnumU64AsStringArray = runtimeEntityType.FindProperty("NullableEnumU64AsStringArray");
+            var nullableEnumU64AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU64AsStringCollection");
+            var nullableEnumU64Collection = runtimeEntityType.FindProperty("NullableEnumU64Collection");
+            var nullableEnumU64NestedCollection = runtimeEntityType.FindProperty("NullableEnumU64NestedCollection");
+            var nullableEnumU8 = runtimeEntityType.FindProperty("NullableEnumU8");
+            var nullableEnumU8Array = runtimeEntityType.FindProperty("NullableEnumU8Array");
+            var nullableEnumU8AsString = runtimeEntityType.FindProperty("NullableEnumU8AsString");
+            var nullableEnumU8AsStringArray = runtimeEntityType.FindProperty("NullableEnumU8AsStringArray");
+            var nullableEnumU8AsStringCollection = runtimeEntityType.FindProperty("NullableEnumU8AsStringCollection");
+            var nullableEnumU8Collection = runtimeEntityType.FindProperty("NullableEnumU8Collection");
+            var nullableFloat = runtimeEntityType.FindProperty("NullableFloat");
+            var nullableFloatArray = runtimeEntityType.FindProperty("NullableFloatArray");
+            var nullableGuid = runtimeEntityType.FindProperty("NullableGuid");
+            var nullableGuidArray = runtimeEntityType.FindProperty("NullableGuidArray");
+            var nullableGuidNestedCollection = runtimeEntityType.FindProperty("NullableGuidNestedCollection");
+            var nullableIPAddress = runtimeEntityType.FindProperty("NullableIPAddress");
+            var nullableIPAddressArray = runtimeEntityType.FindProperty("NullableIPAddressArray");
+            var nullableInt16 = runtimeEntityType.FindProperty("NullableInt16");
+            var nullableInt16Array = runtimeEntityType.FindProperty("NullableInt16Array");
+            var nullableInt32 = runtimeEntityType.FindProperty("NullableInt32");
+            var nullableInt32Array = runtimeEntityType.FindProperty("NullableInt32Array");
+            var nullableInt32NestedCollection = runtimeEntityType.FindProperty("NullableInt32NestedCollection");
+            var nullableInt64 = runtimeEntityType.FindProperty("NullableInt64");
+            var nullableInt64Array = runtimeEntityType.FindProperty("NullableInt64Array");
+            var nullableInt64NestedCollection = runtimeEntityType.FindProperty("NullableInt64NestedCollection");
+            var nullableInt8 = runtimeEntityType.FindProperty("NullableInt8");
+            var nullableInt8Array = runtimeEntityType.FindProperty("NullableInt8Array");
+            var nullablePhysicalAddress = runtimeEntityType.FindProperty("NullablePhysicalAddress");
+            var nullablePhysicalAddressArray = runtimeEntityType.FindProperty("NullablePhysicalAddressArray");
+            var nullablePhysicalAddressNestedCollection = runtimeEntityType.FindProperty("NullablePhysicalAddressNestedCollection");
+            var nullableString = runtimeEntityType.FindProperty("NullableString");
+            var nullableStringArray = runtimeEntityType.FindProperty("NullableStringArray");
+            var nullableStringNestedCollection = runtimeEntityType.FindProperty("NullableStringNestedCollection");
+            var nullableTimeOnly = runtimeEntityType.FindProperty("NullableTimeOnly");
+            var nullableTimeOnlyArray = runtimeEntityType.FindProperty("NullableTimeOnlyArray");
+            var nullableTimeSpan = runtimeEntityType.FindProperty("NullableTimeSpan");
+            var nullableTimeSpanArray = runtimeEntityType.FindProperty("NullableTimeSpanArray");
+            var nullableUInt16 = runtimeEntityType.FindProperty("NullableUInt16");
+            var nullableUInt16Array = runtimeEntityType.FindProperty("NullableUInt16Array");
+            var nullableUInt32 = runtimeEntityType.FindProperty("NullableUInt32");
+            var nullableUInt32Array = runtimeEntityType.FindProperty("NullableUInt32Array");
+            var nullableUInt64 = runtimeEntityType.FindProperty("NullableUInt64");
+            var nullableUInt64Array = runtimeEntityType.FindProperty("NullableUInt64Array");
+            var nullableUInt8 = runtimeEntityType.FindProperty("NullableUInt8");
+            var nullableUInt8Array = runtimeEntityType.FindProperty("NullableUInt8Array");
+            var nullableUInt8NestedCollection = runtimeEntityType.FindProperty("NullableUInt8NestedCollection");
+            var nullableUri = runtimeEntityType.FindProperty("NullableUri");
+            var nullableUriArray = runtimeEntityType.FindProperty("NullableUriArray");
+            var physicalAddress = runtimeEntityType.FindProperty("PhysicalAddress");
+            var physicalAddressArray = runtimeEntityType.FindProperty("PhysicalAddressArray");
+            var physicalAddressToBytesConverterProperty = runtimeEntityType.FindProperty("PhysicalAddressToBytesConverterProperty");
+            var physicalAddressToStringConverterProperty = runtimeEntityType.FindProperty("PhysicalAddressToStringConverterProperty");
+            var @string = runtimeEntityType.FindProperty("String");
+            var stringArray = runtimeEntityType.FindProperty("StringArray");
+            var stringNestedCollection = runtimeEntityType.FindProperty("StringNestedCollection");
+            var stringReadOnlyCollection = runtimeEntityType.FindProperty("StringReadOnlyCollection");
+            var stringToBoolConverterProperty = runtimeEntityType.FindProperty("StringToBoolConverterProperty");
+            var stringToBytesConverterProperty = runtimeEntityType.FindProperty("StringToBytesConverterProperty");
+            var stringToCharConverterProperty = runtimeEntityType.FindProperty("StringToCharConverterProperty");
+            var stringToDateOnlyConverterProperty = runtimeEntityType.FindProperty("StringToDateOnlyConverterProperty");
+            var stringToDateTimeConverterProperty = runtimeEntityType.FindProperty("StringToDateTimeConverterProperty");
+            var stringToDateTimeOffsetConverterProperty = runtimeEntityType.FindProperty("StringToDateTimeOffsetConverterProperty");
+            var stringToDecimalNumberConverterProperty = runtimeEntityType.FindProperty("StringToDecimalNumberConverterProperty");
+            var stringToDoubleNumberConverterProperty = runtimeEntityType.FindProperty("StringToDoubleNumberConverterProperty");
+            var stringToEnumConverterProperty = runtimeEntityType.FindProperty("StringToEnumConverterProperty");
+            var stringToGuidConverterProperty = runtimeEntityType.FindProperty("StringToGuidConverterProperty");
+            var stringToIntNumberConverterProperty = runtimeEntityType.FindProperty("StringToIntNumberConverterProperty");
+            var stringToTimeOnlyConverterProperty = runtimeEntityType.FindProperty("StringToTimeOnlyConverterProperty");
+            var stringToTimeSpanConverterProperty = runtimeEntityType.FindProperty("StringToTimeSpanConverterProperty");
+            var stringToUriConverterProperty = runtimeEntityType.FindProperty("StringToUriConverterProperty");
+            var timeOnly = runtimeEntityType.FindProperty("TimeOnly");
+            var timeOnlyArray = runtimeEntityType.FindProperty("TimeOnlyArray");
+            var timeOnlyToStringConverterProperty = runtimeEntityType.FindProperty("TimeOnlyToStringConverterProperty");
+            var timeOnlyToTicksConverterProperty = runtimeEntityType.FindProperty("TimeOnlyToTicksConverterProperty");
+            var timeSpan = runtimeEntityType.FindProperty("TimeSpan");
+            var timeSpanArray = runtimeEntityType.FindProperty("TimeSpanArray");
+            var timeSpanToStringConverterProperty = runtimeEntityType.FindProperty("TimeSpanToStringConverterProperty");
+            var timeSpanToTicksConverterProperty = runtimeEntityType.FindProperty("TimeSpanToTicksConverterProperty");
+            var uInt16 = runtimeEntityType.FindProperty("UInt16");
+            var uInt16Array = runtimeEntityType.FindProperty("UInt16Array");
+            var uInt32 = runtimeEntityType.FindProperty("UInt32");
+            var uInt32Array = runtimeEntityType.FindProperty("UInt32Array");
+            var uInt64 = runtimeEntityType.FindProperty("UInt64");
+            var uInt64Array = runtimeEntityType.FindProperty("UInt64Array");
+            var uInt8 = runtimeEntityType.FindProperty("UInt8");
+            var uInt8Array = runtimeEntityType.FindProperty("UInt8Array");
+            var uInt8NestedCollection = runtimeEntityType.FindProperty("UInt8NestedCollection");
+            var uInt8ReadOnlyCollection = runtimeEntityType.FindProperty("UInt8ReadOnlyCollection");
+            var uri = runtimeEntityType.FindProperty("Uri");
+            var uriArray = runtimeEntityType.FindProperty("UriArray");
+            var uriToStringConverterProperty = runtimeEntityType.FindProperty("UriToStringConverterProperty");
+            var key = runtimeEntityType.FindKey(new[] { id });
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<CompiledModelTestBase.ManyTypesId>(key));
+            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<CompiledModelTestBase.ManyTypesId>(key));
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg = ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId, bool, bool[], bool[][], IReadOnlyCollection<bool>, bool, bool, bool, byte[], byte[][], byte[][][], byte[], int, char, char[], char[][], char, DateOnly, DateOnly[], DateOnly, DateTime, DateTime[], DateTimeOffset, DateTimeOffset, DateTimeOffset, DateTime, DateTime, DateTime, decimal, decimal[]>(((ValueComparer<CompiledModelTestBase.ManyTypesId>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.ManyTypesId>(id)), ((ValueComparer<bool>)(((IProperty)@bool).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(@bool)), (((IEnumerable<bool>)(source.GetCurrentValue<bool[]>(boolArray))) == null ? null : ((bool[])(((ValueComparer<IEnumerable<bool>>)(((IProperty)boolArray).GetValueComparer())).Snapshot(((IEnumerable<bool>)(source.GetCurrentValue<bool[]>(boolArray))))))), (((object)(source.GetCurrentValue<bool[][]>(boolNestedCollection))) == null ? null : ((bool[][])(((ValueComparer<object>)(((IProperty)boolNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<bool[][]>(boolNestedCollection))))))), (((IEnumerable<bool>)(source.GetCurrentValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<bool>)(((ValueComparer<IEnumerable<bool>>)(((IProperty)boolReadOnlyCollection).GetValueComparer())).Snapshot(((IEnumerable<bool>)(source.GetCurrentValue<IReadOnlyCollection<bool>>(boolReadOnlyCollection))))))), ((ValueComparer<bool>)(((IProperty)boolToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(boolToStringConverterProperty)), ((ValueComparer<bool>)(((IProperty)boolToTwoValuesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(boolToTwoValuesConverterProperty)), ((ValueComparer<bool>)(((IProperty)boolToZeroOneConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(boolToZeroOneConverterProperty)), (source.GetCurrentValue<byte[]>(bytes) == null ? null : ((ValueComparer<byte[]>)(((IProperty)bytes).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(bytes))), (((object)(source.GetCurrentValue<byte[][]>(bytesArray))) == null ? null : ((byte[][])(((ValueComparer<object>)(((IProperty)bytesArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<byte[][]>(bytesArray))))))), (((object)(source.GetCurrentValue<byte[][][]>(bytesNestedCollection))) == null ? null : ((byte[][][])(((ValueComparer<object>)(((IProperty)bytesNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<byte[][][]>(bytesNestedCollection))))))), (source.GetCurrentValue<byte[]>(bytesToStringConverterProperty) == null ? null : ((ValueComparer<byte[]>)(((IProperty)bytesToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(bytesToStringConverterProperty))), ((ValueComparer<int>)(((IProperty)castingConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(castingConverterProperty)), ((ValueComparer<char>)(((IProperty)@char).GetValueComparer())).Snapshot(source.GetCurrentValue<char>(@char)), (((IEnumerable<char>)(source.GetCurrentValue<char[]>(charArray))) == null ? null : ((char[])(((ValueComparer<IEnumerable<char>>)(((IProperty)charArray).GetValueComparer())).Snapshot(((IEnumerable<char>)(source.GetCurrentValue<char[]>(charArray))))))), (((object)(source.GetCurrentValue<char[][]>(charNestedCollection))) == null ? null : ((char[][])(((ValueComparer<object>)(((IProperty)charNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<char[][]>(charNestedCollection))))))), ((ValueComparer<char>)(((IProperty)charToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<char>(charToStringConverterProperty)), ((ValueComparer<DateOnly>)(((IProperty)dateOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<DateOnly>(dateOnly)), (((IEnumerable<DateOnly>)(source.GetCurrentValue<DateOnly[]>(dateOnlyArray))) == null ? null : ((DateOnly[])(((ValueComparer<IEnumerable<DateOnly>>)(((IProperty)dateOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<DateOnly>)(source.GetCurrentValue<DateOnly[]>(dateOnlyArray))))))), ((ValueComparer<DateOnly>)(((IProperty)dateOnlyToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateOnly>(dateOnlyToStringConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTime).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTime)), (((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(dateTimeArray))) == null ? null : ((DateTime[])(((ValueComparer<IEnumerable<DateTime>>)(((IProperty)dateTimeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(dateTimeArray))))))), ((ValueComparer<DateTimeOffset>)(((IProperty)dateTimeOffsetToBinaryConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBinaryConverterProperty)), ((ValueComparer<DateTimeOffset>)(((IProperty)dateTimeOffsetToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToBytesConverterProperty)), ((ValueComparer<DateTimeOffset>)(((IProperty)dateTimeOffsetToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTimeOffset>(dateTimeOffsetToStringConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTimeToBinaryConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTimeToBinaryConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTimeToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTimeToStringConverterProperty)), ((ValueComparer<DateTime>)(((IProperty)dateTimeToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime>(dateTimeToTicksConverterProperty)), ((ValueComparer<decimal>)(((IProperty)@decimal).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal>(@decimal)), (((IEnumerable<decimal>)(source.GetCurrentValue<decimal[]>(decimalArray))) == null ? null : ((decimal[])(((ValueComparer<IEnumerable<decimal>>)(((IProperty)decimalArray).GetValueComparer())).Snapshot(((IEnumerable<decimal>)(source.GetCurrentValue<decimal[]>(decimalArray))))))))));
+                    var entity0 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg0 = ((ISnapshot)(new Snapshot<decimal, decimal, double, double[], double, double, CompiledModelTestBase.Enum16, CompiledModelTestBase.Enum16[], CompiledModelTestBase.Enum16, CompiledModelTestBase.Enum16[], List<CompiledModelTestBase.Enum16>, List<CompiledModelTestBase.Enum16>, CompiledModelTestBase.Enum32, CompiledModelTestBase.Enum32[], CompiledModelTestBase.Enum32, CompiledModelTestBase.Enum32[], List<CompiledModelTestBase.Enum32>, List<CompiledModelTestBase.Enum32>, List<CompiledModelTestBase.Enum32>[][], CompiledModelTestBase.Enum64, CompiledModelTestBase.Enum64[], CompiledModelTestBase.Enum64, CompiledModelTestBase.Enum64[], List<CompiledModelTestBase.Enum64>, List<CompiledModelTestBase.Enum64>, CompiledModelTestBase.Enum8, CompiledModelTestBase.Enum8[], CompiledModelTestBase.Enum8, CompiledModelTestBase.Enum8[], List<CompiledModelTestBase.Enum8>>(((ValueComparer<decimal>)(((IProperty)decimalNumberToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal>(decimalNumberToBytesConverterProperty)), ((ValueComparer<decimal>)(((IProperty)decimalNumberToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal>(decimalNumberToStringConverterProperty)), ((ValueComparer<double>)(((IProperty)@double).GetValueComparer())).Snapshot(source.GetCurrentValue<double>(@double)), (((IEnumerable<double>)(source.GetCurrentValue<double[]>(doubleArray))) == null ? null : ((double[])(((ValueComparer<IEnumerable<double>>)(((IProperty)doubleArray).GetValueComparer())).Snapshot(((IEnumerable<double>)(source.GetCurrentValue<double[]>(doubleArray))))))), ((ValueComparer<double>)(((IProperty)doubleNumberToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<double>(doubleNumberToBytesConverterProperty)), ((ValueComparer<double>)(((IProperty)doubleNumberToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<double>(doubleNumberToStringConverterProperty)), ((ValueComparer<CompiledModelTestBase.Enum16>)(((IProperty)enum16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16)), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16Array))) == null ? null : ((CompiledModelTestBase.Enum16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16Array))))))), ((ValueComparer<CompiledModelTestBase.Enum16>)(((IProperty)enum16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16>(enum16AsString)), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<CompiledModelTestBase.Enum16[]>(enum16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16Collection))) == null ? null : ((List<CompiledModelTestBase.Enum16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16>>)(((IProperty)enum16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16>>(enum16Collection))))))), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enum32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32)), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32Array))) == null ? null : ((CompiledModelTestBase.Enum32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32Array))))))), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enum32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enum32AsString)), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<CompiledModelTestBase.Enum32[]>(enum32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32Collection))) == null ? null : ((List<CompiledModelTestBase.Enum32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32>>)(((IProperty)enum32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>>(enum32Collection))))))), (((object)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>[][]>(enum32NestedCollection))) == null ? null : ((List<CompiledModelTestBase.Enum32>[][])(((ValueComparer<object>)(((IProperty)enum32NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32>[][]>(enum32NestedCollection))))))), ((ValueComparer<CompiledModelTestBase.Enum64>)(((IProperty)enum64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64)), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64Array))) == null ? null : ((CompiledModelTestBase.Enum64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64Array))))))), ((ValueComparer<CompiledModelTestBase.Enum64>)(((IProperty)enum64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64>(enum64AsString)), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<CompiledModelTestBase.Enum64[]>(enum64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64Collection))) == null ? null : ((List<CompiledModelTestBase.Enum64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64>>)(((IProperty)enum64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64>>(enum64Collection))))))), ((ValueComparer<CompiledModelTestBase.Enum8>)(((IProperty)enum8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8)), (((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8Array))) == null ? null : ((CompiledModelTestBase.Enum8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8Array))))))), ((ValueComparer<CompiledModelTestBase.Enum8>)(((IProperty)enum8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8>(enum8AsString)), (((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<CompiledModelTestBase.Enum8[]>(enum8AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8AsStringCollection))))))))));
+                    var entity1 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg1 = ((ISnapshot)(new Snapshot<List<CompiledModelTestBase.Enum8>, CompiledModelTestBase.Enum8[][], CompiledModelTestBase.Enum32, CompiledModelTestBase.Enum32, CompiledModelTestBase.EnumU16, CompiledModelTestBase.EnumU16[], CompiledModelTestBase.EnumU16, CompiledModelTestBase.EnumU16[], List<CompiledModelTestBase.EnumU16>, List<CompiledModelTestBase.EnumU16>, CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32[], CompiledModelTestBase.EnumU32, CompiledModelTestBase.EnumU32[], List<CompiledModelTestBase.EnumU32>, List<CompiledModelTestBase.EnumU32>, CompiledModelTestBase.EnumU64, CompiledModelTestBase.EnumU64[], CompiledModelTestBase.EnumU64, CompiledModelTestBase.EnumU64[], List<CompiledModelTestBase.EnumU64>, List<CompiledModelTestBase.EnumU64>, CompiledModelTestBase.EnumU64[][], CompiledModelTestBase.EnumU8, CompiledModelTestBase.EnumU8[], CompiledModelTestBase.EnumU8, CompiledModelTestBase.EnumU8[], List<CompiledModelTestBase.EnumU8>, List<CompiledModelTestBase.EnumU8>, float>((((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8Collection))) == null ? null : ((List<CompiledModelTestBase.Enum8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8>>)(((IProperty)enum8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8>>(enum8Collection))))))), (((object)(source.GetCurrentValue<CompiledModelTestBase.Enum8[][]>(enum8NestedCollection))) == null ? null : ((CompiledModelTestBase.Enum8[][])(((ValueComparer<object>)(((IProperty)enum8NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<CompiledModelTestBase.Enum8[][]>(enum8NestedCollection))))))), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enumToNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToNumberConverterProperty)), ((ValueComparer<CompiledModelTestBase.Enum32>)(((IProperty)enumToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32>(enumToStringConverterProperty)), ((ValueComparer<CompiledModelTestBase.EnumU16>)(((IProperty)enumU16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16)), (((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16Array))) == null ? null : ((CompiledModelTestBase.EnumU16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU16>)(((IProperty)enumU16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16>(enumU16AsString)), (((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU16[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16[]>(enumU16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU16>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16>>)(((IProperty)enumU16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16>>(enumU16Collection))))))), ((ValueComparer<CompiledModelTestBase.EnumU32>)(((IProperty)enumU32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32)), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32Array))) == null ? null : ((CompiledModelTestBase.EnumU32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU32>)(((IProperty)enumU32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32>(enumU32AsString)), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU32[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32[]>(enumU32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU32>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32>>)(((IProperty)enumU32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32>>(enumU32Collection))))))), ((ValueComparer<CompiledModelTestBase.EnumU64>)(((IProperty)enumU64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64)), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64Array))) == null ? null : ((CompiledModelTestBase.EnumU64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU64>)(((IProperty)enumU64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64>(enumU64AsString)), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU64[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[]>(enumU64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU64>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64>>)(((IProperty)enumU64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64>>(enumU64Collection))))))), (((object)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[][]>(enumU64NestedCollection))) == null ? null : ((CompiledModelTestBase.EnumU64[][])(((ValueComparer<object>)(((IProperty)enumU64NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<CompiledModelTestBase.EnumU64[][]>(enumU64NestedCollection))))))), ((ValueComparer<CompiledModelTestBase.EnumU8>)(((IProperty)enumU8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8)), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8Array))) == null ? null : ((CompiledModelTestBase.EnumU8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8Array))))))), ((ValueComparer<CompiledModelTestBase.EnumU8>)(((IProperty)enumU8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8>(enumU8AsString)), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU8[])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8[]>(enumU8AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU8>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8>>)(((IProperty)enumU8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8>>(enumU8Collection))))))), ((ValueComparer<float>)(((IProperty)@float).GetValueComparer())).Snapshot(source.GetCurrentValue<float>(@float)))));
+                    var entity2 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg2 = ((ISnapshot)(new Snapshot<float[], Guid, Guid[], ICollection<Guid[][]>, Guid, Guid, IPAddress, IPAddress[], IReadOnlyCollection<IPAddress>, IPAddress, IPAddress, short, short[], int, int[], int[][], IReadOnlyCollection<int>, long, long[], IList<long[]>[], sbyte, sbyte[], sbyte[][][], int, int, int?, bool?, bool? [], byte[], byte[][]>((((IEnumerable<float>)(source.GetCurrentValue<float[]>(floatArray))) == null ? null : ((float[])(((ValueComparer<IEnumerable<float>>)(((IProperty)floatArray).GetValueComparer())).Snapshot(((IEnumerable<float>)(source.GetCurrentValue<float[]>(floatArray))))))), ((ValueComparer<Guid>)(((IProperty)guid).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(guid)), (((IEnumerable<Guid>)(source.GetCurrentValue<Guid[]>(guidArray))) == null ? null : ((Guid[])(((ValueComparer<IEnumerable<Guid>>)(((IProperty)guidArray).GetValueComparer())).Snapshot(((IEnumerable<Guid>)(source.GetCurrentValue<Guid[]>(guidArray))))))), (((object)(source.GetCurrentValue<ICollection<Guid[][]>>(guidNestedCollection))) == null ? null : ((ICollection<Guid[][]>)(((ValueComparer<object>)(((IProperty)guidNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<ICollection<Guid[][]>>(guidNestedCollection))))))), ((ValueComparer<Guid>)(((IProperty)guidToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(guidToBytesConverterProperty)), ((ValueComparer<Guid>)(((IProperty)guidToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(guidToStringConverterProperty)), (source.GetCurrentValue<IPAddress>(iPAddress) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)iPAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(iPAddress))), (((object)(source.GetCurrentValue<IPAddress[]>(iPAddressArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)iPAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(iPAddressArray))))))), (((object)(source.GetCurrentValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<IPAddress>)(((ValueComparer<object>)(((IProperty)iPAddressReadOnlyCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IReadOnlyCollection<IPAddress>>(iPAddressReadOnlyCollection))))))), (source.GetCurrentValue<IPAddress>(iPAddressToBytesConverterProperty) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)iPAddressToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(iPAddressToBytesConverterProperty))), (source.GetCurrentValue<IPAddress>(iPAddressToStringConverterProperty) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)iPAddressToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(iPAddressToStringConverterProperty))), ((ValueComparer<short>)(((IProperty)int16).GetValueComparer())).Snapshot(source.GetCurrentValue<short>(int16)), (((IEnumerable<short>)(source.GetCurrentValue<short[]>(int16Array))) == null ? null : ((short[])(((ValueComparer<IEnumerable<short>>)(((IProperty)int16Array).GetValueComparer())).Snapshot(((IEnumerable<short>)(source.GetCurrentValue<short[]>(int16Array))))))), ((ValueComparer<int>)(((IProperty)int32).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(int32)), (((IEnumerable<int>)(source.GetCurrentValue<int[]>(int32Array))) == null ? null : ((int[])(((ValueComparer<IEnumerable<int>>)(((IProperty)int32Array).GetValueComparer())).Snapshot(((IEnumerable<int>)(source.GetCurrentValue<int[]>(int32Array))))))), (((object)(source.GetCurrentValue<int[][]>(int32NestedCollection))) == null ? null : ((int[][])(((ValueComparer<object>)(((IProperty)int32NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<int[][]>(int32NestedCollection))))))), (((IEnumerable<int>)(source.GetCurrentValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<int>)(((ValueComparer<IEnumerable<int>>)(((IProperty)int32ReadOnlyCollection).GetValueComparer())).Snapshot(((IEnumerable<int>)(source.GetCurrentValue<IReadOnlyCollection<int>>(int32ReadOnlyCollection))))))), ((ValueComparer<long>)(((IProperty)int64).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(int64)), (((IEnumerable<long>)(source.GetCurrentValue<long[]>(int64Array))) == null ? null : ((long[])(((ValueComparer<IEnumerable<long>>)(((IProperty)int64Array).GetValueComparer())).Snapshot(((IEnumerable<long>)(source.GetCurrentValue<long[]>(int64Array))))))), (((object)(source.GetCurrentValue<IList<long[]>[]>(int64NestedCollection))) == null ? null : ((IList<long[]>[])(((ValueComparer<object>)(((IProperty)int64NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IList<long[]>[]>(int64NestedCollection))))))), ((ValueComparer<sbyte>)(((IProperty)int8).GetValueComparer())).Snapshot(source.GetCurrentValue<sbyte>(int8)), (((IEnumerable<sbyte>)(source.GetCurrentValue<sbyte[]>(int8Array))) == null ? null : ((sbyte[])(((ValueComparer<IEnumerable<sbyte>>)(((IProperty)int8Array).GetValueComparer())).Snapshot(((IEnumerable<sbyte>)(source.GetCurrentValue<sbyte[]>(int8Array))))))), (((object)(source.GetCurrentValue<sbyte[][][]>(int8NestedCollection))) == null ? null : ((sbyte[][][])(((ValueComparer<object>)(((IProperty)int8NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<sbyte[][][]>(int8NestedCollection))))))), ((ValueComparer<int>)(((IProperty)intNumberToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(intNumberToBytesConverterProperty)), ((ValueComparer<int>)(((IProperty)intNumberToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(intNumberToStringConverterProperty)), (source.GetCurrentValue<int?>(nullIntToNullStringConverterProperty) == null ? null : ((ValueComparer<int?>)(((IProperty)nullIntToNullStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<int?>(nullIntToNullStringConverterProperty))), (source.GetCurrentValue<bool?>(nullableBool) == null ? null : ((ValueComparer<bool?>)(((IProperty)nullableBool).GetValueComparer())).Snapshot(source.GetCurrentValue<bool?>(nullableBool))), (((IEnumerable<bool?>)(source.GetCurrentValue<bool? []>(nullableBoolArray))) == null ? null : ((bool? [])(((ValueComparer<IEnumerable<bool?>>)(((IProperty)nullableBoolArray).GetValueComparer())).Snapshot(((IEnumerable<bool?>)(source.GetCurrentValue<bool? []>(nullableBoolArray))))))), (source.GetCurrentValue<byte[]>(nullableBytes) == null ? null : ((ValueComparer<byte[]>)(((IProperty)nullableBytes).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(nullableBytes))), (((object)(source.GetCurrentValue<byte[][]>(nullableBytesArray))) == null ? null : ((byte[][])(((ValueComparer<object>)(((IProperty)nullableBytesArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<byte[][]>(nullableBytesArray))))))))));
+                    var entity3 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg3 = ((ISnapshot)(new Snapshot<byte[][][], char?, char? [], DateOnly?, DateOnly? [], DateTime?, DateTime? [], decimal?, decimal? [], double?, double? [], CompiledModelTestBase.Enum16?, CompiledModelTestBase.Enum16? [], CompiledModelTestBase.Enum16?, CompiledModelTestBase.Enum16? [], List<CompiledModelTestBase.Enum16?>, List<CompiledModelTestBase.Enum16?>, CompiledModelTestBase.Enum32?, CompiledModelTestBase.Enum32? [], CompiledModelTestBase.Enum32?, CompiledModelTestBase.Enum32? [], List<CompiledModelTestBase.Enum32?>, List<CompiledModelTestBase.Enum32?>, CompiledModelTestBase.Enum32? [][][], CompiledModelTestBase.Enum64?, CompiledModelTestBase.Enum64? [], CompiledModelTestBase.Enum64?, CompiledModelTestBase.Enum64? [], List<CompiledModelTestBase.Enum64?>, List<CompiledModelTestBase.Enum64?>>((((object)(source.GetCurrentValue<byte[][][]>(nullableBytesNestedCollection))) == null ? null : ((byte[][][])(((ValueComparer<object>)(((IProperty)nullableBytesNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<byte[][][]>(nullableBytesNestedCollection))))))), (source.GetCurrentValue<char?>(nullableChar) == null ? null : ((ValueComparer<char?>)(((IProperty)nullableChar).GetValueComparer())).Snapshot(source.GetCurrentValue<char?>(nullableChar))), (((IEnumerable<char?>)(source.GetCurrentValue<char? []>(nullableCharArray))) == null ? null : ((char? [])(((ValueComparer<IEnumerable<char?>>)(((IProperty)nullableCharArray).GetValueComparer())).Snapshot(((IEnumerable<char?>)(source.GetCurrentValue<char? []>(nullableCharArray))))))), (source.GetCurrentValue<DateOnly?>(nullableDateOnly) == null ? null : ((ValueComparer<DateOnly?>)(((IProperty)nullableDateOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<DateOnly?>(nullableDateOnly))), (((IEnumerable<DateOnly?>)(source.GetCurrentValue<DateOnly? []>(nullableDateOnlyArray))) == null ? null : ((DateOnly? [])(((ValueComparer<IEnumerable<DateOnly?>>)(((IProperty)nullableDateOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<DateOnly?>)(source.GetCurrentValue<DateOnly? []>(nullableDateOnlyArray))))))), (source.GetCurrentValue<DateTime?>(nullableDateTime) == null ? null : ((ValueComparer<DateTime?>)(((IProperty)nullableDateTime).GetValueComparer())).Snapshot(source.GetCurrentValue<DateTime?>(nullableDateTime))), (((IEnumerable<DateTime?>)(source.GetCurrentValue<DateTime? []>(nullableDateTimeArray))) == null ? null : ((DateTime? [])(((ValueComparer<IEnumerable<DateTime?>>)(((IProperty)nullableDateTimeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime?>)(source.GetCurrentValue<DateTime? []>(nullableDateTimeArray))))))), (source.GetCurrentValue<decimal?>(nullableDecimal) == null ? null : ((ValueComparer<decimal?>)(((IProperty)nullableDecimal).GetValueComparer())).Snapshot(source.GetCurrentValue<decimal?>(nullableDecimal))), (((IEnumerable<decimal?>)(source.GetCurrentValue<decimal? []>(nullableDecimalArray))) == null ? null : ((decimal? [])(((ValueComparer<IEnumerable<decimal?>>)(((IProperty)nullableDecimalArray).GetValueComparer())).Snapshot(((IEnumerable<decimal?>)(source.GetCurrentValue<decimal? []>(nullableDecimalArray))))))), (source.GetCurrentValue<double?>(nullableDouble) == null ? null : ((ValueComparer<double?>)(((IProperty)nullableDouble).GetValueComparer())).Snapshot(source.GetCurrentValue<double?>(nullableDouble))), (((IEnumerable<double?>)(source.GetCurrentValue<double? []>(nullableDoubleArray))) == null ? null : ((double? [])(((ValueComparer<IEnumerable<double?>>)(((IProperty)nullableDoubleArray).GetValueComparer())).Snapshot(((IEnumerable<double?>)(source.GetCurrentValue<double? []>(nullableDoubleArray))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum16?>)(((IProperty)nullableEnum16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array))) == null ? null : ((CompiledModelTestBase.Enum16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum16?>)(((IProperty)nullableEnum16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum16?>(nullableEnum16AsString))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<CompiledModelTestBase.Enum16? []>(nullableEnum16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection))) == null ? null : ((List<CompiledModelTestBase.Enum16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum16?>>)(((IProperty)nullableEnum16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum16?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum16?>>(nullableEnum16Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum32?>)(((IProperty)nullableEnum32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array))) == null ? null : ((CompiledModelTestBase.Enum32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum32?>)(((IProperty)nullableEnum32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum32?>(nullableEnum32AsString))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<CompiledModelTestBase.Enum32? []>(nullableEnum32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection))) == null ? null : ((List<CompiledModelTestBase.Enum32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum32?>>)(((IProperty)nullableEnum32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum32?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum32?>>(nullableEnum32Collection))))))), (((object)(source.GetCurrentValue<CompiledModelTestBase.Enum32? [][][]>(nullableEnum32NestedCollection))) == null ? null : ((CompiledModelTestBase.Enum32? [][][])(((ValueComparer<object>)(((IProperty)nullableEnum32NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<CompiledModelTestBase.Enum32? [][][]>(nullableEnum32NestedCollection))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum64?>)(((IProperty)nullableEnum64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array))) == null ? null : ((CompiledModelTestBase.Enum64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum64?>)(((IProperty)nullableEnum64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum64?>(nullableEnum64AsString))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<CompiledModelTestBase.Enum64? []>(nullableEnum64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection))) == null ? null : ((List<CompiledModelTestBase.Enum64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum64?>>)(((IProperty)nullableEnum64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum64?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum64?>>(nullableEnum64Collection))))))))));
+                    var entity4 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg4 = ((ISnapshot)(new Snapshot<CompiledModelTestBase.Enum8?, CompiledModelTestBase.Enum8? [], CompiledModelTestBase.Enum8?, CompiledModelTestBase.Enum8? [], List<CompiledModelTestBase.Enum8?>, List<CompiledModelTestBase.Enum8?>, CompiledModelTestBase.Enum8? [][], CompiledModelTestBase.EnumU16?, CompiledModelTestBase.EnumU16? [], CompiledModelTestBase.EnumU16?, CompiledModelTestBase.EnumU16? [], List<CompiledModelTestBase.EnumU16?>, List<CompiledModelTestBase.EnumU16?>, CompiledModelTestBase.EnumU32?, CompiledModelTestBase.EnumU32? [], CompiledModelTestBase.EnumU32?, CompiledModelTestBase.EnumU32? [], List<CompiledModelTestBase.EnumU32?>, List<CompiledModelTestBase.EnumU32?>, CompiledModelTestBase.EnumU64?, CompiledModelTestBase.EnumU64? [], CompiledModelTestBase.EnumU64?, CompiledModelTestBase.EnumU64? [], List<CompiledModelTestBase.EnumU64?>, List<CompiledModelTestBase.EnumU64?>, CompiledModelTestBase.EnumU64? [][], CompiledModelTestBase.EnumU8?, CompiledModelTestBase.EnumU8? [], CompiledModelTestBase.EnumU8?, CompiledModelTestBase.EnumU8? []>((source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum8?>)(((IProperty)nullableEnum8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array))) == null ? null : ((CompiledModelTestBase.Enum8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8Array))))))), (source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.Enum8?>)(((IProperty)nullableEnum8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.Enum8?>(nullableEnum8AsString))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray))) == null ? null : ((CompiledModelTestBase.Enum8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<CompiledModelTestBase.Enum8? []>(nullableEnum8AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.Enum8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection))) == null ? null : ((List<CompiledModelTestBase.Enum8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.Enum8?>>)(((IProperty)nullableEnum8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.Enum8?>)(source.GetCurrentValue<List<CompiledModelTestBase.Enum8?>>(nullableEnum8Collection))))))), (((object)(source.GetCurrentValue<CompiledModelTestBase.Enum8? [][]>(nullableEnum8NestedCollection))) == null ? null : ((CompiledModelTestBase.Enum8? [][])(((ValueComparer<object>)(((IProperty)nullableEnum8NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<CompiledModelTestBase.Enum8? [][]>(nullableEnum8NestedCollection))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU16?>)(((IProperty)nullableEnumU16).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array))) == null ? null : ((CompiledModelTestBase.EnumU16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU16?>)(((IProperty)nullableEnumU16AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU16?>(nullableEnumU16AsString))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU16? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU16? []>(nullableEnumU16AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU16?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU16?>>)(((IProperty)nullableEnumU16Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU16?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU16?>>(nullableEnumU16Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU32?>)(((IProperty)nullableEnumU32).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array))) == null ? null : ((CompiledModelTestBase.EnumU32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU32?>)(((IProperty)nullableEnumU32AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU32?>(nullableEnumU32AsString))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU32? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU32? []>(nullableEnumU32AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU32?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU32?>>)(((IProperty)nullableEnumU32Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU32?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU32?>>(nullableEnumU32Collection))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU64?>)(((IProperty)nullableEnumU64).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array))) == null ? null : ((CompiledModelTestBase.EnumU64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU64?>)(((IProperty)nullableEnumU64AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU64?>(nullableEnumU64AsString))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU64? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? []>(nullableEnumU64AsStringArray))))))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU64?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU64?>>)(((IProperty)nullableEnumU64Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU64?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU64?>>(nullableEnumU64Collection))))))), (((object)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? [][]>(nullableEnumU64NestedCollection))) == null ? null : ((CompiledModelTestBase.EnumU64? [][])(((ValueComparer<object>)(((IProperty)nullableEnumU64NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<CompiledModelTestBase.EnumU64? [][]>(nullableEnumU64NestedCollection))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU8?>)(((IProperty)nullableEnumU8).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8))), (((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array))) == null ? null : ((CompiledModelTestBase.EnumU8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8Array).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8Array))))))), (source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString) == null ? null : ((ValueComparer<CompiledModelTestBase.EnumU8?>)(((IProperty)nullableEnumU8AsString).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.EnumU8?>(nullableEnumU8AsString))), (((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray))) == null ? null : ((CompiledModelTestBase.EnumU8? [])(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8AsStringArray).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<CompiledModelTestBase.EnumU8? []>(nullableEnumU8AsStringArray))))))))));
+                    var entity5 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg5 = ((ISnapshot)(new Snapshot<List<CompiledModelTestBase.EnumU8?>, List<CompiledModelTestBase.EnumU8?>, float?, float? [], Guid?, Guid? [], Guid? [][], IPAddress, IPAddress[], short?, short? [], int?, int? [], int? [][], long?, long? [], List<long? [][]>, sbyte?, sbyte? [], PhysicalAddress, PhysicalAddress[], IEnumerable<PhysicalAddress[][]>, string, string[], string[][], TimeOnly?, TimeOnly? [], TimeSpan?, TimeSpan? [], ushort?>((((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection))) == null ? null : ((List<CompiledModelTestBase.EnumU8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8AsStringCollection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8AsStringCollection))))))), (((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection))) == null ? null : ((List<CompiledModelTestBase.EnumU8?>)(((ValueComparer<IEnumerable<CompiledModelTestBase.EnumU8?>>)(((IProperty)nullableEnumU8Collection).GetValueComparer())).Snapshot(((IEnumerable<CompiledModelTestBase.EnumU8?>)(source.GetCurrentValue<List<CompiledModelTestBase.EnumU8?>>(nullableEnumU8Collection))))))), (source.GetCurrentValue<float?>(nullableFloat) == null ? null : ((ValueComparer<float?>)(((IProperty)nullableFloat).GetValueComparer())).Snapshot(source.GetCurrentValue<float?>(nullableFloat))), (((IEnumerable<float?>)(source.GetCurrentValue<float? []>(nullableFloatArray))) == null ? null : ((float? [])(((ValueComparer<IEnumerable<float?>>)(((IProperty)nullableFloatArray).GetValueComparer())).Snapshot(((IEnumerable<float?>)(source.GetCurrentValue<float? []>(nullableFloatArray))))))), (source.GetCurrentValue<Guid?>(nullableGuid) == null ? null : ((ValueComparer<Guid?>)(((IProperty)nullableGuid).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid?>(nullableGuid))), (((IEnumerable<Guid?>)(source.GetCurrentValue<Guid? []>(nullableGuidArray))) == null ? null : ((Guid? [])(((ValueComparer<IEnumerable<Guid?>>)(((IProperty)nullableGuidArray).GetValueComparer())).Snapshot(((IEnumerable<Guid?>)(source.GetCurrentValue<Guid? []>(nullableGuidArray))))))), (((object)(source.GetCurrentValue<Guid? [][]>(nullableGuidNestedCollection))) == null ? null : ((Guid? [][])(((ValueComparer<object>)(((IProperty)nullableGuidNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<Guid? [][]>(nullableGuidNestedCollection))))))), (source.GetCurrentValue<IPAddress>(nullableIPAddress) == null ? null : ((ValueComparer<IPAddress>)(((IProperty)nullableIPAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<IPAddress>(nullableIPAddress))), (((object)(source.GetCurrentValue<IPAddress[]>(nullableIPAddressArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)nullableIPAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(nullableIPAddressArray))))))), (source.GetCurrentValue<short?>(nullableInt16) == null ? null : ((ValueComparer<short?>)(((IProperty)nullableInt16).GetValueComparer())).Snapshot(source.GetCurrentValue<short?>(nullableInt16))), (((IEnumerable<short?>)(source.GetCurrentValue<short? []>(nullableInt16Array))) == null ? null : ((short? [])(((ValueComparer<IEnumerable<short?>>)(((IProperty)nullableInt16Array).GetValueComparer())).Snapshot(((IEnumerable<short?>)(source.GetCurrentValue<short? []>(nullableInt16Array))))))), (source.GetCurrentValue<int?>(nullableInt32) == null ? null : ((ValueComparer<int?>)(((IProperty)nullableInt32).GetValueComparer())).Snapshot(source.GetCurrentValue<int?>(nullableInt32))), (((IEnumerable<int?>)(source.GetCurrentValue<int? []>(nullableInt32Array))) == null ? null : ((int? [])(((ValueComparer<IEnumerable<int?>>)(((IProperty)nullableInt32Array).GetValueComparer())).Snapshot(((IEnumerable<int?>)(source.GetCurrentValue<int? []>(nullableInt32Array))))))), (((object)(source.GetCurrentValue<int? [][]>(nullableInt32NestedCollection))) == null ? null : ((int? [][])(((ValueComparer<object>)(((IProperty)nullableInt32NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<int? [][]>(nullableInt32NestedCollection))))))), (source.GetCurrentValue<long?>(nullableInt64) == null ? null : ((ValueComparer<long?>)(((IProperty)nullableInt64).GetValueComparer())).Snapshot(source.GetCurrentValue<long?>(nullableInt64))), (((IEnumerable<long?>)(source.GetCurrentValue<long? []>(nullableInt64Array))) == null ? null : ((long? [])(((ValueComparer<IEnumerable<long?>>)(((IProperty)nullableInt64Array).GetValueComparer())).Snapshot(((IEnumerable<long?>)(source.GetCurrentValue<long? []>(nullableInt64Array))))))), (((object)(source.GetCurrentValue<List<long? [][]>>(nullableInt64NestedCollection))) == null ? null : ((List<long? [][]>)(((ValueComparer<object>)(((IProperty)nullableInt64NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<List<long? [][]>>(nullableInt64NestedCollection))))))), (source.GetCurrentValue<sbyte?>(nullableInt8) == null ? null : ((ValueComparer<sbyte?>)(((IProperty)nullableInt8).GetValueComparer())).Snapshot(source.GetCurrentValue<sbyte?>(nullableInt8))), (((IEnumerable<sbyte?>)(source.GetCurrentValue<sbyte? []>(nullableInt8Array))) == null ? null : ((sbyte? [])(((ValueComparer<IEnumerable<sbyte?>>)(((IProperty)nullableInt8Array).GetValueComparer())).Snapshot(((IEnumerable<sbyte?>)(source.GetCurrentValue<sbyte? []>(nullableInt8Array))))))), (source.GetCurrentValue<PhysicalAddress>(nullablePhysicalAddress) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)nullablePhysicalAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(nullablePhysicalAddress))), (((object)(source.GetCurrentValue<PhysicalAddress[]>(nullablePhysicalAddressArray))) == null ? null : ((PhysicalAddress[])(((ValueComparer<object>)(((IProperty)nullablePhysicalAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<PhysicalAddress[]>(nullablePhysicalAddressArray))))))), (((object)(source.GetCurrentValue<IEnumerable<PhysicalAddress[][]>>(nullablePhysicalAddressNestedCollection))) == null ? null : ((IEnumerable<PhysicalAddress[][]>)(((ValueComparer<object>)(((IProperty)nullablePhysicalAddressNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IEnumerable<PhysicalAddress[][]>>(nullablePhysicalAddressNestedCollection))))))), (source.GetCurrentValue<string>(nullableString) == null ? null : ((ValueComparer<string>)(((IProperty)nullableString).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(nullableString))), (((object)(source.GetCurrentValue<string[]>(nullableStringArray))) == null ? null : ((string[])(((ValueComparer<object>)(((IProperty)nullableStringArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<string[]>(nullableStringArray))))))), (((object)(source.GetCurrentValue<string[][]>(nullableStringNestedCollection))) == null ? null : ((string[][])(((ValueComparer<object>)(((IProperty)nullableStringNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<string[][]>(nullableStringNestedCollection))))))), (source.GetCurrentValue<TimeOnly?>(nullableTimeOnly) == null ? null : ((ValueComparer<TimeOnly?>)(((IProperty)nullableTimeOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly?>(nullableTimeOnly))), (((IEnumerable<TimeOnly?>)(source.GetCurrentValue<TimeOnly? []>(nullableTimeOnlyArray))) == null ? null : ((TimeOnly? [])(((ValueComparer<IEnumerable<TimeOnly?>>)(((IProperty)nullableTimeOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<TimeOnly?>)(source.GetCurrentValue<TimeOnly? []>(nullableTimeOnlyArray))))))), (source.GetCurrentValue<TimeSpan?>(nullableTimeSpan) == null ? null : ((ValueComparer<TimeSpan?>)(((IProperty)nullableTimeSpan).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan?>(nullableTimeSpan))), (((IEnumerable<TimeSpan?>)(source.GetCurrentValue<TimeSpan? []>(nullableTimeSpanArray))) == null ? null : ((TimeSpan? [])(((ValueComparer<IEnumerable<TimeSpan?>>)(((IProperty)nullableTimeSpanArray).GetValueComparer())).Snapshot(((IEnumerable<TimeSpan?>)(source.GetCurrentValue<TimeSpan? []>(nullableTimeSpanArray))))))), (source.GetCurrentValue<ushort?>(nullableUInt16) == null ? null : ((ValueComparer<ushort?>)(((IProperty)nullableUInt16).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort?>(nullableUInt16))))));
+                    var entity6 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    var liftedArg6 = ((ISnapshot)(new Snapshot<ushort? [], uint?, uint? [], ulong?, ulong? [], byte?, byte? [], byte? [][], Uri, Uri[], PhysicalAddress, PhysicalAddress[], PhysicalAddress, PhysicalAddress, string, string[], string[][], IReadOnlyCollection<string>, string, string, string, string, string, string, string, string, string, string, string, string>((((IEnumerable<ushort?>)(source.GetCurrentValue<ushort? []>(nullableUInt16Array))) == null ? null : ((ushort? [])(((ValueComparer<IEnumerable<ushort?>>)(((IProperty)nullableUInt16Array).GetValueComparer())).Snapshot(((IEnumerable<ushort?>)(source.GetCurrentValue<ushort? []>(nullableUInt16Array))))))), (source.GetCurrentValue<uint?>(nullableUInt32) == null ? null : ((ValueComparer<uint?>)(((IProperty)nullableUInt32).GetValueComparer())).Snapshot(source.GetCurrentValue<uint?>(nullableUInt32))), (((IEnumerable<uint?>)(source.GetCurrentValue<uint? []>(nullableUInt32Array))) == null ? null : ((uint? [])(((ValueComparer<IEnumerable<uint?>>)(((IProperty)nullableUInt32Array).GetValueComparer())).Snapshot(((IEnumerable<uint?>)(source.GetCurrentValue<uint? []>(nullableUInt32Array))))))), (source.GetCurrentValue<ulong?>(nullableUInt64) == null ? null : ((ValueComparer<ulong?>)(((IProperty)nullableUInt64).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong?>(nullableUInt64))), (((IEnumerable<ulong?>)(source.GetCurrentValue<ulong? []>(nullableUInt64Array))) == null ? null : ((ulong? [])(((ValueComparer<IEnumerable<ulong?>>)(((IProperty)nullableUInt64Array).GetValueComparer())).Snapshot(((IEnumerable<ulong?>)(source.GetCurrentValue<ulong? []>(nullableUInt64Array))))))), (source.GetCurrentValue<byte?>(nullableUInt8) == null ? null : ((ValueComparer<byte?>)(((IProperty)nullableUInt8).GetValueComparer())).Snapshot(source.GetCurrentValue<byte?>(nullableUInt8))), (((IEnumerable<byte?>)(source.GetCurrentValue<byte? []>(nullableUInt8Array))) == null ? null : ((byte? [])(((ValueComparer<IEnumerable<byte?>>)(((IProperty)nullableUInt8Array).GetValueComparer())).Snapshot(((IEnumerable<byte?>)(source.GetCurrentValue<byte? []>(nullableUInt8Array))))))), (((object)(source.GetCurrentValue<byte? [][]>(nullableUInt8NestedCollection))) == null ? null : ((byte? [][])(((ValueComparer<object>)(((IProperty)nullableUInt8NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<byte? [][]>(nullableUInt8NestedCollection))))))), (source.GetCurrentValue<Uri>(nullableUri) == null ? null : ((ValueComparer<Uri>)(((IProperty)nullableUri).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(nullableUri))), (((object)(source.GetCurrentValue<Uri[]>(nullableUriArray))) == null ? null : ((Uri[])(((ValueComparer<object>)(((IProperty)nullableUriArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<Uri[]>(nullableUriArray))))))), (source.GetCurrentValue<PhysicalAddress>(physicalAddress) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)physicalAddress).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(physicalAddress))), (((object)(source.GetCurrentValue<PhysicalAddress[]>(physicalAddressArray))) == null ? null : ((PhysicalAddress[])(((ValueComparer<object>)(((IProperty)physicalAddressArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<PhysicalAddress[]>(physicalAddressArray))))))), (source.GetCurrentValue<PhysicalAddress>(physicalAddressToBytesConverterProperty) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)physicalAddressToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(physicalAddressToBytesConverterProperty))), (source.GetCurrentValue<PhysicalAddress>(physicalAddressToStringConverterProperty) == null ? null : ((ValueComparer<PhysicalAddress>)(((IProperty)physicalAddressToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<PhysicalAddress>(physicalAddressToStringConverterProperty))), (source.GetCurrentValue<string>(@string) == null ? null : ((ValueComparer<string>)(((IProperty)@string).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(@string))), (((object)(source.GetCurrentValue<string[]>(stringArray))) == null ? null : ((string[])(((ValueComparer<object>)(((IProperty)stringArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<string[]>(stringArray))))))), (((object)(source.GetCurrentValue<string[][]>(stringNestedCollection))) == null ? null : ((string[][])(((ValueComparer<object>)(((IProperty)stringNestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<string[][]>(stringNestedCollection))))))), (((object)(source.GetCurrentValue<IReadOnlyCollection<string>>(stringReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<string>)(((ValueComparer<object>)(((IProperty)stringReadOnlyCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IReadOnlyCollection<string>>(stringReadOnlyCollection))))))), (source.GetCurrentValue<string>(stringToBoolConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToBoolConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToBoolConverterProperty))), (source.GetCurrentValue<string>(stringToBytesConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToBytesConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToBytesConverterProperty))), (source.GetCurrentValue<string>(stringToCharConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToCharConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToCharConverterProperty))), (source.GetCurrentValue<string>(stringToDateOnlyConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDateOnlyConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDateOnlyConverterProperty))), (source.GetCurrentValue<string>(stringToDateTimeConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDateTimeConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDateTimeConverterProperty))), (source.GetCurrentValue<string>(stringToDateTimeOffsetConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDateTimeOffsetConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDateTimeOffsetConverterProperty))), (source.GetCurrentValue<string>(stringToDecimalNumberConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDecimalNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDecimalNumberConverterProperty))), (source.GetCurrentValue<string>(stringToDoubleNumberConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToDoubleNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToDoubleNumberConverterProperty))), (source.GetCurrentValue<string>(stringToEnumConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToEnumConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToEnumConverterProperty))), (source.GetCurrentValue<string>(stringToGuidConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToGuidConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToGuidConverterProperty))), (source.GetCurrentValue<string>(stringToIntNumberConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToIntNumberConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToIntNumberConverterProperty))), (source.GetCurrentValue<string>(stringToTimeOnlyConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToTimeOnlyConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToTimeOnlyConverterProperty))))));
+                    var entity7 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    return ((ISnapshot)(new MultiSnapshot(new ISnapshot[] { liftedArg, liftedArg0, liftedArg1, liftedArg2, liftedArg3, liftedArg4, liftedArg5, liftedArg6, ((ISnapshot)(new Snapshot<string, string, TimeOnly, TimeOnly[], TimeOnly, TimeOnly, TimeSpan, TimeSpan[], TimeSpan, TimeSpan, ushort, ushort[], uint, uint[], ulong, ulong[], byte, byte[], List<byte[]>, IReadOnlyCollection<byte>, Uri, Uri[], Uri>((source.GetCurrentValue<string>(stringToTimeSpanConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToTimeSpanConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToTimeSpanConverterProperty))), (source.GetCurrentValue<string>(stringToUriConverterProperty) == null ? null : ((ValueComparer<string>)(((IProperty)stringToUriConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(stringToUriConverterProperty))), ((ValueComparer<TimeOnly>)(((IProperty)timeOnly).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnly)), (((IEnumerable<TimeOnly>)(source.GetCurrentValue<TimeOnly[]>(timeOnlyArray))) == null ? null : ((TimeOnly[])(((ValueComparer<IEnumerable<TimeOnly>>)(((IProperty)timeOnlyArray).GetValueComparer())).Snapshot(((IEnumerable<TimeOnly>)(source.GetCurrentValue<TimeOnly[]>(timeOnlyArray))))))), ((ValueComparer<TimeOnly>)(((IProperty)timeOnlyToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnlyToStringConverterProperty)), ((ValueComparer<TimeOnly>)(((IProperty)timeOnlyToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeOnly>(timeOnlyToTicksConverterProperty)), ((ValueComparer<TimeSpan>)(((IProperty)timeSpan).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpan)), (((IEnumerable<TimeSpan>)(source.GetCurrentValue<TimeSpan[]>(timeSpanArray))) == null ? null : ((TimeSpan[])(((ValueComparer<IEnumerable<TimeSpan>>)(((IProperty)timeSpanArray).GetValueComparer())).Snapshot(((IEnumerable<TimeSpan>)(source.GetCurrentValue<TimeSpan[]>(timeSpanArray))))))), ((ValueComparer<TimeSpan>)(((IProperty)timeSpanToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpanToStringConverterProperty)), ((ValueComparer<TimeSpan>)(((IProperty)timeSpanToTicksConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<TimeSpan>(timeSpanToTicksConverterProperty)), ((ValueComparer<ushort>)(((IProperty)uInt16).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(uInt16)), (((IEnumerable<ushort>)(source.GetCurrentValue<ushort[]>(uInt16Array))) == null ? null : ((ushort[])(((ValueComparer<IEnumerable<ushort>>)(((IProperty)uInt16Array).GetValueComparer())).Snapshot(((IEnumerable<ushort>)(source.GetCurrentValue<ushort[]>(uInt16Array))))))), ((ValueComparer<uint>)(((IProperty)uInt32).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(uInt32)), (((IEnumerable<uint>)(source.GetCurrentValue<uint[]>(uInt32Array))) == null ? null : ((uint[])(((ValueComparer<IEnumerable<uint>>)(((IProperty)uInt32Array).GetValueComparer())).Snapshot(((IEnumerable<uint>)(source.GetCurrentValue<uint[]>(uInt32Array))))))), ((ValueComparer<ulong>)(((IProperty)uInt64).GetValueComparer())).Snapshot(source.GetCurrentValue<ulong>(uInt64)), (((IEnumerable<ulong>)(source.GetCurrentValue<ulong[]>(uInt64Array))) == null ? null : ((ulong[])(((ValueComparer<IEnumerable<ulong>>)(((IProperty)uInt64Array).GetValueComparer())).Snapshot(((IEnumerable<ulong>)(source.GetCurrentValue<ulong[]>(uInt64Array))))))), ((ValueComparer<byte>)(((IProperty)uInt8).GetValueComparer())).Snapshot(source.GetCurrentValue<byte>(uInt8)), (source.GetCurrentValue<byte[]>(uInt8Array) == null ? null : ((ValueComparer<byte[]>)(((IProperty)uInt8Array).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(uInt8Array))), (((object)(source.GetCurrentValue<List<byte[]>>(uInt8NestedCollection))) == null ? null : ((List<byte[]>)(((ValueComparer<object>)(((IProperty)uInt8NestedCollection).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<List<byte[]>>(uInt8NestedCollection))))))), (((IEnumerable<byte>)(source.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection))) == null ? null : ((IReadOnlyCollection<byte>)(((ValueComparer<IEnumerable<byte>>)(((IProperty)uInt8ReadOnlyCollection).GetValueComparer())).Snapshot(((IEnumerable<byte>)(source.GetCurrentValue<IReadOnlyCollection<byte>>(uInt8ReadOnlyCollection))))))), (source.GetCurrentValue<Uri>(uri) == null ? null : ((ValueComparer<Uri>)(((IProperty)uri).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(uri))), (((object)(source.GetCurrentValue<Uri[]>(uriArray))) == null ? null : ((Uri[])(((ValueComparer<object>)(((IProperty)uriArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<Uri[]>(uriArray))))))), (source.GetCurrentValue<Uri>(uriToStringConverterProperty) == null ? null : ((ValueComparer<Uri>)(((IProperty)uriToStringConverterProperty).GetValueComparer())).Snapshot(source.GetCurrentValue<Uri>(uriToStringConverterProperty)))))) })));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId>(((ValueComparer<CompiledModelTestBase.ManyTypesId>)(((IProperty)id).GetValueComparer())).Snapshot(default(CompiledModelTestBase.ManyTypesId))))));
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId>(default(CompiledModelTestBase.ManyTypesId)))));
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => Snapshot.Empty);
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.ManyTypes)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<CompiledModelTestBase.ManyTypesId>(((ValueComparer<CompiledModelTestBase.ManyTypesId>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.ManyTypesId>(id)))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 263,
+                navigationCount: 0,
+                complexPropertyCount: 0,
+                originalValueCount: 263,
+                shadowCount: 0,
+                relationshipCount: 1,
+                storeGeneratedCount: 1);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesUnsafeAccessors.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesUnsafeAccessors.cs
new file mode 100644
index 0000000000..76f983784d
--- /dev/null
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesUnsafeAccessors.cs
@@ -0,0 +1,805 @@
+// <auto-generated />
+using System;
+using System.Collections.Generic;
+using System.Net;
+using System.Net.NetworkInformation;
+using System.Runtime.CompilerServices;
+using Microsoft.EntityFrameworkCore.Scaffolding;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    public static class ManyTypesUnsafeAccessors
+    {
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
+        public static extern ref CompiledModelTestBase.ManyTypesId Id(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Bool>k__BackingField")]
+        public static extern ref bool Bool(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BoolArray>k__BackingField")]
+        public static extern ref bool[] BoolArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BoolNestedCollection>k__BackingField")]
+        public static extern ref bool[][] BoolNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_boolReadOnlyCollection")]
+        public static extern ref List<bool> _boolReadOnlyCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BoolToStringConverterProperty>k__BackingField")]
+        public static extern ref bool BoolToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BoolToTwoValuesConverterProperty>k__BackingField")]
+        public static extern ref bool BoolToTwoValuesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BoolToZeroOneConverterProperty>k__BackingField")]
+        public static extern ref bool BoolToZeroOneConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Bytes>k__BackingField")]
+        public static extern ref byte[] Bytes(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BytesArray>k__BackingField")]
+        public static extern ref byte[][] BytesArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BytesNestedCollection>k__BackingField")]
+        public static extern ref byte[][][] BytesNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<BytesToStringConverterProperty>k__BackingField")]
+        public static extern ref byte[] BytesToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<CastingConverterProperty>k__BackingField")]
+        public static extern ref int CastingConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Char>k__BackingField")]
+        public static extern ref char Char(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<CharArray>k__BackingField")]
+        public static extern ref char[] CharArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<CharNestedCollection>k__BackingField")]
+        public static extern ref char[][] CharNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<CharToStringConverterProperty>k__BackingField")]
+        public static extern ref char CharToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateOnly>k__BackingField")]
+        public static extern ref DateOnly DateOnly(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateOnlyArray>k__BackingField")]
+        public static extern ref DateOnly[] DateOnlyArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateOnlyToStringConverterProperty>k__BackingField")]
+        public static extern ref DateOnly DateOnlyToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTime>k__BackingField")]
+        public static extern ref DateTime DateTime(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTimeArray>k__BackingField")]
+        public static extern ref DateTime[] DateTimeArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTimeOffsetToBinaryConverterProperty>k__BackingField")]
+        public static extern ref DateTimeOffset DateTimeOffsetToBinaryConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTimeOffsetToBytesConverterProperty>k__BackingField")]
+        public static extern ref DateTimeOffset DateTimeOffsetToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTimeOffsetToStringConverterProperty>k__BackingField")]
+        public static extern ref DateTimeOffset DateTimeOffsetToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTimeToBinaryConverterProperty>k__BackingField")]
+        public static extern ref DateTime DateTimeToBinaryConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTimeToStringConverterProperty>k__BackingField")]
+        public static extern ref DateTime DateTimeToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DateTimeToTicksConverterProperty>k__BackingField")]
+        public static extern ref DateTime DateTimeToTicksConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Decimal>k__BackingField")]
+        public static extern ref decimal Decimal(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DecimalArray>k__BackingField")]
+        public static extern ref decimal[] DecimalArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DecimalNumberToBytesConverterProperty>k__BackingField")]
+        public static extern ref decimal DecimalNumberToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DecimalNumberToStringConverterProperty>k__BackingField")]
+        public static extern ref decimal DecimalNumberToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Double>k__BackingField")]
+        public static extern ref double Double(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DoubleArray>k__BackingField")]
+        public static extern ref double[] DoubleArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DoubleNumberToBytesConverterProperty>k__BackingField")]
+        public static extern ref double DoubleNumberToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<DoubleNumberToStringConverterProperty>k__BackingField")]
+        public static extern ref double DoubleNumberToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum16>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16 Enum16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum16Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16[] Enum16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum16AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16 Enum16AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum16AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16[] Enum16AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum16AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum16> Enum16AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum16Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum16> Enum16Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum32>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32 Enum32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum32Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32[] Enum32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum32AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32 Enum32AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum32AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32[] Enum32AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum32AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum32> Enum32AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum32Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum32> Enum32Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum32NestedCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum32>[][] Enum32NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum64>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64 Enum64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum64Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64[] Enum64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum64AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64 Enum64AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum64AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64[] Enum64AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum64AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum64> Enum64AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum64Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum64> Enum64Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum8>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8 Enum8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum8Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8[] Enum8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum8AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8 Enum8AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum8AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8[] Enum8AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum8AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum8> Enum8AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum8Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum8> Enum8Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum8NestedCollection>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8[][] Enum8NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumToNumberConverterProperty>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32 EnumToNumberConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumToStringConverterProperty>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32 EnumToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU16>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16 EnumU16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU16Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16[] EnumU16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU16AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16 EnumU16AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU16AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16[] EnumU16AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU16AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU16> EnumU16AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU16Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU16> EnumU16Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU32>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32 EnumU32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU32Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32[] EnumU32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU32AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32 EnumU32AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU32AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32[] EnumU32AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU32AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU32> EnumU32AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU32Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU32> EnumU32Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU64>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64 EnumU64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU64Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64[] EnumU64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU64AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64 EnumU64AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU64AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64[] EnumU64AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU64AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU64> EnumU64AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU64Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU64> EnumU64Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU64NestedCollection>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64[][] EnumU64NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU8>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8 EnumU8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU8Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8[] EnumU8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU8AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8 EnumU8AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU8AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8[] EnumU8AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU8AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU8> EnumU8AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EnumU8Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU8> EnumU8Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Float>k__BackingField")]
+        public static extern ref float Float(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<FloatArray>k__BackingField")]
+        public static extern ref float[] FloatArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Guid>k__BackingField")]
+        public static extern ref Guid Guid(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<GuidArray>k__BackingField")]
+        public static extern ref Guid[] GuidArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<GuidNestedCollection>k__BackingField")]
+        public static extern ref ICollection<Guid[][]> GuidNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<GuidToBytesConverterProperty>k__BackingField")]
+        public static extern ref Guid GuidToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<GuidToStringConverterProperty>k__BackingField")]
+        public static extern ref Guid GuidToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<IPAddress>k__BackingField")]
+        public static extern ref IPAddress IPAddress(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<IPAddressArray>k__BackingField")]
+        public static extern ref IPAddress[] IPAddressArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_ipAddressReadOnlyCollection")]
+        public static extern ref List<IPAddress> _ipAddressReadOnlyCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<IPAddressToBytesConverterProperty>k__BackingField")]
+        public static extern ref IPAddress IPAddressToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<IPAddressToStringConverterProperty>k__BackingField")]
+        public static extern ref IPAddress IPAddressToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int16>k__BackingField")]
+        public static extern ref short Int16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int16Array>k__BackingField")]
+        public static extern ref short[] Int16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int32>k__BackingField")]
+        public static extern ref int Int32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int32Array>k__BackingField")]
+        public static extern ref int[] Int32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int32NestedCollection>k__BackingField")]
+        public static extern ref int[][] Int32NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_int32ReadOnlyCollection")]
+        public static extern ref List<int> _int32ReadOnlyCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int64>k__BackingField")]
+        public static extern ref long Int64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int64Array>k__BackingField")]
+        public static extern ref long[] Int64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int64NestedCollection>k__BackingField")]
+        public static extern ref IList<long[]>[] Int64NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int8>k__BackingField")]
+        public static extern ref sbyte Int8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int8Array>k__BackingField")]
+        public static extern ref sbyte[] Int8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Int8NestedCollection>k__BackingField")]
+        public static extern ref sbyte[][][] Int8NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<IntNumberToBytesConverterProperty>k__BackingField")]
+        public static extern ref int IntNumberToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<IntNumberToStringConverterProperty>k__BackingField")]
+        public static extern ref int IntNumberToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullIntToNullStringConverterProperty>k__BackingField")]
+        public static extern ref int? NullIntToNullStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableBool>k__BackingField")]
+        public static extern ref bool? NullableBool(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableBoolArray>k__BackingField")]
+        public static extern ref bool?[] NullableBoolArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableBytes>k__BackingField")]
+        public static extern ref byte[] NullableBytes(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableBytesArray>k__BackingField")]
+        public static extern ref byte[][] NullableBytesArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableBytesNestedCollection>k__BackingField")]
+        public static extern ref byte[][][] NullableBytesNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableChar>k__BackingField")]
+        public static extern ref char? NullableChar(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableCharArray>k__BackingField")]
+        public static extern ref char?[] NullableCharArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDateOnly>k__BackingField")]
+        public static extern ref DateOnly? NullableDateOnly(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDateOnlyArray>k__BackingField")]
+        public static extern ref DateOnly?[] NullableDateOnlyArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDateTime>k__BackingField")]
+        public static extern ref DateTime? NullableDateTime(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDateTimeArray>k__BackingField")]
+        public static extern ref DateTime?[] NullableDateTimeArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDecimal>k__BackingField")]
+        public static extern ref decimal? NullableDecimal(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDecimalArray>k__BackingField")]
+        public static extern ref decimal?[] NullableDecimalArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDouble>k__BackingField")]
+        public static extern ref double? NullableDouble(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableDoubleArray>k__BackingField")]
+        public static extern ref double?[] NullableDoubleArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum16>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16? NullableEnum16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum16Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16?[] NullableEnum16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum16AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16? NullableEnum16AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum16AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum16?[] NullableEnum16AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum16AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum16?> NullableEnum16AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum16Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum16?> NullableEnum16Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum32>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32? NullableEnum32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum32Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32?[] NullableEnum32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum32AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32? NullableEnum32AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum32AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32?[] NullableEnum32AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum32AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum32?> NullableEnum32AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum32Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum32?> NullableEnum32Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum32NestedCollection>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum32?[][][] NullableEnum32NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum64>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64? NullableEnum64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum64Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64?[] NullableEnum64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum64AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64? NullableEnum64AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum64AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum64?[] NullableEnum64AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum64AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum64?> NullableEnum64AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum64Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum64?> NullableEnum64Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum8>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8? NullableEnum8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum8Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8?[] NullableEnum8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum8AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8? NullableEnum8AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum8AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8?[] NullableEnum8AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum8AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum8?> NullableEnum8AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum8Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.Enum8?> NullableEnum8Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnum8NestedCollection>k__BackingField")]
+        public static extern ref CompiledModelTestBase.Enum8?[][] NullableEnum8NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU16>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16? NullableEnumU16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU16Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16?[] NullableEnumU16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU16AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16? NullableEnumU16AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU16AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU16?[] NullableEnumU16AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU16AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU16?> NullableEnumU16AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU16Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU16?> NullableEnumU16Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU32>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32? NullableEnumU32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU32Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32?[] NullableEnumU32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU32AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32? NullableEnumU32AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU32AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU32?[] NullableEnumU32AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU32AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU32?> NullableEnumU32AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU32Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU32?> NullableEnumU32Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU64>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64? NullableEnumU64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU64Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64?[] NullableEnumU64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU64AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64? NullableEnumU64AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU64AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64?[] NullableEnumU64AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU64AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU64?> NullableEnumU64AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU64Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU64?> NullableEnumU64Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU64NestedCollection>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU64?[][] NullableEnumU64NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU8>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8? NullableEnumU8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU8Array>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8?[] NullableEnumU8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU8AsString>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8? NullableEnumU8AsString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU8AsStringArray>k__BackingField")]
+        public static extern ref CompiledModelTestBase.EnumU8?[] NullableEnumU8AsStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU8AsStringCollection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU8?> NullableEnumU8AsStringCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableEnumU8Collection>k__BackingField")]
+        public static extern ref List<CompiledModelTestBase.EnumU8?> NullableEnumU8Collection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableFloat>k__BackingField")]
+        public static extern ref float? NullableFloat(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableFloatArray>k__BackingField")]
+        public static extern ref float?[] NullableFloatArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableGuid>k__BackingField")]
+        public static extern ref Guid? NullableGuid(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableGuidArray>k__BackingField")]
+        public static extern ref Guid?[] NullableGuidArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableGuidNestedCollection>k__BackingField")]
+        public static extern ref Guid?[][] NullableGuidNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableIPAddress>k__BackingField")]
+        public static extern ref IPAddress NullableIPAddress(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableIPAddressArray>k__BackingField")]
+        public static extern ref IPAddress[] NullableIPAddressArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt16>k__BackingField")]
+        public static extern ref short? NullableInt16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt16Array>k__BackingField")]
+        public static extern ref short?[] NullableInt16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt32>k__BackingField")]
+        public static extern ref int? NullableInt32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt32Array>k__BackingField")]
+        public static extern ref int?[] NullableInt32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt32NestedCollection>k__BackingField")]
+        public static extern ref int?[][] NullableInt32NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt64>k__BackingField")]
+        public static extern ref long? NullableInt64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt64Array>k__BackingField")]
+        public static extern ref long?[] NullableInt64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt64NestedCollection>k__BackingField")]
+        public static extern ref List<long?[][]> NullableInt64NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt8>k__BackingField")]
+        public static extern ref sbyte? NullableInt8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableInt8Array>k__BackingField")]
+        public static extern ref sbyte?[] NullableInt8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullablePhysicalAddress>k__BackingField")]
+        public static extern ref PhysicalAddress NullablePhysicalAddress(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullablePhysicalAddressArray>k__BackingField")]
+        public static extern ref PhysicalAddress[] NullablePhysicalAddressArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullablePhysicalAddressNestedCollection>k__BackingField")]
+        public static extern ref IEnumerable<PhysicalAddress[][]> NullablePhysicalAddressNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableString>k__BackingField")]
+        public static extern ref string NullableString(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableStringArray>k__BackingField")]
+        public static extern ref string[] NullableStringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableStringNestedCollection>k__BackingField")]
+        public static extern ref string[][] NullableStringNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableTimeOnly>k__BackingField")]
+        public static extern ref TimeOnly? NullableTimeOnly(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableTimeOnlyArray>k__BackingField")]
+        public static extern ref TimeOnly?[] NullableTimeOnlyArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableTimeSpan>k__BackingField")]
+        public static extern ref TimeSpan? NullableTimeSpan(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableTimeSpanArray>k__BackingField")]
+        public static extern ref TimeSpan?[] NullableTimeSpanArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt16>k__BackingField")]
+        public static extern ref ushort? NullableUInt16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt16Array>k__BackingField")]
+        public static extern ref ushort?[] NullableUInt16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt32>k__BackingField")]
+        public static extern ref uint? NullableUInt32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt32Array>k__BackingField")]
+        public static extern ref uint?[] NullableUInt32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt64>k__BackingField")]
+        public static extern ref ulong? NullableUInt64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt64Array>k__BackingField")]
+        public static extern ref ulong?[] NullableUInt64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt8>k__BackingField")]
+        public static extern ref byte? NullableUInt8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt8Array>k__BackingField")]
+        public static extern ref byte?[] NullableUInt8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUInt8NestedCollection>k__BackingField")]
+        public static extern ref byte?[][] NullableUInt8NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUri>k__BackingField")]
+        public static extern ref Uri NullableUri(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NullableUriArray>k__BackingField")]
+        public static extern ref Uri[] NullableUriArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<PhysicalAddress>k__BackingField")]
+        public static extern ref PhysicalAddress PhysicalAddress(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<PhysicalAddressArray>k__BackingField")]
+        public static extern ref PhysicalAddress[] PhysicalAddressArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<PhysicalAddressToBytesConverterProperty>k__BackingField")]
+        public static extern ref PhysicalAddress PhysicalAddressToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<PhysicalAddressToStringConverterProperty>k__BackingField")]
+        public static extern ref PhysicalAddress PhysicalAddressToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<String>k__BackingField")]
+        public static extern ref string String(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringArray>k__BackingField")]
+        public static extern ref string[] StringArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringNestedCollection>k__BackingField")]
+        public static extern ref string[][] StringNestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_stringReadOnlyCollection")]
+        public static extern ref List<string> _stringReadOnlyCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToBoolConverterProperty>k__BackingField")]
+        public static extern ref string StringToBoolConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToBytesConverterProperty>k__BackingField")]
+        public static extern ref string StringToBytesConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToCharConverterProperty>k__BackingField")]
+        public static extern ref string StringToCharConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToDateOnlyConverterProperty>k__BackingField")]
+        public static extern ref string StringToDateOnlyConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToDateTimeConverterProperty>k__BackingField")]
+        public static extern ref string StringToDateTimeConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToDateTimeOffsetConverterProperty>k__BackingField")]
+        public static extern ref string StringToDateTimeOffsetConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToDecimalNumberConverterProperty>k__BackingField")]
+        public static extern ref string StringToDecimalNumberConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToDoubleNumberConverterProperty>k__BackingField")]
+        public static extern ref string StringToDoubleNumberConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToEnumConverterProperty>k__BackingField")]
+        public static extern ref string StringToEnumConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToGuidConverterProperty>k__BackingField")]
+        public static extern ref string StringToGuidConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToIntNumberConverterProperty>k__BackingField")]
+        public static extern ref string StringToIntNumberConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToTimeOnlyConverterProperty>k__BackingField")]
+        public static extern ref string StringToTimeOnlyConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToTimeSpanConverterProperty>k__BackingField")]
+        public static extern ref string StringToTimeSpanConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<StringToUriConverterProperty>k__BackingField")]
+        public static extern ref string StringToUriConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeOnly>k__BackingField")]
+        public static extern ref TimeOnly TimeOnly(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeOnlyArray>k__BackingField")]
+        public static extern ref TimeOnly[] TimeOnlyArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeOnlyToStringConverterProperty>k__BackingField")]
+        public static extern ref TimeOnly TimeOnlyToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeOnlyToTicksConverterProperty>k__BackingField")]
+        public static extern ref TimeOnly TimeOnlyToTicksConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeSpan>k__BackingField")]
+        public static extern ref TimeSpan TimeSpan(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeSpanArray>k__BackingField")]
+        public static extern ref TimeSpan[] TimeSpanArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeSpanToStringConverterProperty>k__BackingField")]
+        public static extern ref TimeSpan TimeSpanToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TimeSpanToTicksConverterProperty>k__BackingField")]
+        public static extern ref TimeSpan TimeSpanToTicksConverterProperty(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt16>k__BackingField")]
+        public static extern ref ushort UInt16(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt16Array>k__BackingField")]
+        public static extern ref ushort[] UInt16Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt32>k__BackingField")]
+        public static extern ref uint UInt32(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt32Array>k__BackingField")]
+        public static extern ref uint[] UInt32Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt64>k__BackingField")]
+        public static extern ref ulong UInt64(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt64Array>k__BackingField")]
+        public static extern ref ulong[] UInt64Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt8>k__BackingField")]
+        public static extern ref byte UInt8(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt8Array>k__BackingField")]
+        public static extern ref byte[] UInt8Array(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UInt8NestedCollection>k__BackingField")]
+        public static extern ref List<byte[]> UInt8NestedCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_uInt8ReadOnlyCollection")]
+        public static extern ref List<byte> _uInt8ReadOnlyCollection(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Uri>k__BackingField")]
+        public static extern ref Uri Uri(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UriArray>k__BackingField")]
+        public static extern ref Uri[] UriArray(CompiledModelTestBase.ManyTypes @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UriToStringConverterProperty>k__BackingField")]
+        public static extern ref Uri UriToStringConverterProperty(CompiledModelTestBase.ManyTypes @this);
+    }
+}
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
index ba5cdffb30..95fb28229f 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
@@ -4,9 +4,16 @@
 using System.Net;
 using System.Reflection;
 using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
+using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding;
+using Microsoft.EntityFrameworkCore.Storage;
+using Microsoft.EntityFrameworkCore.Storage.Json;
+using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -33,12 +40,68 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalDerivedId.SetAccessors(
+                long (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : (entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0))),
+                long (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                long (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalDerivedId, 0),
+                long (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalDerivedId, 0),
+                object (ValueBuffer valueBuffer) => valueBuffer[0]);
+            principalDerivedId.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: 0,
+                shadowIndex: 0,
+                relationshipIndex: 0,
+                storeGenerationIndex: 0);
+            principalDerivedId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
+            principalDerivedId.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(principalDerivedId));
 
             var principalDerivedAlternateId = runtimeEntityType.AddProperty(
                 "PrincipalDerivedAlternateId",
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalDerivedAlternateId.SetAccessors(
+                Guid (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : (entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1))),
+                Guid (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalDerivedAlternateId, 1),
+                Guid (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalDerivedAlternateId, 1),
+                object (ValueBuffer valueBuffer) => valueBuffer[1]);
+            principalDerivedAlternateId.SetPropertyIndexes(
+                index: 1,
+                originalValueIndex: 1,
+                shadowIndex: 1,
+                relationshipIndex: 1,
+                storeGenerationIndex: 1);
+            principalDerivedAlternateId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            principalDerivedAlternateId.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(principalDerivedAlternateId));
 
             var id = runtimeEntityType.AddProperty(
                 "Id",
@@ -46,6 +109,34 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                int (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(2) ? entry.ReadStoreGeneratedValue<int>(2) : (entry.FlaggedAsTemporary(2) && entry.ReadShadowValue<int>(2) == 0 ? entry.ReadTemporaryValue<int>(2) : entry.ReadShadowValue<int>(2))),
+                int (InternalEntityEntry entry) => entry.ReadShadowValue<int>(2),
+                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 2),
+                int (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 2),
+                object (ValueBuffer valueBuffer) => valueBuffer[2]);
+            id.SetPropertyIndexes(
+                index: 2,
+                originalValueIndex: 2,
+                shadowIndex: 2,
+                relationshipIndex: 2,
+                storeGenerationIndex: 2);
+            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                clrType: typeof(int),
+                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);
+            id.SetCurrentValueComparer(new EntryCurrentValueComparer<int>(id));
 
             var details = runtimeEntityType.AddProperty(
                 "Details",
@@ -53,6 +144,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Details", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            details.SetGetter(
+                string (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._details(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._details(entity) == null,
+                string (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._details(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._details(instance) == null);
+            details.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, string value) => OwnedTypeUnsafeAccessors._details(entity) = value);
+            details.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, string value) => OwnedTypeUnsafeAccessors._details(entity) = value);
+            details.SetAccessors(
+                string (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._details(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                string (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._details(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(details, 3),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(details),
+                object (ValueBuffer valueBuffer) => valueBuffer[3]);
+            details.SetPropertyIndexes(
+                index: 3,
+                originalValueIndex: 3,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            details.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                clrType: typeof(string),
+                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
 
             var number = runtimeEntityType.AddProperty(
                 "Number",
@@ -60,6 +187,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: 0);
+            number.SetGetter(
+                int (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.Number(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.Number(entity) == 0,
+                int (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.Number(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.Number(instance) == 0);
+            number.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, int value) => OwnedTypeUnsafeAccessors.Number(entity) = value);
+            number.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, int value) => OwnedTypeUnsafeAccessors.Number(entity) = value);
+            number.SetAccessors(
+                int (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.Number(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                int (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.Number(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(number, 4),
+                int (InternalEntityEntry entry) => entry.GetCurrentValue<int>(number),
+                object (ValueBuffer valueBuffer) => valueBuffer[4]);
+            number.SetPropertyIndexes(
+                index: 4,
+                originalValueIndex: 4,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            number.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                clrType: typeof(int),
+                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);
 
             var refTypeArray = runtimeEntityType.AddProperty(
                 "RefTypeArray",
@@ -67,6 +230,75 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeArray.SetGetter(
+                IPAddress[] (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeArray(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeArray(entity) == null,
+                IPAddress[] (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeArray(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeArray(instance) == null);
+            refTypeArray.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IPAddress[] value) => OwnedTypeUnsafeAccessors._refTypeArray(entity) = value);
+            refTypeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IPAddress[] value) => OwnedTypeUnsafeAccessors._refTypeArray(entity) = value);
+            refTypeArray.SetAccessors(
+                IPAddress[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress[]>(refTypeArray, 5),
+                IPAddress[] (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress[]>(refTypeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[5]);
+            refTypeArray.SetPropertyIndexes(
+                index: 5,
+                originalValueIndex: 5,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -74,6 +306,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeEnumerable.SetGetter(
+                IEnumerable<string> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity) == null,
+                IEnumerable<string> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeEnumerable(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeEnumerable(instance) == null);
+            refTypeEnumerable.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<string> value) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity) = value);
+            refTypeEnumerable.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<string> value) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity) = value);
+            refTypeEnumerable.SetAccessors(
+                IEnumerable<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<string> (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<string>>(refTypeEnumerable, 6),
+                IEnumerable<string> (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable),
+                object (ValueBuffer valueBuffer) => valueBuffer[6]);
+            refTypeEnumerable.SetPropertyIndexes(
+                index: 6,
+                originalValueIndex: 6,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -81,6 +368,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeIList.SetGetter(
+                IList<string> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeIList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeIList(entity) == null,
+                IList<string> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeIList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeIList(instance) == null);
+            refTypeIList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<string> value) => OwnedTypeUnsafeAccessors._refTypeIList(entity) = value);
+            refTypeIList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<string> value) => OwnedTypeUnsafeAccessors._refTypeIList(entity) = value);
+            refTypeIList.SetAccessors(
+                IList<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<string> (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<string>>(refTypeIList, 7),
+                IList<string> (InternalEntityEntry entry) => entry.GetCurrentValue<IList<string>>(refTypeIList),
+                object (ValueBuffer valueBuffer) => valueBuffer[7]);
+            refTypeIList.SetPropertyIndexes(
+                index: 7,
+                originalValueIndex: 7,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -88,6 +430,75 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeList.SetGetter(
+                List<IPAddress> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeList(entity) == null,
+                List<IPAddress> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeList(instance) == null);
+            refTypeList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, List<IPAddress> value) => OwnedTypeUnsafeAccessors._refTypeList(entity) = value);
+            refTypeList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, List<IPAddress> value) => OwnedTypeUnsafeAccessors._refTypeList(entity) = value);
+            refTypeList.SetAccessors(
+                List<IPAddress> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<IPAddress> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<IPAddress> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<IPAddress>>(refTypeList, 8),
+                List<IPAddress> (InternalEntityEntry entry) => entry.GetCurrentValue<List<IPAddress>>(refTypeList),
+                object (ValueBuffer valueBuffer) => valueBuffer[8]);
+            refTypeList.SetPropertyIndexes(
+                index: 8,
+                originalValueIndex: 8,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -95,6 +506,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeArray.SetGetter(
+                DateTime[] (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeArray(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeArray(entity) == null,
+                DateTime[] (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeArray(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeArray(instance) == null);
+            valueTypeArray.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, DateTime[] value) => OwnedTypeUnsafeAccessors._valueTypeArray(entity) = value);
+            valueTypeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, DateTime[] value) => OwnedTypeUnsafeAccessors._valueTypeArray(entity) = value);
+            valueTypeArray.SetAccessors(
+                DateTime[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime[]>(valueTypeArray, 9),
+                DateTime[] (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime[]>(valueTypeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[9]);
+            valueTypeArray.SetPropertyIndexes(
+                index: 9,
+                originalValueIndex: 9,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                keyComparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    keyComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    providerValueComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    clrType: typeof(DateTime),
+                    jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -102,6 +568,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeEnumerable.SetGetter(
+                IEnumerable<byte> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity) == null,
+                IEnumerable<byte> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(instance) == null);
+            valueTypeEnumerable.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<byte> value) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity) = value);
+            valueTypeEnumerable.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<byte> value) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity) = value);
+            valueTypeEnumerable.SetAccessors(
+                IEnumerable<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<byte> (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<byte>>(valueTypeEnumerable, 10),
+                IEnumerable<byte> (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable),
+                object (ValueBuffer valueBuffer) => valueBuffer[10]);
+            valueTypeEnumerable.SetPropertyIndexes(
+                index: 10,
+                originalValueIndex: 10,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -109,6 +630,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeIList.SetGetter(
+                IList<byte> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity) == null,
+                IList<byte> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.ValueTypeIList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.ValueTypeIList(instance) == null);
+            valueTypeIList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<byte> value) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity) = value);
+            valueTypeIList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<byte> value) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity) = value);
+            valueTypeIList.SetAccessors(
+                IList<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.ValueTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.ValueTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<byte> (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<byte>>(valueTypeIList, 11),
+                IList<byte> (InternalEntityEntry entry) => entry.GetCurrentValue<IList<byte>>(valueTypeIList),
+                object (ValueBuffer valueBuffer) => valueBuffer[11]);
+            valueTypeIList.SetPropertyIndexes(
+                index: 11,
+                originalValueIndex: 11,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -116,11 +692,72 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeList.SetGetter(
+                List<short> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeList(entity) == null,
+                List<short> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeList(instance) == null);
+            valueTypeList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, List<short> value) => OwnedTypeUnsafeAccessors._valueTypeList(entity) = value);
+            valueTypeList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, List<short> value) => OwnedTypeUnsafeAccessors._valueTypeList(entity) = value);
+            valueTypeList.SetAccessors(
+                List<short> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<short> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<short> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<short>>(valueTypeList, 12),
+                List<short> (InternalEntityEntry entry) => entry.GetCurrentValue<List<short>>(valueTypeList),
+                object (ValueBuffer valueBuffer) => valueBuffer[12]);
+            valueTypeList.SetPropertyIndexes(
+                index: 12,
+                originalValueIndex: 12,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<short>, short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<short>, short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionOfStructsReaderWriter<List<short>, short>(
+                    JsonInt16ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<short>, short>(
+                    JsonInt16ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    keyComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    providerValueComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    clrType: typeof(short),
+                    jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 serviceType: typeof(DbContext));
+            context.SetPropertyIndexes(
+                index: -1,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
 
             var key = runtimeEntityType.AddKey(
                 new[] { principalDerivedId, principalDerivedAlternateId, id });
@@ -145,11 +782,82 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>).GetField("ManyOwned", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 eagerLoaded: true);
 
+            manyOwned.SetGetter(
+                ICollection<CompiledModelTestBase.OwnedType> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity),
+                bool (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity) == null,
+                ICollection<CompiledModelTestBase.OwnedType> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> instance) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(instance),
+                bool (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> instance) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(instance) == null);
+            manyOwned.SetSetter(
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.OwnedType> value) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity) = value);
+            manyOwned.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.OwnedType> value) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity) = value);
+            manyOwned.SetAccessors(
+                ICollection<CompiledModelTestBase.OwnedType> (InternalEntityEntry entry) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(entry.Entity))),
+                ICollection<CompiledModelTestBase.OwnedType> (InternalEntityEntry entry) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(entry.Entity))),
+                null,
+                ICollection<CompiledModelTestBase.OwnedType> (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<CompiledModelTestBase.OwnedType>>(manyOwned),
+                null);
+            manyOwned.SetPropertyIndexes(
+                index: 3,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: 5,
+                storeGenerationIndex: -1);
+            manyOwned.SetCollectionAccessor<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>, ICollection<CompiledModelTestBase.OwnedType>, CompiledModelTestBase.OwnedType>(
+                ICollection<CompiledModelTestBase.OwnedType> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity),
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.OwnedType> collection) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity) = ((ICollection<CompiledModelTestBase.OwnedType>)(collection)),
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.OwnedType> collection) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity) = ((ICollection<CompiledModelTestBase.OwnedType>)(collection)),
+                ICollection<CompiledModelTestBase.OwnedType> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, Action<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>, ICollection<CompiledModelTestBase.OwnedType>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>, ICollection<CompiledModelTestBase.OwnedType>, CompiledModelTestBase.OwnedType>(entity, setter),
+                ICollection<CompiledModelTestBase.OwnedType> () => ((ICollection<CompiledModelTestBase.OwnedType>)(((ICollection<CompiledModelTestBase.OwnedType>)(new HashSet<CompiledModelTestBase.OwnedType>(ReferenceEqualityComparer.Instance))))));
             return runtimeForeignKey;
         }
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var principalDerivedId = runtimeEntityType.FindProperty("PrincipalDerivedId");
+            var principalDerivedAlternateId = runtimeEntityType.FindProperty("PrincipalDerivedAlternateId");
+            var id = runtimeEntityType.FindProperty("Id");
+            var details = runtimeEntityType.FindProperty("Details");
+            var number = runtimeEntityType.FindProperty("Number");
+            var refTypeArray = runtimeEntityType.FindProperty("RefTypeArray");
+            var refTypeEnumerable = runtimeEntityType.FindProperty("RefTypeEnumerable");
+            var refTypeIList = runtimeEntityType.FindProperty("RefTypeIList");
+            var refTypeList = runtimeEntityType.FindProperty("RefTypeList");
+            var valueTypeArray = runtimeEntityType.FindProperty("ValueTypeArray");
+            var valueTypeEnumerable = runtimeEntityType.FindProperty("ValueTypeEnumerable");
+            var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList");
+            var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList");
+            var key = runtimeEntityType.FindKey(new[] { principalDerivedId, principalDerivedAlternateId, id });
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
+            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.OwnedType)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, int, string, int, IPAddress[], IEnumerable<string>, IList<string>, List<IPAddress>, DateTime[], IEnumerable<byte>, IList<byte>, List<short>>(((ValueComparer<long>)(((IProperty)principalDerivedId).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(principalDerivedId)), ((ValueComparer<Guid>)(((IProperty)principalDerivedAlternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalDerivedAlternateId)), ((ValueComparer<int>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(id)), (source.GetCurrentValue<string>(details) == null ? null : ((ValueComparer<string>)(((IProperty)details).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(details))), ((ValueComparer<int>)(((IProperty)number).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(number)), (((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)refTypeArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))))))), (((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))) == null ? null : ((IEnumerable<string>)(((ValueComparer<object>)(((IProperty)refTypeEnumerable).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))))))), (((object)(source.GetCurrentValue<IList<string>>(refTypeIList))) == null ? null : ((IList<string>)(((ValueComparer<object>)(((IProperty)refTypeIList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IList<string>>(refTypeIList))))))), (((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))) == null ? null : ((List<IPAddress>)(((ValueComparer<object>)(((IProperty)refTypeList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))))))), (((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))) == null ? null : ((DateTime[])(((ValueComparer<IEnumerable<DateTime>>)(((IProperty)valueTypeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))))))), (source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable) == null ? null : ((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeEnumerable).GetValueComparer())).Snapshot(source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable))), (((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))) == null ? null : ((IList<byte>)(((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeIList).GetValueComparer())).Snapshot(((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))))))), (((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))) == null ? null : ((List<short>)(((ValueComparer<IEnumerable<short>>)(((IProperty)valueTypeList).GetValueComparer())).Snapshot(((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))))))))));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid, int>(((ValueComparer<long>)(((IProperty)principalDerivedId).GetValueComparer())).Snapshot(default(long)), ((ValueComparer<Guid>)(((IProperty)principalDerivedAlternateId).GetValueComparer())).Snapshot(default(Guid)), ((ValueComparer<int>)(((IProperty)id).GetValueComparer())).Snapshot(default(int))))));
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<long, Guid, int>(default(long), default(Guid), default(int)))));
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<long, Guid, int>((source.ContainsKey("PrincipalDerivedId") ? ((long)(source["PrincipalDerivedId"])) : 0L), (source.ContainsKey("PrincipalDerivedAlternateId") ? ((Guid)(source["PrincipalDerivedAlternateId"])) : new Guid("00000000-0000-0000-0000-000000000000")), (source.ContainsKey("Id") ? ((int)(source["Id"])) : 0)))));
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid, int>(default(long), default(Guid), default(int)))));
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.OwnedType)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, int>(((ValueComparer<long>)(((IProperty)principalDerivedId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(principalDerivedId)), ((ValueComparer<Guid>)(((IProperty)principalDerivedAlternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalDerivedAlternateId)), ((ValueComparer<int>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<int>(id)))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 13,
+                navigationCount: 0,
+                complexPropertyCount: 0,
+                originalValueCount: 13,
+                shadowCount: 3,
+                relationshipCount: 3,
+                storeGeneratedCount: 3);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
index 1734e6dc9b..889517b87f 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
@@ -4,9 +4,16 @@
 using System.Net;
 using System.Reflection;
 using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
+using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding;
+using Microsoft.EntityFrameworkCore.Storage;
+using Microsoft.EntityFrameworkCore.Storage.Json;
+using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -35,6 +42,34 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalBaseId.SetAccessors(
+                long (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : (entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0))),
+                long (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                long (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalBaseId, 0),
+                long (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalBaseId, 0),
+                object (ValueBuffer valueBuffer) => valueBuffer[0]);
+            principalBaseId.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: 0,
+                shadowIndex: 0,
+                relationshipIndex: 0,
+                storeGenerationIndex: 0);
+            principalBaseId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
+            principalBaseId.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(principalBaseId));
 
             var principalBaseAlternateId = runtimeEntityType.AddProperty(
                 "PrincipalBaseAlternateId",
@@ -42,6 +77,34 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalBaseAlternateId.SetAccessors(
+                Guid (InternalEntityEntry entry) => (entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : (entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1))),
+                Guid (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalBaseAlternateId, 1),
+                Guid (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalBaseAlternateId, 1),
+                object (ValueBuffer valueBuffer) => valueBuffer[1]);
+            principalBaseAlternateId.SetPropertyIndexes(
+                index: 1,
+                originalValueIndex: 1,
+                shadowIndex: 1,
+                relationshipIndex: 1,
+                storeGenerationIndex: 1);
+            principalBaseAlternateId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            principalBaseAlternateId.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(principalBaseAlternateId));
 
             var details = runtimeEntityType.AddProperty(
                 "Details",
@@ -50,6 +113,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_details", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            details.SetGetter(
+                string (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._details(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._details(entity) == null,
+                string (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._details(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._details(instance) == null);
+            details.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, string value) => OwnedTypeUnsafeAccessors._details(entity) = value);
+            details.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, string value) => OwnedTypeUnsafeAccessors._details(entity) = value);
+            details.SetAccessors(
+                string (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._details(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                string (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._details(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(details, 2),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(details),
+                object (ValueBuffer valueBuffer) => valueBuffer[2]);
+            details.SetPropertyIndexes(
+                index: 2,
+                originalValueIndex: 2,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            details.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                clrType: typeof(string),
+                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
 
             var number = runtimeEntityType.AddProperty(
                 "Number",
@@ -58,6 +157,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 sentinel: 0);
+            number.SetGetter(
+                int (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.Number(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.Number(entity) == 0,
+                int (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.Number(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.Number(instance) == 0);
+            number.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, int value) => OwnedTypeUnsafeAccessors.Number(entity) = value);
+            number.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, int value) => OwnedTypeUnsafeAccessors.Number(entity) = value);
+            number.SetAccessors(
+                int (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.Number(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                int (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.Number(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                int (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(number, 3),
+                int (InternalEntityEntry entry) => entry.GetCurrentValue<int>(number),
+                object (ValueBuffer valueBuffer) => valueBuffer[3]);
+            number.SetPropertyIndexes(
+                index: 3,
+                originalValueIndex: 3,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            number.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                keyComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                providerValueComparer: new ValueComparer<int>(
+                    bool (int v1, int v2) => v1 == v2,
+                    int (int v) => v,
+                    int (int v) => v),
+                clrType: typeof(int),
+                jsonValueReaderWriter: JsonInt32ReaderWriter.Instance);
 
             var refTypeArray = runtimeEntityType.AddProperty(
                 "RefTypeArray",
@@ -66,6 +201,75 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            refTypeArray.SetGetter(
+                IPAddress[] (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeArray(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeArray(entity) == null,
+                IPAddress[] (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeArray(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeArray(instance) == null);
+            refTypeArray.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IPAddress[] value) => OwnedTypeUnsafeAccessors._refTypeArray(entity) = value);
+            refTypeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IPAddress[] value) => OwnedTypeUnsafeAccessors._refTypeArray(entity) = value);
+            refTypeArray.SetAccessors(
+                IPAddress[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress[]>(refTypeArray, 4),
+                IPAddress[] (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress[]>(refTypeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[4]);
+            refTypeArray.SetPropertyIndexes(
+                index: 4,
+                originalValueIndex: 4,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -74,6 +278,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            refTypeEnumerable.SetGetter(
+                IEnumerable<string> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity) == null,
+                IEnumerable<string> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeEnumerable(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeEnumerable(instance) == null);
+            refTypeEnumerable.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<string> value) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity) = value);
+            refTypeEnumerable.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<string> value) => OwnedTypeUnsafeAccessors._refTypeEnumerable(entity) = value);
+            refTypeEnumerable.SetAccessors(
+                IEnumerable<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<string> (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<string>>(refTypeEnumerable, 5),
+                IEnumerable<string> (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable),
+                object (ValueBuffer valueBuffer) => valueBuffer[5]);
+            refTypeEnumerable.SetPropertyIndexes(
+                index: 5,
+                originalValueIndex: 5,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -82,6 +341,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            refTypeIList.SetGetter(
+                IList<string> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeIList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeIList(entity) == null,
+                IList<string> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeIList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeIList(instance) == null);
+            refTypeIList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<string> value) => OwnedTypeUnsafeAccessors._refTypeIList(entity) = value);
+            refTypeIList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<string> value) => OwnedTypeUnsafeAccessors._refTypeIList(entity) = value);
+            refTypeIList.SetAccessors(
+                IList<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<string> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<string> (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<string>>(refTypeIList, 6),
+                IList<string> (InternalEntityEntry entry) => entry.GetCurrentValue<IList<string>>(refTypeIList),
+                object (ValueBuffer valueBuffer) => valueBuffer[6]);
+            refTypeIList.SetPropertyIndexes(
+                index: 6,
+                originalValueIndex: 6,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -90,6 +404,75 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            refTypeList.SetGetter(
+                List<IPAddress> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._refTypeList(entity) == null,
+                List<IPAddress> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._refTypeList(instance) == null);
+            refTypeList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, List<IPAddress> value) => OwnedTypeUnsafeAccessors._refTypeList(entity) = value);
+            refTypeList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, List<IPAddress> value) => OwnedTypeUnsafeAccessors._refTypeList(entity) = value);
+            refTypeList.SetAccessors(
+                List<IPAddress> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<IPAddress> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._refTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<IPAddress> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<IPAddress>>(refTypeList, 7),
+                List<IPAddress> (InternalEntityEntry entry) => entry.GetCurrentValue<List<IPAddress>>(refTypeList),
+                object (ValueBuffer valueBuffer) => valueBuffer[7]);
+            refTypeList.SetPropertyIndexes(
+                index: 7,
+                originalValueIndex: 7,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -98,6 +481,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            valueTypeArray.SetGetter(
+                DateTime[] (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeArray(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeArray(entity) == null,
+                DateTime[] (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeArray(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeArray(instance) == null);
+            valueTypeArray.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, DateTime[] value) => OwnedTypeUnsafeAccessors._valueTypeArray(entity) = value);
+            valueTypeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, DateTime[] value) => OwnedTypeUnsafeAccessors._valueTypeArray(entity) = value);
+            valueTypeArray.SetAccessors(
+                DateTime[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeArray(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime[]>(valueTypeArray, 8),
+                DateTime[] (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime[]>(valueTypeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[8]);
+            valueTypeArray.SetPropertyIndexes(
+                index: 8,
+                originalValueIndex: 8,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                keyComparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    keyComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    providerValueComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    clrType: typeof(DateTime),
+                    jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -106,6 +544,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            valueTypeEnumerable.SetGetter(
+                IEnumerable<byte> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity) == null,
+                IEnumerable<byte> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(instance) == null);
+            valueTypeEnumerable.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<byte> value) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity) = value);
+            valueTypeEnumerable.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IEnumerable<byte> value) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(entity) = value);
+            valueTypeEnumerable.SetAccessors(
+                IEnumerable<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeEnumerable(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IEnumerable<byte> (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<byte>>(valueTypeEnumerable, 9),
+                IEnumerable<byte> (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable),
+                object (ValueBuffer valueBuffer) => valueBuffer[9]);
+            valueTypeEnumerable.SetPropertyIndexes(
+                index: 9,
+                originalValueIndex: 9,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -114,6 +607,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            valueTypeIList.SetGetter(
+                IList<byte> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity) == null,
+                IList<byte> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.ValueTypeIList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors.ValueTypeIList(instance) == null);
+            valueTypeIList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<byte> value) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity) = value);
+            valueTypeIList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, IList<byte> value) => OwnedTypeUnsafeAccessors.ValueTypeIList(entity) = value);
+            valueTypeIList.SetAccessors(
+                IList<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.ValueTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<byte> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors.ValueTypeIList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                IList<byte> (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<byte>>(valueTypeIList, 10),
+                IList<byte> (InternalEntityEntry entry) => entry.GetCurrentValue<IList<byte>>(valueTypeIList),
+                object (ValueBuffer valueBuffer) => valueBuffer[10]);
+            valueTypeIList.SetPropertyIndexes(
+                index: 10,
+                originalValueIndex: 10,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -122,11 +670,72 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            valueTypeList.SetGetter(
+                List<short> (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeList(entity),
+                bool (CompiledModelTestBase.OwnedType entity) => OwnedTypeUnsafeAccessors._valueTypeList(entity) == null,
+                List<short> (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeList(instance),
+                bool (CompiledModelTestBase.OwnedType instance) => OwnedTypeUnsafeAccessors._valueTypeList(instance) == null);
+            valueTypeList.SetSetter(
+                (CompiledModelTestBase.OwnedType entity, List<short> value) => OwnedTypeUnsafeAccessors._valueTypeList(entity) = value);
+            valueTypeList.SetMaterializationSetter(
+                (CompiledModelTestBase.OwnedType entity, List<short> value) => OwnedTypeUnsafeAccessors._valueTypeList(entity) = value);
+            valueTypeList.SetAccessors(
+                List<short> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<short> (InternalEntityEntry entry) => OwnedTypeUnsafeAccessors._valueTypeList(((CompiledModelTestBase.OwnedType)(entry.Entity))),
+                List<short> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<short>>(valueTypeList, 11),
+                List<short> (InternalEntityEntry entry) => entry.GetCurrentValue<List<short>>(valueTypeList),
+                object (ValueBuffer valueBuffer) => valueBuffer[11]);
+            valueTypeList.SetPropertyIndexes(
+                index: 11,
+                originalValueIndex: 11,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<short>, short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<short>, short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionOfStructsReaderWriter<List<short>, short>(
+                    JsonInt16ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<short>, short>(
+                    JsonInt16ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    keyComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    providerValueComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    clrType: typeof(short),
+                    jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("Context", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 serviceType: typeof(DbContext));
+            context.SetPropertyIndexes(
+                index: -1,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
 
             var key = runtimeEntityType.AddKey(
                 new[] { principalBaseId, principalBaseAlternateId });
@@ -155,11 +764,75 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 propertyAccessMode: PropertyAccessMode.Field,
                 eagerLoaded: true);
 
+            owned.SetGetter(
+                CompiledModelTestBase.OwnedType (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors._ownedField(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors._ownedField(entity) == null,
+                CompiledModelTestBase.OwnedType (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors._ownedField(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors._ownedField(instance) == null);
+            owned.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.OwnedType value) => PrincipalBaseUnsafeAccessors._ownedField(entity) = value);
+            owned.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.OwnedType value) => PrincipalBaseUnsafeAccessors._ownedField(entity) = value);
+            owned.SetAccessors(
+                CompiledModelTestBase.OwnedType (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors._ownedField(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.OwnedType (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors._ownedField(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                null,
+                CompiledModelTestBase.OwnedType (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.OwnedType>(owned),
+                null);
+            owned.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: 2,
+                storeGenerationIndex: -1);
             return runtimeForeignKey;
         }
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var principalBaseId = runtimeEntityType.FindProperty("PrincipalBaseId");
+            var principalBaseAlternateId = runtimeEntityType.FindProperty("PrincipalBaseAlternateId");
+            var details = runtimeEntityType.FindProperty("Details");
+            var number = runtimeEntityType.FindProperty("Number");
+            var refTypeArray = runtimeEntityType.FindProperty("RefTypeArray");
+            var refTypeEnumerable = runtimeEntityType.FindProperty("RefTypeEnumerable");
+            var refTypeIList = runtimeEntityType.FindProperty("RefTypeIList");
+            var refTypeList = runtimeEntityType.FindProperty("RefTypeList");
+            var valueTypeArray = runtimeEntityType.FindProperty("ValueTypeArray");
+            var valueTypeEnumerable = runtimeEntityType.FindProperty("ValueTypeEnumerable");
+            var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList");
+            var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList");
+            var key = runtimeEntityType.FindKey(new[] { principalBaseId, principalBaseAlternateId });
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
+            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.OwnedType)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, string, int, IPAddress[], IEnumerable<string>, IList<string>, List<IPAddress>, DateTime[], IEnumerable<byte>, IList<byte>, List<short>>(((ValueComparer<long>)(((IProperty)principalBaseId).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(principalBaseId)), ((ValueComparer<Guid>)(((IProperty)principalBaseAlternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalBaseAlternateId)), (source.GetCurrentValue<string>(details) == null ? null : ((ValueComparer<string>)(((IProperty)details).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(details))), ((ValueComparer<int>)(((IProperty)number).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(number)), (((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)refTypeArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))))))), (((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))) == null ? null : ((IEnumerable<string>)(((ValueComparer<object>)(((IProperty)refTypeEnumerable).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))))))), (((object)(source.GetCurrentValue<IList<string>>(refTypeIList))) == null ? null : ((IList<string>)(((ValueComparer<object>)(((IProperty)refTypeIList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IList<string>>(refTypeIList))))))), (((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))) == null ? null : ((List<IPAddress>)(((ValueComparer<object>)(((IProperty)refTypeList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))))))), (((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))) == null ? null : ((DateTime[])(((ValueComparer<IEnumerable<DateTime>>)(((IProperty)valueTypeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))))))), (source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable) == null ? null : ((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeEnumerable).GetValueComparer())).Snapshot(source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable))), (((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))) == null ? null : ((IList<byte>)(((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeIList).GetValueComparer())).Snapshot(((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))))))), (((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))) == null ? null : ((List<short>)(((ValueComparer<IEnumerable<short>>)(((IProperty)valueTypeList).GetValueComparer())).Snapshot(((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))))))))));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid>(((ValueComparer<long>)(((IProperty)principalBaseId).GetValueComparer())).Snapshot(default(long)), ((ValueComparer<Guid>)(((IProperty)principalBaseAlternateId).GetValueComparer())).Snapshot(default(Guid))))));
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<long, Guid>(default(long), default(Guid)))));
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<long, Guid>((source.ContainsKey("PrincipalBaseId") ? ((long)(source["PrincipalBaseId"])) : 0L), (source.ContainsKey("PrincipalBaseAlternateId") ? ((Guid)(source["PrincipalBaseAlternateId"])) : new Guid("00000000-0000-0000-0000-000000000000"))))));
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid>(default(long), default(Guid)))));
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.OwnedType)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid>(((ValueComparer<long>)(((IProperty)principalBaseId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(principalBaseId)), ((ValueComparer<Guid>)(((IProperty)principalBaseAlternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalBaseAlternateId)))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 12,
+                navigationCount: 0,
+                complexPropertyCount: 0,
+                originalValueCount: 12,
+                shadowCount: 2,
+                relationshipCount: 2,
+                storeGeneratedCount: 2);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeUnsafeAccessors.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeUnsafeAccessors.cs
new file mode 100644
index 0000000000..ed8d21e397
--- /dev/null
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeUnsafeAccessors.cs
@@ -0,0 +1,45 @@
+// <auto-generated />
+using System;
+using System.Collections.Generic;
+using System.Net;
+using System.Runtime.CompilerServices;
+using Microsoft.EntityFrameworkCore.Scaffolding;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    public static class OwnedTypeUnsafeAccessors
+    {
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_details")]
+        public static extern ref string _details(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Number>k__BackingField")]
+        public static extern ref int Number(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeArray")]
+        public static extern ref IPAddress[] _refTypeArray(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeEnumerable")]
+        public static extern ref IEnumerable<string> _refTypeEnumerable(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeIList")]
+        public static extern ref IList<string> _refTypeIList(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_refTypeList")]
+        public static extern ref List<IPAddress> _refTypeList(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_valueTypeArray")]
+        public static extern ref DateTime[] _valueTypeArray(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_valueTypeEnumerable")]
+        public static extern ref IEnumerable<byte> _valueTypeEnumerable(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeIList>k__BackingField")]
+        public static extern ref IList<byte> ValueTypeIList(CompiledModelTestBase.OwnedType @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_valueTypeList")]
+        public static extern ref List<short> _valueTypeList(CompiledModelTestBase.OwnedType @this);
+    }
+}
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
index f732733bf0..2092fe8ace 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
@@ -4,10 +4,16 @@
 using System.Net;
 using System.Reflection;
 using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
+using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding;
+using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Storage.Json;
+using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
 using Microsoft.EntityFrameworkCore.ValueGeneration;
 
 #pragma warning disable 219, 612, 618
@@ -38,6 +44,45 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 afterSaveBehavior: PropertySaveBehavior.Throw);
+            id.SetGetter(
+                long? (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.Id(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => !(PrincipalBaseUnsafeAccessors.Id(entity).HasValue),
+                long? (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.Id(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => !(PrincipalBaseUnsafeAccessors.Id(instance).HasValue));
+            id.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, long? value) => PrincipalBaseUnsafeAccessors.Id(entity) = value);
+            id.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, long? value) => PrincipalBaseUnsafeAccessors.Id(entity) = value);
+            id.SetAccessors(
+                long? (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Id(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                long? (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Id(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                long? (InternalEntityEntry entry) => entry.ReadOriginalValue<long?>(id, 0),
+                long? (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long?>(id, 0),
+                object (ValueBuffer valueBuffer) => valueBuffer[0]);
+            id.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: 0,
+                shadowIndex: -1,
+                relationshipIndex: 0,
+                storeGenerationIndex: -1);
+            id.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
+            id.SetCurrentValueComparer(new EntryCurrentValueComparer<long?>(id));
+            id.SetComparer(new NullableValueComparer<long>(id.TypeMapping.Comparer));
+            id.SetKeyComparer(new NullableValueComparer<long>(id.TypeMapping.KeyComparer));
 
             var alternateId = runtimeEntityType.AddProperty(
                 "AlternateId",
@@ -47,12 +92,76 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"),
                 jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            alternateId.SetGetter(
+                Guid (CompiledModelTestBase.PrincipalBase entity) => entity.AlternateId,
+                bool (CompiledModelTestBase.PrincipalBase entity) => entity.AlternateId == new Guid("00000000-0000-0000-0000-000000000000"),
+                Guid (CompiledModelTestBase.PrincipalBase instance) => instance.AlternateId,
+                bool (CompiledModelTestBase.PrincipalBase instance) => instance.AlternateId == new Guid("00000000-0000-0000-0000-000000000000"));
+            alternateId.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, Guid value) => entity.AlternateId = value);
+            alternateId.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, Guid value) => entity.AlternateId = value);
+            alternateId.SetAccessors(
+                Guid (InternalEntityEntry entry) => ((CompiledModelTestBase.PrincipalBase)(entry.Entity)).AlternateId,
+                Guid (InternalEntityEntry entry) => ((CompiledModelTestBase.PrincipalBase)(entry.Entity)).AlternateId,
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(alternateId, 1),
+                Guid (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(alternateId, 1),
+                object (ValueBuffer valueBuffer) => valueBuffer[1]);
+            alternateId.SetPropertyIndexes(
+                index: 1,
+                originalValueIndex: 1,
+                shadowIndex: -1,
+                relationshipIndex: 1,
+                storeGenerationIndex: -1);
+            alternateId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            alternateId.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(alternateId));
 
             var discriminator = runtimeEntityType.AddProperty(
                 "Discriminator",
                 typeof(string),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                string (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                string (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                string (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 2),
+                string (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                object (ValueBuffer valueBuffer) => valueBuffer[2]);
+            discriminator.SetPropertyIndexes(
+                index: 2,
+                originalValueIndex: 2,
+                shadowIndex: 0,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            discriminator.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                keyComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                clrType: typeof(string),
+                jsonValueReaderWriter: JsonStringReaderWriter.Instance);
 
             var enum1 = runtimeEntityType.AddProperty(
                 "Enum1",
@@ -60,6 +169,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: (CompiledModelTestBase.AnEnum)0);
+            enum1.SetGetter(
+                CompiledModelTestBase.AnEnum (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.Enum1(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => object.Equals(((object)(PrincipalBaseUnsafeAccessors.Enum1(entity))), ((object)((CompiledModelTestBase.AnEnum)0L))),
+                CompiledModelTestBase.AnEnum (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.Enum1(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => object.Equals(((object)(PrincipalBaseUnsafeAccessors.Enum1(instance))), ((object)((CompiledModelTestBase.AnEnum)0L))));
+            enum1.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AnEnum value) => PrincipalBaseUnsafeAccessors.Enum1(entity) = value);
+            enum1.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AnEnum value) => PrincipalBaseUnsafeAccessors.Enum1(entity) = value);
+            enum1.SetAccessors(
+                CompiledModelTestBase.AnEnum (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Enum1(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AnEnum (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Enum1(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AnEnum (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.AnEnum>(enum1, 3),
+                CompiledModelTestBase.AnEnum (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.AnEnum>(enum1),
+                object (ValueBuffer valueBuffer) => valueBuffer[3]);
+            enum1.SetPropertyIndexes(
+                index: 3,
+                originalValueIndex: 3,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
+                    bool (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AnEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AnEnum (CompiledModelTestBase.AnEnum v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
+                    bool (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AnEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AnEnum (CompiledModelTestBase.AnEnum v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
+                    bool (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AnEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AnEnum (CompiledModelTestBase.AnEnum v) => v),
+                clrType: typeof(CompiledModelTestBase.AnEnum),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);
 
             var enum2 = runtimeEntityType.AddProperty(
                 "Enum2",
@@ -67,6 +212,44 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("Enum2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Enum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            enum2.SetGetter(
+                CompiledModelTestBase.AnEnum? (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.Enum2(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => !(PrincipalBaseUnsafeAccessors.Enum2(entity).HasValue),
+                CompiledModelTestBase.AnEnum? (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.Enum2(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => !(PrincipalBaseUnsafeAccessors.Enum2(instance).HasValue));
+            enum2.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AnEnum? value) => PrincipalBaseUnsafeAccessors.Enum2(entity) = (value == null ? value : ((CompiledModelTestBase.AnEnum? )(((CompiledModelTestBase.AnEnum)(value))))));
+            enum2.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AnEnum? value) => PrincipalBaseUnsafeAccessors.Enum2(entity) = (value == null ? value : ((CompiledModelTestBase.AnEnum? )(((CompiledModelTestBase.AnEnum)(value))))));
+            enum2.SetAccessors(
+                CompiledModelTestBase.AnEnum? (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Enum2(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AnEnum? (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Enum2(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AnEnum? (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.AnEnum?>(enum2, 4),
+                CompiledModelTestBase.AnEnum? (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.AnEnum?>(enum2),
+                object (ValueBuffer valueBuffer) => valueBuffer[4]);
+            enum2.SetPropertyIndexes(
+                index: 4,
+                originalValueIndex: 4,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            enum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
+                    bool (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AnEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AnEnum (CompiledModelTestBase.AnEnum v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
+                    bool (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AnEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AnEnum (CompiledModelTestBase.AnEnum v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.AnEnum>(
+                    bool (CompiledModelTestBase.AnEnum v1, CompiledModelTestBase.AnEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AnEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AnEnum (CompiledModelTestBase.AnEnum v) => v),
+                clrType: typeof(CompiledModelTestBase.AnEnum),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AnEnum>.Instance);
+            enum2.SetComparer(new NullableValueComparer<CompiledModelTestBase.AnEnum>(enum2.TypeMapping.Comparer));
+            enum2.SetKeyComparer(new NullableValueComparer<CompiledModelTestBase.AnEnum>(enum2.TypeMapping.KeyComparer));
 
             var flagsEnum1 = runtimeEntityType.AddProperty(
                 "FlagsEnum1",
@@ -74,6 +257,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("FlagsEnum1", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum1>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 sentinel: (CompiledModelTestBase.AFlagsEnum)0);
+            flagsEnum1.SetGetter(
+                CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.FlagsEnum1(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => object.Equals(((object)(PrincipalBaseUnsafeAccessors.FlagsEnum1(entity))), ((object)((CompiledModelTestBase.AFlagsEnum)0L))),
+                CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.FlagsEnum1(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => object.Equals(((object)(PrincipalBaseUnsafeAccessors.FlagsEnum1(instance))), ((object)((CompiledModelTestBase.AFlagsEnum)0L))));
+            flagsEnum1.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AFlagsEnum value) => PrincipalBaseUnsafeAccessors.FlagsEnum1(entity) = value);
+            flagsEnum1.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AFlagsEnum value) => PrincipalBaseUnsafeAccessors.FlagsEnum1(entity) = value);
+            flagsEnum1.SetAccessors(
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.FlagsEnum1(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.FlagsEnum1(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum1, 5),
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum1),
+                object (ValueBuffer valueBuffer) => valueBuffer[5]);
+            flagsEnum1.SetPropertyIndexes(
+                index: 5,
+                originalValueIndex: 5,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            flagsEnum1.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
+                    bool (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AFlagsEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.AFlagsEnum v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
+                    bool (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AFlagsEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.AFlagsEnum v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
+                    bool (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AFlagsEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.AFlagsEnum v) => v),
+                clrType: typeof(CompiledModelTestBase.AFlagsEnum),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);
 
             var flagsEnum2 = runtimeEntityType.AddProperty(
                 "FlagsEnum2",
@@ -82,6 +301,42 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<FlagsEnum2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Property,
                 sentinel: CompiledModelTestBase.AFlagsEnum.B | CompiledModelTestBase.AFlagsEnum.C);
+            flagsEnum2.SetGetter(
+                CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.Get_FlagsEnum2(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => object.Equals(((object)(PrincipalBaseUnsafeAccessors.Get_FlagsEnum2(entity))), ((object)(CompiledModelTestBase.AFlagsEnum.B | CompiledModelTestBase.AFlagsEnum.C))),
+                CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.Get_FlagsEnum2(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => object.Equals(((object)(PrincipalBaseUnsafeAccessors.Get_FlagsEnum2(instance))), ((object)(CompiledModelTestBase.AFlagsEnum.B | CompiledModelTestBase.AFlagsEnum.C))));
+            flagsEnum2.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AFlagsEnum value) => PrincipalBaseUnsafeAccessors.Set_FlagsEnum2(entity, value));
+            flagsEnum2.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, CompiledModelTestBase.AFlagsEnum value) => PrincipalBaseUnsafeAccessors.Set_FlagsEnum2(entity, value));
+            flagsEnum2.SetAccessors(
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Get_FlagsEnum2(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Get_FlagsEnum2(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum2, 6),
+                CompiledModelTestBase.AFlagsEnum (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum2),
+                object (ValueBuffer valueBuffer) => valueBuffer[6]);
+            flagsEnum2.SetPropertyIndexes(
+                index: 6,
+                originalValueIndex: 6,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            flagsEnum2.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
+                    bool (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AFlagsEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.AFlagsEnum v) => v),
+                keyComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
+                    bool (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AFlagsEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.AFlagsEnum v) => v),
+                providerValueComparer: new ValueComparer<CompiledModelTestBase.AFlagsEnum>(
+                    bool (CompiledModelTestBase.AFlagsEnum v1, CompiledModelTestBase.AFlagsEnum v2) => object.Equals(((object)(v1)), ((object)(v2))),
+                    int (CompiledModelTestBase.AFlagsEnum v) => ((object)v).GetHashCode(),
+                    CompiledModelTestBase.AFlagsEnum (CompiledModelTestBase.AFlagsEnum v) => v),
+                clrType: typeof(CompiledModelTestBase.AFlagsEnum),
+                jsonValueReaderWriter: JsonSignedEnumReaderWriter<CompiledModelTestBase.AFlagsEnum>.Instance);
 
             var refTypeArray = runtimeEntityType.AddProperty(
                 "RefTypeArray",
@@ -89,6 +344,75 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeArray.SetGetter(
+                IPAddress[] (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeArray(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeArray(entity) == null,
+                IPAddress[] (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeArray(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeArray(instance) == null);
+            refTypeArray.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IPAddress[] value) => PrincipalBaseUnsafeAccessors.RefTypeArray(entity) = value);
+            refTypeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IPAddress[] value) => PrincipalBaseUnsafeAccessors.RefTypeArray(entity) = value);
+            refTypeArray.SetAccessors(
+                IPAddress[] (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeArray(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeArray(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IPAddress[] (InternalEntityEntry entry) => entry.ReadOriginalValue<IPAddress[]>(refTypeArray, 7),
+                IPAddress[] (InternalEntityEntry entry) => entry.GetCurrentValue<IPAddress[]>(refTypeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[7]);
+            refTypeArray.SetPropertyIndexes(
+                index: 7,
+                originalValueIndex: 7,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<IPAddress[], IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<IPAddress[], IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -96,6 +420,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeEnumerable.SetGetter(
+                IEnumerable<string> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(entity) == null,
+                IEnumerable<string> (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(instance) == null);
+            refTypeEnumerable.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IEnumerable<string> value) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(entity) = value);
+            refTypeEnumerable.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IEnumerable<string> value) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(entity) = value);
+            refTypeEnumerable.SetAccessors(
+                IEnumerable<string> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IEnumerable<string> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeEnumerable(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IEnumerable<string> (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<string>>(refTypeEnumerable, 8),
+                IEnumerable<string> (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable),
+                object (ValueBuffer valueBuffer) => valueBuffer[8]);
+            refTypeEnumerable.SetPropertyIndexes(
+                index: 8,
+                originalValueIndex: 8,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -103,6 +482,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeIList.SetGetter(
+                IList<string> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeIList(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeIList(entity) == null,
+                IList<string> (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeIList(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeIList(instance) == null);
+            refTypeIList.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IList<string> value) => PrincipalBaseUnsafeAccessors.RefTypeIList(entity) = value);
+            refTypeIList.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IList<string> value) => PrincipalBaseUnsafeAccessors.RefTypeIList(entity) = value);
+            refTypeIList.SetAccessors(
+                IList<string> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeIList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IList<string> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeIList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IList<string> (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<string>>(refTypeIList, 9),
+                IList<string> (InternalEntityEntry entry) => entry.GetCurrentValue<IList<string>>(refTypeIList),
+                object (ValueBuffer valueBuffer) => valueBuffer[9]);
+            refTypeIList.SetPropertyIndexes(
+                index: 9,
+                originalValueIndex: 9,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<string>, string>(new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<string>(new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
+                    JsonStringReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    keyComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    clrType: typeof(string),
+                    jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -110,6 +544,75 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            refTypeList.SetGetter(
+                List<IPAddress> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeList(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.RefTypeList(entity) == null,
+                List<IPAddress> (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeList(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.RefTypeList(instance) == null);
+            refTypeList.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, List<IPAddress> value) => PrincipalBaseUnsafeAccessors.RefTypeList(entity) = value);
+            refTypeList.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, List<IPAddress> value) => PrincipalBaseUnsafeAccessors.RefTypeList(entity) = value);
+            refTypeList.SetAccessors(
+                List<IPAddress> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                List<IPAddress> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.RefTypeList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                List<IPAddress> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<IPAddress>>(refTypeList, 10),
+                List<IPAddress> (InternalEntityEntry entry) => entry.GetCurrentValue<List<IPAddress>>(refTypeList),
+                object (ValueBuffer valueBuffer) => valueBuffer[10]);
+            refTypeList.SetPropertyIndexes(
+                index: 10,
+                originalValueIndex: 10,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            refTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                keyComparer: new ListOfReferenceTypesComparer<List<IPAddress>, IPAddress>(new ValueComparer<IPAddress>(
+                    bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                    int (IPAddress v) => ((object)v).GetHashCode(),
+                    IPAddress (IPAddress v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<IPAddress>(new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v))))),
+                jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<IPAddress>, IPAddress>(
+                    new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    keyComparer: new ValueComparer<IPAddress>(
+                        bool (IPAddress v1, IPAddress v2) => v1 == null && v2 == null || v1 != null && v2 != null && v1.Equals(v2),
+                        int (IPAddress v) => ((object)v).GetHashCode(),
+                        IPAddress (IPAddress v) => v),
+                    providerValueComparer: new ValueComparer<string>(
+                        bool (string v1, string v2) => v1 == v2,
+                        int (string v) => ((object)v).GetHashCode(),
+                        string (string v) => v),
+                    converter: new ValueConverter<IPAddress, string>(
+                        string (IPAddress v) => ((object)v).ToString(),
+                        IPAddress (string v) => IPAddress.Parse(v)),
+                    jsonValueReaderWriter: new JsonConvertedValueReaderWriter<IPAddress, string>(
+                        JsonStringReaderWriter.Instance,
+                        new ValueConverter<IPAddress, string>(
+                            string (IPAddress v) => ((object)v).ToString(),
+                            IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -117,6 +620,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeArray.SetGetter(
+                DateTime[] (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeArray(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeArray(entity) == null,
+                DateTime[] (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeArray(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeArray(instance) == null);
+            valueTypeArray.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, DateTime[] value) => PrincipalBaseUnsafeAccessors.ValueTypeArray(entity) = value);
+            valueTypeArray.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, DateTime[] value) => PrincipalBaseUnsafeAccessors.ValueTypeArray(entity) = value);
+            valueTypeArray.SetAccessors(
+                DateTime[] (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeArray(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeArray(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                DateTime[] (InternalEntityEntry entry) => entry.ReadOriginalValue<DateTime[]>(valueTypeArray, 11),
+                DateTime[] (InternalEntityEntry entry) => entry.GetCurrentValue<DateTime[]>(valueTypeArray),
+                object (ValueBuffer valueBuffer) => valueBuffer[11]);
+            valueTypeArray.SetPropertyIndexes(
+                index: 11,
+                originalValueIndex: 11,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeArray.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                keyComparer: new ListOfValueTypesComparer<DateTime[], DateTime>(new ValueComparer<DateTime>(
+                    bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                    int (DateTime v) => ((object)v).GetHashCode(),
+                    DateTime (DateTime v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<DateTime>(new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
+                    JsonDateTimeReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    keyComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    providerValueComparer: new ValueComparer<DateTime>(
+                        bool (DateTime v1, DateTime v2) => v1.Equals(v2),
+                        int (DateTime v) => ((object)v).GetHashCode(),
+                        DateTime (DateTime v) => v),
+                    clrType: typeof(DateTime),
+                    jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -124,6 +682,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeEnumerable.SetGetter(
+                IEnumerable<byte> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(entity) == null,
+                IEnumerable<byte> (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(instance) == null);
+            valueTypeEnumerable.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IEnumerable<byte> value) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(entity) = value);
+            valueTypeEnumerable.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IEnumerable<byte> value) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(entity) = value);
+            valueTypeEnumerable.SetAccessors(
+                IEnumerable<byte> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IEnumerable<byte> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeEnumerable(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IEnumerable<byte> (InternalEntityEntry entry) => entry.ReadOriginalValue<IEnumerable<byte>>(valueTypeEnumerable, 12),
+                IEnumerable<byte> (InternalEntityEntry entry) => entry.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable),
+                object (ValueBuffer valueBuffer) => valueBuffer[12]);
+            valueTypeEnumerable.SetPropertyIndexes(
+                index: 12,
+                originalValueIndex: 12,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeEnumerable.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -131,6 +744,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeIList.SetGetter(
+                IList<byte> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeIList(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeIList(entity) == null,
+                IList<byte> (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeIList(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeIList(instance) == null);
+            valueTypeIList.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IList<byte> value) => PrincipalBaseUnsafeAccessors.ValueTypeIList(entity) = value);
+            valueTypeIList.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, IList<byte> value) => PrincipalBaseUnsafeAccessors.ValueTypeIList(entity) = value);
+            valueTypeIList.SetAccessors(
+                IList<byte> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeIList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IList<byte> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeIList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                IList<byte> (InternalEntityEntry entry) => entry.ReadOriginalValue<IList<byte>>(valueTypeIList, 13),
+                IList<byte> (InternalEntityEntry entry) => entry.GetCurrentValue<IList<byte>>(valueTypeIList),
+                object (ValueBuffer valueBuffer) => valueBuffer[13]);
+            valueTypeIList.SetPropertyIndexes(
+                index: 13,
+                originalValueIndex: 13,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeIList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<byte>, byte>(new ValueComparer<byte>(
+                    bool (byte v1, byte v2) => v1 == v2,
+                    int (byte v) => ((int)(v)),
+                    byte (byte v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<byte>(new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<byte>, byte>(
+                    JsonByteReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    keyComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    providerValueComparer: new ValueComparer<byte>(
+                        bool (byte v1, byte v2) => v1 == v2,
+                        int (byte v) => ((int)(v)),
+                        byte (byte v) => v),
+                    clrType: typeof(byte),
+                    jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -138,6 +806,61 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            valueTypeList.SetGetter(
+                List<short> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeList(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.ValueTypeList(entity) == null,
+                List<short> (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeList(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.ValueTypeList(instance) == null);
+            valueTypeList.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, List<short> value) => PrincipalBaseUnsafeAccessors.ValueTypeList(entity) = value);
+            valueTypeList.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, List<short> value) => PrincipalBaseUnsafeAccessors.ValueTypeList(entity) = value);
+            valueTypeList.SetAccessors(
+                List<short> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                List<short> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.ValueTypeList(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                List<short> (InternalEntityEntry entry) => entry.ReadOriginalValue<List<short>>(valueTypeList, 14),
+                List<short> (InternalEntityEntry entry) => entry.GetCurrentValue<List<short>>(valueTypeList),
+                object (ValueBuffer valueBuffer) => valueBuffer[14]);
+            valueTypeList.SetPropertyIndexes(
+                index: 14,
+                originalValueIndex: 14,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            valueTypeList.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ListOfValueTypesComparer<List<short>, short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                keyComparer: new ListOfValueTypesComparer<List<short>, short>(new ValueComparer<short>(
+                    bool (short v1, short v2) => v1 == v2,
+                    int (short v) => ((int)(v)),
+                    short (short v) => v)),
+                providerValueComparer: new ValueComparer<string>(
+                    bool (string v1, string v2) => v1 == v2,
+                    int (string v) => ((object)v).GetHashCode(),
+                    string (string v) => v),
+                converter: new CollectionToJsonStringConverter<short>(new JsonCollectionOfStructsReaderWriter<List<short>, short>(
+                    JsonInt16ReaderWriter.Instance)),
+                jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<List<short>, short>(
+                    JsonInt16ReaderWriter.Instance),
+                elementMapping: InMemoryTypeMapping.Default.Clone(
+                    comparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    keyComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    providerValueComparer: new ValueComparer<short>(
+                        bool (short v1, short v2) => v1 == v2,
+                        int (short v) => ((int)(v)),
+                        short (short v) => v),
+                    clrType: typeof(short),
+                    jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var key = runtimeEntityType.AddKey(
                 new[] { id });
@@ -171,11 +894,88 @@ public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType decl
                 inverse.Inverse = skipNavigation;
             }
 
+            skipNavigation.SetGetter(
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.Deriveds(entity),
+                bool (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.Deriveds(entity) == null,
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.Deriveds(instance),
+                bool (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseUnsafeAccessors.Deriveds(instance) == null);
+            skipNavigation.SetSetter(
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseUnsafeAccessors.Deriveds(entity) = value);
+            skipNavigation.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseUnsafeAccessors.Deriveds(entity) = value);
+            skipNavigation.SetAccessors(
+                ICollection<CompiledModelTestBase.PrincipalBase> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Deriveds(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                ICollection<CompiledModelTestBase.PrincipalBase> (InternalEntityEntry entry) => PrincipalBaseUnsafeAccessors.Deriveds(((CompiledModelTestBase.PrincipalBase)(entry.Entity))),
+                null,
+                ICollection<CompiledModelTestBase.PrincipalBase> (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<CompiledModelTestBase.PrincipalBase>>(skipNavigation),
+                null);
+            skipNavigation.SetPropertyIndexes(
+                index: 1,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: 3,
+                storeGenerationIndex: -1);
+            skipNavigation.SetCollectionAccessor<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseUnsafeAccessors.Deriveds(entity),
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseUnsafeAccessors.Deriveds(entity) = ((ICollection<CompiledModelTestBase.PrincipalBase>)(collection)),
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseUnsafeAccessors.Deriveds(entity) = ((ICollection<CompiledModelTestBase.PrincipalBase>)(collection)),
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalBase entity, Action<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(entity, setter),
+                ICollection<CompiledModelTestBase.PrincipalBase> () => ((ICollection<CompiledModelTestBase.PrincipalBase>)(((ICollection<CompiledModelTestBase.PrincipalBase>)(new HashSet<CompiledModelTestBase.PrincipalBase>(ReferenceEqualityComparer.Instance))))));
             return skipNavigation;
         }
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var id = runtimeEntityType.FindProperty("Id");
+            var alternateId = runtimeEntityType.FindProperty("AlternateId");
+            var discriminator = runtimeEntityType.FindProperty("Discriminator");
+            var enum1 = runtimeEntityType.FindProperty("Enum1");
+            var enum2 = runtimeEntityType.FindProperty("Enum2");
+            var flagsEnum1 = runtimeEntityType.FindProperty("FlagsEnum1");
+            var flagsEnum2 = runtimeEntityType.FindProperty("FlagsEnum2");
+            var refTypeArray = runtimeEntityType.FindProperty("RefTypeArray");
+            var refTypeEnumerable = runtimeEntityType.FindProperty("RefTypeEnumerable");
+            var refTypeIList = runtimeEntityType.FindProperty("RefTypeIList");
+            var refTypeList = runtimeEntityType.FindProperty("RefTypeList");
+            var valueTypeArray = runtimeEntityType.FindProperty("ValueTypeArray");
+            var valueTypeEnumerable = runtimeEntityType.FindProperty("ValueTypeEnumerable");
+            var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList");
+            var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList");
+            var key = runtimeEntityType.FindKey(new[] { id });
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
+            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
+            var key0 = runtimeEntityType.FindKey(new[] { id, alternateId });
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key0));
+            key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key0));
+            var owned = runtimeEntityType.FindNavigation("Owned");
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.PrincipalBase)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long?, Guid, string, CompiledModelTestBase.AnEnum, CompiledModelTestBase.AnEnum?, CompiledModelTestBase.AFlagsEnum, CompiledModelTestBase.AFlagsEnum, IPAddress[], IEnumerable<string>, IList<string>, List<IPAddress>, DateTime[], IEnumerable<byte>, IList<byte>, List<short>>((source.GetCurrentValue<long?>(id) == null ? null : ((ValueComparer<long?>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<long?>(id))), ((ValueComparer<Guid>)(((IProperty)alternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(alternateId)), (source.GetCurrentValue<string>(discriminator) == null ? null : ((ValueComparer<string>)(((IProperty)discriminator).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(discriminator))), ((ValueComparer<CompiledModelTestBase.AnEnum>)(((IProperty)enum1).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AnEnum>(enum1)), (source.GetCurrentValue<CompiledModelTestBase.AnEnum?>(enum2) == null ? null : ((ValueComparer<CompiledModelTestBase.AnEnum?>)(((IProperty)enum2).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AnEnum?>(enum2))), ((ValueComparer<CompiledModelTestBase.AFlagsEnum>)(((IProperty)flagsEnum1).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum1)), ((ValueComparer<CompiledModelTestBase.AFlagsEnum>)(((IProperty)flagsEnum2).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum2)), (((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)refTypeArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))))))), (((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))) == null ? null : ((IEnumerable<string>)(((ValueComparer<object>)(((IProperty)refTypeEnumerable).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))))))), (((object)(source.GetCurrentValue<IList<string>>(refTypeIList))) == null ? null : ((IList<string>)(((ValueComparer<object>)(((IProperty)refTypeIList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IList<string>>(refTypeIList))))))), (((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))) == null ? null : ((List<IPAddress>)(((ValueComparer<object>)(((IProperty)refTypeList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))))))), (((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))) == null ? null : ((DateTime[])(((ValueComparer<IEnumerable<DateTime>>)(((IProperty)valueTypeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))))))), (source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable) == null ? null : ((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeEnumerable).GetValueComparer())).Snapshot(source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable))), (((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))) == null ? null : ((IList<byte>)(((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeIList).GetValueComparer())).Snapshot(((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))))))), (((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))) == null ? null : ((List<short>)(((ValueComparer<IEnumerable<short>>)(((IProperty)valueTypeList).GetValueComparer())).Snapshot(((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))))))))));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => Snapshot.Empty);
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => Snapshot.Empty);
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<string>((source.ContainsKey("Discriminator") ? ((string)(source["Discriminator"])) : null)))));
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<string>(default(string)))));
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.PrincipalBase)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long?, Guid, object, object>((source.GetCurrentValue<long?>(id) == null ? null : ((ValueComparer<long?>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long?>(id))), ((ValueComparer<Guid>)(((IProperty)alternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(alternateId)), PrincipalBaseUnsafeAccessors._ownedField(entity8), (object)(null))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 15,
+                navigationCount: 2,
+                complexPropertyCount: 0,
+                originalValueCount: 15,
+                shadowCount: 1,
+                relationshipCount: 4,
+                storeGeneratedCount: 0);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
index 2fe1d6cd30..6a3c6f9dd7 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
@@ -1,10 +1,18 @@
 // <auto-generated />
 using System;
+using System.Collections;
 using System.Collections.Generic;
+using System.Linq;
 using System.Reflection;
 using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
+using Microsoft.EntityFrameworkCore.InMemory.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Storage;
+using Microsoft.EntityFrameworkCore.Storage.Json;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -32,30 +40,310 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                 afterSaveBehavior: PropertySaveBehavior.Throw);
+            derivedsId.SetGetter(
+                long (Dictionary<string, object> entity) => ((((IDictionary<string, object>)entity).ContainsKey("DerivedsId") ? entity["DerivedsId"] : null) == null ? 0L : ((long)((((IDictionary<string, object>)entity).ContainsKey("DerivedsId") ? entity["DerivedsId"] : null)))),
+                bool (Dictionary<string, object> entity) => (((IDictionary<string, object>)entity).ContainsKey("DerivedsId") ? entity["DerivedsId"] : null) == null,
+                long (Dictionary<string, object> instance) => ((((IDictionary<string, object>)instance).ContainsKey("DerivedsId") ? instance["DerivedsId"] : null) == null ? 0L : ((long)((((IDictionary<string, object>)instance).ContainsKey("DerivedsId") ? instance["DerivedsId"] : null)))),
+                bool (Dictionary<string, object> instance) => (((IDictionary<string, object>)instance).ContainsKey("DerivedsId") ? instance["DerivedsId"] : null) == null);
+            derivedsId.SetSetter(
+                (Dictionary<string, object> entity, long value) => entity["DerivedsId"] = ((object)(value)));
+            derivedsId.SetMaterializationSetter(
+                (Dictionary<string, object> entity, long value) => entity["DerivedsId"] = ((object)(value)));
+            derivedsId.SetAccessors(
+                long (InternalEntityEntry entry) =>
+                {
+                    if (entry.FlaggedAsStoreGenerated(0))
+                    {
+                        return entry.ReadStoreGeneratedValue<long>(0);
+                    }
+                    else
+                    {
+                        {
+                            if (entry.FlaggedAsTemporary(0) && (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("DerivedsId") ? ((Dictionary<string, object>)(entry.Entity))["DerivedsId"] : null) == null)
+                            {
+                                return entry.ReadTemporaryValue<long>(0);
+                            }
+                            else
+                            {
+                                var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("DerivedsId") ? ((Dictionary<string, object>)(entry.Entity))["DerivedsId"] : null);
+                                return (nullableValue == null ? default(long) : ((long)(nullableValue)));
+                            }
+                        }
+                    }
+                },
+                long (InternalEntityEntry entry) =>
+                {
+                    var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("DerivedsId") ? ((Dictionary<string, object>)(entry.Entity))["DerivedsId"] : null);
+                    return (nullableValue == null ? default(long) : ((long)(nullableValue)));
+                },
+                long (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(derivedsId, 0),
+                long (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(derivedsId, 0),
+                object (ValueBuffer valueBuffer) => valueBuffer[0]);
+            derivedsId.SetPropertyIndexes(
+                index: 0,
+                originalValueIndex: 0,
+                shadowIndex: -1,
+                relationshipIndex: 0,
+                storeGenerationIndex: 0);
+            derivedsId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
+            derivedsId.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(derivedsId));
 
             var derivedsAlternateId = runtimeEntityType.AddProperty(
                 "DerivedsAlternateId",
                 typeof(Guid),
                 propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                 afterSaveBehavior: PropertySaveBehavior.Throw);
+            derivedsAlternateId.SetGetter(
+                Guid (Dictionary<string, object> entity) => ((((IDictionary<string, object>)entity).ContainsKey("DerivedsAlternateId") ? entity["DerivedsAlternateId"] : null) == null ? new Guid("00000000-0000-0000-0000-000000000000") : ((Guid)((((IDictionary<string, object>)entity).ContainsKey("DerivedsAlternateId") ? entity["DerivedsAlternateId"] : null)))),
+                bool (Dictionary<string, object> entity) => (((IDictionary<string, object>)entity).ContainsKey("DerivedsAlternateId") ? entity["DerivedsAlternateId"] : null) == null,
+                Guid (Dictionary<string, object> instance) => ((((IDictionary<string, object>)instance).ContainsKey("DerivedsAlternateId") ? instance["DerivedsAlternateId"] : null) == null ? new Guid("00000000-0000-0000-0000-000000000000") : ((Guid)((((IDictionary<string, object>)instance).ContainsKey("DerivedsAlternateId") ? instance["DerivedsAlternateId"] : null)))),
+                bool (Dictionary<string, object> instance) => (((IDictionary<string, object>)instance).ContainsKey("DerivedsAlternateId") ? instance["DerivedsAlternateId"] : null) == null);
+            derivedsAlternateId.SetSetter(
+                (Dictionary<string, object> entity, Guid value) => entity["DerivedsAlternateId"] = ((object)(value)));
+            derivedsAlternateId.SetMaterializationSetter(
+                (Dictionary<string, object> entity, Guid value) => entity["DerivedsAlternateId"] = ((object)(value)));
+            derivedsAlternateId.SetAccessors(
+                Guid (InternalEntityEntry entry) =>
+                {
+                    if (entry.FlaggedAsStoreGenerated(1))
+                    {
+                        return entry.ReadStoreGeneratedValue<Guid>(1);
+                    }
+                    else
+                    {
+                        {
+                            if (entry.FlaggedAsTemporary(1) && (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("DerivedsAlternateId") ? ((Dictionary<string, object>)(entry.Entity))["DerivedsAlternateId"] : null) == null)
+                            {
+                                return entry.ReadTemporaryValue<Guid>(1);
+                            }
+                            else
+                            {
+                                var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("DerivedsAlternateId") ? ((Dictionary<string, object>)(entry.Entity))["DerivedsAlternateId"] : null);
+                                return (nullableValue == null ? default(Guid) : ((Guid)(nullableValue)));
+                            }
+                        }
+                    }
+                },
+                Guid (InternalEntityEntry entry) =>
+                {
+                    var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("DerivedsAlternateId") ? ((Dictionary<string, object>)(entry.Entity))["DerivedsAlternateId"] : null);
+                    return (nullableValue == null ? default(Guid) : ((Guid)(nullableValue)));
+                },
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(derivedsAlternateId, 1),
+                Guid (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(derivedsAlternateId, 1),
+                object (ValueBuffer valueBuffer) => valueBuffer[1]);
+            derivedsAlternateId.SetPropertyIndexes(
+                index: 1,
+                originalValueIndex: 1,
+                shadowIndex: -1,
+                relationshipIndex: 1,
+                storeGenerationIndex: 1);
+            derivedsAlternateId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            derivedsAlternateId.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(derivedsAlternateId));
 
             var principalsId = runtimeEntityType.AddProperty(
                 "PrincipalsId",
                 typeof(long),
                 propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                 afterSaveBehavior: PropertySaveBehavior.Throw);
+            principalsId.SetGetter(
+                long (Dictionary<string, object> entity) => ((((IDictionary<string, object>)entity).ContainsKey("PrincipalsId") ? entity["PrincipalsId"] : null) == null ? 0L : ((long)((((IDictionary<string, object>)entity).ContainsKey("PrincipalsId") ? entity["PrincipalsId"] : null)))),
+                bool (Dictionary<string, object> entity) => (((IDictionary<string, object>)entity).ContainsKey("PrincipalsId") ? entity["PrincipalsId"] : null) == null,
+                long (Dictionary<string, object> instance) => ((((IDictionary<string, object>)instance).ContainsKey("PrincipalsId") ? instance["PrincipalsId"] : null) == null ? 0L : ((long)((((IDictionary<string, object>)instance).ContainsKey("PrincipalsId") ? instance["PrincipalsId"] : null)))),
+                bool (Dictionary<string, object> instance) => (((IDictionary<string, object>)instance).ContainsKey("PrincipalsId") ? instance["PrincipalsId"] : null) == null);
+            principalsId.SetSetter(
+                (Dictionary<string, object> entity, long value) => entity["PrincipalsId"] = ((object)(value)));
+            principalsId.SetMaterializationSetter(
+                (Dictionary<string, object> entity, long value) => entity["PrincipalsId"] = ((object)(value)));
+            principalsId.SetAccessors(
+                long (InternalEntityEntry entry) =>
+                {
+                    if (entry.FlaggedAsStoreGenerated(2))
+                    {
+                        return entry.ReadStoreGeneratedValue<long>(2);
+                    }
+                    else
+                    {
+                        {
+                            if (entry.FlaggedAsTemporary(2) && (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("PrincipalsId") ? ((Dictionary<string, object>)(entry.Entity))["PrincipalsId"] : null) == null)
+                            {
+                                return entry.ReadTemporaryValue<long>(2);
+                            }
+                            else
+                            {
+                                var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("PrincipalsId") ? ((Dictionary<string, object>)(entry.Entity))["PrincipalsId"] : null);
+                                return (nullableValue == null ? default(long) : ((long)(nullableValue)));
+                            }
+                        }
+                    }
+                },
+                long (InternalEntityEntry entry) =>
+                {
+                    var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("PrincipalsId") ? ((Dictionary<string, object>)(entry.Entity))["PrincipalsId"] : null);
+                    return (nullableValue == null ? default(long) : ((long)(nullableValue)));
+                },
+                long (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalsId, 2),
+                long (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalsId, 2),
+                object (ValueBuffer valueBuffer) => valueBuffer[2]);
+            principalsId.SetPropertyIndexes(
+                index: 2,
+                originalValueIndex: 2,
+                shadowIndex: -1,
+                relationshipIndex: 2,
+                storeGenerationIndex: 2);
+            principalsId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                keyComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                providerValueComparer: new ValueComparer<long>(
+                    bool (long v1, long v2) => v1 == v2,
+                    int (long v) => ((object)v).GetHashCode(),
+                    long (long v) => v),
+                clrType: typeof(long),
+                jsonValueReaderWriter: JsonInt64ReaderWriter.Instance);
+            principalsId.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(principalsId));
 
             var principalsAlternateId = runtimeEntityType.AddProperty(
                 "PrincipalsAlternateId",
                 typeof(Guid),
                 propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                 afterSaveBehavior: PropertySaveBehavior.Throw);
+            principalsAlternateId.SetGetter(
+                Guid (Dictionary<string, object> entity) => ((((IDictionary<string, object>)entity).ContainsKey("PrincipalsAlternateId") ? entity["PrincipalsAlternateId"] : null) == null ? new Guid("00000000-0000-0000-0000-000000000000") : ((Guid)((((IDictionary<string, object>)entity).ContainsKey("PrincipalsAlternateId") ? entity["PrincipalsAlternateId"] : null)))),
+                bool (Dictionary<string, object> entity) => (((IDictionary<string, object>)entity).ContainsKey("PrincipalsAlternateId") ? entity["PrincipalsAlternateId"] : null) == null,
+                Guid (Dictionary<string, object> instance) => ((((IDictionary<string, object>)instance).ContainsKey("PrincipalsAlternateId") ? instance["PrincipalsAlternateId"] : null) == null ? new Guid("00000000-0000-0000-0000-000000000000") : ((Guid)((((IDictionary<string, object>)instance).ContainsKey("PrincipalsAlternateId") ? instance["PrincipalsAlternateId"] : null)))),
+                bool (Dictionary<string, object> instance) => (((IDictionary<string, object>)instance).ContainsKey("PrincipalsAlternateId") ? instance["PrincipalsAlternateId"] : null) == null);
+            principalsAlternateId.SetSetter(
+                (Dictionary<string, object> entity, Guid value) => entity["PrincipalsAlternateId"] = ((object)(value)));
+            principalsAlternateId.SetMaterializationSetter(
+                (Dictionary<string, object> entity, Guid value) => entity["PrincipalsAlternateId"] = ((object)(value)));
+            principalsAlternateId.SetAccessors(
+                Guid (InternalEntityEntry entry) =>
+                {
+                    if (entry.FlaggedAsStoreGenerated(3))
+                    {
+                        return entry.ReadStoreGeneratedValue<Guid>(3);
+                    }
+                    else
+                    {
+                        {
+                            if (entry.FlaggedAsTemporary(3) && (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("PrincipalsAlternateId") ? ((Dictionary<string, object>)(entry.Entity))["PrincipalsAlternateId"] : null) == null)
+                            {
+                                return entry.ReadTemporaryValue<Guid>(3);
+                            }
+                            else
+                            {
+                                var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("PrincipalsAlternateId") ? ((Dictionary<string, object>)(entry.Entity))["PrincipalsAlternateId"] : null);
+                                return (nullableValue == null ? default(Guid) : ((Guid)(nullableValue)));
+                            }
+                        }
+                    }
+                },
+                Guid (InternalEntityEntry entry) =>
+                {
+                    var nullableValue = (((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("PrincipalsAlternateId") ? ((Dictionary<string, object>)(entry.Entity))["PrincipalsAlternateId"] : null);
+                    return (nullableValue == null ? default(Guid) : ((Guid)(nullableValue)));
+                },
+                Guid (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalsAlternateId, 3),
+                Guid (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalsAlternateId, 3),
+                object (ValueBuffer valueBuffer) => valueBuffer[3]);
+            principalsAlternateId.SetPropertyIndexes(
+                index: 3,
+                originalValueIndex: 3,
+                shadowIndex: -1,
+                relationshipIndex: 3,
+                storeGenerationIndex: 3);
+            principalsAlternateId.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                keyComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                providerValueComparer: new ValueComparer<Guid>(
+                    bool (Guid v1, Guid v2) => v1 == v2,
+                    int (Guid v) => ((object)v).GetHashCode(),
+                    Guid (Guid v) => v),
+                clrType: typeof(Guid),
+                jsonValueReaderWriter: JsonGuidReaderWriter.Instance);
+            principalsAlternateId.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(principalsAlternateId));
 
             var rowid = runtimeEntityType.AddProperty(
                 "rowid",
                 typeof(byte[]),
                 propertyInfo: runtimeEntityType.FindIndexerPropertyInfo(),
                 nullable: true);
+            rowid.SetGetter(
+                byte[] (Dictionary<string, object> entity) => ((((IDictionary<string, object>)entity).ContainsKey("rowid") ? entity["rowid"] : null) == null ? null : ((byte[])((((IDictionary<string, object>)entity).ContainsKey("rowid") ? entity["rowid"] : null)))),
+                bool (Dictionary<string, object> entity) => (((IDictionary<string, object>)entity).ContainsKey("rowid") ? entity["rowid"] : null) == null,
+                byte[] (Dictionary<string, object> instance) => ((((IDictionary<string, object>)instance).ContainsKey("rowid") ? instance["rowid"] : null) == null ? null : ((byte[])((((IDictionary<string, object>)instance).ContainsKey("rowid") ? instance["rowid"] : null)))),
+                bool (Dictionary<string, object> instance) => (((IDictionary<string, object>)instance).ContainsKey("rowid") ? instance["rowid"] : null) == null);
+            rowid.SetSetter(
+                (Dictionary<string, object> entity, byte[] value) => entity["rowid"] = ((object)(value)));
+            rowid.SetMaterializationSetter(
+                (Dictionary<string, object> entity, byte[] value) => entity["rowid"] = ((object)(value)));
+            rowid.SetAccessors(
+                byte[] (InternalEntityEntry entry) => ((byte[])((((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("rowid") ? ((Dictionary<string, object>)(entry.Entity))["rowid"] : null))),
+                byte[] (InternalEntityEntry entry) => ((byte[])((((IDictionary<string, object>)((Dictionary<string, object>)(entry.Entity))).ContainsKey("rowid") ? ((Dictionary<string, object>)(entry.Entity))["rowid"] : null))),
+                byte[] (InternalEntityEntry entry) => entry.ReadOriginalValue<byte[]>(rowid, 4),
+                byte[] (InternalEntityEntry entry) => entry.GetCurrentValue<byte[]>(rowid),
+                object (ValueBuffer valueBuffer) => valueBuffer[4]);
+            rowid.SetPropertyIndexes(
+                index: 4,
+                originalValueIndex: 4,
+                shadowIndex: -1,
+                relationshipIndex: -1,
+                storeGenerationIndex: -1);
+            rowid.TypeMapping = InMemoryTypeMapping.Default.Clone(
+                comparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => ((object)v).GetHashCode(),
+                    byte[] (byte[] v) => v),
+                keyComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                providerValueComparer: new ValueComparer<byte[]>(
+                    bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
+                    int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
+                    byte[] (byte[] source) => source.ToArray()),
+                clrType: typeof(byte[]),
+                jsonValueReaderWriter: JsonByteArrayReaderWriter.Instance);
 
             var key = runtimeEntityType.AddKey(
                 new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
@@ -88,6 +376,42 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var derivedsId = runtimeEntityType.FindProperty("DerivedsId");
+            var derivedsAlternateId = runtimeEntityType.FindProperty("DerivedsAlternateId");
+            var principalsId = runtimeEntityType.FindProperty("PrincipalsId");
+            var principalsAlternateId = runtimeEntityType.FindProperty("PrincipalsAlternateId");
+            var rowid = runtimeEntityType.FindProperty("rowid");
+            var key = runtimeEntityType.FindKey(new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
+            key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((Dictionary<string, object>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, long, Guid, byte[]>(((ValueComparer<long>)(((IProperty)derivedsId).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(derivedsId)), ((ValueComparer<Guid>)(((IProperty)derivedsAlternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(derivedsAlternateId)), ((ValueComparer<long>)(((IProperty)principalsId).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(principalsId)), ((ValueComparer<Guid>)(((IProperty)principalsAlternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalsAlternateId)), (source.GetCurrentValue<byte[]>(rowid) == null ? null : ((ValueComparer<byte[]>)(((IProperty)rowid).GetValueComparer())).Snapshot(source.GetCurrentValue<byte[]>(rowid))))));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<long, Guid, long, Guid>(((ValueComparer<long>)(((IProperty)derivedsId).GetValueComparer())).Snapshot(default(long)), ((ValueComparer<Guid>)(((IProperty)derivedsAlternateId).GetValueComparer())).Snapshot(default(Guid)), ((ValueComparer<long>)(((IProperty)principalsId).GetValueComparer())).Snapshot(default(long)), ((ValueComparer<Guid>)(((IProperty)principalsAlternateId).GetValueComparer())).Snapshot(default(Guid))))));
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => ((ISnapshot)(new Snapshot<long, Guid, long, Guid>(default(long), default(Guid), default(long), default(Guid)))));
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => Snapshot.Empty);
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((Dictionary<string, object>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long, Guid, long, Guid>(((ValueComparer<long>)(((IProperty)derivedsId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(derivedsId)), ((ValueComparer<Guid>)(((IProperty)derivedsAlternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(derivedsAlternateId)), ((ValueComparer<long>)(((IProperty)principalsId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(principalsId)), ((ValueComparer<Guid>)(((IProperty)principalsAlternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(principalsAlternateId)))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 5,
+                navigationCount: 0,
+                complexPropertyCount: 0,
+                originalValueCount: 5,
+                shadowCount: 0,
+                relationshipCount: 4,
+                storeGeneratedCount: 4);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseUnsafeAccessors.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseUnsafeAccessors.cs
new file mode 100644
index 0000000000..4b43c6dd1f
--- /dev/null
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseUnsafeAccessors.cs
@@ -0,0 +1,63 @@
+// <auto-generated />
+using System;
+using System.Collections.Generic;
+using System.Net;
+using System.Runtime.CompilerServices;
+using Microsoft.EntityFrameworkCore.Scaffolding;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    public static class PrincipalBaseUnsafeAccessors
+    {
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
+        public static extern ref long? Id(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum1>k__BackingField")]
+        public static extern ref CompiledModelTestBase.AnEnum Enum1(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Enum2>k__BackingField")]
+        public static extern ref CompiledModelTestBase.AnEnum? Enum2(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<FlagsEnum1>k__BackingField")]
+        public static extern ref CompiledModelTestBase.AFlagsEnum FlagsEnum1(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = "get_FlagsEnum2")]
+        public static extern CompiledModelTestBase.AFlagsEnum Get_FlagsEnum2(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Method, Name = "set_FlagsEnum2")]
+        public static extern void Set_FlagsEnum2(CompiledModelTestBase.PrincipalBase @this, CompiledModelTestBase.AFlagsEnum value);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<RefTypeArray>k__BackingField")]
+        public static extern ref IPAddress[] RefTypeArray(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<RefTypeEnumerable>k__BackingField")]
+        public static extern ref IEnumerable<string> RefTypeEnumerable(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<RefTypeIList>k__BackingField")]
+        public static extern ref IList<string> RefTypeIList(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<RefTypeList>k__BackingField")]
+        public static extern ref List<IPAddress> RefTypeList(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeArray>k__BackingField")]
+        public static extern ref DateTime[] ValueTypeArray(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeEnumerable>k__BackingField")]
+        public static extern ref IEnumerable<byte> ValueTypeEnumerable(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeIList>k__BackingField")]
+        public static extern ref IList<byte> ValueTypeIList(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeList>k__BackingField")]
+        public static extern ref List<short> ValueTypeList(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_ownedField")]
+        public static extern ref CompiledModelTestBase.OwnedType _ownedField(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> Deriveds(CompiledModelTestBase.PrincipalBase @this);
+    }
+}
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
index b366bffcd9..a431b47bce 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
@@ -1,9 +1,13 @@
 // <auto-generated />
 using System;
 using System.Collections.Generic;
+using System.Net;
 using System.Reflection;
+using Microsoft.EntityFrameworkCore.ChangeTracking;
+using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Scaffolding;
 
 #pragma warning disable 219, 612, 618
@@ -51,11 +55,84 @@ public static RuntimeSkipNavigation CreateSkipNavigation1(RuntimeEntityType decl
                 inverse.Inverse = skipNavigation;
             }
 
+            skipNavigation.SetGetter(
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(entity),
+                bool (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(entity) == null,
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> instance) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(instance),
+                bool (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> instance) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(instance) == null);
+            skipNavigation.SetSetter(
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(entity) = value);
+            skipNavigation.SetMaterializationSetter(
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(entity) = value);
+            skipNavigation.SetAccessors(
+                ICollection<CompiledModelTestBase.PrincipalBase> (InternalEntityEntry entry) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(entry.Entity))),
+                ICollection<CompiledModelTestBase.PrincipalBase> (InternalEntityEntry entry) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(entry.Entity))),
+                null,
+                ICollection<CompiledModelTestBase.PrincipalBase> (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<CompiledModelTestBase.PrincipalBase>>(skipNavigation),
+                null);
+            skipNavigation.SetPropertyIndexes(
+                index: 4,
+                originalValueIndex: -1,
+                shadowIndex: -1,
+                relationshipIndex: 6,
+                storeGenerationIndex: -1);
+            skipNavigation.SetCollectionAccessor<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(entity),
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(entity) = ((ICollection<CompiledModelTestBase.PrincipalBase>)(collection)),
+                (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Principals(entity) = ((ICollection<CompiledModelTestBase.PrincipalBase>)(collection)),
+                ICollection<CompiledModelTestBase.PrincipalBase> (CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> entity, Action<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>, ICollection<CompiledModelTestBase.PrincipalBase>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(entity, setter),
+                ICollection<CompiledModelTestBase.PrincipalBase> () => ((ICollection<CompiledModelTestBase.PrincipalBase>)(((ICollection<CompiledModelTestBase.PrincipalBase>)(new HashSet<CompiledModelTestBase.PrincipalBase>(ReferenceEqualityComparer.Instance))))));
             return skipNavigation;
         }
 
         public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
+            var id = runtimeEntityType.FindProperty("Id");
+            var alternateId = runtimeEntityType.FindProperty("AlternateId");
+            var discriminator = runtimeEntityType.FindProperty("Discriminator");
+            var enum1 = runtimeEntityType.FindProperty("Enum1");
+            var enum2 = runtimeEntityType.FindProperty("Enum2");
+            var flagsEnum1 = runtimeEntityType.FindProperty("FlagsEnum1");
+            var flagsEnum2 = runtimeEntityType.FindProperty("FlagsEnum2");
+            var refTypeArray = runtimeEntityType.FindProperty("RefTypeArray");
+            var refTypeEnumerable = runtimeEntityType.FindProperty("RefTypeEnumerable");
+            var refTypeIList = runtimeEntityType.FindProperty("RefTypeIList");
+            var refTypeList = runtimeEntityType.FindProperty("RefTypeList");
+            var valueTypeArray = runtimeEntityType.FindProperty("ValueTypeArray");
+            var valueTypeEnumerable = runtimeEntityType.FindProperty("ValueTypeEnumerable");
+            var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList");
+            var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList");
+            var owned = runtimeEntityType.FindNavigation("Owned");
+            var dependent = runtimeEntityType.FindNavigation("Dependent");
+            var manyOwned = runtimeEntityType.FindNavigation("ManyOwned");
+            runtimeEntityType.SetOriginalValuesFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long?, Guid, string, CompiledModelTestBase.AnEnum, CompiledModelTestBase.AnEnum?, CompiledModelTestBase.AFlagsEnum, CompiledModelTestBase.AFlagsEnum, IPAddress[], IEnumerable<string>, IList<string>, List<IPAddress>, DateTime[], IEnumerable<byte>, IList<byte>, List<short>>((source.GetCurrentValue<long?>(id) == null ? null : ((ValueComparer<long?>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<long?>(id))), ((ValueComparer<Guid>)(((IProperty)alternateId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(alternateId)), (source.GetCurrentValue<string>(discriminator) == null ? null : ((ValueComparer<string>)(((IProperty)discriminator).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(discriminator))), ((ValueComparer<CompiledModelTestBase.AnEnum>)(((IProperty)enum1).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AnEnum>(enum1)), (source.GetCurrentValue<CompiledModelTestBase.AnEnum?>(enum2) == null ? null : ((ValueComparer<CompiledModelTestBase.AnEnum?>)(((IProperty)enum2).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AnEnum?>(enum2))), ((ValueComparer<CompiledModelTestBase.AFlagsEnum>)(((IProperty)flagsEnum1).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum1)), ((ValueComparer<CompiledModelTestBase.AFlagsEnum>)(((IProperty)flagsEnum2).GetValueComparer())).Snapshot(source.GetCurrentValue<CompiledModelTestBase.AFlagsEnum>(flagsEnum2)), (((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))) == null ? null : ((IPAddress[])(((ValueComparer<object>)(((IProperty)refTypeArray).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IPAddress[]>(refTypeArray))))))), (((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))) == null ? null : ((IEnumerable<string>)(((ValueComparer<object>)(((IProperty)refTypeEnumerable).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IEnumerable<string>>(refTypeEnumerable))))))), (((object)(source.GetCurrentValue<IList<string>>(refTypeIList))) == null ? null : ((IList<string>)(((ValueComparer<object>)(((IProperty)refTypeIList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<IList<string>>(refTypeIList))))))), (((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))) == null ? null : ((List<IPAddress>)(((ValueComparer<object>)(((IProperty)refTypeList).GetValueComparer())).Snapshot(((object)(source.GetCurrentValue<List<IPAddress>>(refTypeList))))))), (((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))) == null ? null : ((DateTime[])(((ValueComparer<IEnumerable<DateTime>>)(((IProperty)valueTypeArray).GetValueComparer())).Snapshot(((IEnumerable<DateTime>)(source.GetCurrentValue<DateTime[]>(valueTypeArray))))))), (source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable) == null ? null : ((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeEnumerable).GetValueComparer())).Snapshot(source.GetCurrentValue<IEnumerable<byte>>(valueTypeEnumerable))), (((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))) == null ? null : ((IList<byte>)(((ValueComparer<IEnumerable<byte>>)(((IProperty)valueTypeIList).GetValueComparer())).Snapshot(((IEnumerable<byte>)(source.GetCurrentValue<IList<byte>>(valueTypeIList))))))), (((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))) == null ? null : ((List<short>)(((ValueComparer<IEnumerable<short>>)(((IProperty)valueTypeList).GetValueComparer())).Snapshot(((IEnumerable<short>)(source.GetCurrentValue<List<short>>(valueTypeList))))))))));
+                });
+            runtimeEntityType.SetStoreGeneratedValuesFactory(
+                ISnapshot () => Snapshot.Empty);
+            runtimeEntityType.SetTemporaryValuesFactory(
+                ISnapshot (InternalEntityEntry source) => Snapshot.Empty);
+            runtimeEntityType.SetShadowValuesFactory(
+                ISnapshot (IDictionary<string, object> source) => ((ISnapshot)(new Snapshot<string>((source.ContainsKey("Discriminator") ? ((string)(source["Discriminator"])) : null)))));
+            runtimeEntityType.SetEmptyShadowValuesFactory(
+                ISnapshot () => ((ISnapshot)(new Snapshot<string>(default(string)))));
+            runtimeEntityType.SetRelationshipSnapshotFactory(
+                ISnapshot (InternalEntityEntry source) =>
+                {
+                    var entity8 = ((CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>>)(source.Entity));
+                    return ((ISnapshot)(new Snapshot<long?, Guid, object, object, object, object, object>((source.GetCurrentValue<long?>(id) == null ? null : ((ValueComparer<long?>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long?>(id))), ((ValueComparer<Guid>)(((IProperty)alternateId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(alternateId)), PrincipalBaseUnsafeAccessors._ownedField(entity8), (object)(null), PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.Dependent(entity8), SnapshotFactoryFactory.SnapshotCollection(PrincipalDerivedUnsafeAccessors<CompiledModelTestBase.DependentBase<byte?>>.ManyOwned(entity8)), (object)(null))));
+                });
+            runtimeEntityType.Counts = new PropertyCounts(
+                propertyCount: 15,
+                navigationCount: 5,
+                complexPropertyCount: 0,
+                originalValueCount: 15,
+                shadowCount: 1,
+                relationshipCount: 7,
+                storeGeneratedCount: 0);
 
             Customize(runtimeEntityType);
         }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedUnsafeAccessors.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedUnsafeAccessors.cs
new file mode 100644
index 0000000000..924e4c8262
--- /dev/null
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedUnsafeAccessors.cs
@@ -0,0 +1,23 @@
+// <auto-generated />
+using System.Collections.Generic;
+using System.Runtime.CompilerServices;
+using Microsoft.EntityFrameworkCore.Scaffolding;
+
+#pragma warning disable 219, 612, 618
+#nullable disable
+
+namespace TestNamespace
+{
+    public static class PrincipalDerivedUnsafeAccessors<TDependent>
+        where TDependent : class
+    {
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Dependent>k__BackingField")]
+        public static extern ref TDependent Dependent(CompiledModelTestBase.PrincipalDerived<TDependent> @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "ManyOwned")]
+        public static extern ref ICollection<CompiledModelTestBase.OwnedType> ManyOwned(CompiledModelTestBase.PrincipalDerived<TDependent> @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> Principals(CompiledModelTestBase.PrincipalDerived<TDependent> @this);
+    }
+}
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
index 9d059fbdb9..9c6ca022a1 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
@@ -401,6 +401,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -461,6 +463,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -521,6 +525,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -595,6 +601,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -655,6 +663,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         DateTime (DateTime v) => v),
                     clrType: typeof(DateTime),
                     jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -715,6 +725,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -775,6 +787,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -835,6 +849,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             OwnedComplexProperty.Create(runtimeEntityType);
             var key = runtimeEntityType.AddKey(
@@ -1071,6 +1087,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             new ValueConverter<IPAddress, string>(
                                 string (IPAddress v) => ((object)v).ToString(),
                                 IPAddress (string v) => IPAddress.Parse(v)))));
+                var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+                refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
                 var refTypeEnumerable = complexType.AddProperty(
                     "RefTypeEnumerable",
@@ -1139,6 +1157,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             string (string v) => v),
                         clrType: typeof(string),
                         jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+                refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                 var refTypeIList = complexType.AddProperty(
                     "RefTypeIList",
@@ -1207,6 +1227,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             string (string v) => v),
                         clrType: typeof(string),
                         jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+                refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
                 var refTypeList = complexType.AddProperty(
                     "RefTypeList",
@@ -1289,6 +1311,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             new ValueConverter<IPAddress, string>(
                                 string (IPAddress v) => ((object)v).ToString(),
                                 IPAddress (string v) => IPAddress.Parse(v)))));
+                var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+                refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
                 var valueTypeArray = complexType.AddProperty(
                     "ValueTypeArray",
@@ -1357,6 +1381,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             DateTime (DateTime v) => v),
                         clrType: typeof(DateTime),
                         jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+                var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+                valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
                 var valueTypeEnumerable = complexType.AddProperty(
                     "ValueTypeEnumerable",
@@ -1425,6 +1451,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             byte (byte v) => v),
                         clrType: typeof(byte),
                         jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+                valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                 var valueTypeIList = complexType.AddProperty(
                     "ValueTypeIList",
@@ -1493,6 +1521,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             byte (byte v) => v),
                         clrType: typeof(byte),
                         jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+                valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
                 var valueTypeList = complexType.AddProperty(
                     "ValueTypeList",
@@ -1561,6 +1591,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             short (short v) => v),
                         clrType: typeof(short),
                         jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+                var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+                valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
                 PrincipalComplexProperty.Create(complexType);
                 complexType.AddAnnotation("go", "brr");
@@ -2014,6 +2046,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 new ValueConverter<IPAddress, string>(
                                     string (IPAddress v) => ((object)v).ToString(),
                                     IPAddress (string v) => IPAddress.Parse(v)))));
+                    var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+                    refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
                     var refTypeEnumerable = complexType.AddProperty(
                         "RefTypeEnumerable",
@@ -2084,6 +2118,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 string (string v) => v),
                             clrType: typeof(string),
                             jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                    var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+                    refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                     var refTypeIList = complexType.AddProperty(
                         "RefTypeIList",
@@ -2154,6 +2190,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 string (string v) => v),
                             clrType: typeof(string),
                             jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+                    var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+                    refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
                     var refTypeList = complexType.AddProperty(
                         "RefTypeList",
@@ -2238,6 +2276,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 new ValueConverter<IPAddress, string>(
                                     string (IPAddress v) => ((object)v).ToString(),
                                     IPAddress (string v) => IPAddress.Parse(v)))));
+                    var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+                    refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
                     var valueTypeArray = complexType.AddProperty(
                         "ValueTypeArray",
@@ -2308,6 +2348,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 DateTime (DateTime v) => v),
                             clrType: typeof(DateTime),
                             jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+                    var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+                    valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
                     var valueTypeEnumerable = complexType.AddProperty(
                         "ValueTypeEnumerable",
@@ -2378,6 +2420,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 byte (byte v) => v),
                             clrType: typeof(byte),
                             jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                    var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+                    valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
                     var valueTypeIList = complexType.AddProperty(
                         "ValueTypeIList",
@@ -2448,6 +2492,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 byte (byte v) => v),
                             clrType: typeof(byte),
                             jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+                    var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+                    valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
                     var valueTypeList = complexType.AddProperty(
                         "ValueTypeList",
@@ -2518,6 +2564,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 short (short v) => v),
                             clrType: typeof(short),
                             jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+                    var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+                    valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
                     return complexProperty;
                 }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
index fa1d5745f8..50f899d64e 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
@@ -52,18 +52,21 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
 
             var boolNestedCollection = runtimeEntityType.AddProperty(
                 "BoolNestedCollection",
                 typeof(bool[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolNestedCollectionElementType = boolNestedCollection.SetElementType(typeof(bool[]));
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
                 "BoolReadOnlyCollection",
                 typeof(IReadOnlyCollection<bool>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_boolReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BoolToStringConverterProperty",
@@ -122,12 +125,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
 
             var bytesNestedCollection = runtimeEntityType.AddProperty(
                 "BytesNestedCollection",
                 typeof(byte[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var bytesNestedCollectionElementType = bytesNestedCollection.SetElementType(typeof(byte[][]));
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BytesToStringConverterProperty",
@@ -157,12 +162,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
 
             var charNestedCollection = runtimeEntityType.AddProperty(
                 "CharNestedCollection",
                 typeof(char[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var charNestedCollectionElementType = charNestedCollection.SetElementType(typeof(char[]));
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
                 "CharToStringConverterProperty",
@@ -184,6 +191,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "DateOnlyToStringConverterProperty",
@@ -205,6 +213,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateTime[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                 "DateTimeOffsetToBinaryConverterProperty",
@@ -265,6 +274,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DecimalNumberToBytesConverterProperty",
@@ -294,6 +304,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DoubleNumberToBytesConverterProperty",
@@ -323,6 +334,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
 
             var enum16AsString = runtimeEntityType.AddProperty(
                 "Enum16AsString",
@@ -337,18 +349,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum16AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
 
             var enum16Collection = runtimeEntityType.AddProperty(
                 "Enum16Collection",
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
 
             var enum32 = runtimeEntityType.AddProperty(
                 "Enum32",
@@ -362,6 +379,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
 
             var enum32AsString = runtimeEntityType.AddProperty(
                 "Enum32AsString",
@@ -376,24 +394,30 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum32AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
 
             var enum32Collection = runtimeEntityType.AddProperty(
                 "Enum32Collection",
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
 
             var enum32NestedCollection = runtimeEntityType.AddProperty(
                 "Enum32NestedCollection",
                 typeof(List<CompiledModelTestBase.Enum32>[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32NestedCollectionElementType = enum32NestedCollection.SetElementType(typeof(List<CompiledModelTestBase.Enum32>[]));
 
             var enum64 = runtimeEntityType.AddProperty(
                 "Enum64",
@@ -407,6 +431,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
 
             var enum64AsString = runtimeEntityType.AddProperty(
                 "Enum64AsString",
@@ -421,18 +446,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum64AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
 
             var enum64Collection = runtimeEntityType.AddProperty(
                 "Enum64Collection",
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
 
             var enum8 = runtimeEntityType.AddProperty(
                 "Enum8",
@@ -446,6 +476,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
 
             var enum8AsString = runtimeEntityType.AddProperty(
                 "Enum8AsString",
@@ -460,24 +491,30 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum8AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
 
             var enum8Collection = runtimeEntityType.AddProperty(
                 "Enum8Collection",
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
 
             var enum8NestedCollection = runtimeEntityType.AddProperty(
                 "Enum8NestedCollection",
                 typeof(CompiledModelTestBase.Enum8[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8NestedCollectionElementType = enum8NestedCollection.SetElementType(typeof(CompiledModelTestBase.Enum8[]));
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                 "EnumToNumberConverterProperty",
@@ -507,6 +544,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
 
             var enumU16AsString = runtimeEntityType.AddProperty(
                 "EnumU16AsString",
@@ -521,18 +559,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU16AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
 
             var enumU16Collection = runtimeEntityType.AddProperty(
                 "EnumU16Collection",
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
 
             var enumU32 = runtimeEntityType.AddProperty(
                 "EnumU32",
@@ -546,6 +589,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
 
             var enumU32AsString = runtimeEntityType.AddProperty(
                 "EnumU32AsString",
@@ -560,18 +604,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU32AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
 
             var enumU32Collection = runtimeEntityType.AddProperty(
                 "EnumU32Collection",
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
 
             var enumU64 = runtimeEntityType.AddProperty(
                 "EnumU64",
@@ -585,6 +634,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
 
             var enumU64AsString = runtimeEntityType.AddProperty(
                 "EnumU64AsString",
@@ -599,24 +649,30 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU64AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
 
             var enumU64Collection = runtimeEntityType.AddProperty(
                 "EnumU64Collection",
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
 
             var enumU64NestedCollection = runtimeEntityType.AddProperty(
                 "EnumU64NestedCollection",
                 typeof(CompiledModelTestBase.EnumU64[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64NestedCollectionElementType = enumU64NestedCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64[]));
 
             var enumU8 = runtimeEntityType.AddProperty(
                 "EnumU8",
@@ -630,6 +686,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
 
             var enumU8AsString = runtimeEntityType.AddProperty(
                 "EnumU8AsString",
@@ -644,18 +701,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU8AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
 
             var enumU8Collection = runtimeEntityType.AddProperty(
                 "EnumU8Collection",
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
 
             var @float = runtimeEntityType.AddProperty(
                 "Float",
@@ -669,6 +731,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
 
             var guid = runtimeEntityType.AddProperty(
                 "Guid",
@@ -682,12 +745,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
 
             var guidNestedCollection = runtimeEntityType.AddProperty(
                 "GuidNestedCollection",
                 typeof(ICollection<Guid[][]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var guidNestedCollectionElementType = guidNestedCollection.SetElementType(typeof(Guid[][]));
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "GuidToBytesConverterProperty",
@@ -716,12 +781,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
 
             var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
                 "IPAddressReadOnlyCollection",
                 typeof(IReadOnlyCollection<IPAddress>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_ipAddressReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IPAddressToBytesConverterProperty",
@@ -749,6 +817,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
 
             var int32 = runtimeEntityType.AddProperty(
                 "Int32",
@@ -762,18 +831,21 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
 
             var int32NestedCollection = runtimeEntityType.AddProperty(
                 "Int32NestedCollection",
                 typeof(int[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32NestedCollectionElementType = int32NestedCollection.SetElementType(typeof(int[]));
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
                 "Int32ReadOnlyCollection",
                 typeof(IReadOnlyCollection<int>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_int32ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
 
             var int64 = runtimeEntityType.AddProperty(
                 "Int64",
@@ -787,12 +859,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
 
             var int64NestedCollection = runtimeEntityType.AddProperty(
                 "Int64NestedCollection",
                 typeof(IList<long[]>[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int64NestedCollectionElementType = int64NestedCollection.SetElementType(typeof(IList<long[]>));
 
             var int8 = runtimeEntityType.AddProperty(
                 "Int8",
@@ -806,12 +880,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
 
             var int8NestedCollection = runtimeEntityType.AddProperty(
                 "Int8NestedCollection",
                 typeof(sbyte[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int8NestedCollectionElementType = int8NestedCollection.SetElementType(typeof(sbyte[][]));
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IntNumberToBytesConverterProperty",
@@ -849,6 +925,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
 
             var nullableBytes = runtimeEntityType.AddProperty(
                 "NullableBytes",
@@ -862,12 +940,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
 
             var nullableBytesNestedCollection = runtimeEntityType.AddProperty(
                 "NullableBytesNestedCollection",
                 typeof(byte[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBytesNestedCollectionElementType = nullableBytesNestedCollection.SetElementType(typeof(byte[][]));
 
             var nullableChar = runtimeEntityType.AddProperty(
                 "NullableChar",
@@ -881,6 +962,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
                 "NullableDateOnly",
@@ -894,6 +977,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
 
             var nullableDateTime = runtimeEntityType.AddProperty(
                 "NullableDateTime",
@@ -907,6 +992,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateTime?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
 
             var nullableDecimal = runtimeEntityType.AddProperty(
                 "NullableDecimal",
@@ -920,6 +1007,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
 
             var nullableDouble = runtimeEntityType.AddProperty(
                 "NullableDouble",
@@ -933,6 +1022,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
                 "NullableEnum16",
@@ -946,6 +1037,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
                 "NullableEnum16AsString",
@@ -959,18 +1052,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum16AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
                 "NullableEnum16Collection",
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
                 "NullableEnum32",
@@ -984,6 +1083,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
                 "NullableEnum32AsString",
@@ -997,24 +1098,31 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum32AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
                 "NullableEnum32Collection",
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum32NestedCollection = runtimeEntityType.AddProperty(
                 "NullableEnum32NestedCollection",
                 typeof(CompiledModelTestBase.Enum32?[][][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32NestedCollectionElementType = nullableEnum32NestedCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?[][]));
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
                 "NullableEnum64",
@@ -1028,6 +1136,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
                 "NullableEnum64AsString",
@@ -1041,18 +1151,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum64AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
                 "NullableEnum64Collection",
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
                 "NullableEnum8",
@@ -1066,6 +1182,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
                 "NullableEnum8AsString",
@@ -1079,24 +1197,31 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum8AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
                 "NullableEnum8Collection",
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnum8NestedCollection = runtimeEntityType.AddProperty(
                 "NullableEnum8NestedCollection",
                 typeof(CompiledModelTestBase.Enum8?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8NestedCollectionElementType = nullableEnum8NestedCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?[]));
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
                 "NullableEnumU16",
@@ -1110,6 +1235,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsString",
@@ -1123,18 +1250,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU16Collection",
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
                 "NullableEnumU32",
@@ -1148,6 +1281,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsString",
@@ -1161,18 +1296,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU32Collection",
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
                 "NullableEnumU64",
@@ -1186,6 +1327,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsString",
@@ -1199,24 +1342,31 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU64Collection",
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU64NestedCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU64NestedCollection",
                 typeof(CompiledModelTestBase.EnumU64?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64NestedCollectionElementType = nullableEnumU64NestedCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?[]));
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
                 "NullableEnumU8",
@@ -1230,6 +1380,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsString",
@@ -1243,18 +1395,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU8Collection",
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableFloat = runtimeEntityType.AddProperty(
                 "NullableFloat",
@@ -1268,6 +1426,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
 
             var nullableGuid = runtimeEntityType.AddProperty(
                 "NullableGuid",
@@ -1281,12 +1441,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
 
             var nullableGuidNestedCollection = runtimeEntityType.AddProperty(
                 "NullableGuidNestedCollection",
                 typeof(Guid?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableGuidNestedCollectionElementType = nullableGuidNestedCollection.SetElementType(typeof(Guid?[]));
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
                 "NullableIPAddress",
@@ -1300,6 +1463,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
 
             var nullableInt16 = runtimeEntityType.AddProperty(
                 "NullableInt16",
@@ -1313,6 +1478,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
 
             var nullableInt32 = runtimeEntityType.AddProperty(
                 "NullableInt32",
@@ -1326,12 +1493,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
 
             var nullableInt32NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt32NestedCollection",
                 typeof(int?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt32NestedCollectionElementType = nullableInt32NestedCollection.SetElementType(typeof(int?[]));
 
             var nullableInt64 = runtimeEntityType.AddProperty(
                 "NullableInt64",
@@ -1345,12 +1515,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
 
             var nullableInt64NestedCollection = runtimeEntityType.AddProperty(
                 "NullableInt64NestedCollection",
                 typeof(List<long?[][]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt64NestedCollectionElementType = nullableInt64NestedCollection.SetElementType(typeof(long?[][]));
 
             var nullableInt8 = runtimeEntityType.AddProperty(
                 "NullableInt8",
@@ -1364,6 +1537,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddress",
@@ -1377,12 +1552,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
 
             var nullablePhysicalAddressNestedCollection = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddressNestedCollection",
                 typeof(IEnumerable<PhysicalAddress[][]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullablePhysicalAddressNestedCollectionElementType = nullablePhysicalAddressNestedCollection.SetElementType(typeof(PhysicalAddress[][]));
 
             var nullableString = runtimeEntityType.AddProperty(
                 "NullableString",
@@ -1396,12 +1574,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
 
             var nullableStringNestedCollection = runtimeEntityType.AddProperty(
                 "NullableStringNestedCollection",
                 typeof(string[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableStringNestedCollectionElementType = nullableStringNestedCollection.SetElementType(typeof(string[]));
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
                 "NullableTimeOnly",
@@ -1415,6 +1596,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
                 "NullableTimeSpan",
@@ -1428,6 +1611,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeSpan?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
                 "NullableUInt16",
@@ -1441,6 +1626,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
                 "NullableUInt32",
@@ -1454,6 +1641,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
                 "NullableUInt64",
@@ -1467,6 +1656,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
                 "NullableUInt8",
@@ -1480,12 +1671,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
 
             var nullableUInt8NestedCollection = runtimeEntityType.AddProperty(
                 "NullableUInt8NestedCollection",
                 typeof(byte?[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt8NestedCollectionElementType = nullableUInt8NestedCollection.SetElementType(typeof(byte?[]));
 
             var nullableUri = runtimeEntityType.AddProperty(
                 "NullableUri",
@@ -1499,6 +1693,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
 
             var physicalAddress = runtimeEntityType.AddProperty(
                 "PhysicalAddress",
@@ -1511,6 +1707,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "PhysicalAddressToBytesConverterProperty",
@@ -1537,18 +1734,21 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
 
             var stringNestedCollection = runtimeEntityType.AddProperty(
                 "StringNestedCollection",
                 typeof(string[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringNestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringNestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringNestedCollectionElementType = stringNestedCollection.SetElementType(typeof(string[]));
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
                 "StringReadOnlyCollection",
                 typeof(IReadOnlyCollection<string>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_stringReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBoolConverterProperty",
@@ -1662,6 +1862,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeOnlyToStringConverterProperty",
@@ -1691,6 +1892,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeSpan[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeSpanToStringConverterProperty",
@@ -1720,6 +1922,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
 
             var uInt32 = runtimeEntityType.AddProperty(
                 "UInt32",
@@ -1733,6 +1936,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
 
             var uInt64 = runtimeEntityType.AddProperty(
                 "UInt64",
@@ -1746,6 +1950,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
 
             var uInt8 = runtimeEntityType.AddProperty(
                 "UInt8",
@@ -1765,12 +1970,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<byte[]>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8NestedCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt8NestedCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt8NestedCollectionElementType = uInt8NestedCollection.SetElementType(typeof(byte[]));
 
             var uInt8ReadOnlyCollection = runtimeEntityType.AddProperty(
                 "UInt8ReadOnlyCollection",
                 typeof(IReadOnlyCollection<byte>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_uInt8ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
 
             var uri = runtimeEntityType.AddProperty(
                 "Uri",
@@ -1783,6 +1990,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                 "UriToStringConverterProperty",
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
index ba5cdffb30..4f5b2e88a0 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
@@ -67,6 +67,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -74,6 +75,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -81,6 +83,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -88,6 +91,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -95,6 +99,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -102,6 +107,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -109,6 +115,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -116,6 +123,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
index 1734e6dc9b..e7b86ecf74 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
@@ -66,6 +66,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -74,6 +75,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -82,6 +84,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -90,6 +93,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -98,6 +102,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -106,6 +111,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -114,6 +120,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -122,6 +129,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
index f732733bf0..61feee6969 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
@@ -89,6 +89,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -96,6 +97,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -103,6 +105,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -110,6 +113,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -117,6 +121,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -124,6 +129,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -131,6 +137,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -138,6 +145,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var key = runtimeEntityType.AddKey(
                 new[] { id });
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs
index d7b161d2ec..3ab6993708 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs
@@ -355,6 +355,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -415,6 +417,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -475,6 +479,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         string (string v) => v),
                     clrType: typeof(string),
                     jsonValueReaderWriter: JsonStringReaderWriter.Instance));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -549,6 +555,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -609,6 +617,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         DateTime (DateTime v) => v),
                     clrType: typeof(DateTime),
                     jsonValueReaderWriter: JsonDateTimeReaderWriter.Instance));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -669,6 +679,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -729,6 +741,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     clrType: typeof(byte),
                     jsonValueReaderWriter: JsonByteReaderWriter.Instance));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -789,6 +803,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     clrType: typeof(short),
                     jsonValueReaderWriter: JsonInt16ReaderWriter.Instance));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var key = runtimeEntityType.AddKey(
                 new[] { id });
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/CompiledModelInMemoryTest.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/CompiledModelInMemoryTest.cs
index 73d200e8f1..425d4a1354 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/CompiledModelInMemoryTest.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/CompiledModelInMemoryTest.cs
@@ -506,7 +506,7 @@ protected virtual void AssertCyclesModel(IModel model)
             TestHelpers.ModelAsserter.AssertEqual(principalBaseFk.PrincipalKey.Properties, dependentFk.Properties);
         }
 
-        [ConditionalFact(Skip = "Primitive collections not supported completely")]
+        //[ConditionalFact(Skip = "Primitive collections not supported completely")]
         public override Task BigModel()
             => base.BigModel();
 
diff --git a/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs
index 789bf20c5e..563367bdcf 100644
--- a/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Scaffolding/CompiledModelRelationalTestBase.cs
@@ -16,22 +16,7 @@ public virtual Task BigModel_with_JSON_columns()
         => Test(
             modelBuilder => BuildBigModel(modelBuilder, jsonColumns: true),
             model => AssertBigModel(model, jsonColumns: true),
-            async c =>
-            {
-                c.Set<PrincipalDerived<DependentBase<byte?>>>().Add(
-                    new PrincipalDerived<DependentBase<byte?>>
-                    {
-                        Id = 1,
-                        AlternateId = new Guid(),
-                        Dependent = new DependentDerived<byte?>(1, "one"),
-                        Owned = new OwnedType(c)
-                    });
-
-                await c.SaveChangesAsync();
-
-                var dependent = c.Set<PrincipalDerived<DependentBase<byte?>>>().Include(p => p.Dependent).Single().Dependent!;
-                Assert.Equal("one", ((DependentDerived<byte?>)dependent).GetData());
-            },
+            context => UseBigModel(context, jsonColumns: true),
             options: new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true, ForNativeAot = true });
 
     protected override void BuildBigModel(ModelBuilder modelBuilder, bool jsonColumns)
@@ -163,6 +148,10 @@ protected override void AssertBigModel(IModel model, bool jsonColumns)
         Assert.Equal("ManyTypes", manyTypesType.GetTableName());
         Assert.Null(manyTypesType.GetSchema());
 
+        var ipAddressCollection = manyTypesType.FindProperty(nameof(ManyTypes.IPAddressReadOnlyCollection))!;
+        var ipAddressElementType = ipAddressCollection.GetElementType();
+        Assert.NotNull(ipAddressCollection.GetColumnType());
+
         var principalBase = model.FindEntityType(typeof(PrincipalBase))!;
         Assert.Equal("PrincipalBase", principalBase.GetTableName());
         var principalId = principalBase.FindProperty(nameof(PrincipalBase.Id))!;
diff --git a/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs b/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
index b24acb1775..03ae7397e7 100644
--- a/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
+++ b/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
@@ -88,7 +88,7 @@ protected virtual Task BigModel(bool forNativeAot, [CallerMemberName] string tes
         => Test(
             modelBuilder => BuildBigModel(modelBuilder, jsonColumns: false),
             model => AssertBigModel(model, jsonColumns: false),
-            UseBigModel,
+            context => UseBigModel(context, jsonColumns: false),
             options: new CompiledModelCodeGenerationOptions { UseNullableReferenceTypes = true, ForNativeAot = forNativeAot },
             testName: testName);
 
@@ -290,6 +290,27 @@ protected virtual void AssertBigModel(IModel model, bool jsonColumns)
         Assert.Null(manyTypesType.FindIndexerPropertyInfo());
         Assert.Equal(ChangeTrackingStrategy.Snapshot, manyTypesType.GetChangeTrackingStrategy());
 
+        var ipAddressCollection = manyTypesType.FindProperty(nameof(ManyTypes.IPAddressReadOnlyCollection));
+        if (ipAddressCollection != null)
+        {
+            Assert.True(ipAddressCollection.IsPrimitiveCollection);
+            var ipAddressElementType = ipAddressCollection.GetElementType()!;
+            Assert.Equal(typeof(IPAddress), ipAddressElementType.ClrType);
+            Assert.Same(ipAddressCollection, ipAddressElementType.CollectionProperty);
+            Assert.Equal(typeof(string), ipAddressElementType.GetProviderClrType());
+            Assert.Null(ipAddressElementType.GetMaxLength());
+            Assert.Null(ipAddressElementType.GetPrecision());
+            Assert.Null(ipAddressElementType.GetScale());
+            Assert.Null(ipAddressElementType.IsUnicode());
+            Assert.Equal(ipAddressCollection.GetTypeMapping().ElementTypeMapping?.GetType(), ipAddressElementType.GetTypeMapping().GetType());
+            Assert.NotNull(ipAddressElementType.GetTypeMapping().Comparer);
+            Assert.NotNull(ipAddressElementType.GetTypeMapping().Converter);
+            Assert.NotNull(ipAddressElementType.GetTypeMapping().JsonValueReaderWriter);
+            Assert.NotNull(ipAddressElementType.GetValueComparer());
+            Assert.Null(ipAddressElementType.GetValueConverter());
+            Assert.Null(ipAddressElementType.GetJsonValueReaderWriter());
+        }
+
         Assert.Null(model.FindEntityType(typeof(AbstractBase)));
         var principalBase = model.FindEntityType(typeof(PrincipalBase))!;
         Assert.Equal(typeof(PrincipalBase).FullName, principalBase.Name);
@@ -557,17 +578,16 @@ protected virtual void AssertBigModel(IModel model, bool jsonColumns)
             principalDerived.GetDeclaredReferencingForeignKeys());
     }
 
-    protected virtual async Task UseBigModel(DbContext context)
+    protected virtual async Task UseBigModel(DbContext context, bool jsonColumns)
     {
         var principalDerived = new PrincipalDerived<DependentBase<byte?>>
         {
             AlternateId = new Guid(),
-            Dependent = new DependentBase<byte?>(1),
+            Dependent = new DependentDerived<byte?>(1, "one"),
             Owned = new OwnedType(context)
         };
 
-        var principalBase = context.Model.FindEntityType(typeof(PrincipalBase))!;
-        var principalId = principalBase.FindProperty(nameof(PrincipalBase.Id))!;
+        var principalId = context.Model.FindEntityType(typeof(PrincipalBase))!.FindProperty(nameof(PrincipalBase.Id))!;
         if (principalId.ValueGenerated == ValueGenerated.Never)
         {
             principalDerived.Id = 10;
@@ -575,7 +595,568 @@ protected virtual async Task UseBigModel(DbContext context)
 
         context.Add(principalDerived);
 
+        var types = new ManyTypes()
+        {
+            Bool = true,
+            UInt8 = 1,
+            Int16 = 2,
+            Int32 = 3,
+            Int64 = 4,
+            UInt16 = 5,
+            UInt32 = 6,
+            UInt64 = 7,
+            Char = 'a',
+            Float = 8.0f,
+            Double = 9.0,
+            Decimal = 10.0m,
+            String = "11",
+            Guid = Guid.NewGuid(),
+            DateTime = new DateTime(2023, 10, 10, 10, 10, 10),
+            DateOnly = new DateOnly(2023, 10, 10),
+            TimeOnly = new TimeOnly(10, 10),
+            TimeSpan = new TimeSpan(1),
+            Bytes = [1, 2, 3],
+            Uri = new Uri("https://www.example.com"),
+            PhysicalAddress = PhysicalAddress.Parse("00-00-00-00-00-01"),
+            IPAddress = IPAddress.Parse("127.0.0.1"),
+
+            NullableBool = true,
+            NullableUInt8 = 1,
+            NullableInt16 = 2,
+            NullableInt32 = 3,
+            NullableInt64 = 4,
+            NullableUInt16 = 5,
+            NullableUInt32 = 6,
+            NullableUInt64 = 7,
+            NullableChar = 'a',
+            NullableFloat = 8.0f,
+            NullableDouble = 9.0,
+            NullableDecimal = 10.0m,
+            NullableString = "11",
+            NullableGuid = Guid.NewGuid(),
+            NullableDateTime = new DateTime(2023, 10, 10, 10, 10, 10),
+            NullableDateOnly = new DateOnly(2023, 10, 10),
+            NullableTimeOnly = new TimeOnly(10, 10),
+            NullableTimeSpan = new TimeSpan(1),
+            NullableBytes = [1, 2, 3],
+            NullableUri = new Uri("https://www.example.com"),
+
+            BoolArray = [true],
+            Int8Array = [1],
+            Int16Array = [2],
+            Int32Array = [3],
+            Int64Array = [4],
+            UInt8Array = [1],
+            UInt16Array = [5],
+            UInt32Array = [6],
+            UInt64Array = [7],
+            CharArray = ['a'],
+            FloatArray = [8.0f],
+            DoubleArray = [9.0],
+            DecimalArray = [10.0m],
+            StringArray = ["11"],
+            GuidArray = [Guid.NewGuid()],
+            DateTimeArray = [new DateTime(2023, 10, 10, 10, 10, 10)],
+            DateOnlyArray = [new DateOnly(2023, 10, 10)],
+            TimeOnlyArray = [new TimeOnly(10, 10)],
+            TimeSpanArray = [new TimeSpan(1)],
+            BytesArray = [[1, 2, 3]],
+            UriArray = [new Uri("https://www.example.com")],
+            IPAddressArray = [IPAddress.Parse("127.0.0.1")],
+            PhysicalAddressArray = [PhysicalAddress.Parse("00-00-00-00-00-01")],
+
+            NullableBoolArray = [true],
+            NullableInt8Array = [1],
+            NullableInt16Array = [2],
+            NullableInt32Array = [3],
+            NullableInt64Array = [4],
+            NullableUInt8Array = [1],
+            NullableUInt16Array = [5],
+            NullableUInt32Array = [6],
+            NullableUInt64Array = [7],
+            NullableCharArray = ['a'],
+            NullableFloatArray = [8.0f],
+            NullableDoubleArray = [9.0],
+            NullableDecimalArray = [10.0m],
+            NullableStringArray = ["11"],
+            NullableGuidArray = [Guid.NewGuid()],
+            NullableDateTimeArray = [new DateTime(2023, 10, 10, 10, 10, 10)],
+            NullableDateOnlyArray = [new DateOnly(2023, 10, 10)],
+            NullableTimeOnlyArray = [new TimeOnly(10, 10)],
+            NullableTimeSpanArray = [new TimeSpan(1)],
+            NullableBytesArray = [[1, 2, 3]],
+            NullableUriArray = [new Uri("https://www.example.com")],
+            NullableIPAddressArray = [IPAddress.Parse("127.0.0.1")],
+            NullablePhysicalAddressArray = [PhysicalAddress.Parse("00-00-00-00-00-01")],
+
+            BoolReadOnlyCollection = [true],
+            UInt8ReadOnlyCollection = [1],
+            Int32ReadOnlyCollection = [2],
+            StringReadOnlyCollection = ["3"],
+            IPAddressReadOnlyCollection = [IPAddress.Parse("127.0.0.1")],
+
+            Enum8 = Enum8.One,
+            Enum16 = Enum16.One,
+            Enum32 = Enum32.One,
+            Enum64 = Enum64.One,
+            EnumU8 = EnumU8.One,
+            EnumU16 = EnumU16.One,
+            EnumU32 = EnumU32.One,
+            EnumU64 = EnumU64.One,
+
+            Enum8AsString = Enum8.One,
+            Enum16AsString = Enum16.One,
+            Enum32AsString = Enum32.One,
+            Enum64AsString = Enum64.One,
+            EnumU8AsString = EnumU8.One,
+            EnumU16AsString = EnumU16.One,
+            EnumU32AsString = EnumU32.One,
+            EnumU64AsString = EnumU64.One,
+
+            Enum8Collection = [Enum8.One],
+            Enum16Collection = [Enum16.One],
+            Enum32Collection = [Enum32.One],
+            Enum64Collection = [Enum64.One],
+            EnumU8Collection = [EnumU8.One],
+            EnumU16Collection = [EnumU16.One],
+            EnumU32Collection = [EnumU32.One],
+            EnumU64Collection = [EnumU64.One],
+
+            Enum8AsStringCollection = [Enum8.One],
+            Enum16AsStringCollection = [Enum16.One],
+            Enum32AsStringCollection = [Enum32.One],
+            Enum64AsStringCollection = [Enum64.One],
+            EnumU8AsStringCollection = [EnumU8.One],
+            EnumU16AsStringCollection = [EnumU16.One],
+            EnumU32AsStringCollection = [EnumU32.One],
+            EnumU64AsStringCollection = [EnumU64.One],
+
+            NullableEnum8Collection = [Enum8.One],
+            NullableEnum16Collection = [Enum16.One],
+            NullableEnum32Collection = [Enum32.One],
+            NullableEnum64Collection = [Enum64.One],
+            NullableEnumU8Collection = [EnumU8.One],
+            NullableEnumU16Collection = [EnumU16.One],
+            NullableEnumU32Collection = [EnumU32.One],
+            NullableEnumU64Collection = [EnumU64.One],
+
+            NullableEnum8AsStringCollection = [Enum8.One],
+            NullableEnum16AsStringCollection = [Enum16.One],
+            NullableEnum32AsStringCollection = [Enum32.One],
+            NullableEnum64AsStringCollection = [Enum64.One],
+            NullableEnumU8AsStringCollection = [EnumU8.One],
+            NullableEnumU16AsStringCollection = [EnumU16.One],
+            NullableEnumU32AsStringCollection = [EnumU32.One],
+            NullableEnumU64AsStringCollection = [EnumU64.One],
+
+            Enum8Array = [Enum8.One],
+            Enum16Array = [Enum16.One],
+            Enum32Array = [Enum32.One],
+            Enum64Array = [Enum64.One],
+            EnumU8Array = [EnumU8.One],
+            EnumU16Array = [EnumU16.One],
+            EnumU32Array = [EnumU32.One],
+            EnumU64Array = [EnumU64.One],
+
+            Enum8AsStringArray = [Enum8.One],
+            Enum16AsStringArray = [Enum16.One],
+            Enum32AsStringArray = [Enum32.One],
+            Enum64AsStringArray = [Enum64.One],
+            EnumU8AsStringArray = [EnumU8.One],
+            EnumU16AsStringArray = [EnumU16.One],
+            EnumU32AsStringArray = [EnumU32.One],
+            EnumU64AsStringArray = [EnumU64.One],
+
+            NullableEnum8Array = [Enum8.One],
+            NullableEnum16Array = [Enum16.One],
+            NullableEnum32Array = [Enum32.One],
+            NullableEnum64Array = [Enum64.One],
+            NullableEnumU8Array = [EnumU8.One],
+            NullableEnumU16Array = [EnumU16.One],
+            NullableEnumU32Array = [EnumU32.One],
+            NullableEnumU64Array = [EnumU64.One],
+
+            NullableEnum8AsStringArray = [Enum8.One],
+            NullableEnum16AsStringArray = [Enum16.One],
+            NullableEnum32AsStringArray = [Enum32.One],
+            NullableEnum64AsStringArray = [Enum64.One],
+            NullableEnumU8AsStringArray = [EnumU8.One],
+            NullableEnumU16AsStringArray = [EnumU16.One],
+            NullableEnumU32AsStringArray = [EnumU32.One],
+            NullableEnumU64AsStringArray = [EnumU64.One],
+
+            BoolNestedCollection = [[true]],
+            UInt8NestedCollection = [[9]],
+            Int8NestedCollection = [[[9]]],
+            Int32NestedCollection = [[9]],
+            Int64NestedCollection = [[[9L]]],
+            CharNestedCollection = [['a']],
+            StringNestedCollection = [["11"]],
+            GuidNestedCollection = [[[Guid.NewGuid()]]],
+            BytesNestedCollection = [[[1, 2, 3]]],
+            NullableUInt8NestedCollection = [[9]],
+            NullableInt32NestedCollection = [[9]],
+            NullableInt64NestedCollection = [[[9L]]],
+            NullableStringNestedCollection = [["11"]],
+            NullableGuidNestedCollection = [[Guid.NewGuid()]],
+            NullableBytesNestedCollection = [[[1, 2, 3]]],
+            NullablePhysicalAddressNestedCollection = [[[PhysicalAddress.Parse("00-00-00-00-00-01")]]],
+
+            Enum8NestedCollection = [[Enum8.One]],
+            Enum32NestedCollection = [[[Enum32.One]]],
+            EnumU64NestedCollection = [[EnumU64.One]],
+            NullableEnum8NestedCollection = [[Enum8.One]],
+            NullableEnum32NestedCollection = [[[Enum32.One]]],
+            NullableEnumU64NestedCollection = [[EnumU64.One]],
+
+            BoolToStringConverterProperty = true,
+            BoolToTwoValuesConverterProperty = true,
+            BoolToZeroOneConverterProperty = true,
+            BytesToStringConverterProperty = [1, 2, 3],
+            CastingConverterProperty = 1,
+            CharToStringConverterProperty = 'a',
+            DateOnlyToStringConverterProperty = new DateOnly(2023, 10, 10),
+            DateTimeOffsetToBinaryConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.Zero),
+            DateTimeOffsetToBytesConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.Zero),
+            DateTimeOffsetToStringConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.Zero),
+            DateTimeToBinaryConverterProperty = new DateTime(2023, 10, 10, 10, 10, 10),
+            DateTimeToStringConverterProperty = new DateTime(2023, 10, 10, 10, 10, 10),
+            EnumToNumberConverterProperty = Enum32.One,
+            EnumToStringConverterProperty = Enum32.One,
+            GuidToBytesConverterProperty = Guid.NewGuid(),
+            GuidToStringConverterProperty = Guid.NewGuid(),
+            IPAddressToBytesConverterProperty = IPAddress.Parse("127.0.0.1"),
+            IPAddressToStringConverterProperty = IPAddress.Parse("127.0.0.1"),
+            IntNumberToBytesConverterProperty = 1,
+            DecimalNumberToBytesConverterProperty = 1.0m,
+            DoubleNumberToBytesConverterProperty = 1.0,
+            IntNumberToStringConverterProperty = 1,
+            DecimalNumberToStringConverterProperty = 1.0m,
+            DoubleNumberToStringConverterProperty = 1.0,
+            PhysicalAddressToBytesConverterProperty = PhysicalAddress.Parse("00-00-00-00-00-01"),
+            PhysicalAddressToStringConverterProperty = PhysicalAddress.Parse("00-00-00-00-00-01"),
+            StringToBoolConverterProperty = "true",
+            StringToBytesConverterProperty = "1",
+            StringToCharConverterProperty = "a",
+            StringToDateOnlyConverterProperty = new DateOnly(2023, 10, 10).ToString(@"yyyy\-MM\-dd"),
+            StringToDateTimeConverterProperty = new DateTime(2023, 10, 10, 10, 10, 10).ToString(@"yyyy\-MM\-dd HH\:mm\:ss.FFFFFFF"),
+            StringToDateTimeOffsetConverterProperty = new DateTimeOffset(2023, 10, 10, 10, 10, 10, TimeSpan.FromHours(1))
+                .ToString(@"yyyy\-MM\-dd HH\:mm\:ss.FFFFFFFzzz"),
+            StringToEnumConverterProperty = "One",
+            StringToGuidConverterProperty = Guid.NewGuid().ToString(),
+            StringToIntNumberConverterProperty = "1",
+            StringToDecimalNumberConverterProperty = "1.0",
+            StringToDoubleNumberConverterProperty = "1.0",
+            StringToTimeOnlyConverterProperty = new TimeOnly(10, 10).ToString("o"),
+            StringToTimeSpanConverterProperty = new TimeSpan(1).ToString("c"),
+            StringToUriConverterProperty = "https://www.example.com/",
+            TimeOnlyToStringConverterProperty = new TimeOnly(10, 10),
+            TimeOnlyToTicksConverterProperty = new TimeOnly(10, 10),
+            TimeSpanToStringConverterProperty = new TimeSpan(1),
+            TimeSpanToTicksConverterProperty = new TimeSpan(1),
+            UriToStringConverterProperty = new Uri("https://www.example.com/"),
+            NullIntToNullStringConverterProperty = null
+        };
+
+        var manyTypesId = context.Model.FindEntityType(typeof(ManyTypes))!.FindProperty(nameof(ManyTypes.Id))!;
+        if (manyTypesId.ValueGenerated == ValueGenerated.Never)
+        {
+            types.Id = new ManyTypesId(17);
+        }
+
+        context.Add(types);
+
         await context.SaveChangesAsync();
+
+        var dependent = context.Set<PrincipalDerived<DependentBase<byte?>>>().Include(p => p.Dependent).Single().Dependent!;
+        Assert.Equal("one", ((DependentDerived<byte?>)dependent).GetData());
+
+        var typesFromStore = context.Set<ManyTypes>().OrderBy(m => m.Id).First();
+        AssertEqual(types, typesFromStore, jsonColumns);
+    }
+
+    protected virtual void AssertEqual(ManyTypes types, ManyTypes otherTypes, bool jsonColumns)
+    {
+        Assert.Equal(types.Id.Id, otherTypes.Id.Id);
+        Assert.Equal(types.Bool, otherTypes.Bool);
+        Assert.Equal(types.UInt8, otherTypes.UInt8);
+        Assert.Equal(types.UInt16, otherTypes.UInt16);
+        Assert.Equal(types.UInt32, otherTypes.UInt32);
+        Assert.Equal(types.UInt64, otherTypes.UInt64);
+        Assert.Equal(types.Int8, otherTypes.Int8);
+        Assert.Equal(types.Int16, otherTypes.Int16);
+        Assert.Equal(types.Int32, otherTypes.Int32);
+        Assert.Equal(types.Int64, otherTypes.Int64);
+        Assert.Equal(types.Char, otherTypes.Char);
+        Assert.Equal(types.Decimal, otherTypes.Decimal);
+        Assert.Equal(types.Double, otherTypes.Double);
+        Assert.Equal(types.Float, otherTypes.Float);
+        Assert.Equal(types.Guid, otherTypes.Guid);
+        Assert.Equal(types.DateTime, otherTypes.DateTime);
+        Assert.Equal(types.DateOnly, otherTypes.DateOnly);
+        Assert.Equal(types.TimeOnly, otherTypes.TimeOnly);
+        Assert.Equal(types.TimeSpan, otherTypes.TimeSpan);
+        Assert.Equal(types.String, otherTypes.String);
+        Assert.Equal(types.Bytes, otherTypes.Bytes);
+        Assert.Equal(types.Uri, otherTypes.Uri);
+        Assert.Equal(types.IPAddress, otherTypes.IPAddress);
+        Assert.Equal(types.PhysicalAddress, otherTypes.PhysicalAddress);
+
+        Assert.Equal(types.NullableBool, otherTypes.NullableBool);
+        Assert.Equal(types.NullableUInt8, otherTypes.NullableUInt8);
+        Assert.Equal(types.NullableUInt16, otherTypes.NullableUInt16);
+        Assert.Equal(types.NullableUInt32, otherTypes.NullableUInt32);
+        Assert.Equal(types.NullableUInt64, otherTypes.NullableUInt64);
+        Assert.Equal(types.NullableInt8, otherTypes.NullableInt8);
+        Assert.Equal(types.NullableInt16, otherTypes.NullableInt16);
+        Assert.Equal(types.NullableInt32, otherTypes.NullableInt32);
+        Assert.Equal(types.NullableInt64, otherTypes.NullableInt64);
+        Assert.Equal(types.NullableChar, otherTypes.NullableChar);
+        Assert.Equal(types.NullableDecimal, otherTypes.NullableDecimal);
+        Assert.Equal(types.NullableDouble, otherTypes.NullableDouble);
+        Assert.Equal(types.NullableFloat, otherTypes.NullableFloat);
+        Assert.Equal(types.NullableGuid, otherTypes.NullableGuid);
+        Assert.Equal(types.NullableDateTime, otherTypes.NullableDateTime);
+        Assert.Equal(types.NullableDateOnly, otherTypes.NullableDateOnly);
+        Assert.Equal(types.NullableTimeOnly, otherTypes.NullableTimeOnly);
+        Assert.Equal(types.NullableTimeSpan, otherTypes.NullableTimeSpan);
+        Assert.Equal(types.NullableString, otherTypes.NullableString);
+        Assert.Equal(types.NullableBytes, otherTypes.NullableBytes);
+        Assert.Equal(types.NullableUri, otherTypes.NullableUri);
+        Assert.Equal(types.NullableIPAddress, otherTypes.NullableIPAddress);
+        Assert.Equal(types.NullablePhysicalAddress, otherTypes.NullablePhysicalAddress);
+
+        Assert.Equal(types.BoolArray, otherTypes.BoolArray);
+        Assert.Equal(types.UInt8Array, otherTypes.UInt8Array);
+        Assert.Equal(types.UInt16Array, otherTypes.UInt16Array);
+        Assert.Equal(types.UInt32Array, otherTypes.UInt32Array);
+        Assert.Equal(types.UInt64Array, otherTypes.UInt64Array);
+        Assert.Equal(types.Int8Array, otherTypes.Int8Array);
+        Assert.Equal(types.Int16Array, otherTypes.Int16Array);
+        Assert.Equal(types.Int32Array, otherTypes.Int32Array);
+        Assert.Equal(types.Int64Array, otherTypes.Int64Array);
+        Assert.Equal(types.CharArray, otherTypes.CharArray);
+        Assert.Equal(types.DecimalArray, otherTypes.DecimalArray);
+        Assert.Equal(types.DoubleArray, otherTypes.DoubleArray);
+        Assert.Equal(types.FloatArray, otherTypes.FloatArray);
+        Assert.Equal(types.GuidArray, otherTypes.GuidArray);
+        Assert.Equal(types.DateTimeArray, otherTypes.DateTimeArray);
+        Assert.Equal(types.DateOnlyArray, otherTypes.DateOnlyArray);
+        Assert.Equal(types.TimeOnlyArray, otherTypes.TimeOnlyArray);
+        Assert.Equal(types.TimeSpanArray, otherTypes.TimeSpanArray);
+        Assert.Equal(types.StringArray, otherTypes.StringArray);
+        Assert.Equal(types.BytesArray, otherTypes.BytesArray);
+        Assert.Equal(types.UriArray, otherTypes.UriArray);
+        Assert.Equal(types.IPAddressArray, otherTypes.IPAddressArray);
+        Assert.Equal(types.PhysicalAddressArray, otherTypes.PhysicalAddressArray);
+
+        Assert.Equal(types.NullableBoolArray, otherTypes.NullableBoolArray);
+        Assert.Equal(types.NullableUInt8Array, otherTypes.NullableUInt8Array);
+        Assert.Equal(types.NullableUInt16Array, otherTypes.NullableUInt16Array);
+        Assert.Equal(types.NullableUInt32Array, otherTypes.NullableUInt32Array);
+        Assert.Equal(types.NullableUInt64Array, otherTypes.NullableUInt64Array);
+        Assert.Equal(types.NullableInt8Array, otherTypes.NullableInt8Array);
+        Assert.Equal(types.NullableInt16Array, otherTypes.NullableInt16Array);
+        Assert.Equal(types.NullableInt32Array, otherTypes.NullableInt32Array);
+        Assert.Equal(types.NullableInt64Array, otherTypes.NullableInt64Array);
+        Assert.Equal(types.NullableCharArray, otherTypes.NullableCharArray);
+        Assert.Equal(types.NullableDecimalArray, otherTypes.NullableDecimalArray);
+        Assert.Equal(types.NullableDoubleArray, otherTypes.NullableDoubleArray);
+        Assert.Equal(types.NullableFloatArray, otherTypes.NullableFloatArray);
+        Assert.Equal(types.NullableGuidArray, otherTypes.NullableGuidArray);
+        Assert.Equal(types.NullableDateTimeArray, otherTypes.NullableDateTimeArray);
+        Assert.Equal(types.NullableDateOnlyArray, otherTypes.NullableDateOnlyArray);
+        Assert.Equal(types.NullableTimeOnlyArray, otherTypes.NullableTimeOnlyArray);
+        Assert.Equal(types.NullableTimeSpanArray, otherTypes.NullableTimeSpanArray);
+        Assert.Equal(types.NullableStringArray, otherTypes.NullableStringArray);
+        Assert.Equal(types.NullableBytesArray, otherTypes.NullableBytesArray);
+        Assert.Equal(types.NullableUriArray, otherTypes.NullableUriArray);
+        Assert.Equal(types.NullableIPAddressArray, otherTypes.NullableIPAddressArray);
+        Assert.Equal(types.NullablePhysicalAddressArray, otherTypes.NullablePhysicalAddressArray);
+
+        Assert.Equal(types.BoolReadOnlyCollection, otherTypes.BoolReadOnlyCollection);
+        Assert.Equal(types.UInt8ReadOnlyCollection, otherTypes.UInt8ReadOnlyCollection);
+        Assert.Equal(types.Int32ReadOnlyCollection, otherTypes.Int32ReadOnlyCollection);
+        Assert.Equal(types.StringReadOnlyCollection, otherTypes.StringReadOnlyCollection);
+        Assert.Equal(types.IPAddressReadOnlyCollection, otherTypes.IPAddressReadOnlyCollection);
+
+        Assert.Equal(types.Enum8, otherTypes.Enum8);
+        Assert.Equal(types.Enum16, otherTypes.Enum16);
+        Assert.Equal(types.Enum32, otherTypes.Enum32);
+        Assert.Equal(types.Enum64, otherTypes.Enum64);
+        Assert.Equal(types.EnumU8, otherTypes.EnumU8);
+        Assert.Equal(types.EnumU16, otherTypes.EnumU16);
+        Assert.Equal(types.EnumU32, otherTypes.EnumU32);
+        Assert.Equal(types.EnumU64, otherTypes.EnumU64);
+
+        Assert.Equal(types.Enum8AsString, otherTypes.Enum8AsString);
+        Assert.Equal(types.Enum16AsString, otherTypes.Enum16AsString);
+        Assert.Equal(types.Enum32AsString, otherTypes.Enum32AsString);
+        Assert.Equal(types.Enum64AsString, otherTypes.Enum64AsString);
+        Assert.Equal(types.EnumU8AsString, otherTypes.EnumU8AsString);
+        Assert.Equal(types.EnumU16AsString, otherTypes.EnumU16AsString);
+        Assert.Equal(types.EnumU32AsString, otherTypes.EnumU32AsString);
+        Assert.Equal(types.EnumU64AsString, otherTypes.EnumU64AsString);
+
+        Assert.Equal(types.NullableEnum8, otherTypes.NullableEnum8);
+        Assert.Equal(types.NullableEnum16, otherTypes.NullableEnum16);
+        Assert.Equal(types.NullableEnum32, otherTypes.NullableEnum32);
+        Assert.Equal(types.NullableEnum64, otherTypes.NullableEnum64);
+        Assert.Equal(types.NullableEnumU8, otherTypes.NullableEnumU8);
+        Assert.Equal(types.NullableEnumU16, otherTypes.NullableEnumU16);
+        Assert.Equal(types.NullableEnumU32, otherTypes.NullableEnumU32);
+        Assert.Equal(types.NullableEnumU64, otherTypes.NullableEnumU64);
+
+        Assert.Equal(types.NullableEnum8AsString, otherTypes.NullableEnum8AsString);
+        Assert.Equal(types.NullableEnum16AsString, otherTypes.NullableEnum16AsString);
+        Assert.Equal(types.NullableEnum32AsString, otherTypes.NullableEnum32AsString);
+        Assert.Equal(types.NullableEnum64AsString, otherTypes.NullableEnum64AsString);
+        Assert.Equal(types.NullableEnumU8AsString, otherTypes.NullableEnumU8AsString);
+        Assert.Equal(types.NullableEnumU16AsString, otherTypes.NullableEnumU16AsString);
+        Assert.Equal(types.NullableEnumU32AsString, otherTypes.NullableEnumU32AsString);
+        Assert.Equal(types.NullableEnumU64AsString, otherTypes.NullableEnumU64AsString);
+
+        Assert.Equal(types.Enum8Collection, otherTypes.Enum8Collection);
+        Assert.Equal(types.Enum16Collection, otherTypes.Enum16Collection);
+        Assert.Equal(types.Enum32Collection, otherTypes.Enum32Collection);
+        Assert.Equal(types.Enum64Collection, otherTypes.Enum64Collection);
+        Assert.Equal(types.EnumU8Collection, otherTypes.EnumU8Collection);
+        Assert.Equal(types.EnumU16Collection, otherTypes.EnumU16Collection);
+        Assert.Equal(types.EnumU32Collection, otherTypes.EnumU32Collection);
+        Assert.Equal(types.EnumU64Collection, otherTypes.EnumU64Collection);
+
+        Assert.Equal(types.Enum8AsStringCollection, otherTypes.Enum8AsStringCollection);
+        Assert.Equal(types.Enum16AsStringCollection, otherTypes.Enum16AsStringCollection);
+        Assert.Equal(types.Enum32AsStringCollection, otherTypes.Enum32AsStringCollection);
+        Assert.Equal(types.Enum64AsStringCollection, otherTypes.Enum64AsStringCollection);
+        Assert.Equal(types.EnumU8AsStringCollection, otherTypes.EnumU8AsStringCollection);
+        Assert.Equal(types.EnumU16AsStringCollection, otherTypes.EnumU16AsStringCollection);
+        Assert.Equal(types.EnumU32AsStringCollection, otherTypes.EnumU32AsStringCollection);
+        Assert.Equal(types.EnumU64AsStringCollection, otherTypes.EnumU64AsStringCollection);
+
+        Assert.Equal(types.NullableEnum8Collection, otherTypes.NullableEnum8Collection);
+        Assert.Equal(types.NullableEnum16Collection, otherTypes.NullableEnum16Collection);
+        Assert.Equal(types.NullableEnum32Collection, otherTypes.NullableEnum32Collection);
+        Assert.Equal(types.NullableEnum64Collection, otherTypes.NullableEnum64Collection);
+        Assert.Equal(types.NullableEnumU8Collection, otherTypes.NullableEnumU8Collection);
+        Assert.Equal(types.NullableEnumU16Collection, otherTypes.NullableEnumU16Collection);
+        Assert.Equal(types.NullableEnumU32Collection, otherTypes.NullableEnumU32Collection);
+        Assert.Equal(types.NullableEnumU64Collection, otherTypes.NullableEnumU64Collection);
+
+        Assert.Equal(types.NullableEnum8AsStringCollection, otherTypes.NullableEnum8AsStringCollection);
+        Assert.Equal(types.NullableEnum16AsStringCollection, otherTypes.NullableEnum16AsStringCollection);
+        Assert.Equal(types.NullableEnum32AsStringCollection, otherTypes.NullableEnum32AsStringCollection);
+        Assert.Equal(types.NullableEnum64AsStringCollection, otherTypes.NullableEnum64AsStringCollection);
+        Assert.Equal(types.NullableEnumU8AsStringCollection, otherTypes.NullableEnumU8AsStringCollection);
+        Assert.Equal(types.NullableEnumU16AsStringCollection, otherTypes.NullableEnumU16AsStringCollection);
+        Assert.Equal(types.NullableEnumU32AsStringCollection, otherTypes.NullableEnumU32AsStringCollection);
+        Assert.Equal(types.NullableEnumU64AsStringCollection, otherTypes.NullableEnumU64AsStringCollection);
+
+        Assert.Equal(types.Enum8Array, otherTypes.Enum8Array);
+        Assert.Equal(types.Enum16Array, otherTypes.Enum16Array);
+        Assert.Equal(types.Enum32Array, otherTypes.Enum32Array);
+        Assert.Equal(types.Enum64Array, otherTypes.Enum64Array);
+        Assert.Equal(types.EnumU8Array, otherTypes.EnumU8Array);
+        Assert.Equal(types.EnumU16Array, otherTypes.EnumU16Array);
+        Assert.Equal(types.EnumU32Array, otherTypes.EnumU32Array);
+        Assert.Equal(types.EnumU64Array, otherTypes.EnumU64Array);
+
+        Assert.Equal(types.Enum8AsStringArray, otherTypes.Enum8AsStringArray);
+        Assert.Equal(types.Enum16AsStringArray, otherTypes.Enum16AsStringArray);
+        Assert.Equal(types.Enum32AsStringArray, otherTypes.Enum32AsStringArray);
+        Assert.Equal(types.Enum64AsStringArray, otherTypes.Enum64AsStringArray);
+        Assert.Equal(types.EnumU8AsStringArray, otherTypes.EnumU8AsStringArray);
+        Assert.Equal(types.EnumU16AsStringArray, otherTypes.EnumU16AsStringArray);
+        Assert.Equal(types.EnumU32AsStringArray, otherTypes.EnumU32AsStringArray);
+        Assert.Equal(types.EnumU64AsStringArray, otherTypes.EnumU64AsStringArray);
+
+        Assert.Equal(types.NullableEnum8Array, otherTypes.NullableEnum8Array);
+        Assert.Equal(types.NullableEnum16Array, otherTypes.NullableEnum16Array);
+        Assert.Equal(types.NullableEnum32Array, otherTypes.NullableEnum32Array);
+        Assert.Equal(types.NullableEnum64Array, otherTypes.NullableEnum64Array);
+        Assert.Equal(types.NullableEnumU8Array, otherTypes.NullableEnumU8Array);
+        Assert.Equal(types.NullableEnumU16Array, otherTypes.NullableEnumU16Array);
+        Assert.Equal(types.NullableEnumU32Array, otherTypes.NullableEnumU32Array);
+        Assert.Equal(types.NullableEnumU64Array, otherTypes.NullableEnumU64Array);
+
+        Assert.Equal(types.NullableEnum8AsStringArray, otherTypes.NullableEnum8AsStringArray);
+        Assert.Equal(types.NullableEnum16AsStringArray, otherTypes.NullableEnum16AsStringArray);
+        Assert.Equal(types.NullableEnum32AsStringArray, otherTypes.NullableEnum32AsStringArray);
+        Assert.Equal(types.NullableEnum64AsStringArray, otherTypes.NullableEnum64AsStringArray);
+        Assert.Equal(types.NullableEnumU8AsStringArray, otherTypes.NullableEnumU8AsStringArray);
+        Assert.Equal(types.NullableEnumU16AsStringArray, otherTypes.NullableEnumU16AsStringArray);
+        Assert.Equal(types.NullableEnumU32AsStringArray, otherTypes.NullableEnumU32AsStringArray);
+        Assert.Equal(types.NullableEnumU64AsStringArray, otherTypes.NullableEnumU64AsStringArray);
+
+        Assert.Equal(types.BoolNestedCollection, otherTypes.BoolNestedCollection);
+        Assert.Equal(types.UInt8NestedCollection, otherTypes.UInt8NestedCollection);
+        Assert.Equal(types.Int8NestedCollection, otherTypes.Int8NestedCollection);
+        Assert.Equal(types.Int32NestedCollection, otherTypes.Int32NestedCollection);
+        Assert.Equal(types.Int64NestedCollection, otherTypes.Int64NestedCollection);
+        Assert.Equal(types.CharNestedCollection, otherTypes.CharNestedCollection);
+        Assert.Equal(types.GuidNestedCollection, otherTypes.GuidNestedCollection);
+        Assert.Equal(types.StringNestedCollection, otherTypes.StringNestedCollection);
+        Assert.Equal(types.BytesNestedCollection, otherTypes.BytesNestedCollection);
+
+        Assert.Equal(types.NullableUInt8NestedCollection, otherTypes.NullableUInt8NestedCollection);
+        Assert.Equal(types.NullableInt32NestedCollection, otherTypes.NullableInt32NestedCollection);
+        Assert.Equal(types.NullableInt64NestedCollection, otherTypes.NullableInt64NestedCollection);
+        Assert.Equal(types.NullableGuidNestedCollection, otherTypes.NullableGuidNestedCollection);
+        Assert.Equal(types.NullableStringNestedCollection, otherTypes.NullableStringNestedCollection);
+        Assert.Equal(types.NullableBytesNestedCollection, otherTypes.NullableBytesNestedCollection);
+        Assert.Equal(types.NullablePhysicalAddressNestedCollection, otherTypes.NullablePhysicalAddressNestedCollection);
+
+        Assert.Equal(types.Enum8NestedCollection, otherTypes.Enum8NestedCollection);
+        Assert.Equal(types.Enum32NestedCollection, otherTypes.Enum32NestedCollection);
+        Assert.Equal(types.EnumU64NestedCollection, otherTypes.EnumU64NestedCollection);
+        Assert.Equal(types.NullableEnum8NestedCollection, otherTypes.NullableEnum8NestedCollection);
+        Assert.Equal(types.NullableEnum32NestedCollection, otherTypes.NullableEnum32NestedCollection);
+        Assert.Equal(types.NullableEnumU64NestedCollection, otherTypes.NullableEnumU64NestedCollection);
+
+        Assert.Equal(types.BoolToStringConverterProperty, otherTypes.BoolToStringConverterProperty);
+        Assert.Equal(types.BoolToTwoValuesConverterProperty, otherTypes.BoolToTwoValuesConverterProperty);
+        Assert.Equal(types.BoolToZeroOneConverterProperty, otherTypes.BoolToZeroOneConverterProperty);
+        Assert.Equal(types.BytesToStringConverterProperty, otherTypes.BytesToStringConverterProperty);
+        Assert.Equal(types.CastingConverterProperty, otherTypes.CastingConverterProperty);
+        Assert.Equal(types.CharToStringConverterProperty, otherTypes.CharToStringConverterProperty);
+        Assert.Equal(types.DateOnlyToStringConverterProperty, otherTypes.DateOnlyToStringConverterProperty);
+        Assert.Equal(types.DateTimeOffsetToBinaryConverterProperty, otherTypes.DateTimeOffsetToBinaryConverterProperty);
+        Assert.Equal(types.DateTimeOffsetToBytesConverterProperty, otherTypes.DateTimeOffsetToBytesConverterProperty);
+        Assert.Equal(types.DateTimeOffsetToStringConverterProperty, otherTypes.DateTimeOffsetToStringConverterProperty);
+        Assert.Equal(types.DateTimeToBinaryConverterProperty, otherTypes.DateTimeToBinaryConverterProperty);
+        Assert.Equal(types.DateTimeToStringConverterProperty, otherTypes.DateTimeToStringConverterProperty);
+        Assert.Equal(types.EnumToNumberConverterProperty, otherTypes.EnumToNumberConverterProperty);
+        Assert.Equal(types.EnumToStringConverterProperty, otherTypes.EnumToStringConverterProperty);
+        Assert.Equal(types.GuidToBytesConverterProperty, otherTypes.GuidToBytesConverterProperty);
+        Assert.Equal(types.GuidToStringConverterProperty, otherTypes.GuidToStringConverterProperty);
+        Assert.Equal(types.IPAddressToBytesConverterProperty, otherTypes.IPAddressToBytesConverterProperty);
+        Assert.Equal(types.IPAddressToStringConverterProperty, otherTypes.IPAddressToStringConverterProperty);
+        Assert.Equal(types.IntNumberToBytesConverterProperty, otherTypes.IntNumberToBytesConverterProperty);
+        Assert.Equal(types.DecimalNumberToBytesConverterProperty, otherTypes.DecimalNumberToBytesConverterProperty);
+        Assert.Equal(types.DoubleNumberToBytesConverterProperty, otherTypes.DoubleNumberToBytesConverterProperty);
+        Assert.Equal(types.IntNumberToStringConverterProperty, otherTypes.IntNumberToStringConverterProperty);
+        Assert.Equal(types.DecimalNumberToStringConverterProperty, otherTypes.DecimalNumberToStringConverterProperty);
+        Assert.Equal(types.DoubleNumberToStringConverterProperty, otherTypes.DoubleNumberToStringConverterProperty);
+        Assert.Equal(types.PhysicalAddressToBytesConverterProperty, otherTypes.PhysicalAddressToBytesConverterProperty);
+        Assert.Equal(types.PhysicalAddressToStringConverterProperty, otherTypes.PhysicalAddressToStringConverterProperty);
+        Assert.Equal(types.StringToBoolConverterProperty, otherTypes.StringToBoolConverterProperty);
+        Assert.Equal(types.StringToBytesConverterProperty, otherTypes.StringToBytesConverterProperty);
+        Assert.Equal(types.StringToCharConverterProperty, otherTypes.StringToCharConverterProperty);
+        Assert.Equal(types.StringToDateOnlyConverterProperty, otherTypes.StringToDateOnlyConverterProperty);
+        Assert.Equal(types.StringToDateTimeConverterProperty, otherTypes.StringToDateTimeConverterProperty);
+        Assert.Equal(types.StringToDateTimeOffsetConverterProperty, otherTypes.StringToDateTimeOffsetConverterProperty);
+        Assert.Equal(types.StringToEnumConverterProperty, otherTypes.StringToEnumConverterProperty);
+        Assert.Equal(types.StringToIntNumberConverterProperty, otherTypes.StringToIntNumberConverterProperty);
+        Assert.Equal(types.StringToDecimalNumberConverterProperty, otherTypes.StringToDecimalNumberConverterProperty);
+        Assert.Equal(types.StringToDoubleNumberConverterProperty, otherTypes.StringToDoubleNumberConverterProperty);
+        Assert.Equal(types.StringToTimeOnlyConverterProperty, otherTypes.StringToTimeOnlyConverterProperty);
+        Assert.Equal(types.StringToTimeSpanConverterProperty, otherTypes.StringToTimeSpanConverterProperty);
+        Assert.Equal(types.StringToUriConverterProperty, otherTypes.StringToUriConverterProperty);
+        Assert.Equal(types.TimeOnlyToStringConverterProperty, otherTypes.TimeOnlyToStringConverterProperty);
+        Assert.Equal(types.TimeOnlyToTicksConverterProperty, otherTypes.TimeOnlyToTicksConverterProperty);
+        Assert.Equal(types.TimeSpanToStringConverterProperty, otherTypes.TimeSpanToStringConverterProperty);
+        Assert.Equal(types.UriToStringConverterProperty, otherTypes.UriToStringConverterProperty);
+        Assert.Equal(types.NullIntToNullStringConverterProperty, otherTypes.NullIntToNullStringConverterProperty);
     }
 
     [ConditionalFact]
@@ -920,26 +1501,41 @@ public class ManyTypes
         public IPAddress?[] NullableIPAddressArray { get; set; } = null!;
         public PhysicalAddress?[] NullablePhysicalAddressArray { get; set; } = null!;
 
-        private readonly List<bool> _boolReadOnlyCollection = [];
-        private readonly List<byte> _uInt8ReadOnlyCollection = [];
-        private readonly List<int> _int32ReadOnlyCollection = [];
-        private readonly List<string> _stringReadOnlyCollection = [];
-        private readonly List<IPAddress> _ipAddressReadOnlyCollection = [];
+        private List<bool> _boolReadOnlyCollection = [];
+        private List<byte> _uInt8ReadOnlyCollection = [];
+        private List<int> _int32ReadOnlyCollection = [];
+        private List<string> _stringReadOnlyCollection = [];
+        private List<IPAddress> _ipAddressReadOnlyCollection = [];
 
         public IReadOnlyCollection<bool> BoolReadOnlyCollection
-            => _boolReadOnlyCollection.ToList();
+        {
+            get => _boolReadOnlyCollection.ToList();
+            set => _boolReadOnlyCollection = value.ToList();
+        }
 
         public IReadOnlyCollection<byte> UInt8ReadOnlyCollection
-            => _uInt8ReadOnlyCollection.ToList();
+        {
+            get => _uInt8ReadOnlyCollection.ToList();
+            set => _uInt8ReadOnlyCollection = value.ToList();
+        }
 
         public IReadOnlyCollection<int> Int32ReadOnlyCollection
-            => _int32ReadOnlyCollection.ToList();
+        {
+            get => _int32ReadOnlyCollection.ToList();
+            set => _int32ReadOnlyCollection = value.ToList();
+        }
 
         public IReadOnlyCollection<string> StringReadOnlyCollection
-            => _stringReadOnlyCollection.ToList();
+        {
+            get => _stringReadOnlyCollection.ToList();
+            set => _stringReadOnlyCollection = value.ToList();
+        }
 
         public IReadOnlyCollection<IPAddress> IPAddressReadOnlyCollection
-            => _ipAddressReadOnlyCollection.ToList();
+        {
+            get => _ipAddressReadOnlyCollection.ToList();
+            set => _ipAddressReadOnlyCollection = value.ToList();
+        }
 
         public Enum8 Enum8 { get; set; }
         public Enum16 Enum16 { get; set; }
diff --git a/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs b/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs
index b9f4f93cc7..794dbab424 100644
--- a/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs
+++ b/test/EFCore.Specification.Tests/TestUtilities/ModelAsserter.cs
@@ -370,6 +370,7 @@ protected ModelAsserter()
             () => Assert.Equal(expected.GetPrecision(), actual.GetPrecision()),
             () => Assert.Equal(expected.GetScale(), actual.GetScale()),
             () => Assert.Equal(expected.IsUnicode(), actual.IsUnicode()),
+            () => Assert.Equal(expected.IsPrimitiveCollection, actual.IsPrimitiveCollection),
             () => Assert.Equal(expected.GetProviderClrType(), actual.GetProviderClrType()),
             () =>
             {
@@ -395,6 +396,14 @@ protected ModelAsserter()
                     Assert.NotNull(actualComparer);
                 }
             },
+            () => AssertEqual(
+                expected.GetElementType(),
+                actual.GetElementType(),
+                compareMemberAnnotations ? expected.GetElementType()?.GetAnnotations() : null,
+                compareMemberAnnotations ? expected.GetElementType()?.GetAnnotations() : null,
+                compareBackreferences,
+                compareMemberAnnotations),
+            () => Assert.Equal(expected.FindTypeMapping()?.GetType(), actual.FindTypeMapping()?.GetType()),
             () => Assert.Equal(expected.IsKey(), actual.IsKey()),
             () => Assert.Equal(expected.IsForeignKey(), actual.IsForeignKey()),
             () => Assert.Equal(expected.IsIndex(), actual.IsIndex()),
@@ -663,6 +672,44 @@ protected ModelAsserter()
         return true;
     }
 
+    public virtual bool AssertEqual(
+        IReadOnlyElementType? expected,
+        IReadOnlyElementType? actual,
+        IEnumerable<IAnnotation>? expectedAnnotations,
+        IEnumerable<IAnnotation>? actualAnnotations,
+        bool compareBackreferences = false,
+        bool compareMemberAnnotations = false)
+    {
+        if (expected == null)
+        {
+            Assert.Null(actual);
+            return true;
+        }
+        Assert.NotNull(actual);
+
+        expectedAnnotations ??= Enumerable.Empty<IAnnotation>();
+        expectedAnnotations = expectedAnnotations.Where(a => !CoreAnnotationNames.AllNames.Contains(a.Name));
+        actualAnnotations ??= Enumerable.Empty<IAnnotation>();
+        actualAnnotations = actualAnnotations.Where(a => !CoreAnnotationNames.AllNames.Contains(a.Name));
+        Assert.Multiple(
+            () => Assert.Equal(expected.ClrType, actual.ClrType),
+            () => Assert.Equal(expected.IsNullable, actual.IsNullable),
+            () => Assert.Equal(expected.GetMaxLength(), actual.GetMaxLength()),
+            () => Assert.Equal(expected.GetPrecision(), actual.GetPrecision()),
+            () => Assert.Equal(expected.GetScale(), actual.GetScale()),
+            () => Assert.Equal(expected.IsUnicode(), actual.IsUnicode()),
+            () => Assert.Equal(expected.FindTypeMapping()?.GetType(), actual.FindTypeMapping()?.GetType()),
+            () =>
+            {
+                if (compareBackreferences)
+                {
+                    Assert.Equal(expected.CollectionProperty.Name, actual.CollectionProperty.Name);
+                }
+            },
+            () => Assert.Equal(expectedAnnotations, actualAnnotations, TestAnnotationComparer.Instance));
+        return true;
+    }
+
     public virtual void AssertEqual(
         IEnumerable<IReadOnlyKey> expectedKeys,
         IEnumerable<IReadOnlyKey> actualKeys,
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
index e36b79214b..3ef8ea21bb 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
@@ -194,6 +194,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v1, bool v2) => v1 == v2,
                         int (bool v) => ((object)v).GetHashCode(),
                         bool (bool v) => v)));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
+            boolArrayElementType.TypeMapping = boolArray.TypeMapping.ElementTypeMapping;
             boolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -257,6 +259,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v1, bool v2) => v1 == v2,
                         int (bool v) => ((object)v).GetHashCode(),
                         bool (bool v) => v)));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
+            boolReadOnlyCollectionElementType.TypeMapping = boolReadOnlyCollection.TypeMapping.ElementTypeMapping;
             boolReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -523,6 +527,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "varbinary(max)"),
                     storeTypePostfix: StoreTypePostfix.None));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
+            bytesArrayElementType.TypeMapping = bytesArray.TypeMapping.ElementTypeMapping;
             bytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -769,6 +775,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<char, string>(
                             string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                             char (string v) => (v.Length < 1 ? '\0' : v[0])))));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
+            charArrayElementType.TypeMapping = charArray.TypeMapping.ElementTypeMapping;
             charArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -932,6 +940,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                         int (DateOnly v) => ((object)v).GetHashCode(),
                         DateOnly (DateOnly v) => v)));
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
+            dateOnlyArrayElementType.TypeMapping = dateOnlyArray.TypeMapping.ElementTypeMapping;
             dateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -1093,6 +1103,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
+            dateTimeArrayElementType.TypeMapping = dateTimeArray.TypeMapping.ElementTypeMapping;
             dateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
@@ -1508,6 +1520,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (decimal v1, decimal v2) => v1 == v2,
                         int (decimal v) => ((object)v).GetHashCode(),
                         decimal (decimal v) => v)));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
+            decimalArrayElementType.TypeMapping = decimalArray.TypeMapping.ElementTypeMapping;
             decimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -1723,6 +1737,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (double v1, double v2) => v1.Equals(v2),
                         int (double v) => ((object)v).GetHashCode(),
                         double (double v) => v)));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
+            doubleArrayElementType.TypeMapping = doubleArray.TypeMapping.ElementTypeMapping;
             doubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -1962,6 +1978,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16ArrayElementType.TypeMapping = enum16Array.TypeMapping.ElementTypeMapping;
             enum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16AsString = runtimeEntityType.AddProperty(
@@ -2102,6 +2120,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringArrayElementType.TypeMapping = enum16AsStringArray.TypeMapping.ElementTypeMapping;
             enum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
@@ -2186,6 +2207,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringCollectionElementType.TypeMapping = enum16AsStringCollection.TypeMapping.ElementTypeMapping;
             enum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16Collection = runtimeEntityType.AddProperty(
@@ -2265,6 +2289,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16CollectionElementType.TypeMapping = enum16Collection.TypeMapping.ElementTypeMapping;
             enum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32 = runtimeEntityType.AddProperty(
@@ -2394,6 +2420,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32ArrayElementType.TypeMapping = enum32Array.TypeMapping.ElementTypeMapping;
             enum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32AsString = runtimeEntityType.AddProperty(
@@ -2534,6 +2562,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringArrayElementType.TypeMapping = enum32AsStringArray.TypeMapping.ElementTypeMapping;
             enum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
@@ -2618,6 +2649,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringCollectionElementType.TypeMapping = enum32AsStringCollection.TypeMapping.ElementTypeMapping;
             enum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32Collection = runtimeEntityType.AddProperty(
@@ -2697,6 +2731,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32CollectionElementType.TypeMapping = enum32Collection.TypeMapping.ElementTypeMapping;
             enum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64 = runtimeEntityType.AddProperty(
@@ -2826,6 +2862,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64ArrayElementType.TypeMapping = enum64Array.TypeMapping.ElementTypeMapping;
             enum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64AsString = runtimeEntityType.AddProperty(
@@ -2966,6 +3004,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringArrayElementType.TypeMapping = enum64AsStringArray.TypeMapping.ElementTypeMapping;
             enum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
@@ -3050,6 +3091,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringCollectionElementType.TypeMapping = enum64AsStringCollection.TypeMapping.ElementTypeMapping;
             enum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64Collection = runtimeEntityType.AddProperty(
@@ -3129,6 +3173,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64CollectionElementType.TypeMapping = enum64Collection.TypeMapping.ElementTypeMapping;
             enum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8 = runtimeEntityType.AddProperty(
@@ -3258,6 +3304,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8ArrayElementType.TypeMapping = enum8Array.TypeMapping.ElementTypeMapping;
             enum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8AsString = runtimeEntityType.AddProperty(
@@ -3398,6 +3446,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringArrayElementType.TypeMapping = enum8AsStringArray.TypeMapping.ElementTypeMapping;
             enum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
@@ -3482,6 +3533,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringCollectionElementType.TypeMapping = enum8AsStringCollection.TypeMapping.ElementTypeMapping;
             enum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8Collection = runtimeEntityType.AddProperty(
@@ -3561,6 +3615,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8CollectionElementType.TypeMapping = enum8Collection.TypeMapping.ElementTypeMapping;
             enum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
@@ -3797,6 +3853,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16ArrayElementType.TypeMapping = enumU16Array.TypeMapping.ElementTypeMapping;
             enumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16AsString = runtimeEntityType.AddProperty(
@@ -3937,6 +3995,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringArrayElementType.TypeMapping = enumU16AsStringArray.TypeMapping.ElementTypeMapping;
             enumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
@@ -4021,6 +4082,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringCollectionElementType.TypeMapping = enumU16AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16Collection = runtimeEntityType.AddProperty(
@@ -4100,6 +4164,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16CollectionElementType.TypeMapping = enumU16Collection.TypeMapping.ElementTypeMapping;
             enumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32 = runtimeEntityType.AddProperty(
@@ -4229,6 +4295,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32ArrayElementType.TypeMapping = enumU32Array.TypeMapping.ElementTypeMapping;
             enumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32AsString = runtimeEntityType.AddProperty(
@@ -4369,6 +4437,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringArrayElementType.TypeMapping = enumU32AsStringArray.TypeMapping.ElementTypeMapping;
             enumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
@@ -4453,6 +4524,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringCollectionElementType.TypeMapping = enumU32AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32Collection = runtimeEntityType.AddProperty(
@@ -4532,6 +4606,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32CollectionElementType.TypeMapping = enumU32Collection.TypeMapping.ElementTypeMapping;
             enumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64 = runtimeEntityType.AddProperty(
@@ -4669,6 +4745,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64ArrayElementType.TypeMapping = enumU64Array.TypeMapping.ElementTypeMapping;
             enumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64AsString = runtimeEntityType.AddProperty(
@@ -4809,6 +4887,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringArrayElementType.TypeMapping = enumU64AsStringArray.TypeMapping.ElementTypeMapping;
             enumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
@@ -4893,6 +4974,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringCollectionElementType.TypeMapping = enumU64AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64Collection = runtimeEntityType.AddProperty(
@@ -4976,6 +5060,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64CollectionElementType.TypeMapping = enumU64Collection.TypeMapping.ElementTypeMapping;
             enumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8 = runtimeEntityType.AddProperty(
@@ -5105,6 +5191,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8ArrayElementType.TypeMapping = enumU8Array.TypeMapping.ElementTypeMapping;
             enumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8AsString = runtimeEntityType.AddProperty(
@@ -5245,6 +5333,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringArrayElementType.TypeMapping = enumU8AsStringArray.TypeMapping.ElementTypeMapping;
             enumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
@@ -5329,6 +5420,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringCollectionElementType.TypeMapping = enumU8AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8Collection = runtimeEntityType.AddProperty(
@@ -5408,6 +5502,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8CollectionElementType.TypeMapping = enumU8Collection.TypeMapping.ElementTypeMapping;
             enumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var @float = runtimeEntityType.AddProperty(
@@ -5513,6 +5609,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (float v1, float v2) => v1.Equals(v2),
                         int (float v) => ((object)v).GetHashCode(),
                         float (float v) => v)));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
+            floatArrayElementType.TypeMapping = floatArray.TypeMapping.ElementTypeMapping;
             floatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var guid = runtimeEntityType.AddProperty(
@@ -5622,6 +5720,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         Guid (Guid v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "uniqueidentifier")));
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
+            guidArrayElementType.TypeMapping = guidArray.TypeMapping.ElementTypeMapping;
             guidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -5870,6 +5970,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
+            iPAddressArrayElementType.TypeMapping = iPAddressArray.TypeMapping.ElementTypeMapping;
             iPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -5954,6 +6056,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
+            iPAddressReadOnlyCollectionElementType.TypeMapping = iPAddressReadOnlyCollection.TypeMapping.ElementTypeMapping;
             iPAddressReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -6167,6 +6272,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
+            int16ArrayElementType.TypeMapping = int16Array.TypeMapping.ElementTypeMapping;
             int16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int32 = runtimeEntityType.AddProperty(
@@ -6272,6 +6379,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (int v1, int v2) => v1 == v2,
                         int (int v) => v,
                         int (int v) => v)));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
+            int32ArrayElementType.TypeMapping = int32Array.TypeMapping.ElementTypeMapping;
             int32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -6335,6 +6444,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (int v1, int v2) => v1 == v2,
                         int (int v) => v,
                         int (int v) => v)));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
+            int32ReadOnlyCollectionElementType.TypeMapping = int32ReadOnlyCollection.TypeMapping.ElementTypeMapping;
             int32ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int64 = runtimeEntityType.AddProperty(
@@ -6440,6 +6551,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (long v1, long v2) => v1 == v2,
                         int (long v) => ((object)v).GetHashCode(),
                         long (long v) => v)));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
+            int64ArrayElementType.TypeMapping = int64Array.TypeMapping.ElementTypeMapping;
             int64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int8 = runtimeEntityType.AddProperty(
@@ -6569,6 +6682,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<sbyte, short>(
                             short (sbyte v) => ((short)(v)),
                             sbyte (short v) => ((sbyte)(v))))));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
+            int8ArrayElementType.TypeMapping = int8Array.TypeMapping.ElementTypeMapping;
             int8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -6844,6 +6959,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v1, bool v2) => v1 == v2,
                         int (bool v) => ((object)v).GetHashCode(),
                         bool (bool v) => v)));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
+            nullableBoolArrayElementType.TypeMapping = nullableBoolArray.TypeMapping.ElementTypeMapping;
+            nullableBoolArrayElementType.SetComparer(new NullableValueComparer<bool>(nullableBoolArrayElementType.TypeMapping.Comparer));
             nullableBoolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableBytes = runtimeEntityType.AddProperty(
@@ -6955,6 +7074,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "varbinary(max)"),
                     storeTypePostfix: StoreTypePostfix.None));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
+            nullableBytesArrayElementType.TypeMapping = nullableBytesArray.TypeMapping.ElementTypeMapping;
             nullableBytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableChar = runtimeEntityType.AddProperty(
@@ -7096,6 +7218,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<char, string>(
                             string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                             char (string v) => (v.Length < 1 ? '\0' : v[0])))));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
+            nullableCharArrayElementType.TypeMapping = nullableCharArray.TypeMapping.ElementTypeMapping;
+            nullableCharArrayElementType.SetComparer(new NullableValueComparer<char>(nullableCharArrayElementType.TypeMapping.Comparer));
             nullableCharArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
@@ -7203,6 +7329,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                         int (DateOnly v) => ((object)v).GetHashCode(),
                         DateOnly (DateOnly v) => v)));
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
+            nullableDateOnlyArrayElementType.TypeMapping = nullableDateOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableDateOnlyArrayElementType.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnlyArrayElementType.TypeMapping.Comparer));
             nullableDateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDateTime = runtimeEntityType.AddProperty(
@@ -7310,6 +7440,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
+            nullableDateTimeArrayElementType.TypeMapping = nullableDateTimeArray.TypeMapping.ElementTypeMapping;
+            nullableDateTimeArrayElementType.SetComparer(new NullableValueComparer<DateTime>(nullableDateTimeArrayElementType.TypeMapping.Comparer));
             nullableDateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDecimal = runtimeEntityType.AddProperty(
@@ -7417,6 +7551,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (decimal v1, decimal v2) => v1 == v2,
                         int (decimal v) => ((object)v).GetHashCode(),
                         decimal (decimal v) => v)));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
+            nullableDecimalArrayElementType.TypeMapping = nullableDecimalArray.TypeMapping.ElementTypeMapping;
+            nullableDecimalArrayElementType.SetComparer(new NullableValueComparer<decimal>(nullableDecimalArrayElementType.TypeMapping.Comparer));
             nullableDecimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDouble = runtimeEntityType.AddProperty(
@@ -7524,6 +7662,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (double v1, double v2) => v1.Equals(v2),
                         int (double v) => ((object)v).GetHashCode(),
                         double (double v) => v)));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
+            nullableDoubleArrayElementType.TypeMapping = nullableDoubleArray.TypeMapping.ElementTypeMapping;
+            nullableDoubleArrayElementType.SetComparer(new NullableValueComparer<double>(nullableDoubleArrayElementType.TypeMapping.Comparer));
             nullableDoubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
@@ -7655,6 +7797,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16ArrayElementType.TypeMapping = nullableEnum16Array.TypeMapping.ElementTypeMapping;
+            nullableEnum16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16ArrayElementType.TypeMapping.Comparer));
             nullableEnum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
@@ -7786,6 +7932,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringArrayElementType.TypeMapping = nullableEnum16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
@@ -7865,6 +8015,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringCollectionElementType.TypeMapping = nullableEnum16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
@@ -7944,6 +8098,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16CollectionElementType.TypeMapping = nullableEnum16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16CollectionElementType.TypeMapping.Comparer));
             nullableEnum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
@@ -8075,6 +8233,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32ArrayElementType.TypeMapping = nullableEnum32Array.TypeMapping.ElementTypeMapping;
+            nullableEnum32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32ArrayElementType.TypeMapping.Comparer));
             nullableEnum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
@@ -8206,6 +8368,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringArrayElementType.TypeMapping = nullableEnum32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
@@ -8285,6 +8451,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringCollectionElementType.TypeMapping = nullableEnum32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
@@ -8364,6 +8534,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32CollectionElementType.TypeMapping = nullableEnum32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32CollectionElementType.TypeMapping.Comparer));
             nullableEnum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
@@ -8495,6 +8669,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64ArrayElementType.TypeMapping = nullableEnum64Array.TypeMapping.ElementTypeMapping;
+            nullableEnum64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64ArrayElementType.TypeMapping.Comparer));
             nullableEnum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
@@ -8626,6 +8804,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringArrayElementType.TypeMapping = nullableEnum64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
@@ -8705,6 +8887,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringCollectionElementType.TypeMapping = nullableEnum64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
@@ -8784,6 +8970,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64CollectionElementType.TypeMapping = nullableEnum64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64CollectionElementType.TypeMapping.Comparer));
             nullableEnum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
@@ -8915,6 +9105,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8ArrayElementType.TypeMapping = nullableEnum8Array.TypeMapping.ElementTypeMapping;
+            nullableEnum8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8ArrayElementType.TypeMapping.Comparer));
             nullableEnum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
@@ -9046,6 +9240,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringArrayElementType.TypeMapping = nullableEnum8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
@@ -9125,6 +9323,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringCollectionElementType.TypeMapping = nullableEnum8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
@@ -9204,6 +9406,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8CollectionElementType.TypeMapping = nullableEnum8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8CollectionElementType.TypeMapping.Comparer));
             nullableEnum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
@@ -9335,6 +9541,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16ArrayElementType.TypeMapping = nullableEnumU16Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16ArrayElementType.TypeMapping.Comparer));
             nullableEnumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
@@ -9466,6 +9676,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringArrayElementType.TypeMapping = nullableEnumU16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
@@ -9545,6 +9759,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringCollectionElementType.TypeMapping = nullableEnumU16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
@@ -9624,6 +9842,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16CollectionElementType.TypeMapping = nullableEnumU16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16CollectionElementType.TypeMapping.Comparer));
             nullableEnumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
@@ -9755,6 +9977,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32ArrayElementType.TypeMapping = nullableEnumU32Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32ArrayElementType.TypeMapping.Comparer));
             nullableEnumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
@@ -9886,6 +10112,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringArrayElementType.TypeMapping = nullableEnumU32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
@@ -9965,6 +10195,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringCollectionElementType.TypeMapping = nullableEnumU32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
@@ -10044,6 +10278,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32CollectionElementType.TypeMapping = nullableEnumU32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32CollectionElementType.TypeMapping.Comparer));
             nullableEnumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
@@ -10183,6 +10421,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64ArrayElementType.TypeMapping = nullableEnumU64Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64ArrayElementType.TypeMapping.Comparer));
             nullableEnumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
@@ -10322,6 +10564,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringArrayElementType.TypeMapping = nullableEnumU64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
@@ -10405,6 +10651,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringCollectionElementType.TypeMapping = nullableEnumU64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
@@ -10488,6 +10738,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64CollectionElementType.TypeMapping = nullableEnumU64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64CollectionElementType.TypeMapping.Comparer));
             nullableEnumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
@@ -10619,6 +10873,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8ArrayElementType.TypeMapping = nullableEnumU8Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8ArrayElementType.TypeMapping.Comparer));
             nullableEnumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
@@ -10750,6 +11008,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringArrayElementType.TypeMapping = nullableEnumU8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
@@ -10829,6 +11091,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringCollectionElementType.TypeMapping = nullableEnumU8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
@@ -10908,6 +11174,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8CollectionElementType.TypeMapping = nullableEnumU8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8CollectionElementType.TypeMapping.Comparer));
             nullableEnumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableFloat = runtimeEntityType.AddProperty(
@@ -11015,6 +11285,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (float v1, float v2) => v1.Equals(v2),
                         int (float v) => ((object)v).GetHashCode(),
                         float (float v) => v)));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
+            nullableFloatArrayElementType.TypeMapping = nullableFloatArray.TypeMapping.ElementTypeMapping;
+            nullableFloatArrayElementType.SetComparer(new NullableValueComparer<float>(nullableFloatArrayElementType.TypeMapping.Comparer));
             nullableFloatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableGuid = runtimeEntityType.AddProperty(
@@ -11126,6 +11400,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         Guid (Guid v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "uniqueidentifier")));
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
+            nullableGuidArrayElementType.TypeMapping = nullableGuidArray.TypeMapping.ElementTypeMapping;
+            nullableGuidArrayElementType.SetComparer(new NullableValueComparer<Guid>(nullableGuidArrayElementType.TypeMapping.Comparer));
             nullableGuidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
@@ -11265,6 +11543,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
+            nullableIPAddressArrayElementType.TypeMapping = nullableIPAddressArray.TypeMapping.ElementTypeMapping;
             nullableIPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt16 = runtimeEntityType.AddProperty(
@@ -11372,6 +11653,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
+            nullableInt16ArrayElementType.TypeMapping = nullableInt16Array.TypeMapping.ElementTypeMapping;
+            nullableInt16ArrayElementType.SetComparer(new NullableValueComparer<short>(nullableInt16ArrayElementType.TypeMapping.Comparer));
             nullableInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt32 = runtimeEntityType.AddProperty(
@@ -11479,6 +11764,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (int v1, int v2) => v1 == v2,
                         int (int v) => v,
                         int (int v) => v)));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
+            nullableInt32ArrayElementType.TypeMapping = nullableInt32Array.TypeMapping.ElementTypeMapping;
+            nullableInt32ArrayElementType.SetComparer(new NullableValueComparer<int>(nullableInt32ArrayElementType.TypeMapping.Comparer));
             nullableInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt64 = runtimeEntityType.AddProperty(
@@ -11586,6 +11875,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (long v1, long v2) => v1 == v2,
                         int (long v) => ((object)v).GetHashCode(),
                         long (long v) => v)));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
+            nullableInt64ArrayElementType.TypeMapping = nullableInt64Array.TypeMapping.ElementTypeMapping;
+            nullableInt64ArrayElementType.SetComparer(new NullableValueComparer<long>(nullableInt64ArrayElementType.TypeMapping.Comparer));
             nullableInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt8 = runtimeEntityType.AddProperty(
@@ -11717,6 +12010,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<sbyte, short>(
                             short (sbyte v) => ((short)(v)),
                             sbyte (short v) => ((sbyte)(v))))));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
+            nullableInt8ArrayElementType.TypeMapping = nullableInt8Array.TypeMapping.ElementTypeMapping;
+            nullableInt8ArrayElementType.SetComparer(new NullableValueComparer<sbyte>(nullableInt8ArrayElementType.TypeMapping.Comparer));
             nullableInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
@@ -11856,6 +12153,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
+            nullablePhysicalAddressArrayElementType.TypeMapping = nullablePhysicalAddressArray.TypeMapping.ElementTypeMapping;
             nullablePhysicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableString = runtimeEntityType.AddProperty(
@@ -11971,6 +12271,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
+            nullableStringArrayElementType.TypeMapping = nullableStringArray.TypeMapping.ElementTypeMapping;
             nullableStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
@@ -12078,6 +12381,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                         int (TimeOnly v) => ((object)v).GetHashCode(),
                         TimeOnly (TimeOnly v) => v)));
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
+            nullableTimeOnlyArrayElementType.TypeMapping = nullableTimeOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableTimeOnlyArrayElementType.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnlyArrayElementType.TypeMapping.Comparer));
             nullableTimeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
@@ -12185,6 +12492,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                         int (TimeSpan v) => ((object)v).GetHashCode(),
                         TimeSpan (TimeSpan v) => v)));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
+            nullableTimeSpanArrayElementType.TypeMapping = nullableTimeSpanArray.TypeMapping.ElementTypeMapping;
+            nullableTimeSpanArrayElementType.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpanArrayElementType.TypeMapping.Comparer));
             nullableTimeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
@@ -12316,6 +12627,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ushort, int>(
                             int (ushort v) => ((int)(v)),
                             ushort (int v) => ((ushort)(v))))));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
+            nullableUInt16ArrayElementType.TypeMapping = nullableUInt16Array.TypeMapping.ElementTypeMapping;
+            nullableUInt16ArrayElementType.SetComparer(new NullableValueComparer<ushort>(nullableUInt16ArrayElementType.TypeMapping.Comparer));
             nullableUInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
@@ -12447,6 +12762,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<uint, long>(
                             long (uint v) => ((long)(v)),
                             uint (long v) => ((uint)(v))))));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
+            nullableUInt32ArrayElementType.TypeMapping = nullableUInt32Array.TypeMapping.ElementTypeMapping;
+            nullableUInt32ArrayElementType.SetComparer(new NullableValueComparer<uint>(nullableUInt32ArrayElementType.TypeMapping.Comparer));
             nullableUInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
@@ -12586,6 +12905,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ulong, decimal>(
                             decimal (ulong v) => ((decimal)(v)),
                             ulong (decimal v) => ((ulong)(v))))));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
+            nullableUInt64ArrayElementType.TypeMapping = nullableUInt64Array.TypeMapping.ElementTypeMapping;
+            nullableUInt64ArrayElementType.SetComparer(new NullableValueComparer<ulong>(nullableUInt64ArrayElementType.TypeMapping.Comparer));
             nullableUInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
@@ -12693,6 +13016,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
+            nullableUInt8ArrayElementType.TypeMapping = nullableUInt8Array.TypeMapping.ElementTypeMapping;
+            nullableUInt8ArrayElementType.SetComparer(new NullableValueComparer<byte>(nullableUInt8ArrayElementType.TypeMapping.Comparer));
             nullableUInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUri = runtimeEntityType.AddProperty(
@@ -12832,6 +13159,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
+            nullableUriArrayElementType.TypeMapping = nullableUriArray.TypeMapping.ElementTypeMapping;
             nullableUriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var physicalAddress = runtimeEntityType.AddProperty(
@@ -12970,6 +13300,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
+            physicalAddressArrayElementType.TypeMapping = physicalAddressArray.TypeMapping.ElementTypeMapping;
             physicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -13192,6 +13524,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
+            stringArrayElementType.TypeMapping = stringArray.TypeMapping.ElementTypeMapping;
             stringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -13260,6 +13594,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
+            stringReadOnlyCollectionElementType.TypeMapping = stringReadOnlyCollection.TypeMapping.ElementTypeMapping;
             stringReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
@@ -14090,6 +14426,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                         int (TimeOnly v) => ((object)v).GetHashCode(),
                         TimeOnly (TimeOnly v) => v)));
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
+            timeOnlyArrayElementType.TypeMapping = timeOnlyArray.TypeMapping.ElementTypeMapping;
             timeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -14302,6 +14640,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                         int (TimeSpan v) => ((object)v).GetHashCode(),
                         TimeSpan (TimeSpan v) => v)));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
+            timeSpanArrayElementType.TypeMapping = timeSpanArray.TypeMapping.ElementTypeMapping;
             timeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -14538,6 +14878,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ushort, int>(
                             int (ushort v) => ((int)(v)),
                             ushort (int v) => ((ushort)(v))))));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
+            uInt16ArrayElementType.TypeMapping = uInt16Array.TypeMapping.ElementTypeMapping;
             uInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt32 = runtimeEntityType.AddProperty(
@@ -14667,6 +15009,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<uint, long>(
                             long (uint v) => ((long)(v)),
                             uint (long v) => ((uint)(v))))));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
+            uInt32ArrayElementType.TypeMapping = uInt32Array.TypeMapping.ElementTypeMapping;
             uInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt64 = runtimeEntityType.AddProperty(
@@ -14804,6 +15148,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ulong, decimal>(
                             decimal (ulong v) => ((decimal)(v)),
                             ulong (decimal v) => ((ulong)(v))))));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
+            uInt64ArrayElementType.TypeMapping = uInt64Array.TypeMapping.ElementTypeMapping;
             uInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt8 = runtimeEntityType.AddProperty(
@@ -14953,6 +15299,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
+            uInt8ReadOnlyCollectionElementType.TypeMapping = uInt8ReadOnlyCollection.TypeMapping.ElementTypeMapping;
             uInt8ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uri = runtimeEntityType.AddProperty(
@@ -15091,6 +15439,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
+            uriArrayElementType.TypeMapping = uriArray.TypeMapping.ElementTypeMapping;
             uriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
index 35f1e9a00f..5042c9a976 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
@@ -309,6 +309,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -378,6 +380,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -447,6 +451,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -532,6 +538,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -596,6 +604,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -660,6 +670,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -724,6 +736,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -788,6 +802,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var context = runtimeEntityType.AddServiceProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
index 7491960459..b16735e3d7 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
@@ -303,6 +303,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -373,6 +375,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -443,6 +447,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -529,6 +535,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -594,6 +602,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -659,6 +669,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -724,6 +736,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -789,6 +803,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var context = runtimeEntityType.AddServiceProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
index 596ffa47ed..bed7c6cc61 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
@@ -426,6 +426,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -495,6 +497,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -564,6 +568,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -649,6 +655,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -713,6 +721,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -777,6 +787,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -841,6 +853,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -905,6 +919,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var key = runtimeEntityType.AddKey(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
index e36b79214b..3ef8ea21bb 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
@@ -194,6 +194,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v1, bool v2) => v1 == v2,
                         int (bool v) => ((object)v).GetHashCode(),
                         bool (bool v) => v)));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
+            boolArrayElementType.TypeMapping = boolArray.TypeMapping.ElementTypeMapping;
             boolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -257,6 +259,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v1, bool v2) => v1 == v2,
                         int (bool v) => ((object)v).GetHashCode(),
                         bool (bool v) => v)));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
+            boolReadOnlyCollectionElementType.TypeMapping = boolReadOnlyCollection.TypeMapping.ElementTypeMapping;
             boolReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -523,6 +527,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "varbinary(max)"),
                     storeTypePostfix: StoreTypePostfix.None));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
+            bytesArrayElementType.TypeMapping = bytesArray.TypeMapping.ElementTypeMapping;
             bytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -769,6 +775,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<char, string>(
                             string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                             char (string v) => (v.Length < 1 ? '\0' : v[0])))));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
+            charArrayElementType.TypeMapping = charArray.TypeMapping.ElementTypeMapping;
             charArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -932,6 +940,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                         int (DateOnly v) => ((object)v).GetHashCode(),
                         DateOnly (DateOnly v) => v)));
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
+            dateOnlyArrayElementType.TypeMapping = dateOnlyArray.TypeMapping.ElementTypeMapping;
             dateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -1093,6 +1103,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
+            dateTimeArrayElementType.TypeMapping = dateTimeArray.TypeMapping.ElementTypeMapping;
             dateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
@@ -1508,6 +1520,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (decimal v1, decimal v2) => v1 == v2,
                         int (decimal v) => ((object)v).GetHashCode(),
                         decimal (decimal v) => v)));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
+            decimalArrayElementType.TypeMapping = decimalArray.TypeMapping.ElementTypeMapping;
             decimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -1723,6 +1737,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (double v1, double v2) => v1.Equals(v2),
                         int (double v) => ((object)v).GetHashCode(),
                         double (double v) => v)));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
+            doubleArrayElementType.TypeMapping = doubleArray.TypeMapping.ElementTypeMapping;
             doubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -1962,6 +1978,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16ArrayElementType.TypeMapping = enum16Array.TypeMapping.ElementTypeMapping;
             enum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16AsString = runtimeEntityType.AddProperty(
@@ -2102,6 +2120,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringArrayElementType.TypeMapping = enum16AsStringArray.TypeMapping.ElementTypeMapping;
             enum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
@@ -2186,6 +2207,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringCollectionElementType.TypeMapping = enum16AsStringCollection.TypeMapping.ElementTypeMapping;
             enum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16Collection = runtimeEntityType.AddProperty(
@@ -2265,6 +2289,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16CollectionElementType.TypeMapping = enum16Collection.TypeMapping.ElementTypeMapping;
             enum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32 = runtimeEntityType.AddProperty(
@@ -2394,6 +2420,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32ArrayElementType.TypeMapping = enum32Array.TypeMapping.ElementTypeMapping;
             enum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32AsString = runtimeEntityType.AddProperty(
@@ -2534,6 +2562,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringArrayElementType.TypeMapping = enum32AsStringArray.TypeMapping.ElementTypeMapping;
             enum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
@@ -2618,6 +2649,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringCollectionElementType.TypeMapping = enum32AsStringCollection.TypeMapping.ElementTypeMapping;
             enum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32Collection = runtimeEntityType.AddProperty(
@@ -2697,6 +2731,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32CollectionElementType.TypeMapping = enum32Collection.TypeMapping.ElementTypeMapping;
             enum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64 = runtimeEntityType.AddProperty(
@@ -2826,6 +2862,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64ArrayElementType.TypeMapping = enum64Array.TypeMapping.ElementTypeMapping;
             enum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64AsString = runtimeEntityType.AddProperty(
@@ -2966,6 +3004,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringArrayElementType.TypeMapping = enum64AsStringArray.TypeMapping.ElementTypeMapping;
             enum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
@@ -3050,6 +3091,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringCollectionElementType.TypeMapping = enum64AsStringCollection.TypeMapping.ElementTypeMapping;
             enum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64Collection = runtimeEntityType.AddProperty(
@@ -3129,6 +3173,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64CollectionElementType.TypeMapping = enum64Collection.TypeMapping.ElementTypeMapping;
             enum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8 = runtimeEntityType.AddProperty(
@@ -3258,6 +3304,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8ArrayElementType.TypeMapping = enum8Array.TypeMapping.ElementTypeMapping;
             enum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8AsString = runtimeEntityType.AddProperty(
@@ -3398,6 +3446,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringArrayElementType.TypeMapping = enum8AsStringArray.TypeMapping.ElementTypeMapping;
             enum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
@@ -3482,6 +3533,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringCollectionElementType.TypeMapping = enum8AsStringCollection.TypeMapping.ElementTypeMapping;
             enum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8Collection = runtimeEntityType.AddProperty(
@@ -3561,6 +3615,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8CollectionElementType.TypeMapping = enum8Collection.TypeMapping.ElementTypeMapping;
             enum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
@@ -3797,6 +3853,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16ArrayElementType.TypeMapping = enumU16Array.TypeMapping.ElementTypeMapping;
             enumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16AsString = runtimeEntityType.AddProperty(
@@ -3937,6 +3995,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringArrayElementType.TypeMapping = enumU16AsStringArray.TypeMapping.ElementTypeMapping;
             enumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
@@ -4021,6 +4082,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringCollectionElementType.TypeMapping = enumU16AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16Collection = runtimeEntityType.AddProperty(
@@ -4100,6 +4164,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16CollectionElementType.TypeMapping = enumU16Collection.TypeMapping.ElementTypeMapping;
             enumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32 = runtimeEntityType.AddProperty(
@@ -4229,6 +4295,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32ArrayElementType.TypeMapping = enumU32Array.TypeMapping.ElementTypeMapping;
             enumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32AsString = runtimeEntityType.AddProperty(
@@ -4369,6 +4437,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringArrayElementType.TypeMapping = enumU32AsStringArray.TypeMapping.ElementTypeMapping;
             enumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
@@ -4453,6 +4524,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringCollectionElementType.TypeMapping = enumU32AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32Collection = runtimeEntityType.AddProperty(
@@ -4532,6 +4606,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32CollectionElementType.TypeMapping = enumU32Collection.TypeMapping.ElementTypeMapping;
             enumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64 = runtimeEntityType.AddProperty(
@@ -4669,6 +4745,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64ArrayElementType.TypeMapping = enumU64Array.TypeMapping.ElementTypeMapping;
             enumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64AsString = runtimeEntityType.AddProperty(
@@ -4809,6 +4887,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringArrayElementType.TypeMapping = enumU64AsStringArray.TypeMapping.ElementTypeMapping;
             enumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
@@ -4893,6 +4974,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringCollectionElementType.TypeMapping = enumU64AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64Collection = runtimeEntityType.AddProperty(
@@ -4976,6 +5060,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64CollectionElementType.TypeMapping = enumU64Collection.TypeMapping.ElementTypeMapping;
             enumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8 = runtimeEntityType.AddProperty(
@@ -5105,6 +5191,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8ArrayElementType.TypeMapping = enumU8Array.TypeMapping.ElementTypeMapping;
             enumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8AsString = runtimeEntityType.AddProperty(
@@ -5245,6 +5333,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringArrayElementType.TypeMapping = enumU8AsStringArray.TypeMapping.ElementTypeMapping;
             enumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
@@ -5329,6 +5420,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringCollectionElementType.TypeMapping = enumU8AsStringCollection.TypeMapping.ElementTypeMapping;
             enumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8Collection = runtimeEntityType.AddProperty(
@@ -5408,6 +5502,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8CollectionElementType.TypeMapping = enumU8Collection.TypeMapping.ElementTypeMapping;
             enumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var @float = runtimeEntityType.AddProperty(
@@ -5513,6 +5609,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (float v1, float v2) => v1.Equals(v2),
                         int (float v) => ((object)v).GetHashCode(),
                         float (float v) => v)));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
+            floatArrayElementType.TypeMapping = floatArray.TypeMapping.ElementTypeMapping;
             floatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var guid = runtimeEntityType.AddProperty(
@@ -5622,6 +5720,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         Guid (Guid v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "uniqueidentifier")));
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
+            guidArrayElementType.TypeMapping = guidArray.TypeMapping.ElementTypeMapping;
             guidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -5870,6 +5970,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
+            iPAddressArrayElementType.TypeMapping = iPAddressArray.TypeMapping.ElementTypeMapping;
             iPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -5954,6 +6056,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
+            iPAddressReadOnlyCollectionElementType.TypeMapping = iPAddressReadOnlyCollection.TypeMapping.ElementTypeMapping;
             iPAddressReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -6167,6 +6272,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
+            int16ArrayElementType.TypeMapping = int16Array.TypeMapping.ElementTypeMapping;
             int16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int32 = runtimeEntityType.AddProperty(
@@ -6272,6 +6379,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (int v1, int v2) => v1 == v2,
                         int (int v) => v,
                         int (int v) => v)));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
+            int32ArrayElementType.TypeMapping = int32Array.TypeMapping.ElementTypeMapping;
             int32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -6335,6 +6444,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (int v1, int v2) => v1 == v2,
                         int (int v) => v,
                         int (int v) => v)));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
+            int32ReadOnlyCollectionElementType.TypeMapping = int32ReadOnlyCollection.TypeMapping.ElementTypeMapping;
             int32ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int64 = runtimeEntityType.AddProperty(
@@ -6440,6 +6551,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (long v1, long v2) => v1 == v2,
                         int (long v) => ((object)v).GetHashCode(),
                         long (long v) => v)));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
+            int64ArrayElementType.TypeMapping = int64Array.TypeMapping.ElementTypeMapping;
             int64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int8 = runtimeEntityType.AddProperty(
@@ -6569,6 +6682,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<sbyte, short>(
                             short (sbyte v) => ((short)(v)),
                             sbyte (short v) => ((sbyte)(v))))));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
+            int8ArrayElementType.TypeMapping = int8Array.TypeMapping.ElementTypeMapping;
             int8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -6844,6 +6959,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v1, bool v2) => v1 == v2,
                         int (bool v) => ((object)v).GetHashCode(),
                         bool (bool v) => v)));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
+            nullableBoolArrayElementType.TypeMapping = nullableBoolArray.TypeMapping.ElementTypeMapping;
+            nullableBoolArrayElementType.SetComparer(new NullableValueComparer<bool>(nullableBoolArrayElementType.TypeMapping.Comparer));
             nullableBoolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableBytes = runtimeEntityType.AddProperty(
@@ -6955,6 +7074,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "varbinary(max)"),
                     storeTypePostfix: StoreTypePostfix.None));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
+            nullableBytesArrayElementType.TypeMapping = nullableBytesArray.TypeMapping.ElementTypeMapping;
             nullableBytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableChar = runtimeEntityType.AddProperty(
@@ -7096,6 +7218,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<char, string>(
                             string (char v) => string.Format(CultureInfo.InvariantCulture, "{0}", ((object)(v))),
                             char (string v) => (v.Length < 1 ? '\0' : v[0])))));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
+            nullableCharArrayElementType.TypeMapping = nullableCharArray.TypeMapping.ElementTypeMapping;
+            nullableCharArrayElementType.SetComparer(new NullableValueComparer<char>(nullableCharArrayElementType.TypeMapping.Comparer));
             nullableCharArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
@@ -7203,6 +7329,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateOnly v1, DateOnly v2) => v1.Equals(v2),
                         int (DateOnly v) => ((object)v).GetHashCode(),
                         DateOnly (DateOnly v) => v)));
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
+            nullableDateOnlyArrayElementType.TypeMapping = nullableDateOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableDateOnlyArrayElementType.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnlyArrayElementType.TypeMapping.Comparer));
             nullableDateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDateTime = runtimeEntityType.AddProperty(
@@ -7310,6 +7440,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
+            nullableDateTimeArrayElementType.TypeMapping = nullableDateTimeArray.TypeMapping.ElementTypeMapping;
+            nullableDateTimeArrayElementType.SetComparer(new NullableValueComparer<DateTime>(nullableDateTimeArrayElementType.TypeMapping.Comparer));
             nullableDateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDecimal = runtimeEntityType.AddProperty(
@@ -7417,6 +7551,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (decimal v1, decimal v2) => v1 == v2,
                         int (decimal v) => ((object)v).GetHashCode(),
                         decimal (decimal v) => v)));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
+            nullableDecimalArrayElementType.TypeMapping = nullableDecimalArray.TypeMapping.ElementTypeMapping;
+            nullableDecimalArrayElementType.SetComparer(new NullableValueComparer<decimal>(nullableDecimalArrayElementType.TypeMapping.Comparer));
             nullableDecimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDouble = runtimeEntityType.AddProperty(
@@ -7524,6 +7662,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (double v1, double v2) => v1.Equals(v2),
                         int (double v) => ((object)v).GetHashCode(),
                         double (double v) => v)));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
+            nullableDoubleArrayElementType.TypeMapping = nullableDoubleArray.TypeMapping.ElementTypeMapping;
+            nullableDoubleArrayElementType.SetComparer(new NullableValueComparer<double>(nullableDoubleArrayElementType.TypeMapping.Comparer));
             nullableDoubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
@@ -7655,6 +7797,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16ArrayElementType.TypeMapping = nullableEnum16Array.TypeMapping.ElementTypeMapping;
+            nullableEnum16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16ArrayElementType.TypeMapping.Comparer));
             nullableEnum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
@@ -7786,6 +7932,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringArrayElementType.TypeMapping = nullableEnum16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
@@ -7865,6 +8015,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringCollectionElementType.TypeMapping = nullableEnum16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
@@ -7944,6 +8098,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16CollectionElementType.TypeMapping = nullableEnum16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16CollectionElementType.TypeMapping.Comparer));
             nullableEnum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
@@ -8075,6 +8233,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32ArrayElementType.TypeMapping = nullableEnum32Array.TypeMapping.ElementTypeMapping;
+            nullableEnum32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32ArrayElementType.TypeMapping.Comparer));
             nullableEnum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
@@ -8206,6 +8368,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringArrayElementType.TypeMapping = nullableEnum32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
@@ -8285,6 +8451,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringCollectionElementType.TypeMapping = nullableEnum32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
@@ -8364,6 +8534,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32CollectionElementType.TypeMapping = nullableEnum32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32CollectionElementType.TypeMapping.Comparer));
             nullableEnum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
@@ -8495,6 +8669,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64ArrayElementType.TypeMapping = nullableEnum64Array.TypeMapping.ElementTypeMapping;
+            nullableEnum64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64ArrayElementType.TypeMapping.Comparer));
             nullableEnum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
@@ -8626,6 +8804,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringArrayElementType.TypeMapping = nullableEnum64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
@@ -8705,6 +8887,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringCollectionElementType.TypeMapping = nullableEnum64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
@@ -8784,6 +8970,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64CollectionElementType.TypeMapping = nullableEnum64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64CollectionElementType.TypeMapping.Comparer));
             nullableEnum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
@@ -8915,6 +9105,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8ArrayElementType.TypeMapping = nullableEnum8Array.TypeMapping.ElementTypeMapping;
+            nullableEnum8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8ArrayElementType.TypeMapping.Comparer));
             nullableEnum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
@@ -9046,6 +9240,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringArrayElementType.TypeMapping = nullableEnum8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
@@ -9125,6 +9323,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringCollectionElementType.TypeMapping = nullableEnum8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
@@ -9204,6 +9406,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, short>(
                             short (CompiledModelTestBase.Enum8 value) => ((short)(value)),
                             CompiledModelTestBase.Enum8 (short value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8CollectionElementType.TypeMapping = nullableEnum8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8CollectionElementType.TypeMapping.Comparer));
             nullableEnum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
@@ -9335,6 +9541,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16ArrayElementType.TypeMapping = nullableEnumU16Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16ArrayElementType.TypeMapping.Comparer));
             nullableEnumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
@@ -9466,6 +9676,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringArrayElementType.TypeMapping = nullableEnumU16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
@@ -9545,6 +9759,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringCollectionElementType.TypeMapping = nullableEnumU16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
@@ -9624,6 +9842,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, int>(
                             int (CompiledModelTestBase.EnumU16 value) => ((int)(value)),
                             CompiledModelTestBase.EnumU16 (int value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16CollectionElementType.TypeMapping = nullableEnumU16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16CollectionElementType.TypeMapping.Comparer));
             nullableEnumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
@@ -9755,6 +9977,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32ArrayElementType.TypeMapping = nullableEnumU32Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32ArrayElementType.TypeMapping.Comparer));
             nullableEnumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
@@ -9886,6 +10112,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringArrayElementType.TypeMapping = nullableEnumU32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
@@ -9965,6 +10195,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringCollectionElementType.TypeMapping = nullableEnumU32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
@@ -10044,6 +10278,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, long>(
                             long (CompiledModelTestBase.EnumU32 value) => ((long)(value)),
                             CompiledModelTestBase.EnumU32 (long value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32CollectionElementType.TypeMapping = nullableEnumU32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32CollectionElementType.TypeMapping.Comparer));
             nullableEnumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
@@ -10183,6 +10421,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64ArrayElementType.TypeMapping = nullableEnumU64Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64ArrayElementType.TypeMapping.Comparer));
             nullableEnumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
@@ -10322,6 +10564,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringArrayElementType.TypeMapping = nullableEnumU64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
@@ -10405,6 +10651,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringCollectionElementType.TypeMapping = nullableEnumU64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
@@ -10488,6 +10738,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, decimal>(
                             decimal (CompiledModelTestBase.EnumU64 value) => ((decimal)(((long)(value)))),
                             CompiledModelTestBase.EnumU64 (decimal value) => ((CompiledModelTestBase.EnumU64)(((long)(value))))))));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64CollectionElementType.TypeMapping = nullableEnumU64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64CollectionElementType.TypeMapping.Comparer));
             nullableEnumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
@@ -10619,6 +10873,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8ArrayElementType.TypeMapping = nullableEnumU8Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8ArrayElementType.TypeMapping.Comparer));
             nullableEnumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
@@ -10750,6 +11008,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringArrayElementType.TypeMapping = nullableEnumU8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringArrayElementType.TypeMapping.Comparer));
             nullableEnumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
@@ -10829,6 +11091,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringCollectionElementType.TypeMapping = nullableEnumU8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringCollectionElementType.TypeMapping.Comparer));
             nullableEnumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
@@ -10908,6 +11174,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8CollectionElementType.TypeMapping = nullableEnumU8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8CollectionElementType.TypeMapping.Comparer));
             nullableEnumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableFloat = runtimeEntityType.AddProperty(
@@ -11015,6 +11285,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (float v1, float v2) => v1.Equals(v2),
                         int (float v) => ((object)v).GetHashCode(),
                         float (float v) => v)));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
+            nullableFloatArrayElementType.TypeMapping = nullableFloatArray.TypeMapping.ElementTypeMapping;
+            nullableFloatArrayElementType.SetComparer(new NullableValueComparer<float>(nullableFloatArrayElementType.TypeMapping.Comparer));
             nullableFloatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableGuid = runtimeEntityType.AddProperty(
@@ -11126,6 +11400,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         Guid (Guid v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "uniqueidentifier")));
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
+            nullableGuidArrayElementType.TypeMapping = nullableGuidArray.TypeMapping.ElementTypeMapping;
+            nullableGuidArrayElementType.SetComparer(new NullableValueComparer<Guid>(nullableGuidArrayElementType.TypeMapping.Comparer));
             nullableGuidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
@@ -11265,6 +11543,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
+            nullableIPAddressArrayElementType.TypeMapping = nullableIPAddressArray.TypeMapping.ElementTypeMapping;
             nullableIPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt16 = runtimeEntityType.AddProperty(
@@ -11372,6 +11653,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
+            nullableInt16ArrayElementType.TypeMapping = nullableInt16Array.TypeMapping.ElementTypeMapping;
+            nullableInt16ArrayElementType.SetComparer(new NullableValueComparer<short>(nullableInt16ArrayElementType.TypeMapping.Comparer));
             nullableInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt32 = runtimeEntityType.AddProperty(
@@ -11479,6 +11764,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (int v1, int v2) => v1 == v2,
                         int (int v) => v,
                         int (int v) => v)));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
+            nullableInt32ArrayElementType.TypeMapping = nullableInt32Array.TypeMapping.ElementTypeMapping;
+            nullableInt32ArrayElementType.SetComparer(new NullableValueComparer<int>(nullableInt32ArrayElementType.TypeMapping.Comparer));
             nullableInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt64 = runtimeEntityType.AddProperty(
@@ -11586,6 +11875,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (long v1, long v2) => v1 == v2,
                         int (long v) => ((object)v).GetHashCode(),
                         long (long v) => v)));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
+            nullableInt64ArrayElementType.TypeMapping = nullableInt64Array.TypeMapping.ElementTypeMapping;
+            nullableInt64ArrayElementType.SetComparer(new NullableValueComparer<long>(nullableInt64ArrayElementType.TypeMapping.Comparer));
             nullableInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt8 = runtimeEntityType.AddProperty(
@@ -11717,6 +12010,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<sbyte, short>(
                             short (sbyte v) => ((short)(v)),
                             sbyte (short v) => ((sbyte)(v))))));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
+            nullableInt8ArrayElementType.TypeMapping = nullableInt8Array.TypeMapping.ElementTypeMapping;
+            nullableInt8ArrayElementType.SetComparer(new NullableValueComparer<sbyte>(nullableInt8ArrayElementType.TypeMapping.Comparer));
             nullableInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
@@ -11856,6 +12153,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
+            nullablePhysicalAddressArrayElementType.TypeMapping = nullablePhysicalAddressArray.TypeMapping.ElementTypeMapping;
             nullablePhysicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableString = runtimeEntityType.AddProperty(
@@ -11971,6 +12271,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
+            nullableStringArrayElementType.TypeMapping = nullableStringArray.TypeMapping.ElementTypeMapping;
             nullableStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
@@ -12078,6 +12381,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                         int (TimeOnly v) => ((object)v).GetHashCode(),
                         TimeOnly (TimeOnly v) => v)));
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
+            nullableTimeOnlyArrayElementType.TypeMapping = nullableTimeOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableTimeOnlyArrayElementType.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnlyArrayElementType.TypeMapping.Comparer));
             nullableTimeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
@@ -12185,6 +12492,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                         int (TimeSpan v) => ((object)v).GetHashCode(),
                         TimeSpan (TimeSpan v) => v)));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
+            nullableTimeSpanArrayElementType.TypeMapping = nullableTimeSpanArray.TypeMapping.ElementTypeMapping;
+            nullableTimeSpanArrayElementType.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpanArrayElementType.TypeMapping.Comparer));
             nullableTimeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
@@ -12316,6 +12627,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ushort, int>(
                             int (ushort v) => ((int)(v)),
                             ushort (int v) => ((ushort)(v))))));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
+            nullableUInt16ArrayElementType.TypeMapping = nullableUInt16Array.TypeMapping.ElementTypeMapping;
+            nullableUInt16ArrayElementType.SetComparer(new NullableValueComparer<ushort>(nullableUInt16ArrayElementType.TypeMapping.Comparer));
             nullableUInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
@@ -12447,6 +12762,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<uint, long>(
                             long (uint v) => ((long)(v)),
                             uint (long v) => ((uint)(v))))));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
+            nullableUInt32ArrayElementType.TypeMapping = nullableUInt32Array.TypeMapping.ElementTypeMapping;
+            nullableUInt32ArrayElementType.SetComparer(new NullableValueComparer<uint>(nullableUInt32ArrayElementType.TypeMapping.Comparer));
             nullableUInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
@@ -12586,6 +12905,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ulong, decimal>(
                             decimal (ulong v) => ((decimal)(v)),
                             ulong (decimal v) => ((ulong)(v))))));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
+            nullableUInt64ArrayElementType.TypeMapping = nullableUInt64Array.TypeMapping.ElementTypeMapping;
+            nullableUInt64ArrayElementType.SetComparer(new NullableValueComparer<ulong>(nullableUInt64ArrayElementType.TypeMapping.Comparer));
             nullableUInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
@@ -12693,6 +13016,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
+            nullableUInt8ArrayElementType.TypeMapping = nullableUInt8Array.TypeMapping.ElementTypeMapping;
+            nullableUInt8ArrayElementType.SetComparer(new NullableValueComparer<byte>(nullableUInt8ArrayElementType.TypeMapping.Comparer));
             nullableUInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUri = runtimeEntityType.AddProperty(
@@ -12832,6 +13159,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
+            nullableUriArrayElementType.TypeMapping = nullableUriArray.TypeMapping.ElementTypeMapping;
             nullableUriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var physicalAddress = runtimeEntityType.AddProperty(
@@ -12970,6 +13300,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
+            physicalAddressArrayElementType.TypeMapping = physicalAddressArray.TypeMapping.ElementTypeMapping;
             physicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -13192,6 +13524,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
+            stringArrayElementType.TypeMapping = stringArray.TypeMapping.ElementTypeMapping;
             stringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -13260,6 +13594,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
+            stringReadOnlyCollectionElementType.TypeMapping = stringReadOnlyCollection.TypeMapping.ElementTypeMapping;
             stringReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
@@ -14090,6 +14426,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeOnly v1, TimeOnly v2) => v1.Equals(v2),
                         int (TimeOnly v) => ((object)v).GetHashCode(),
                         TimeOnly (TimeOnly v) => v)));
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
+            timeOnlyArrayElementType.TypeMapping = timeOnlyArray.TypeMapping.ElementTypeMapping;
             timeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -14302,6 +14640,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (TimeSpan v1, TimeSpan v2) => v1.Equals(v2),
                         int (TimeSpan v) => ((object)v).GetHashCode(),
                         TimeSpan (TimeSpan v) => v)));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
+            timeSpanArrayElementType.TypeMapping = timeSpanArray.TypeMapping.ElementTypeMapping;
             timeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -14538,6 +14878,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ushort, int>(
                             int (ushort v) => ((int)(v)),
                             ushort (int v) => ((ushort)(v))))));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
+            uInt16ArrayElementType.TypeMapping = uInt16Array.TypeMapping.ElementTypeMapping;
             uInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt32 = runtimeEntityType.AddProperty(
@@ -14667,6 +15009,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<uint, long>(
                             long (uint v) => ((long)(v)),
                             uint (long v) => ((uint)(v))))));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
+            uInt32ArrayElementType.TypeMapping = uInt32Array.TypeMapping.ElementTypeMapping;
             uInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt64 = runtimeEntityType.AddProperty(
@@ -14804,6 +15148,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<ulong, decimal>(
                             decimal (ulong v) => ((decimal)(v)),
                             ulong (decimal v) => ((ulong)(v))))));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
+            uInt64ArrayElementType.TypeMapping = uInt64Array.TypeMapping.ElementTypeMapping;
             uInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt8 = runtimeEntityType.AddProperty(
@@ -14953,6 +15299,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
+            uInt8ReadOnlyCollectionElementType.TypeMapping = uInt8ReadOnlyCollection.TypeMapping.ElementTypeMapping;
             uInt8ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uri = runtimeEntityType.AddProperty(
@@ -15091,6 +15439,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
+            uriArrayElementType.TypeMapping = uriArray.TypeMapping.ElementTypeMapping;
             uriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
index 96d5589d28..c277432bea 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
@@ -309,6 +309,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -378,6 +380,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -447,6 +451,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -532,6 +538,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -596,6 +604,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -660,6 +670,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -724,6 +736,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -788,6 +802,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var context = runtimeEntityType.AddServiceProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
index e217a59aa8..c10cf75cbd 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
@@ -281,6 +281,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -351,6 +353,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -421,6 +425,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -507,6 +513,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -572,6 +580,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -637,6 +647,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -702,6 +714,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -767,6 +781,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var context = runtimeEntityType.AddServiceProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
index c1485c9b15..a3a6b017a5 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
@@ -455,6 +455,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -524,6 +526,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -593,6 +597,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -678,6 +684,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -742,6 +750,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -806,6 +816,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -870,6 +882,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -934,6 +948,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var key = runtimeEntityType.AddKey(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
index b88d873aec..ad691c8482 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
@@ -443,6 +443,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -512,6 +514,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -581,6 +585,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -666,6 +672,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -730,6 +738,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -794,6 +804,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -858,6 +870,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -922,6 +936,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             OwnedComplexProperty.Create(runtimeEntityType);
@@ -1181,6 +1197,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             new ValueConverter<IPAddress, string>(
                                 string (IPAddress v) => ((object)v).ToString(),
                                 IPAddress (string v) => IPAddress.Parse(v)))));
+                var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+                refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
                 refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 var refTypeEnumerable = complexType.AddProperty(
@@ -1258,6 +1276,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             unicode: true,
                             dbType: System.Data.DbType.String),
                         storeTypePostfix: StoreTypePostfix.None));
+                var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+                refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
                 refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 var refTypeIList = complexType.AddProperty(
@@ -1335,6 +1355,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             unicode: true,
                             dbType: System.Data.DbType.String),
                         storeTypePostfix: StoreTypePostfix.None));
+                var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+                refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
                 refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 var refTypeList = complexType.AddProperty(
@@ -1428,6 +1450,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             new ValueConverter<IPAddress, string>(
                                 string (IPAddress v) => ((object)v).ToString(),
                                 IPAddress (string v) => IPAddress.Parse(v)))));
+                var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+                refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
                 refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 var valueTypeArray = complexType.AddProperty(
@@ -1500,6 +1524,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                             int (DateTime v) => ((object)v).GetHashCode(),
                             DateTime (DateTime v) => v)));
+                var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+                valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
                 valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 var valueTypeEnumerable = complexType.AddProperty(
@@ -1572,6 +1598,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             bool (byte v1, byte v2) => v1 == v2,
                             int (byte v) => ((int)(v)),
                             byte (byte v) => v)));
+                var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+                valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
                 valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 var valueTypeIList = complexType.AddProperty(
@@ -1644,6 +1672,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             bool (byte v1, byte v2) => v1 == v2,
                             int (byte v) => ((int)(v)),
                             byte (byte v) => v)));
+                var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+                valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
                 valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 var valueTypeList = complexType.AddProperty(
@@ -1716,6 +1746,8 @@ public static RuntimeComplexProperty Create(RuntimeEntityType declaringType)
                             bool (short v1, short v2) => v1 == v2,
                             int (short v) => ((int)(v)),
                             short (short v) => v)));
+                var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+                valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
                 valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                 PrincipalComplexProperty.Create(complexType);
@@ -2214,6 +2246,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 new ValueConverter<IPAddress, string>(
                                     string (IPAddress v) => ((object)v).ToString(),
                                     IPAddress (string v) => IPAddress.Parse(v)))));
+                    var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+                    refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
                     refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     var refTypeEnumerable = complexType.AddProperty(
@@ -2293,6 +2327,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 unicode: true,
                                 dbType: System.Data.DbType.String),
                             storeTypePostfix: StoreTypePostfix.None));
+                    var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+                    refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
                     refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     var refTypeIList = complexType.AddProperty(
@@ -2372,6 +2408,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 unicode: true,
                                 dbType: System.Data.DbType.String),
                             storeTypePostfix: StoreTypePostfix.None));
+                    var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+                    refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
                     refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     var refTypeList = complexType.AddProperty(
@@ -2467,6 +2505,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 new ValueConverter<IPAddress, string>(
                                     string (IPAddress v) => ((object)v).ToString(),
                                     IPAddress (string v) => IPAddress.Parse(v)))));
+                    var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+                    refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
                     refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     var valueTypeArray = complexType.AddProperty(
@@ -2541,6 +2581,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                                 int (DateTime v) => ((object)v).GetHashCode(),
                                 DateTime (DateTime v) => v)));
+                    var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+                    valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
                     valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     var valueTypeEnumerable = complexType.AddProperty(
@@ -2615,6 +2657,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 bool (byte v1, byte v2) => v1 == v2,
                                 int (byte v) => ((int)(v)),
                                 byte (byte v) => v)));
+                    var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+                    valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
                     valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     var valueTypeIList = complexType.AddProperty(
@@ -2689,6 +2733,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 bool (byte v1, byte v2) => v1 == v2,
                                 int (byte v) => ((int)(v)),
                                 byte (byte v) => v)));
+                    var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+                    valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
                     valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     var valueTypeList = complexType.AddProperty(
@@ -2763,6 +2809,8 @@ public static RuntimeComplexProperty Create(RuntimeComplexType declaringType)
                                 bool (short v1, short v2) => v1 == v2,
                                 int (short v) => ((int)(v)),
                                 short (short v) => v)));
+                    var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+                    valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
                     valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
                     complexType.AddAnnotation("Relational:FunctionName", "PrincipalBaseTvf");
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
index 37cadf024c..8e8c4fa5fb 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
@@ -55,6 +55,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
             boolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -62,6 +63,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IReadOnlyCollection<bool>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_boolReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
             boolReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -130,6 +132,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
             bytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -163,6 +166,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
             charArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -188,6 +192,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
             dateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -212,6 +217,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateTime[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
             dateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
@@ -280,6 +286,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
             decimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -313,6 +320,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
             doubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -346,6 +354,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
             enum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16AsString = runtimeEntityType.AddProperty(
@@ -362,6 +371,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
             enum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
@@ -369,6 +380,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
             enum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum16Collection = runtimeEntityType.AddProperty(
@@ -376,6 +389,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
             enum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32 = runtimeEntityType.AddProperty(
@@ -391,6 +405,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
             enum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32AsString = runtimeEntityType.AddProperty(
@@ -407,6 +422,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
             enum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
@@ -414,6 +431,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
             enum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum32Collection = runtimeEntityType.AddProperty(
@@ -421,6 +440,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
             enum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64 = runtimeEntityType.AddProperty(
@@ -436,6 +456,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
             enum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64AsString = runtimeEntityType.AddProperty(
@@ -452,6 +473,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
             enum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
@@ -459,6 +482,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
             enum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum64Collection = runtimeEntityType.AddProperty(
@@ -466,6 +491,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
             enum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8 = runtimeEntityType.AddProperty(
@@ -481,6 +507,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
             enum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8AsString = runtimeEntityType.AddProperty(
@@ -497,6 +524,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
             enum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
@@ -504,6 +533,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
             enum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enum8Collection = runtimeEntityType.AddProperty(
@@ -511,6 +542,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
             enum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
@@ -544,6 +576,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
             enumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16AsString = runtimeEntityType.AddProperty(
@@ -560,6 +593,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
             enumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
@@ -567,6 +602,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
             enumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU16Collection = runtimeEntityType.AddProperty(
@@ -574,6 +611,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
             enumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32 = runtimeEntityType.AddProperty(
@@ -589,6 +627,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
             enumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32AsString = runtimeEntityType.AddProperty(
@@ -605,6 +644,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
             enumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
@@ -612,6 +653,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
             enumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU32Collection = runtimeEntityType.AddProperty(
@@ -619,6 +662,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
             enumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64 = runtimeEntityType.AddProperty(
@@ -634,6 +678,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
             enumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64AsString = runtimeEntityType.AddProperty(
@@ -650,6 +695,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
             enumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
@@ -657,6 +704,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
             enumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU64Collection = runtimeEntityType.AddProperty(
@@ -664,6 +713,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
             enumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8 = runtimeEntityType.AddProperty(
@@ -679,6 +729,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
             enumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8AsString = runtimeEntityType.AddProperty(
@@ -695,6 +746,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
             enumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
@@ -702,6 +755,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
             enumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var enumU8Collection = runtimeEntityType.AddProperty(
@@ -709,6 +764,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
             enumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var @float = runtimeEntityType.AddProperty(
@@ -724,6 +780,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
             floatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var guid = runtimeEntityType.AddProperty(
@@ -739,6 +796,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
             guidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -771,6 +829,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
             iPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -778,6 +837,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IReadOnlyCollection<IPAddress>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_ipAddressReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
             iPAddressReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -809,6 +870,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
             int16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int32 = runtimeEntityType.AddProperty(
@@ -824,6 +886,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
             int32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -831,6 +894,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IReadOnlyCollection<int>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_int32ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
             int32ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int64 = runtimeEntityType.AddProperty(
@@ -846,6 +910,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
             int64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var int8 = runtimeEntityType.AddProperty(
@@ -861,6 +926,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
             int8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -903,6 +969,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
             nullableBoolArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableBytes = runtimeEntityType.AddProperty(
@@ -918,6 +986,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
             nullableBytesArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableChar = runtimeEntityType.AddProperty(
@@ -933,6 +1003,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
             nullableCharArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
@@ -948,6 +1020,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
             nullableDateOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDateTime = runtimeEntityType.AddProperty(
@@ -963,6 +1037,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateTime?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
             nullableDateTimeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDecimal = runtimeEntityType.AddProperty(
@@ -978,6 +1054,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
             nullableDecimalArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableDouble = runtimeEntityType.AddProperty(
@@ -993,6 +1071,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
             nullableDoubleArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
@@ -1008,6 +1088,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
             nullableEnum16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
@@ -1023,6 +1105,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
             nullableEnum16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
@@ -1030,6 +1114,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
             nullableEnum16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
@@ -1037,6 +1123,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
             nullableEnum16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
@@ -1052,6 +1140,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
             nullableEnum32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
@@ -1067,6 +1157,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
             nullableEnum32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
@@ -1074,6 +1166,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
             nullableEnum32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
@@ -1081,6 +1175,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
             nullableEnum32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
@@ -1096,6 +1192,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
             nullableEnum64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
@@ -1111,6 +1209,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
             nullableEnum64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
@@ -1118,6 +1218,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
             nullableEnum64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
@@ -1125,6 +1227,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
             nullableEnum64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
@@ -1140,6 +1244,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
             nullableEnum8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
@@ -1155,6 +1261,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
             nullableEnum8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
@@ -1162,6 +1270,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
             nullableEnum8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
@@ -1169,6 +1279,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
             nullableEnum8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
@@ -1184,6 +1296,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
             nullableEnumU16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
@@ -1199,6 +1313,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
             nullableEnumU16AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
@@ -1206,6 +1322,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
             nullableEnumU16AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
@@ -1213,6 +1331,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
             nullableEnumU16Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
@@ -1228,6 +1348,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
             nullableEnumU32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
@@ -1243,6 +1365,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
             nullableEnumU32AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
@@ -1250,6 +1374,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
             nullableEnumU32AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
@@ -1257,6 +1383,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
             nullableEnumU32Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
@@ -1272,6 +1400,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
             nullableEnumU64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
@@ -1287,6 +1417,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
             nullableEnumU64AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
@@ -1294,6 +1426,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
             nullableEnumU64AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
@@ -1301,6 +1435,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
             nullableEnumU64Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
@@ -1316,6 +1452,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
             nullableEnumU8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
@@ -1331,6 +1469,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
             nullableEnumU8AsStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
@@ -1338,6 +1478,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
             nullableEnumU8AsStringCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
@@ -1345,6 +1487,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
             nullableEnumU8Collection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableFloat = runtimeEntityType.AddProperty(
@@ -1360,6 +1504,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
             nullableFloatArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableGuid = runtimeEntityType.AddProperty(
@@ -1375,6 +1521,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
             nullableGuidArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
@@ -1390,6 +1538,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
             nullableIPAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt16 = runtimeEntityType.AddProperty(
@@ -1405,6 +1555,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
             nullableInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt32 = runtimeEntityType.AddProperty(
@@ -1420,6 +1572,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
             nullableInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt64 = runtimeEntityType.AddProperty(
@@ -1435,6 +1589,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
             nullableInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableInt8 = runtimeEntityType.AddProperty(
@@ -1450,6 +1606,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
             nullableInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
@@ -1465,6 +1623,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
             nullablePhysicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableString = runtimeEntityType.AddProperty(
@@ -1480,6 +1640,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
             nullableStringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
@@ -1495,6 +1657,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
             nullableTimeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
@@ -1510,6 +1674,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeSpan?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
             nullableTimeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
@@ -1525,6 +1691,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
             nullableUInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
@@ -1540,6 +1708,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
             nullableUInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
@@ -1555,6 +1725,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
             nullableUInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
@@ -1570,6 +1742,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
             nullableUInt8Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var nullableUri = runtimeEntityType.AddProperty(
@@ -1585,6 +1759,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
             nullableUriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var physicalAddress = runtimeEntityType.AddProperty(
@@ -1599,6 +1775,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
             physicalAddressArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
@@ -1629,6 +1806,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
             stringArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
@@ -1636,6 +1814,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IReadOnlyCollection<string>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_stringReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
             stringReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
@@ -1765,6 +1944,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
             timeOnlyArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -1798,6 +1978,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeSpan[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
             timeSpanArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
@@ -1831,6 +2012,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
             uInt16Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt32 = runtimeEntityType.AddProperty(
@@ -1846,6 +2028,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
             uInt32Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt64 = runtimeEntityType.AddProperty(
@@ -1861,6 +2044,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
             uInt64Array.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uInt8 = runtimeEntityType.AddProperty(
@@ -1883,6 +2067,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IReadOnlyCollection<byte>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_uInt8ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
             uInt8ReadOnlyCollection.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uri = runtimeEntityType.AddProperty(
@@ -1897,6 +2082,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
             uriArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
index 132e8988c3..09e924e334 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
@@ -72,6 +72,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -80,6 +81,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -88,6 +90,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -96,6 +99,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -104,6 +108,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -112,6 +117,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -120,6 +126,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -128,6 +135,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var context = runtimeEntityType.AddServiceProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
index 2e7704f128..535866fd48 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
@@ -92,6 +92,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -101,6 +102,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -110,6 +112,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -119,6 +122,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -128,6 +132,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -137,6 +142,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -146,6 +152,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -155,6 +162,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var context = runtimeEntityType.AddServiceProperty(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
index 7a34a9120b..541471fae2 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
@@ -99,6 +99,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -107,6 +108,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -115,6 +117,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -123,6 +126,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -131,6 +135,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -139,6 +144,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -147,6 +153,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -155,6 +162,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var key = runtimeEntityType.AddKey(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs
index 0cfa13e849..df188bf052 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs
@@ -458,6 +458,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
             refTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
@@ -527,6 +529,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
             refTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeIList = runtimeEntityType.AddProperty(
@@ -596,6 +600,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         unicode: true,
                         dbType: System.Data.DbType.String),
                     storeTypePostfix: StoreTypePostfix.None));
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
             refTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var refTypeList = runtimeEntityType.AddProperty(
@@ -681,6 +687,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
             refTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeArray = runtimeEntityType.AddProperty(
@@ -745,6 +753,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (DateTime v1, DateTime v2) => v1.Equals(v2),
                         int (DateTime v) => ((object)v).GetHashCode(),
                         DateTime (DateTime v) => v)));
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
             valueTypeArray.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
@@ -809,6 +819,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
             valueTypeEnumerable.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeIList = runtimeEntityType.AddProperty(
@@ -873,6 +885,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte v1, byte v2) => v1 == v2,
                         int (byte v) => ((int)(v)),
                         byte (byte v) => v)));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
             valueTypeIList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var valueTypeList = runtimeEntityType.AddProperty(
@@ -937,6 +951,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (short v1, short v2) => v1 == v2,
                         int (short v) => ((int)(v)),
                         short (short v) => v)));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
             valueTypeList.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
             var key = runtimeEntityType.AddKey(
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
index 2fec0bb509..2bfbd74c41 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
@@ -194,6 +194,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
+            boolArrayElementType.TypeMapping = boolArray.TypeMapping.ElementTypeMapping;
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
                 "BoolReadOnlyCollection",
@@ -253,6 +255,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
+            boolReadOnlyCollectionElementType.TypeMapping = boolReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BoolToStringConverterProperty",
@@ -504,6 +508,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                         int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                         byte[] (byte[] source) => source.ToArray())));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
+            bytesArrayElementType.TypeMapping = bytesArray.TypeMapping.ElementTypeMapping;
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BytesToStringConverterProperty",
@@ -706,6 +712,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         char (char v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
+            charArrayElementType.TypeMapping = charArray.TypeMapping.ElementTypeMapping;
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
                 "CharToStringConverterProperty",
@@ -832,6 +840,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateOnly[], DateOnly>(
                     JsonDateOnlyReaderWriter.Instance),
                 elementMapping: SqliteDateOnlyTypeMapping.Default);
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
+            dateOnlyArrayElementType.TypeMapping = dateOnlyArray.TypeMapping.ElementTypeMapping;
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "DateOnlyToStringConverterProperty",
@@ -958,6 +968,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
+            dateTimeArrayElementType.TypeMapping = dateTimeArray.TypeMapping.ElementTypeMapping;
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                 "DateTimeOffsetToBinaryConverterProperty",
@@ -1321,6 +1333,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<decimal[], decimal>(
                     SqliteJsonDecimalReaderWriter.Instance),
                 elementMapping: SqliteDecimalTypeMapping.Default);
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
+            decimalArrayElementType.TypeMapping = decimalArray.TypeMapping.ElementTypeMapping;
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DecimalNumberToBytesConverterProperty",
@@ -1527,6 +1541,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         double (double v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
+            doubleArrayElementType.TypeMapping = doubleArray.TypeMapping.ElementTypeMapping;
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DoubleNumberToBytesConverterProperty",
@@ -1757,6 +1773,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16ArrayElementType.TypeMapping = enum16Array.TypeMapping.ElementTypeMapping;
 
             var enum16AsString = runtimeEntityType.AddProperty(
                 "Enum16AsString",
@@ -1880,6 +1898,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringArrayElementType.TypeMapping = enum16AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum16AsStringCollection",
@@ -1953,6 +1974,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringCollectionElementType.TypeMapping = enum16AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum16Collection = runtimeEntityType.AddProperty(
                 "Enum16Collection",
@@ -2028,6 +2052,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16CollectionElementType.TypeMapping = enum16Collection.TypeMapping.ElementTypeMapping;
 
             var enum32 = runtimeEntityType.AddProperty(
                 "Enum32",
@@ -2154,6 +2180,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32ArrayElementType.TypeMapping = enum32Array.TypeMapping.ElementTypeMapping;
 
             var enum32AsString = runtimeEntityType.AddProperty(
                 "Enum32AsString",
@@ -2277,6 +2305,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringArrayElementType.TypeMapping = enum32AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum32AsStringCollection",
@@ -2350,6 +2381,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringCollectionElementType.TypeMapping = enum32AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum32Collection = runtimeEntityType.AddProperty(
                 "Enum32Collection",
@@ -2425,6 +2459,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32CollectionElementType.TypeMapping = enum32Collection.TypeMapping.ElementTypeMapping;
 
             var enum64 = runtimeEntityType.AddProperty(
                 "Enum64",
@@ -2551,6 +2587,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64ArrayElementType.TypeMapping = enum64Array.TypeMapping.ElementTypeMapping;
 
             var enum64AsString = runtimeEntityType.AddProperty(
                 "Enum64AsString",
@@ -2674,6 +2712,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringArrayElementType.TypeMapping = enum64AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum64AsStringCollection",
@@ -2747,6 +2788,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringCollectionElementType.TypeMapping = enum64AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum64Collection = runtimeEntityType.AddProperty(
                 "Enum64Collection",
@@ -2822,6 +2866,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64CollectionElementType.TypeMapping = enum64Collection.TypeMapping.ElementTypeMapping;
 
             var enum8 = runtimeEntityType.AddProperty(
                 "Enum8",
@@ -2948,6 +2994,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8ArrayElementType.TypeMapping = enum8Array.TypeMapping.ElementTypeMapping;
 
             var enum8AsString = runtimeEntityType.AddProperty(
                 "Enum8AsString",
@@ -3071,6 +3119,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringArrayElementType.TypeMapping = enum8AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum8AsStringCollection",
@@ -3144,6 +3195,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringCollectionElementType.TypeMapping = enum8AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum8Collection = runtimeEntityType.AddProperty(
                 "Enum8Collection",
@@ -3219,6 +3273,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8CollectionElementType.TypeMapping = enum8Collection.TypeMapping.ElementTypeMapping;
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                 "EnumToNumberConverterProperty",
@@ -3447,6 +3503,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16ArrayElementType.TypeMapping = enumU16Array.TypeMapping.ElementTypeMapping;
 
             var enumU16AsString = runtimeEntityType.AddProperty(
                 "EnumU16AsString",
@@ -3570,6 +3628,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringArrayElementType.TypeMapping = enumU16AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU16AsStringCollection",
@@ -3643,6 +3704,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringCollectionElementType.TypeMapping = enumU16AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU16Collection = runtimeEntityType.AddProperty(
                 "EnumU16Collection",
@@ -3718,6 +3782,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16CollectionElementType.TypeMapping = enumU16Collection.TypeMapping.ElementTypeMapping;
 
             var enumU32 = runtimeEntityType.AddProperty(
                 "EnumU32",
@@ -3844,6 +3910,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32ArrayElementType.TypeMapping = enumU32Array.TypeMapping.ElementTypeMapping;
 
             var enumU32AsString = runtimeEntityType.AddProperty(
                 "EnumU32AsString",
@@ -3967,6 +4035,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringArrayElementType.TypeMapping = enumU32AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU32AsStringCollection",
@@ -4040,6 +4111,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringCollectionElementType.TypeMapping = enumU32AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU32Collection = runtimeEntityType.AddProperty(
                 "EnumU32Collection",
@@ -4115,6 +4189,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32CollectionElementType.TypeMapping = enumU32Collection.TypeMapping.ElementTypeMapping;
 
             var enumU64 = runtimeEntityType.AddProperty(
                 "EnumU64",
@@ -4237,6 +4313,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64ArrayElementType.TypeMapping = enumU64Array.TypeMapping.ElementTypeMapping;
 
             var enumU64AsString = runtimeEntityType.AddProperty(
                 "EnumU64AsString",
@@ -4360,6 +4438,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringArrayElementType.TypeMapping = enumU64AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU64AsStringCollection",
@@ -4433,6 +4514,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringCollectionElementType.TypeMapping = enumU64AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU64Collection = runtimeEntityType.AddProperty(
                 "EnumU64Collection",
@@ -4506,6 +4590,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64CollectionElementType.TypeMapping = enumU64Collection.TypeMapping.ElementTypeMapping;
 
             var enumU8 = runtimeEntityType.AddProperty(
                 "EnumU8",
@@ -4632,6 +4718,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8ArrayElementType.TypeMapping = enumU8Array.TypeMapping.ElementTypeMapping;
 
             var enumU8AsString = runtimeEntityType.AddProperty(
                 "EnumU8AsString",
@@ -4755,6 +4843,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringArrayElementType.TypeMapping = enumU8AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU8AsStringCollection",
@@ -4828,6 +4919,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringCollectionElementType.TypeMapping = enumU8AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU8Collection = runtimeEntityType.AddProperty(
                 "EnumU8Collection",
@@ -4903,6 +4997,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8CollectionElementType.TypeMapping = enumU8Collection.TypeMapping.ElementTypeMapping;
 
             var @float = runtimeEntityType.AddProperty(
                 "Float",
@@ -5005,6 +5101,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         float (float v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
+            floatArrayElementType.TypeMapping = floatArray.TypeMapping.ElementTypeMapping;
 
             var guid = runtimeEntityType.AddProperty(
                 "Guid",
@@ -5079,6 +5177,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
                     SqliteJsonGuidReaderWriter.Instance),
                 elementMapping: SqliteGuidTypeMapping.Default);
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
+            guidArrayElementType.TypeMapping = guidArray.TypeMapping.ElementTypeMapping;
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "GuidToBytesConverterProperty",
@@ -5308,6 +5408,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
+            iPAddressArrayElementType.TypeMapping = iPAddressArray.TypeMapping.ElementTypeMapping;
 
             var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
                 "IPAddressReadOnlyCollection",
@@ -5383,6 +5485,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
+            iPAddressReadOnlyCollectionElementType.TypeMapping = iPAddressReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IPAddressToBytesConverterProperty",
@@ -5587,6 +5692,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
+            int16ArrayElementType.TypeMapping = int16Array.TypeMapping.ElementTypeMapping;
 
             var int32 = runtimeEntityType.AddProperty(
                 "Int32",
@@ -5689,6 +5796,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
+            int32ArrayElementType.TypeMapping = int32Array.TypeMapping.ElementTypeMapping;
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
                 "Int32ReadOnlyCollection",
@@ -5748,6 +5857,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
+            int32ReadOnlyCollectionElementType.TypeMapping = int32ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var int64 = runtimeEntityType.AddProperty(
                 "Int64",
@@ -5850,6 +5961,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         long (long v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
+            int64ArrayElementType.TypeMapping = int64Array.TypeMapping.ElementTypeMapping;
 
             var int8 = runtimeEntityType.AddProperty(
                 "Int8",
@@ -5952,6 +6065,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         sbyte (sbyte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
+            int8ArrayElementType.TypeMapping = int8Array.TypeMapping.ElementTypeMapping;
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IntNumberToBytesConverterProperty",
@@ -6212,6 +6327,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
+            nullableBoolArrayElementType.TypeMapping = nullableBoolArray.TypeMapping.ElementTypeMapping;
+            nullableBoolArrayElementType.SetComparer(new NullableValueComparer<bool>(nullableBoolArrayElementType.TypeMapping.Comparer));
 
             var nullableBytes = runtimeEntityType.AddProperty(
                 "NullableBytes",
@@ -6310,6 +6429,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                         int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                         byte[] (byte[] source) => source.ToArray())));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
+            nullableBytesArrayElementType.TypeMapping = nullableBytesArray.TypeMapping.ElementTypeMapping;
 
             var nullableChar = runtimeEntityType.AddProperty(
                 "NullableChar",
@@ -6414,6 +6536,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         char (char v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
+            nullableCharArrayElementType.TypeMapping = nullableCharArray.TypeMapping.ElementTypeMapping;
+            nullableCharArrayElementType.SetComparer(new NullableValueComparer<char>(nullableCharArrayElementType.TypeMapping.Comparer));
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
                 "NullableDateOnly",
@@ -6490,6 +6616,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateOnly?[], DateOnly>(
                     JsonDateOnlyReaderWriter.Instance),
                 elementMapping: SqliteDateOnlyTypeMapping.Default);
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
+            nullableDateOnlyArrayElementType.TypeMapping = nullableDateOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableDateOnlyArrayElementType.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnlyArrayElementType.TypeMapping.Comparer));
 
             var nullableDateTime = runtimeEntityType.AddProperty(
                 "NullableDateTime",
@@ -6566,6 +6696,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateTime?[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
+            nullableDateTimeArrayElementType.TypeMapping = nullableDateTimeArray.TypeMapping.ElementTypeMapping;
+            nullableDateTimeArrayElementType.SetComparer(new NullableValueComparer<DateTime>(nullableDateTimeArrayElementType.TypeMapping.Comparer));
 
             var nullableDecimal = runtimeEntityType.AddProperty(
                 "NullableDecimal",
@@ -6642,6 +6776,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<decimal?[], decimal>(
                     SqliteJsonDecimalReaderWriter.Instance),
                 elementMapping: SqliteDecimalTypeMapping.Default);
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
+            nullableDecimalArrayElementType.TypeMapping = nullableDecimalArray.TypeMapping.ElementTypeMapping;
+            nullableDecimalArrayElementType.SetComparer(new NullableValueComparer<decimal>(nullableDecimalArrayElementType.TypeMapping.Comparer));
 
             var nullableDouble = runtimeEntityType.AddProperty(
                 "NullableDouble",
@@ -6746,6 +6884,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         double (double v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
+            nullableDoubleArrayElementType.TypeMapping = nullableDoubleArray.TypeMapping.ElementTypeMapping;
+            nullableDoubleArrayElementType.SetComparer(new NullableValueComparer<double>(nullableDoubleArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
                 "NullableEnum16",
@@ -6874,6 +7016,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16ArrayElementType.TypeMapping = nullableEnum16Array.TypeMapping.ElementTypeMapping;
+            nullableEnum16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
                 "NullableEnum16AsString",
@@ -7002,6 +7148,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringArrayElementType.TypeMapping = nullableEnum16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum16AsStringCollection",
@@ -7077,6 +7227,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringCollectionElementType.TypeMapping = nullableEnum16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
                 "NullableEnum16Collection",
@@ -7152,6 +7306,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16CollectionElementType.TypeMapping = nullableEnum16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
                 "NullableEnum32",
@@ -7280,6 +7438,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32ArrayElementType.TypeMapping = nullableEnum32Array.TypeMapping.ElementTypeMapping;
+            nullableEnum32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
                 "NullableEnum32AsString",
@@ -7408,6 +7570,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringArrayElementType.TypeMapping = nullableEnum32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum32AsStringCollection",
@@ -7483,6 +7649,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringCollectionElementType.TypeMapping = nullableEnum32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
                 "NullableEnum32Collection",
@@ -7558,6 +7728,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32CollectionElementType.TypeMapping = nullableEnum32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
                 "NullableEnum64",
@@ -7686,6 +7860,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64ArrayElementType.TypeMapping = nullableEnum64Array.TypeMapping.ElementTypeMapping;
+            nullableEnum64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
                 "NullableEnum64AsString",
@@ -7814,6 +7992,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringArrayElementType.TypeMapping = nullableEnum64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum64AsStringCollection",
@@ -7889,6 +8071,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringCollectionElementType.TypeMapping = nullableEnum64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
                 "NullableEnum64Collection",
@@ -7964,6 +8150,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64CollectionElementType.TypeMapping = nullableEnum64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
                 "NullableEnum8",
@@ -8092,6 +8282,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8ArrayElementType.TypeMapping = nullableEnum8Array.TypeMapping.ElementTypeMapping;
+            nullableEnum8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
                 "NullableEnum8AsString",
@@ -8220,6 +8414,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringArrayElementType.TypeMapping = nullableEnum8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum8AsStringCollection",
@@ -8295,6 +8493,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringCollectionElementType.TypeMapping = nullableEnum8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
                 "NullableEnum8Collection",
@@ -8370,6 +8572,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8CollectionElementType.TypeMapping = nullableEnum8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
                 "NullableEnumU16",
@@ -8498,6 +8704,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16ArrayElementType.TypeMapping = nullableEnumU16Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsString",
@@ -8626,6 +8836,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringArrayElementType.TypeMapping = nullableEnumU16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsStringCollection",
@@ -8701,6 +8915,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringCollectionElementType.TypeMapping = nullableEnumU16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU16Collection",
@@ -8776,6 +8994,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16CollectionElementType.TypeMapping = nullableEnumU16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
                 "NullableEnumU32",
@@ -8904,6 +9126,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32ArrayElementType.TypeMapping = nullableEnumU32Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsString",
@@ -9032,6 +9258,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringArrayElementType.TypeMapping = nullableEnumU32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsStringCollection",
@@ -9107,6 +9337,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringCollectionElementType.TypeMapping = nullableEnumU32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU32Collection",
@@ -9182,6 +9416,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32CollectionElementType.TypeMapping = nullableEnumU32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
                 "NullableEnumU64",
@@ -9306,6 +9544,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64ArrayElementType.TypeMapping = nullableEnumU64Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsString",
@@ -9430,6 +9672,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringArrayElementType.TypeMapping = nullableEnumU64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsStringCollection",
@@ -9503,6 +9749,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringCollectionElementType.TypeMapping = nullableEnumU64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU64Collection",
@@ -9576,6 +9826,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64CollectionElementType.TypeMapping = nullableEnumU64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
                 "NullableEnumU8",
@@ -9704,6 +9958,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8ArrayElementType.TypeMapping = nullableEnumU8Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsString",
@@ -9832,6 +10090,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringArrayElementType.TypeMapping = nullableEnumU8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsStringCollection",
@@ -9907,6 +10169,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringCollectionElementType.TypeMapping = nullableEnumU8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU8Collection",
@@ -9982,6 +10248,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8CollectionElementType.TypeMapping = nullableEnumU8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8CollectionElementType.TypeMapping.Comparer));
 
             var nullableFloat = runtimeEntityType.AddProperty(
                 "NullableFloat",
@@ -10086,6 +10356,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         float (float v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
+            nullableFloatArrayElementType.TypeMapping = nullableFloatArray.TypeMapping.ElementTypeMapping;
+            nullableFloatArrayElementType.SetComparer(new NullableValueComparer<float>(nullableFloatArrayElementType.TypeMapping.Comparer));
 
             var nullableGuid = runtimeEntityType.AddProperty(
                 "NullableGuid",
@@ -10162,6 +10436,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
                     SqliteJsonGuidReaderWriter.Instance),
                 elementMapping: SqliteGuidTypeMapping.Default);
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
+            nullableGuidArrayElementType.TypeMapping = nullableGuidArray.TypeMapping.ElementTypeMapping;
+            nullableGuidArrayElementType.SetComparer(new NullableValueComparer<Guid>(nullableGuidArrayElementType.TypeMapping.Comparer));
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
                 "NullableIPAddress",
@@ -10288,6 +10566,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
+            nullableIPAddressArrayElementType.TypeMapping = nullableIPAddressArray.TypeMapping.ElementTypeMapping;
 
             var nullableInt16 = runtimeEntityType.AddProperty(
                 "NullableInt16",
@@ -10392,6 +10673,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
+            nullableInt16ArrayElementType.TypeMapping = nullableInt16Array.TypeMapping.ElementTypeMapping;
+            nullableInt16ArrayElementType.SetComparer(new NullableValueComparer<short>(nullableInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt32 = runtimeEntityType.AddProperty(
                 "NullableInt32",
@@ -10496,6 +10781,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
+            nullableInt32ArrayElementType.TypeMapping = nullableInt32Array.TypeMapping.ElementTypeMapping;
+            nullableInt32ArrayElementType.SetComparer(new NullableValueComparer<int>(nullableInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt64 = runtimeEntityType.AddProperty(
                 "NullableInt64",
@@ -10600,6 +10889,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         long (long v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
+            nullableInt64ArrayElementType.TypeMapping = nullableInt64Array.TypeMapping.ElementTypeMapping;
+            nullableInt64ArrayElementType.SetComparer(new NullableValueComparer<long>(nullableInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt8 = runtimeEntityType.AddProperty(
                 "NullableInt8",
@@ -10704,6 +10997,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         sbyte (sbyte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
+            nullableInt8ArrayElementType.TypeMapping = nullableInt8Array.TypeMapping.ElementTypeMapping;
+            nullableInt8ArrayElementType.SetComparer(new NullableValueComparer<sbyte>(nullableInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddress",
@@ -10830,6 +11127,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
+            nullablePhysicalAddressArrayElementType.TypeMapping = nullablePhysicalAddressArray.TypeMapping.ElementTypeMapping;
 
             var nullableString = runtimeEntityType.AddProperty(
                 "NullableString",
@@ -10904,6 +11204,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
+            nullableStringArrayElementType.TypeMapping = nullableStringArray.TypeMapping.ElementTypeMapping;
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
                 "NullableTimeOnly",
@@ -10980,6 +11283,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<TimeOnly?[], TimeOnly>(
                     JsonTimeOnlyReaderWriter.Instance),
                 elementMapping: SqliteTimeOnlyTypeMapping.Default);
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
+            nullableTimeOnlyArrayElementType.TypeMapping = nullableTimeOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableTimeOnlyArrayElementType.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnlyArrayElementType.TypeMapping.Comparer));
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
                 "NullableTimeSpan",
@@ -11084,6 +11391,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         TimeSpan (TimeSpan v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
+            nullableTimeSpanArrayElementType.TypeMapping = nullableTimeSpanArray.TypeMapping.ElementTypeMapping;
+            nullableTimeSpanArrayElementType.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpanArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
                 "NullableUInt16",
@@ -11188,6 +11499,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ushort (ushort v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
+            nullableUInt16ArrayElementType.TypeMapping = nullableUInt16Array.TypeMapping.ElementTypeMapping;
+            nullableUInt16ArrayElementType.SetComparer(new NullableValueComparer<ushort>(nullableUInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
                 "NullableUInt32",
@@ -11292,6 +11607,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         uint (uint v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
+            nullableUInt32ArrayElementType.TypeMapping = nullableUInt32Array.TypeMapping.ElementTypeMapping;
+            nullableUInt32ArrayElementType.SetComparer(new NullableValueComparer<uint>(nullableUInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
                 "NullableUInt64",
@@ -11368,6 +11687,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<ulong?[], ulong>(
                     JsonUInt64ReaderWriter.Instance),
                 elementMapping: SqliteULongTypeMapping.Default);
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
+            nullableUInt64ArrayElementType.TypeMapping = nullableUInt64Array.TypeMapping.ElementTypeMapping;
+            nullableUInt64ArrayElementType.SetComparer(new NullableValueComparer<ulong>(nullableUInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
                 "NullableUInt8",
@@ -11472,6 +11795,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
+            nullableUInt8ArrayElementType.TypeMapping = nullableUInt8Array.TypeMapping.ElementTypeMapping;
+            nullableUInt8ArrayElementType.SetComparer(new NullableValueComparer<byte>(nullableUInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullableUri = runtimeEntityType.AddProperty(
                 "NullableUri",
@@ -11594,6 +11921,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
+            nullableUriArrayElementType.TypeMapping = nullableUriArray.TypeMapping.ElementTypeMapping;
 
             var physicalAddress = runtimeEntityType.AddProperty(
                 "PhysicalAddress",
@@ -11719,6 +12049,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
+            physicalAddressArrayElementType.TypeMapping = physicalAddressArray.TypeMapping.ElementTypeMapping;
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "PhysicalAddressToBytesConverterProperty",
@@ -11894,6 +12226,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
+            stringArrayElementType.TypeMapping = stringArray.TypeMapping.ElementTypeMapping;
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
                 "StringReadOnlyCollection",
@@ -11939,6 +12273,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
+            stringReadOnlyCollectionElementType.TypeMapping = stringReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBoolConverterProperty",
@@ -12704,6 +13040,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<TimeOnly[], TimeOnly>(
                     JsonTimeOnlyReaderWriter.Instance),
                 elementMapping: SqliteTimeOnlyTypeMapping.Default);
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
+            timeOnlyArrayElementType.TypeMapping = timeOnlyArray.TypeMapping.ElementTypeMapping;
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeOnlyToStringConverterProperty",
@@ -12910,6 +13248,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         TimeSpan (TimeSpan v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
+            timeSpanArrayElementType.TypeMapping = timeSpanArray.TypeMapping.ElementTypeMapping;
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeSpanToStringConverterProperty",
@@ -13116,6 +13456,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ushort (ushort v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
+            uInt16ArrayElementType.TypeMapping = uInt16Array.TypeMapping.ElementTypeMapping;
 
             var uInt32 = runtimeEntityType.AddProperty(
                 "UInt32",
@@ -13218,6 +13560,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         uint (uint v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
+            uInt32ArrayElementType.TypeMapping = uInt32Array.TypeMapping.ElementTypeMapping;
 
             var uInt64 = runtimeEntityType.AddProperty(
                 "UInt64",
@@ -13292,6 +13636,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<ulong[], ulong>(
                     JsonUInt64ReaderWriter.Instance),
                 elementMapping: SqliteULongTypeMapping.Default);
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
+            uInt64ArrayElementType.TypeMapping = uInt64Array.TypeMapping.ElementTypeMapping;
 
             var uInt8 = runtimeEntityType.AddProperty(
                 "UInt8",
@@ -13434,6 +13780,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
+            uInt8ReadOnlyCollectionElementType.TypeMapping = uInt8ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var uri = runtimeEntityType.AddProperty(
                 "Uri",
@@ -13555,6 +13903,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
+            uriArrayElementType.TypeMapping = uriArray.TypeMapping.ElementTypeMapping;
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                 "UriToStringConverterProperty",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
index 79b5b18a79..5e2138669d 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
@@ -272,6 +272,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -318,6 +320,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -364,6 +368,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -440,6 +446,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -486,6 +494,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -546,6 +556,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -606,6 +618,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -666,6 +680,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
index 24d880519c..14bf283df2 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
@@ -263,6 +263,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -310,6 +312,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -357,6 +361,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -434,6 +440,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -481,6 +489,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -542,6 +552,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -603,6 +615,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -664,6 +678,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
index 536f05b130..30318fdcd6 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
@@ -433,6 +433,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -479,6 +481,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -525,6 +529,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -601,6 +607,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -647,6 +655,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -707,6 +717,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -767,6 +779,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -827,6 +841,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var key = runtimeEntityType.AddKey(
                 new[] { id });
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
index 2fec0bb509..2bfbd74c41 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
@@ -194,6 +194,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
+            boolArrayElementType.TypeMapping = boolArray.TypeMapping.ElementTypeMapping;
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
                 "BoolReadOnlyCollection",
@@ -253,6 +255,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
+            boolReadOnlyCollectionElementType.TypeMapping = boolReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BoolToStringConverterProperty",
@@ -504,6 +508,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                         int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                         byte[] (byte[] source) => source.ToArray())));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
+            bytesArrayElementType.TypeMapping = bytesArray.TypeMapping.ElementTypeMapping;
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BytesToStringConverterProperty",
@@ -706,6 +712,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         char (char v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
+            charArrayElementType.TypeMapping = charArray.TypeMapping.ElementTypeMapping;
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
                 "CharToStringConverterProperty",
@@ -832,6 +840,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateOnly[], DateOnly>(
                     JsonDateOnlyReaderWriter.Instance),
                 elementMapping: SqliteDateOnlyTypeMapping.Default);
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
+            dateOnlyArrayElementType.TypeMapping = dateOnlyArray.TypeMapping.ElementTypeMapping;
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "DateOnlyToStringConverterProperty",
@@ -958,6 +968,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
+            dateTimeArrayElementType.TypeMapping = dateTimeArray.TypeMapping.ElementTypeMapping;
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                 "DateTimeOffsetToBinaryConverterProperty",
@@ -1321,6 +1333,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<decimal[], decimal>(
                     SqliteJsonDecimalReaderWriter.Instance),
                 elementMapping: SqliteDecimalTypeMapping.Default);
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
+            decimalArrayElementType.TypeMapping = decimalArray.TypeMapping.ElementTypeMapping;
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DecimalNumberToBytesConverterProperty",
@@ -1527,6 +1541,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         double (double v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
+            doubleArrayElementType.TypeMapping = doubleArray.TypeMapping.ElementTypeMapping;
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DoubleNumberToBytesConverterProperty",
@@ -1757,6 +1773,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16ArrayElementType.TypeMapping = enum16Array.TypeMapping.ElementTypeMapping;
 
             var enum16AsString = runtimeEntityType.AddProperty(
                 "Enum16AsString",
@@ -1880,6 +1898,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringArrayElementType.TypeMapping = enum16AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum16AsStringCollection",
@@ -1953,6 +1974,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, string>(
                             string (CompiledModelTestBase.Enum16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum16 (string v) => StringEnumConverter<CompiledModelTestBase.Enum16, string, CompiledModelTestBase.Enum16>.ConvertToEnum(v)))));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
+            enum16AsStringCollectionElementType.TypeMapping = enum16AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum16Collection = runtimeEntityType.AddProperty(
                 "Enum16Collection",
@@ -2028,6 +2052,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
+            enum16CollectionElementType.TypeMapping = enum16Collection.TypeMapping.ElementTypeMapping;
 
             var enum32 = runtimeEntityType.AddProperty(
                 "Enum32",
@@ -2154,6 +2180,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32ArrayElementType.TypeMapping = enum32Array.TypeMapping.ElementTypeMapping;
 
             var enum32AsString = runtimeEntityType.AddProperty(
                 "Enum32AsString",
@@ -2277,6 +2305,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringArrayElementType.TypeMapping = enum32AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum32AsStringCollection",
@@ -2350,6 +2381,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, string>(
                             string (CompiledModelTestBase.Enum32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum32 (string v) => StringEnumConverter<CompiledModelTestBase.Enum32, string, CompiledModelTestBase.Enum32>.ConvertToEnum(v)))));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
+            enum32AsStringCollectionElementType.TypeMapping = enum32AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum32Collection = runtimeEntityType.AddProperty(
                 "Enum32Collection",
@@ -2425,6 +2459,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
+            enum32CollectionElementType.TypeMapping = enum32Collection.TypeMapping.ElementTypeMapping;
 
             var enum64 = runtimeEntityType.AddProperty(
                 "Enum64",
@@ -2551,6 +2587,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64ArrayElementType.TypeMapping = enum64Array.TypeMapping.ElementTypeMapping;
 
             var enum64AsString = runtimeEntityType.AddProperty(
                 "Enum64AsString",
@@ -2674,6 +2712,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringArrayElementType.TypeMapping = enum64AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum64AsStringCollection",
@@ -2747,6 +2788,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, string>(
                             string (CompiledModelTestBase.Enum64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum64 (string v) => StringEnumConverter<CompiledModelTestBase.Enum64, string, CompiledModelTestBase.Enum64>.ConvertToEnum(v)))));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
+            enum64AsStringCollectionElementType.TypeMapping = enum64AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum64Collection = runtimeEntityType.AddProperty(
                 "Enum64Collection",
@@ -2822,6 +2866,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
+            enum64CollectionElementType.TypeMapping = enum64Collection.TypeMapping.ElementTypeMapping;
 
             var enum8 = runtimeEntityType.AddProperty(
                 "Enum8",
@@ -2948,6 +2994,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8ArrayElementType.TypeMapping = enum8Array.TypeMapping.ElementTypeMapping;
 
             var enum8AsString = runtimeEntityType.AddProperty(
                 "Enum8AsString",
@@ -3071,6 +3119,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringArrayElementType.TypeMapping = enum8AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum8AsStringCollection",
@@ -3144,6 +3195,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, string>(
                             string (CompiledModelTestBase.Enum8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.Enum8 (string v) => StringEnumConverter<CompiledModelTestBase.Enum8, string, CompiledModelTestBase.Enum8>.ConvertToEnum(v)))));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
+            enum8AsStringCollectionElementType.TypeMapping = enum8AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enum8Collection = runtimeEntityType.AddProperty(
                 "Enum8Collection",
@@ -3219,6 +3273,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
+            enum8CollectionElementType.TypeMapping = enum8Collection.TypeMapping.ElementTypeMapping;
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                 "EnumToNumberConverterProperty",
@@ -3447,6 +3503,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16ArrayElementType.TypeMapping = enumU16Array.TypeMapping.ElementTypeMapping;
 
             var enumU16AsString = runtimeEntityType.AddProperty(
                 "EnumU16AsString",
@@ -3570,6 +3628,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringArrayElementType.TypeMapping = enumU16AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU16AsStringCollection",
@@ -3643,6 +3704,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, string>(
                             string (CompiledModelTestBase.EnumU16 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU16 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU16, string, CompiledModelTestBase.EnumU16>.ConvertToEnum(v)))));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
+            enumU16AsStringCollectionElementType.TypeMapping = enumU16AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU16Collection = runtimeEntityType.AddProperty(
                 "EnumU16Collection",
@@ -3718,6 +3782,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
+            enumU16CollectionElementType.TypeMapping = enumU16Collection.TypeMapping.ElementTypeMapping;
 
             var enumU32 = runtimeEntityType.AddProperty(
                 "EnumU32",
@@ -3844,6 +3910,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32ArrayElementType.TypeMapping = enumU32Array.TypeMapping.ElementTypeMapping;
 
             var enumU32AsString = runtimeEntityType.AddProperty(
                 "EnumU32AsString",
@@ -3967,6 +4035,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringArrayElementType.TypeMapping = enumU32AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU32AsStringCollection",
@@ -4040,6 +4111,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, string>(
                             string (CompiledModelTestBase.EnumU32 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU32 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU32, string, CompiledModelTestBase.EnumU32>.ConvertToEnum(v)))));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
+            enumU32AsStringCollectionElementType.TypeMapping = enumU32AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU32Collection = runtimeEntityType.AddProperty(
                 "EnumU32Collection",
@@ -4115,6 +4189,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
+            enumU32CollectionElementType.TypeMapping = enumU32Collection.TypeMapping.ElementTypeMapping;
 
             var enumU64 = runtimeEntityType.AddProperty(
                 "EnumU64",
@@ -4237,6 +4313,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64ArrayElementType.TypeMapping = enumU64Array.TypeMapping.ElementTypeMapping;
 
             var enumU64AsString = runtimeEntityType.AddProperty(
                 "EnumU64AsString",
@@ -4360,6 +4438,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringArrayElementType.TypeMapping = enumU64AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU64AsStringCollection",
@@ -4433,6 +4514,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, string>(
                             string (CompiledModelTestBase.EnumU64 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU64 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU64, string, CompiledModelTestBase.EnumU64>.ConvertToEnum(v)))));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
+            enumU64AsStringCollectionElementType.TypeMapping = enumU64AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU64Collection = runtimeEntityType.AddProperty(
                 "EnumU64Collection",
@@ -4506,6 +4590,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
+            enumU64CollectionElementType.TypeMapping = enumU64Collection.TypeMapping.ElementTypeMapping;
 
             var enumU8 = runtimeEntityType.AddProperty(
                 "EnumU8",
@@ -4632,6 +4718,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8ArrayElementType.TypeMapping = enumU8Array.TypeMapping.ElementTypeMapping;
 
             var enumU8AsString = runtimeEntityType.AddProperty(
                 "EnumU8AsString",
@@ -4755,6 +4843,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringArrayElementType.TypeMapping = enumU8AsStringArray.TypeMapping.ElementTypeMapping;
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU8AsStringCollection",
@@ -4828,6 +4919,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, string>(
                             string (CompiledModelTestBase.EnumU8 v) => ((object)v).ToString(),
                             CompiledModelTestBase.EnumU8 (string v) => StringEnumConverter<CompiledModelTestBase.EnumU8, string, CompiledModelTestBase.EnumU8>.ConvertToEnum(v)))));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
+            enumU8AsStringCollectionElementType.TypeMapping = enumU8AsStringCollection.TypeMapping.ElementTypeMapping;
 
             var enumU8Collection = runtimeEntityType.AddProperty(
                 "EnumU8Collection",
@@ -4903,6 +4997,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
+            enumU8CollectionElementType.TypeMapping = enumU8Collection.TypeMapping.ElementTypeMapping;
 
             var @float = runtimeEntityType.AddProperty(
                 "Float",
@@ -5005,6 +5101,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         float (float v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
+            floatArrayElementType.TypeMapping = floatArray.TypeMapping.ElementTypeMapping;
 
             var guid = runtimeEntityType.AddProperty(
                 "Guid",
@@ -5079,6 +5177,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<Guid[], Guid>(
                     SqliteJsonGuidReaderWriter.Instance),
                 elementMapping: SqliteGuidTypeMapping.Default);
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
+            guidArrayElementType.TypeMapping = guidArray.TypeMapping.ElementTypeMapping;
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "GuidToBytesConverterProperty",
@@ -5308,6 +5408,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
+            iPAddressArrayElementType.TypeMapping = iPAddressArray.TypeMapping.ElementTypeMapping;
 
             var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
                 "IPAddressReadOnlyCollection",
@@ -5383,6 +5485,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
+            iPAddressReadOnlyCollectionElementType.TypeMapping = iPAddressReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IPAddressToBytesConverterProperty",
@@ -5587,6 +5692,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
+            int16ArrayElementType.TypeMapping = int16Array.TypeMapping.ElementTypeMapping;
 
             var int32 = runtimeEntityType.AddProperty(
                 "Int32",
@@ -5689,6 +5796,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
+            int32ArrayElementType.TypeMapping = int32Array.TypeMapping.ElementTypeMapping;
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
                 "Int32ReadOnlyCollection",
@@ -5748,6 +5857,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
+            int32ReadOnlyCollectionElementType.TypeMapping = int32ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var int64 = runtimeEntityType.AddProperty(
                 "Int64",
@@ -5850,6 +5961,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         long (long v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
+            int64ArrayElementType.TypeMapping = int64Array.TypeMapping.ElementTypeMapping;
 
             var int8 = runtimeEntityType.AddProperty(
                 "Int8",
@@ -5952,6 +6065,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         sbyte (sbyte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
+            int8ArrayElementType.TypeMapping = int8Array.TypeMapping.ElementTypeMapping;
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IntNumberToBytesConverterProperty",
@@ -6212,6 +6327,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (bool v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
+            nullableBoolArrayElementType.TypeMapping = nullableBoolArray.TypeMapping.ElementTypeMapping;
+            nullableBoolArrayElementType.SetComparer(new NullableValueComparer<bool>(nullableBoolArrayElementType.TypeMapping.Comparer));
 
             var nullableBytes = runtimeEntityType.AddProperty(
                 "NullableBytes",
@@ -6310,6 +6429,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         bool (byte[] v1, byte[] v2) => StructuralComparisons.StructuralEqualityComparer.Equals(((object)(v1)), ((object)(v2))),
                         int (byte[] v) => StructuralComparisons.StructuralEqualityComparer.GetHashCode(((object)(v))),
                         byte[] (byte[] source) => source.ToArray())));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
+            nullableBytesArrayElementType.TypeMapping = nullableBytesArray.TypeMapping.ElementTypeMapping;
 
             var nullableChar = runtimeEntityType.AddProperty(
                 "NullableChar",
@@ -6414,6 +6536,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         char (char v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
+            nullableCharArrayElementType.TypeMapping = nullableCharArray.TypeMapping.ElementTypeMapping;
+            nullableCharArrayElementType.SetComparer(new NullableValueComparer<char>(nullableCharArrayElementType.TypeMapping.Comparer));
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
                 "NullableDateOnly",
@@ -6490,6 +6616,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateOnly?[], DateOnly>(
                     JsonDateOnlyReaderWriter.Instance),
                 elementMapping: SqliteDateOnlyTypeMapping.Default);
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
+            nullableDateOnlyArrayElementType.TypeMapping = nullableDateOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableDateOnlyArrayElementType.SetComparer(new NullableValueComparer<DateOnly>(nullableDateOnlyArrayElementType.TypeMapping.Comparer));
 
             var nullableDateTime = runtimeEntityType.AddProperty(
                 "NullableDateTime",
@@ -6566,6 +6696,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<DateTime?[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
+            nullableDateTimeArrayElementType.TypeMapping = nullableDateTimeArray.TypeMapping.ElementTypeMapping;
+            nullableDateTimeArrayElementType.SetComparer(new NullableValueComparer<DateTime>(nullableDateTimeArrayElementType.TypeMapping.Comparer));
 
             var nullableDecimal = runtimeEntityType.AddProperty(
                 "NullableDecimal",
@@ -6642,6 +6776,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<decimal?[], decimal>(
                     SqliteJsonDecimalReaderWriter.Instance),
                 elementMapping: SqliteDecimalTypeMapping.Default);
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
+            nullableDecimalArrayElementType.TypeMapping = nullableDecimalArray.TypeMapping.ElementTypeMapping;
+            nullableDecimalArrayElementType.SetComparer(new NullableValueComparer<decimal>(nullableDecimalArrayElementType.TypeMapping.Comparer));
 
             var nullableDouble = runtimeEntityType.AddProperty(
                 "NullableDouble",
@@ -6746,6 +6884,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         double (double v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
+            nullableDoubleArrayElementType.TypeMapping = nullableDoubleArray.TypeMapping.ElementTypeMapping;
+            nullableDoubleArrayElementType.SetComparer(new NullableValueComparer<double>(nullableDoubleArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
                 "NullableEnum16",
@@ -6874,6 +7016,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16ArrayElementType.TypeMapping = nullableEnum16Array.TypeMapping.ElementTypeMapping;
+            nullableEnum16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
                 "NullableEnum16AsString",
@@ -7002,6 +7148,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringArrayElementType.TypeMapping = nullableEnum16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum16AsStringCollection",
@@ -7077,6 +7227,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16AsStringCollectionElementType.TypeMapping = nullableEnum16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
                 "NullableEnum16Collection",
@@ -7152,6 +7306,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum16, short>(
                             short (CompiledModelTestBase.Enum16 value) => ((short)(value)),
                             CompiledModelTestBase.Enum16 (short value) => ((CompiledModelTestBase.Enum16)(value))))));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
+            nullableEnum16CollectionElementType.TypeMapping = nullableEnum16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum16>(nullableEnum16CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
                 "NullableEnum32",
@@ -7280,6 +7438,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32ArrayElementType.TypeMapping = nullableEnum32Array.TypeMapping.ElementTypeMapping;
+            nullableEnum32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
                 "NullableEnum32AsString",
@@ -7408,6 +7570,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringArrayElementType.TypeMapping = nullableEnum32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum32AsStringCollection",
@@ -7483,6 +7649,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32AsStringCollectionElementType.TypeMapping = nullableEnum32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
                 "NullableEnum32Collection",
@@ -7558,6 +7728,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum32, int>(
                             int (CompiledModelTestBase.Enum32 value) => ((int)(value)),
                             CompiledModelTestBase.Enum32 (int value) => ((CompiledModelTestBase.Enum32)(value))))));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
+            nullableEnum32CollectionElementType.TypeMapping = nullableEnum32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum32>(nullableEnum32CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
                 "NullableEnum64",
@@ -7686,6 +7860,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64ArrayElementType.TypeMapping = nullableEnum64Array.TypeMapping.ElementTypeMapping;
+            nullableEnum64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
                 "NullableEnum64AsString",
@@ -7814,6 +7992,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringArrayElementType.TypeMapping = nullableEnum64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum64AsStringCollection",
@@ -7889,6 +8071,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64AsStringCollectionElementType.TypeMapping = nullableEnum64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
                 "NullableEnum64Collection",
@@ -7964,6 +8150,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum64, long>(
                             long (CompiledModelTestBase.Enum64 value) => ((long)(value)),
                             CompiledModelTestBase.Enum64 (long value) => ((CompiledModelTestBase.Enum64)(value))))));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
+            nullableEnum64CollectionElementType.TypeMapping = nullableEnum64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum64>(nullableEnum64CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
                 "NullableEnum8",
@@ -8092,6 +8282,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8ArrayElementType.TypeMapping = nullableEnum8Array.TypeMapping.ElementTypeMapping;
+            nullableEnum8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
                 "NullableEnum8AsString",
@@ -8220,6 +8414,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringArrayElementType.TypeMapping = nullableEnum8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum8AsStringCollection",
@@ -8295,6 +8493,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8AsStringCollectionElementType.TypeMapping = nullableEnum8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnum8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
                 "NullableEnum8Collection",
@@ -8370,6 +8572,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.Enum8, sbyte>(
                             sbyte (CompiledModelTestBase.Enum8 value) => ((sbyte)(value)),
                             CompiledModelTestBase.Enum8 (sbyte value) => ((CompiledModelTestBase.Enum8)(value))))));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
+            nullableEnum8CollectionElementType.TypeMapping = nullableEnum8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnum8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.Enum8>(nullableEnum8CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
                 "NullableEnumU16",
@@ -8498,6 +8704,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16ArrayElementType.TypeMapping = nullableEnumU16Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU16ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsString",
@@ -8626,6 +8836,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringArrayElementType.TypeMapping = nullableEnumU16AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsStringCollection",
@@ -8701,6 +8915,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16AsStringCollectionElementType.TypeMapping = nullableEnumU16AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU16Collection",
@@ -8776,6 +8994,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU16, ushort>(
                             ushort (CompiledModelTestBase.EnumU16 value) => ((ushort)(value)),
                             CompiledModelTestBase.EnumU16 (ushort value) => ((CompiledModelTestBase.EnumU16)(value))))));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
+            nullableEnumU16CollectionElementType.TypeMapping = nullableEnumU16Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU16CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU16>(nullableEnumU16CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
                 "NullableEnumU32",
@@ -8904,6 +9126,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32ArrayElementType.TypeMapping = nullableEnumU32Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU32ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsString",
@@ -9032,6 +9258,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringArrayElementType.TypeMapping = nullableEnumU32AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsStringCollection",
@@ -9107,6 +9337,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32AsStringCollectionElementType.TypeMapping = nullableEnumU32AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU32Collection",
@@ -9182,6 +9416,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU32, uint>(
                             uint (CompiledModelTestBase.EnumU32 value) => ((uint)(value)),
                             CompiledModelTestBase.EnumU32 (uint value) => ((CompiledModelTestBase.EnumU32)(value))))));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
+            nullableEnumU32CollectionElementType.TypeMapping = nullableEnumU32Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU32CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU32>(nullableEnumU32CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
                 "NullableEnumU64",
@@ -9306,6 +9544,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64ArrayElementType.TypeMapping = nullableEnumU64Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU64ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsString",
@@ -9430,6 +9672,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringArrayElementType.TypeMapping = nullableEnumU64AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsStringCollection",
@@ -9503,6 +9749,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64AsStringCollectionElementType.TypeMapping = nullableEnumU64AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU64Collection",
@@ -9576,6 +9826,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU64, ulong>(
                             ulong (CompiledModelTestBase.EnumU64 value) => ((ulong)(value)),
                             CompiledModelTestBase.EnumU64 (ulong value) => ((CompiledModelTestBase.EnumU64)(value))))));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
+            nullableEnumU64CollectionElementType.TypeMapping = nullableEnumU64Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU64CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU64>(nullableEnumU64CollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
                 "NullableEnumU8",
@@ -9704,6 +9958,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8ArrayElementType.TypeMapping = nullableEnumU8Array.TypeMapping.ElementTypeMapping;
+            nullableEnumU8ArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8ArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsString",
@@ -9832,6 +10090,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringArrayElementType.TypeMapping = nullableEnumU8AsStringArray.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringArrayElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringArrayElementType.TypeMapping.Comparer));
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsStringCollection",
@@ -9907,6 +10169,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8AsStringCollectionElementType.TypeMapping = nullableEnumU8AsStringCollection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8AsStringCollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8AsStringCollectionElementType.TypeMapping.Comparer));
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU8Collection",
@@ -9982,6 +10248,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<CompiledModelTestBase.EnumU8, byte>(
                             byte (CompiledModelTestBase.EnumU8 value) => ((byte)(value)),
                             CompiledModelTestBase.EnumU8 (byte value) => ((CompiledModelTestBase.EnumU8)(value))))));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
+            nullableEnumU8CollectionElementType.TypeMapping = nullableEnumU8Collection.TypeMapping.ElementTypeMapping;
+            nullableEnumU8CollectionElementType.SetComparer(new NullableValueComparer<CompiledModelTestBase.EnumU8>(nullableEnumU8CollectionElementType.TypeMapping.Comparer));
 
             var nullableFloat = runtimeEntityType.AddProperty(
                 "NullableFloat",
@@ -10086,6 +10356,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         float (float v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "REAL")));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
+            nullableFloatArrayElementType.TypeMapping = nullableFloatArray.TypeMapping.ElementTypeMapping;
+            nullableFloatArrayElementType.SetComparer(new NullableValueComparer<float>(nullableFloatArrayElementType.TypeMapping.Comparer));
 
             var nullableGuid = runtimeEntityType.AddProperty(
                 "NullableGuid",
@@ -10162,6 +10436,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<Guid?[], Guid>(
                     SqliteJsonGuidReaderWriter.Instance),
                 elementMapping: SqliteGuidTypeMapping.Default);
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
+            nullableGuidArrayElementType.TypeMapping = nullableGuidArray.TypeMapping.ElementTypeMapping;
+            nullableGuidArrayElementType.SetComparer(new NullableValueComparer<Guid>(nullableGuidArrayElementType.TypeMapping.Comparer));
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
                 "NullableIPAddress",
@@ -10288,6 +10566,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
+            nullableIPAddressArrayElementType.TypeMapping = nullableIPAddressArray.TypeMapping.ElementTypeMapping;
 
             var nullableInt16 = runtimeEntityType.AddProperty(
                 "NullableInt16",
@@ -10392,6 +10673,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
+            nullableInt16ArrayElementType.TypeMapping = nullableInt16Array.TypeMapping.ElementTypeMapping;
+            nullableInt16ArrayElementType.SetComparer(new NullableValueComparer<short>(nullableInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt32 = runtimeEntityType.AddProperty(
                 "NullableInt32",
@@ -10496,6 +10781,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         int (int v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
+            nullableInt32ArrayElementType.TypeMapping = nullableInt32Array.TypeMapping.ElementTypeMapping;
+            nullableInt32ArrayElementType.SetComparer(new NullableValueComparer<int>(nullableInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt64 = runtimeEntityType.AddProperty(
                 "NullableInt64",
@@ -10600,6 +10889,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         long (long v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
+            nullableInt64ArrayElementType.TypeMapping = nullableInt64Array.TypeMapping.ElementTypeMapping;
+            nullableInt64ArrayElementType.SetComparer(new NullableValueComparer<long>(nullableInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableInt8 = runtimeEntityType.AddProperty(
                 "NullableInt8",
@@ -10704,6 +10997,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         sbyte (sbyte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
+            nullableInt8ArrayElementType.TypeMapping = nullableInt8Array.TypeMapping.ElementTypeMapping;
+            nullableInt8ArrayElementType.SetComparer(new NullableValueComparer<sbyte>(nullableInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddress",
@@ -10830,6 +11127,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
+            nullablePhysicalAddressArrayElementType.TypeMapping = nullablePhysicalAddressArray.TypeMapping.ElementTypeMapping;
 
             var nullableString = runtimeEntityType.AddProperty(
                 "NullableString",
@@ -10904,6 +11204,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
+            nullableStringArrayElementType.TypeMapping = nullableStringArray.TypeMapping.ElementTypeMapping;
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
                 "NullableTimeOnly",
@@ -10980,6 +11283,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<TimeOnly?[], TimeOnly>(
                     JsonTimeOnlyReaderWriter.Instance),
                 elementMapping: SqliteTimeOnlyTypeMapping.Default);
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
+            nullableTimeOnlyArrayElementType.TypeMapping = nullableTimeOnlyArray.TypeMapping.ElementTypeMapping;
+            nullableTimeOnlyArrayElementType.SetComparer(new NullableValueComparer<TimeOnly>(nullableTimeOnlyArrayElementType.TypeMapping.Comparer));
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
                 "NullableTimeSpan",
@@ -11084,6 +11391,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         TimeSpan (TimeSpan v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
+            nullableTimeSpanArrayElementType.TypeMapping = nullableTimeSpanArray.TypeMapping.ElementTypeMapping;
+            nullableTimeSpanArrayElementType.SetComparer(new NullableValueComparer<TimeSpan>(nullableTimeSpanArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
                 "NullableUInt16",
@@ -11188,6 +11499,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ushort (ushort v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
+            nullableUInt16ArrayElementType.TypeMapping = nullableUInt16Array.TypeMapping.ElementTypeMapping;
+            nullableUInt16ArrayElementType.SetComparer(new NullableValueComparer<ushort>(nullableUInt16ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
                 "NullableUInt32",
@@ -11292,6 +11607,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         uint (uint v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
+            nullableUInt32ArrayElementType.TypeMapping = nullableUInt32Array.TypeMapping.ElementTypeMapping;
+            nullableUInt32ArrayElementType.SetComparer(new NullableValueComparer<uint>(nullableUInt32ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
                 "NullableUInt64",
@@ -11368,6 +11687,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfNullableStructsReaderWriter<ulong?[], ulong>(
                     JsonUInt64ReaderWriter.Instance),
                 elementMapping: SqliteULongTypeMapping.Default);
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
+            nullableUInt64ArrayElementType.TypeMapping = nullableUInt64Array.TypeMapping.ElementTypeMapping;
+            nullableUInt64ArrayElementType.SetComparer(new NullableValueComparer<ulong>(nullableUInt64ArrayElementType.TypeMapping.Comparer));
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
                 "NullableUInt8",
@@ -11472,6 +11795,10 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
+            nullableUInt8ArrayElementType.TypeMapping = nullableUInt8Array.TypeMapping.ElementTypeMapping;
+            nullableUInt8ArrayElementType.SetComparer(new NullableValueComparer<byte>(nullableUInt8ArrayElementType.TypeMapping.Comparer));
 
             var nullableUri = runtimeEntityType.AddProperty(
                 "NullableUri",
@@ -11594,6 +11921,9 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
+            nullableUriArrayElementType.TypeMapping = nullableUriArray.TypeMapping.ElementTypeMapping;
 
             var physicalAddress = runtimeEntityType.AddProperty(
                 "PhysicalAddress",
@@ -11719,6 +12049,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<PhysicalAddress, string>(
                             string (PhysicalAddress v) => ((object)v).ToString(),
                             PhysicalAddress (string v) => PhysicalAddress.Parse(v)))));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
+            physicalAddressArrayElementType.TypeMapping = physicalAddressArray.TypeMapping.ElementTypeMapping;
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "PhysicalAddressToBytesConverterProperty",
@@ -11894,6 +12226,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<string[], string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
+            stringArrayElementType.TypeMapping = stringArray.TypeMapping.ElementTypeMapping;
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
                 "StringReadOnlyCollection",
@@ -11939,6 +12273,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
+            stringReadOnlyCollectionElementType.TypeMapping = stringReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBoolConverterProperty",
@@ -12704,6 +13040,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<TimeOnly[], TimeOnly>(
                     JsonTimeOnlyReaderWriter.Instance),
                 elementMapping: SqliteTimeOnlyTypeMapping.Default);
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
+            timeOnlyArrayElementType.TypeMapping = timeOnlyArray.TypeMapping.ElementTypeMapping;
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeOnlyToStringConverterProperty",
@@ -12910,6 +13248,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         TimeSpan (TimeSpan v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "TEXT")));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
+            timeSpanArrayElementType.TypeMapping = timeSpanArray.TypeMapping.ElementTypeMapping;
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeSpanToStringConverterProperty",
@@ -13116,6 +13456,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         ushort (ushort v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
+            uInt16ArrayElementType.TypeMapping = uInt16Array.TypeMapping.ElementTypeMapping;
 
             var uInt32 = runtimeEntityType.AddProperty(
                 "UInt32",
@@ -13218,6 +13560,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         uint (uint v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
+            uInt32ArrayElementType.TypeMapping = uInt32Array.TypeMapping.ElementTypeMapping;
 
             var uInt64 = runtimeEntityType.AddProperty(
                 "UInt64",
@@ -13292,6 +13636,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<ulong[], ulong>(
                     JsonUInt64ReaderWriter.Instance),
                 elementMapping: SqliteULongTypeMapping.Default);
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
+            uInt64ArrayElementType.TypeMapping = uInt64Array.TypeMapping.ElementTypeMapping;
 
             var uInt8 = runtimeEntityType.AddProperty(
                 "UInt8",
@@ -13434,6 +13780,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
+            uInt8ReadOnlyCollectionElementType.TypeMapping = uInt8ReadOnlyCollection.TypeMapping.ElementTypeMapping;
 
             var uri = runtimeEntityType.AddProperty(
                 "Uri",
@@ -13555,6 +13903,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<Uri, string>(
                             string (Uri v) => ((object)v).ToString(),
                             Uri (string v) => new Uri(v, UriKind.RelativeOrAbsolute)))));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
+            uriArrayElementType.TypeMapping = uriArray.TypeMapping.ElementTypeMapping;
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                 "UriToStringConverterProperty",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
index ea942c6faa..f8abb5ac45 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
@@ -273,6 +273,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -319,6 +321,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -365,6 +369,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -441,6 +447,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -487,6 +495,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -547,6 +557,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -607,6 +619,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -667,6 +681,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
index 0be37f0f60..426cda080e 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
@@ -243,6 +243,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -290,6 +292,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -337,6 +341,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -414,6 +420,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -461,6 +469,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -522,6 +532,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -583,6 +595,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -644,6 +658,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
index 8455fd3e24..1a12f59b3e 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
@@ -445,6 +445,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
+            refTypeArrayElementType.TypeMapping = refTypeArray.TypeMapping.ElementTypeMapping;
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -491,6 +493,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
+            refTypeEnumerableElementType.TypeMapping = refTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -537,6 +541,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfReferencesReaderWriter<List<string>, string>(
                     JsonStringReaderWriter.Instance),
                 elementMapping: SqliteStringTypeMapping.Default);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
+            refTypeIListElementType.TypeMapping = refTypeIList.TypeMapping.ElementTypeMapping;
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -613,6 +619,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         new ValueConverter<IPAddress, string>(
                             string (IPAddress v) => ((object)v).ToString(),
                             IPAddress (string v) => IPAddress.Parse(v)))));
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
+            refTypeListElementType.TypeMapping = refTypeList.TypeMapping.ElementTypeMapping;
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -659,6 +667,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 jsonValueReaderWriter: new JsonCollectionOfStructsReaderWriter<DateTime[], DateTime>(
                     SqliteJsonDateTimeReaderWriter.Instance),
                 elementMapping: SqliteDateTimeTypeMapping.Default);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
+            valueTypeArrayElementType.TypeMapping = valueTypeArray.TypeMapping.ElementTypeMapping;
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -719,6 +729,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
+            valueTypeEnumerableElementType.TypeMapping = valueTypeEnumerable.TypeMapping.ElementTypeMapping;
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -779,6 +791,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         byte (byte v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
+            valueTypeIListElementType.TypeMapping = valueTypeIList.TypeMapping.ElementTypeMapping;
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -839,6 +853,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                         short (short v) => v),
                     mappingInfo: new RelationalTypeMappingInfo(
                         storeTypeName: "INTEGER")));
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
+            valueTypeListElementType.TypeMapping = valueTypeList.TypeMapping.ElementTypeMapping;
 
             var key = runtimeEntityType.AddKey(
                 new[] { id });
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
index f6777a1fcc..6247347dc2 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/ManyTypesEntityType.cs
@@ -53,12 +53,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolArrayElementType = boolArray.SetElementType(typeof(bool));
 
             var boolReadOnlyCollection = runtimeEntityType.AddProperty(
                 "BoolReadOnlyCollection",
                 typeof(IReadOnlyCollection<bool>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BoolReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_boolReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var boolReadOnlyCollectionElementType = boolReadOnlyCollection.SetElementType(typeof(bool));
 
             var boolToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BoolToStringConverterProperty",
@@ -119,6 +121,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("BytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<BytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var bytesArrayElementType = bytesArray.SetElementType(typeof(byte[]));
 
             var bytesToStringConverterProperty = runtimeEntityType.AddProperty(
                 "BytesToStringConverterProperty",
@@ -148,6 +151,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("CharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<CharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var charArrayElementType = charArray.SetElementType(typeof(char));
 
             var charToStringConverterProperty = runtimeEntityType.AddProperty(
                 "CharToStringConverterProperty",
@@ -169,6 +173,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var dateOnlyArrayElementType = dateOnlyArray.SetElementType(typeof(DateOnly));
 
             var dateOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "DateOnlyToStringConverterProperty",
@@ -190,6 +195,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateTime[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var dateTimeArrayElementType = dateTimeArray.SetElementType(typeof(DateTime));
 
             var dateTimeOffsetToBinaryConverterProperty = runtimeEntityType.AddProperty(
                 "DateTimeOffsetToBinaryConverterProperty",
@@ -250,6 +256,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var decimalArrayElementType = decimalArray.SetElementType(typeof(decimal));
 
             var decimalNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DecimalNumberToBytesConverterProperty",
@@ -279,6 +286,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("DoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<DoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var doubleArrayElementType = doubleArray.SetElementType(typeof(double));
 
             var doubleNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "DoubleNumberToBytesConverterProperty",
@@ -308,6 +316,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16ArrayElementType = enum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16));
 
             var enum16AsString = runtimeEntityType.AddProperty(
                 "Enum16AsString",
@@ -322,18 +331,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16AsStringArrayElementType = enum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
 
             var enum16AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum16AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16AsStringCollectionElementType = enum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16),
+                providerClrType: typeof(string));
 
             var enum16Collection = runtimeEntityType.AddProperty(
                 "Enum16Collection",
                 typeof(List<CompiledModelTestBase.Enum16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum16CollectionElementType = enum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16));
 
             var enum32 = runtimeEntityType.AddProperty(
                 "Enum32",
@@ -347,6 +361,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32ArrayElementType = enum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32));
 
             var enum32AsString = runtimeEntityType.AddProperty(
                 "Enum32AsString",
@@ -361,18 +376,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32AsStringArrayElementType = enum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
 
             var enum32AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum32AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32AsStringCollectionElementType = enum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32),
+                providerClrType: typeof(string));
 
             var enum32Collection = runtimeEntityType.AddProperty(
                 "Enum32Collection",
                 typeof(List<CompiledModelTestBase.Enum32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum32CollectionElementType = enum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32));
 
             var enum64 = runtimeEntityType.AddProperty(
                 "Enum64",
@@ -386,6 +406,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64ArrayElementType = enum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64));
 
             var enum64AsString = runtimeEntityType.AddProperty(
                 "Enum64AsString",
@@ -400,18 +421,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64AsStringArrayElementType = enum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
 
             var enum64AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum64AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64AsStringCollectionElementType = enum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64),
+                providerClrType: typeof(string));
 
             var enum64Collection = runtimeEntityType.AddProperty(
                 "Enum64Collection",
                 typeof(List<CompiledModelTestBase.Enum64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum64CollectionElementType = enum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64));
 
             var enum8 = runtimeEntityType.AddProperty(
                 "Enum8",
@@ -425,6 +451,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8ArrayElementType = enum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8));
 
             var enum8AsString = runtimeEntityType.AddProperty(
                 "Enum8AsString",
@@ -439,18 +466,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8AsStringArrayElementType = enum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
 
             var enum8AsStringCollection = runtimeEntityType.AddProperty(
                 "Enum8AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8AsStringCollectionElementType = enum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8),
+                providerClrType: typeof(string));
 
             var enum8Collection = runtimeEntityType.AddProperty(
                 "Enum8Collection",
                 typeof(List<CompiledModelTestBase.Enum8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Enum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Enum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enum8CollectionElementType = enum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8));
 
             var enumToNumberConverterProperty = runtimeEntityType.AddProperty(
                 "EnumToNumberConverterProperty",
@@ -480,6 +512,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16ArrayElementType = enumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16));
 
             var enumU16AsString = runtimeEntityType.AddProperty(
                 "EnumU16AsString",
@@ -494,18 +527,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16AsStringArrayElementType = enumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
 
             var enumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU16AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16AsStringCollectionElementType = enumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16),
+                providerClrType: typeof(string));
 
             var enumU16Collection = runtimeEntityType.AddProperty(
                 "EnumU16Collection",
                 typeof(List<CompiledModelTestBase.EnumU16>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU16CollectionElementType = enumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16));
 
             var enumU32 = runtimeEntityType.AddProperty(
                 "EnumU32",
@@ -519,6 +557,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32ArrayElementType = enumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32));
 
             var enumU32AsString = runtimeEntityType.AddProperty(
                 "EnumU32AsString",
@@ -533,18 +572,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32AsStringArrayElementType = enumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
 
             var enumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU32AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32AsStringCollectionElementType = enumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32),
+                providerClrType: typeof(string));
 
             var enumU32Collection = runtimeEntityType.AddProperty(
                 "EnumU32Collection",
                 typeof(List<CompiledModelTestBase.EnumU32>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU32CollectionElementType = enumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32));
 
             var enumU64 = runtimeEntityType.AddProperty(
                 "EnumU64",
@@ -558,6 +602,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64ArrayElementType = enumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64));
 
             var enumU64AsString = runtimeEntityType.AddProperty(
                 "EnumU64AsString",
@@ -572,18 +617,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64AsStringArrayElementType = enumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
 
             var enumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU64AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64AsStringCollectionElementType = enumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64),
+                providerClrType: typeof(string));
 
             var enumU64Collection = runtimeEntityType.AddProperty(
                 "EnumU64Collection",
                 typeof(List<CompiledModelTestBase.EnumU64>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU64CollectionElementType = enumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64));
 
             var enumU8 = runtimeEntityType.AddProperty(
                 "EnumU8",
@@ -597,6 +647,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8ArrayElementType = enumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8));
 
             var enumU8AsString = runtimeEntityType.AddProperty(
                 "EnumU8AsString",
@@ -611,18 +662,23 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8AsStringArrayElementType = enumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
 
             var enumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "EnumU8AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8AsStringCollectionElementType = enumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8),
+                providerClrType: typeof(string));
 
             var enumU8Collection = runtimeEntityType.AddProperty(
                 "EnumU8Collection",
                 typeof(List<CompiledModelTestBase.EnumU8>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("EnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<EnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var enumU8CollectionElementType = enumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8));
 
             var @float = runtimeEntityType.AddProperty(
                 "Float",
@@ -636,6 +692,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("FloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<FloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var floatArrayElementType = floatArray.SetElementType(typeof(float));
 
             var guid = runtimeEntityType.AddProperty(
                 "Guid",
@@ -649,6 +706,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("GuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<GuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var guidArrayElementType = guidArray.SetElementType(typeof(Guid));
 
             var guidToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "GuidToBytesConverterProperty",
@@ -677,12 +735,15 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<IPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var iPAddressArrayElementType = iPAddressArray.SetElementType(typeof(IPAddress));
 
             var iPAddressReadOnlyCollection = runtimeEntityType.AddProperty(
                 "IPAddressReadOnlyCollection",
                 typeof(IReadOnlyCollection<IPAddress>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("IPAddressReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_ipAddressReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var iPAddressReadOnlyCollectionElementType = iPAddressReadOnlyCollection.SetElementType(typeof(IPAddress),
+                providerClrType: typeof(string));
 
             var iPAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IPAddressToBytesConverterProperty",
@@ -710,6 +771,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int16ArrayElementType = int16Array.SetElementType(typeof(short));
 
             var int32 = runtimeEntityType.AddProperty(
                 "Int32",
@@ -723,12 +785,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ArrayElementType = int32Array.SetElementType(typeof(int));
 
             var int32ReadOnlyCollection = runtimeEntityType.AddProperty(
                 "Int32ReadOnlyCollection",
                 typeof(IReadOnlyCollection<int>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int32ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_int32ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int32ReadOnlyCollectionElementType = int32ReadOnlyCollection.SetElementType(typeof(int));
 
             var int64 = runtimeEntityType.AddProperty(
                 "Int64",
@@ -742,6 +806,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int64ArrayElementType = int64Array.SetElementType(typeof(long));
 
             var int8 = runtimeEntityType.AddProperty(
                 "Int8",
@@ -755,6 +820,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("Int8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<Int8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var int8ArrayElementType = int8Array.SetElementType(typeof(sbyte));
 
             var intNumberToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "IntNumberToBytesConverterProperty",
@@ -792,6 +858,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(bool?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBoolArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBoolArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBoolArrayElementType = nullableBoolArray.SetElementType(typeof(bool?),
+                nullable: true);
 
             var nullableBytes = runtimeEntityType.AddProperty(
                 "NullableBytes",
@@ -805,6 +873,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte[][]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableBytesArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableBytesArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableBytesArrayElementType = nullableBytesArray.SetElementType(typeof(byte[]),
+                nullable: true);
 
             var nullableChar = runtimeEntityType.AddProperty(
                 "NullableChar",
@@ -818,6 +888,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(char?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableCharArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableCharArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableCharArrayElementType = nullableCharArray.SetElementType(typeof(char?),
+                nullable: true);
 
             var nullableDateOnly = runtimeEntityType.AddProperty(
                 "NullableDateOnly",
@@ -831,6 +903,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDateOnlyArrayElementType = nullableDateOnlyArray.SetElementType(typeof(DateOnly?),
+                nullable: true);
 
             var nullableDateTime = runtimeEntityType.AddProperty(
                 "NullableDateTime",
@@ -844,6 +918,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(DateTime?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDateTimeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDateTimeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDateTimeArrayElementType = nullableDateTimeArray.SetElementType(typeof(DateTime?),
+                nullable: true);
 
             var nullableDecimal = runtimeEntityType.AddProperty(
                 "NullableDecimal",
@@ -857,6 +933,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(decimal?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDecimalArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDecimalArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDecimalArrayElementType = nullableDecimalArray.SetElementType(typeof(decimal?),
+                nullable: true);
 
             var nullableDouble = runtimeEntityType.AddProperty(
                 "NullableDouble",
@@ -870,6 +948,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(double?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableDoubleArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableDoubleArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableDoubleArrayElementType = nullableDoubleArray.SetElementType(typeof(double?),
+                nullable: true);
 
             var nullableEnum16 = runtimeEntityType.AddProperty(
                 "NullableEnum16",
@@ -883,6 +963,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16ArrayElementType = nullableEnum16Array.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum16AsString = runtimeEntityType.AddProperty(
                 "NullableEnum16AsString",
@@ -896,18 +978,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16AsStringArrayElementType = nullableEnum16AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum16AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16AsStringCollectionElementType = nullableEnum16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum16Collection = runtimeEntityType.AddProperty(
                 "NullableEnum16Collection",
                 typeof(List<CompiledModelTestBase.Enum16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum16CollectionElementType = nullableEnum16Collection.SetElementType(typeof(CompiledModelTestBase.Enum16?),
+                nullable: true);
 
             var nullableEnum32 = runtimeEntityType.AddProperty(
                 "NullableEnum32",
@@ -921,6 +1009,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32ArrayElementType = nullableEnum32Array.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum32AsString = runtimeEntityType.AddProperty(
                 "NullableEnum32AsString",
@@ -934,18 +1024,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32AsStringArrayElementType = nullableEnum32AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum32AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32AsStringCollectionElementType = nullableEnum32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum32Collection = runtimeEntityType.AddProperty(
                 "NullableEnum32Collection",
                 typeof(List<CompiledModelTestBase.Enum32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum32CollectionElementType = nullableEnum32Collection.SetElementType(typeof(CompiledModelTestBase.Enum32?),
+                nullable: true);
 
             var nullableEnum64 = runtimeEntityType.AddProperty(
                 "NullableEnum64",
@@ -959,6 +1055,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64ArrayElementType = nullableEnum64Array.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum64AsString = runtimeEntityType.AddProperty(
                 "NullableEnum64AsString",
@@ -972,18 +1070,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64AsStringArrayElementType = nullableEnum64AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum64AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64AsStringCollectionElementType = nullableEnum64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum64Collection = runtimeEntityType.AddProperty(
                 "NullableEnum64Collection",
                 typeof(List<CompiledModelTestBase.Enum64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum64CollectionElementType = nullableEnum64Collection.SetElementType(typeof(CompiledModelTestBase.Enum64?),
+                nullable: true);
 
             var nullableEnum8 = runtimeEntityType.AddProperty(
                 "NullableEnum8",
@@ -997,6 +1101,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8ArrayElementType = nullableEnum8Array.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnum8AsString = runtimeEntityType.AddProperty(
                 "NullableEnum8AsString",
@@ -1010,18 +1116,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8AsStringArrayElementType = nullableEnum8AsStringArray.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnum8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnum8AsStringCollection",
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8AsStringCollectionElementType = nullableEnum8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnum8Collection = runtimeEntityType.AddProperty(
                 "NullableEnum8Collection",
                 typeof(List<CompiledModelTestBase.Enum8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnum8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnum8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnum8CollectionElementType = nullableEnum8Collection.SetElementType(typeof(CompiledModelTestBase.Enum8?),
+                nullable: true);
 
             var nullableEnumU16 = runtimeEntityType.AddProperty(
                 "NullableEnumU16",
@@ -1035,6 +1147,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16ArrayElementType = nullableEnumU16Array.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU16AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsString",
@@ -1048,18 +1162,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU16?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16AsStringArrayElementType = nullableEnumU16AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU16AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU16AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16AsStringCollectionElementType = nullableEnumU16AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU16Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU16Collection",
                 typeof(List<CompiledModelTestBase.EnumU16?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU16Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU16Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU16CollectionElementType = nullableEnumU16Collection.SetElementType(typeof(CompiledModelTestBase.EnumU16?),
+                nullable: true);
 
             var nullableEnumU32 = runtimeEntityType.AddProperty(
                 "NullableEnumU32",
@@ -1073,6 +1193,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32ArrayElementType = nullableEnumU32Array.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU32AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsString",
@@ -1086,18 +1208,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU32?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32AsStringArrayElementType = nullableEnumU32AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU32AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU32AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32AsStringCollectionElementType = nullableEnumU32AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU32Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU32Collection",
                 typeof(List<CompiledModelTestBase.EnumU32?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU32Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU32Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU32CollectionElementType = nullableEnumU32Collection.SetElementType(typeof(CompiledModelTestBase.EnumU32?),
+                nullable: true);
 
             var nullableEnumU64 = runtimeEntityType.AddProperty(
                 "NullableEnumU64",
@@ -1111,6 +1239,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64ArrayElementType = nullableEnumU64Array.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU64AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsString",
@@ -1124,18 +1254,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU64?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64AsStringArrayElementType = nullableEnumU64AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU64AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU64AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64AsStringCollectionElementType = nullableEnumU64AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU64Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU64Collection",
                 typeof(List<CompiledModelTestBase.EnumU64?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU64Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU64Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU64CollectionElementType = nullableEnumU64Collection.SetElementType(typeof(CompiledModelTestBase.EnumU64?),
+                nullable: true);
 
             var nullableEnumU8 = runtimeEntityType.AddProperty(
                 "NullableEnumU8",
@@ -1149,6 +1285,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8ArrayElementType = nullableEnumU8Array.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableEnumU8AsString = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsString",
@@ -1162,18 +1300,24 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.EnumU8?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8AsStringArrayElementType = nullableEnumU8AsStringArray.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableEnumU8AsStringCollection = runtimeEntityType.AddProperty(
                 "NullableEnumU8AsStringCollection",
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8AsStringCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8AsStringCollection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8AsStringCollectionElementType = nullableEnumU8AsStringCollection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableEnumU8Collection = runtimeEntityType.AddProperty(
                 "NullableEnumU8Collection",
                 typeof(List<CompiledModelTestBase.EnumU8?>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableEnumU8Collection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableEnumU8Collection>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableEnumU8CollectionElementType = nullableEnumU8Collection.SetElementType(typeof(CompiledModelTestBase.EnumU8?),
+                nullable: true);
 
             var nullableFloat = runtimeEntityType.AddProperty(
                 "NullableFloat",
@@ -1187,6 +1331,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(float?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableFloatArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableFloatArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableFloatArrayElementType = nullableFloatArray.SetElementType(typeof(float?),
+                nullable: true);
 
             var nullableGuid = runtimeEntityType.AddProperty(
                 "NullableGuid",
@@ -1200,6 +1346,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableGuidArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableGuidArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableGuidArrayElementType = nullableGuidArray.SetElementType(typeof(Guid?),
+                nullable: true);
 
             var nullableIPAddress = runtimeEntityType.AddProperty(
                 "NullableIPAddress",
@@ -1213,6 +1361,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IPAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableIPAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableIPAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableIPAddressArrayElementType = nullableIPAddressArray.SetElementType(typeof(IPAddress),
+                nullable: true);
 
             var nullableInt16 = runtimeEntityType.AddProperty(
                 "NullableInt16",
@@ -1226,6 +1376,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(short?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt16ArrayElementType = nullableInt16Array.SetElementType(typeof(short?),
+                nullable: true);
 
             var nullableInt32 = runtimeEntityType.AddProperty(
                 "NullableInt32",
@@ -1239,6 +1391,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt32ArrayElementType = nullableInt32Array.SetElementType(typeof(int?),
+                nullable: true);
 
             var nullableInt64 = runtimeEntityType.AddProperty(
                 "NullableInt64",
@@ -1252,6 +1406,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt64ArrayElementType = nullableInt64Array.SetElementType(typeof(long?),
+                nullable: true);
 
             var nullableInt8 = runtimeEntityType.AddProperty(
                 "NullableInt8",
@@ -1265,6 +1421,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(sbyte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableInt8ArrayElementType = nullableInt8Array.SetElementType(typeof(sbyte?),
+                nullable: true);
 
             var nullablePhysicalAddress = runtimeEntityType.AddProperty(
                 "NullablePhysicalAddress",
@@ -1278,6 +1436,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullablePhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullablePhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullablePhysicalAddressArrayElementType = nullablePhysicalAddressArray.SetElementType(typeof(PhysicalAddress),
+                nullable: true);
 
             var nullableString = runtimeEntityType.AddProperty(
                 "NullableString",
@@ -1291,6 +1451,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableStringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableStringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableStringArrayElementType = nullableStringArray.SetElementType(typeof(string),
+                nullable: true);
 
             var nullableTimeOnly = runtimeEntityType.AddProperty(
                 "NullableTimeOnly",
@@ -1304,6 +1466,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeOnly?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableTimeOnlyArrayElementType = nullableTimeOnlyArray.SetElementType(typeof(TimeOnly?),
+                nullable: true);
 
             var nullableTimeSpan = runtimeEntityType.AddProperty(
                 "NullableTimeSpan",
@@ -1317,6 +1481,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeSpan?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableTimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableTimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableTimeSpanArrayElementType = nullableTimeSpanArray.SetElementType(typeof(TimeSpan?),
+                nullable: true);
 
             var nullableUInt16 = runtimeEntityType.AddProperty(
                 "NullableUInt16",
@@ -1330,6 +1496,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt16ArrayElementType = nullableUInt16Array.SetElementType(typeof(ushort?),
+                nullable: true);
 
             var nullableUInt32 = runtimeEntityType.AddProperty(
                 "NullableUInt32",
@@ -1343,6 +1511,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt32ArrayElementType = nullableUInt32Array.SetElementType(typeof(uint?),
+                nullable: true);
 
             var nullableUInt64 = runtimeEntityType.AddProperty(
                 "NullableUInt64",
@@ -1356,6 +1526,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt64ArrayElementType = nullableUInt64Array.SetElementType(typeof(ulong?),
+                nullable: true);
 
             var nullableUInt8 = runtimeEntityType.AddProperty(
                 "NullableUInt8",
@@ -1369,6 +1541,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(byte?[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUInt8Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUInt8Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUInt8ArrayElementType = nullableUInt8Array.SetElementType(typeof(byte?),
+                nullable: true);
 
             var nullableUri = runtimeEntityType.AddProperty(
                 "NullableUri",
@@ -1382,6 +1556,8 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("NullableUriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<NullableUriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var nullableUriArrayElementType = nullableUriArray.SetElementType(typeof(Uri),
+                nullable: true);
 
             var physicalAddress = runtimeEntityType.AddProperty(
                 "PhysicalAddress",
@@ -1394,6 +1570,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(PhysicalAddress[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("PhysicalAddressArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<PhysicalAddressArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var physicalAddressArrayElementType = physicalAddressArray.SetElementType(typeof(PhysicalAddress));
 
             var physicalAddressToBytesConverterProperty = runtimeEntityType.AddProperty(
                 "PhysicalAddressToBytesConverterProperty",
@@ -1420,12 +1597,14 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<StringArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringArrayElementType = stringArray.SetElementType(typeof(string));
 
             var stringReadOnlyCollection = runtimeEntityType.AddProperty(
                 "StringReadOnlyCollection",
                 typeof(IReadOnlyCollection<string>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("StringReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_stringReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var stringReadOnlyCollectionElementType = stringReadOnlyCollection.SetElementType(typeof(string));
 
             var stringToBoolConverterProperty = runtimeEntityType.AddProperty(
                 "StringToBoolConverterProperty",
@@ -1539,6 +1718,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeOnly[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeOnlyArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeOnlyArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var timeOnlyArrayElementType = timeOnlyArray.SetElementType(typeof(TimeOnly));
 
             var timeOnlyToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeOnlyToStringConverterProperty",
@@ -1568,6 +1748,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(TimeSpan[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("TimeSpanArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<TimeSpanArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var timeSpanArrayElementType = timeSpanArray.SetElementType(typeof(TimeSpan));
 
             var timeSpanToStringConverterProperty = runtimeEntityType.AddProperty(
                 "TimeSpanToStringConverterProperty",
@@ -1597,6 +1778,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ushort[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt16Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt16Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt16ArrayElementType = uInt16Array.SetElementType(typeof(ushort));
 
             var uInt32 = runtimeEntityType.AddProperty(
                 "UInt32",
@@ -1610,6 +1792,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(uint[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt32Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt32Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt32ArrayElementType = uInt32Array.SetElementType(typeof(uint));
 
             var uInt64 = runtimeEntityType.AddProperty(
                 "UInt64",
@@ -1623,6 +1806,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(ulong[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt64Array", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UInt64Array>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt64ArrayElementType = uInt64Array.SetElementType(typeof(ulong));
 
             var uInt8 = runtimeEntityType.AddProperty(
                 "UInt8",
@@ -1642,6 +1826,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(IReadOnlyCollection<byte>),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UInt8ReadOnlyCollection", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("_uInt8ReadOnlyCollection", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uInt8ReadOnlyCollectionElementType = uInt8ReadOnlyCollection.SetElementType(typeof(byte));
 
             var uri = runtimeEntityType.AddProperty(
                 "Uri",
@@ -1654,6 +1839,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Uri[]),
                 propertyInfo: typeof(CompiledModelTestBase.ManyTypes).GetProperty("UriArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.ManyTypes).GetField("<UriArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
+            var uriArrayElementType = uriArray.SetElementType(typeof(Uri));
 
             var uriToStringConverterProperty = runtimeEntityType.AddProperty(
                 "UriToStringConverterProperty",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
index 5223c57de9..18d86954d2 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedType0EntityType.cs
@@ -67,6 +67,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -74,6 +75,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -81,6 +83,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -88,6 +91,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -95,6 +99,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -102,6 +107,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -109,6 +115,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -116,6 +123,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.OwnedType).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
index b4839f7656..aeb2ec2091 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/OwnedTypeEntityType.cs
@@ -86,6 +86,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -94,6 +95,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -102,6 +104,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeIList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -110,6 +113,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_refTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -118,6 +122,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeArray", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -126,6 +131,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeEnumerable", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -134,6 +140,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -142,6 +149,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 fieldInfo: typeof(CompiledModelTestBase.OwnedType).GetField("_valueTypeList", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 propertyAccessMode: PropertyAccessMode.Field,
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var context = runtimeEntityType.AddServiceProperty(
                 "Context",
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
index 7e0a6cb971..0080604b59 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/No_NativeAOT/PrincipalBaseEntityType.cs
@@ -105,6 +105,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeArrayElementType = refTypeArray.SetElementType(typeof(IPAddress));
 
             var refTypeEnumerable = runtimeEntityType.AddProperty(
                 "RefTypeEnumerable",
@@ -112,6 +113,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeEnumerableElementType = refTypeEnumerable.SetElementType(typeof(string));
 
             var refTypeIList = runtimeEntityType.AddProperty(
                 "RefTypeIList",
@@ -119,6 +121,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeIListElementType = refTypeIList.SetElementType(typeof(string));
 
             var refTypeList = runtimeEntityType.AddProperty(
                 "RefTypeList",
@@ -126,6 +129,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("RefTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<RefTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var refTypeListElementType = refTypeList.SetElementType(typeof(IPAddress));
 
             var valueTypeArray = runtimeEntityType.AddProperty(
                 "ValueTypeArray",
@@ -133,6 +137,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeArray", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeArray>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeArrayElementType = valueTypeArray.SetElementType(typeof(DateTime));
 
             var valueTypeEnumerable = runtimeEntityType.AddProperty(
                 "ValueTypeEnumerable",
@@ -140,6 +145,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeEnumerable", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeEnumerable>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeEnumerableElementType = valueTypeEnumerable.SetElementType(typeof(byte));
 
             var valueTypeIList = runtimeEntityType.AddProperty(
                 "ValueTypeIList",
@@ -147,6 +153,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeIList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeIList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeIListElementType = valueTypeIList.SetElementType(typeof(byte));
 
             var valueTypeList = runtimeEntityType.AddProperty(
                 "ValueTypeList",
@@ -154,6 +161,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyInfo: typeof(CompiledModelTestBase.PrincipalBase).GetProperty("ValueTypeList", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<ValueTypeList>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                 nullable: true);
+            var valueTypeListElementType = valueTypeList.SetElementType(typeof(short));
 
             var key = runtimeEntityType.AddKey(
                 new[] { id });
