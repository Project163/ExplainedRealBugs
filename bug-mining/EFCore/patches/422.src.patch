diff --git a/src/EFCore.Relational/Migrations/MigrationsSqlGenerator.cs b/src/EFCore.Relational/Migrations/MigrationsSqlGenerator.cs
index 5368028458..b7cb97414d 100644
--- a/src/EFCore.Relational/Migrations/MigrationsSqlGenerator.cs
+++ b/src/EFCore.Relational/Migrations/MigrationsSqlGenerator.cs
@@ -238,8 +238,11 @@ protected virtual IUpdateSqlGenerator SqlGenerator
             .Append("ALTER TABLE ")
             .Append(Dependencies.SqlGenerationHelper.DelimitIdentifier(operation.Table, operation.Schema))
             .Append(" ADD ");
+
         PrimaryKeyConstraint(operation, model, builder);
 
+        KeyWithOptions(operation, builder);
+
         if (terminate)
         {
             builder.AppendLine(Dependencies.SqlGenerationHelper.StatementTerminator);
@@ -263,7 +266,11 @@ protected virtual IUpdateSqlGenerator SqlGenerator
             .Append("ALTER TABLE ")
             .Append(Dependencies.SqlGenerationHelper.DelimitIdentifier(operation.Table, operation.Schema))
             .Append(" ADD ");
+
         UniqueConstraint(operation, model, builder);
+
+        KeyWithOptions(operation, builder);
+
         builder.AppendLine(Dependencies.SqlGenerationHelper.StatementTerminator);
         EndStatement(builder);
     }
@@ -1709,6 +1716,16 @@ private static string FormatTable(string table, string? schema)
             .Append(")");
     }
 
+    /// <summary>
+    ///     Generates a SQL fragment for extra with options of a key from a
+    ///     <see cref="AddPrimaryKeyOperation" /> or <see cref="AddUniqueConstraintOperation" />.
+    /// </summary>
+    /// <param name="operation">The operation.</param>
+    /// <param name="builder">The command builder to use to add the SQL fragment.</param>
+    protected virtual void KeyWithOptions(MigrationOperation operation, MigrationCommandListBuilder builder)
+    {
+    }
+
     /// <summary>
     ///     Generates a SQL fragment for traits of an index from a <see cref="CreateIndexOperation" />,
     ///     <see cref="AddPrimaryKeyOperation" />, or <see cref="AddUniqueConstraintOperation" />.
diff --git a/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs b/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
index faca255576..2c0bebd2ab 100644
--- a/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
+++ b/src/EFCore.SqlServer/Design/Internal/SqlServerAnnotationCodeGenerator.cs
@@ -91,6 +91,10 @@ public class SqlServerAnnotationCodeGenerator : AnnotationCodeGenerator
         = typeof(SqlServerKeyBuilderExtensions).GetRuntimeMethod(
             nameof(SqlServerKeyBuilderExtensions.IsClustered), [typeof(KeyBuilder), typeof(bool)])!;
 
+    private static readonly MethodInfo KeyHasFillFactorMethodInfo
+        = typeof(SqlServerKeyBuilderExtensions).GetRuntimeMethod(
+            nameof(SqlServerKeyBuilderExtensions.HasFillFactor), [typeof(KeyBuilder), typeof(int)])!;
+
     private static readonly MethodInfo TableIsTemporalMethodInfo
         = typeof(SqlServerTableBuilderExtensions).GetRuntimeMethod(
             nameof(SqlServerTableBuilderExtensions.IsTemporal), [typeof(TableBuilder), typeof(bool)])!;
@@ -328,11 +332,16 @@ protected override bool IsHandledByConvention(IProperty property, IAnnotation an
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     protected override MethodCallCodeFragment? GenerateFluentApi(IKey key, IAnnotation annotation)
-        => annotation.Name == SqlServerAnnotationNames.Clustered
-            ? (bool)annotation.Value! == false
+        => annotation.Name switch
+        {
+            SqlServerAnnotationNames.Clustered => (bool)annotation.Value! == false
                 ? new MethodCallCodeFragment(KeyIsClusteredMethodInfo, false)
-                : new MethodCallCodeFragment(KeyIsClusteredMethodInfo)
-            : null;
+                : new MethodCallCodeFragment(KeyIsClusteredMethodInfo),
+
+            SqlServerAnnotationNames.FillFactor => new MethodCallCodeFragment(KeyHasFillFactorMethodInfo, annotation.Value),
+
+            _ => null
+        };
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
index 54d2747651..49f80dbd03 100644
--- a/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore.SqlServer/Design/Internal/SqlServerCSharpRuntimeAnnotationCodeGenerator.cs
@@ -132,6 +132,7 @@ public override void Generate(IKey key, CSharpRuntimeAnnotationCodeGeneratorPara
         {
             var annotations = parameters.Annotations;
             annotations.Remove(SqlServerAnnotationNames.Clustered);
+            annotations.Remove(SqlServerAnnotationNames.FillFactor);
         }
 
         base.Generate(key, parameters);
@@ -144,6 +145,7 @@ public override void Generate(IUniqueConstraint uniqueConstraint, CSharpRuntimeA
         {
             var annotations = parameters.Annotations;
             annotations.Remove(SqlServerAnnotationNames.Clustered);
+            annotations.Remove(SqlServerAnnotationNames.FillFactor);
         }
 
         base.Generate(uniqueConstraint, parameters);
diff --git a/src/EFCore.SqlServer/Extensions/SqlServerKeyBuilderExtensions.cs b/src/EFCore.SqlServer/Extensions/SqlServerKeyBuilderExtensions.cs
index 0deb6c0487..4164b26475 100644
--- a/src/EFCore.SqlServer/Extensions/SqlServerKeyBuilderExtensions.cs
+++ b/src/EFCore.SqlServer/Extensions/SqlServerKeyBuilderExtensions.cs
@@ -96,4 +96,86 @@ public static KeyBuilder IsClustered(this KeyBuilder keyBuilder, bool clustered
         bool? clustered,
         bool fromDataAnnotation = false)
         => keyBuilder.CanSetAnnotation(SqlServerAnnotationNames.Clustered, clustered, fromDataAnnotation);
+
+    /// <summary>
+    ///     Configures whether the key is created with fill factor option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and Azure SQL databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="keyBuilder">The builder for the key being configured.</param>
+    /// <param name="fillFactor">A value indicating whether the key is created with fill factor option.</param>
+    /// <returns>A builder to further configure the key.</returns>
+    public static KeyBuilder HasFillFactor(this KeyBuilder keyBuilder, int fillFactor)
+    {
+        keyBuilder.Metadata.SetFillFactor(fillFactor);
+
+        return keyBuilder;
+    }
+
+    /// <summary>
+    ///     Configures whether the key is created with fill factor option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and Azure SQL databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="keyBuilder">The builder for the key being configured.</param>
+    /// <param name="fillFactor">A value indicating whether the key is created with fill factor option.</param>
+    /// <returns>A builder to further configure the key.</returns>
+    public static KeyBuilder<TEntity> HasFillFactor<TEntity>(
+        this KeyBuilder<TEntity> keyBuilder,
+        int fillFactor)
+        => (KeyBuilder<TEntity>)HasFillFactor((KeyBuilder)keyBuilder, fillFactor);
+
+    /// <summary>
+    ///     Configures whether the key is created with fill factor option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and Azure SQL databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="keyBuilder">The builder for the key being configured.</param>
+    /// <param name="fillFactor">A value indicating whether the key is created with fill factor option.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>
+    ///     The same builder instance if the configuration was applied,
+    ///     <see langword="null" /> otherwise.
+    /// </returns>
+    public static IConventionKeyBuilder? HasFillFactor(
+        this IConventionKeyBuilder keyBuilder,
+        int? fillFactor,
+        bool fromDataAnnotation = false)
+    {
+        if (keyBuilder.CanSetFillFactor(fillFactor, fromDataAnnotation))
+        {
+            keyBuilder.Metadata.SetFillFactor(fillFactor, fromDataAnnotation);
+
+            return keyBuilder;
+        }
+
+        return null;
+    }
+
+    /// <summary>
+    ///     Returns a value indicating whether the key can be configured with fill factor option when targeting SQL Server.
+    /// </summary>
+    /// <remarks>
+    ///     See <see href="https://aka.ms/efcore-docs-modeling">Modeling entity types and relationships</see>, and
+    ///     <see href="https://aka.ms/efcore-docs-sqlserver">Accessing SQL Server and Azure SQL databases with EF Core</see>
+    ///     for more information and examples.
+    /// </remarks>
+    /// <param name="keyBuilder">The builder for the key being configured.</param>
+    /// <param name="fillFactor">A value indicating whether the key is created with fill factor option.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns><see langword="true" /> if the key can be configured with fill factor option when targeting SQL Server.</returns>
+    public static bool CanSetFillFactor(
+        this IConventionKeyBuilder keyBuilder,
+        int? fillFactor,
+        bool fromDataAnnotation = false)
+        => keyBuilder.CanSetAnnotation(SqlServerAnnotationNames.FillFactor, fillFactor, fromDataAnnotation);
 }
diff --git a/src/EFCore.SqlServer/Extensions/SqlServerKeyExtensions.cs b/src/EFCore.SqlServer/Extensions/SqlServerKeyExtensions.cs
index 5a5c7d1e1b..be2a27d2ec 100644
--- a/src/EFCore.SqlServer/Extensions/SqlServerKeyExtensions.cs
+++ b/src/EFCore.SqlServer/Extensions/SqlServerKeyExtensions.cs
@@ -82,4 +82,85 @@ public static void SetIsClustered(this IMutableKey key, bool? clustered)
     /// <returns>The <see cref="ConfigurationSource" /> for whether the key is clustered.</returns>
     public static ConfigurationSource? GetIsClusteredConfigurationSource(this IConventionKey key)
         => key.FindAnnotation(SqlServerAnnotationNames.Clustered)?.GetConfigurationSource();
+
+    /// <summary>
+    ///     Returns the fill factor that the key uses.
+    /// </summary>
+    /// <param name="key">The key.</param>
+    /// <returns>The fill factor that the key uses</returns>
+    public static int? GetFillFactor(this IReadOnlyKey key)
+        => (key is RuntimeKey)
+            ? throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData)
+            : (int?)key[SqlServerAnnotationNames.FillFactor];
+
+    /// <summary>
+    ///     Returns the fill factor that the key uses.
+    /// </summary>
+    /// <param name="key">The key.</param>
+    /// <param name="storeObject">The identifier of the store object.</param>
+    /// <returns>The fill factor that the key uses</returns>
+    public static int? GetFillFactor(this IReadOnlyKey key, in StoreObjectIdentifier storeObject)
+    {
+        if (key is RuntimeKey)
+        {
+            throw new InvalidOperationException(CoreStrings.RuntimeModelMissingData);
+        }
+
+        var annotation = key.FindAnnotation(SqlServerAnnotationNames.FillFactor);
+        if (annotation != null)
+        {
+            return (int?)annotation.Value;
+        }
+
+        var sharedTableRootKey = key.FindSharedObjectRootKey(storeObject);
+        return sharedTableRootKey?.GetFillFactor(storeObject);
+    }
+
+    /// <summary>
+    ///     Sets a value for fill factor the key uses.
+    /// </summary>
+    /// <param name="key">The key.</param>
+    /// <param name="fillFactor">The value to set.</param>
+    public static void SetFillFactor(this IMutableKey key, int? fillFactor)
+    {
+        if (fillFactor is <= 0 or > 100)
+        {
+            throw new ArgumentOutOfRangeException(nameof(fillFactor));
+        }
+
+        key.SetAnnotation(
+            SqlServerAnnotationNames.FillFactor,
+            fillFactor);
+    }
+
+    /// <summary>
+    ///     Sets a value for fill factor the key uses.
+    /// </summary>
+    /// <param name="key">The key.</param>
+    /// <param name="fillFactor">The value to set.</param>
+    /// <param name="fromDataAnnotation">Indicates whether the configuration was specified using a data annotation.</param>
+    /// <returns>The configured value.</returns>
+    public static int? SetFillFactor(
+        this IConventionKey key,
+        int? fillFactor,
+        bool fromDataAnnotation = false)
+    {
+        if (fillFactor is <= 0 or > 100)
+        {
+            throw new ArgumentOutOfRangeException(nameof(fillFactor));
+        }
+
+        return (int?)key.SetAnnotation(
+            SqlServerAnnotationNames.FillFactor,
+            fillFactor,
+            fromDataAnnotation)?.Value;
+    }
+
+    /// <summary>
+    ///     Returns the <see cref="ConfigurationSource" /> for whether the key uses the fill factor.
+    /// </summary>
+    /// <param name="key">The key.</param>
+    /// <returns>The <see cref="ConfigurationSource" /> for whether the key uses the fill factor.</returns>
+    public static ConfigurationSource? GetFillFactorConfigurationSource(this IConventionKey key)
+        => key.FindAnnotation(SqlServerAnnotationNames.FillFactor)?.GetConfigurationSource();
 }
diff --git a/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs b/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
index 6a12502aa5..abec9d2859 100644
--- a/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
+++ b/src/EFCore.SqlServer/Metadata/Conventions/SqlServerRuntimeModelConvention.cs
@@ -116,6 +116,7 @@ public class SqlServerRuntimeModelConvention : RelationalRuntimeModelConvention
         if (!runtime)
         {
             annotations.Remove(SqlServerAnnotationNames.Clustered);
+            annotations.Remove(SqlServerAnnotationNames.FillFactor);
         }
     }
 
diff --git a/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs b/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs
index 6667cfbb6d..a6fecde4a4 100644
--- a/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs
+++ b/src/EFCore.SqlServer/Metadata/Internal/SqlServerAnnotationProvider.cs
@@ -158,6 +158,11 @@ public override IEnumerable<IAnnotation> For(IUniqueConstraint constraint, bool
         {
             yield return new Annotation(SqlServerAnnotationNames.Clustered, isClustered);
         }
+
+        if (key.GetFillFactor() is int fillFactor)
+        {
+            yield return new Annotation(SqlServerAnnotationNames.FillFactor, fillFactor);
+        }
     }
 
     /// <summary>
diff --git a/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs b/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs
index 3a5383d953..d96997a0d7 100644
--- a/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs
+++ b/src/EFCore.SqlServer/Migrations/SqlServerMigrationsSqlGenerator.cs
@@ -1775,6 +1775,30 @@ protected override void Generate(UpdateDataOperation operation, IModel? model, M
         }
     }
 
+    /// <summary>
+    ///     Generates a SQL fragment for extra with options of a key from a
+    ///     <see cref="AddPrimaryKeyOperation" />, or <see cref="AddUniqueConstraintOperation" />.
+    /// </summary>
+    /// <param name="operation">The operation.</param>
+    /// <param name="builder">The command builder to use to add the SQL fragment.</param>
+    protected override void KeyWithOptions(MigrationOperation operation, MigrationCommandListBuilder builder)
+    {
+        var options = new List<string>();
+
+        if (operation[SqlServerAnnotationNames.FillFactor] is int fillFactor)
+        {
+            options.Add("FILLFACTOR = " + fillFactor);
+        }
+
+        if (options.Count > 0)
+        {
+            builder
+                .Append(" WITH (")
+                .Append(string.Join(", ", options))
+                .Append(")");
+        }
+    }
+
     /// <summary>
     ///     Generates a SQL fragment for traits of an index from a <see cref="CreateIndexOperation" />,
     ///     <see cref="AddPrimaryKeyOperation" />, or <see cref="AddUniqueConstraintOperation" />.
diff --git a/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs b/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs
index 1cc98409d5..f1ed6e8e4c 100644
--- a/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs
+++ b/src/EFCore.SqlServer/Scaffolding/Internal/SqlServerDatabaseModelFactory.cs
@@ -1087,7 +1087,8 @@ SELECT CAST([i].[object_id] AS nvarchar(12)) + '#' + CAST([i].[index_id] AS nvar
                 .GroupBy(
                     ddr =>
                         (Name: ddr.GetFieldValue<string>("index_name"),
-                            TypeDesc: ddr.GetValueOrDefault<string>("type_desc")))
+                            TypeDesc: ddr.GetValueOrDefault<string>("type_desc"),
+                            FillFactor: ddr.GetValueOrDefault<byte>("fill_factor")))
                 .ToArray();
 
             Check.DebugAssert(primaryKeyGroups.Length is 0 or 1, "Multiple primary keys found");
@@ -1106,7 +1107,8 @@ SELECT CAST([i].[object_id] AS nvarchar(12)) + '#' + CAST([i].[index_id] AS nvar
                 .GroupBy(
                     ddr =>
                         (Name: ddr.GetValueOrDefault<string>("index_name"),
-                            TypeDesc: ddr.GetValueOrDefault<string>("type_desc")))
+                            TypeDesc: ddr.GetValueOrDefault<string>("type_desc"),
+                            FillFactor: ddr.GetValueOrDefault<byte>("fill_factor")))
                 .ToArray();
 
             foreach (var uniqueConstraintGroup in uniqueConstraintGroups)
@@ -1142,7 +1144,7 @@ SELECT CAST([i].[object_id] AS nvarchar(12)) + '#' + CAST([i].[index_id] AS nvar
             }
 
             bool TryGetPrimaryKey(
-                IGrouping<(string Name, string? TypeDesc), DbDataRecord> primaryKeyGroup,
+                IGrouping<(string Name, string? TypeDesc, byte FillFactor), DbDataRecord> primaryKeyGroup,
                 [NotNullWhen(true)] out DatabasePrimaryKey? primaryKey)
             {
                 primaryKey = new DatabasePrimaryKey { Table = table, Name = primaryKeyGroup.Key.Name };
@@ -1152,6 +1154,11 @@ SELECT CAST([i].[object_id] AS nvarchar(12)) + '#' + CAST([i].[index_id] AS nvar
                     primaryKey[SqlServerAnnotationNames.Clustered] = false;
                 }
 
+                if (primaryKeyGroup.Key.FillFactor is > 0 and <= 100)
+                {
+                    primaryKey[SqlServerAnnotationNames.FillFactor] = (int)primaryKeyGroup.Key.FillFactor;
+                }
+
                 foreach (var dataRecord in primaryKeyGroup)
                 {
                     var columnName = dataRecord.GetValueOrDefault<string>("column_name");
@@ -1171,7 +1178,7 @@ SELECT CAST([i].[object_id] AS nvarchar(12)) + '#' + CAST([i].[index_id] AS nvar
             }
 
             bool TryGetUniqueConstraint(
-                IGrouping<(string? Name, string? TypeDesc), DbDataRecord> uniqueConstraintGroup,
+                IGrouping<(string? Name, string? TypeDesc, byte FillFactor), DbDataRecord> uniqueConstraintGroup,
                 [NotNullWhen(true)] out DatabaseUniqueConstraint? uniqueConstraint)
             {
                 uniqueConstraint = new DatabaseUniqueConstraint { Table = table, Name = uniqueConstraintGroup.Key.Name };
@@ -1181,6 +1188,11 @@ SELECT CAST([i].[object_id] AS nvarchar(12)) + '#' + CAST([i].[index_id] AS nvar
                     uniqueConstraint[SqlServerAnnotationNames.Clustered] = true;
                 }
 
+                if (uniqueConstraintGroup.Key.FillFactor is > 0 and <= 100)
+                {
+                    uniqueConstraint[SqlServerAnnotationNames.FillFactor] = (int)uniqueConstraintGroup.Key.FillFactor;
+                }
+
                 foreach (var dataRecord in uniqueConstraintGroup)
                 {
                     var columnName = dataRecord.GetValueOrDefault<string>("column_name");
diff --git a/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.ModelSnapshot.cs b/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.ModelSnapshot.cs
index 3d383fc7a9..a7d5694c67 100644
--- a/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.ModelSnapshot.cs
+++ b/test/EFCore.Design.Tests/Migrations/Design/CSharpMigrationsGeneratorTest.ModelSnapshot.cs
@@ -6072,6 +6072,72 @@ public virtual void Key_multiple_annotations_are_stored_in_snapshot()
                 Assert.Equal("IndexName", key["Relational:Name"]);
             });
 
+    [ConditionalFact]
+    public virtual void Key_fill_factor_is_stored_in_snapshot()
+        => Test(
+            builder =>
+            {
+                builder.Entity<EntityWithOneProperty>().HasKey(t => t.Id).HasFillFactor(90);
+                builder.Ignore<EntityWithTwoProperties>();
+            },
+            AddBoilerPlate(
+                GetHeading()
+                + """
+            modelBuilder.Entity("Microsoft.EntityFrameworkCore.Migrations.Design.CSharpMigrationsGeneratorTest+EntityWithOneProperty", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("int");
+
+                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));
+
+                    b.HasKey("Id");
+
+                    SqlServerKeyBuilderExtensions.HasFillFactor(b.HasKey("Id"), 90);
+
+                    b.ToTable("EntityWithOneProperty", "DefaultSchema");
+                });
+"""),
+            o => Assert.Equal(90, o.GetEntityTypes().First().GetKeys().Single(k => k.IsPrimaryKey()).GetFillFactor()));
+
+    [ConditionalFact]
+    public virtual void Unique_constraint_fill_factor_is_stored_in_snapshot()
+        => Test(
+            builder =>
+            {
+                builder.Entity<EntityWithTwoProperties>().HasAlternateKey(t => t.AlternateId).HasName("KeyName").HasFillFactor(90);
+                builder.Ignore<EntityWithOneProperty>();
+            },
+            AddBoilerPlate(
+                GetHeading()
+                + """
+            modelBuilder.Entity("Microsoft.EntityFrameworkCore.Migrations.Design.CSharpMigrationsGeneratorTest+EntityWithTwoProperties", b =>
+                {
+                    b.Property<int>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("int");
+
+                    SqlServerPropertyBuilderExtensions.UseIdentityColumn(b.Property<int>("Id"));
+
+                    b.Property<int>("AlternateId")
+                        .HasColumnType("int");
+
+                    b.HasKey("Id");
+
+                    b.HasAlternateKey("AlternateId")
+                        .HasName("KeyName");
+
+                    SqlServerKeyBuilderExtensions.HasFillFactor(b.HasAlternateKey("AlternateId"), 90);
+
+                    b.ToTable("EntityWithTwoProperties", "DefaultSchema");
+                });
+"""),
+            model =>
+            {
+                var key = model.GetEntityTypes().First().GetKeys().First();
+                Assert.Equal(90, key.GetFillFactor());
+            });
+
     #endregion
 
     #region Index
diff --git a/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs
index 10ddb89993..33630b787b 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Migrations/MigrationsSqlServerTest.cs
@@ -2806,6 +2806,51 @@ public virtual async Task Add_primary_key_nonclustered()
 """);
     }
 
+    [ConditionalFact]
+    public virtual async Task Add_primary_key_with_fill_factor()
+    {
+        await Test(
+            builder => builder.Entity("People").Property<string>("SomeField").IsRequired().HasMaxLength(450),
+            builder => { },
+            builder => builder.Entity("People").HasKey("SomeField").HasFillFactor(80),
+            model =>
+            {
+                var table = Assert.Single(model.Tables);
+                var primaryKey = table.PrimaryKey;
+                Assert.NotNull(primaryKey);
+                Assert.Equal(80, primaryKey[SqlServerAnnotationNames.FillFactor]);
+            });
+
+        AssertSql(
+            """
+ALTER TABLE [People] ADD CONSTRAINT [PK_People] PRIMARY KEY ([SomeField]) WITH (FILLFACTOR = 80);
+""");
+    }
+
+    [ConditionalFact]
+    public virtual async Task Add_alternate_key_with_fill_factor()
+    {
+        await Test(
+            builder => {
+                builder.Entity("People").Property<string>("SomeField").IsRequired().HasMaxLength(450);
+                builder.Entity("People").Property<string>("SomeOtherField").IsRequired().HasMaxLength(450);
+                },
+            builder => { },
+            builder => builder.Entity("People").HasAlternateKey(["SomeField", "SomeOtherField"]).HasFillFactor(80),
+            model =>
+            {
+                var table = Assert.Single(model.Tables);
+                var uniqueConstraint = table.UniqueConstraints.FirstOrDefault();
+                Assert.NotNull(uniqueConstraint);
+                Assert.Equal(80, uniqueConstraint[SqlServerAnnotationNames.FillFactor]);
+            });
+
+        AssertSql(
+            """
+ALTER TABLE [People] ADD CONSTRAINT [AK_People_SomeField_SomeOtherField] UNIQUE ([SomeField], [SomeOtherField]) WITH (FILLFACTOR = 80);
+""");
+    }
+
     public override async Task Drop_primary_key_int()
     {
         var exception = await Assert.ThrowsAsync<InvalidOperationException>(() => base.Drop_primary_key_int());
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs
index 3890e4054c..8fe42c97bc 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/SqlServerDatabaseModelFactoryTest.cs
@@ -4828,6 +4828,33 @@ public void Set_primary_key_name_from_index()
             },
             "DROP TABLE PrimaryKeyName;");
 
+    [ConditionalFact]
+    public void Primary_key_fill_factor()
+        => Test(
+            @"
+CREATE TABLE PrimaryKeyFillFactor
+(
+    Id INT IDENTITY NOT NULL,
+    Name NVARCHAR(100),
+ CONSTRAINT [PK_Id] PRIMARY KEY NONCLUSTERED
+(
+        [Id] ASC
+) WITH (FILLFACTOR = 80) ON [PRIMARY]
+) ON [PRIMARY];",
+            Enumerable.Empty<string>(),
+            Enumerable.Empty<string>(),
+            (dbModel, scaffoldingFactory) =>
+            {
+                var pk = dbModel.Tables.Single().PrimaryKey;
+                Assert.NotNull(pk);
+                Assert.Equal(["Id"], pk!.Columns.Select(kc => kc.Name).ToList());
+                Assert.Equal(80, pk[SqlServerAnnotationNames.FillFactor]);
+
+                var model = scaffoldingFactory.Create(dbModel, new());
+                Assert.Equal(1, model.GetEntityTypes().Count());
+            },
+            "DROP TABLE PrimaryKeyFillFactor;");
+
     #endregion
 
     #region UniqueConstraintFacets
@@ -4910,6 +4937,34 @@ public void Set_unique_constraint_name_from_index()
             },
             "DROP TABLE UniqueConstraintName;");
 
+    [ConditionalFact]
+    public void Unique_constraint_fill_factor()
+        => Test(
+            @"
+CREATE TABLE UniqueConstraintFillFactor
+(
+    Something NVARCHAR(100) NOT NULL,
+    SomethingElse NVARCHAR(100) NOT NULL,
+ CONSTRAINT [UC_Something_SomethingElse] UNIQUE NONCLUSTERED
+(
+    [Something] ASC,
+    [SomethingElse] ASC
+) WITH (FILLFACTOR = 80) ON [PRIMARY]
+) ON [PRIMARY];",
+            Enumerable.Empty<string>(),
+            Enumerable.Empty<string>(),
+            (dbModel, scaffoldingFactory) =>
+            {
+                var uniqueConstraint = Assert.Single(dbModel.Tables.Single().UniqueConstraints);
+                Assert.NotNull(uniqueConstraint);
+                Assert.Equal(["Something", "SomethingElse"], uniqueConstraint!.Columns.Select(kc => kc.Name).ToList());
+                Assert.Equal(80, uniqueConstraint[SqlServerAnnotationNames.FillFactor]);
+
+                var model = scaffoldingFactory.Create(dbModel, new());
+                Assert.Equal(1, model.GetEntityTypes().Count());
+            },
+            "DROP TABLE UniqueConstraintFillFactor;");
+
     #endregion
 
     #region IndexFacets
diff --git a/test/EFCore.SqlServer.Tests/Design/Internal/SqlServerAnnotationCodeGeneratorTest.cs b/test/EFCore.SqlServer.Tests/Design/Internal/SqlServerAnnotationCodeGeneratorTest.cs
index fd30348cca..2a3f79be4b 100644
--- a/test/EFCore.SqlServer.Tests/Design/Internal/SqlServerAnnotationCodeGeneratorTest.cs
+++ b/test/EFCore.SqlServer.Tests/Design/Internal/SqlServerAnnotationCodeGeneratorTest.cs
@@ -57,6 +57,51 @@ public void GenerateFluentApi_IKey_works_when_nonclustered()
         Assert.Equal(false, result.Arguments[0]);
     }
 
+    [ConditionalFact]
+    public void GenerateFluentApi_IKey_works_with_fillfactor()
+    {
+        var generator = CreateGenerator();
+        var modelBuilder = SqlServerConventionSetBuilder.CreateModelBuilder();
+        modelBuilder.Entity(
+            "Post",
+            x =>
+            {
+                x.Property<int>("Id");
+                x.HasKey("Id").HasFillFactor(80);
+            });
+
+        var key = (IKey)modelBuilder.Model.FindEntityType("Post")!.GetKeys().Single();
+        var result = generator.GenerateFluentApiCalls(key, key.GetAnnotations().ToDictionary(a => a.Name, a => a))
+            .Single();
+
+        Assert.Equal("HasFillFactor", result.Method);
+        Assert.Equal(1, result.Arguments.Count);
+        Assert.Equal(80, result.Arguments[0]);
+    }
+
+    [ConditionalFact]
+    public void GenerateFluentApi_IUniqueConstraint_works_with_fillfactor()
+    {
+        var generator = CreateGenerator();
+        var modelBuilder = SqlServerConventionSetBuilder.CreateModelBuilder();
+        modelBuilder.Entity(
+            "Post",
+            x =>
+            {
+                x.Property<int>("Something");
+                x.Property<int>("SomethingElse");
+                x.HasAlternateKey(["Something", "SomethingElse"]).HasFillFactor(80);
+            });
+        
+        var uniqueConstraint = (IKey)modelBuilder.Model.FindEntityType("Post")!.GetKeys().Single();
+        var result = generator.GenerateFluentApiCalls(uniqueConstraint, uniqueConstraint.GetAnnotations().ToDictionary(a => a.Name, a => a))
+            .Single();
+
+        Assert.Equal("HasFillFactor", result.Method);
+        Assert.Equal(1, result.Arguments.Count);
+        Assert.Equal(80, result.Arguments[0]);
+    }
+
     [ConditionalFact]
     public void GenerateFluentApi_IIndex_works_when_clustered()
     {
diff --git a/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs b/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs
index c5611a5c55..5f4653f57d 100644
--- a/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs
+++ b/test/EFCore.SqlServer.Tests/Metadata/SqlServerBuilderExtensionsTest.cs
@@ -127,6 +127,36 @@ public void Can_set_key_clustering()
         Assert.True(key.IsClustered().Value);
     }
 
+    [ConditionalFact]
+    public void Can_set_key_with_fillfactor()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        modelBuilder
+            .Entity<Customer>()
+            .HasKey(e => e.Id)
+            .HasFillFactor(90);
+
+        var key = modelBuilder.Model.FindEntityType(typeof(Customer)).FindPrimaryKey();
+
+        Assert.Equal(90, key.GetFillFactor());
+    }
+
+    [ConditionalFact]
+    public void Can_set_key_with_fillfactor_non_generic()
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        modelBuilder
+            .Entity(typeof(Customer))
+            .HasKey("Id")
+            .HasFillFactor(90);
+
+        var key = modelBuilder.Model.FindEntityType(typeof(Customer)).FindPrimaryKey();
+
+        Assert.Equal(90, key.GetFillFactor());
+    }
+
     [ConditionalFact]
     public void Can_set_index_include()
     {
@@ -1107,6 +1137,23 @@ public void Can_set_index_with_fillfactor_non_generic()
         Assert.Equal(90, index.GetFillFactor());
     }
 
+    [ConditionalTheory]
+    [InlineData(0)]
+    [InlineData(101)]
+    public void Throws_if_attempt_to_set_key_fillfactor_with_argument_out_of_range(int fillFactor)
+    {
+        var modelBuilder = CreateConventionModelBuilder();
+
+        Assert.Throws<ArgumentOutOfRangeException>(
+            () =>
+            {
+                modelBuilder
+                    .Entity(typeof(Customer))
+                    .HasKey("Id")
+                    .HasFillFactor(fillFactor);
+            });
+    }
+
     [ConditionalTheory]
     [InlineData(0)]
     [InlineData(101)]
diff --git a/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs b/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs
index ff9471259f..0f8dddae5a 100644
--- a/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs
+++ b/test/EFCore.SqlServer.Tests/Migrations/SqlServerModelDifferTest.cs
@@ -1250,6 +1250,56 @@ protected override MigrationsModelDiffer CreateModelDiffer(DbContextOptions opti
     private bool? IsMemoryOptimized(Annotatable annotatable)
         => annotatable[SqlServerAnnotationNames.MemoryOptimized] as bool?;
 
+    [ConditionalFact]
+    public void Dont_rebuild_key_index_with_unchanged_fillfactor_option()
+        => Execute(
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.HasKey("Id").HasFillFactor(90);
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.HasKey("Id").HasFillFactor(90);
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                    }),
+            operations => Assert.Equal(0, operations.Count));
+
+    [ConditionalFact]
+    public void Dont_rebuild_composite_key_index_with_unchanged_fillfactor_option()
+        => Execute(
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.HasAlternateKey("Zip", "City").HasFillFactor(90);
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.HasAlternateKey("Zip", "City").HasFillFactor(90);
+                    }),
+            operations => Assert.Equal(0, operations.Count));
+
     [ConditionalFact]
     public void Dont_rebuild_index_with_unchanged_fillfactor_option()
         => Execute(
@@ -1277,6 +1327,230 @@ public void Dont_rebuild_index_with_unchanged_fillfactor_option()
                     }),
             operations => Assert.Equal(0, operations.Count));
 
+    [ConditionalFact]
+    public void Rebuild_key_index_when_adding_fillfactor_option()
+        => Execute(
+            _ => { },
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.HasKey("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip");
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.HasKey("Id").HasFillFactor(90);
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip");
+                    }),
+            upOps =>
+            {
+                Assert.Equal(2, upOps.Count);
+
+                var operation1 = Assert.IsType<DropPrimaryKeyOperation>(upOps[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("PK_Address", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<AddPrimaryKeyOperation>(upOps[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("PK_Address", operation1.Name);
+
+                var annotation = operation2.GetAnnotation(SqlServerAnnotationNames.FillFactor);
+                Assert.NotNull(annotation);
+
+                var annotationValue = Assert.IsType<int>(annotation.Value);
+                Assert.Equal(90, annotationValue);
+            },
+            downOps =>
+            {
+                Assert.Equal(2, downOps.Count);
+
+                var operation1 = Assert.IsType<DropPrimaryKeyOperation>(downOps[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("PK_Address", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<AddPrimaryKeyOperation>(downOps[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("PK_Address", operation1.Name);
+
+                Assert.Empty(operation2.GetAnnotations());
+            });
+
+    [ConditionalFact]
+    public void Rebuild_key_index_with_different_fillfactor_value()
+        => Execute(
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.HasKey("Id").HasFillFactor(50);
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.HasKey("Id").HasFillFactor(90);
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                    }),
+            operations =>
+            {
+                Assert.Equal(2, operations.Count);
+
+                var operation1 = Assert.IsType<DropPrimaryKeyOperation>(operations[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("PK_Address", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<AddPrimaryKeyOperation>(operations[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("PK_Address", operation1.Name);
+
+                var annotation = operation2.GetAnnotation(SqlServerAnnotationNames.FillFactor);
+                Assert.NotNull(annotation);
+
+                var annotationValue = Assert.IsType<int>(annotation.Value);
+
+                Assert.Equal(90, annotationValue);
+            });
+
+    [ConditionalFact]
+    public void Rebuild_composite_key_index_when_adding_fillfactor_option()
+        => Execute(
+            _ => { },
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasAlternateKey("Zip", "City");
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasAlternateKey("Zip", "City").HasFillFactor(90);
+                    }),
+            upOps =>
+            {
+                Assert.Equal(2, upOps.Count);
+
+                var operation1 = Assert.IsType<DropUniqueConstraintOperation>(upOps[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("AK_Address_Zip_City", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<AddUniqueConstraintOperation>(upOps[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("AK_Address_Zip_City", operation1.Name);
+
+                var annotation = operation2.GetAnnotation(SqlServerAnnotationNames.FillFactor);
+                Assert.NotNull(annotation);
+
+                var annotationValue = Assert.IsType<int>(annotation.Value);
+                Assert.Equal(90, annotationValue);
+            },
+            downOps =>
+            {
+                Assert.Equal(2, downOps.Count);
+
+                var operation1 = Assert.IsType<DropUniqueConstraintOperation>(downOps[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("AK_Address_Zip_City", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<AddUniqueConstraintOperation>(downOps[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("AK_Address_Zip_City", operation1.Name);
+
+                Assert.Empty(operation2.GetAnnotations());
+            });
+
+    [ConditionalFact]
+    public void Rebuild_composite_key_index_with_different_fillfactor_value()
+        => Execute(
+            source => source
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip");
+                        x.HasAlternateKey("Zip", "City").HasFillFactor(50);
+                    }),
+            target => target
+                .Entity(
+                    "Address",
+                    x =>
+                    {
+                        x.Property<int>("Id");
+                        x.Property<string>("Zip");
+                        x.Property<string>("City");
+                        x.Property<string>("Street");
+                        x.HasIndex("Zip");
+                        x.HasAlternateKey("Zip", "City").HasFillFactor(90);
+                    }),
+            operations =>
+            {
+                Assert.Equal(2, operations.Count);
+
+                var operation1 = Assert.IsType<DropUniqueConstraintOperation>(operations[0]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("AK_Address_Zip_City", operation1.Name);
+
+                Assert.Empty(operation1.GetAnnotations());
+
+                var operation2 = Assert.IsType<AddUniqueConstraintOperation>(operations[1]);
+                Assert.Equal("Address", operation1.Table);
+                Assert.Equal("AK_Address_Zip_City", operation1.Name);
+
+                var annotation = operation2.GetAnnotation(SqlServerAnnotationNames.FillFactor);
+                Assert.NotNull(annotation);
+
+                var annotationValue = Assert.IsType<int>(annotation.Value);
+
+                Assert.Equal(90, annotationValue);
+            });
+
     [ConditionalFact]
     public void Rebuild_index_when_adding_fillfactor_option()
         => Execute(
