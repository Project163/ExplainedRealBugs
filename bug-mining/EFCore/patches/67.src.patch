diff --git a/src/EFCore.InMemory/Query/Internal/InMemoryQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.InMemory/Query/Internal/InMemoryQueryableMethodTranslatingExpressionVisitor.cs
index 7f23ee47e0..1ca0441ec6 100644
--- a/src/EFCore.InMemory/Query/Internal/InMemoryQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.InMemory/Query/Internal/InMemoryQueryableMethodTranslatingExpressionVisitor.cs
@@ -1321,11 +1321,6 @@ protected override Expression VisitExtension(Expression extensionExpression)
 
             return innerShaper;
         }
-
-        private static Expression AddConvertToObject(Expression expression)
-            => expression.Type.IsValueType
-                ? Expression.Convert(expression, typeof(object))
-                : expression;
     }
 
     private ShapedQueryExpression TranslateTwoParameterSelector(ShapedQueryExpression source, LambdaExpression resultSelector)
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
index 4cb6e3af47..e41ba43fc6 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.cs
@@ -1655,11 +1655,11 @@ protected override Expression VisitExtension(Expression extensionExpression)
                             : foreignKey.PrincipalKey.Properties[0]);
 
                 var sourceTable = FindRootTableExpressionForColumn(sourceColumn);
-                var ownedTable = new TableExpression(targetTable);
+                TableExpressionBase ownedTable = new TableExpression(targetTable);
 
                 foreach (var annotation in sourceTable.GetAnnotations())
                 {
-                    ownedTable.SetAnnotation(annotation.Name, annotation.Value);
+                    ownedTable = ownedTable.AddAnnotation(annotation.Name, annotation.Value);
                 }
 
                 return _sqlExpressionFactory.Select(targetEntityType, ownedTable);
@@ -1688,11 +1688,6 @@ static TableExpressionBase FindRootTableExpressionForColumn(ColumnExpression col
             }
         }
 
-        private static Expression AddConvertToObject(Expression expression)
-            => expression.Type.IsValueType
-                ? Expression.Convert(expression, typeof(object))
-                : expression;
-
         private EntityProjectionExpression GetEntityProjectionExpression(EntityShaperExpression entityShaperExpression)
             => entityShaperExpression.ValueBufferExpression switch
             {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs
index 64c516c1b3..9f58ec09b4 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/CrossApplyExpression.cs
@@ -43,6 +43,10 @@ public virtual CrossApplyExpression Update(TableExpressionBase table)
             ? new CrossApplyExpression(table, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new CrossApplyExpression(Table, GetAnnotations());
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs
index 84af081406..c5e6c4eef0 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/CrossJoinExpression.cs
@@ -43,6 +43,10 @@ public virtual CrossJoinExpression Update(TableExpressionBase table)
             ? new CrossJoinExpression(table, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new CrossJoinExpression(Table, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs
index 0b4a3c5790..dd834b5fd1 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/ExceptExpression.cs
@@ -61,6 +61,10 @@ public virtual ExceptExpression Update(SelectExpression source1, SelectExpressio
             ? new ExceptExpression(Alias, source1, source2, IsDistinct, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new ExceptExpression(Alias, Source1, Source2, IsDistinct, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
index 344ff9bb7f..f378a6408a 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/FromSqlExpression.cs
@@ -83,6 +83,10 @@ public virtual FromSqlExpression Update(Expression arguments)
             ? new FromSqlExpression(Alias, _table, Sql, arguments, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new FromSqlExpression(Alias, _table, Sql, Arguments, annotations);
+
     /// <inheritdoc />
     ITableBase ITableBasedExpression.Table => _table;
 
diff --git a/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs
index dc7e521e9b..dc4fc43fa4 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/InnerJoinExpression.cs
@@ -53,6 +53,10 @@ public virtual InnerJoinExpression Update(TableExpressionBase table, SqlExpressi
             ? new InnerJoinExpression(table, joinPredicate, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new InnerJoinExpression(Table, JoinPredicate, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs
index 87b2ff22af..b836e27804 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/IntersectExpression.cs
@@ -61,6 +61,10 @@ public virtual IntersectExpression Update(SelectExpression source1, SelectExpres
             ? new IntersectExpression(Alias, source1, source2, IsDistinct, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new IntersectExpression(Alias, Source1, Source2, IsDistinct, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs
index 32e5c6145a..ca8e42132e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/LeftJoinExpression.cs
@@ -53,6 +53,10 @@ public virtual LeftJoinExpression Update(TableExpressionBase table, SqlExpressio
             ? new LeftJoinExpression(table, joinPredicate, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new LeftJoinExpression(Table, JoinPredicate, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs
index 84c66157b6..2cc30f8dda 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/OuterApplyExpression.cs
@@ -43,6 +43,10 @@ public virtual OuterApplyExpression Update(TableExpressionBase table)
             ? new OuterApplyExpression(table, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new OuterApplyExpression(Table, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
index c85a41aa11..57624e4813 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
@@ -513,6 +513,9 @@ public TpcTablesExpression Prune(IReadOnlyList<string> discriminatorValues)
         // This is implementation detail hence visitors are not supposed to see inside unless they really need to.
         protected override Expression VisitChildren(ExpressionVisitor visitor) => this;
 
+        protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+            => new TpcTablesExpression(Alias, EntityType, SelectExpressions, annotations);
+
         protected override void Print(ExpressionPrinter expressionPrinter)
         {
             expressionPrinter.AppendLine("(");
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index 8ed2e6ad81..f2d0a8617f 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -56,6 +56,8 @@ public sealed partial class SelectExpression : TableExpressionBase
     private readonly List<string?> _aliasForClientProjections = new();
     private CloningExpressionVisitor? _cloningExpressionVisitor;
 
+    private SortedDictionary<string, IAnnotation>? _annotations;
+
 #if DEBUG
     private List<string>? _removedAliases;
 #endif
@@ -68,13 +70,22 @@ public sealed partial class SelectExpression : TableExpressionBase
         List<SqlExpression> groupBy,
         List<OrderingExpression> orderings,
         IEnumerable<IAnnotation> annotations)
-        : base(alias, annotations)
+        : base(alias)
     {
         _projection = projections;
         _tables = tables;
         _tableReferences = tableReferences;
         _groupBy = groupBy;
         _orderings = orderings;
+
+        if (annotations != null)
+        {
+            _annotations = new SortedDictionary<string, IAnnotation>();
+            foreach (var annotation in annotations)
+            {
+                _annotations[annotation.Name] = annotation;
+            }
+        }
     }
 
     private SelectExpression(string? alias)
@@ -3776,6 +3787,39 @@ List<T> VisitList<T>(List<T> list, bool inPlace, out bool changed)
         return newSelectExpression;
     }
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => throw new NotImplementedException("inconceivable");
+
+    /// <inheritdoc />
+    public override TableExpressionBase AddAnnotation(string name, object? value)
+    {
+        var oldAnnotation = FindAnnotation(name);
+        if (oldAnnotation != null)
+        {
+            return Equals(oldAnnotation.Value, value)
+                ? this
+                : throw new InvalidOperationException(CoreStrings.DuplicateAnnotation(name, this.Print()));
+        }
+
+        _annotations ??= new();
+        _annotations[name] = new Annotation(name, value);
+
+        return this;
+    }
+
+    /// <inheritdoc />
+    public override IAnnotation? FindAnnotation(string name)
+        => _annotations == null
+            ? null
+            : _annotations.TryGetValue(name, out var annotation)
+                ? annotation
+                : null;
+
+    /// <inheritdoc />
+    public override IEnumerable<IAnnotation> GetAnnotations()
+        => _annotations?.Values ?? Enumerable.Empty<IAnnotation>();
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs
index 959cfdd2f3..3f4c0a62d7 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/TableExpression.cs
@@ -28,23 +28,6 @@ private TableExpression(ITableBase table, IEnumerable<IAnnotation>? annotations)
         Table = table;
     }
 
-    /// <inheritdoc />
-    ITableBase ITableBasedExpression.Table => Table;
-
-    /// <inheritdoc />
-    protected override void Print(ExpressionPrinter expressionPrinter)
-    {
-        if (!string.IsNullOrEmpty(Schema))
-        {
-            expressionPrinter.Append(Schema).Append(".");
-        }
-
-        expressionPrinter.Append(Name);
-        PrintAnnotations(expressionPrinter);
-
-        expressionPrinter.Append(" AS ").Append(Alias);
-    }
-
     /// <summary>
     ///     The alias assigned to this table source.
     /// </summary>
@@ -71,8 +54,28 @@ protected override void Print(ExpressionPrinter expressionPrinter)
     public ITableBase Table { get; }
 
     /// <inheritdoc />
-    public TableExpressionBase Clone()
-        => new TableExpression(Table, GetAnnotations()) { Alias = Alias };
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new TableExpression(Table, annotations) { Alias = Alias };
+
+    /// <inheritdoc />
+    ITableBase ITableBasedExpression.Table => Table;
+
+    /// <inheritdoc />
+    protected override void Print(ExpressionPrinter expressionPrinter)
+    {
+        if (!string.IsNullOrEmpty(Schema))
+        {
+            expressionPrinter.Append(Schema).Append(".");
+        }
+
+        expressionPrinter.Append(Name);
+        PrintAnnotations(expressionPrinter);
+
+        expressionPrinter.Append(" AS ").Append(Alias);
+    }
+
+    /// <inheritdoc />
+    public TableExpressionBase Clone() => CreateWithAnnotations(GetAnnotations());
 
     /// <inheritdoc />
     public override bool Equals(object? obj)
diff --git a/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs b/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs
index e4cfb2342c..d535dc2a3e 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/TableExpressionBase.cs
@@ -12,9 +12,9 @@ namespace Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 ///         not used in application code.
 ///     </para>
 /// </summary>
-public abstract class TableExpressionBase : Expression, IPrintableExpression, IMutableAnnotatable
+public abstract class TableExpressionBase : Expression, IPrintableExpression
 {
-    private SortedDictionary<string, Annotation>? _annotations;
+    private readonly IReadOnlyDictionary<string, IAnnotation>? _annotations;
 
     /// <summary>
     ///     Creates a new instance of the <see cref="TableExpressionBase" /> class.
@@ -37,10 +37,13 @@ protected TableExpressionBase(string? alias, IEnumerable<IAnnotation>? annotatio
 
         if (annotations != null)
         {
+            var dictionary = new SortedDictionary<string, IAnnotation>();
             foreach (var annotation in annotations)
             {
-                SetAnnotation(annotation.Name, annotation.Value);
+                dictionary[annotation.Name] = annotation;
             }
+
+            _annotations = dictionary;
         }
     }
 
@@ -61,33 +64,6 @@ public override Type Type
     public sealed override ExpressionType NodeType
         => ExpressionType.Extension;
 
-    /// <summary>
-    ///     Gets the value annotation with the given name, returning <see langword="null" /> if it does not exist.
-    /// </summary>
-    /// <param name="name">The key of the annotation to find.</param>
-    /// <returns>
-    ///     The value of the existing annotation if an annotation with the specified name already exists.
-    ///     Otherwise, <see langword="null" />.
-    /// </returns>
-    public virtual object? this[string name]
-    {
-        get => FindAnnotation(name)?.Value;
-
-        set
-        {
-            Check.NotEmpty(name, nameof(name));
-
-            if (value == null)
-            {
-                RemoveAnnotation(name);
-            }
-            else
-            {
-                SetAnnotation(name, value);
-            }
-        }
-    }
-
     /// <summary>
     ///     Creates a printable string representation of the given expression using <see cref="ExpressionPrinter" />.
     /// </summary>
@@ -132,87 +108,28 @@ public override int GetHashCode()
     /// </summary>
     /// <param name="name">The key of the annotation to be added.</param>
     /// <param name="value">The value to be stored in the annotation.</param>
-    /// <returns>The newly added annotation.</returns>
-    public virtual Annotation AddAnnotation(string name, object? value)
-        => AddAnnotation(name, new(name, value));
-
-    /// <summary>
-    ///     Adds an annotation to this object. Throws if an annotation with the specified name already exists.
-    /// </summary>
-    /// <param name="name">The key of the annotation to be added.</param>
-    /// <param name="annotation">The annotation to be added.</param>
-    /// <returns>The added annotation.</returns>
-    protected virtual Annotation AddAnnotation(string name, Annotation annotation)
-    {
-        if (FindAnnotation(name) != null)
-        {
-            throw new InvalidOperationException(CoreStrings.DuplicateAnnotation(name, ToString()));
-        }
-
-        SetAnnotation(name, annotation, oldAnnotation: null);
-
-        return annotation;
-    }
-
-    /// <summary>
-    ///     Sets the annotation stored under the given key. Overwrites the existing annotation if an
-    ///     annotation with the specified name already exists.
-    /// </summary>
-    /// <param name="name">The key of the annotation to be added.</param>
-    /// <param name="value">The value to be stored in the annotation.</param>
-    public virtual void SetAnnotation(string name, object? value)
+    /// <returns>The new expression with annotation applied to it.</returns>
+    public virtual TableExpressionBase AddAnnotation(string name, object? value)
     {
         var oldAnnotation = FindAnnotation(name);
-        if (oldAnnotation != null
-            && Equals(oldAnnotation.Value, value))
+        if (oldAnnotation != null)
         {
-            return;
+            return Equals(oldAnnotation.Value, value)
+                ? this
+                : throw new InvalidOperationException(CoreStrings.DuplicateAnnotation(name, this.Print()));
         }
 
-        SetAnnotation(name, new(name, value), oldAnnotation);
-    }
+        var annotation = new Annotation(name, value);
 
-    /// <summary>
-    ///     Sets the annotation stored under the given key. Overwrites the existing annotation if an
-    ///     annotation with the specified name already exists.
-    /// </summary>
-    /// <param name="name">The key of the annotation to be added.</param>
-    /// <param name="annotation">The annotation to be set.</param>
-    /// <param name="oldAnnotation">The annotation being replaced.</param>
-    /// <returns>The annotation that was set.</returns>
-    protected virtual Annotation? SetAnnotation(
-        string name,
-        Annotation annotation,
-        Annotation? oldAnnotation)
-    {
-        _annotations ??= new SortedDictionary<string, Annotation>(StringComparer.Ordinal);
-        _annotations[name] = annotation;
-
-        return annotation;
+        return CreateWithAnnotations(new[] { annotation }.Concat(GetAnnotations()));
     }
 
     /// <summary>
-    ///     Removes the given annotation from this object.
+    ///     Creates an object like this with specified annotations.
     /// </summary>
-    /// <param name="name">The annotation to remove.</param>
-    /// <returns>The annotation that was removed.</returns>
-    public virtual Annotation? RemoveAnnotation(string name)
-    {
-        var annotation = FindAnnotation(name);
-        if (annotation == null)
-        {
-            return null;
-        }
-
-        _annotations!.Remove(name);
-
-        if (_annotations.Count == 0)
-        {
-            _annotations = null;
-        }
-
-        return annotation;
-    }
+    /// <param name="annotations">The annotations to be applied.</param>
+    /// <returns>The new expression with given annotations.</returns>
+    protected abstract TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations);
 
     /// <summary>
     ///     Gets the annotation with the given name, returning <see langword="null" /> if it does not exist.
@@ -221,40 +138,16 @@ public virtual void SetAnnotation(string name, object? value)
     /// <returns>
     ///     The existing annotation if an annotation with the specified name already exists. Otherwise, <see langword="null" />.
     /// </returns>
-    public virtual Annotation? FindAnnotation(string name)
-    {
-        Check.NotEmpty(name, nameof(name));
-
-        return _annotations == null
+    public virtual IAnnotation? FindAnnotation(string name)
+        => _annotations == null
             ? null
             : _annotations.TryGetValue(name, out var annotation)
                 ? annotation
                 : null;
-    }
 
     /// <summary>
     ///     Gets all annotations on the current object.
     /// </summary>
     public virtual IEnumerable<IAnnotation> GetAnnotations()
-        => _annotations?.Values ?? Enumerable.Empty<Annotation>();
-
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    IAnnotation IMutableAnnotatable.AddAnnotation(string name, object? value)
-        => AddAnnotation(name, value);
-
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    IAnnotation? IMutableAnnotatable.RemoveAnnotation(string name)
-        => RemoveAnnotation(name);
-
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    void IMutableAnnotatable.SetOrRemoveAnnotation(string name, object? value)
-        => this[name] = value;
-
-    /// <inheritdoc />
-    [DebuggerStepThrough]
-    IAnnotation? IReadOnlyAnnotatable.FindAnnotation(string name)
-        => FindAnnotation(name);
+        => _annotations?.Values ?? Enumerable.Empty<IAnnotation>();
 }
diff --git a/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs
index db40d23cd9..5c556f64c1 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/TableValuedFunctionExpression.cs
@@ -91,6 +91,10 @@ public virtual TableValuedFunctionExpression Update(IReadOnlyList<SqlExpression>
             ? new TableValuedFunctionExpression(Alias, StoreFunction, arguments, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new TableValuedFunctionExpression(Alias, StoreFunction, Arguments, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs
index 617b53ee41..f72196243f 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/UnionExpression.cs
@@ -61,6 +61,10 @@ public virtual UnionExpression Update(SelectExpression source1, SelectExpression
             ? new UnionExpression(Alias, source1, source2, IsDistinct, GetAnnotations())
             : this;
 
+    /// <inheritdoc />
+    protected override TableExpressionBase CreateWithAnnotations(IEnumerable<IAnnotation> annotations)
+        => new UnionExpression(Alias, Source1, Source2, IsDistinct, annotations);
+
     /// <inheritdoc />
     protected override void Print(ExpressionPrinter expressionPrinter)
     {
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
index 85d4bd799d..85d8489f97 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQuerySqlGenerator.cs
@@ -227,7 +227,8 @@ protected override Expression VisitExtension(Expression extensionExpression)
                 Sql.Append(Dependencies.SqlGenerationHelper.DelimitIdentifier(tableExpression.Name, tableExpression.Schema))
                     .Append(" FOR SYSTEM_TIME ");
 
-                var temporalOperationType = (TemporalOperationType)tableExpression[SqlServerAnnotationNames.TemporalOperationType]!;
+                var temporalOperationType = (TemporalOperationType)tableExpression
+                    .FindAnnotation(SqlServerAnnotationNames.TemporalOperationType)!.Value!;
 
                 switch (temporalOperationType)
                 {
@@ -236,7 +237,7 @@ protected override Expression VisitExtension(Expression extensionExpression)
                         break;
 
                     case TemporalOperationType.AsOf:
-                        var pointInTime = (DateTime)tableExpression[SqlServerAnnotationNames.TemporalAsOfPointInTime]!;
+                        var pointInTime = (DateTime)tableExpression.FindAnnotation(SqlServerAnnotationNames.TemporalAsOfPointInTime)!.Value!;
 
                         Sql.Append("AS OF ")
                             .Append(_typeMappingSource.GetMapping(typeof(DateTime)).GenerateSqlLiteral(pointInTime));
@@ -246,10 +247,10 @@ protected override Expression VisitExtension(Expression extensionExpression)
                     case TemporalOperationType.ContainedIn:
                     case TemporalOperationType.FromTo:
                         var from = _typeMappingSource.GetMapping(typeof(DateTime)).GenerateSqlLiteral(
-                            (DateTime)tableExpression[SqlServerAnnotationNames.TemporalRangeOperationFrom]!);
+                            (DateTime)tableExpression.FindAnnotation(SqlServerAnnotationNames.TemporalRangeOperationFrom)!.Value!);
 
                         var to = _typeMappingSource.GetMapping(typeof(DateTime)).GenerateSqlLiteral(
-                            (DateTime)tableExpression[SqlServerAnnotationNames.TemporalRangeOperationTo]!);
+                            (DateTime)tableExpression.FindAnnotation(SqlServerAnnotationNames.TemporalRangeOperationTo)!.Value!);
 
                         switch (temporalOperationType)
                         {
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs
index 66319ea677..ab05a12159 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerQueryableMethodTranslatingExpressionVisitor.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using System.Diagnostics.CodeAnalysis;
+using System.Linq.Expressions;
 using Microsoft.EntityFrameworkCore.Query.SqlExpressions;
 using Microsoft.EntityFrameworkCore.SqlServer.Metadata.Internal;
 
@@ -61,44 +62,30 @@ protected override Expression VisitExtension(Expression extensionExpression)
         if (extensionExpression is TemporalQueryRootExpression queryRootExpression)
         {
             var selectExpression = RelationalDependencies.SqlExpressionFactory.Select(queryRootExpression.EntityType);
-
-            var tableExpressions = ExtractTableExpressions(selectExpression);
-            ValidateAllTablesHaveSameAnnotations(tableExpressions);
-            foreach (var tableExpression in tableExpressions)
+            Func<TableExpression, TableExpressionBase> annotationApplyingFunc = queryRootExpression switch
             {
-                switch (queryRootExpression)
-                {
-                    case TemporalAllQueryRootExpression:
-                        tableExpression[SqlServerAnnotationNames.TemporalOperationType] = TemporalOperationType.All;
-                        break;
-
-                    case TemporalAsOfQueryRootExpression asOf:
-                        tableExpression[SqlServerAnnotationNames.TemporalOperationType] = TemporalOperationType.AsOf;
-                        tableExpression[SqlServerAnnotationNames.TemporalAsOfPointInTime] = asOf.PointInTime;
-                        break;
-
-                    case TemporalBetweenQueryRootExpression between:
-                        tableExpression[SqlServerAnnotationNames.TemporalOperationType] = TemporalOperationType.Between;
-                        tableExpression[SqlServerAnnotationNames.TemporalRangeOperationFrom] = between.From;
-                        tableExpression[SqlServerAnnotationNames.TemporalRangeOperationTo] = between.To;
-                        break;
-
-                    case TemporalContainedInQueryRootExpression containedIn:
-                        tableExpression[SqlServerAnnotationNames.TemporalOperationType] = TemporalOperationType.ContainedIn;
-                        tableExpression[SqlServerAnnotationNames.TemporalRangeOperationFrom] = containedIn.From;
-                        tableExpression[SqlServerAnnotationNames.TemporalRangeOperationTo] = containedIn.To;
-                        break;
-
-                    case TemporalFromToQueryRootExpression fromTo:
-                        tableExpression[SqlServerAnnotationNames.TemporalOperationType] = TemporalOperationType.FromTo;
-                        tableExpression[SqlServerAnnotationNames.TemporalRangeOperationFrom] = fromTo.From;
-                        tableExpression[SqlServerAnnotationNames.TemporalRangeOperationTo] = fromTo.To;
-                        break;
-
-                    default:
-                        throw new InvalidOperationException(queryRootExpression.Print());
-                }
-            }
+                TemporalAllQueryRootExpression => te => te
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalOperationType, TemporalOperationType.All),
+                TemporalAsOfQueryRootExpression asOf => te => te
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalOperationType, TemporalOperationType.AsOf)
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalAsOfPointInTime, asOf.PointInTime),
+                TemporalBetweenQueryRootExpression between => te => te
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalOperationType, TemporalOperationType.Between)
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalRangeOperationFrom, between.From)
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalRangeOperationTo, between.To),
+                TemporalContainedInQueryRootExpression containedIn => te => te
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalOperationType, TemporalOperationType.ContainedIn)
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalRangeOperationFrom, containedIn.From)
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalRangeOperationTo, containedIn.To),
+                TemporalFromToQueryRootExpression fromTo => te => te
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalOperationType, TemporalOperationType.FromTo)
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalRangeOperationFrom, fromTo.From)
+                        .AddAnnotation(SqlServerAnnotationNames.TemporalRangeOperationTo, fromTo.To),
+                _ => throw new InvalidOperationException(queryRootExpression.Print()),
+            };
+
+            selectExpression = (SelectExpression)new TemporalAnnotationApplyingExpressionVisitor(annotationApplyingFunc)
+                .Visit(selectExpression);
 
             return new ShapedQueryExpression(
                 selectExpression,
@@ -159,59 +146,21 @@ protected override Expression VisitExtension(Expression extensionExpression)
         return false;
     }
 
-    private List<TableExpressionBase> ExtractTableExpressions(TableExpressionBase tableExpressionBase)
+    private sealed class TemporalAnnotationApplyingExpressionVisitor : ExpressionVisitor
     {
-        if (tableExpressionBase is JoinExpressionBase joinExpression)
-        {
-            tableExpressionBase = joinExpression.Table;
-        }
+        private readonly Func<TableExpression, TableExpressionBase> _annotationApplyingFunc;
 
-        if (tableExpressionBase is TableExpression tableExpression)
+        public TemporalAnnotationApplyingExpressionVisitor(Func<TableExpression, TableExpressionBase> annotationApplyingFunc)
         {
-            return new List<TableExpressionBase> { tableExpression };
+            _annotationApplyingFunc = annotationApplyingFunc;
         }
 
-        if (tableExpressionBase is SelectExpression selectExpression)
+        [return: NotNullIfNotNull("expression")]
+        public override Expression? Visit(Expression? expression)
         {
-            var result = new List<TableExpressionBase>();
-            foreach (var table in selectExpression.Tables)
-            {
-                result.AddRange(ExtractTableExpressions(table));
-            }
-
-            return result;
-        }
-
-        if (tableExpressionBase is SetOperationBase setOperationBase)
-        {
-            var result = new List<TableExpressionBase>();
-            result.AddRange(ExtractTableExpressions(setOperationBase.Source1));
-            result.AddRange(ExtractTableExpressions(setOperationBase.Source2));
-
-            return result;
-        }
-
-        throw new InvalidOperationException("Unsupported table expression base type.");
-    }
-
-    private void ValidateAllTablesHaveSameAnnotations(List<TableExpressionBase> tableExpressions)
-    {
-        List<IAnnotation>? expectedAnnotations = null;
-        foreach (var tableExpression in tableExpressions)
-        {
-            if (expectedAnnotations == null)
-            {
-                expectedAnnotations = new List<IAnnotation>(tableExpression.GetAnnotations().OrderBy(x => x.Name));
-            }
-            else
-            {
-                var annotations = tableExpression.GetAnnotations().OrderBy(x => x.Name).ToList();
-                if (expectedAnnotations.Count != annotations.Count
-                    || expectedAnnotations.Zip(annotations, (e, a) => e.Name != a.Name || e.Value != a.Value).Any())
-                {
-                    throw new InvalidOperationException("Annotations for all tables representing an entity type must match.");
-                }
-            }
+            return expression is TableExpression tableExpression
+                ? _annotationApplyingFunc(tableExpression)
+                : base.Visit(expression);
         }
     }
 }
