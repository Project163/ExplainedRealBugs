diff --git a/src/EFCore/Metadata/Internal/EntityTypeExtensions.cs b/src/EFCore/Metadata/Internal/EntityTypeExtensions.cs
index a2db313126..30476e2396 100644
--- a/src/EFCore/Metadata/Internal/EntityTypeExtensions.cs
+++ b/src/EFCore/Metadata/Internal/EntityTypeExtensions.cs
@@ -116,28 +116,7 @@ public static bool IsInOwnershipPath(this IReadOnlyEntityType entityType, Type t
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public static bool IsInOwnershipPath(this IReadOnlyEntityType entityType, IReadOnlyEntityType targetType)
-    {
-        if (entityType == targetType)
-        {
-            return true;
-        }
-
-        var owner = entityType;
-        while (true)
-        {
-            var ownership = owner.FindOwnership();
-            if (ownership == null)
-            {
-                return false;
-            }
-
-            owner = ownership.PrincipalEntityType;
-            if (owner.IsAssignableFrom(targetType))
-            {
-                return true;
-            }
-        }
-    }
+        => entityType.IsInOwnershipPath(targetType);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore/Metadata/Internal/InternalComplexTypeBuilder.cs b/src/EFCore/Metadata/Internal/InternalComplexTypeBuilder.cs
index 050cb192e5..1358617546 100644
--- a/src/EFCore/Metadata/Internal/InternalComplexTypeBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalComplexTypeBuilder.cs
@@ -43,9 +43,11 @@ public new virtual ComplexType Metadata
         [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.Interfaces)] Type? propertyType,
         string propertyName,
         ConfigurationSource configurationSource,
-        bool checkClrProperty = false)
+        bool checkClrProperty,
+        bool skipTypeCheck)
         => !IsIgnored(propertyName, configurationSource)
             && (propertyType == null
+                || skipTypeCheck
                 || Metadata.Model.Builder.CanBeConfigured(propertyType, TypeConfigurationType.Property, configurationSource))
             && (!checkClrProperty
                 || propertyType != null
diff --git a/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs b/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
index 8eaf54203a..6cdef5bd72 100644
--- a/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalEntityTypeBuilder.cs
@@ -537,9 +537,11 @@ public override void RemoveMembersInHierarchy(string propertyName, Configuration
         [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.Interfaces)] Type? propertyType,
         string propertyName,
         ConfigurationSource configurationSource,
-        bool checkClrProperty = false)
+        bool checkClrProperty,
+        bool skipTypeCheck)
         => !IsIgnored(propertyName, configurationSource)
             && (propertyType == null
+                || skipTypeCheck
                 || Metadata.Model.Builder.CanBeConfigured(propertyType, TypeConfigurationType.Property, configurationSource))
             && (!checkClrProperty
                 || propertyType != null
@@ -2810,7 +2812,7 @@ public static InternalIndexBuilder DetachIndex(Index indexToDetach)
 
                 shouldInvert ??= setTargetAsPrincipal != true
                     && (setTargetAsPrincipal != null
-                        || ((IReadOnlyEntityType)targetEntityType).IsInOwnershipPath(Metadata));
+                        || targetEntityType.IsInOwnershipPath(Metadata));
                 if (!shouldInvert.Value)
                 {
                     newRelationship = CreateForeignKey(
@@ -2838,7 +2840,6 @@ public static InternalIndexBuilder DetachIndex(Index indexToDetach)
                 }
 
                 relationship = newRelationship;
-
                 if (relationship == null)
                 {
                     return null;
@@ -3570,7 +3571,11 @@ private static bool Contains(IReadOnlyForeignKey? inheritedFk, IReadOnlyForeignK
                 targetShouldBeOwned ??= true;
                 break;
             default:
-                return null;
+                if (configurationSource != ConfigurationSource.Explicit)
+                {
+                    return null;
+                }
+                break;
         }
 
         if (targetShouldBeOwned == null
@@ -3730,6 +3735,11 @@ private static bool Contains(IReadOnlyForeignKey? inheritedFk, IReadOnlyForeignK
             foreignKey: null, principalEntityTypeBuilder, dependentProperties, principalKey,
             propertyBaseName, required, configurationSource)!;
 
+        if (foreignKey == null)
+        {
+            return null;
+        }
+
         if (required.HasValue
             && foreignKey.IsRequired == required.Value)
         {
diff --git a/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs b/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs
index c60a876577..56690729fa 100644
--- a/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalForeignKeyBuilder.cs
@@ -1129,8 +1129,7 @@ public virtual bool CanSetIsOwnership(bool? ownership, ConfigurationSource? conf
         var newOwnership = newEntityType.GetForeignKeys().SingleOrDefault(fk => fk.IsOwnership);
         if (newOwnership == null)
         {
-            Check.DebugAssert(Metadata.IsInModel, "Metadata isn't in the model");
-            return Metadata.Builder;
+            return Metadata.IsInModel ? Metadata.Builder : null;
         }
 
         Check.DebugAssert(!Metadata.IsInModel, "Metadata is in the model");
@@ -2922,11 +2921,6 @@ private static InternalForeignKeyBuilder MergeFacetsFrom(Navigation newNavigatio
                 ConfigurationSource.Convention)!;
         }
 
-        foreach (var removedForeignKey in removedForeignKeys)
-        {
-            Metadata.DeclaringEntityType.Model.ConventionDispatcher.Tracker.Update(removedForeignKey, newRelationshipBuilder.Metadata);
-        }
-
         if (tempIndex?.IsInModel == true)
         {
             dependentEntityType.RemoveIndex(tempIndex.Properties);
@@ -2937,6 +2931,16 @@ private static InternalForeignKeyBuilder MergeFacetsFrom(Navigation newNavigatio
             keyTempIndex.DeclaringEntityType.RemoveIndex(keyTempIndex.Properties);
         }
 
+        if (newRelationshipBuilder == null)
+        {
+            return null;
+        }
+
+        foreach (var removedForeignKey in removedForeignKeys)
+        {
+            Metadata.DeclaringEntityType.Model.ConventionDispatcher.Tracker.Update(removedForeignKey, newRelationshipBuilder.Metadata);
+        }
+
         return newRelationshipBuilder;
     }
 
diff --git a/src/EFCore/Metadata/Internal/InternalTypeBaseBuilder.cs b/src/EFCore/Metadata/Internal/InternalTypeBaseBuilder.cs
index 77fbf7e2f9..b9ab85070b 100644
--- a/src/EFCore/Metadata/Internal/InternalTypeBaseBuilder.cs
+++ b/src/EFCore/Metadata/Internal/InternalTypeBaseBuilder.cs
@@ -88,8 +88,13 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
     public virtual InternalPropertyBuilder? Property(
         Type? propertyType,
         string propertyName,
-        ConfigurationSource? configurationSource)
-        => Property(propertyType, propertyName, typeConfigurationSource: configurationSource, configurationSource: configurationSource);
+        ConfigurationSource? configurationSource,
+        bool skipTypeCheck = false)
+        => Property(
+            propertyType, propertyName, memberInfo: null,
+            typeConfigurationSource: configurationSource,
+            configurationSource: configurationSource,
+            skipTypeCheck);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -101,11 +106,13 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
         [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.Interfaces)] Type? propertyType,
         string propertyName,
         ConfigurationSource? typeConfigurationSource,
-        ConfigurationSource? configurationSource)
+        ConfigurationSource? configurationSource,
+        bool skipTypeCheck = false)
         => Property(
             propertyType, propertyName, memberInfo: null,
             typeConfigurationSource,
-            configurationSource);
+            configurationSource,
+            skipTypeCheck);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -134,7 +141,8 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
     public virtual InternalPropertyBuilder? IndexerProperty(
         [DynamicallyAccessedMembers(IProperty.DynamicallyAccessedMemberTypes)] Type? propertyType,
         string propertyName,
-        ConfigurationSource? configurationSource)
+        ConfigurationSource? configurationSource,
+        bool skipTypeCheck = false)
     {
         var indexerPropertyInfo = Metadata.FindIndexerPropertyInfo();
         if (indexerPropertyInfo == null)
@@ -143,7 +151,7 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
                 CoreStrings.NonIndexerEntityType(propertyName, Metadata.DisplayName(), typeof(string).ShortDisplayName()));
         }
 
-        return Property(propertyType, propertyName, indexerPropertyInfo, configurationSource, configurationSource);
+        return Property(propertyType, propertyName, indexerPropertyInfo, configurationSource, configurationSource, skipTypeCheck);
     }
 
     /// <summary>
@@ -157,7 +165,8 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
         string propertyName,
         MemberInfo? memberInfo,
         ConfigurationSource? typeConfigurationSource,
-        ConfigurationSource? configurationSource)
+        ConfigurationSource? configurationSource,
+        bool skipTypeCheck = false)
     {
         var entityType = Metadata;
         List<Property>? propertiesToDetach = null;
@@ -214,8 +223,8 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
         else
         {
             if (configurationSource != ConfigurationSource.Explicit
-                && (!configurationSource.HasValue
-                    || !CanAddProperty(propertyType ?? memberInfo?.GetMemberType(), propertyName, configurationSource.Value)))
+                && (!configurationSource.HasValue || !CanAddProperty(propertyType ?? memberInfo?.GetMemberType(),
+                    propertyName, configurationSource.Value, skipTypeCheck: skipTypeCheck)))
             {
                 return null;
             }
@@ -358,11 +367,13 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
     public virtual InternalPropertyBuilder? CreateUniqueProperty(
         Type propertyType,
         string propertyName,
-        bool required)
+        bool required,
+        bool checkType = false)
         => CreateUniqueProperties(
             new[] { propertyType },
             new[] { propertyName },
-            required)?.First().Builder;
+            required,
+            checkTypes: checkType)?.First().Builder;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -373,14 +384,16 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
     public virtual IReadOnlyList<Property>? CreateUniqueProperties(
         IReadOnlyList<Type> propertyTypes,
         IReadOnlyList<string> propertyNames,
-        bool isRequired)
+        bool isRequired,
+        bool checkTypes = false)
         => TryCreateUniqueProperties(
             propertyNames.Count,
             null,
             propertyTypes,
             propertyNames,
             isRequired,
-            "").Item2;
+            "",
+            checkTypes: checkTypes).Item2;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -391,14 +404,16 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
     public virtual IReadOnlyList<Property>? CreateUniqueProperties(
         IReadOnlyList<Property> principalProperties,
         bool isRequired,
-        string baseName)
+        string baseName,
+        bool checkTypes = false)
         => TryCreateUniqueProperties(
             principalProperties.Count,
             null,
             principalProperties.Select(p => p.ClrType),
             principalProperties.Select(p => p.Name),
             isRequired,
-            baseName).Item2;
+            baseName,
+            checkTypes: checkTypes).Item2;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -412,7 +427,8 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
         IEnumerable<Type> principalPropertyTypes,
         IEnumerable<string> principalPropertyNames,
         bool isRequired,
-        string baseName)
+        string baseName,
+        bool checkTypes = false)
     {
         var newProperties = currentProperties == null ? new Property[propertyCount] : null;
         var clrProperties = Metadata.GetRuntimeProperties();
@@ -446,8 +462,11 @@ public static bool IsCompatible(MemberInfo? newMemberInfo, PropertyBase existing
                     if (currentProperties == null)
                     {
                         var propertyBuilder = Property(
-                            clrType, propertyName, typeConfigurationSource: null,
-                            configurationSource: ConfigurationSource.Convention);
+                            clrType,
+                            propertyName,
+                            typeConfigurationSource: null,
+                            configurationSource: ConfigurationSource.Convention,
+                            skipTypeCheck: !checkTypes);
 
                         if (propertyBuilder == null)
                         {
@@ -768,7 +787,8 @@ public virtual void RemoveMembersInHierarchy(string propertyName, ConfigurationS
                     || typeConfigurationSource.Overrides(existingTypeConfigurationSource)))
             || configurationSource.Overrides(existingProperty.GetConfigurationSource())
             : configurationSource.HasValue
-            && CanAddProperty(propertyType ?? memberInfo?.GetMemberType(), propertyName, configurationSource.Value, checkClrProperty);
+            && CanAddProperty(propertyType ?? memberInfo?.GetMemberType(),
+                propertyName, configurationSource.Value, checkClrProperty: checkClrProperty);
     }
 
     /// <summary>
@@ -781,7 +801,8 @@ public virtual void RemoveMembersInHierarchy(string propertyName, ConfigurationS
         [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.Interfaces)] Type? propertyType,
         string propertyName,
         ConfigurationSource configurationSource,
-        bool checkClrProperty = false);
+        bool checkClrProperty = false,
+        bool skipTypeCheck = false);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/test/EFCore.Tests/ModelBuilding/OneToOneTestBase.cs b/test/EFCore.Tests/ModelBuilding/OneToOneTestBase.cs
index 8ee3d93cd9..932af4558e 100644
--- a/test/EFCore.Tests/ModelBuilding/OneToOneTestBase.cs
+++ b/test/EFCore.Tests/ModelBuilding/OneToOneTestBase.cs
@@ -2670,7 +2670,7 @@ public virtual void Throws_on_ambiguous_FK_when_self_referencing()
 
             Assert.Equal(
                 CoreStrings.AmbiguousOneToOneRelationship("SelfRef.SelfRef1", "SelfRef.SelfRef2"),
-                Assert.Throws<InvalidOperationException>(() => modelBuilder.FinalizeModel()).Message);
+                Assert.Throws<InvalidOperationException>(modelBuilder.FinalizeModel).Message);
         }
 
         [ConditionalFact]
@@ -2684,7 +2684,7 @@ public virtual void Throws_on_two_ambiguous_FK_when_self_referencing()
 
             Assert.Equal(
                 CoreStrings.AmbiguousOneToOneRelationship("SelfRef.SelfRef1", "SelfRef.SelfRef2"),
-                Assert.Throws<InvalidOperationException>(() => modelBuilder.FinalizeModel()).Message);
+                Assert.Throws<InvalidOperationException>(modelBuilder.FinalizeModel).Message);
         }
 
         [ConditionalFact]
diff --git a/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs b/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs
index c3338ce874..3cd6ad75c0 100644
--- a/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs
+++ b/test/EFCore.Tests/ModelBuilding/OwnedTypesTestBase.cs
@@ -2,107 +2,12 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 // ReSharper disable InconsistentNaming
-
 namespace Microsoft.EntityFrameworkCore.ModelBuilding;
 
 public abstract partial class ModelBuilderTest
 {
     public abstract class OwnedTypesTestBase : ModelBuilderTestBase
     {
-        [ConditionalTheory] // Issue #28091
-        [InlineData(16, 2, 16, 4, 16, 4, 16, 4, 16, 4)]
-        [InlineData(16, 2, 17, 4, 17, 4, 17, 4, 17, 4)]
-        [InlineData(null, null, 16, 4, 16, 4, 16, 4, 16, 4)]
-        [InlineData(null, null, 16, 4, 15, 3, 14, 2, 13, 1)]
-        [InlineData(null, null, 16, null, 15, null, 14, null, 13, null)]
-        [InlineData(17, null, 16, null, 15, null, 14, null, 13, null)]
-        [InlineData(17, 5, 16, 4, 15, 3, 14, 2, 13, 1)]
-        [InlineData(17, 5, null, null, null, null, null, null, null, null)]
-        public virtual void Precision_and_scale_for_property_type_used_in_owned_types_can_be_overwritten(
-            int? defaultPrecision,
-            int? defaultScale,
-            int? mainPrecision,
-            int? mainScale,
-            int? otherPrecision,
-            int? otherScale,
-            int? onePrecision,
-            int? oneScale,
-            int? manyPrecision,
-            int? manyScale)
-        {
-            var modelBuilder = CreateModelBuilder(
-                c =>
-                {
-                    if (defaultPrecision.HasValue)
-                    {
-                        if (defaultScale.HasValue)
-                        {
-                            c.Properties<decimal>().HavePrecision(defaultPrecision.Value, defaultScale.Value);
-                        }
-                        else
-                        {
-                            c.Properties<decimal>().HavePrecision(defaultPrecision.Value);
-                        }
-                    }
-                });
-
-            modelBuilder.Entity<MainOtter>(
-                b =>
-                {
-                    HasPrecision(b.Property(x => x.Number), mainPrecision, mainScale);
-                    b.OwnsOne(
-                        b => b.OwnedEntity, b =>
-                        {
-                            HasPrecision(b.Property(x => x.Number), onePrecision, oneScale);
-                        });
-                });
-
-            modelBuilder.Entity<OtherOtter>(
-                b =>
-                {
-                    HasPrecision(b.Property(x => x.Number), otherPrecision, otherScale);
-                    b.OwnsMany(
-                        b => b.OwnedEntities, b =>
-                        {
-                            HasPrecision(b.Property(x => x.Number), manyPrecision, manyScale);
-                        });
-                });
-
-            var model = modelBuilder.FinalizeModel();
-
-            var mainType = model.FindEntityType(typeof(MainOtter))!;
-            var otherType = model.FindEntityType(typeof(OtherOtter))!;
-            var oneType = model.FindEntityType(typeof(OwnedOtter), nameof(MainOtter.OwnedEntity), mainType)!;
-            var manyType = model.FindEntityType(typeof(OwnedOtter), nameof(OtherOtter.OwnedEntities), otherType)!;
-
-            Assert.Equal(mainPrecision ?? defaultPrecision, mainType.FindProperty(nameof(MainOtter.Number))!.GetPrecision());
-            Assert.Equal(mainScale ?? defaultScale, mainType.FindProperty(nameof(MainOtter.Number))!.GetScale());
-
-            Assert.Equal(otherPrecision ?? defaultPrecision, otherType.FindProperty(nameof(OtherOtter.Number))!.GetPrecision());
-            Assert.Equal(otherScale ?? defaultScale, otherType.FindProperty(nameof(OtherOtter.Number))!.GetScale());
-
-            Assert.Equal(onePrecision ?? defaultPrecision, oneType.FindProperty(nameof(OwnedOtter.Number))!.GetPrecision());
-            Assert.Equal(oneScale ?? defaultScale, oneType.FindProperty(nameof(OwnedOtter.Number))!.GetScale());
-
-            Assert.Equal(manyPrecision ?? defaultPrecision, manyType.FindProperty(nameof(OwnedOtter.Number))!.GetPrecision());
-            Assert.Equal(manyScale ?? defaultScale, manyType.FindProperty(nameof(OwnedOtter.Number))!.GetScale());
-
-            void HasPrecision(TestPropertyBuilder<decimal> testPropertyBuilder, int? precision, int? scale)
-            {
-                if (precision.HasValue)
-                {
-                    if (scale.HasValue)
-                    {
-                        testPropertyBuilder.HasPrecision(precision.Value, scale.Value);
-                    }
-                    else
-                    {
-                        testPropertyBuilder.HasPrecision(precision.Value);
-                    }
-                }
-            }
-        }
-
         [ConditionalFact]
         public virtual void Can_configure_owned_type()
         {
@@ -1531,6 +1436,192 @@ public virtual void Can_configure_self_ownership()
             Assert.Equal(2, model.GetEntityTypes().Count(e => e.ClrType == typeof(AnotherBookLabel)));
         }
 
+        [ConditionalTheory] // Issue #28091
+        [InlineData(16, 2, 16, 4, 16, 4, 16, 4, 16, 4)]
+        [InlineData(16, 2, 17, 4, 17, 4, 17, 4, 17, 4)]
+        [InlineData(null, null, 16, 4, 16, 4, 16, 4, 16, 4)]
+        [InlineData(null, null, 16, 4, 15, 3, 14, 2, 13, 1)]
+        [InlineData(null, null, 16, null, 15, null, 14, null, 13, null)]
+        [InlineData(17, null, 16, null, 15, null, 14, null, 13, null)]
+        [InlineData(17, 5, 16, 4, 15, 3, 14, 2, 13, 1)]
+        [InlineData(17, 5, null, null, null, null, null, null, null, null)]
+        public virtual void Precision_and_scale_for_property_type_used_in_owned_types_can_be_overwritten(
+            int? defaultPrecision,
+            int? defaultScale,
+            int? mainPrecision,
+            int? mainScale,
+            int? otherPrecision,
+            int? otherScale,
+            int? onePrecision,
+            int? oneScale,
+            int? manyPrecision,
+            int? manyScale)
+        {
+            var modelBuilder = CreateModelBuilder(
+                c =>
+                {
+                    if (defaultPrecision.HasValue)
+                    {
+                        if (defaultScale.HasValue)
+                        {
+                            c.Properties<decimal>().HavePrecision(defaultPrecision.Value, defaultScale.Value);
+                        }
+                        else
+                        {
+                            c.Properties<decimal>().HavePrecision(defaultPrecision.Value);
+                        }
+                    }
+                });
+
+            modelBuilder.Entity<MainOtter>(
+                b =>
+                {
+                    HasPrecision(b.Property(x => x.Number), mainPrecision, mainScale);
+                    b.OwnsOne(
+                        b => b.OwnedEntity, b =>
+                        {
+                            HasPrecision(b.Property(x => x.Number), onePrecision, oneScale);
+                        });
+                });
+
+            modelBuilder.Entity<OtherOtter>(
+                b =>
+                {
+                    HasPrecision(b.Property(x => x.Number), otherPrecision, otherScale);
+                    b.OwnsMany(
+                        b => b.OwnedEntities, b =>
+                        {
+                            HasPrecision(b.Property(x => x.Number), manyPrecision, manyScale);
+                        });
+                });
+
+            var model = modelBuilder.FinalizeModel();
+
+            var mainType = model.FindEntityType(typeof(MainOtter))!;
+            var otherType = model.FindEntityType(typeof(OtherOtter))!;
+            var oneType = model.FindEntityType(typeof(OwnedOtter), nameof(MainOtter.OwnedEntity), mainType)!;
+            var manyType = model.FindEntityType(typeof(OwnedOtter), nameof(OtherOtter.OwnedEntities), otherType)!;
+
+            Assert.Equal(mainPrecision ?? defaultPrecision, mainType.FindProperty(nameof(MainOtter.Number))!.GetPrecision());
+            Assert.Equal(mainScale ?? defaultScale, mainType.FindProperty(nameof(MainOtter.Number))!.GetScale());
+
+            Assert.Equal(otherPrecision ?? defaultPrecision, otherType.FindProperty(nameof(OtherOtter.Number))!.GetPrecision());
+            Assert.Equal(otherScale ?? defaultScale, otherType.FindProperty(nameof(OtherOtter.Number))!.GetScale());
+
+            Assert.Equal(onePrecision ?? defaultPrecision, oneType.FindProperty(nameof(OwnedOtter.Number))!.GetPrecision());
+            Assert.Equal(oneScale ?? defaultScale, oneType.FindProperty(nameof(OwnedOtter.Number))!.GetScale());
+
+            Assert.Equal(manyPrecision ?? defaultPrecision, manyType.FindProperty(nameof(OwnedOtter.Number))!.GetPrecision());
+            Assert.Equal(manyScale ?? defaultScale, manyType.FindProperty(nameof(OwnedOtter.Number))!.GetScale());
+
+            void HasPrecision(TestPropertyBuilder<decimal> testPropertyBuilder, int? precision, int? scale)
+            {
+                if (precision.HasValue)
+                {
+                    if (scale.HasValue)
+                    {
+                        testPropertyBuilder.HasPrecision(precision.Value, scale.Value);
+                    }
+                    else
+                    {
+                        testPropertyBuilder.HasPrecision(precision.Value);
+                    }
+                }
+            }
+        }
+
+        protected class Department
+        {
+            public DepartmentId Id { get; protected set; }
+            public List<DepartmentId> DepartmentIds { get; set; }
+        }
+
+        protected class DepartmentId
+        {
+            public DepartmentId() { }
+
+            public DepartmentId(int value)
+            {
+                Value = value;
+            }
+
+            public int Value { get; }
+        }
+
+        protected class Office
+        {
+            public int Id { get; protected set; }
+            public List<DepartmentId> DepartmentIds { get; set; }
+        }
+
+        [ConditionalFact]
+        public virtual void Can_configure_property_and_owned_entity_of_same_type()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Entity<Department>(b =>
+            {
+                b.Property(d => d.Id)
+                    .HasConversion(
+                        id => id.Value,
+                        value => new DepartmentId(value));
+
+                b.OwnsMany(d => d.DepartmentIds);
+            });
+
+            modelBuilder.Entity<Office>()
+                .OwnsMany(o => o.DepartmentIds);
+
+            var model = modelBuilder.FinalizeModel();
+
+            var departmentType = model.FindEntityType(typeof(Department))!;
+            var departmentNestedType = model.FindEntityType(typeof(DepartmentId), nameof(Department.DepartmentIds), departmentType)!;
+            var officeType = model.FindEntityType(typeof(Office))!;
+            var officeNestedType = model.FindEntityType(typeof(DepartmentId), nameof(Office.DepartmentIds), officeType)!;
+
+            var departmentIdProperty = departmentType.FindProperty(nameof(Department.Id));
+            Assert.NotNull(departmentIdProperty);
+            Assert.NotNull(departmentNestedType);
+            Assert.NotNull(officeNestedType);
+
+            var departmentIdFkProperty = departmentNestedType.GetForeignKeys().Single().Properties[0];
+            Assert.Same(departmentIdProperty.GetValueConverter(), departmentIdFkProperty.GetValueConverter());
+        }
+
+        [ConditionalFact]
+        public virtual void Can_configure_owned_entity_and_property_of_same_type()
+        {
+            var modelBuilder = CreateModelBuilder();
+
+            modelBuilder.Entity<Office>()
+                .OwnsMany(o => o.DepartmentIds);
+
+            modelBuilder.Entity<Department>(b =>
+            {
+                b.Property(d => d.Id)
+                    .HasConversion(
+                        id => id.Value,
+                        value => new DepartmentId(value));
+
+                b.OwnsMany(d => d.DepartmentIds);
+            });
+
+            var model = modelBuilder.FinalizeModel();
+
+            var departmentType = model.FindEntityType(typeof(Department))!;
+            var departmentNestedType = model.FindEntityType(typeof(DepartmentId), nameof(Department.DepartmentIds), departmentType)!;
+            var officeType = model.FindEntityType(typeof(Office))!;
+            var officeNestedType = model.FindEntityType(typeof(DepartmentId), nameof(Office.DepartmentIds), officeType)!;
+
+            var departmentIdProperty = departmentType.FindProperty(nameof(Department.Id));
+            Assert.NotNull(departmentIdProperty);
+            Assert.NotNull(departmentNestedType);
+            Assert.NotNull(officeNestedType);
+
+            var departmentIdFkProperty = departmentNestedType.GetForeignKeys().Single().Properties[0];
+            Assert.Same(departmentIdProperty.GetValueConverter(), departmentIdFkProperty.GetValueConverter());
+        }
+
         [ConditionalFact]
         public virtual void Reconfiguring_entity_type_as_owned_throws()
         {
