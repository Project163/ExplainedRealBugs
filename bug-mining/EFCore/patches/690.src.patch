diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs
index 77b611b08c..e70acb5519 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs
@@ -70,8 +70,11 @@ public sealed partial class ShaperProcessingExpressionVisitor : ExpressionVisito
         private static readonly MethodInfo IncludeJsonEntityCollectionMethodInfo
             = typeof(ShaperProcessingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(IncludeJsonEntityCollection))!;
 
-        private static readonly MethodInfo MaterializeJsonEntityMethodInfo
-            = typeof(ShaperProcessingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(MaterializeJsonEntity))!;
+        private static readonly MethodInfo MaterializeJsonStructuralTypeMethodInfo
+            = typeof(ShaperProcessingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(MaterializeJsonStructuralType))!;
+
+        private static readonly MethodInfo MaterializeJsonNullableValueStructuralTypeMethodInfo
+            = typeof(ShaperProcessingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(MaterializeJsonNullableValueStructuralType))!;
 
         private static readonly MethodInfo MaterializeJsonEntityCollectionMethodInfo
             = typeof(ShaperProcessingExpressionVisitor).GetTypeInfo().GetDeclaredMethod(nameof(MaterializeJsonEntityCollection))!;
@@ -959,20 +962,64 @@ void GenerateCurrentElementIfPending()
         ///     doing so can result in application failures when updating to a new Entity Framework Core release.
         /// </summary>
         [EntityFrameworkInternal]
-        public static TEntity? MaterializeJsonEntity<TEntity>(
+        public static TStructural? MaterializeJsonStructuralType<TStructural>(
             QueryContext queryContext,
             object[]? keyPropertyValues,
             JsonReaderData? jsonReaderData,
             bool nullable,
-            Func<QueryContext, object[]?, JsonReaderData, TEntity> shaper)
-            where TEntity : class
+            Func<QueryContext, object[]?, JsonReaderData, TStructural> shaper)
+        {
+            if (jsonReaderData == null)
+            {
+                return nullable
+                    ? default
+                    : throw new InvalidOperationException(
+                        RelationalStrings.JsonRequiredEntityWithNullJson(typeof(TStructural).Name));
+            }
+
+            var manager = new Utf8JsonReaderManager(jsonReaderData, queryContext.QueryLogger);
+            var tokenType = manager.CurrentReader.TokenType;
+
+            switch (tokenType)
+            {
+                case JsonTokenType.Null:
+                    return nullable
+                        ? default
+                        : throw new InvalidOperationException(
+                            RelationalStrings.JsonRequiredEntityWithNullJson(typeof(TStructural).Name));
+
+                case not JsonTokenType.StartObject:
+                    throw new InvalidOperationException(
+                        CoreStrings.JsonReaderInvalidTokenType(tokenType.ToString()));
+            }
+
+            manager.CaptureState();
+            var result = shaper(queryContext, keyPropertyValues, jsonReaderData);
+
+            return result;
+        }
+
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        [EntityFrameworkInternal]
+        public static TStructural? MaterializeJsonNullableValueStructuralType<TStructural>(
+            QueryContext queryContext,
+            object[]? keyPropertyValues,
+            JsonReaderData? jsonReaderData,
+            bool nullable,
+            Func<QueryContext, object[]?, JsonReaderData, TStructural> shaper)
+            where TStructural : struct
         {
             if (jsonReaderData == null)
             {
                 return nullable
                     ? null
                     : throw new InvalidOperationException(
-                        RelationalStrings.JsonRequiredEntityWithNullJson(typeof(TEntity).Name));
+                        RelationalStrings.JsonRequiredEntityWithNullJson(typeof(TStructural).Name));
             }
 
             var manager = new Utf8JsonReaderManager(jsonReaderData, queryContext.QueryLogger);
@@ -984,7 +1031,7 @@ void GenerateCurrentElementIfPending()
                     return nullable
                         ? null
                         : throw new InvalidOperationException(
-                            RelationalStrings.JsonRequiredEntityWithNullJson(typeof(TEntity).Name));
+                            RelationalStrings.JsonRequiredEntityWithNullJson(typeof(TStructural).Name));
 
                 case not JsonTokenType.StartObject:
                     throw new InvalidOperationException(
@@ -1081,16 +1128,14 @@ void GenerateCurrentElementIfPending()
         ///     doing so can result in application failures when updating to a new Entity Framework Core release.
         /// </summary>
         [EntityFrameworkInternal]
-        public static void IncludeJsonEntityReference<TIncludingEntity, TIncludedEntity>(
+        public static void IncludeJsonEntityReference<TStructural, TRelatedStructural>(
             QueryContext queryContext,
             object[]? keyPropertyValues,
             JsonReaderData? jsonReaderData,
-            TIncludingEntity entity,
-            Func<QueryContext, object[]?, JsonReaderData, TIncludedEntity> innerShaper,
-            Action<TIncludingEntity, TIncludedEntity> fixup,
+            TStructural structuralType,
+            Func<QueryContext, object[]?, JsonReaderData, TRelatedStructural> innerShaper,
+            Action<TStructural, TRelatedStructural> fixup,
             bool performFixup)
-            where TIncludingEntity : class
-            where TIncludedEntity : class
         {
             if (jsonReaderData == null)
             {
@@ -1114,7 +1159,7 @@ void GenerateCurrentElementIfPending()
 
             if (performFixup)
             {
-                fixup(entity, included);
+                fixup(structuralType, included);
             }
         }
 
diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
index 0ace14bbc6..6bdb8d1f2e 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
@@ -1672,7 +1672,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                         var elementFixup = Lambda(
                             Block(
                                 typeof(void),
-                                AssignReferenceRelationship(
+                                AssignStructuralProperty(
                                     innerFixupCollectionElementParameter,
                                     innerFixupParentParameter,
                                     inverseNavigation)),
@@ -1709,7 +1709,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                 {
                     var fixup = GenerateReferenceFixupForJson(
                         structuralType.ClrType,
-                        relatedStructuralType.ClrType,
+                        nestedRelationship.ClrType,
                         nestedRelationship,
                         inverseNavigation);
 
@@ -1847,8 +1847,27 @@ relationship switch
                 return materializeJsonEntityCollectionMethodCall;
             }
 
+
+            // Return the materializer for this JSON object, including null checks which would return null.
+            MethodInfo method;
+
+            if (relationship is not null && Nullable.GetUnderlyingType(relationship.ClrType) is { } underlyingType)
+            {
+                // The association property into which we're assigning has a nullable value type, so generate
+                // a materializer that returns that nullable value type (note that the shaperLambda that
+                // we pass itself always returns a non-nullable value (the null checks are outside of it.))
+                Check.DebugAssert(nullable, "On non-nullable relationship but the relationship's ClrType is Nullable<T>");
+                Check.DebugAssert(underlyingType == structuralType.ClrType);
+
+                method = MaterializeJsonNullableValueStructuralTypeMethodInfo.MakeGenericMethod(structuralType.ClrType);
+            }
+            else
+            {
+                method = MaterializeJsonStructuralTypeMethodInfo.MakeGenericMethod(structuralType.ClrType);
+            }
+
             var materializedRootJsonEntity = Call(
-                MaterializeJsonEntityMethodInfo.MakeGenericMethod(structuralType.ClrType),
+                method,
                 QueryCompilationContext.QueryContextParameter,
                 keyValuesParameter,
                 jsonReaderDataParameter,
@@ -1969,9 +1988,9 @@ protected override Expression VisitSwitch(SwitchExpression switchExpression)
 
                     var managerVariable = Variable(typeof(Utf8JsonReaderManager), "jsonReaderManager");
                     var tokenTypeVariable = Variable(typeof(JsonTokenType), "tokenType");
-                    var jsonEntityTypeVariable = (ParameterExpression)jsonEntityTypeInitializerBlock.Expressions[^1];
+                    var jsonStructuralTypeVariable = (ParameterExpression)jsonEntityTypeInitializerBlock.Expressions[^1];
 
-                    Debug.Assert(jsonEntityTypeVariable.Type == structuralType.ClrType);
+                    Debug.Assert(jsonStructuralTypeVariable.Type == structuralType.ClrType);
 
                     var finalBlockVariables = new List<ParameterExpression>
                     {
@@ -2024,7 +2043,7 @@ protected override Expression VisitSwitch(SwitchExpression switchExpression)
                     // - navigation fixups
                     // - entity instance variable that is returned as end result
                     var propertyAssignmentReplacer = new ValueBufferTryReadValueMethodsReplacer(
-                        jsonEntityTypeVariable, propertyAssignmentMap);
+                        jsonStructuralTypeVariable, propertyAssignmentMap);
 
                     if (body.Expressions[0] is BinaryExpression
                         {
@@ -2051,7 +2070,7 @@ protected override Expression VisitSwitch(SwitchExpression switchExpression)
                     // or for empty/null collections of a tracking queries.
                     ProcessFixup(queryStateManager ? trackingInnerFixupMap : innerFixupMap);
 
-                    finalBlockExpressions.Add(jsonEntityTypeVariable);
+                    finalBlockExpressions.Add(jsonStructuralTypeVariable);
 
                     return Block(
                         finalBlockVariables,
@@ -2063,18 +2082,35 @@ void ProcessFixup(IDictionary<string, LambdaExpression> fixupMap)
                         {
                             var navigationEntityParameter = _navigationVariableMap[fixup.Key];
 
-                            // we need to add null checks before we run fixup logic. For regular entities, whose fixup is done as part of the "Materialize*" method
-                            // the checks are done there (same will be done for the "optimized" scenario, where we populate properties directly rather than store in variables)
-                            // but in this case fixups are standalone, so the null safety must be added by us directly
-                            finalBlockExpressions.Add(
-                                IfThen(
-                                    NotEqual(
-                                        jsonEntityTypeVariable,
-                                        Constant(null, jsonEntityTypeVariable.Type)),
-                                    Invoke(
-                                        fixup.Value,
-                                        jsonEntityTypeVariable,
-                                        _navigationVariableMap[fixup.Key])));
+                            // Inject the fixup code for each property; we have this as a set of lambdas in the fixup map.
+                            // In the normal case, simply Invoke the lambda, passing it the structural type to be fixed up as a parameter.
+                            // This unfortunately doesn't work on value types (where a copy would be mutated), so for them,
+                            // we unwrap the lambda and integrate its body directly.
+                            // We should ideally do this for all cases (no need for the extra lambda Invoke), but there are some issues around us writing
+                            // to readonly fields.
+                            if (jsonStructuralTypeVariable.Type.IsValueType /*&& Nullable.GetUnderlyingType(jsonStructuralTypeVariable.Type) is null*/)
+                            {
+                                var fixupBody = ReplacingExpressionVisitor.Replace(
+                                    originals: [fixup.Value.Parameters[0], fixup.Value.Parameters[1]],
+                                    replacements: [jsonStructuralTypeVariable, _navigationVariableMap[fixup.Key]],
+                                    fixup.Value.Body);
+
+                                finalBlockExpressions.Add(fixupBody);
+                            }
+                            else
+                            {
+                                // If the structural type being fixed up is nullable, then we need to add null checks before we run fixup logic.
+                                // For regular entities, whose fixup is done as part of the "Materialize*" method, the checks are done there
+                                // (the same will be done for the "optimized" scenario, where we populate properties directly rather than store in variables).
+                                // But in this case fixups are standalone, so the null safety must be added here.
+                                finalBlockExpressions.Add(
+                                    IfThen(
+                                        NotEqual(jsonStructuralTypeVariable, Constant(null, jsonStructuralTypeVariable.Type)),
+                                        Invoke(
+                                            fixup.Value,
+                                            jsonStructuralTypeVariable,
+                                            _navigationVariableMap[fixup.Key])));
+                            }
                         }
                     }
                 }
@@ -2756,7 +2792,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                 expressions.Add(
                     relationship.IsCollection
                         ? AddToCollectionRelationship(entityParameter, relatedEntityParameter, relationship)
-                        : AssignReferenceRelationship(entityParameter, relatedEntityParameter, relationship));
+                        : AssignStructuralProperty(entityParameter, relatedEntityParameter, relationship));
             }
 
             if (inverseNavigation != null
@@ -2765,26 +2801,26 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                 expressions.Add(
                     inverseNavigation.IsCollection
                         ? AddToCollectionRelationship(relatedEntityParameter, entityParameter, inverseNavigation)
-                        : AssignReferenceRelationship(relatedEntityParameter, entityParameter, inverseNavigation));
+                        : AssignStructuralProperty(relatedEntityParameter, entityParameter, inverseNavigation));
             }
 
             return Lambda(Block(typeof(void), expressions), entityParameter, relatedEntityParameter);
         }
 
         private static LambdaExpression GenerateReferenceFixupForJson(
-            Type entityType,
-            Type relatedEntityType,
+            Type clrType,
+            Type relatedClrType,
             IPropertyBase relationship,
             INavigationBase? inverseNavigation)
         {
-            var entityParameter = Parameter(entityType);
-            var relatedEntityParameter = Parameter(relatedEntityType);
+            var entityParameter = Parameter(clrType);
+            var relatedEntityParameter = Parameter(relatedClrType);
             var expressions = new List<Expression>();
 
             if (!relationship.IsShadowProperty())
             {
                 expressions.Add(
-                    AssignReferenceRelationship(
+                    AssignStructuralProperty(
                         entityParameter,
                         relatedEntityParameter,
                         relationship));
@@ -2794,7 +2830,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
                 && !inverseNavigation.IsShadowProperty())
             {
                 expressions.Add(
-                    AssignReferenceRelationship(
+                    AssignStructuralProperty(
                         relatedEntityParameter,
                         entityParameter,
                         inverseNavigation));
@@ -2821,11 +2857,21 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
             }
         }
 
-        private static Expression AssignReferenceRelationship(
-            ParameterExpression entity,
-            ParameterExpression relatedEntity,
-            IPropertyBase relationship)
-            => entity.MakeMemberAccess(relationship.GetMemberInfo(forMaterialization: true, forSet: true)).Assign(relatedEntity);
+        private static Expression AssignStructuralProperty(
+            ParameterExpression structuralType,
+            ParameterExpression relatedStructuralType,
+            IPropertyBase structuralProperty)
+        {
+            var setter = structuralProperty.GetMemberInfo(forMaterialization: true, forSet: true);
+
+            // If we're assigning a value complex type to a nullable complex property, add an upcast for typing
+            var assignee = structuralProperty.ClrType.IsNullableValueType()
+                && structuralProperty.ClrType.UnwrapNullableType() == relatedStructuralType.Type
+                ? Convert(relatedStructuralType, structuralProperty.ClrType)
+                : (Expression)relatedStructuralType;
+
+            return structuralType.MakeMemberAccess(setter).Assign(assignee);
+        }
 
         private Expression GetOrCreateCollectionObjectLambda(Type entityType, IPropertyBase relationship)
         {
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index c09bf1a72f..237c7a6b94 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -2885,14 +2885,14 @@ static TableExpressionBase FindRootTableExpressionForColumn(SelectExpression sel
                     complexType.GetJsonPropertyName()
                     ?? throw new UnreachableException($"No JSON property name for complex property {complexProperty.Name}"),
                     tableAlias,
-                    complexProperty.ClrType,
+                    complexProperty.ClrType.UnwrapNullableType(),
                     typeMapping: containerColumn.StoreTypeMapping,
                     isComplexTypeNullable)
                 : new ColumnExpression(
                     containerColumn.Name,
                     tableAlias,
                     containerColumn,
-                    complexProperty.ClrType,
+                    complexProperty.ClrType.UnwrapNullableType(),
                     containerColumn.StoreTypeMapping,
                     isComplexTypeNullable);
 
diff --git a/src/EFCore/Metadata/Internal/ClrCollectionAccessor.cs b/src/EFCore/Metadata/Internal/ClrCollectionAccessor.cs
index 3aeae04a8b..40ca6a48b2 100644
--- a/src/EFCore/Metadata/Internal/ClrCollectionAccessor.cs
+++ b/src/EFCore/Metadata/Internal/ClrCollectionAccessor.cs
@@ -11,17 +11,16 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class ClrCollectionAccessor<TEntity, TCollection, TElement> : IClrCollectionAccessor
-    where TEntity : class
+public class ClrCollectionAccessor<TStructural, TCollection, TElement> : IClrCollectionAccessor
     where TCollection : class, IEnumerable<TElement>
     where TElement : class
 {
     private readonly string _propertyName;
     private readonly bool _shadow;
-    private readonly Func<TEntity, TCollection>? _getCollection;
-    private readonly Action<TEntity, TCollection>? _setCollection;
-    private readonly Action<TEntity, TCollection>? _setCollectionForMaterialization;
-    private readonly Func<TEntity, Action<TEntity, TCollection>, TCollection>? _createAndSetCollection;
+    private readonly Func<TStructural, TCollection>? _getCollection;
+    private readonly Action<TStructural, TCollection>? _setCollection;
+    private readonly Action<TStructural, TCollection>? _setCollectionForMaterialization;
+    private readonly Func<TStructural, Action<TStructural, TCollection>, TCollection>? _createAndSetCollection;
     private readonly Func<TCollection>? _createCollection;
 
     /// <summary>
@@ -42,10 +41,10 @@ public virtual Type CollectionType
     public ClrCollectionAccessor(
         string propertyName,
         bool shadow,
-        Func<TEntity, TCollection>? getCollection,
-        Action<TEntity, TCollection>? setCollection,
-        Action<TEntity, TCollection>? setCollectionForMaterialization,
-        Func<TEntity, Action<TEntity, TCollection>, TCollection>? createAndSetCollection,
+        Func<TStructural, TCollection>? getCollection,
+        Action<TStructural, TCollection>? setCollection,
+        Action<TStructural, TCollection>? setCollectionForMaterialization,
+        Func<TStructural, Action<TStructural, TCollection>, TCollection>? createAndSetCollection,
         Func<TCollection>? createCollection)
     {
         _propertyName = propertyName;
@@ -96,7 +95,7 @@ public virtual object Create()
         {
             throw new InvalidOperationException(
                 CoreStrings.NavigationCannotCreateType(
-                    _propertyName, typeof(TEntity).ShortDisplayName(), typeof(TCollection).ShortDisplayName()));
+                    _propertyName, typeof(TStructural).ShortDisplayName(), typeof(TCollection).ShortDisplayName()));
         }
 
         return _createCollection();
@@ -122,17 +121,17 @@ private ICollection<TElement> GetOrCreateCollection(object instance, bool forMat
 
             if (setCollection == null)
             {
-                throw new InvalidOperationException(CoreStrings.NavigationNoSetter(_propertyName, typeof(TEntity).ShortDisplayName()));
+                throw new InvalidOperationException(CoreStrings.NavigationNoSetter(_propertyName, typeof(TStructural).ShortDisplayName()));
             }
 
             if (_createAndSetCollection == null)
             {
                 throw new InvalidOperationException(
                     CoreStrings.NavigationCannotCreateType(
-                        _propertyName, typeof(TEntity).ShortDisplayName(), typeof(TCollection).ShortDisplayName()));
+                        _propertyName, typeof(TStructural).ShortDisplayName(), typeof(TCollection).ShortDisplayName()));
             }
 
-            collection = (ICollection<TElement>)_createAndSetCollection((TEntity)instance, setCollection);
+            collection = (ICollection<TElement>)_createAndSetCollection((TStructural)instance, setCollection);
         }
 
         return collection;
@@ -147,7 +146,7 @@ private ICollection<TElement> GetOrCreateCollection(object instance, bool forMat
             return (ICollection<TElement>?)_createCollection?.Invoke();
         }
 
-        var enumerable = _getCollection!((TEntity)instance);
+        var enumerable = _getCollection!((TStructural)instance);
         var collection = enumerable as ICollection<TElement>;
 
         if (enumerable != null
@@ -156,7 +155,7 @@ private ICollection<TElement> GetOrCreateCollection(object instance, bool forMat
             throw new InvalidOperationException(
                 CoreStrings.NavigationBadType(
                     _propertyName,
-                    typeof(TEntity).ShortDisplayName(),
+                    typeof(TStructural).ShortDisplayName(),
                     enumerable.GetType().ShortDisplayName(),
                     typeof(TElement).ShortDisplayName()));
         }
@@ -171,7 +170,7 @@ private ICollection<TElement> GetOrCreateCollection(object instance, bool forMat
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual bool Contains(object entity, object value)
-        => Contains(GetCollection((TEntity)entity), value);
+        => Contains(GetCollection((TStructural)entity), value);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -189,7 +188,7 @@ public virtual bool ContainsStandalone(object collection, object value)
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual bool Remove(object entity, object value)
-        => RemoveStandalone(GetCollection((TEntity)entity), value);
+        => RemoveStandalone(GetCollection((TStructural)entity), value);
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore/Metadata/Internal/ClrCollectionAccessorFactory.cs b/src/EFCore/Metadata/Internal/ClrCollectionAccessorFactory.cs
index 5a56de2633..d162e49a94 100644
--- a/src/EFCore/Metadata/Internal/ClrCollectionAccessorFactory.cs
+++ b/src/EFCore/Metadata/Internal/ClrCollectionAccessorFactory.cs
@@ -109,12 +109,11 @@ private ClrCollectionAccessorFactory()
     }
 
     [UsedImplicitly]
-    private static IClrCollectionAccessor CreateGeneric<TEntity, TCollection, TElement>(IPropertyBase relationship)
-        where TEntity : class
+    private static IClrCollectionAccessor CreateGeneric<TStructural, TCollection, TElement>(IPropertyBase relationship)
         where TCollection : class, IEnumerable<TElement>
         where TElement : class
     {
-        CreateExpressions<TEntity, TCollection, TElement>(
+        CreateExpressions<TStructural, TCollection, TElement>(
             relationship,
             out var getCollection,
             out var setCollection,
@@ -122,7 +121,7 @@ private ClrCollectionAccessorFactory()
             out var createAndSetCollection,
             out var createCollection);
 
-        return new ClrCollectionAccessor<TEntity, TCollection, TElement>(
+        return new ClrCollectionAccessor<TStructural, TCollection, TElement>(
             relationship.Name,
             relationship.IsShadowProperty(),
             getCollection?.Compile(),
@@ -180,14 +179,13 @@ private ClrCollectionAccessorFactory()
         = typeof(ClrCollectionAccessorFactory).GetMethod(nameof(CreateExpressions), BindingFlags.Static | BindingFlags.NonPublic)!;
 
     [UsedImplicitly]
-    private static void CreateExpressions<TEntity, TCollection, TElement>(
+    private static void CreateExpressions<TStructural, TCollection, TElement>(
         IPropertyBase relationship,
-        out Expression<Func<TEntity, TCollection>>? getCollection,
-        out Expression<Action<TEntity, TCollection>>? setCollection,
-        out Expression<Action<TEntity, TCollection>>? setCollectionForMaterialization,
-        out Expression<Func<TEntity, Action<TEntity, TCollection>, TCollection>>? createAndSetCollection,
+        out Expression<Func<TStructural, TCollection>>? getCollection,
+        out Expression<Action<TStructural, TCollection>>? setCollection,
+        out Expression<Action<TStructural, TCollection>>? setCollectionForMaterialization,
+        out Expression<Func<TStructural, Action<TStructural, TCollection>, TCollection>>? createAndSetCollection,
         out Expression<Func<TCollection>>? createCollection)
-        where TEntity : class
         where TCollection : class, IEnumerable<TElement>
         where TElement : class
     {
@@ -197,7 +195,7 @@ private ClrCollectionAccessorFactory()
         createAndSetCollection = null;
         createCollection = null;
 
-        var entityParameter = Expression.Parameter(typeof(TEntity), "entity");
+        var entityParameter = Expression.Parameter(typeof(TStructural), "entity");
         var valueParameter = Expression.Parameter(typeof(TCollection), "collection");
 
         if (!relationship.IsShadowProperty())
@@ -211,7 +209,7 @@ private ClrCollectionAccessorFactory()
                 memberAccessForRead = Expression.Convert(memberAccessForRead, typeof(TCollection));
             }
 
-            getCollection = Expression.Lambda<Func<TEntity, TCollection>>(
+            getCollection = Expression.Lambda<Func<TStructural, TCollection>>(
                 memberAccessForRead,
                 entityParameter);
 
@@ -227,7 +225,7 @@ private ClrCollectionAccessorFactory()
         }
 
         var concreteType = CollectionTypeFactory.Instance.TryFindTypeToInstantiate(
-            typeof(TEntity),
+            typeof(TStructural),
             typeof(TCollection),
             relationship.DeclaringType.Model[CoreAnnotationNames.FullChangeTrackingNotificationsRequired] != null);
         if (concreteType != null)
@@ -236,18 +234,18 @@ private ClrCollectionAccessorFactory()
             if (setCollection != null
                 || setCollectionForMaterialization != null)
             {
-                var setterParameter = Expression.Parameter(typeof(Action<TEntity, TCollection>), "setter");
+                var setterParameter = Expression.Parameter(typeof(Action<TStructural, TCollection>), "setter");
 
                 var createAndSetCollectionMethod = isHashSet
                     ? CreateAndSetHashSetMethod
-                        .MakeGenericMethod(typeof(TEntity), typeof(TCollection), typeof(TElement))
+                        .MakeGenericMethod(typeof(TStructural), typeof(TCollection), typeof(TElement))
                     : IsObservableHashSet(concreteType)
                         ? CreateAndSetObservableHashSetMethod
-                            .MakeGenericMethod(typeof(TEntity), typeof(TCollection), typeof(TElement))
+                            .MakeGenericMethod(typeof(TStructural), typeof(TCollection), typeof(TElement))
                         : CreateAndSetMethod
-                            .MakeGenericMethod(typeof(TEntity), typeof(TCollection), concreteType);
+                            .MakeGenericMethod(typeof(TStructural), typeof(TCollection), concreteType);
 
-                createAndSetCollection = Expression.Lambda<Func<TEntity, Action<TEntity, TCollection>, TCollection>>(
+                createAndSetCollection = Expression.Lambda<Func<TStructural, Action<TStructural, TCollection>, TCollection>>(
                     Expression.Call(createAndSetCollectionMethod, entityParameter, setterParameter),
                     entityParameter,
                     setterParameter);
@@ -260,11 +258,11 @@ private ClrCollectionAccessorFactory()
                     : Expression.Lambda<Func<TCollection>>(Expression.New(concreteType));
         }
 
-        static Expression<Action<TEntity, TCollection>> CreateSetterDelegate(
+        static Expression<Action<TStructural, TCollection>> CreateSetterDelegate(
             ParameterExpression parameterExpression,
             MemberInfo memberInfo,
             ParameterExpression valueParameter1)
-            => Expression.Lambda<Action<TEntity, TCollection>>(
+            => Expression.Lambda<Action<TStructural, TCollection>>(
                 Expression.MakeMemberAccess(
                     parameterExpression,
                     memberInfo).Assign(
@@ -298,10 +296,9 @@ private static bool IsObservableHashSet(Type type)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public static TCollection CreateAndSet<TEntity, TCollection, TConcreteCollection>(
-        TEntity entity,
-        Action<TEntity, TCollection> setterDelegate)
-        where TEntity : class
+    public static TCollection CreateAndSet<TStructural, TCollection, TConcreteCollection>(
+        TStructural entity,
+        Action<TStructural, TCollection> setterDelegate)
         where TCollection : class
         where TConcreteCollection : TCollection, new()
     {
@@ -316,10 +313,9 @@ private static bool IsObservableHashSet(Type type)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public static TCollection CreateAndSetHashSet<TEntity, TCollection, TElement>(
-        TEntity entity,
-        Action<TEntity, TCollection> setterDelegate)
-        where TEntity : class
+    public static TCollection CreateAndSetHashSet<TStructural, TCollection, TElement>(
+        TStructural entity,
+        Action<TStructural, TCollection> setterDelegate)
         where TCollection : class
         where TElement : class
     {
@@ -334,10 +330,9 @@ private static bool IsObservableHashSet(Type type)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public static TCollection CreateAndSetObservableHashSet<TEntity, TCollection, TElement>(
-        TEntity entity,
-        Action<TEntity, TCollection> setterDelegate)
-        where TEntity : class
+    public static TCollection CreateAndSetObservableHashSet<TStructural, TCollection, TElement>(
+        TStructural entity,
+        Action<TStructural, TCollection> setterDelegate)
         where TCollection : class
         where TElement : class
     {
diff --git a/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexJson/ComplexJsonRelationalFixtureBase.cs b/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexJson/ComplexJsonRelationalFixtureBase.cs
index e73bb0a06c..e232c354de 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexJson/ComplexJsonRelationalFixtureBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexJson/ComplexJsonRelationalFixtureBase.cs
@@ -20,6 +20,21 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
             b.ComplexProperty(e => e.OptionalRelated, orb => orb.ToJson());
             b.ComplexCollection(e => e.RelatedCollection, rcb => rcb.ToJson());
         });
+
+        modelBuilder.Entity<ValueRootEntity>(b =>
+        {
+            b.ComplexProperty(e => e.RequiredRelated, rrb => rrb.ToJson());
+
+            b.ComplexProperty(e => e.OptionalRelated, orb =>
+            {
+                orb.ToJson();
+
+                // TODO: Without the following, we get an ambiguous property error
+                orb.ComplexProperty(r => r.OptionalNested).IsRequired(false);
+            });
+
+            b.ComplexCollection(e => e.RelatedCollection, rcb => rcb.ToJson());
+        });
     }
 
     public TestSqlLoggerFactory TestSqlLoggerFactory
diff --git a/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexTableSplitting/ComplexTableSplittingRelationalFixtureBase.cs b/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexTableSplitting/ComplexTableSplittingRelationalFixtureBase.cs
index 7de13bb4ec..cf20901ebb 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexTableSplitting/ComplexTableSplittingRelationalFixtureBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/Relationships/ComplexTableSplitting/ComplexTableSplittingRelationalFixtureBase.cs
@@ -24,27 +24,17 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
 
         modelBuilder.Entity<RootEntity>(b =>
         {
-            b.ComplexProperty(
-                e => e.RequiredRelated, rrb =>
-                {
-                    rrb.ComplexProperty(r => r.RequiredNested);
-                    rrb.ComplexProperty(r => r.OptionalNested);
-
-                    // Collections are not supported with table splitting, only JSON
-                    rrb.Ignore(r => r.NestedCollection);
-                });
-
-            b.ComplexProperty(
-                e => e.OptionalRelated, orb =>
-                {
-                    orb.ComplexProperty(o => o.RequiredNested);
-                    orb.ComplexProperty(o => o.OptionalNested);
-
-                    // Collections are not supported with table splitting, only JSON
-                    orb.Ignore(o => o.NestedCollection);
-                });
+            // Collections are not supported with table splitting, only JSON
+            b.ComplexProperty(e => e.RequiredRelated, rrb => rrb.Ignore(r => r.NestedCollection));
+            b.ComplexProperty(e => e.OptionalRelated, orb => orb.Ignore(o => o.NestedCollection));
+            b.Ignore(r => r.RelatedCollection);
+        });
 
+        modelBuilder.Entity<ValueRootEntity>(b =>
+        {
             // Collections are not supported with table splitting, only JSON
+            b.ComplexProperty(e => e.RequiredRelated, rrb => rrb.Ignore(r => r.NestedCollection));
+            b.ComplexProperty(e => e.OptionalRelated, orb => orb.Ignore(o => o.NestedCollection));
             b.Ignore(r => r.RelatedCollection);
         });
     }
diff --git a/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesFixtureBase.cs b/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesFixtureBase.cs
index f72d33ea72..e92ca50539 100644
--- a/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesFixtureBase.cs
+++ b/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesFixtureBase.cs
@@ -26,6 +26,34 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
             b.ComplexCollection(e => e.RelatedCollection, rcb
                 => rcb.ComplexProperty(r => r.OptionalNested).IsRequired(false));
         });
+
+        // Value types are only supported with complex types, so we add them to the model here.
+        modelBuilder.Entity<ValueRootEntity>(b =>
+        {
+            b.Property(x => x.Id).ValueGeneratedNever();
+
+            // Note that all collections below are reference type collections,
+            // as we don't yet support complex collections of value types, #31411
+            b.ComplexProperty(e => e.RequiredRelated);
+
+            b.ComplexProperty(e => e.OptionalRelated, orb =>
+            {
+                orb.IsRequired(false);
+                orb.ComplexProperty(r => r.OptionalNested).IsRequired(false);
+            });
+
+            b.ComplexCollection(e => e.RelatedCollection, rcb
+                => rcb.ComplexProperty(r => r.OptionalNested).IsRequired(false));
+        });
+    }
+
+    protected override async Task SeedAsync(PoolableDbContext context)
+    {
+        await base.SeedAsync(context);
+
+        context.Set<ValueRootEntity>().AddRange(Data.ValueRootEntities);
+
+        await context.SaveChangesAsync();
     }
 
     // Derived fixtures ignore some complex properties that are mapped in this one
diff --git a/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesProjectionTestBase.cs b/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesProjectionTestBase.cs
index c68684a4e5..dd6bc7cb29 100644
--- a/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesProjectionTestBase.cs
+++ b/test/EFCore.Specification.Tests/Query/Relationships/ComplexProperties/ComplexPropertiesProjectionTestBase.cs
@@ -5,4 +5,16 @@ namespace Microsoft.EntityFrameworkCore.Query.Relationships.ComplexProperties;
 
 public abstract class ComplexPropertiesProjectionTestBase<TFixture>(TFixture fixture)
     : RelationshipsProjectionTestBase<TFixture>(fixture)
-    where TFixture : ComplexPropertiesFixtureBase, new();
+    where TFixture : ComplexPropertiesFixtureBase, new()
+{
+    #region Value types
+
+    [ConditionalTheory]
+    [MemberData(nameof(TrackingData))]
+    public virtual Task Select_root_with_value_types(QueryTrackingBehavior queryTrackingBehavior)
+        => AssertQuery(
+            ss => ss.Set<ValueRootEntity>(),
+            queryTrackingBehavior: queryTrackingBehavior);
+
+    #endregion Value types
+}
diff --git a/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsData.cs b/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsData.cs
index abda0c886b..2fd5c904e6 100644
--- a/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsData.cs
+++ b/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsData.cs
@@ -11,6 +11,8 @@ public RelationshipsData()
         RelatedTypes = [];
         NestedTypes = [];
         RootReferencingEntities = CreateRootReferencingEntities(RootEntities);
+
+        ValueRootEntities = CreateValueRootEntities(RootEntities);
     }
 
     public List<RootEntity> RootEntities { get; }
@@ -21,7 +23,9 @@ public RelationshipsData()
 
     public List<RootReferencingEntity> RootReferencingEntities { get; }
 
-    public static List<RootEntity> CreateRootEntities()
+    public List<ValueRootEntity> ValueRootEntities { get; }
+
+    private static List<RootEntity> CreateRootEntities()
     {
         var id = 1;
 
@@ -314,7 +318,7 @@ RootEntity CreateRootEntity(int id, string? description, Action<RootEntity>? cus
         }
     }
 
-    public static List<RootReferencingEntity> CreateRootReferencingEntities(IEnumerable<RootEntity> rootEntities)
+    private static List<RootReferencingEntity> CreateRootReferencingEntities(IEnumerable<RootEntity> rootEntities)
     {
         var rootReferencingEntities = new List<RootReferencingEntity>();
 
@@ -331,6 +335,9 @@ public static List<RootReferencingEntity> CreateRootReferencingEntities(IEnumera
         return rootReferencingEntities;
     }
 
+    private static List<ValueRootEntity> CreateValueRootEntities(List<RootEntity> rootEntities)
+        => rootEntities.Select(ValueRootEntity.FromRootEntity).ToList();
+
     public IQueryable<TEntity> Set<TEntity>()
         where TEntity : class
         => typeof(TEntity) switch
@@ -340,6 +347,8 @@ public IQueryable<TEntity> Set<TEntity>()
             var t when t == typeof(NestedType) => (IQueryable<TEntity>)NestedTypes.AsQueryable(),
             var t when t == typeof(RootReferencingEntity) => (IQueryable<TEntity>)RootReferencingEntities.AsQueryable(),
 
+            var t when t == typeof(ValueRootEntity) => (IQueryable<TEntity>)ValueRootEntities.AsQueryable(),
+
             _ => throw new InvalidOperationException("Invalid entity type: " + typeof(TEntity))
         };
 }
diff --git a/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsModelValueTypes.cs b/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsModelValueTypes.cs
new file mode 100644
index 0000000000..0f1dc31b8e
--- /dev/null
+++ b/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsModelValueTypes.cs
@@ -0,0 +1,120 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System.Diagnostics.CodeAnalysis;
+
+namespace Microsoft.EntityFrameworkCore.Query.Relationships;
+
+/// <summary>
+/// Variant of <see cref="RootEntity" /> containing value type complex types.
+/// </summary>
+public class ValueRootEntity
+{
+    public int Id { get; set; }
+    public required string Name { get; set; }
+
+    public required ValueRelatedType RequiredRelated { get; set; }
+    public ValueRelatedType? OptionalRelated { get; set; }
+
+    // TODO: We don't yet support complex collections of value types, #31411;
+    // For now map a reference type collection instead.
+    public List<RelatedType> RelatedCollection { get; set; } = null!;
+
+    public override string ToString() => Name;
+
+    public static ValueRootEntity FromRootEntity(RootEntity rootEntity)
+        => new()
+        {
+            Id = rootEntity.Id,
+            Name = rootEntity.Name,
+
+            RequiredRelated = ValueRelatedType.FromRelatedType(rootEntity.RequiredRelated).Value,
+            OptionalRelated = ValueRelatedType.FromRelatedType(rootEntity.OptionalRelated),
+
+            // TODO: Collection of nullable related types
+            RelatedCollection = rootEntity.RelatedCollection.Select(r => r.DeepClone()).ToList()
+        };
+}
+
+/// <summary>
+/// Variant of <see cref="RelatedType" /> as a value type.
+/// </summary>
+public struct ValueRelatedType : IEquatable<ValueRelatedType>
+{
+    public ValueRelatedType()
+    {
+    }
+
+    public int Id { get; set; }
+    public required string Name { get; set; }
+
+    public int Int { get; set; }
+    public string String { get; set; } = null!;
+
+    public required ValueNestedType RequiredNested { get; set; }
+    public ValueNestedType? OptionalNested { get; set; }
+
+    // TODO: Collection of nullable nested types
+    // TODO: We don't yet support complex collections of value types, #31411;
+    // For now map a reference type collection instead.
+    public List<NestedType> NestedCollection { get; set; } = null!;
+
+    public readonly bool Equals(ValueRelatedType other)
+        => Id == other.Id
+           && Name == other.Name
+           && Int == other.Int
+           && String == other.String
+           && RequiredNested.Equals(other.RequiredNested)
+           && (OptionalNested is null && other.OptionalNested is null || OptionalNested?.Equals(other.RequiredNested) == true)
+           && NestedCollection.SequenceEqual(other.NestedCollection);
+
+    [return: NotNullIfNotNull(nameof(relatedType))]
+    public static ValueRelatedType? FromRelatedType(RelatedType? relatedType)
+        => relatedType is null ? null : new()
+        {
+            Id = relatedType.Id,
+            Name = relatedType.Name,
+            Int = relatedType.Int,
+            String = relatedType.String,
+
+            RequiredNested = ValueNestedType.FromNestedType(relatedType.RequiredNested).Value,
+            OptionalNested = ValueNestedType.FromNestedType(relatedType.OptionalNested),
+            NestedCollection = relatedType.NestedCollection.Select((n) => n.DeepClone()).ToList()
+        };
+
+    public override string ToString() => Name;
+}
+
+/// <summary>
+/// Variant of <see cref="ValueNestedType" /> as a value type.
+/// </summary>
+public struct ValueNestedType : IEquatable<ValueNestedType>
+{
+    public ValueNestedType()
+    {
+    }
+
+    public int Id { get; set; }
+    public required string Name { get; set; }
+
+    public int Int { get; set; }
+    public string String { get; set; } = null!;
+
+    public readonly bool Equals(ValueNestedType other)
+        => Id == other.Id
+           && Name == other.Name
+           && Int == other.Int
+           && String == other.String;
+
+    [return: NotNullIfNotNull(nameof(nestedType))]
+    public static ValueNestedType? FromNestedType(NestedType? nestedType)
+        => nestedType is null ? null : new()
+        {
+            Id = nestedType.Id,
+            Name = nestedType.Name,
+            Int = nestedType.Int,
+            String = nestedType.String
+        };
+
+    public override string ToString() => Name;
+}
diff --git a/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsQueryFixtureBase.cs b/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsQueryFixtureBase.cs
index 70cd74521a..ba939b24c6 100644
--- a/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsQueryFixtureBase.cs
+++ b/test/EFCore.Specification.Tests/Query/Relationships/RelationshipsQueryFixtureBase.cs
@@ -8,18 +8,22 @@ public abstract class RelationshipsQueryFixtureBase : SharedStoreFixtureBase<Poo
     public virtual bool AreCollectionsOrdered
         => true;
 
-    private readonly RelationshipsData _data;
+    public RelationshipsData Data { get; private set; }
 
     public RelationshipsQueryFixtureBase()
     {
-        _data = CreateData();
+        Data = CreateData();
 
         EntityAsserters = new Dictionary<Type, Action<object?, object?>>
         {
             [typeof(RootEntity)] = (e, a) => NullSafeAssert<RootEntity>(e, a, AssertRootEntity),
             [typeof(RelatedType)] = (e, a) => NullSafeAssert<RelatedType>(e, a, AssertRelatedType),
             [typeof(NestedType)] = (e, a) => NullSafeAssert<NestedType>(e, a, AssertNestedType),
-            [typeof(RootReferencingEntity)] = (e, a) => NullSafeAssert<RootReferencingEntity>(e, a, AssertPreRootEntity)
+            [typeof(RootReferencingEntity)] = (e, a) => NullSafeAssert<RootReferencingEntity>(e, a, AssertPreRootEntity),
+
+            [typeof(ValueRootEntity)] = (e, a) => NullSafeAssert<ValueRootEntity>(e, a, AssertValueRootEntity),
+            [typeof(ValueRelatedType)] = (e, a) => NullSafeAssert<ValueRelatedType>(e, a, AssertValueRelatedType),
+            [typeof(ValueNestedType)] = (e, a) => NullSafeAssert<ValueNestedType>(e, a, AssertValueNestedType),
         }.ToDictionary(e => e.Key, e => (object)e.Value);
     }
 
@@ -27,17 +31,17 @@ public Func<DbContext> GetContextCreator()
         => CreateContext;
 
     public virtual ISetSource GetExpectedData()
-        => _data;
+        => Data;
 
     protected virtual RelationshipsData CreateData()
         => new();
 
     protected override Task SeedAsync(PoolableDbContext context)
     {
-        context.Set<RootEntity>().AddRange(_data.RootEntities);
+        context.Set<RootEntity>().AddRange(Data.RootEntities);
         if (context.Model.FindEntityType(typeof(RootReferencingEntity)) is not null)
         {
-            context.Set<RootReferencingEntity>().AddRange(_data.RootReferencingEntities);
+            context.Set<RootReferencingEntity>().AddRange(Data.RootReferencingEntities);
         }
 
         return context.SaveChangesAsync();
@@ -61,7 +65,11 @@ protected override void OnModelCreating(ModelBuilder modelBuilder, DbContext con
         { typeof(RootEntity), e => ((RootEntity?)e)?.Id },
         { typeof(RelatedType), e => ((RelatedType?)e)?.Id },
         { typeof(NestedType), e => ((NestedType?)e)?.Id },
-        { typeof(RootReferencingEntity), e => ((RootReferencingEntity?)e)?.Id }
+        { typeof(RootReferencingEntity), e => ((RootReferencingEntity?)e)?.Id },
+
+        { typeof(ValueRootEntity), e => ((ValueRootEntity?)e)?.Id },
+        { typeof(ValueRelatedType), e => ((ValueRelatedType?)e)?.Id },
+        { typeof(ValueNestedType), e => ((ValueNestedType?)e)?.Id },
     }.ToDictionary(e => e.Key, e => (object)e.Value);
 
     public virtual IReadOnlyDictionary<Type, object> EntityAsserters { get; }
@@ -139,6 +147,40 @@ private void AssertPreRootEntity(RootReferencingEntity e, RootReferencingEntity
         NullSafeAssert<RootEntity>(e.Root, a.Root, AssertRootEntity);
     }
 
+    private void AssertValueRootEntity(ValueRootEntity e, ValueRootEntity a)
+    {
+        Assert.Equal(e.Id, a.Id);
+        Assert.Equal(e.Name, a.Name);
+
+        AssertValueRelatedType(e.RequiredRelated, a.RequiredRelated);
+        NullSafeAssert<ValueRelatedType>(e.OptionalRelated, a.OptionalRelated, AssertValueRelatedType);
+
+        // TODO: Complete for collection, mind ordering (how is this done elsewhere?)
+    }
+
+    private void AssertValueRelatedType(ValueRelatedType e, ValueRelatedType a)
+    {
+        Assert.Equal(e.Id, a.Id);
+        Assert.Equal(e.Name, a.Name);
+
+        Assert.Equal(e.Int, a.Int);
+        Assert.Equal(e.String, a.String);
+
+        AssertValueNestedType(e.RequiredNested, a.RequiredNested);
+        NullSafeAssert<ValueNestedType>(e.OptionalNested, a.OptionalNested, AssertValueNestedType);
+
+        // TODO: Complete for collection, mind ordering (how is this done elsewhere?)
+    }
+
+    private void AssertValueNestedType(ValueNestedType e, ValueNestedType a)
+    {
+        Assert.Equal(e.Id, a.Id);
+        Assert.Equal(e.Name, a.Name);
+
+        Assert.Equal(e.Int, a.Int);
+        Assert.Equal(e.String, a.String);
+    }
+
     private void NullSafeAssert<T>(object? e, object? a, Action<T, T> assertAction)
     {
         if (e is T ee && a is T aa)
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs
index 791075c9dc..98414e0abf 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/Relationships/ComplexJson/ComplexJsonProjectionSqlServerTest.cs
@@ -336,6 +336,21 @@ public override async Task Select_subquery_optional_related_FirstOrDefault(Query
 
     #endregion Subquery
 
+    #region Value types
+
+    public override async Task Select_root_with_value_types(QueryTrackingBehavior queryTrackingBehavior)
+    {
+        await base.Select_root_with_value_types(queryTrackingBehavior);
+
+        AssertSql(
+            """
+SELECT [v].[Id], [v].[Name], [v].[OptionalRelated], [v].[RelatedCollection], [v].[RequiredRelated]
+FROM [ValueRootEntity] AS [v]
+""");
+    }
+
+    #endregion Value types
+
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
