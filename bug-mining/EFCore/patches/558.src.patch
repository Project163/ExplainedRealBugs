diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
index 147b90ffcf..60b910af18 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.cs
@@ -2743,12 +2743,22 @@ Expression valueExpression
                 // return incorrect mapping. So for that case we would prefer to incorporate the FromProvider lambda, like we used to do before AOT
                 // and only resort to unreliable TypeMappingSource lookup, if the converter expression captures "forbidden" constant
                 // see issue #33517 for more details
-                var requiresLiftableConstant =
-                    new ConstantValidator().RequiresLiftableConstant(converter.ConvertFromProviderExpression.Body);
-                if (property != null || requiresLiftableConstant)
+                // UPDATE: instead of guessing the type mapping in case where we don't have IProperty and converter uses non-literal constant,
+                // we just revert to the pre-AOT behavior, i.e. we still use converter.ConvertFromProviderExpression
+                // this will not work for precompiled query (which realistically was already broken for this scenario - type mapping we "guess"
+                // is pretty much always wrong), but regular case (not pre-compiled) will continue to work. 
+                if (property != null)
                 {
-                    var typeMappingExpression = CreateTypeMappingExpression(
-                        property, type, typeMapping, _parentVisitor.Dependencies.LiftableConstantFactory);
+                    var typeMappingExpression = Call(
+                        Convert(
+                            _parentVisitor.Dependencies.LiftableConstantFactory.CreateLiftableConstant(
+                                property,
+                                LiftableConstantExpressionHelpers.BuildMemberAccessLambdaForProperty(property),
+                                property.Name + "Property",
+                                typeof(IPropertyBase)),
+                            typeof(IReadOnlyProperty)),
+                        PropertyGetTypeMappingMethod);
+
                     converterExpression = Property(typeMappingExpression, nameof(CoreTypeMapping.Converter));
 
                     var converterType = converter.GetType();
@@ -2887,69 +2897,6 @@ Expression valueExpression
             }
 
             return valueExpression;
-
-            static Expression CreateTypeMappingExpression(
-                IPropertyBase? property,
-                Type type,
-                RelationalTypeMapping typeMapping,
-                ILiftableConstantFactory liftableConstantFactory)
-            {
-                Expression typeMappingExpression;
-                if (property != null)
-                {
-                    typeMappingExpression = Call(
-                        Convert(
-                            liftableConstantFactory.CreateLiftableConstant(
-                                property,
-                                LiftableConstantExpressionHelpers.BuildMemberAccessLambdaForProperty(property),
-                                property.Name + "Property",
-                                typeof(IPropertyBase)),
-                            typeof(IReadOnlyProperty)),
-                        PropertyGetTypeMappingMethod);
-                }
-                else
-                {
-                    // NOTE: this is unreliable way to get type mapping. Only doing this as last resort, hoping to "guess" the right one
-                    Expression<Func<MaterializerLiftableConstantContext, Type, object>> resolverTemplate =
-                        (c, _) => (RelationalTypeMapping)c.Dependencies.TypeMappingSource.FindMapping(_, c.Dependencies.Model, null)!;
-
-                    var body = ReplacingExpressionVisitor.Replace(
-                        resolverTemplate.Parameters[1],
-                        Constant(type),
-                        resolverTemplate.Body);
-
-                    typeMappingExpression = liftableConstantFactory.CreateLiftableConstant(
-                        typeMapping,
-                        Lambda<Func<MaterializerLiftableConstantContext, object>>(body, resolverTemplate.Parameters[0]),
-                        "typeMapping",
-                        typeof(RelationalTypeMapping));
-                }
-
-                return typeMappingExpression;
-            }
-        }
-
-        private sealed class ConstantValidator : ExpressionVisitor
-        {
-            private bool _requiresLiftableConstant;
-
-            public bool RequiresLiftableConstant(Expression expression)
-            {
-                _requiresLiftableConstant = false;
-                Visit(expression);
-
-                return _requiresLiftableConstant;
-            }
-
-            protected override Expression VisitConstant(ConstantExpression constantExpression)
-            {
-                if (!_requiresLiftableConstant && !LiftableConstantExpressionHelpers.IsLiteral(constantExpression.Value))
-                {
-                    _requiresLiftableConstant = true;
-                }
-
-                return constantExpression;
-            }
         }
 
         private Expression CreateReadJsonPropertyValueExpression(
diff --git a/src/EFCore/Query/LiftableConstantProcessor.cs b/src/EFCore/Query/LiftableConstantProcessor.cs
index 5438841760..5e384638cd 100644
--- a/src/EFCore/Query/LiftableConstantProcessor.cs
+++ b/src/EFCore/Query/LiftableConstantProcessor.cs
@@ -256,11 +256,17 @@ protected override Expression VisitMember(MemberExpression memberExpression)
             ? memberExpression
             : base.VisitMember(memberExpression);
 
-    protected override Expression VisitConstant(ConstantExpression node)
-    {
-        _unsupportedConstantChecker.Check(node);
-        return node;
-    }
+    // issue #34760 - disabling the liftable constant verification because we sometimes are forced to
+    // use them (when type mapping has custom converter but we can't reliably get the correct type mapping
+    // when building the shaper) - if that converter uses a closure, we will embed it in the shaper
+    // we don't have a reasonalbe alternative currently
+    // Once #33517 is done, we should re-enable this check
+    //protected override Expression VisitConstant(ConstantExpression node)
+    //{
+    //    _unsupportedConstantChecker.Check(node);
+
+    //    return node;
+    //}
 #endif
 
     private sealed class UnsupportedConstantChecker(LiftableConstantProcessor liftableConstantProcessor) : ExpressionVisitor
diff --git a/test/EFCore.Relational.Specification.Tests/Query/AdHocPrecompiledQueryRelationalTestBase.cs b/test/EFCore.Relational.Specification.Tests/Query/AdHocPrecompiledQueryRelationalTestBase.cs
index e9980c5e6f..4b9ed3777f 100644
--- a/test/EFCore.Relational.Specification.Tests/Query/AdHocPrecompiledQueryRelationalTestBase.cs
+++ b/test/EFCore.Relational.Specification.Tests/Query/AdHocPrecompiledQueryRelationalTestBase.cs
@@ -217,6 +217,123 @@ private NonPublicEntity()
 // }
 // """);
 
+    [ConditionalFact]
+    public virtual async Task Projecting_property_requiring_converter_with_closure_is_not_supported()
+    {
+        var contextFactory = await InitializeAsync<PrecompiledContext34760>();
+        var options = contextFactory.GetOptions();
+
+        await Test(
+"""
+await using var context = new AdHocPrecompiledQueryRelationalTestBase.PrecompiledContext34760(dbContextOptions);
+var publishDates = await context.Books.Select(x => x.PublishDate).ToListAsync();
+""",
+            typeof(PrecompiledContext34760),
+            options,
+            precompilationErrorAsserter: errors
+                => Assert.StartsWith(
+                    "Encountered a constant of unsupported type 'MyDatetimeConverter'. Only primitive constant nodes are supported.",
+                    errors.Single().Exception.Message));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Projecting_expression_requiring_converter_without_closure_works()
+    {
+        var contextFactory = await InitializeAsync<PrecompiledContext34760>();
+        var options = contextFactory.GetOptions();
+
+        await Test(
+"""
+await using var context = new AdHocPrecompiledQueryRelationalTestBase.PrecompiledContext34760(dbContextOptions);
+var audiobookDates = await context.Books.Select(x => x.AudiobookDate).ToListAsync();
+""",
+            typeof(PrecompiledContext34760),
+            options);
+    }
+
+    [ConditionalFact]
+    public virtual async Task Projecting_entity_with_property_requiring_converter_with_closure_works()
+    {
+        var contextFactory = await InitializeAsync<PrecompiledContext34760>();
+        var options = contextFactory.GetOptions();
+
+        await Test(
+"""
+await using var context = new AdHocPrecompiledQueryRelationalTestBase.PrecompiledContext34760(dbContextOptions);
+var books = await context.Books.ToListAsync();
+""",
+            typeof(PrecompiledContext34760),
+            options);
+    }
+
+    public class PrecompiledContext34760(DbContextOptions options) : DbContext(options)
+    {
+        public DbSet<Book> Books { get; set; } = null!;
+
+        protected override void OnModelCreating(ModelBuilder modelBuilder)
+        {
+            modelBuilder.Entity<Book>().Property(e => e.Id).ValueGeneratedNever();
+            modelBuilder.Entity<Book>().Property(e => e.PublishDate).HasConversion(new MyDateTimeValueConverterWithClosure(new MyDatetimeConverter()));
+            modelBuilder.Entity<Book>().Property(e => e.AudiobookDate).HasConversion(new MyDateTimeValueConverterWithoutClosure());
+        }
+
+        public Task SeedAsync()
+        {
+            AddRange(
+                new Book
+                {
+                    Id = 1,
+                    Name = "The Blade Itself",
+                    PublishDate = new DateTime(2006, 5, 4, 11, 59, 59),
+                    AudiobookDate = new DateTime(2015, 9, 8, 23, 59, 59)
+                },
+                new Book
+                {
+                    Id = 2,
+                    Name = "Red Rising",
+                    PublishDate = new DateTime(2014, 1, 27, 23, 59, 59),
+                    AudiobookDate = new DateTime(2014, 1, 27, 23, 59, 59),
+                });
+
+            return SaveChangesAsync();
+        }
+
+        public class Book
+        {
+            public int Id { get; set; }
+            public string? Name { get; set; }
+
+            public virtual DateTime PublishDate { get; set; }
+            public virtual DateTime AudiobookDate { get; set; }
+        }
+
+        public class MyDateTimeValueConverterWithClosure : ValueConverter<DateTime, DateTime>
+        {
+            public MyDateTimeValueConverterWithClosure(MyDatetimeConverter myDatetimeConverter)
+                : base(
+                    x => myDatetimeConverter.Normalize(x),
+                    x => myDatetimeConverter.Normalize(x))
+            {
+            }
+        }
+
+        public class MyDateTimeValueConverterWithoutClosure : ValueConverter<DateTime, DateTime>
+        {
+            public MyDateTimeValueConverterWithoutClosure()
+                : base(
+                    x => new MyDatetimeConverter().Normalize(x),
+                    x => new MyDatetimeConverter().Normalize(x))
+            {
+            }
+        }
+
+        public class MyDatetimeConverter
+        {
+            public virtual DateTime Normalize(DateTime dateTime)
+                => dateTime.Date;
+        }
+    }
+
     protected TestSqlLoggerFactory TestSqlLoggerFactory
         => (TestSqlLoggerFactory)ListLoggerFactory;
 
diff --git a/test/EFCore.Specification.Tests/Query/AdHocAdvancedMappingsQueryTestBase.cs b/test/EFCore.Specification.Tests/Query/AdHocAdvancedMappingsQueryTestBase.cs
index c14b2cdecc..544517b0e1 100644
--- a/test/EFCore.Specification.Tests/Query/AdHocAdvancedMappingsQueryTestBase.cs
+++ b/test/EFCore.Specification.Tests/Query/AdHocAdvancedMappingsQueryTestBase.cs
@@ -692,4 +692,123 @@ public class Dog : Pet
     }
 
     #endregion
+
+    #region 34760
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Projecting_property_with_converter_with_closure(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context34760>(seed: c => c.SeedAsync());
+        using var context = contextFactory.CreateContext();
+
+        var query = context.Books.Select(x => x.PublishDate);
+
+        var result = await query.ToListAsync();
+        Assert.Equal(2, result.Count);
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Projecting_expression_with_converter_with_closure(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context34760>(seed: c => c.SeedAsync());
+        using var context = contextFactory.CreateContext();
+
+        var query = context.Books
+            .GroupBy(t => t.Id)
+            .Select(g => new
+            {
+                Day = g.Min(t => t.PublishDate)
+            });
+
+        var result = await query.ToListAsync();
+        Assert.Equal(2, result.Count);
+    }
+
+    [ConditionalTheory]
+    [MemberData(nameof(IsAsyncData))]
+    public virtual async Task Projecting_property_with_converter_without_closure(bool async)
+    {
+        var contextFactory = await InitializeAsync<Context34760>(seed: c => c.SeedAsync());
+        using var context = contextFactory.CreateContext();
+
+        var query = context.Books
+            .GroupBy(t => t.Id)
+            .Select(g => new
+            {
+                Day = g.Min(t => t.AudiobookDate)
+            });
+
+        var result = await query.ToListAsync();
+        Assert.Equal(2, result.Count);
+    }
+
+    protected class Context34760(DbContextOptions options) : DbContext(options)
+    {
+        public DbSet<Book> Books { get; set; }
+
+        protected override void OnModelCreating(ModelBuilder modelBuilder)
+        {
+            modelBuilder.Entity<Book>().Property(e => e.Id).ValueGeneratedNever();
+            modelBuilder.Entity<Book>().Property(e => e.PublishDate).HasConversion(new MyDateTimeValueConverterWithClosure(new MyDatetimeConverter()));
+            modelBuilder.Entity<Book>().Property(e => e.AudiobookDate).HasConversion(new MyDateTimeValueConverterWithoutClosure());
+        }
+
+        public Task SeedAsync()
+        {
+            AddRange(
+                new Book {
+                    Id = 1,
+                    Name = "The Blade Itself",
+                    PublishDate = new DateTime(2006, 5, 4, 11, 59, 59),
+                    AudiobookDate = new DateTime(2015, 9, 8, 23, 59, 59)
+                },
+                new Book {
+                    Id = 2,
+                    Name = "Red Rising",
+                    PublishDate = new DateTime(2014, 1, 27, 23, 59, 59),
+                    AudiobookDate = new DateTime(2014, 1, 27, 23, 59, 59),
+                });
+
+            return SaveChangesAsync();
+        }
+
+        public class Book
+        {
+            public int Id { get; set; }
+            public string Name { get; set; }
+
+            public virtual DateTime PublishDate { get; set; }
+            public virtual DateTime AudiobookDate { get; set; }
+        }
+
+        public class MyDateTimeValueConverterWithClosure : ValueConverter<DateTime, DateTime>
+        {
+            public MyDateTimeValueConverterWithClosure(MyDatetimeConverter myDatetimeConverter)
+                : base(
+                    x => myDatetimeConverter.Normalize(x),
+                    x => myDatetimeConverter.Normalize(x))
+            {
+            }
+        }
+
+        public class MyDateTimeValueConverterWithoutClosure : ValueConverter<DateTime, DateTime>
+        {
+            public MyDateTimeValueConverterWithoutClosure()
+                : base(
+                    x => new MyDatetimeConverter().Normalize(x),
+                    x => new MyDatetimeConverter().Normalize(x))
+            {
+            }
+        }
+
+        public class MyDatetimeConverter
+        {
+            public virtual DateTime Normalize(DateTime dateTime)
+                => dateTime.Date;
+        }
+    }
+
+    #endregion
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocAdvancedMappingsQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocAdvancedMappingsQuerySqlServerTest.cs
index 6f0bce9d4d..38d8464757 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocAdvancedMappingsQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocAdvancedMappingsQuerySqlServerTest.cs
@@ -305,6 +305,41 @@ public override async Task Projecting_one_of_two_similar_complex_types_picks_the
 ) AS [s]
 LEFT JOIN [As] AS [a] ON [s].[AId] = [a].[Id]
 ORDER BY [s].[Id]
+""");
+    }
+
+    public override async Task Projecting_property_with_converter_with_closure(bool async)
+    {
+        await base.Projecting_property_with_converter_with_closure(async);
+
+        AssertSql(
+"""
+SELECT [b].[PublishDate]
+FROM [Books] AS [b]
+""");
+    }
+
+    public override async Task Projecting_expression_with_converter_with_closure(bool async)
+    {
+        await base.Projecting_expression_with_converter_with_closure(async);
+
+        AssertSql(
+"""
+SELECT MIN([b].[PublishDate]) AS [Day]
+FROM [Books] AS [b]
+GROUP BY [b].[Id]
+""");
+    }
+
+    public override async Task Projecting_property_with_converter_without_closure(bool async)
+    {
+        await base.Projecting_property_with_converter_without_closure(async);
+
+        AssertSql(
+"""
+SELECT MIN([b].[AudiobookDate]) AS [Day]
+FROM [Books] AS [b]
+GROUP BY [b].[Id]
 """);
     }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocPrecompiledQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocPrecompiledQuerySqlServerTest.cs
index 2063c4bcd9..5b846108e5 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/AdHocPrecompiledQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/AdHocPrecompiledQuerySqlServerTest.cs
@@ -72,6 +72,35 @@ public override async Task Materialize_non_public()
 """);
     }
 
+    public override async Task Projecting_property_requiring_converter_with_closure_is_not_supported()
+    {
+        await base.Projecting_property_requiring_converter_with_closure_is_not_supported();
+
+        AssertSql();
+    }
+
+    public override async Task Projecting_expression_requiring_converter_without_closure_works()
+    {
+        await base.Projecting_expression_requiring_converter_without_closure_works();
+
+        AssertSql(
+"""
+SELECT [b].[AudiobookDate]
+FROM [Books] AS [b]
+""");
+    }
+
+    public override async Task Projecting_entity_with_property_requiring_converter_with_closure_works()
+    {
+        await base.Projecting_entity_with_property_requiring_converter_with_closure_works();
+
+        AssertSql(
+"""
+SELECT [b].[Id], [b].[AudiobookDate], [b].[Name], [b].[PublishDate]
+FROM [Books] AS [b]
+""");
+    }
+
     [ConditionalFact]
     public virtual void Check_all_tests_overridden()
         => TestHelpers.AssertAllMethodsOverridden(GetType());
