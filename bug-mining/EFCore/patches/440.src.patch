diff --git a/src/EFCore/Metadata/Conventions/InversePropertyAttributeConvention.cs b/src/EFCore/Metadata/Conventions/InversePropertyAttributeConvention.cs
index 9566c94858..44441eab27 100644
--- a/src/EFCore/Metadata/Conventions/InversePropertyAttributeConvention.cs
+++ b/src/EFCore/Metadata/Conventions/InversePropertyAttributeConvention.cs
@@ -630,7 +630,8 @@ private static void Remove(IConventionNavigation navigation)
             {
                 foreach (var (memberInfo, references) in navigationMap.Values)
                 {
-                    if (memberInfo.GetMemberType().IsAssignableFrom(entityType.ClrType)
+                    var memberInfoType = memberInfo.GetMemberType();
+                    if ((memberInfoType.TryGetSequenceType() ?? memberInfoType).IsAssignableFrom(entityType.ClrType)
                         && IsAmbiguousInverse(navigation, entityType, references))
                     {
                         return true;
diff --git a/test/EFCore.Specification.Tests/DataAnnotationTestBase.cs b/test/EFCore.Specification.Tests/DataAnnotationTestBase.cs
index 16f871d924..f2eb55466c 100644
--- a/test/EFCore.Specification.Tests/DataAnnotationTestBase.cs
+++ b/test/EFCore.Specification.Tests/DataAnnotationTestBase.cs
@@ -2227,7 +2227,7 @@ public virtual void InversePropertyAttribute_pointing_to_same_skip_nav_on_base_c
     {
         var modelBuilder = CreateModelBuilder();
         modelBuilder.Entity<AmbiguousInversePropertyLeft>();
-        modelBuilder.Entity<AmbiguousInversePropertyLeftDerived>();
+        modelBuilder.Entity<AmbiguousInversePropertyRightDerived>();
 
         Assert.Equal(
             CoreStrings.WarningAsErrorTemplate(
@@ -2249,7 +2249,6 @@ protected class AmbiguousInversePropertyLeft
 
     protected class AmbiguousInversePropertyLeftDerived : AmbiguousInversePropertyLeft
     {
-        public List<AmbiguousInversePropertyRightDerived> DerivedRights { get; set; }
     }
 
     protected class AmbiguousInversePropertyRight
@@ -2771,6 +2770,21 @@ public virtual void InverseProperty_with_case_sensitive_clr_property()
         Validate(modelBuilder);
     }
 
+    [ConditionalFact]
+    public virtual void InverseProperty_with_potentially_ambigous_derived_types()
+    {
+        var modelBuilder = CreateModelBuilder();
+        var model = modelBuilder.Model;
+
+        modelBuilder.Ignore<CPSorder>();
+        modelBuilder.Entity<SpecialOrder>();
+        modelBuilder.Entity<CPSpecialOrder>();
+
+        modelBuilder.Entity<CPSorder>().HasKey(e => e.Id);
+
+        Validate(modelBuilder);
+    }
+
     public abstract class DataAnnotationFixtureBase : SharedStoreFixtureBase<PoolableDbContext>
     {
         protected override string StoreName
@@ -2929,4 +2943,12 @@ protected class Partner
         [InverseProperty(nameof(CPSorder.CPSchargePartner))]
         public virtual ICollection<CPSorder> CPSorders { get; set; }
     }
+
+    protected class SpecialOrder : CPSorder
+    {
+    }
+
+    protected class CPSpecialOrder : CPSorder
+    {
+    }
 }
