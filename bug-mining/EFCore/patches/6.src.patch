diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
index d5320431d8..ed599055dc 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.Helper.cs
@@ -810,9 +810,8 @@ private sealed class CloningExpressionVisitor : ExpressionVisitor
                     }
 
                     // Now that we have SelectExpression, we visit all components and update table references inside columns
-                    newSelectExpression =
-                        (SelectExpression)new ColumnExpressionReplacingExpressionVisitor(selectExpression, newSelectExpression)
-                            .Visit(newSelectExpression);
+                    newSelectExpression = (SelectExpression)new ColumnExpressionReplacingExpressionVisitor(
+                        selectExpression, newSelectExpression._tableReferences).Visit(newSelectExpression);
 
                     return newSelectExpression;
                 }
@@ -826,10 +825,11 @@ private sealed class ColumnExpressionReplacingExpressionVisitor : ExpressionVisi
             private readonly SelectExpression _oldSelectExpression;
             private readonly Dictionary<string, TableReferenceExpression> _newTableReferences;
 
-            public ColumnExpressionReplacingExpressionVisitor(SelectExpression oldSelectExpression, SelectExpression newSelectExpression)
+            public ColumnExpressionReplacingExpressionVisitor(
+                SelectExpression oldSelectExpression, IEnumerable<TableReferenceExpression> newTableReferences)
             {
                 _oldSelectExpression = oldSelectExpression;
-                _newTableReferences = newSelectExpression._tableReferences.ToDictionary(e => e.Alias);
+                _newTableReferences = newTableReferences.ToDictionary(e => e.Alias);
             }
 
             [return: NotNullIfNotNull("expression")]
@@ -894,8 +894,14 @@ public GroupByAggregateLiftingExpressionVisitor(SelectExpression selectExpressio
                         if (initialTableCounts > 0)
                         {
                             // If there are no initial table then this is not correlated grouping subquery
+                            // We only replace columns from initial tables.
+                            // Additional tables may have been added to outer from other terms which may end up matching on table alias
                             var columnExpressionReplacingExpressionVisitor =
-                                new ColumnExpressionReplacingExpressionVisitor(subquery, _selectExpression);
+                                AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue27083", out var enabled2) && enabled2
+                                ? new ColumnExpressionReplacingExpressionVisitor(
+                                    subquery, _selectExpression._tableReferences)
+                                : new ColumnExpressionReplacingExpressionVisitor(
+                                    subquery, _selectExpression._tableReferences.Take(initialTableCounts));
                             if (subquery._tables.Count != initialTableCounts)
                             {
                                 // If subquery has more tables then we expanded join on it.
@@ -931,7 +937,8 @@ private void CopyOverOwnedJoinInSameTable(SelectExpression target, SelectExpress
             {
                 if (target._projection.Count != source._projection.Count)
                 {
-                    var columnExpressionReplacingExpressionVisitor = new ColumnExpressionReplacingExpressionVisitor(source, target);
+                    var columnExpressionReplacingExpressionVisitor = new ColumnExpressionReplacingExpressionVisitor(
+                        source, target._tableReferences);
                     var minProjectionCount = Math.Min(target._projection.Count, source._projection.Count);
                     var initialProjectionCount = 0;
                     for (var i = 0; i < minProjectionCount; i++)
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
index 98ecfad6e5..fddea73a0f 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SelectExpression.cs
@@ -622,9 +622,8 @@ static Expression RemoveConvert(Expression expression)
                             if (querySplittingBehavior == QuerySplittingBehavior.SplitQuery)
                             {
                                 var outerSelectExpression = (SelectExpression)cloningExpressionVisitor!.Visit(baseSelectExpression!);
-                                innerSelectExpression =
-                                    (SelectExpression)new ColumnExpressionReplacingExpressionVisitor(this, outerSelectExpression)
-                                        .Visit(innerSelectExpression);
+                                innerSelectExpression = (SelectExpression)new ColumnExpressionReplacingExpressionVisitor(
+                                    this, outerSelectExpression._tableReferences).Visit(innerSelectExpression);
 
                                 if (outerSelectExpression.Limit != null
                                     || outerSelectExpression.Offset != null
diff --git a/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs b/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs
index 013cd5922a..4633013d76 100644
--- a/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs
+++ b/test/EFCore.Specification.Tests/Query/SimpleQueryTestBase.cs
@@ -598,5 +598,133 @@ protected class OrderItem
             public DateTime? ShippingDate { get; set; }
             public DateTime? CancellationDate { get; set; }
         }
+
+        [ConditionalTheory]
+        [MemberData(nameof(IsAsyncData))]
+        public virtual async Task GroupBy_Aggregate_over_navigations_repeated(bool async)
+        {
+            var contextFactory = await InitializeAsync<Context27083>(seed: c => c.Seed());
+            using var context = contextFactory.CreateContext();
+
+            var query = context
+                .Set<TimeSheet>()
+                .Where(x => x.OrderId != null)
+                .GroupBy(x => x.OrderId)
+                .Select(x => new
+                {
+                    HourlyRate = x.Min(f => f.Order.HourlyRate),
+                    CustomerId = x.Min(f => f.Project.Customer.Id),
+                    CustomerName = x.Min(f => f.Project.Customer.Name),
+                });
+
+            var timeSheets = async
+                ? await query.ToListAsync()
+                : query.ToList();
+
+            Assert.Equal(2, timeSheets.Count);
+        }
+
+        [ConditionalTheory]
+        [MemberData(nameof(IsAsyncData))]
+        public virtual async Task Aggregate_over_subquery_in_group_by_projection(bool async)
+        {
+            var contextFactory = await InitializeAsync<Context27083>(seed: c => c.Seed());
+            using var context = contextFactory.CreateContext();
+
+            Expression<Func<Order, bool>> someFilterFromOutside = x => x.Number != "A1";
+
+            var query = context
+                .Set<Order>()
+                .Where(someFilterFromOutside)
+                .GroupBy(x => new { x.CustomerId, x.Number })
+                .Select(x => new
+                {
+                    x.Key.CustomerId,
+                    CustomerMinHourlyRate = context.Set<Order>().Where(n => n.CustomerId == x.Key.CustomerId).Min(h => h.HourlyRate),
+                    HourlyRate = x.Min(f => f.HourlyRate),
+                    Count = x.Count()
+                });
+
+            var orders = async
+                ? await query.ToListAsync()
+                : query.ToList();
+
+            Assert.Collection(orders,
+                t => Assert.Equal(10, t.CustomerMinHourlyRate),
+                t => Assert.Equal(20, t.CustomerMinHourlyRate));
+        }
+
+        protected class Context27083 : DbContext
+        {
+            public Context27083(DbContextOptions options)
+                : base(options)
+            {
+            }
+
+            public DbSet<TimeSheet> TimeSheets { get; set; }
+            public DbSet<Customer> Customers { get; set; }
+
+            public void Seed()
+            {
+                var customerA = new Customer { Name = "Customer A" };
+                var customerB = new Customer { Name = "Customer B" };
+
+                var projectA = new Project { Customer = customerA };
+                var projectB = new Project { Customer = customerB };
+
+                var orderA1 = new Order { Number = "A1", Customer = customerA, HourlyRate = 10 };
+                var orderA2 = new Order { Number = "A2", Customer = customerA, HourlyRate = 11 };
+                var orderB1 = new Order { Number = "B1", Customer = customerB, HourlyRate = 20 };
+
+                var timeSheetA = new TimeSheet { Order = orderA1, Project = projectA };
+                var timeSheetB = new TimeSheet { Order = orderB1, Project = projectB };
+
+                AddRange(customerA, customerB);
+                AddRange(projectA, projectB);
+                AddRange(orderA1, orderA2, orderB1);
+                AddRange(timeSheetA, timeSheetB);
+                SaveChanges();
+            }
+        }
+
+        protected class Customer
+        {
+            public int Id { get; set; }
+
+            public string Name { get; set; }
+
+            public List<Project> Projects { get; set; }
+            public List<Order> Orders { get; set; }
+        }
+
+        protected class Order
+        {
+            public int Id { get; set; }
+            public string Number { get; set; }
+
+            public int CustomerId { get; set; }
+            public Customer Customer { get; set; }
+
+            public int HourlyRate { get; set; }
+        }
+
+        protected class Project
+        {
+            public int Id { get; set; }
+            public int CustomerId { get; set; }
+
+            public Customer Customer { get; set; }
+        }
+
+        protected class TimeSheet
+        {
+            public int Id { get; set; }
+
+            public int ProjectId { get; set; }
+            public Project Project { get; set; }
+
+            public int? OrderId { get; set; }
+            public Order Order { get; set; }
+        }
     }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs
index 6c327967dc..106bae7a55 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Query/SimpleQuerySqlServerTest.cs
@@ -147,5 +147,35 @@ public override async Task GroupBy_aggregate_on_right_side_of_join(bool async)
 WHERE [o].[OrderId] = @__orderId_0
 ORDER BY [o].[OrderId]");
         }
+
+        public override async Task GroupBy_Aggregate_over_navigations_repeated(bool async)
+        {
+            await base.GroupBy_Aggregate_over_navigations_repeated(async);
+
+            AssertSql(
+                @"SELECT MIN([o].[HourlyRate]) AS [HourlyRate], MIN([c].[Id]) AS [CustomerId], MIN([c0].[Name]) AS [CustomerName]
+FROM [TimeSheets] AS [t]
+LEFT JOIN [Order] AS [o] ON [t].[OrderId] = [o].[Id]
+INNER JOIN [Project] AS [p] ON [t].[ProjectId] = [p].[Id]
+INNER JOIN [Customers] AS [c] ON [p].[CustomerId] = [c].[Id]
+INNER JOIN [Project] AS [p0] ON [t].[ProjectId] = [p0].[Id]
+INNER JOIN [Customers] AS [c0] ON [p0].[CustomerId] = [c0].[Id]
+WHERE [t].[OrderId] IS NOT NULL
+GROUP BY [t].[OrderId]");
+        }
+
+        public override async Task Aggregate_over_subquery_in_group_by_projection(bool async)
+        {
+            await base.Aggregate_over_subquery_in_group_by_projection(async);
+
+            AssertSql(
+                @"SELECT [o].[CustomerId], (
+    SELECT MIN([o0].[HourlyRate])
+    FROM [Order] AS [o0]
+    WHERE [o0].[CustomerId] = [o].[CustomerId]) AS [CustomerMinHourlyRate], MIN([o].[HourlyRate]) AS [HourlyRate], COUNT(*) AS [Count]
+FROM [Order] AS [o]
+WHERE ([o].[Number] <> N'A1') OR [o].[Number] IS NULL
+GROUP BY [o].[CustomerId], [o].[Number]");
+        }
     }
 }
