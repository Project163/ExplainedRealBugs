diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs
index 750957cbdd..38ceb4f094 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosProjectionBindingExpressionVisitor.cs
@@ -745,5 +745,5 @@ private static Expression MatchTypes(Expression expression, Type targetType)
 
     [UsedImplicitly]
     private static T GetParameterValue<T>(QueryContext queryContext, string parameterName)
-        => (T)queryContext.ParameterValues[parameterName]!;
+        => (T)queryContext.Parameters[parameterName]!;
 }
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.PagingQueryingEnumerable.cs b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.PagingQueryingEnumerable.cs
index 6e84ffa782..2766b35a3c 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.PagingQueryingEnumerable.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.PagingQueryingEnumerable.cs
@@ -67,7 +67,7 @@ private sealed class PagingQueryingEnumerable<T> : IAsyncEnumerable<CosmosPage<T
             _cosmosContainer = rootEntityType.GetContainer()
                 ?? throw new UnreachableException("Root entity type without a Cosmos container.");
             _cosmosPartitionKey = GeneratePartitionKey(
-                rootEntityType, partitionKeyPropertyValues, _cosmosQueryContext.ParameterValues);
+                rootEntityType, partitionKeyPropertyValues, _cosmosQueryContext.Parameters);
         }
 
         public IAsyncEnumerator<CosmosPage<T>> GetAsyncEnumerator(CancellationToken cancellationToken = default)
@@ -77,9 +77,9 @@ private CosmosSqlQuery GenerateQuery()
             => _querySqlGeneratorFactory.Create().GetSqlQuery(
                 (SelectExpression)new ParameterInliner(
                         _sqlExpressionFactory,
-                        _cosmosQueryContext.ParameterValues)
+                        _cosmosQueryContext.Parameters)
                     .Visit(_selectExpression),
-                _cosmosQueryContext.ParameterValues);
+                _cosmosQueryContext.Parameters);
 
         private sealed class AsyncEnumerator : IAsyncEnumerator<CosmosPage<T>>
         {
@@ -135,11 +135,11 @@ public async ValueTask<bool> MoveNextAsync()
 
                     _hasExecuted = true;
 
-                    var maxItemCount = (int)_cosmosQueryContext.ParameterValues[_queryingEnumerable._maxItemCountParameterName];
+                    var maxItemCount = (int)_cosmosQueryContext.Parameters[_queryingEnumerable._maxItemCountParameterName];
                     var continuationToken =
-                        (string)_cosmosQueryContext.ParameterValues[_queryingEnumerable._continuationTokenParameterName];
+                        (string)_cosmosQueryContext.Parameters[_queryingEnumerable._continuationTokenParameterName];
                     var responseContinuationTokenLimitInKb = (int?)
-                        _cosmosQueryContext.ParameterValues[_queryingEnumerable._responseContinuationTokenLimitInKbParameterName];
+                        _cosmosQueryContext.Parameters[_queryingEnumerable._responseContinuationTokenLimitInKbParameterName];
 
                     var sqlQuery = _queryingEnumerable.GenerateQuery();
 
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs
index 26c7d885cd..ced9ff5422 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.QueryingEnumerable.cs
@@ -57,7 +57,7 @@ private sealed class QueryingEnumerable<T> : IEnumerable<T>, IAsyncEnumerable<T>
             _cosmosContainer = rootEntityType.GetContainer()
                 ?? throw new UnreachableException("Root entity type without a Cosmos container.");
             _cosmosPartitionKey = GeneratePartitionKey(
-                rootEntityType, partitionKeyPropertyValues, _cosmosQueryContext.ParameterValues);
+                rootEntityType, partitionKeyPropertyValues, _cosmosQueryContext.Parameters);
         }
 
         public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
@@ -73,9 +73,9 @@ private CosmosSqlQuery GenerateQuery()
             => _querySqlGeneratorFactory.Create().GetSqlQuery(
                 (SelectExpression)new ParameterInliner(
                         _sqlExpressionFactory,
-                        _cosmosQueryContext.ParameterValues)
+                        _cosmosQueryContext.Parameters)
                     .Visit(_selectExpression),
-                _cosmosQueryContext.ParameterValues);
+                _cosmosQueryContext.Parameters);
 
         public string ToQueryString()
         {
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs
index 9e833adbb3..6884390298 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosShapedQueryCompilingExpressionVisitor.ReadItemQueryingEnumerable.cs
@@ -53,7 +53,7 @@ private sealed class ReadItemQueryingEnumerable<T> : IEnumerable<T>, IAsyncEnume
             _cosmosContainer = rootEntityType.GetContainer()
                 ?? throw new UnreachableException("Root entity type without a Cosmos container.");
             _cosmosPartitionKey = GeneratePartitionKey(
-                rootEntityType, partitionKeyPropertyValues, _cosmosQueryContext.ParameterValues);
+                rootEntityType, partitionKeyPropertyValues, _cosmosQueryContext.Parameters);
         }
 
         public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default)
@@ -83,7 +83,7 @@ private bool TryGetResourceId(out string resourceId)
             {
                 var value = _readItemInfo.PropertyValues[property] switch
                 {
-                    SqlParameterExpression { Name: var parameterName } => _cosmosQueryContext.ParameterValues[parameterName],
+                    SqlParameterExpression { Name: var parameterName } => _cosmosQueryContext.Parameters[parameterName],
                     SqlConstantExpression { Value: var constantValue } => constantValue,
                     _ => throw new UnreachableException()
                 };
diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
index e46d7344f5..deda6fe2a3 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosSqlTranslatingExpressionVisitor.cs
@@ -1179,7 +1179,7 @@ private Expression CreatePropertyAccessExpression(Expression target, IProperty p
 
     private static T? ParameterValueExtractor<T>(QueryContext context, string baseParameterName, IProperty property)
     {
-        var baseParameter = context.ParameterValues[baseParameterName];
+        var baseParameter = context.Parameters[baseParameterName];
         return baseParameter == null ? (T?)(object?)null : (T?)property.GetGetter().GetClrValue(baseParameter);
     }
 
@@ -1188,7 +1188,7 @@ private Expression CreatePropertyAccessExpression(Expression target, IProperty p
         string baseParameterName,
         IProperty property)
     {
-        if (context.ParameterValues[baseParameterName] is not IEnumerable<TEntity> baseListParameter)
+        if (context.Parameters[baseParameterName] is not IEnumerable<TEntity> baseListParameter)
         {
             return null;
         }
diff --git a/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
index 9b60e2a1d3..d11cf7f07f 100644
--- a/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
+++ b/src/EFCore.Design/Query/Internal/PrecompiledQueryCodeGenerator.cs
@@ -797,7 +797,7 @@ void ProcessCapturedVariables()
                         {
                             // Special case: this is a non-lambda argument (Skip/Take/FromSql).
                             // Simply add the argument directly as a parameter
-                            code.AppendLine($"""queryContext.AddParameter("{evaluatableRootPaths.ParameterName}", {parameterName});""");
+                            code.AppendLine($"""queryContext.Parameters.Add("{evaluatableRootPaths.ParameterName}", {parameterName});""");
                             continue;
                         }
 
@@ -849,7 +849,7 @@ void ProcessCapturedVariables()
                                 //       (see ExpressionTreeFuncletizer.Evaluate()).
                                 // TODO: Basically this means that the evaluator should come from ExpressionTreeFuncletizer itself, as part of its outputs
                                 // TODO: Integrate try/catch around the evaluation?
-                                code.AppendLine("queryContext.AddParameter(");
+                                code.AppendLine("queryContext.Parameters.Add(");
                                 using (code.Indent())
                                 {
                                     code
@@ -893,7 +893,7 @@ void ProcessCapturedVariables()
                     };
 
                     code.AppendLine(
-                        $"""queryContext.AddParameter("{evaluatableRootPaths.ParameterName}", {argumentsParameter});""");
+                        $"""queryContext.Parameters.Add("{evaluatableRootPaths.ParameterName}", {argumentsParameter});""");
 
                     break;
                 }
diff --git a/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs b/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
index 4c451233f7..9ccba1f965 100644
--- a/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
+++ b/src/EFCore.InMemory/Query/Internal/InMemoryExpressionTranslatingExpressionVisitor.cs
@@ -1216,7 +1216,7 @@ protected override Expression VisitUnary(UnaryExpression unaryExpression)
 
     [UsedImplicitly]
     private static T GetParameterValue<T>(QueryContext queryContext, string parameterName)
-        => (T)queryContext.ParameterValues[parameterName]!;
+        => (T)queryContext.Parameters[parameterName]!;
 
     private static bool IsConvertedToNullable(Expression result, Expression original)
         => result.Type.IsNullableType()
@@ -1480,7 +1480,7 @@ private Expression CreatePropertyAccessExpression(Expression target, IProperty p
 
     private static T? ParameterValueExtractor<T>(QueryContext context, string baseParameterName, IProperty property)
     {
-        var baseParameter = context.ParameterValues[baseParameterName];
+        var baseParameter = context.Parameters[baseParameterName];
         return baseParameter == null ? (T?)(object?)null : (T?)property.GetGetter().GetClrValue(baseParameter);
     }
 
@@ -1489,7 +1489,7 @@ private Expression CreatePropertyAccessExpression(Expression target, IProperty p
         string baseParameterName,
         IProperty property)
     {
-        if (!(context.ParameterValues[baseParameterName] is IEnumerable<TEntity> baseListParameter))
+        if (!(context.Parameters[baseParameterName] is IEnumerable<TEntity> baseListParameter))
         {
             return null;
         }
diff --git a/src/EFCore.Relational/Extensions/Internal/RelationalCommandResolverExtensions.cs b/src/EFCore.Relational/Extensions/Internal/RelationalCommandResolverExtensions.cs
index 5723ef6036..5dab1a56b8 100644
--- a/src/EFCore.Relational/Extensions/Internal/RelationalCommandResolverExtensions.cs
+++ b/src/EFCore.Relational/Extensions/Internal/RelationalCommandResolverExtensions.cs
@@ -24,7 +24,7 @@ public static class RelationalCommandResolverExtensions
         this RelationalCommandResolver relationalCommandResolver,
         RelationalQueryContext queryContext)
     {
-        var relationalCommandTemplate = relationalCommandResolver(queryContext.ParameterValues);
+        var relationalCommandTemplate = relationalCommandResolver(queryContext.Parameters);
         var relationalCommand = queryContext.Connection.RentCommand();
         relationalCommand.PopulateFrom(relationalCommandTemplate);
         return relationalCommand;
diff --git a/src/EFCore.Relational/Query/CacheSafeParameterFacade.cs b/src/EFCore.Relational/Query/CacheSafeParameterFacade.cs
new file mode 100644
index 0000000000..2fca19d902
--- /dev/null
+++ b/src/EFCore.Relational/Query/CacheSafeParameterFacade.cs
@@ -0,0 +1,45 @@
+// Licensed to the .NET Foundation under one or more agreements.
+// The .NET Foundation licenses this file to you under the MIT license.
+
+using System;
+
+namespace Microsoft.EntityFrameworkCore.Query;
+
+/// <summary>
+///     A facade over <see cref="QueryContext.Parameters" /> which provides cache-safe way to access parameters after the SQL cache.
+/// </summary>
+/// <remarks>
+///     The SQL cache only includes then nullability of parameters in its cache key. Accordingly, this type exposes an API for checking
+///     the nullability of a parameter. It also allows retrieving the full parameter dictionary for arbitrary checks, but when this
+///     API is called, the facade records this fact, and the resulting SQL will not get cached.
+/// </remarks>
+public sealed class CacheSafeParameterFacade(Dictionary<string, object?> parameters)
+{
+    /// <summary>
+    ///     Returns whether the parameter with the given name is null.
+    /// </summary>
+    /// <remarks>
+    ///     The method assumes that the parameter with the given name exists in the dictionary,
+    ///     and otherwise throws <see cref="UnreachableException" />.
+    /// </remarks>
+    public bool IsParameterNull(string parameterName)
+        => parameters.TryGetValue(parameterName, out var value)
+            ? value is null
+            : throw new UnreachableException($"Parameter with name '{parameterName}' does not exist.");
+
+    /// <summary>
+    ///     Returns the full dictionary of parameters, and disables caching for the generated SQL.
+    /// </summary>
+    public Dictionary<string, object?> GetParametersAndDisableSqlCaching()
+    {
+        CanCache = false;
+
+        return parameters;
+    }
+
+    /// <summary>
+    ///     Whether the SQL generated using this facade can be cached, i.e. whether the full dictionary of parameters
+    ///     has been accessed.
+    /// </summary>
+    public bool CanCache { get; private set; } = true;
+}
diff --git a/src/EFCore.Relational/Query/Internal/FromSqlQueryingEnumerable.cs b/src/EFCore.Relational/Query/Internal/FromSqlQueryingEnumerable.cs
index 3bdd96e16b..f57f117b04 100644
--- a/src/EFCore.Relational/Query/Internal/FromSqlQueryingEnumerable.cs
+++ b/src/EFCore.Relational/Query/Internal/FromSqlQueryingEnumerable.cs
@@ -128,11 +128,11 @@ IEnumerator IEnumerable.GetEnumerator()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual DbCommand CreateDbCommand()
-        => _relationalCommandResolver(_relationalQueryContext.ParameterValues)
+        => _relationalCommandResolver(_relationalQueryContext.Parameters)
             .CreateDbCommand(
                 new RelationalCommandParameterObject(
                     _relationalQueryContext.Connection,
-                    _relationalQueryContext.ParameterValues,
+                    _relationalQueryContext.Parameters,
                     null,
                     null,
                     null,
@@ -269,7 +269,7 @@ private static bool InitializeReader(Enumerator enumerator)
             enumerator._dataReader = relationalCommand.ExecuteReader(
                 new RelationalCommandParameterObject(
                     enumerator._relationalQueryContext.Connection,
-                    enumerator._relationalQueryContext.ParameterValues,
+                    enumerator._relationalQueryContext.Parameters,
                     enumerator._readerColumns,
                     enumerator._relationalQueryContext.Context,
                     enumerator._relationalQueryContext.CommandLogger,
@@ -384,7 +384,7 @@ private static async Task<bool> InitializeReaderAsync(AsyncEnumerator enumerator
             enumerator._dataReader = await relationalCommand.ExecuteReaderAsync(
                     new RelationalCommandParameterObject(
                         enumerator._relationalQueryContext.Connection,
-                        enumerator._relationalQueryContext.ParameterValues,
+                        enumerator._relationalQueryContext.Parameters,
                         enumerator._readerColumns,
                         enumerator._relationalQueryContext.Context,
                         enumerator._relationalQueryContext.CommandLogger,
diff --git a/src/EFCore.Relational/Query/Internal/GroupBySingleQueryingEnumerable.cs b/src/EFCore.Relational/Query/Internal/GroupBySingleQueryingEnumerable.cs
index 7caf949822..af0eb423bf 100644
--- a/src/EFCore.Relational/Query/Internal/GroupBySingleQueryingEnumerable.cs
+++ b/src/EFCore.Relational/Query/Internal/GroupBySingleQueryingEnumerable.cs
@@ -139,11 +139,11 @@ IEnumerator IEnumerable.GetEnumerator()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual DbCommand CreateDbCommand()
-        => _relationalCommandResolver(_relationalQueryContext.ParameterValues)
+        => _relationalCommandResolver(_relationalQueryContext.Parameters)
             .CreateDbCommand(
                 new RelationalCommandParameterObject(
                     _relationalQueryContext.Connection,
-                    _relationalQueryContext.ParameterValues,
+                    _relationalQueryContext.Parameters,
                     null,
                     null,
                     null, CommandSource.LinqQuery),
@@ -339,7 +339,7 @@ private static bool InitializeReader(Enumerator enumerator)
             var dataReader = enumerator._dataReader = relationalCommand.ExecuteReader(
                 new RelationalCommandParameterObject(
                     enumerator._relationalQueryContext.Connection,
-                    enumerator._relationalQueryContext.ParameterValues,
+                    enumerator._relationalQueryContext.Parameters,
                     enumerator._readerColumns,
                     enumerator._relationalQueryContext.Context,
                     enumerator._relationalQueryContext.CommandLogger,
@@ -519,7 +519,7 @@ private static async Task<bool> InitializeReaderAsync(AsyncEnumerator enumerator
             var dataReader = enumerator._dataReader = await relationalCommand.ExecuteReaderAsync(
                     new RelationalCommandParameterObject(
                         enumerator._relationalQueryContext.Connection,
-                        enumerator._relationalQueryContext.ParameterValues,
+                        enumerator._relationalQueryContext.Parameters,
                         enumerator._readerColumns,
                         enumerator._relationalQueryContext.Context,
                         enumerator._relationalQueryContext.CommandLogger,
diff --git a/src/EFCore.Relational/Query/Internal/GroupBySplitQueryingEnumerable.cs b/src/EFCore.Relational/Query/Internal/GroupBySplitQueryingEnumerable.cs
index 982b59dcdb..e8b6787290 100644
--- a/src/EFCore.Relational/Query/Internal/GroupBySplitQueryingEnumerable.cs
+++ b/src/EFCore.Relational/Query/Internal/GroupBySplitQueryingEnumerable.cs
@@ -149,11 +149,11 @@ IEnumerator IEnumerable.GetEnumerator()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual DbCommand CreateDbCommand()
-        => _relationalCommandResolver(_relationalQueryContext.ParameterValues)
+        => _relationalCommandResolver(_relationalQueryContext.Parameters)
             .CreateDbCommand(
                 new RelationalCommandParameterObject(
                     _relationalQueryContext.Connection,
-                    _relationalQueryContext.ParameterValues,
+                    _relationalQueryContext.Parameters,
                     null,
                     null,
                     null, CommandSource.LinqQuery),
@@ -339,7 +339,7 @@ private static bool InitializeReader(Enumerator enumerator)
             var dataReader = enumerator._dataReader = relationalCommand.ExecuteReader(
                 new RelationalCommandParameterObject(
                     enumerator._relationalQueryContext.Connection,
-                    enumerator._relationalQueryContext.ParameterValues,
+                    enumerator._relationalQueryContext.Parameters,
                     enumerator._readerColumns,
                     enumerator._relationalQueryContext.Context,
                     enumerator._relationalQueryContext.CommandLogger,
@@ -510,7 +510,7 @@ private static async Task<bool> InitializeReaderAsync(AsyncEnumerator enumerator
             var dataReader = enumerator._dataReader = await relationalCommand.ExecuteReaderAsync(
                     new RelationalCommandParameterObject(
                         enumerator._relationalQueryContext.Connection,
-                        enumerator._relationalQueryContext.ParameterValues,
+                        enumerator._relationalQueryContext.Parameters,
                         enumerator._readerColumns,
                         enumerator._relationalQueryContext.Context,
                         enumerator._relationalQueryContext.CommandLogger,
diff --git a/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs b/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs
index 15435beed3..4d19a2b3ea 100644
--- a/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs
+++ b/src/EFCore.Relational/Query/Internal/RelationalCommandCache.cs
@@ -70,7 +70,7 @@ public virtual IRelationalCommandTemplate GetRelationalCommandTemplate(Dictionar
             {
                 if (!_memoryCache.TryGetValue(cacheKey, out relationalCommandTemplate))
                 {
-                    var queryExpression = _relationalParameterBasedSqlProcessor.Optimize(
+                    var queryExpression = _relationalParameterBasedSqlProcessor.Process(
                         _queryExpression, parameters, out var canCache);
                     relationalCommandTemplate = _querySqlGeneratorFactory.Create().GetCommand(queryExpression);
 
diff --git a/src/EFCore.Relational/Query/Internal/RelationalParameterProcessor.cs b/src/EFCore.Relational/Query/Internal/RelationalParameterProcessor.cs
index 4c4f2c8512..b955ccae28 100644
--- a/src/EFCore.Relational/Query/Internal/RelationalParameterProcessor.cs
+++ b/src/EFCore.Relational/Query/Internal/RelationalParameterProcessor.cs
@@ -35,9 +35,8 @@ public class RelationalParameterProcessor : ExpressionVisitor
 
     private readonly Dictionary<string, SqlParameterExpression> _sqlParameters = new();
 
-    private IReadOnlyDictionary<string, object?> _parametersValues;
+    private CacheSafeParameterFacade _parametersFacade;
     private ParameterNameGenerator _parameterNameGenerator;
-    private bool _canCache;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -54,7 +53,7 @@ public class RelationalParameterProcessor : ExpressionVisitor
         _typeMappingSource = dependencies.TypeMappingSource;
         _parameterNameGeneratorFactory = dependencies.ParameterNameGeneratorFactory;
         _sqlGenerationHelper = dependencies.SqlGenerationHelper;
-        _parametersValues = default!;
+        _parametersFacade = default!;
         _parameterNameGenerator = default!;
     }
 
@@ -69,20 +68,15 @@ public class RelationalParameterProcessor : ExpressionVisitor
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual Expression Expand(
-        Expression queryExpression,
-        IReadOnlyDictionary<string, object?> parameterValues,
-        out bool canCache)
+    public virtual Expression Expand(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
     {
         _visitedFromSqlExpressions.Clear();
         _prefixedParameterNames.Clear();
         _sqlParameters.Clear();
         _parameterNameGenerator = _parameterNameGeneratorFactory.Create();
-        _parametersValues = parameterValues;
-        _canCache = true;
+        _parametersFacade = parametersFacade;
 
         var result = Visit(queryExpression);
-        canCache = _canCache;
 
         return result;
     }
@@ -146,8 +140,8 @@ private FromSqlExpression VisitFromSql(FromSqlExpression fromSql)
         {
             case QueryParameterExpression queryParameter:
                 // parameter value will never be null. It could be empty object?[]
-                var parameterValues = (object?[])_parametersValues[queryParameter.Name]!;
-                _canCache = false;
+                var parameters = _parametersFacade.GetParametersAndDisableSqlCaching();
+                var parameterValues = (object?[])parameters[queryParameter.Name]!;
 
                 var subParameters = new List<IRelationalParameter>(parameterValues.Length);
                 // ReSharper disable once ForCanBeConvertedToForeach
diff --git a/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs b/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs
index dc2831a8d5..937410dd76 100644
--- a/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/Internal/RelationalProjectionBindingExpressionVisitor.cs
@@ -661,7 +661,7 @@ private ProjectionBindingExpression AddClientProjection(Expression expression, T
     /// </summary>
     public static T GetParameterValue<T>(QueryContext queryContext, string parameterName)
 #pragma warning restore IDE0052 // Remove unread private members
-        => (T)queryContext.ParameterValues[parameterName]!;
+        => (T)queryContext.Parameters[parameterName]!;
 
     private sealed class IncludeFindingExpressionVisitor : ExpressionVisitor
     {
diff --git a/src/EFCore.Relational/Query/Internal/SingleQueryingEnumerable.cs b/src/EFCore.Relational/Query/Internal/SingleQueryingEnumerable.cs
index d3037ae67f..5a79eb34b9 100644
--- a/src/EFCore.Relational/Query/Internal/SingleQueryingEnumerable.cs
+++ b/src/EFCore.Relational/Query/Internal/SingleQueryingEnumerable.cs
@@ -123,11 +123,11 @@ IEnumerator IEnumerable.GetEnumerator()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual DbCommand CreateDbCommand()
-        => _relationalCommandResolver(_relationalQueryContext.ParameterValues)
+        => _relationalCommandResolver(_relationalQueryContext.Parameters)
             .CreateDbCommand(
                 new RelationalCommandParameterObject(
                     _relationalQueryContext.Connection,
-                    _relationalQueryContext.ParameterValues,
+                    _relationalQueryContext.Parameters,
                     null,
                     null,
                     null, CommandSource.LinqQuery),
@@ -266,7 +266,7 @@ private static bool InitializeReader(Enumerator enumerator)
             var dataReader = enumerator._dataReader = relationalCommand.ExecuteReader(
                 new RelationalCommandParameterObject(
                     enumerator._relationalQueryContext.Connection,
-                    enumerator._relationalQueryContext.ParameterValues,
+                    enumerator._relationalQueryContext.Parameters,
                     enumerator._readerColumns,
                     enumerator._relationalQueryContext.Context,
                     enumerator._relationalQueryContext.CommandLogger,
@@ -420,7 +420,7 @@ private static async Task<bool> InitializeReaderAsync(AsyncEnumerator enumerator
             var dataReader = enumerator._dataReader = await relationalCommand.ExecuteReaderAsync(
                     new RelationalCommandParameterObject(
                         enumerator._relationalQueryContext.Connection,
-                        enumerator._relationalQueryContext.ParameterValues,
+                        enumerator._relationalQueryContext.Parameters,
                         enumerator._readerColumns,
                         enumerator._relationalQueryContext.Context,
                         enumerator._relationalQueryContext.CommandLogger,
diff --git a/src/EFCore.Relational/Query/Internal/SplitQueryingEnumerable.cs b/src/EFCore.Relational/Query/Internal/SplitQueryingEnumerable.cs
index 5a8e99b477..2a7140594a 100644
--- a/src/EFCore.Relational/Query/Internal/SplitQueryingEnumerable.cs
+++ b/src/EFCore.Relational/Query/Internal/SplitQueryingEnumerable.cs
@@ -133,11 +133,11 @@ IEnumerator IEnumerable.GetEnumerator()
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public virtual DbCommand CreateDbCommand()
-        => _relationalCommandResolver(_relationalQueryContext.ParameterValues)
+        => _relationalCommandResolver(_relationalQueryContext.Parameters)
             .CreateDbCommand(
                 new RelationalCommandParameterObject(
                     _relationalQueryContext.Connection,
-                    _relationalQueryContext.ParameterValues,
+                    _relationalQueryContext.Parameters,
                     null,
                     null,
                     null,
@@ -260,7 +260,7 @@ private static bool InitializeReader(Enumerator enumerator)
             var dataReader = enumerator._dataReader = relationalCommand.ExecuteReader(
                 new RelationalCommandParameterObject(
                     enumerator._relationalQueryContext.Connection,
-                    enumerator._relationalQueryContext.ParameterValues,
+                    enumerator._relationalQueryContext.Parameters,
                     enumerator._readerColumns,
                     enumerator._relationalQueryContext.Context,
                     enumerator._relationalQueryContext.CommandLogger,
@@ -408,7 +408,7 @@ private static async Task<bool> InitializeReaderAsync(AsyncEnumerator enumerator
             var dataReader = enumerator._dataReader = await relationalCommand.ExecuteReaderAsync(
                     new RelationalCommandParameterObject(
                         enumerator._relationalQueryContext.Connection,
-                        enumerator._relationalQueryContext.ParameterValues,
+                        enumerator._relationalQueryContext.Parameters,
                         enumerator._readerColumns,
                         enumerator._relationalQueryContext.Context,
                         enumerator._relationalQueryContext.CommandLogger,
diff --git a/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessor.cs b/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessor.cs
index 3bf2c39d8c..990e718f95 100644
--- a/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessor.cs
+++ b/src/EFCore.Relational/Query/RelationalParameterBasedSqlProcessor.cs
@@ -41,23 +41,30 @@ public class RelationalParameterBasedSqlProcessor
     protected virtual RelationalParameterBasedSqlProcessorParameters Parameters { get; }
 
     /// <summary>
-    ///     Optimizes the query expression for given parameter values.
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    /// <param name="queryExpression">A query expression to optimize.</param>
-    /// <param name="parametersValues">A dictionary of parameter values to use.</param>
-    /// <param name="canCache">A bool value indicating if the query expression can be cached.</param>
-    /// <returns>An optimized query expression.</returns>
-    public virtual Expression Optimize(
-        Expression queryExpression,
-        Dictionary<string, object?> parametersValues,
-        out bool canCache)
+    [EntityFrameworkInternal]
+    public virtual Expression Process(Expression queryExpression, Dictionary<string, object?> parameters, out bool canCache)
     {
-        canCache = true;
-        queryExpression = ProcessSqlNullability(queryExpression, parametersValues, out var sqlNullabilityCanCache);
-        canCache &= sqlNullabilityCanCache;
+        var parametersFacade = new CacheSafeParameterFacade(parameters);
+        var result = Process(queryExpression, parametersFacade);
+        canCache = parametersFacade.CanCache;
+
+        return result;
+    }
 
-        queryExpression = ExpandFromSqlParameter(queryExpression, parametersValues, out var fromSqlParameterCanCache);
-        canCache &= fromSqlParameterCanCache;
+    /// <summary>
+    ///     Performs final query processing that takes parameter values into account.
+    /// </summary>
+    /// <param name="queryExpression">A query expression to process.</param>
+    /// <param name="parametersFacade">A facade allowing access to parameters in a cache-safe way.</param>
+    public virtual Expression Process(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
+    {
+        queryExpression = ProcessSqlNullability(queryExpression, parametersFacade);
+        queryExpression = ExpandFromSqlParameter(queryExpression, parametersFacade);
 
         return queryExpression;
     }
@@ -67,25 +74,31 @@ public class RelationalParameterBasedSqlProcessor
     ///     optimize it for given parameter values.
     /// </summary>
     /// <param name="queryExpression">A query expression to optimize.</param>
-    /// <param name="parametersValues">A dictionary of parameter values to use.</param>
-    /// <param name="canCache">A bool value indicating if the query expression can be cached.</param>
+    /// <param name="parametersFacade">A facade allowing access to parameters in a cache-safe way.</param>
     /// <returns>A processed query expression.</returns>
-    protected virtual Expression ProcessSqlNullability(
-        Expression queryExpression,
-        Dictionary<string, object?> parametersValues,
-        out bool canCache)
-        => new SqlNullabilityProcessor(Dependencies, Parameters).Process(queryExpression, parametersValues, out canCache);
+    protected virtual Expression ProcessSqlNullability(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
+        => new SqlNullabilityProcessor(Dependencies, Parameters).Process(queryExpression, parametersFacade);
 
     /// <summary>
     ///     Expands the parameters to <see cref="FromSqlExpression" /> inside the query expression for given parameter values.
     /// </summary>
     /// <param name="queryExpression">A query expression to optimize.</param>
+    /// <param name="parametersFacade">A facade allowing access to parameters in a cache-safe way.</param>
+    /// <returns>A processed query expression.</returns>
+    protected virtual Expression ExpandFromSqlParameter(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
+        => new RelationalParameterProcessor(Dependencies).Expand(queryExpression, parametersFacade);
+
+    /// <summary>
+    ///     Optimizes the query expression for given parameter values.
+    /// </summary>
+    /// <param name="queryExpression">A query expression to optimize.</param>
     /// <param name="parametersValues">A dictionary of parameter values to use.</param>
     /// <param name="canCache">A bool value indicating if the query expression can be cached.</param>
-    /// <returns>A processed query expression.</returns>
-    protected virtual Expression ExpandFromSqlParameter(
+    /// <returns>An optimized query expression.</returns>
+    [Obsolete("Override Process() instead", error: true)]
+    public virtual Expression Optimize(
         Expression queryExpression,
         IReadOnlyDictionary<string, object?> parametersValues,
         out bool canCache)
-        => new RelationalParameterProcessor(Dependencies).Expand(queryExpression, parametersValues, out canCache);
+        => throw new UnreachableException();
 }
diff --git a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
index 51e2693b62..308cf9489b 100644
--- a/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
+++ b/src/EFCore.Relational/Query/RelationalQueryableMethodTranslatingExpressionVisitor.ExecuteUpdate.cs
@@ -560,7 +560,7 @@ static Expression GetEntitySource(IModel model, Expression propertyAccessExpress
         List<IComplexProperty>? complexPropertyChain,
         IProperty property)
     {
-        var baseValue = context.ParameterValues[baseParameterName];
+        var baseValue = context.Parameters[baseParameterName];
 
         if (complexPropertyChain is not null)
         {
diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs
index 664151585d..419e8e7bbe 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.ShaperProcessingExpressionVisitor.ClientMethods.cs
@@ -447,7 +447,7 @@ void GenerateCurrentElementIfPending()
                     return relationalCommand.ExecuteReader(
                         new RelationalCommandParameterObject(
                             queryContext.Connection,
-                            queryContext.ParameterValues,
+                            queryContext.Parameters,
                             readerColumns,
                             queryContext.Context,
                             queryContext.CommandLogger,
@@ -543,7 +543,7 @@ void GenerateCurrentElementIfPending()
                     return await relationalCommand.ExecuteReaderAsync(
                             new RelationalCommandParameterObject(
                                 queryContext.Connection,
-                                queryContext.ParameterValues,
+                                queryContext.Parameters,
                                 readerColumns,
                                 queryContext.Context,
                                 queryContext.CommandLogger,
@@ -812,7 +812,7 @@ void GenerateCurrentElementIfPending()
                     return relationalCommand.ExecuteReader(
                         new RelationalCommandParameterObject(
                             queryContext.Connection,
-                            queryContext.ParameterValues,
+                            queryContext.Parameters,
                             readerColumns,
                             queryContext.Context,
                             queryContext.CommandLogger,
@@ -903,7 +903,7 @@ void GenerateCurrentElementIfPending()
                     return await relationalCommand.ExecuteReaderAsync(
                             new RelationalCommandParameterObject(
                                 queryContext.Connection,
-                                queryContext.ParameterValues,
+                                queryContext.Parameters,
                                 readerColumns,
                                 queryContext.Context,
                                 queryContext.CommandLogger,
diff --git a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs
index bcd74192e8..aec6e3cc14 100644
--- a/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalShapedQueryCompilingExpressionVisitor.cs
@@ -147,7 +147,7 @@ Expression GenerateNonQueryShaper(Expression nonQueryExpression, CommandSource c
                     return relationalCommand.ExecuteNonQuery(
                         new RelationalCommandParameterObject(
                             state.relationalQueryContext.Connection,
-                            state.relationalQueryContext.ParameterValues,
+                            state.relationalQueryContext.Parameters,
                             null,
                             state.relationalQueryContext.Context,
                             state.relationalQueryContext.CommandLogger,
@@ -214,7 +214,7 @@ Expression GenerateNonQueryShaper(Expression nonQueryExpression, CommandSource c
                     return relationalCommand.ExecuteNonQueryAsync(
                         new RelationalCommandParameterObject(
                             state.relationalQueryContext.Connection,
-                            state.relationalQueryContext.ParameterValues,
+                            state.relationalQueryContext.Parameters,
                             null,
                             state.relationalQueryContext.Context,
                             state.relationalQueryContext.CommandLogger,
@@ -662,7 +662,7 @@ static object GenerateNonNullParameterValue(Type type)
 
             Expression GenerateRelationalCommandExpression(Dictionary<string, object?> parameters, out bool canCache)
             {
-                var queryExpression = _relationalParameterBasedSqlProcessor.Optimize(select, parameters, out canCache);
+                var queryExpression = _relationalParameterBasedSqlProcessor.Process(select, parameters, out canCache);
                 if (!canCache)
                 {
                     return null!;
diff --git a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
index 3a2fdd6b72..c8f4ec3633 100644
--- a/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Relational/Query/RelationalSqlTranslatingExpressionVisitor.cs
@@ -2097,7 +2097,7 @@ MemberInitExpression memberInitExpression
         List<IComplexProperty>? complexPropertyChain,
         IProperty property)
     {
-        var baseValue = context.ParameterValues[baseParameterName];
+        var baseValue = context.Parameters[baseParameterName];
 
         if (complexPropertyChain is not null)
         {
@@ -2127,7 +2127,7 @@ MemberInitExpression memberInitExpression
         string baseParameterName,
         IProperty property)
     {
-        if (context.ParameterValues[baseParameterName] is not IEnumerable<TEntity> baseListParameter)
+        if (context.Parameters[baseParameterName] is not IEnumerable<TEntity> baseListParameter)
         {
             return null;
         }
diff --git a/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs b/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
index cb6690997f..48c1602fba 100644
--- a/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
+++ b/src/EFCore.Relational/Query/SqlExpressions/SqlParameterExpression.cs
@@ -24,7 +24,7 @@ public SqlParameterExpression(string name, Type type, RelationalTypeMapping? typ
     /// <summary>
     ///     Creates a new instance of the <see cref="SqlParameterExpression" /> class.
     /// </summary>
-    /// <param name="invariantName">The name of the parameter as it is recorded in <see cref="QueryContext.ParameterValues" />.</param>
+    /// <param name="invariantName">The name of the parameter as it is recorded in <see cref="QueryContext.Parameters" />.</param>
     /// <param name="name">
     ///     The name of the parameter as it will be set on <see cref="DbParameter.ParameterName" /> and inside the SQL as a placeholder
     ///     (before any additional placeholder character prefixing).
@@ -49,7 +49,7 @@ public SqlParameterExpression(string name, Type type, RelationalTypeMapping? typ
     }
 
     /// <summary>
-    ///     The name of the parameter as it is recorded in <see cref="QueryContext.ParameterValues" />.
+    ///     The name of the parameter as it is recorded in <see cref="QueryContext.Parameters" />.
     /// </summary>
     public string InvariantName { get; }
 
diff --git a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
index 062a79f1be..1f5cb874be 100644
--- a/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
+++ b/src/EFCore.Relational/Query/SqlNullabilityProcessor.cs
@@ -23,11 +23,11 @@ public class SqlNullabilityProcessor : ExpressionVisitor
     private readonly List<ColumnExpression> _nonNullableColumns;
     private readonly List<ColumnExpression> _nullValueColumns;
     private readonly ISqlExpressionFactory _sqlExpressionFactory;
+
     /// <summary>
     /// Tracks parameters for collection expansion, allowing reuse.
     /// </summary>
     private readonly Dictionary<SqlParameterExpression, List<SqlParameterExpression>> _collectionParameterExpansionMap;
-    private bool _canCache;
 
     /// <summary>
     ///     Creates a new instance of the <see cref="SqlNullabilityProcessor" /> class.
@@ -46,7 +46,7 @@ public class SqlNullabilityProcessor : ExpressionVisitor
         _nonNullableColumns = [];
         _nullValueColumns = [];
         _collectionParameterExpansionMap = [];
-        ParameterValues = null!;
+        ParametersFacade = null!;
     }
 
     /// <summary>
@@ -67,39 +67,26 @@ public class SqlNullabilityProcessor : ExpressionVisitor
     /// <summary>
     ///     Dictionary of current parameter values in use.
     /// </summary>
-    protected virtual Dictionary<string, object?> ParameterValues { get; private set; }
+    protected virtual CacheSafeParameterFacade ParametersFacade { get; private set; }
 
     /// <summary>
     ///     Processes a query expression to apply null semantics and optimize it.
     /// </summary>
     /// <param name="queryExpression">A query expression to process.</param>
-    /// <param name="parameterValues">A dictionary of parameter values in use.</param>
-    /// <param name="canCache">A bool value indicating whether the query expression can be cached.</param>
+    /// <param name="parametersFacade">A facade allowing access to parameters in a cache-safe way.</param>
     /// <returns>An optimized query expression.</returns>
-    public virtual Expression Process(
-        Expression queryExpression,
-        Dictionary<string, object?> parameterValues,
-        out bool canCache)
+    public virtual Expression Process(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
     {
-        _canCache = true;
         _nonNullableColumns.Clear();
         _nullValueColumns.Clear();
         _collectionParameterExpansionMap.Clear();
-        ParameterValues = parameterValues;
+        ParametersFacade = parametersFacade;
 
         var result = Visit(queryExpression);
 
-        canCache = _canCache;
-
         return result;
     }
 
-    /// <summary>
-    ///     Marks the select expression being processed as cannot be cached.
-    /// </summary>
-    protected virtual void DoNotCache()
-        => _canCache = false;
-
     /// <summary>
     ///     Adds a column to non nullable columns list to further optimizations can take the column as non-nullable.
     /// </summary>
@@ -128,11 +115,11 @@ protected override Expression VisitExtension(Expression node)
 
             case ValuesExpression { ValuesParameter: SqlParameterExpression valuesParameter } valuesExpression:
             {
-                DoNotCache();
                 Check.DebugAssert(valuesParameter.TypeMapping is not null);
                 Check.DebugAssert(valuesParameter.TypeMapping.ElementTypeMapping is not null);
                 var elementTypeMapping = (RelationalTypeMapping)valuesParameter.TypeMapping.ElementTypeMapping;
-                var values = ((IEnumerable?)ParameterValues[valuesParameter.Name])?.Cast<object>().ToList() ?? [];
+                var queryParameters = ParametersFacade.GetParametersAndDisableSqlCaching();
+                var values = ((IEnumerable?)queryParameters[valuesParameter.Name])?.Cast<object>().ToList() ?? [];
 
                 var intTypeMapping = (IntTypeMapping?)Dependencies.TypeMappingSource.FindMapping(typeof(int));
                 Check.DebugAssert(intTypeMapping is not null);
@@ -152,8 +139,8 @@ protected override Expression VisitExtension(Expression node)
                             // otherwise reuse it.
                             if (expandedParameters.Count <= i)
                             {
-                                var parameterName = Uniquifier.Uniquify(valuesParameter.Name, ParameterValues, int.MaxValue);
-                                ParameterValues.Add(parameterName, values[i]);
+                                var parameterName = Uniquifier.Uniquify(valuesParameter.Name, queryParameters, int.MaxValue);
+                                queryParameters.Add(parameterName, values[i]);
                                 var parameterExpression = new SqlParameterExpression(parameterName, values[i]?.GetType() ?? typeof(object), elementTypeMapping);
                                 expandedParameters.Add(parameterExpression);
                             }
@@ -624,7 +611,7 @@ protected virtual SqlExpression VisitIn(InExpression inExpression, bool allowOpt
 
                 case (false, true):
                 {
-                    // If the item is non-nullable but the projection is nullable, NULL will only be returned if the item wasn't found
+                    // If the item is non-nullable but the subquery projection is nullable, NULL will only be returned if the item wasn't found
                     // (as with the above case).
                     // Use as-is in optimized expansion (NULL is interpreted as false anyway), or compensate by coalescing NULL to false:
                     // WHERE NonNullable IN (SELECT Nullable FROM foo) -> WHERE COALESCE(NonNullable IN (SELECT Nullable FROM foo), false)
@@ -827,9 +814,9 @@ protected virtual SqlExpression VisitIn(InExpression inExpression, bool allowOpt
             {
                 // The InExpression has a values parameter. Expand it out, embedding its values as constants into the SQL; disable SQL
                 // caching.
-                DoNotCache();
                 var elementTypeMapping = (RelationalTypeMapping)inExpression.ValuesParameter.TypeMapping!.ElementTypeMapping!;
-                var values = ((IEnumerable?)ParameterValues[valuesParameter.Name])?.Cast<object>().ToList() ?? [];
+                var parameters = ParametersFacade.GetParametersAndDisableSqlCaching();
+                var values = ((IEnumerable?)parameters[valuesParameter.Name])?.Cast<object>().ToList() ?? [];
 
                 processedValues = [];
 
@@ -861,8 +848,8 @@ protected virtual SqlExpression VisitIn(InExpression inExpression, bool allowOpt
                             // otherwise reuse it.
                             if (expandedParameters.Count <= i)
                             {
-                                var parameterName = Uniquifier.Uniquify(valuesParameter.Name, ParameterValues, int.MaxValue);
-                                ParameterValues.Add(parameterName, values[i]);
+                                var parameterName = Uniquifier.Uniquify(valuesParameter.Name, parameters, int.MaxValue);
+                                parameters.Add(parameterName, values[i]);
                                 var parameterExpression = new SqlParameterExpression(parameterName, values[i]?.GetType() ?? typeof(object), elementTypeMapping);
                                 expandedParameters.Add(parameterExpression);
                             }
@@ -1423,28 +1410,24 @@ SqlExpression AddNullConcatenationProtection(SqlExpression argument, RelationalT
         bool allowOptimizedExpansion,
         out bool nullable)
     {
-        if (!ParameterValues.TryGetValue(sqlParameterExpression.Name, out var parameterValue))
+        if (ParametersFacade.IsParameterNull(sqlParameterExpression.Name))
         {
-            throw new UnreachableException(
-                $"Encountered SqlParameter with name '{sqlParameterExpression.Name}', but such a parameter does not exist.");
-        }
+            nullable = true;
 
-        nullable = parameterValue == null;
-
-        if (nullable)
-        {
             return _sqlExpressionFactory.Constant(
                 null,
                 sqlParameterExpression.Type,
                 sqlParameterExpression.TypeMapping);
         }
 
+        nullable = false;
+
         if (sqlParameterExpression.ShouldBeConstantized)
         {
-            DoNotCache();
+            var parameters = ParametersFacade.GetParametersAndDisableSqlCaching();
 
             return _sqlExpressionFactory.Constant(
-                parameterValue,
+                parameters[sqlParameterExpression.Name],
                 sqlParameterExpression.Type,
                 sensitive: true,
                 sqlParameterExpression.TypeMapping);
@@ -1522,7 +1505,7 @@ protected virtual bool PreferExistsToInWithCoalesce
     // Note that we can check parameter values for null since we cache by the parameter nullability; but we cannot do the same for bool.
     private bool IsNull(SqlExpression? expression)
         => expression is SqlConstantExpression { Value: null }
-            || expression is SqlParameterExpression { Name: string parameterName } && ParameterValues[parameterName] is null;
+            || expression is SqlParameterExpression { Name: string parameterName } && ParametersFacade.IsParameterNull(parameterName);
 
     private bool IsTrue(SqlExpression? expression)
         => expression is SqlConstantExpression { Value: true };
@@ -1820,11 +1803,14 @@ static bool TryNegate(ExpressionType expressionType, out ExpressionType result)
             }
             && projectedColumn.TableAlias == collectionTable.Alias
             && IsCollectionTable(collectionTable, out var collection)
-            && collection is SqlParameterExpression collectionParameter
-            && ParameterValues[collectionParameter.Name] is IList values)
+            && collection is SqlParameterExpression collectionParameter)
         {
-            // We're looking at a parameter beyond its simple nullability, so we can't use the 2nd-level cache for this query.
-            DoNotCache();
+            // We're looking at a parameter beyond its simple nullability, so we can't use the SQL cache for this query.
+            var parameters = ParametersFacade.GetParametersAndDisableSqlCaching();
+            if (parameters[collectionParameter.Name] is not IList values)
+            {
+                throw new UnreachableException($"Parameter '{collectionParameter.Name}' is not an IList.");
+            }
 
             IList? processedValues = null;
 
@@ -1864,7 +1850,7 @@ static bool TryNegate(ExpressionType expressionType, out ExpressionType result)
 
             var rewrittenParameter = new SqlParameterExpression(
                 collectionParameter.Name + "_without_nulls", collectionParameter.Type, collectionParameter.TypeMapping);
-            ParameterValues[rewrittenParameter.Name] = processedValues;
+            parameters[rewrittenParameter.Name] = processedValues;
             var rewrittenCollectionTable = UpdateParameterCollection(collectionTable, rewrittenParameter);
 
             // We clone the select expression since Update below doesn't create a pure copy, mutating the original as well (because of
@@ -1946,7 +1932,7 @@ private SqlExpression ProcessNullNotNull(SqlExpression sqlExpression, bool opera
                 // not_null_value_parameter is null -> false
                 // not_null_value_parameter is not null -> true
                 return _sqlExpressionFactory.Constant(
-                    ParameterValues[sqlParameterOperand.Name] == null ^ sqlUnaryExpression.OperatorType == ExpressionType.NotEqual,
+                    ParametersFacade.IsParameterNull(sqlParameterOperand.Name) ^ sqlUnaryExpression.OperatorType == ExpressionType.NotEqual,
                     sqlUnaryExpression.TypeMapping);
 
             case ColumnExpression columnOperand
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerParameterBasedSqlProcessor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerParameterBasedSqlProcessor.cs
index c932ab1665..ed57e0fee8 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerParameterBasedSqlProcessor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerParameterBasedSqlProcessor.cs
@@ -36,31 +36,21 @@ public class SqlServerParameterBasedSqlProcessor : RelationalParameterBasedSqlPr
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override Expression Optimize(
-        Expression queryExpression,
-        Dictionary<string, object?> parametersValues,
-        out bool canCache)
+    public override Expression Process(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
     {
-        var optimizedQueryExpression = new SkipTakeCollapsingExpressionVisitor(Dependencies.SqlExpressionFactory)
-            .Process(queryExpression, parametersValues, out var canCache2);
+        var afterZeroLimitConversion = new SqlServerZeroLimitConverter(Dependencies.SqlExpressionFactory)
+            .Process(queryExpression, parametersFacade);
 
-        optimizedQueryExpression = base.Optimize(optimizedQueryExpression, parametersValues, out canCache);
+        var afterBaseProcessing = base.Process(afterZeroLimitConversion, parametersFacade);
 
-        canCache &= canCache2;
+        var afterSearchConditionConversion = new SearchConditionConverter(Dependencies.SqlExpressionFactory)
+            .Visit(afterBaseProcessing);
 
-        return new SearchConditionConverter(Dependencies.SqlExpressionFactory).Visit(optimizedQueryExpression);
+        return afterSearchConditionConversion;
     }
 
     /// <inheritdoc />
-    protected override Expression ProcessSqlNullability(
-        Expression selectExpression,
-        Dictionary<string, object?> parametersValues,
-        out bool canCache)
-    {
-        Check.NotNull(selectExpression);
-        Check.NotNull(parametersValues);
-
-        return new SqlServerSqlNullabilityProcessor(Dependencies, Parameters, _sqlServerSingletonOptions).Process(
-            selectExpression, parametersValues, out canCache);
-    }
+    protected override Expression ProcessSqlNullability(Expression selectExpression, CacheSafeParameterFacade parametersFacade)
+        => new SqlServerSqlNullabilityProcessor(Dependencies, Parameters, _sqlServerSingletonOptions).Process(
+            selectExpression, parametersFacade);
 }
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlNullabilityProcessor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlNullabilityProcessor.cs
index 0fb3d4f51e..3527665d14 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlNullabilityProcessor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlNullabilityProcessor.cs
@@ -53,9 +53,9 @@ public class SqlServerSqlNullabilityProcessor : SqlNullabilityProcessor
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public override Expression Process(Expression queryExpression, Dictionary<string, object?> parameterValues, out bool canCache)
+    public override Expression Process(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
     {
-        var result = base.Process(queryExpression, parameterValues, out canCache);
+        var result = base.Process(queryExpression, parametersFacade);
         _openJsonAliasCounter = 0;
         return result;
     }
@@ -291,8 +291,9 @@ protected override SqlExpression VisitIn(InExpression inExpression, bool allowOp
         out List<SqlExpression>? constantsResult,
         out bool? containsNulls)
     {
-        DoNotCache();
-        var values = ((IEnumerable?)ParameterValues[valuesParameter.Name])?.Cast<object>().ToList() ?? [];
+        var parameters = ParametersFacade.GetParametersAndDisableSqlCaching();
+        var values = ((IEnumerable?)parameters[valuesParameter.Name])?.Cast<object>().ToList() ?? [];
+
         // SQL Server has limit on number of parameters in a query.
         // If we're over that limit, we switch to using single parameter
         // and processing it through JSON functions.
diff --git a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
index 8e4edd47f0..8b1abfc068 100644
--- a/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerSqlTranslatingExpressionVisitor.cs
@@ -482,7 +482,7 @@ SqlExpression CharIndexGreaterThanZero()
         QueryContext queryContext,
         string baseParameterName,
         StartsEndsWithContains methodType)
-        => queryContext.ParameterValues[baseParameterName] switch
+        => queryContext.Parameters[baseParameterName] switch
         {
             null => null,
 
diff --git a/src/EFCore.SqlServer/Query/Internal/SkipTakeCollapsingExpressionVisitor.cs b/src/EFCore.SqlServer/Query/Internal/SqlServerZeroLimitConverter.cs
similarity index 68%
rename from src/EFCore.SqlServer/Query/Internal/SkipTakeCollapsingExpressionVisitor.cs
rename to src/EFCore.SqlServer/Query/Internal/SqlServerZeroLimitConverter.cs
index 00ecaab9ee..f4eea232d2 100644
--- a/src/EFCore.SqlServer/Query/Internal/SkipTakeCollapsingExpressionVisitor.cs
+++ b/src/EFCore.SqlServer/Query/Internal/SqlServerZeroLimitConverter.cs
@@ -11,12 +11,11 @@ namespace Microsoft.EntityFrameworkCore.SqlServer.Query.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class SkipTakeCollapsingExpressionVisitor : ExpressionVisitor
+public class SqlServerZeroLimitConverter : ExpressionVisitor
 {
     private readonly ISqlExpressionFactory _sqlExpressionFactory;
 
-    private IReadOnlyDictionary<string, object?> _parameterValues;
-    private bool _canCache;
+    private CacheSafeParameterFacade _parametersFacade;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -24,10 +23,10 @@ public class SkipTakeCollapsingExpressionVisitor : ExpressionVisitor
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public SkipTakeCollapsingExpressionVisitor(ISqlExpressionFactory sqlExpressionFactory)
+    public SqlServerZeroLimitConverter(ISqlExpressionFactory sqlExpressionFactory)
     {
         _sqlExpressionFactory = sqlExpressionFactory;
-        _parameterValues = null!;
+        _parametersFacade = null!;
     }
 
     /// <summary>
@@ -36,19 +35,11 @@ public SkipTakeCollapsingExpressionVisitor(ISqlExpressionFactory sqlExpressionFa
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual Expression Process(
-        Expression queryExpression,
-        IReadOnlyDictionary<string, object?> parametersValues,
-        out bool canCache)
+    public virtual Expression Process(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
     {
-        _parameterValues = parametersValues;
-        _canCache = true;
+        _parametersFacade = parametersFacade;
 
-        var result = Visit(queryExpression);
-
-        canCache = _canCache;
-
-        return result;
+        return Visit(queryExpression);
     }
 
     /// <summary>
@@ -59,11 +50,11 @@ public SkipTakeCollapsingExpressionVisitor(ISqlExpressionFactory sqlExpressionFa
     /// </summary>
     protected override Expression VisitExtension(Expression extensionExpression)
     {
+        // SQL Server doesn't support 0 in the FETCH NEXT x ROWS ONLY clause. We use this clause when translating LINQ Take(), but
+        // only if there's also a Skip(), otherwise we translate to SQL TOP(x), which does allow 0.
+        // Check for this case, and replace with a false predicate (since no rows should be returned).
         if (extensionExpression is SelectExpression { Offset: not null, Limit: not null } selectExpression)
         {
-            // SQL Server doesn't support 0 in the FETCH NEXT x ROWS ONLY clause. We use this clause when translating LINQ Take(), but
-            // only if there's also a Skip(), otherwise we translate to SQL TOP(x), which does allow 0.
-            // Check for this case, and replace with a false predicate (since no rows should be returned).
             if (IsZero(selectExpression.Limit))
             {
                 return selectExpression.Update(
@@ -72,25 +63,18 @@ protected override Expression VisitExtension(Expression extensionExpression)
                     selectExpression.GroupBy,
                     selectExpression.GroupBy.Count > 0 ? _sqlExpressionFactory.Constant(false) : null,
                     selectExpression.Projection,
-                    new List<OrderingExpression>(0),
+                    orderings: [],
                     offset: null,
                     limit: null);
             }
 
             bool IsZero(SqlExpression? sqlExpression)
-            {
-                switch (sqlExpression)
+                => sqlExpression switch
                 {
-                    case SqlConstantExpression { Value: int intValue }:
-                        return intValue == 0;
-                    case SqlParameterExpression parameter:
-                        _canCache = false;
-                        return _parameterValues[parameter.Name] is 0;
-
-                    default:
-                        return false;
-                }
-            }
+                    SqlConstantExpression { Value: int i } => i == 0,
+                    SqlParameterExpression p => _parametersFacade.GetParametersAndDisableSqlCaching()[p.Name] is 0,
+                    _ => false
+                };
         }
 
         return base.VisitExtension(extensionExpression);
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteParameterBasedSqlProcessor.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteParameterBasedSqlProcessor.cs
index 3e62bf8e9a..5833215b9c 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteParameterBasedSqlProcessor.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteParameterBasedSqlProcessor.cs
@@ -30,9 +30,6 @@ public class SqliteParameterBasedSqlProcessor : RelationalParameterBasedSqlProce
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected override Expression ProcessSqlNullability(
-        Expression queryExpression,
-        Dictionary<string, object?> parametersValues,
-        out bool canCache)
-        => new SqliteSqlNullabilityProcessor(Dependencies, Parameters).Process(queryExpression, parametersValues, out canCache);
+    protected override Expression ProcessSqlNullability(Expression queryExpression, CacheSafeParameterFacade parametersFacade)
+        => new SqliteSqlNullabilityProcessor(Dependencies, Parameters).Process(queryExpression, parametersFacade);
 }
diff --git a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
index 0d04114979..ea89ab030f 100644
--- a/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Sqlite.Core/Query/Internal/SqliteSqlTranslatingExpressionVisitor.cs
@@ -448,7 +448,7 @@ protected override Expression VisitMethodCall(MethodCallExpression methodCallExp
         QueryContext queryContext,
         string baseParameterName,
         bool startsWith)
-        => queryContext.ParameterValues[baseParameterName] switch
+        => queryContext.Parameters[baseParameterName] switch
         {
             null => null,
 
diff --git a/src/EFCore/Query/Internal/CompiledQueryBase.cs b/src/EFCore/Query/Internal/CompiledQueryBase.cs
index 609f5f0e50..a7c8c478d3 100644
--- a/src/EFCore/Query/Internal/CompiledQueryBase.cs
+++ b/src/EFCore/Query/Internal/CompiledQueryBase.cs
@@ -67,9 +67,10 @@ protected CompiledQueryBase(LambdaExpression queryExpression)
 
         queryContext.CancellationToken = cancellationToken;
 
+        var queryParameters = queryContext.Parameters;
         for (var i = 0; i < parameters.Length; i++)
         {
-            queryContext.AddParameter(_queryExpression.Parameters[i + 1].Name!, parameters[i]);
+            queryParameters.Add(_queryExpression.Parameters[i + 1].Name!, parameters[i]);
         }
 
         return _executor.Executor(queryContext);
diff --git a/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs b/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs
index 3319a97ef4..44fdec7dbc 100644
--- a/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs
+++ b/src/EFCore/Query/Internal/ExpressionTreeFuncletizer.cs
@@ -96,7 +96,7 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
 
     private IQueryProvider? _currentQueryProvider;
     private State _state;
-    private IParameterValues _parameterValues = null!;
+    private Dictionary<string, object?> _parameters = null!;
 
     private readonly IModel _model;
     private readonly ContextParameterReplacer _contextParameterReplacer;
@@ -154,10 +154,10 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
     /// </remarks>
     public virtual Expression ExtractParameters(
         Expression expression,
-        IParameterValues parameterValues,
+        Dictionary<string, object?> parameters,
         bool parameterize,
         bool clearParameterizedValues)
-        => ExtractParameters(expression, parameterValues, parameterize, clearParameterizedValues, precompiledQuery: false);
+        => ExtractParameters(expression, parameters, parameterize, clearParameterizedValues, precompiledQuery: false);
 
     /// <summary>
     ///     Processes an expression tree, extracting parameters and evaluating evaluatable fragments as part of the pass.
@@ -172,13 +172,13 @@ public class ExpressionTreeFuncletizer : ExpressionVisitor
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
     public virtual Expression ExtractParameters(
         Expression expression,
-        IParameterValues parameterValues,
+        Dictionary<string, object?> parameters,
         bool parameterize,
         bool clearParameterizedValues,
         bool precompiledQuery)
     {
         Reset(clearParameterizedValues);
-        _parameterValues = parameterValues;
+        _parameters = parameters;
         _parameterize = parameterize;
         _calculatingPath = false;
         _precompiledQuery = precompiledQuery;
@@ -210,7 +210,7 @@ public virtual void ResetPathCalculation()
 
         // In precompilation mode we don't actually extract parameter values; but we do need to generate the parameter names, using the
         // same logic (and via the same code) used in parameter extraction, and that logic requires _parameterValues.
-        _parameterValues = new DummyParameterValues();
+        _parameters = new Dictionary<string, object?>();
     }
 
     /// <summary>
@@ -1955,7 +1955,7 @@ private static StateType CombineStateTypes(StateType stateType1, StateType state
                 };
 
                 // We still maintain _parameterValues since later parameter names are generated based on already-populated names.
-                _parameterValues.AddParameter(parameterName, null);
+                _parameters.Add(parameterName, null);
 
                 return evaluatableRoot;
             }
@@ -1972,7 +1972,7 @@ private static StateType CombineStateTypes(StateType stateType1, StateType state
                 && !evaluatableRoot.Type.IsValueType
                 && evaluatableRoot is MemberExpression { Member: IParameterNullabilityInfo { IsNonNullableReferenceType: true } };
 
-            _parameterValues.AddParameter(parameterName, value);
+            _parameters.Add(parameterName, value);
 
             return _parameterizedValues[evaluatableRoot] = new QueryParameterExpression(
                 parameterName,
@@ -2330,15 +2330,4 @@ private sealed class ContextParameterReplacer(Type contextType) : ExpressionVisi
                     ? ContextParameterExpression
                     : base.Visit(expression);
     }
-
-    private sealed class DummyParameterValues : IParameterValues
-    {
-        private readonly Dictionary<string, object?> _parameterValues = new();
-
-        public Dictionary<string, object?> ParameterValues
-            => _parameterValues;
-
-        public void AddParameter(string name, object? value)
-            => _parameterValues.Add(name, value);
-    }
 }
diff --git a/src/EFCore/Query/Internal/IParameterValues.cs b/src/EFCore/Query/Internal/IParameterValues.cs
deleted file mode 100644
index ec5a3eeb33..0000000000
--- a/src/EFCore/Query/Internal/IParameterValues.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-// Licensed to the .NET Foundation under one or more agreements.
-// The .NET Foundation licenses this file to you under the MIT license.
-
-namespace Microsoft.EntityFrameworkCore.Query.Internal;
-
-/// <summary>
-///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-///     any release. You should only use it directly in your code with extreme caution and knowing that
-///     doing so can result in application failures when updating to a new Entity Framework Core release.
-/// </summary>
-public interface IParameterValues
-{
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    Dictionary<string, object?> ParameterValues { get; }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    void AddParameter(string name, object? value);
-}
diff --git a/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs b/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
index 48211e9b30..5f9baa1a5c 100644
--- a/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
+++ b/src/EFCore/Query/Internal/NavigationExpandingExpressionVisitor.cs
@@ -56,7 +56,7 @@ public partial class NavigationExpandingExpressionVisitor : ExpressionVisitor
 
     private readonly Dictionary<QueryFiltersCacheKey, LambdaExpression> _parameterizedQueryFilterPredicateCache = [];
 
-    private readonly Parameters _parameters = new();
+    private readonly Dictionary<string, object?> _parameters = new();
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -168,7 +168,7 @@ public virtual Expression Expand(Expression query)
                     QueryContextContextPropertyInfo),
                 _queryCompilationContext.ContextType);
 
-        foreach (var (key, value) in _parameters.ParameterValues)
+        foreach (var (key, value) in _parameters)
         {
             var lambda = (LambdaExpression)value!;
             var remappedLambdaBody = ReplacingExpressionVisitor.Replace(
@@ -2281,35 +2281,15 @@ private static Expression SnapshotExpression(Expression selector)
     }
 
     private static EntityReference? UnwrapEntityReference(Expression? expression)
-    {
-        switch (expression)
+        => expression switch
         {
-            case EntityReference entityReference:
-                return entityReference;
-
-            case NavigationTreeExpression navigationTreeExpression:
-                return UnwrapEntityReference(navigationTreeExpression.Value);
-
-            case NavigationExpansionExpression navigationExpansionExpression
-                when navigationExpansionExpression.CardinalityReducingGenericMethodInfo != null:
-                return UnwrapEntityReference(navigationExpansionExpression.PendingSelector);
-
-            case OwnedNavigationReference ownedNavigationReference:
-                return ownedNavigationReference.EntityReference;
+            EntityReference entityReference => entityReference,
+            NavigationTreeExpression navigationTreeExpression => UnwrapEntityReference(navigationTreeExpression.Value),
+            NavigationExpansionExpression navigationExpansionExpression
+                when navigationExpansionExpression.CardinalityReducingGenericMethodInfo is not null
+                => UnwrapEntityReference(navigationExpansionExpression.PendingSelector),
+            OwnedNavigationReference ownedNavigationReference => ownedNavigationReference.EntityReference,
 
-            default:
-                return null;
-        }
-    }
-
-    private sealed class Parameters : IParameterValues
-    {
-        private readonly Dictionary<string, object?> _parameterValues = new Dictionary<string, object?>();
-
-        public Dictionary<string, object?> ParameterValues
-            => _parameterValues;
-
-        public void AddParameter(string name, object? value)
-            => _parameterValues.Add(name, value);
-    }
+            _ => null,
+        };
 }
diff --git a/src/EFCore/Query/Internal/QueryCompiler.cs b/src/EFCore/Query/Internal/QueryCompiler.cs
index 950c7bebde..4476f54b6f 100644
--- a/src/EFCore/Query/Internal/QueryCompiler.cs
+++ b/src/EFCore/Query/Internal/QueryCompiler.cs
@@ -74,7 +74,7 @@ private TResult ExecuteCore<TResult>(Expression query, bool async, CancellationT
 
         queryContext.CancellationToken = cancellationToken;
 
-        var queryAfterExtraction = ExtractParameters(query, queryContext, _logger);
+        var queryAfterExtraction = ExtractParameters(query, queryContext.Parameters, _logger);
 
         var compiledQuery
             = _compiledQueryCache
@@ -95,7 +95,9 @@ var compiledQuery
     /// </summary>
     public virtual Func<QueryContext, TResult> CreateCompiledQuery<TResult>(Expression query)
     {
-        var queryAfterExtraction = ExtractParameters(query, _queryContextFactory.Create(), _logger, compiledQuery: true);
+        var queryContext = _queryContextFactory.Create();
+
+        var queryAfterExtraction = ExtractParameters(query, queryContext.Parameters, _logger, compiledQuery: true);
 
         return CompileQueryCore<TResult>(_database, queryAfterExtraction, _model, false);
     }
@@ -108,7 +110,9 @@ var compiledQuery
     /// </summary>
     public virtual Func<QueryContext, TResult> CreateCompiledAsyncQuery<TResult>(Expression query)
     {
-        var queryAfterExtraction = ExtractParameters(query, _queryContextFactory.Create(), _logger, compiledQuery: true);
+        var queryContext = _queryContextFactory.Create();
+
+        var queryAfterExtraction = ExtractParameters(query, queryContext.Parameters, _logger, compiledQuery: true);
 
         return CompileQueryCore<TResult>(_database, queryAfterExtraction, _model, true);
     }
@@ -135,9 +139,10 @@ var compiledQuery
     [Experimental(EFDiagnostics.PrecompiledQueryExperimental)]
     public virtual Expression<Func<QueryContext, TResult>> PrecompileQuery<TResult>(Expression query, bool async)
     {
+        var queryContext = _queryContextFactory.Create();
+
         query = new ExpressionTreeFuncletizer(_model, _evaluatableExpressionFilter, _contextType, generateContextAccessors: false, _logger)
-            .ExtractParameters(
-                query, _queryContextFactory.Create(), parameterize: true, clearParameterizedValues: true, precompiledQuery: true);
+            .ExtractParameters(query, queryContext.Parameters, parameterize: true, clearParameterizedValues: true, precompiledQuery: true);
 
         return _database.CompileQueryExpression<TResult>(query, async);
     }
@@ -150,10 +155,10 @@ var compiledQuery
     /// </summary>
     public virtual Expression ExtractParameters(
         Expression query,
-        IParameterValues parameterValues,
+        Dictionary<string, object?> parameters,
         IDiagnosticsLogger<DbLoggerCategory.Query> logger,
         bool compiledQuery = false,
         bool generateContextAccessors = false)
         => new ExpressionTreeFuncletizer(_model, _evaluatableExpressionFilter, _contextType, generateContextAccessors: false, logger)
-            .ExtractParameters(query, parameterValues, parameterize: !compiledQuery, clearParameterizedValues: true);
+            .ExtractParameters(query, parameters, parameterize: !compiledQuery, clearParameterizedValues: true);
 }
diff --git a/src/EFCore/Query/QueryCompilationContext.cs b/src/EFCore/Query/QueryCompilationContext.cs
index 177ce56325..88545f5ee4 100644
--- a/src/EFCore/Query/QueryCompilationContext.cs
+++ b/src/EFCore/Query/QueryCompilationContext.cs
@@ -258,14 +258,19 @@ private Expression InsertRuntimeParameters(Expression query)
                     .Select(
                         kv =>
                             Expression.Call(
-                                QueryContextParameter,
-                                QueryContextAddParameterMethodInfo,
+                                Expression.Property(
+                                    QueryContextParameter,
+                                    QueryContextParametersProperty),
+                                ParameterDictionaryAddMethod,
                                 Expression.Constant(kv.Key),
                                 Expression.Convert(Expression.Invoke(kv.Value, QueryContextParameter), typeof(object))))
                     .Append(query));
 
-    private static readonly MethodInfo QueryContextAddParameterMethodInfo
-        = typeof(QueryContext).GetTypeInfo().GetDeclaredMethod(nameof(QueryContext.AddParameter))!;
+    private static readonly PropertyInfo QueryContextParametersProperty
+        = typeof(QueryContext).GetProperty(nameof(QueryContext.Parameters))!;
+
+    private static readonly MethodInfo ParameterDictionaryAddMethod
+        = typeof(Dictionary<string, object?>).GetMethod(nameof(Dictionary<string, object?>.Add))!;
 
     [DebuggerDisplay("{Microsoft.EntityFrameworkCore.Query.ExpressionPrinter.Print(this), nq}")]
     private sealed class NotTranslatedExpressionType : Expression, IPrintableExpression
diff --git a/src/EFCore/Query/QueryContext.cs b/src/EFCore/Query/QueryContext.cs
index 87724f2489..f66888cff3 100644
--- a/src/EFCore/Query/QueryContext.cs
+++ b/src/EFCore/Query/QueryContext.cs
@@ -19,9 +19,8 @@ namespace Microsoft.EntityFrameworkCore.Query;
 ///     See <see href="https://aka.ms/efcore-docs-providers">Implementation of database providers and extensions</see>
 ///     and <see href="https://aka.ms/efcore-docs-how-query-works">How EF Core queries work</see> for more information and examples.
 /// </remarks>
-public abstract class QueryContext : IParameterValues
+public abstract class QueryContext
 {
-    private readonly Dictionary<string, object?> _parameterValues = new Dictionary<string, object?>();
     private IStateManager? _stateManager;
 
     /// <summary>
@@ -41,10 +40,15 @@ protected QueryContext(QueryContextDependencies dependencies)
     }
 
     /// <summary>
-    ///     The current DbContext in using while executing the query.
+    ///     The current <see cref="DbContext" /> in using while executing the query.
     /// </summary>
     public virtual DbContext Context { get; }
 
+    /// <summary>
+    ///     The query parameter used in the query query.
+    /// </summary>
+    public virtual Dictionary<string, object?> Parameters { get; } = new();
+
     /// <summary>
     ///     Dependencies for this service.
     /// </summary>
@@ -94,20 +98,6 @@ public virtual IDiagnosticsLogger<DbLoggerCategory.Database.Command> CommandLogg
     public virtual IDiagnosticsLogger<DbLoggerCategory.Query> QueryLogger
         => Dependencies.QueryLogger;
 
-    /// <summary>
-    ///     The parameter values to use while executing the query.
-    /// </summary>
-    public virtual Dictionary<string, object?> ParameterValues
-        => _parameterValues;
-
-    /// <summary>
-    ///     Adds a parameter to <see cref="ParameterValues" /> for this query.
-    /// </summary>
-    /// <param name="name">The name.</param>
-    /// <param name="value">The value.</param>
-    public virtual void AddParameter(string name, object? value)
-        => _parameterValues.Add(name, value);
-
     /// <summary>
     ///     Initializes the <see cref="IStateManager" /> to be used with this QueryContext.
     /// </summary>
