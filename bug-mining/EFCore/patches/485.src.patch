diff --git a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
index 2224c1ffd7..deef99e67d 100644
--- a/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
+++ b/src/EFCore.Design/Scaffolding/Internal/CSharpRuntimeModelCodeGenerator.cs
@@ -546,7 +546,8 @@ private string GenerateEntityType(IEntityType entityType, string @namespace, Dic
             .AppendLine("{");
         using (mainBuilder.Indent())
         {
-            CreateEntityType(entityType, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, nullable);
+            var memberAccessReplacements = new Dictionary<MemberInfo, QualifiedName>();
+            CreateEntityType(entityType, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, memberAccessReplacements, nullable);
 
             foreach (var complexProperty in entityType.GetDeclaredComplexProperties())
             {
@@ -556,16 +557,16 @@ private string GenerateEntityType(IEntityType entityType, string @namespace, Dic
             var foreignKeyNumber = 1;
             foreach (var foreignKey in entityType.GetDeclaredForeignKeys())
             {
-                CreateForeignKey(foreignKey, foreignKeyNumber++, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, className, nullable);
+                CreateForeignKey(foreignKey, foreignKeyNumber++, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, memberAccessReplacements, className, nullable);
             }
 
             var navigationNumber = 1;
             foreach (var navigation in entityType.GetDeclaredSkipNavigations())
             {
-                CreateSkipNavigation(navigation, navigationNumber++, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, className, nullable);
+                CreateSkipNavigation(navigation, navigationNumber++, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, memberAccessReplacements, className, nullable);
             }
 
-            CreateAnnotations(entityType, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, nullable);
+            CreateAnnotations(entityType, @namespace, mainBuilder, methodBuilder, namespaces, entityClassNames, memberAccessReplacements, nullable);
 
             var methods = methodBuilder.ToString();
             if (!string.IsNullOrEmpty(methods))
@@ -592,6 +593,7 @@ private string GenerateEntityType(IEntityType entityType, string @namespace, Dic
         IndentedStringBuilder methodBuilder,
         SortedSet<string> namespaces,
         Dictionary<ITypeBase, string> configurationClassNames,
+        Dictionary<MemberInfo, QualifiedName>? memberAccessReplacements,
         bool nullable)
     {
         mainBuilder
@@ -634,12 +636,12 @@ private string GenerateEntityType(IEntityType entityType, string @namespace, Dic
 
             foreach (var property in entityType.GetDeclaredProperties())
             {
-                Create(property, memberAccessReplacements: null, parameters);
+                Create(property, memberAccessReplacements, parameters);
             }
 
             foreach (var property in entityType.GetDeclaredServiceProperties())
             {
-                Create(property, memberAccessReplacements: null, parameters);
+                Create(property, memberAccessReplacements, parameters);
             }
 
             foreach (var complexProperty in entityType.GetDeclaredComplexProperties())
@@ -653,6 +655,16 @@ private string GenerateEntityType(IEntityType entityType, string @namespace, Dic
                     .AppendLine(");");
             }
 
+            foreach (var navigation in entityType.GetDeclaredNavigations())
+            {
+                CreatePrivateAccessors(navigation, memberAccessReplacements, parameters);
+            }
+
+            foreach (var navigation in entityType.GetDeclaredSkipNavigations())
+            {
+                CreatePrivateAccessors(navigation, memberAccessReplacements, parameters);
+            }
+
             foreach (var key in entityType.GetDeclaredKeys())
             {
                 Create(key, parameters, nullable);
@@ -1148,14 +1160,17 @@ private void
         SetPropertyBaseProperties(
         IPropertyBase property,
         Dictionary<MemberInfo, QualifiedName>? memberAccessReplacements,
-        CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
+        CSharpRuntimeAnnotationCodeGeneratorParameters parameters,
+        bool createPrivateAccessors = true)
     {
         var variableName = parameters.TargetName;
         var mainBuilder = parameters.MainBuilder;
+        var unsafeAccessors = new HashSet<string>();
+
         if (!property.IsShadowProperty()
             && property is not IServiceProperty) // Service properties don't use property accessors
         {
-            memberAccessReplacements = CreatePrivateAccessors(property, memberAccessReplacements, parameters);
+            memberAccessReplacements = CreatePrivateAccessors(property, memberAccessReplacements, parameters, create: createPrivateAccessors);
 
             ClrPropertyGetterFactory.Instance.Create(
                 property,
@@ -1164,9 +1179,6 @@ private void
                 out var structuralGetterExpression,
                 out var hasStructuralSentinelExpression);
 
-            // TODO
-            var unsafeAccessors = new HashSet<string>();
-
             mainBuilder
                 .Append(variableName).AppendLine(".SetGetter(")
                 .IncrementIndent()
@@ -1197,7 +1209,10 @@ private void
                 .AppendLines(_code.Expression(materializationSetterExpression, parameters.Namespaces, unsafeAccessors, (IReadOnlyDictionary<object, string>)parameters.ScopeVariables, memberAccessReplacements), skipFinalNewline: true)
                 .AppendLine(");")
                 .DecrementIndent();
+        }
 
+        if (property is not IServiceProperty)
+        {
             PropertyAccessorsFactory.Instance.Create(property,
                 out var currentValueGetter,
                 out var preStoreGeneratedCurrentValueGetter,
@@ -1223,6 +1238,9 @@ private void
                     : _code.Expression(valueBufferGetter, parameters.Namespaces, unsafeAccessors, (IReadOnlyDictionary<object, string>)parameters.ScopeVariables, memberAccessReplacements), skipFinalNewline: true)
                 .AppendLine(");")
                 .DecrementIndent();
+
+            Check.DebugAssert(unsafeAccessors.Count == 0, "Generated unsafe accessors not handled: " +
+                string.Join(Environment.NewLine, unsafeAccessors));
         }
 
         var propertyIndexes = ((IRuntimePropertyBase)property).PropertyIndexes;
@@ -1319,13 +1337,13 @@ private void
                 {
                     AddNamespace(typeof(UnsafeAccessorAttribute), parameters.Namespaces);
                     AddNamespace(field.FieldType, parameters.Namespaces);
-                    AddNamespace(property.DeclaringType.ClrType, parameters.Namespaces);
+                    AddNamespace(field.DeclaringType!, parameters.Namespaces);
 
                     parameters.MethodBuilder
                         .AppendLine()
                         .AppendLine($"[UnsafeAccessor(UnsafeAccessorKind.Field, Name = \"{field.Name}\")]")
                         .Append($"public static extern ref {_code.Reference(field.FieldType)} {methodName}(")
-                        .AppendLine($"{_code.Reference(property.DeclaringType.ClrType)} @this);");
+                        .AppendLine($"{_code.Reference(field.DeclaringType!)} @this);");
 
                     return qualifiedName;
                 }
@@ -1357,7 +1375,7 @@ private void
                 {
                     AddNamespace(typeof(UnsafeAccessorAttribute), parameters.Namespaces);
                     AddNamespace(methodInfo.ReturnType, parameters.Namespaces);
-                    AddNamespace(property.DeclaringType.ClrType, parameters.Namespaces);
+                    AddNamespace(methodInfo.DeclaringType!, parameters.Namespaces);
                     foreach (var parameter in methodInfo.GetParameters())
                     {
                         AddNamespace(parameter.ParameterType, parameters.Namespaces);
@@ -1371,7 +1389,7 @@ private void
                         .AppendLine()
                         .AppendLine($"[UnsafeAccessor(UnsafeAccessorKind.Method, Name = \"{methodInfo.Name}\")]")
                         .Append($"public static extern {returnType} {methodName}(")
-                        .Append($"{_code.Reference(property.DeclaringType.ClrType)} @this");
+                        .Append($"{_code.Reference(methodInfo.DeclaringType!)} @this");
 
                     if (methodInfo.GetParameters().Length > 0)
                     {
@@ -1825,6 +1843,7 @@ private void
         IndentedStringBuilder methodBuilder,
         SortedSet<string> namespaces,
         Dictionary<ITypeBase, string> configurationClassNames,
+        Dictionary<MemberInfo, QualifiedName> memberAccessReplacements,
         string className,
         bool nullable)
     {
@@ -1921,13 +1940,13 @@ private void
             var navigation = foreignKey.DependentToPrincipal;
             if (navigation != null)
             {
-                Create(navigation, foreignKeyVariable, parameters with { TargetName = declaringEntityType });
+                Create(navigation, foreignKeyVariable, memberAccessReplacements, parameters with { TargetName = declaringEntityType });
             }
 
             navigation = foreignKey.PrincipalToDependent;
             if (navigation != null)
             {
-                Create(navigation, foreignKeyVariable, parameters with { TargetName = principalEntityType });
+                Create(navigation, foreignKeyVariable, memberAccessReplacements, parameters with { TargetName = principalEntityType });
             }
 
             CreateAnnotations(
@@ -1948,6 +1967,7 @@ private void
     private void Create(
         INavigation navigation,
         string foreignKeyVariable,
+        Dictionary<MemberInfo, QualifiedName> memberAccessReplacements,
         CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
     {
         var mainBuilder = parameters.MainBuilder;
@@ -1980,8 +2000,6 @@ private void
 
         var navigationParameters = parameters with { TargetName = navigationVariable };
 
-        var memberAccessReplacements = CreatePrivateAccessors(navigation, null, navigationParameters, create: false, qualify: true);
-
         SetNavigationBaseProperties(navigation, memberAccessReplacements, navigationParameters);
 
         CreateAnnotations(navigation, _annotationCodeGenerator.Generate, navigationParameters);
@@ -1989,10 +2007,11 @@ private void
 
     private void SetNavigationBaseProperties(
         INavigationBase navigation,
-        Dictionary<MemberInfo, QualifiedName>? memberAccessReplacements,
+        Dictionary<MemberInfo, QualifiedName> memberAccessReplacements,
         CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
     {
-        SetPropertyBaseProperties(navigation, memberAccessReplacements, parameters);
+        CreatePrivateAccessors(navigation, memberAccessReplacements, parameters, create: false, qualify: true);
+        SetPropertyBaseProperties(navigation, memberAccessReplacements, parameters, createPrivateAccessors: false);
 
         if (!navigation.IsCollection)
         {
@@ -2011,7 +2030,6 @@ private void
             out var createAndSetCollection,
             out var createCollection);
 
-        // TODO
         var unsafeAccessors = new HashSet<string>();
 
         AddNamespace(propertyType, parameters.Namespaces);
@@ -2040,6 +2058,9 @@ private void
                 : _code.Expression(createCollection, parameters.Namespaces, unsafeAccessors, (IReadOnlyDictionary<object, string>)parameters.ScopeVariables, memberAccessReplacements), skipFinalNewline: true)
             .AppendLine(");")
             .DecrementIndent();
+
+        Check.DebugAssert(unsafeAccessors.Count == 0, "Generated unsafe accessors not handled: " +
+            string.Join(Environment.NewLine, unsafeAccessors));
     }
 
     private void CreateSkipNavigation(
@@ -2050,6 +2071,7 @@ private void
         IndentedStringBuilder methodBuilder,
         SortedSet<string> namespaces,
         Dictionary<ITypeBase, string> configurationClassNames,
+        Dictionary<MemberInfo, QualifiedName> memberAccessReplacements,
         string className,
         bool nullable)
     {
@@ -2070,11 +2092,15 @@ private void
             var scopeVariables = new BidirectionalDictionary<object, string>
             {
                 { navigation.DeclaringEntityType, declaringEntityType },
-                { navigation.TargetEntityType, targetEntityType },
                 { navigation.JoinEntityType, joinEntityType },
                 { navigation, navigationVariable }
             };
 
+            if (navigation.TargetEntityType != navigation.DeclaringEntityType)
+            {
+                scopeVariables.Add(navigation.TargetEntityType, targetEntityType);
+            }
+
             var parameters = new CSharpRuntimeAnnotationCodeGeneratorParameters(
                 navigationVariable,
                 className,
@@ -2154,8 +2180,6 @@ private void
                 .AppendLine("}")
                 .AppendLine();
 
-            var memberAccessReplacements = new Dictionary<MemberInfo, QualifiedName>();
-
             SetNavigationBaseProperties(navigation, memberAccessReplacements, parameters);
 
             CreateAnnotations(navigation, _annotationCodeGenerator.Generate, parameters);
@@ -2197,6 +2221,7 @@ private void Create(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParame
         IndentedStringBuilder methodBuilder,
         SortedSet<string> namespaces,
         Dictionary<ITypeBase, string> configurationClassNames,
+        Dictionary<MemberInfo, QualifiedName> memberAccessReplacements,
         bool nullable)
     {
         mainBuilder.AppendLine()
@@ -2222,8 +2247,7 @@ private void Create(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParame
                     configurationClassNames,
                     nullable);
 
-            Dictionary<MemberInfo, QualifiedName>? memberAccessReplacements = null;
-            memberAccessReplacements = GenerateMemberReferences(entityType, memberAccessReplacements, parameters);
+            GenerateMemberReferences(entityType, memberAccessReplacements, parameters);
 
             foreach (var key in entityType.GetDeclaredKeys())
             {
@@ -2233,38 +2257,51 @@ private void Create(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParame
                     keyVariableName = _code.Identifier("key", key, parameters.ScopeObjects);
 
                     mainBuilder
-                        .Append($"var {keyVariableName} = ")
-                        .Append(entityTypeVariable).Append(".FindKey(");
+                        .Append($"var {keyVariableName} = {entityTypeVariable}.{nameof(RuntimeEntityType.FindKey)}(");
                     FindProperties(entityTypeVariable, key.Properties, mainBuilder, nullable, parameters.ScopeVariables);
                     mainBuilder.AppendLine(");");
                 }
 
+                var createKeyValueFactoryMethod = nameof(KeyValueFactoryFactory.CreateCompositeFactory);
+                var keyType = key.GetKeyType();
+                if (key.Properties.Count == 1)
+                {
+                    AddNamespace(keyType, parameters.Namespaces);
+
+                    if (keyType.IsNullableType())
+                    {
+                        var nonNullableKeyType = keyType.UnwrapNullableType();
+                        if (nonNullableKeyType == keyType)
+                        {
+                            // This is just a dummy type to satisfy the generic constraint, it won't actually be used
+                            nonNullableKeyType = typeof(int);
+                        }
+
+                        createKeyValueFactoryMethod =
+                            $"{nameof(KeyValueFactoryFactory.CreateSimpleNullableFactory)}<{_code.Reference(keyType)}, {_code.Reference(nonNullableKeyType)}>";
+                    }
+                    else
+                    {
+                        createKeyValueFactoryMethod =
+                            $"{nameof(KeyValueFactoryFactory.CreateSimpleNonNullableFactory)}<{_code.Reference(keyType)}>";
+                    }
+                }
+
                 mainBuilder
-                    .Append(keyVariableName)
-                    .Append(".SetPrincipalKeyValueFactory(")
-                    .Append(_code.Reference(typeof(KeyValueFactoryFactory)))
-                    .Append(".Create<")
-                    .Append(_code.Reference(key.GetKeyType()))
-                    .Append(">(")
-                    .Append(keyVariableName)
-                    .AppendLine("));");
+                    .Append($"{keyVariableName}.{nameof(RuntimeKey.SetPrincipalKeyValueFactory)}(")
+                    .AppendLine($"{_code.Reference(typeof(KeyValueFactoryFactory))}.{createKeyValueFactoryMethod}({keyVariableName}));");
 
                 mainBuilder
-                    .Append(keyVariableName)
-                    .Append(".SetIdentityMapFactory(")
-                    .Append(_code.Reference(typeof(IdentityMapFactoryFactory)))
-                    .Append(".CreateFactory<")
-                    .Append(_code.Reference(key.GetKeyType()))
-                    .Append(">(")
-                    .Append(keyVariableName)
-                    .AppendLine("));");
+                    .Append($"{keyVariableName}.{nameof(RuntimeKey.SetIdentityMapFactory)}(")
+                    .Append($"{_code.Reference(typeof(IdentityMapFactoryFactory))}.{nameof(IdentityMapFactoryFactory.CreateFactory)}")
+                    .AppendLine($"<{_code.Reference(keyType)}>({keyVariableName}));");
             }
 
             foreach (var navigation in entityType.GetNavigations())
             {
                 var variableName = _code.Identifier(navigation.Name, navigation, parameters.ScopeObjects, capitalize: false);
 
-                memberAccessReplacements = CreatePrivateAccessors(navigation, memberAccessReplacements, parameters, create: navigation.DeclaringType == entityType, qualify: navigation.DeclaringType != entityType);
+                CreatePrivateAccessors(navigation, memberAccessReplacements, parameters, create: false, qualify: navigation.DeclaringType != entityType);
 
                 mainBuilder
                     .Append($"var {variableName} = ")
@@ -2339,8 +2376,8 @@ private void Create(ITrigger trigger, CSharpRuntimeAnnotationCodeGeneratorParame
 
             CreateAnnotations(entityType, _annotationCodeGenerator.Generate, parameters);
 
-            // TODO: Output any additional unsafe accessors
-            Check.DebugAssert(unsafeAccessors.Count == 0, "Generated unsafe accessors not handled");
+            Check.DebugAssert(unsafeAccessors.Count == 0, "Generated unsafe accessors not handled: " +
+                string.Join(Environment.NewLine, unsafeAccessors));
 
             mainBuilder
                 .AppendLine()
diff --git a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
index 943f9e11e0..a2632f662a 100644
--- a/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore.Relational/Design/Internal/RelationalCSharpRuntimeAnnotationCodeGenerator.cs
@@ -2,6 +2,7 @@
 // The .NET Foundation licenses this file to you under the MIT license.
 
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Design.Internal;
 
@@ -378,18 +379,12 @@ public virtual void Generate(IRelationalModel model, CSharpRuntimeAnnotationCode
     public virtual void Generate(ITableBase table, CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
         => GenerateSimpleAnnotations(parameters);
 
-    private string GetOrCreate(
+    private string Create(
         ITable table,
         CSharpRuntimeAnnotationCodeGeneratorParameters parameters)
     {
-        var metadataVariables = parameters.ScopeVariables;
-        if (metadataVariables.TryGetValue(table, out var tableVariable))
-        {
-            return tableVariable;
-        }
-
         var code = Dependencies.CSharpHelper;
-        tableVariable = code.Identifier(table.Name + "Table", table, parameters.ScopeObjects, capitalize: false);
+        var tableVariable = code.Identifier(table.Name + "Table", table, parameters.ScopeObjects, capitalize: false);
         var mainBuilder = parameters.MainBuilder;
         mainBuilder
             .Append($"var {tableVariable} = new Table({code.Literal(table.Name)}, {code.Literal(table.Schema)}, ")
@@ -402,26 +397,6 @@ public virtual void Generate(ITableBase table, CSharpRuntimeAnnotationCodeGenera
             Create(column, tableParameters);
         }
 
-        foreach (var uniqueConstraint in table.UniqueConstraints)
-        {
-            Create(uniqueConstraint, uniqueConstraint.Columns.Select(c => metadataVariables[c]), tableParameters);
-        }
-
-        foreach (var index in table.Indexes)
-        {
-            Create(index, index.Columns.Select(c => metadataVariables[c]), tableParameters);
-        }
-
-        foreach (var trigger in table.Triggers)
-        {
-            var entityTypeVariable = metadataVariables[trigger.EntityType];
-
-            var triggerName = trigger.GetDatabaseName(StoreObjectIdentifier.Table(table.Name, table.Schema));
-            mainBuilder
-                .Append($"{tableVariable}.Triggers.Add({code.Literal(triggerName)}, ")
-                .AppendLine($"{entityTypeVariable}.FindDeclaredTrigger({code.Literal(trigger.ModelName)}));");
-        }
-
         CreateAnnotations(
             table,
             Generate,
@@ -746,6 +721,13 @@ public virtual void Generate(IColumnBase column, CSharpRuntimeAnnotationCodeGene
             .AppendLine(";")
             .AppendLine($"{parameters.TargetName}.Columns.Add({code.Literal(column.Name)}, {columnVariable});");
 
+        AddNamespace(typeof(ColumnAccessorsFactory), parameters.Namespaces);
+        AddNamespace(column.ProviderClrType, parameters.Namespaces);
+        var columnClrType = code.Reference(column.ProviderClrType);
+        mainBuilder
+            .Append(columnVariable).Append(".").Append(nameof(Column.Accessors)).Append(" = ")
+            .AppendLine($"{nameof(ColumnAccessorsFactory)}.CreateGeneric<{columnClrType}>({columnVariable});");
+
         CreateAnnotations(
             column,
             Generate,
@@ -936,7 +918,7 @@ public virtual void Generate(IStoreStoredProcedureParameter parameter, CSharpRun
         var uniqueConstraintVariable = code.Identifier(uniqueConstraint.Name, uniqueConstraint, parameters.ScopeObjects, capitalize: false);
         var mainBuilder = parameters.MainBuilder;
         mainBuilder
-            .Append("var ").Append(uniqueConstraintVariable).Append(" = new ").Append("UniqueConstraint").Append("(")
+            .Append("var ").Append(uniqueConstraintVariable).Append(" = new UniqueConstraint(")
             .Append(code.Literal(uniqueConstraint.Name)).Append(", ")
             .Append(parameters.TargetName).Append(", ")
             .Append("new[] { ").AppendJoin(columns).AppendLine(" });");
@@ -947,6 +929,22 @@ public virtual void Generate(IStoreStoredProcedureParameter parameter, CSharpRun
                 .Append(parameters.TargetName).Append(".PrimaryKey = ").Append(uniqueConstraintVariable).AppendLine(";");
         }
 
+        AddNamespace(typeof(CompositeRowKeyValueFactory), parameters.Namespaces);
+        mainBuilder
+            .Append(uniqueConstraintVariable).Append(".").Append(nameof(UniqueConstraint.SetRowKeyValueFactory)).Append("(");
+        if (uniqueConstraint.Columns.Count == 1)
+        {
+            var type = uniqueConstraint.Columns.First().ProviderClrType;
+            mainBuilder
+                .Append($"new SimpleRowKeyValueFactory<{code.Reference(type)}>({uniqueConstraintVariable})");
+        }
+        else
+        {
+            mainBuilder
+                .Append($"new CompositeRowKeyValueFactory({uniqueConstraintVariable})");
+        }
+        mainBuilder.AppendLine(");");
+
         CreateAnnotations(
             uniqueConstraint,
             Generate,
@@ -997,6 +995,22 @@ public virtual void Generate(IUniqueConstraint uniqueConstraint, CSharpRuntimeAn
             .Append("new[] { ").AppendJoin(columns).Append(" }, ")
             .Append(code.Literal(index.IsUnique)).AppendLine(");");
 
+        AddNamespace(typeof(CompositeRowIndexValueFactory), parameters.Namespaces);
+        mainBuilder
+            .Append(indexVariable).Append(".").Append(nameof(TableIndex.SetRowIndexValueFactory)).Append("(");
+        if (index.Columns.Count == 1)
+        {
+            var type = index.Columns.First().ProviderClrType;
+            mainBuilder
+                .Append($"new SimpleRowIndexValueFactory<{code.Reference(type)}>({indexVariable})");
+        }
+        else
+        {
+            mainBuilder
+                .Append($"new CompositeRowIndexValueFactory({indexVariable})");
+        }
+        mainBuilder.AppendLine(");");
+
         CreateAnnotations(
             index,
             Generate,
@@ -1052,6 +1066,25 @@ public virtual void Generate(ITableIndex index, CSharpRuntimeAnnotationCodeGener
             .Append($"{principalTableVariable}.FindUniqueConstraint({code.Literal(foreignKey.PrincipalUniqueConstraint.Name)})!, ")
             .Append(code.Literal(foreignKey.OnDeleteAction)).AppendLine(");").DecrementIndent();
 
+        AddNamespace(typeof(CompositeRowForeignKeyValueFactory), parameters.Namespaces);
+        mainBuilder
+            .Append(foreignKeyConstraintVariable).Append(".").Append(nameof(ForeignKeyConstraint.SetRowForeignKeyValueFactory)).Append("(");
+        var createRowForeignKeyValueFactoryMethod = "new CompositeRowForeignKeyValueFactory(";
+        if (foreignKey.Columns.Count == 1)
+        {
+            var principalColumn = foreignKey.PrincipalColumns.First();
+            var dependentColumn = foreignKey.Columns.First();
+            createRowForeignKeyValueFactoryMethod = principalColumn.ProviderClrType.IsNullableType() || principalColumn.IsNullable
+                ? $"{nameof(RowForeignKeyValueFactoryFactory)}.{nameof(RowForeignKeyValueFactoryFactory.CreateSimpleNullableFactory)}"
+                : $"{nameof(RowForeignKeyValueFactoryFactory)}.{nameof(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory)}";
+            createRowForeignKeyValueFactoryMethod +=
+                $"<{code.Reference(principalColumn.ProviderClrType)}, {code.Reference(dependentColumn.ProviderClrType)}>(";
+        }
+
+        mainBuilder
+            .Append($"{createRowForeignKeyValueFactoryMethod}{foreignKeyConstraintVariable})");
+        mainBuilder.AppendLine(");");
+
         CreateAnnotations(
             foreignKey,
             Generate,
@@ -1149,7 +1182,12 @@ public virtual void Generate(ITableMappingBase tableMapping, CSharpRuntimeAnnota
         var typeBaseVariable = metadataVariables[typeBase];
 
         var table = tableMapping.Table;
-        var tableVariable = GetOrCreate(table, parameters);
+        if (!parameters.ScopeVariables.TryGetValue(table, out var tableVariable))
+        {
+            tableVariable = Create(table, parameters);
+        }
+
+        var tableParameters = parameters with { TargetName = tableVariable };
         var tableMappingVariable = code.Identifier(table.Name + "TableMapping", tableMapping, parameters.ScopeObjects, capitalize: false);
 
         GenerateAddMapping(
@@ -1173,6 +1211,29 @@ public virtual void Generate(ITableMappingBase tableMapping, CSharpRuntimeAnnota
                 .Append($"{typeBaseVariable}.FindProperty({code.Literal(columnMapping.Property.Name)})!, ")
                 .Append(tableMappingVariable).AppendLine(");");
         }
+
+        if (tableMapping == table.EntityTypeMappings.Last())
+        {
+            foreach (var uniqueConstraint in table.UniqueConstraints)
+            {
+                Create(uniqueConstraint, uniqueConstraint.Columns.Select(c => metadataVariables[c]), tableParameters);
+            }
+
+            foreach (var index in table.Indexes)
+            {
+                Create(index, index.Columns.Select(c => metadataVariables[c]), tableParameters);
+            }
+
+            foreach (var trigger in table.Triggers)
+            {
+                var entityTypeVariable = metadataVariables[trigger.EntityType];
+
+                var triggerName = trigger.GetDatabaseName(StoreObjectIdentifier.Table(table.Name, table.Schema));
+                mainBuilder
+                    .Append($"{tableVariable}.Triggers.Add({code.Literal(triggerName)}, ")
+                    .AppendLine($"{entityTypeVariable}.FindDeclaredTrigger({code.Literal(trigger.ModelName)}));");
+            }
+        }
     }
 
     /// <summary>
diff --git a/src/EFCore.Relational/Infrastructure/RelationalModelDependencies.cs b/src/EFCore.Relational/Infrastructure/RelationalModelDependencies.cs
index 217cbd6059..f892d70ab6 100644
--- a/src/EFCore.Relational/Infrastructure/RelationalModelDependencies.cs
+++ b/src/EFCore.Relational/Infrastructure/RelationalModelDependencies.cs
@@ -50,11 +50,13 @@ public sealed record RelationalModelDependencies
     public RelationalModelDependencies(
         IRowKeyValueFactoryFactory rowKeyValueFactoryFactory,
         IRowForeignKeyValueFactoryFactory foreignKeyRowValueFactorySource,
-        IRowIndexValueFactoryFactory rowIndexValueFactoryFactory)
+        IRowIndexValueFactoryFactory rowIndexValueFactoryFactory,
+        IValueConverterSelector valueConverterSelector)
     {
         RowKeyValueFactoryFactory = rowKeyValueFactoryFactory;
         RowForeignKeyValueFactoryFactory = foreignKeyRowValueFactorySource;
         RowIndexValueFactoryFactory = rowIndexValueFactoryFactory;
+        ValueConverterSelector = valueConverterSelector;
     }
 
     /// <summary>
@@ -83,4 +85,13 @@ public sealed record RelationalModelDependencies
     /// </summary>
     [EntityFrameworkInternal]
     public IRowIndexValueFactoryFactory RowIndexValueFactoryFactory { get; init; }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    [EntityFrameworkInternal]
+    public IValueConverterSelector ValueConverterSelector { get; init; }
 }
diff --git a/src/EFCore.Relational/Metadata/Internal/ForeignKeyConstraint.cs b/src/EFCore.Relational/Metadata/Internal/ForeignKeyConstraint.cs
index b802cad311..53d904470e 100644
--- a/src/EFCore.Relational/Metadata/Internal/ForeignKeyConstraint.cs
+++ b/src/EFCore.Relational/Metadata/Internal/ForeignKeyConstraint.cs
@@ -14,6 +14,8 @@ namespace Microsoft.EntityFrameworkCore.Metadata.Internal;
 /// </summary>
 public class ForeignKeyConstraint : Annotatable, IForeignKeyConstraint
 {
+    private IRowForeignKeyValueFactory? _foreignKeyRowValueFactory;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -100,7 +102,14 @@ public override bool IsReadOnly
     /// <inheritdoc />
     public virtual ReferentialAction OnDeleteAction { get; set; }
 
-    private IRowForeignKeyValueFactory? _foreignKeyRowValueFactory;
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void SetRowForeignKeyValueFactory(IRowForeignKeyValueFactory factory)
+        => _foreignKeyRowValueFactory = factory;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.Relational/Metadata/Internal/TableIndex.cs b/src/EFCore.Relational/Metadata/Internal/TableIndex.cs
index 31866e8084..61d020b0c6 100644
--- a/src/EFCore.Relational/Metadata/Internal/TableIndex.cs
+++ b/src/EFCore.Relational/Metadata/Internal/TableIndex.cs
@@ -81,6 +81,15 @@ public override bool IsReadOnly
 
     private IRowIndexValueFactory? _rowIndexValueFactory;
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual void SetRowIndexValueFactory(IRowIndexValueFactory factory)
+        => _rowIndexValueFactory = factory;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Relational/Metadata/Internal/UniqueConstraint.cs b/src/EFCore.Relational/Metadata/Internal/UniqueConstraint.cs
index 0886ebeb3f..d080bc7381 100644
--- a/src/EFCore.Relational/Metadata/Internal/UniqueConstraint.cs
+++ b/src/EFCore.Relational/Metadata/Internal/UniqueConstraint.cs
@@ -75,13 +75,8 @@ public override bool IsReadOnly
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual IRowKeyValueFactory GetRowKeyValueFactory()
-        => NonCapturingLazyInitializer.EnsureInitialized(
-            ref _rowKeyValueFactory, this,
-            static constraint =>
-                RuntimeFeature.IsDynamicCodeSupported
-                    ? constraint.Table.Model.Model.GetRelationalDependencies().RowKeyValueFactoryFactory.Create(constraint)
-                    : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
+    public virtual void SetRowKeyValueFactory(IRowKeyValueFactory factory)
+        => _rowKeyValueFactory = factory;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -89,9 +84,13 @@ public virtual IRowKeyValueFactory GetRowKeyValueFactory()
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    [EntityFrameworkInternal]
-    public virtual void SetRowKeyValueFactory(IRowKeyValueFactory factory)
-        => _rowKeyValueFactory = factory;
+    public virtual IRowKeyValueFactory GetRowKeyValueFactory()
+        => NonCapturingLazyInitializer.EnsureInitialized(
+            ref _rowKeyValueFactory, this,
+            static constraint =>
+                RuntimeFeature.IsDynamicCodeSupported
+                    ? constraint.Table.Model.Model.GetRelationalDependencies().RowKeyValueFactoryFactory.Create(constraint)
+                    : throw new InvalidOperationException(CoreStrings.NativeAotNoCompiledModel));
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.Relational/Update/Internal/CompositeRowForeignKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/CompositeRowForeignKeyValueFactory.cs
index ab44d45936..d91d033341 100644
--- a/src/EFCore.Relational/Update/Internal/CompositeRowForeignKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/CompositeRowForeignKeyValueFactory.cs
@@ -1,6 +1,7 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Update.Internal;
@@ -15,7 +16,8 @@ public class CompositeRowForeignKeyValueFactory : CompositeRowValueFactory, IRow
 {
     private readonly IForeignKeyConstraint _foreignKey;
     private readonly IRowKeyValueFactory<object?[]> _principalKeyValueFactory;
-    private readonly List<ValueConverter?> _valueConverters;
+    private List<ValueConverter?>? _valueConverters;
+    private IEqualityComparer<object?[]>? _equalityComparer;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -23,44 +25,66 @@ public class CompositeRowForeignKeyValueFactory : CompositeRowValueFactory, IRow
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public CompositeRowForeignKeyValueFactory(
-        IForeignKeyConstraint foreignKey,
-        IValueConverterSelector valueConverterSelector)
+    public CompositeRowForeignKeyValueFactory(IForeignKeyConstraint foreignKey)
         : base(foreignKey.Columns)
     {
         _foreignKey = foreignKey;
         _principalKeyValueFactory =
             (IRowKeyValueFactory<object?[]>)((UniqueConstraint)foreignKey.PrincipalUniqueConstraint).GetRowKeyValueFactory();
+    }
 
-        var columns = foreignKey.Columns;
-        _valueConverters = new List<ValueConverter?>(columns.Count);
-
-        for (var i = 0; i < columns.Count; i++)
-        {
-            var fkColumn = columns[i];
-            var pkColumn = foreignKey.PrincipalColumns[i];
-            var fkType = fkColumn.ProviderClrType;
-            var pkType = pkColumn.ProviderClrType;
-            if (fkType != pkType)
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    protected override List<ValueConverter?>? ValueConverters =>
+        NonCapturingLazyInitializer.EnsureInitialized(
+            ref _valueConverters, this, static factory =>
             {
-                var converterInfos = valueConverterSelector.Select(pkType, fkType).ToList();
-                if (converterInfos.Count == 0)
+                var foreignKey = factory._foreignKey;
+                var valueConverterSelector = foreignKey.Table.Model.Model.GetRelationalDependencies().ValueConverterSelector;
+                var columns = foreignKey.Columns;
+                var valueConverters = new List<ValueConverter?>(columns.Count);
+                for (var i = 0; i < columns.Count; i++)
                 {
-                    throw new InvalidOperationException(
-                        RelationalStrings.StoredKeyTypesNotConvertable(
-                            fkColumn.Name, fkColumn.StoreType, pkColumn.StoreType, pkColumn.Name));
+                    var fkColumn = columns[i];
+                    var pkColumn = foreignKey.PrincipalColumns[i];
+                    var fkType = fkColumn.ProviderClrType;
+                    var pkType = pkColumn.ProviderClrType;
+                    if (fkType != pkType)
+                    {
+                        var converterInfos = valueConverterSelector.Select(pkType, fkType).ToList();
+                        if (converterInfos.Count == 0)
+                        {
+                            throw new InvalidOperationException(
+                                RelationalStrings.StoredKeyTypesNotConvertable(
+                                    fkColumn.Name, fkColumn.StoreType, pkColumn.StoreType, pkColumn.Name));
+                        }
+
+                        valueConverters.Add(converterInfos.First().Create());
+                    }
+                    else
+                    {
+                        valueConverters.Add(null);
+                    }
                 }
 
-                _valueConverters.Add(converterInfos.First().Create());
-            }
-            else
-            {
-                _valueConverters.Add(null);
-            }
-        }
+                return valueConverters;
+            });
 
-        ValueConverters = _valueConverters;
-        EqualityComparer = CreateEqualityComparer(columns, _valueConverters);
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public override IEqualityComparer<object?[]> EqualityComparer
+    {
+        get => NonCapturingLazyInitializer.EnsureInitialized(
+               ref _equalityComparer, this, static factory => CreateEqualityComparer(factory.Columns, factory.ValueConverters));
+        protected set => _equalityComparer = value;
     }
 
     /// <summary>
diff --git a/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs b/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs
index 76e6ca16b3..e5004b74fd 100644
--- a/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/CompositeRowValueFactory.cs
@@ -11,7 +11,7 @@ namespace Microsoft.EntityFrameworkCore.Update.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public abstract class CompositeRowValueFactory
+public abstract class CompositeRowValueFactory(IReadOnlyList<IColumn> columns)
 {
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -19,18 +19,7 @@ public abstract class CompositeRowValueFactory
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected CompositeRowValueFactory(IReadOnlyList<IColumn> columns)
-    {
-        Columns = columns;
-    }
-
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    protected virtual List<ValueConverter?>? ValueConverters { get; set; }
+    protected virtual List<ValueConverter?>? ValueConverters { get; }
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -46,7 +35,7 @@ protected CompositeRowValueFactory(IReadOnlyList<IColumn> columns)
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    protected virtual IReadOnlyList<IColumn> Columns { get; }
+    protected virtual IReadOnlyList<IColumn> Columns { get; } = columns;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs
index abf174c872..4cbe3e473f 100644
--- a/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactory.cs
@@ -16,8 +16,9 @@ namespace Microsoft.EntityFrameworkCore.Update.Internal;
 public abstract class RowForeignKeyValueFactory<TKey, TForeignKey> : IRowForeignKeyValueFactory<TKey>
 {
     private readonly IForeignKeyConstraint _foreignKey;
-    private readonly ValueConverter? _valueConverter;
     private readonly IRowKeyValueFactory<TKey> _principalKeyValueFactory;
+    private ValueConverter? _valueConverter;
+    private IEqualityComparer<TKey>? _equalityComparer;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -28,34 +29,15 @@ public abstract class RowForeignKeyValueFactory<TKey, TForeignKey> : IRowForeign
     protected RowForeignKeyValueFactory(
         IForeignKeyConstraint foreignKey,
         IColumn column,
-        ColumnAccessors columnAccessors,
-        IValueConverterSelector valueConverterSelector)
+        ColumnAccessors columnAccessors)
     {
         _foreignKey = foreignKey;
         Column = column;
-
-        if (typeof(TKey) == typeof(TForeignKey))
-        {
-            ColumnAccessors = columnAccessors;
-        }
-        else
-        {
-            var converterInfos = valueConverterSelector.Select(typeof(TKey), typeof(TForeignKey)).ToList();
-            if (converterInfos.Count == 0)
-            {
-                var pkColumn = foreignKey.PrincipalColumns[0];
-                throw new InvalidOperationException(
-                    RelationalStrings.StoredKeyTypesNotConvertable(
-                        column.Name, column.StoreType, pkColumn.StoreType, pkColumn.Name));
-            }
-
-            _valueConverter = converterInfos.First().Create();
-
-            ColumnAccessors = new ColumnAccessors(
+        ColumnAccessors = typeof(TKey) == typeof(TForeignKey)
+            ? columnAccessors
+            : new ColumnAccessors(
                 ConvertAccessor((Func<IReadOnlyModificationCommand, (TForeignKey, bool)>)columnAccessors.CurrentValueGetter),
                 ConvertAccessor((Func<IReadOnlyModificationCommand, (TForeignKey, bool)>)columnAccessors.OriginalValueGetter));
-        }
-
         _principalKeyValueFactory =
             (IRowKeyValueFactory<TKey>)((UniqueConstraint)foreignKey.PrincipalUniqueConstraint).GetRowKeyValueFactory();
     }
@@ -67,7 +49,7 @@ public abstract class RowForeignKeyValueFactory<TKey, TForeignKey> : IRowForeign
             var tuple = columnAccessor(command);
             return (tuple.Item1 == null
                 ? (default, tuple.Item2)
-                : ((TKey)_valueConverter!.ConvertFromProvider(tuple.Item1)!, tuple.Item2))!;
+                : ((TKey)ValueConverter!.ConvertFromProvider(tuple.Item1)!, tuple.Item2))!;
         };
 
     /// <summary>
@@ -76,7 +58,11 @@ public abstract class RowForeignKeyValueFactory<TKey, TForeignKey> : IRowForeign
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public abstract IEqualityComparer<TKey> EqualityComparer { get; }
+#pragma warning disable EF1001 // Internal EF Core API usage.
+    public virtual IEqualityComparer<TKey> EqualityComparer => NonCapturingLazyInitializer.EnsureInitialized(
+        ref _equalityComparer, this, static factory
+            => NullableComparerAdapter<TKey>.Wrap(factory.Column.ProviderValueComparer, factory.ValueConverter));
+#pragma warning restore EF1001 // Internal EF Core API usage.
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -94,6 +80,32 @@ public abstract class RowForeignKeyValueFactory<TKey, TForeignKey> : IRowForeign
     /// </summary>
     public virtual ColumnAccessors ColumnAccessors { get; }
 
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual ValueConverter? ValueConverter => typeof(TKey) == typeof(TForeignKey)
+        ? null
+        : NonCapturingLazyInitializer.EnsureInitialized(
+            ref _valueConverter, this, static factory =>
+            {
+                var foreignKey = factory._foreignKey;
+                var column = factory.Column;
+                var valueConverterSelector = foreignKey.Table.Model.Model.GetRelationalDependencies().ValueConverterSelector;
+                var converterInfos = valueConverterSelector.Select(typeof(TKey), typeof(TForeignKey)).ToList();
+                if (converterInfos.Count == 0)
+                {
+                    var pkColumn = foreignKey.PrincipalColumns[0];
+                    throw new InvalidOperationException(
+                        RelationalStrings.StoredKeyTypesNotConvertable(
+                            column.Name, column.StoreType, pkColumn.StoreType, pkColumn.Name));
+                }
+
+                return converterInfos.First().Create();
+            });
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -148,17 +160,6 @@ public virtual object CreatePrincipalEquatableKeyValue(IReadOnlyModificationComm
         bool fromOriginalValues,
         [NotNullWhen(true)] out TKey? key);
 
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    protected virtual IEqualityComparer<TKey> CreateKeyEqualityComparer(IColumn column)
-#pragma warning disable EF1001 // Internal EF Core API usage.
-        => NullableComparerAdapter<TKey>.Wrap(column.ProviderValueComparer, _valueConverter);
-#pragma warning restore EF1001 // Internal EF Core API usage.
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
diff --git a/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactoryFactory.cs b/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactoryFactory.cs
index c298003f1d..91581bf897 100644
--- a/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactoryFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/RowForeignKeyValueFactoryFactory.cs
@@ -1,7 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using JetBrains.Annotations;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 
 namespace Microsoft.EntityFrameworkCore.Update.Internal;
@@ -14,67 +13,75 @@ namespace Microsoft.EntityFrameworkCore.Update.Internal;
 /// </summary>
 public class RowForeignKeyValueFactoryFactory : IRowForeignKeyValueFactoryFactory
 {
-    private readonly IValueConverterSelector _valueConverterSelector;
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public RowForeignKeyValueFactoryFactory(IValueConverterSelector valueConverterSelector)
+    public virtual IRowForeignKeyValueFactory Create(IForeignKeyConstraint foreignKey)
     {
-        _valueConverterSelector = valueConverterSelector;
+        if (foreignKey.Columns.Count != 1)
+        {
+            return new CompositeRowForeignKeyValueFactory(foreignKey);
+        }
+
+        var principalColumn = foreignKey.PrincipalColumns.First();
+        var createMethod = principalColumn.ProviderClrType.IsNullableType() || principalColumn.IsNullable
+            ? CreateNullableMethod
+            : CreateNonNullableMethod;
+
+        return (IRowForeignKeyValueFactory)createMethod
+            .MakeGenericMethod(
+                foreignKey.PrincipalColumns.First().ProviderClrType,
+                foreignKey.Columns.First().ProviderClrType)
+            .Invoke(null, [foreignKey])!;
     }
 
+    private static readonly MethodInfo CreateNullableMethod = typeof(RowForeignKeyValueFactoryFactory).GetTypeInfo()
+        .GetDeclaredMethod(nameof(CreateSimpleNullableFactory))!;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual IRowForeignKeyValueFactory Create(IForeignKeyConstraint foreignKey)
-        => foreignKey.Columns.Count == 1
-            ? (IRowForeignKeyValueFactory)CreateMethod
-                .MakeGenericMethod(
-                    foreignKey.PrincipalColumns.First().ProviderClrType,
-                    foreignKey.Columns.First().ProviderClrType)
-                .Invoke(null, [foreignKey, _valueConverterSelector])!
-            : new CompositeRowForeignKeyValueFactory(foreignKey, _valueConverterSelector);
-
-    private static readonly MethodInfo CreateMethod = typeof(RowForeignKeyValueFactoryFactory).GetTypeInfo()
-        .GetDeclaredMethod(nameof(CreateSimple))!;
-
-    [UsedImplicitly]
-    private static IRowForeignKeyValueFactory CreateSimple<TKey, TForeignKey>(
-        IForeignKeyConstraint foreignKey,
-        IValueConverterSelector valueConverterSelector)
+    public static IRowForeignKeyValueFactory CreateSimpleNullableFactory<TKey, TForeignKey>(
+        IForeignKeyConstraint foreignKey)
         where TKey : notnull
     {
         var dependentColumn = foreignKey.Columns.First();
         var principalColumn = foreignKey.PrincipalColumns.First();
         var columnAccessors = ((Column)dependentColumn).Accessors;
 
-        if (principalColumn.ProviderClrType.IsNullableType()
-            || (dependentColumn.IsNullable
-                && principalColumn.IsNullable))
-        {
-            return new SimpleFullyNullableRowForeignKeyValueFactory<TKey, TForeignKey>(
-                foreignKey, dependentColumn, columnAccessors, valueConverterSelector);
-        }
+        return principalColumn.ProviderClrType.IsNullableType()
+            || (dependentColumn.IsNullable && principalColumn.IsNullable)
+            ? new SimpleFullyNullableRowForeignKeyValueFactory<TKey, TForeignKey>(
+                foreignKey, dependentColumn, columnAccessors)
+            : new SimpleNullablePrincipalRowForeignKeyValueFactory<TKey, TForeignKey>(
+                   foreignKey, dependentColumn, columnAccessors);
+    }
 
-        if (dependentColumn.IsNullable)
-        {
-            return (IRowForeignKeyValueFactory<TKey>)Activator.CreateInstance(
-                typeof(SimpleNullableRowForeignKeyValueFactory<,>).MakeGenericType(
-                    typeof(TKey), typeof(TForeignKey)), foreignKey, dependentColumn, columnAccessors, valueConverterSelector)!;
-        }
+    private static readonly MethodInfo CreateNonNullableMethod = typeof(RowForeignKeyValueFactoryFactory).GetTypeInfo()
+        .GetDeclaredMethod(nameof(CreateSimpleNonNullableFactory))!;
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static IRowForeignKeyValueFactory CreateSimpleNonNullableFactory<TKey, TForeignKey>(
+        IForeignKeyConstraint foreignKey)
+        where TKey : struct
+    {
+        var dependentColumn = foreignKey.Columns.First();
+        var columnAccessors = ((Column)dependentColumn).Accessors;
 
-        return principalColumn.IsNullable
-            ? (IRowForeignKeyValueFactory<TKey>)Activator.CreateInstance(
-                typeof(SimpleNullablePrincipalRowForeignKeyValueFactory<,>).MakeGenericType(
-                    typeof(TKey), typeof(TKey), typeof(TForeignKey)), foreignKey, dependentColumn, columnAccessors)!
+        return dependentColumn.IsNullable
+            ? new SimpleNullableRowForeignKeyValueFactory<TKey, TForeignKey>(foreignKey, dependentColumn, columnAccessors)
             : new SimpleNonNullableRowForeignKeyValueFactory<TKey, TForeignKey>(
-                foreignKey, dependentColumn, columnAccessors, valueConverterSelector);
+                foreignKey, dependentColumn, columnAccessors);
     }
 }
diff --git a/src/EFCore.Relational/Update/Internal/RowIndexValueFactoryFactory.cs b/src/EFCore.Relational/Update/Internal/RowIndexValueFactoryFactory.cs
index 11a3385f0f..c33b5c8815 100644
--- a/src/EFCore.Relational/Update/Internal/RowIndexValueFactoryFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/RowIndexValueFactoryFactory.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using JetBrains.Annotations;
-
 namespace Microsoft.EntityFrameworkCore.Update.Internal;
 
 /// <summary>
@@ -29,7 +27,6 @@ public virtual IRowIndexValueFactory Create(ITableIndex index)
     private static readonly MethodInfo _createMethod = typeof(RowIndexValueFactoryFactory).GetTypeInfo()
         .GetDeclaredMethod(nameof(CreateSimple))!;
 
-    [UsedImplicitly]
     private static IRowIndexValueFactory<TKey> CreateSimple<TKey>(ITableIndex index)
         => new SimpleRowIndexValueFactory<TKey>(index);
 }
diff --git a/src/EFCore.Relational/Update/Internal/RowKeyValueFactoryFactory.cs b/src/EFCore.Relational/Update/Internal/RowKeyValueFactoryFactory.cs
index 44d9e06716..2620f18d4c 100644
--- a/src/EFCore.Relational/Update/Internal/RowKeyValueFactoryFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/RowKeyValueFactoryFactory.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using JetBrains.Annotations;
-
 namespace Microsoft.EntityFrameworkCore.Update.Internal;
 
 /// <summary>
@@ -29,7 +27,6 @@ public virtual IRowKeyValueFactory Create(IUniqueConstraint key)
     private static readonly MethodInfo _createMethod = typeof(RowKeyValueFactoryFactory).GetTypeInfo()
         .GetDeclaredMethod(nameof(CreateSimpleFactory))!;
 
-    [UsedImplicitly]
     private static IRowKeyValueFactory<TKey> CreateSimpleFactory<TKey>(IUniqueConstraint key)
         => new SimpleRowKeyValueFactory<TKey>(key);
 }
diff --git a/src/EFCore.Relational/Update/Internal/SimpleFullyNullableRowForeignKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/SimpleFullyNullableRowForeignKeyValueFactory.cs
index 1fa0064190..16610bf092 100644
--- a/src/EFCore.Relational/Update/Internal/SimpleFullyNullableRowForeignKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/SimpleFullyNullableRowForeignKeyValueFactory.cs
@@ -11,27 +11,10 @@ namespace Microsoft.EntityFrameworkCore.Update.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class SimpleFullyNullableRowForeignKeyValueFactory<TKey, TForeignKey> : RowForeignKeyValueFactory<TKey, TForeignKey>
+public class SimpleFullyNullableRowForeignKeyValueFactory<TKey, TForeignKey>(
+    IForeignKeyConstraint foreignKey, IColumn column, ColumnAccessors columnAccessors)
+    : RowForeignKeyValueFactory<TKey, TForeignKey>(foreignKey, column, columnAccessors)
 {
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public SimpleFullyNullableRowForeignKeyValueFactory(
-        IForeignKeyConstraint foreignKey,
-        IColumn column,
-        ColumnAccessors columnAccessors,
-        IValueConverterSelector valueConverterSelector)
-        : base(foreignKey, column, columnAccessors, valueConverterSelector)
-    {
-        EqualityComparer = CreateKeyEqualityComparer(column);
-    }
-
-    /// <inheritdoc />
-    public override IEqualityComparer<TKey> EqualityComparer { get; }
-
     /// <inheritdoc />
     public override bool TryCreateDependentKeyValue(object?[] keyValues, [NotNullWhen(true)] out TKey? key)
     {
diff --git a/src/EFCore.Relational/Update/Internal/SimpleNonNullableRowForeignKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/SimpleNonNullableRowForeignKeyValueFactory.cs
index f3283f1cd7..3acc779f17 100644
--- a/src/EFCore.Relational/Update/Internal/SimpleNonNullableRowForeignKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/SimpleNonNullableRowForeignKeyValueFactory.cs
@@ -20,18 +20,11 @@ public class SimpleNonNullableRowForeignKeyValueFactory<TKey, TForeignKey> : Row
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
     public SimpleNonNullableRowForeignKeyValueFactory(
-        IForeignKeyConstraint foreignKey,
-        IColumn column,
-        ColumnAccessors columnAccessors,
-        IValueConverterSelector valueConverterSelector)
-        : base(foreignKey, column, columnAccessors, valueConverterSelector)
+        IForeignKeyConstraint foreignKey, IColumn column, ColumnAccessors columnAccessors)
+        : base(foreignKey, column, columnAccessors)
     {
-        EqualityComparer = CreateKeyEqualityComparer(column);
     }
 
-    /// <inheritdoc />
-    public override IEqualityComparer<TKey> EqualityComparer { get; }
-
     /// <inheritdoc />
     public override bool TryCreateDependentKeyValue(object?[] keyValues, [NotNullWhen(true)] out TKey? key)
     {
diff --git a/src/EFCore.Relational/Update/Internal/SimpleNullablePrincipalRowForeignKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/SimpleNullablePrincipalRowForeignKeyValueFactory.cs
index 97f8e1d3e5..f8c9eb34d6 100644
--- a/src/EFCore.Relational/Update/Internal/SimpleNullablePrincipalRowForeignKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/SimpleNullablePrincipalRowForeignKeyValueFactory.cs
@@ -11,29 +11,11 @@ namespace Microsoft.EntityFrameworkCore.Update.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class SimpleNullablePrincipalRowForeignKeyValueFactory<TKey, TForeignKey>
-    : RowForeignKeyValueFactory<TKey, TForeignKey>
+public class SimpleNullablePrincipalRowForeignKeyValueFactory<TKey, TForeignKey>(
+    IForeignKeyConstraint foreignKey, IColumn column, ColumnAccessors columnAccessors)
+    : RowForeignKeyValueFactory<TKey, TForeignKey>(foreignKey, column, columnAccessors)
     where TKey : notnull
 {
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public SimpleNullablePrincipalRowForeignKeyValueFactory(
-        IForeignKeyConstraint foreignKey,
-        IColumn column,
-        ColumnAccessors columnAccessors,
-        IValueConverterSelector valueConverterSelector)
-        : base(foreignKey, column, columnAccessors, valueConverterSelector)
-    {
-        EqualityComparer = CreateKeyEqualityComparer(column);
-    }
-
-    /// <inheritdoc />
-    public override IEqualityComparer<TKey> EqualityComparer { get; }
-
     /// <inheritdoc />
     public override bool TryCreateDependentKeyValue(object?[] keyValues, [NotNullWhen(true)] out TKey? key)
     {
diff --git a/src/EFCore.Relational/Update/Internal/SimpleNullableRowForeignKeyValueFactory.cs b/src/EFCore.Relational/Update/Internal/SimpleNullableRowForeignKeyValueFactory.cs
index 292cc8a543..61118512e7 100644
--- a/src/EFCore.Relational/Update/Internal/SimpleNullableRowForeignKeyValueFactory.cs
+++ b/src/EFCore.Relational/Update/Internal/SimpleNullableRowForeignKeyValueFactory.cs
@@ -11,28 +11,11 @@ namespace Microsoft.EntityFrameworkCore.Update.Internal;
 ///     any release. You should only use it directly in your code with extreme caution and knowing that
 ///     doing so can result in application failures when updating to a new Entity Framework Core release.
 /// </summary>
-public class SimpleNullableRowForeignKeyValueFactory<TKey, TForeignKey> : RowForeignKeyValueFactory<TKey, TForeignKey>
+public class SimpleNullableRowForeignKeyValueFactory<TKey, TForeignKey>(
+    IForeignKeyConstraint foreignKey, IColumn column, ColumnAccessors columnAccessors)
+    : RowForeignKeyValueFactory<TKey, TForeignKey>(foreignKey, column, columnAccessors)
     where TKey : struct
 {
-    /// <summary>
-    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
-    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
-    ///     any release. You should only use it directly in your code with extreme caution and knowing that
-    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
-    /// </summary>
-    public SimpleNullableRowForeignKeyValueFactory(
-        IForeignKeyConstraint foreignKey,
-        IColumn column,
-        ColumnAccessors columnAccessors,
-        IValueConverterSelector valueConverterSelector)
-        : base(foreignKey, column, columnAccessors, valueConverterSelector)
-    {
-        EqualityComparer = CreateKeyEqualityComparer(column);
-    }
-
-    /// <inheritdoc />
-    public override IEqualityComparer<TKey> EqualityComparer { get; }
-
     /// <inheritdoc />
     public override bool TryCreateDependentKeyValue(object?[] keyValues, [NotNullWhen(true)] out TKey key)
         => HandleNullableValue((TKey?)keyValues[0], out key);
diff --git a/src/EFCore/ChangeTracking/Internal/DependentKeyValueFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/DependentKeyValueFactoryFactory.cs
index e0685c2785..32bb118f99 100644
--- a/src/EFCore/ChangeTracking/Internal/DependentKeyValueFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/DependentKeyValueFactoryFactory.cs
@@ -17,29 +17,28 @@ public class DependentKeyValueFactoryFactory
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public virtual IDependentKeyValueFactory<TKey> CreateSimple<TKey>(
+    public virtual IDependentKeyValueFactory<TKey> CreateSimpleNullable<TKey, TNonNullableKey>(
         IForeignKey foreignKey,
         IPrincipalKeyValueFactory<TKey> principalKeyValueFactory)
         where TKey : notnull
-    {
-        var dependentIsNullable = foreignKey.Properties[0].ClrType.IsNullableType();
-        var principalIsNullable = foreignKey.PrincipalKey.Properties[0].ClrType.IsNullableType();
+        where TNonNullableKey : struct
+        => foreignKey.Properties[0].ClrType.IsNullableType()
+            ? new SimpleFullyNullableDependentKeyValueFactory<TKey>(foreignKey, principalKeyValueFactory)
+            : new SimpleNullablePrincipalDependentKeyValueFactory<TKey, TNonNullableKey>(foreignKey, principalKeyValueFactory);
 
-        if (dependentIsNullable)
-        {
-            return principalIsNullable
-                ? new SimpleFullyNullableDependentKeyValueFactory<TKey>(foreignKey, principalKeyValueFactory)
-                : (IDependentKeyValueFactory<TKey>)Activator.CreateInstance(
-                    typeof(SimpleNullableDependentKeyValueFactory<>).MakeGenericType(
-                        typeof(TKey)), foreignKey, principalKeyValueFactory)!;
-        }
-
-        return principalIsNullable
-            ? (IDependentKeyValueFactory<TKey>)Activator.CreateInstance(
-                typeof(SimpleNullablePrincipalDependentKeyValueFactory<,>).MakeGenericType(
-                    typeof(TKey), typeof(TKey).UnwrapNullableType()), foreignKey, principalKeyValueFactory)!
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public virtual IDependentKeyValueFactory<TKey> CreateSimpleNonNullable<TKey>(
+        IForeignKey foreignKey,
+        IPrincipalKeyValueFactory<TKey> principalKeyValueFactory)
+        where TKey : struct
+        => foreignKey.Properties[0].ClrType.IsNullableType()
+            ? new SimpleNullableDependentKeyValueFactory<TKey>(foreignKey, principalKeyValueFactory)
             : new SimpleNonNullableDependentKeyValueFactory<TKey>(foreignKey, principalKeyValueFactory);
-    }
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
diff --git a/src/EFCore/ChangeTracking/Internal/IdentityMapFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/IdentityMapFactoryFactory.cs
index 7019429934..d55152d70a 100644
--- a/src/EFCore/ChangeTracking/Internal/IdentityMapFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/IdentityMapFactoryFactory.cs
@@ -1,8 +1,6 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
-using JetBrains.Annotations;
-
 namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 
 /// <summary>
diff --git a/src/EFCore/ChangeTracking/Internal/KeyValueFactoryFactory.cs b/src/EFCore/ChangeTracking/Internal/KeyValueFactoryFactory.cs
index 11b133e17a..a46717bf39 100644
--- a/src/EFCore/ChangeTracking/Internal/KeyValueFactoryFactory.cs
+++ b/src/EFCore/ChangeTracking/Internal/KeyValueFactoryFactory.cs
@@ -13,63 +13,121 @@ namespace Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
 /// </summary>
 public class KeyValueFactoryFactory
 {
+    private static MethodInfo? _createSimpleFactoryNullableMethod;
+    private static MethodInfo? _createSimpleFactoryNonNullableMethod;
+
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
     ///     any release. You should only use it directly in your code with extreme caution and knowing that
     ///     doing so can result in application failures when updating to a new Entity Framework Core release.
     /// </summary>
-    public static IPrincipalKeyValueFactory<TKey> Create<TKey>(IKey key)
-        where TKey : notnull
-        => key.Properties.Count == 1
-            ? CreateSimpleFactory<TKey>(key)
-            : (IPrincipalKeyValueFactory<TKey>)CreateCompositeFactory(key);
+    public static IPrincipalKeyValueFactory Create(IKey key)
+    {
+        if (key.Properties.Count != 1)
+        {
+            return CreateCompositeFactory(key);
+        }
+
+        var keyType = key.GetKeyType();
+        if (keyType.IsNullableType())
+        {
+            _createSimpleFactoryNullableMethod ??= typeof(KeyValueFactoryFactory).GetMethod(nameof(CreateSimpleNullableFactory))!;
+            var nonNullableKeyType = keyType.UnwrapNullableType();
+            return (IPrincipalKeyValueFactory)_createSimpleFactoryNullableMethod.MakeGenericMethod(
+                keyType, nonNullableKeyType == keyType ? typeof(int) : nonNullableKeyType)
+                .Invoke(null, [key])!;
+        }
+        else
+        {
+            _createSimpleFactoryNonNullableMethod ??= typeof(KeyValueFactoryFactory)
+                .GetMethod(nameof(CreateSimpleNonNullableFactory))!;
+            return (IPrincipalKeyValueFactory)_createSimpleFactoryNonNullableMethod.MakeGenericMethod(keyType)
+                .Invoke(null, [key])!;
+        }
+    }
 
-    private static SimplePrincipalKeyValueFactory<TKey> CreateSimpleFactory<TKey>(IKey key)
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static SimplePrincipalKeyValueFactory<TKey> CreateSimpleNullableFactory<TKey, TNonNullableKey>(IKey key)
         where TKey : notnull
+        where TNonNullableKey : struct
     {
-        var dependentFactory = new DependentKeyValueFactoryFactory();
+        DependentKeyValueFactoryFactory? dependentFactory = null;
         var principalKeyValueFactory = new SimplePrincipalKeyValueFactory<TKey>(key);
 
         foreach (var foreignKey in key.GetReferencingForeignKeys())
         {
-            var dependentKeyValueFactory = dependentFactory.CreateSimple(foreignKey, principalKeyValueFactory);
+            dependentFactory ??= new DependentKeyValueFactoryFactory();
+            SetFactories(
+                foreignKey,
+                principalKeyValueFactory,
+                dependentFactory.CreateSimpleNullable<TKey, TNonNullableKey>(foreignKey, principalKeyValueFactory));
+        }
 
+        return principalKeyValueFactory;
+    }
+
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static SimplePrincipalKeyValueFactory<TKey> CreateSimpleNonNullableFactory<TKey>(IKey key)
+        where TKey : struct
+    {
+        DependentKeyValueFactoryFactory? dependentFactory = null;
+        var principalKeyValueFactory = new SimplePrincipalKeyValueFactory<TKey>(key);
+
+        foreach (var foreignKey in key.GetReferencingForeignKeys())
+        {
+            dependentFactory ??= new DependentKeyValueFactoryFactory();
             SetFactories(
                 foreignKey,
-                dependentKeyValueFactory,
-                () => new DependentsMap<TKey>(foreignKey, principalKeyValueFactory, dependentKeyValueFactory));
+                principalKeyValueFactory,
+                dependentFactory.CreateSimpleNonNullable(foreignKey, principalKeyValueFactory));
         }
 
         return principalKeyValueFactory;
     }
 
-    private static CompositePrincipalKeyValueFactory CreateCompositeFactory(IKey key)
+    /// <summary>
+    ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+    ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+    ///     any release. You should only use it directly in your code with extreme caution and knowing that
+    ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+    /// </summary>
+    public static CompositePrincipalKeyValueFactory CreateCompositeFactory(IKey key)
     {
-        var dependentFactory = new DependentKeyValueFactoryFactory();
+        DependentKeyValueFactoryFactory? dependentFactory = null;
         var principalKeyValueFactory = new CompositePrincipalKeyValueFactory(key);
 
         foreach (var foreignKey in key.GetReferencingForeignKeys())
         {
-            var dependentKeyValueFactory = dependentFactory.CreateComposite(foreignKey, principalKeyValueFactory);
-
+            dependentFactory ??= new DependentKeyValueFactoryFactory();
             SetFactories(
                 foreignKey,
-                dependentKeyValueFactory,
-                () => new DependentsMap<IReadOnlyList<object?>>(foreignKey, principalKeyValueFactory, dependentKeyValueFactory));
+                principalKeyValueFactory,
+                dependentFactory.CreateComposite(foreignKey, principalKeyValueFactory));
         }
 
         return principalKeyValueFactory;
     }
 
-    private static void SetFactories(
+    private static void SetFactories<TKey>(
         IForeignKey foreignKey,
-        IDependentKeyValueFactory dependentKeyValueFactory,
-        Func<IDependentsMap> dependentsMapFactory)
+        IPrincipalKeyValueFactory<TKey> principalKeyValueFactory,
+        IDependentKeyValueFactory<TKey> dependentKeyValueFactory)
+        where TKey : notnull
     {
-        var concreteForeignKey = (IRuntimeForeignKey)foreignKey;
-
-        concreteForeignKey.DependentKeyValueFactory = dependentKeyValueFactory;
-        concreteForeignKey.DependentsMapFactory = dependentsMapFactory;
+        var runtimeForeignKey = (IRuntimeForeignKey)foreignKey;
+        runtimeForeignKey.DependentKeyValueFactory = dependentKeyValueFactory;
+        runtimeForeignKey.DependentsMapFactory = () => new DependentsMap<TKey>(
+            foreignKey, principalKeyValueFactory, dependentKeyValueFactory);
     }
 }
diff --git a/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs b/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
index 514cd52211..7b74a05666 100644
--- a/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
+++ b/src/EFCore/Design/Internal/CSharpRuntimeAnnotationCodeGenerator.cs
@@ -364,7 +364,6 @@ public static void AddNamespace(Type type, ISet<string> namespaces)
             AddNamespace(converter.ModelClrType, parameters.Namespaces);
             AddNamespace(converter.ProviderClrType, parameters.Namespaces);
 
-            // TODO
             var unsafeAccessors = new HashSet<string>();
 
             mainBuilder
@@ -380,6 +379,9 @@ public static void AddNamespace(Type type, ISet<string> namespaces)
                 .AppendLines(codeHelper.Expression(converter.ConvertFromProviderExpression, parameters.Namespaces, unsafeAccessors),
                     skipFinalNewline: true);
 
+            Check.DebugAssert(unsafeAccessors.Count == 0, "Generated unsafe accessors not handled: " +
+                string.Join(Environment.NewLine, unsafeAccessors));
+
             if (converter.ConvertsNulls)
             {
                 mainBuilder
@@ -432,7 +434,6 @@ public void Create(ValueComparer comparer, CSharpRuntimeAnnotationCodeGeneratorP
             AddNamespace(typeof(ValueComparer<>), parameters.Namespaces);
             AddNamespace(comparer.Type, parameters.Namespaces);
 
-            // TODO
             var unsafeAccessors = new HashSet<string>();
 
             mainBuilder
@@ -450,6 +451,9 @@ public void Create(ValueComparer comparer, CSharpRuntimeAnnotationCodeGeneratorP
                     skipFinalNewline: true)
                 .Append(")")
                 .DecrementIndent();
+
+            Check.DebugAssert(unsafeAccessors.Count == 0, "Generated unsafe accessors not handled: " +
+                string.Join(Environment.NewLine, unsafeAccessors));
         }
         else
         {
diff --git a/src/EFCore/Metadata/Internal/Key.cs b/src/EFCore/Metadata/Internal/Key.cs
index 83b255ca17..d191cda9b2 100644
--- a/src/EFCore/Metadata/Internal/Key.cs
+++ b/src/EFCore/Metadata/Internal/Key.cs
@@ -159,17 +159,6 @@ public virtual IEnumerable<ForeignKey> GetReferencingForeignKeys()
                 return IdentityMapFactoryFactory.Create(key);
             });
 
-    private static readonly MethodInfo _createPrincipalKeyValueFactoryMethod = typeof(Key).GetTypeInfo()
-        .GetDeclaredMethod(nameof(CreatePrincipalKeyValueFactory))!;
-
-    [UsedImplicitly]
-    private IPrincipalKeyValueFactory<TKey> CreatePrincipalKeyValueFactory<TKey>()
-        where TKey : notnull
-    {
-        EnsureReadOnly();
-        return KeyValueFactoryFactory.Create<TKey>(this);
-    }
-
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
     ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
@@ -340,11 +329,17 @@ IEnumerable<IReadOnlyForeignKey> IReadOnlyKey.GetReferencingForeignKeys()
 
     IPrincipalKeyValueFactory<TKey> IKey.GetPrincipalKeyValueFactory<TKey>()
         => (IPrincipalKeyValueFactory<TKey>)NonCapturingLazyInitializer.EnsureInitialized(
-            ref _principalKeyValueFactory, this, static key => key.CreatePrincipalKeyValueFactory<TKey>());
+            ref _principalKeyValueFactory, this, static key =>
+            {
+                key.EnsureReadOnly();
+                return KeyValueFactoryFactory.Create(key);
+            });
 
     IPrincipalKeyValueFactory IKey.GetPrincipalKeyValueFactory()
         => (IPrincipalKeyValueFactory)NonCapturingLazyInitializer.EnsureInitialized(
-            ref _principalKeyValueFactory, (IKey)this, static key => _createPrincipalKeyValueFactoryMethod
-                .MakeGenericMethod(key.GetKeyType())
-                .Invoke(key, [])!);
+            ref _principalKeyValueFactory, this, static key =>
+            {
+                key.EnsureReadOnly();
+                return KeyValueFactoryFactory.Create(key);
+            });
 }
diff --git a/src/EFCore/Metadata/RuntimeKey.cs b/src/EFCore/Metadata/RuntimeKey.cs
index 4f6f6c6641..eeaffb69cd 100644
--- a/src/EFCore/Metadata/RuntimeKey.cs
+++ b/src/EFCore/Metadata/RuntimeKey.cs
@@ -17,7 +17,7 @@ public class RuntimeKey : RuntimeAnnotatableBase, IRuntimeKey
 {
     // Warning: Never access these fields directly as access needs to be thread-safe
     private Func<bool, IIdentityMap>? _identityMapFactory;
-    private object? _principalKeyValueFactory;
+    private IPrincipalKeyValueFactory? _principalKeyValueFactory;
 
     /// <summary>
     ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -131,20 +131,12 @@ IEnumerable<IReadOnlyForeignKey> IReadOnlyKey.GetReferencingForeignKeys()
     /// <inheritdoc />
     IPrincipalKeyValueFactory<TKey> IKey.GetPrincipalKeyValueFactory<TKey>()
         => (IPrincipalKeyValueFactory<TKey>)NonCapturingLazyInitializer.EnsureInitialized(
-            ref _principalKeyValueFactory, this, static key => key.CreatePrincipalKeyValueFactory<TKey>());
+            ref _principalKeyValueFactory, this, static key => KeyValueFactoryFactory.Create(key));
 
     /// <inheritdoc />
     IPrincipalKeyValueFactory IKey.GetPrincipalKeyValueFactory()
-        => (IPrincipalKeyValueFactory)NonCapturingLazyInitializer.EnsureInitialized(
-            ref _principalKeyValueFactory, (IKey)this, static key => _createPrincipalKeyValueFactoryMethod
-                .MakeGenericMethod(key.GetKeyType())
-                .Invoke(key, [])!);
-
-    private static readonly MethodInfo _createPrincipalKeyValueFactoryMethod = typeof(Key).GetTypeInfo()
-        .GetDeclaredMethod(nameof(CreatePrincipalKeyValueFactory))!;
-
-    private IPrincipalKeyValueFactory<TKey> CreatePrincipalKeyValueFactory<TKey>()
-        where TKey : notnull => KeyValueFactoryFactory.Create<TKey>(this);
+        => NonCapturingLazyInitializer.EnsureInitialized(
+            ref _principalKeyValueFactory, (IKey)this, static key => KeyValueFactoryFactory.Create(key));
 
     /// <inheritdoc />
     Func<bool, IIdentityMap> IRuntimeKey.GetIdentityMapFactory()
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs
index 54ed4fad90..09b25359a0 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/Basic_cosmos_model/DataEntityType.cs
@@ -41,6 +41,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(int),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -69,6 +75,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long?),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 providerPropertyType: typeof(string));
+            partitionId.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Nullable<long>>(partitionId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Nullable<long>>(partitionId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             partitionId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -156,6 +168,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new IdValueGeneratorFactory().Create);
+            __id.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(__id, 3),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<string>(__id, 2),
+                (ValueBuffer valueBuffer) => valueBuffer[3]);
             __id.SetPropertyIndexes(
                 index: 3,
                 originalValueIndex: 3,
@@ -187,6 +205,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAddOrUpdate,
                 beforeSaveBehavior: PropertySaveBehavior.Ignore,
                 afterSaveBehavior: PropertySaveBehavior.Ignore);
+            __jObject.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(4) ? entry.ReadStoreGeneratedValue<JObject>(0) : entry.FlaggedAsTemporary(4) && entry.ReadShadowValue<JObject>(3) == null ? entry.ReadTemporaryValue<JObject>(0) : entry.ReadShadowValue<JObject>(3),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<JObject>(3),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<JObject>(__jObject, 4),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<JObject>(__jObject),
+                (ValueBuffer valueBuffer) => valueBuffer[4]);
             __jObject.SetPropertyIndexes(
                 index: 4,
                 originalValueIndex: 4,
@@ -217,6 +241,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAddOrUpdate,
                 beforeSaveBehavior: PropertySaveBehavior.Ignore,
                 afterSaveBehavior: PropertySaveBehavior.Ignore);
+            _etag.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(5) ? entry.ReadStoreGeneratedValue<string>(1) : entry.FlaggedAsTemporary(5) && entry.ReadShadowValue<string>(4) == null ? entry.ReadTemporaryValue<string>(1) : entry.ReadShadowValue<string>(4),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(4),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(_etag, 5),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(_etag),
+                (ValueBuffer valueBuffer) => valueBuffer[5]);
             _etag.SetPropertyIndexes(
                 index: 5,
                 originalValueIndex: 5,
@@ -258,10 +288,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var __jObject = runtimeEntityType.FindProperty("__jObject")!;
             var _etag = runtimeEntityType.FindProperty("_etag")!;
             var key = runtimeEntityType.FindKey(new[] { id, partitionId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             var key0 = runtimeEntityType.FindKey(new[] { __id, partitionId });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key0));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
index e7b450b870..629753c132 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
@@ -130,6 +130,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             discriminator.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -157,6 +163,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new IdValueGeneratorFactory().Create);
+            __id.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(__id, 3),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<string>(__id, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[3]);
             __id.SetPropertyIndexes(
                 index: 3,
                 originalValueIndex: 3,
@@ -188,6 +200,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAddOrUpdate,
                 beforeSaveBehavior: PropertySaveBehavior.Ignore,
                 afterSaveBehavior: PropertySaveBehavior.Ignore);
+            __jObject.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(4) ? entry.ReadStoreGeneratedValue<JObject>(0) : entry.FlaggedAsTemporary(4) && entry.ReadShadowValue<JObject>(2) == null ? entry.ReadTemporaryValue<JObject>(0) : entry.ReadShadowValue<JObject>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<JObject>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<JObject>(__jObject, 4),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<JObject>(__jObject),
+                (ValueBuffer valueBuffer) => valueBuffer[4]);
             __jObject.SetPropertyIndexes(
                 index: 4,
                 originalValueIndex: 4,
@@ -228,10 +246,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var __id = runtimeEntityType.FindProperty("__id")!;
             var __jObject = runtimeEntityType.FindProperty("__jObject")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var key0 = runtimeEntityType.FindKey(new[] { __id });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<string>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<string, int>(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<string>(key0));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
@@ -268,7 +286,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
-        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentDerived<int> @this);
+        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentBase<int> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Data>k__BackingField")]
         public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentDerived1_Data(CompiledModelTestBase.DependentDerived<int> @this);
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
index dc1dd75562..530bc77edc 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
@@ -94,6 +94,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 1),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             discriminator.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -298,6 +304,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "PrincipalBaseId",
                 typeof(long?),
                 nullable: true);
+            principalBaseId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(6) ? entry.ReadStoreGeneratedValue<Nullable<long>>(1) : entry.FlaggedAsTemporary(6) && !entry.ReadShadowValue<Nullable<long>>(1).HasValue ? entry.ReadTemporaryValue<Nullable<long>>(1) : entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Nullable<long>>(principalBaseId, 6),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Nullable<long>>(principalBaseId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[6]);
             principalBaseId.SetPropertyIndexes(
                 index: 6,
                 originalValueIndex: 6,
@@ -2648,17 +2660,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             deriveds.SetGetter(
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) == null,
-                (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance),
-                (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance) == null);
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) == null,
+                (CompiledModelTestBase.PrincipalBase instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance),
+                (CompiledModelTestBase.PrincipalBase instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance) == null);
             deriveds.SetSetter(
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
             deriveds.SetMaterializationSetter(
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
             deriveds.SetAccessors(
-                (InternalEntityEntry entry) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
-                (InternalEntityEntry entry) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<CompiledModelTestBase.PrincipalBase>>(deriveds),
                 null);
@@ -2669,11 +2681,12 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
             deriveds.SetCollectionAccessor<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
                 (CompiledModelTestBase.PrincipalBase entity, Action<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(entity, setter),
                 () => (ICollection<CompiledModelTestBase.PrincipalBase>)(ICollection<CompiledModelTestBase.PrincipalBase>)new HashSet<CompiledModelTestBase.PrincipalBase>(ReferenceEqualityComparer.Instance));
+            deriveds.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds", "TestNamespace") });
             return runtimeForeignKey;
         }
 
@@ -2723,7 +2736,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList1 = principalBase.FindProperty("ValueTypeIList")!;
             var valueTypeList1 = principalBase.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var deriveds = runtimeEntityType.FindNavigation("Deriveds")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_provider_value_comparer/MyEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_provider_value_comparer/MyEntityEntityType.cs
index ab2df23f90..0079f18efc 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_provider_value_comparer/MyEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_provider_value_comparer/MyEntityEntityType.cs
@@ -115,7 +115,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_type_mapping/MyEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_type_mapping/MyEntityEntityType.cs
index 76e0d6bc19..b8e10fd25c 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_type_mapping/MyEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_type_mapping/MyEntityEntityType.cs
@@ -110,7 +110,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_comparer/MyEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_comparer/MyEntityEntityType.cs
index b65ffb72d9..499a726fda 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_comparer/MyEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_comparer/MyEntityEntityType.cs
@@ -115,7 +115,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_converter/MyEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_converter/MyEntityEntityType.cs
index 4c7d468a51..c728e94a8f 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_converter/MyEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Custom_value_converter/MyEntityEntityType.cs
@@ -117,7 +117,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IdentityUserEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IdentityUserEntityType.cs
index c6122b3232..41b8e35f65 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IdentityUserEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IdentityUserEntityType.cs
@@ -172,6 +172,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 3),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[3]);
             discriminator.SetPropertyIndexes(
                 index: 3,
                 originalValueIndex: 3,
@@ -750,7 +756,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var twoFactorEnabled = runtimeEntityType.FindProperty("TwoFactorEnabled")!;
             var userName = runtimeEntityType.FindProperty("UserName")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<string>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<string, int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<string>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
@@ -787,48 +793,48 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_Id(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_Id(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<AccessFailedCount>k__BackingField")]
-        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_AccessFailedCount(IdentityUser @this);
+        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_AccessFailedCount(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ConcurrencyStamp>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_ConcurrencyStamp(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_ConcurrencyStamp(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Email>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_Email(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_Email(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<EmailConfirmed>k__BackingField")]
-        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_EmailConfirmed(IdentityUser @this);
+        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_EmailConfirmed(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<LockoutEnabled>k__BackingField")]
-        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_LockoutEnabled(IdentityUser @this);
+        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_LockoutEnabled(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<LockoutEnd>k__BackingField")]
-        public static extern ref DateTimeOffset? UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_LockoutEnd(IdentityUser @this);
+        public static extern ref DateTimeOffset? UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_LockoutEnd(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NormalizedEmail>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_NormalizedEmail(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_NormalizedEmail(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<NormalizedUserName>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_NormalizedUserName(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_NormalizedUserName(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<PasswordHash>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_PasswordHash(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_PasswordHash(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<PhoneNumber>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_PhoneNumber(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_PhoneNumber(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<PhoneNumberConfirmed>k__BackingField")]
-        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_PhoneNumberConfirmed(IdentityUser @this);
+        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_PhoneNumberConfirmed(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<SecurityStamp>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_SecurityStamp(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_SecurityStamp(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<TwoFactorEnabled>k__BackingField")]
-        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_TwoFactorEnabled(IdentityUser @this);
+        public static extern ref bool UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_TwoFactorEnabled(IdentityUser<string> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<UserName>k__BackingField")]
-        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_UserName(IdentityUser @this);
+        public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_TestModels_AspNetIdentity_IdentityUser1_UserName(IdentityUser<string> @this);
     }
 }
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IndexEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IndexEntityType.cs
index a4987bdc4f..5592f0f146 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IndexEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/IndexEntityType.cs
@@ -88,7 +88,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<Guid>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<Guid>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<Guid>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/ScaffoldingEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/ScaffoldingEntityType.cs
index 00e1332404..8c0141f0e8 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/ScaffoldingEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Fully_qualified_model/ScaffoldingEntityType.cs
@@ -88,7 +88,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Global_namespace/EntityType1.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Global_namespace/EntityType1.cs
index dae73c32d7..a1ef1e36f3 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Global_namespace/EntityType1.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Global_namespace/EntityType1.cs
@@ -108,7 +108,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
     {
         var id = runtimeEntityType.FindProperty("Id")!;
         var key = runtimeEntityType.FindKey(new[] { id });
-        key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+        key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
         key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
         runtimeEntityType.SetOriginalValuesFactory(
             (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity3EntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity3EntityType.cs
index b21abdbdc2..f4af351d1b 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity3EntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity3EntityType.cs
@@ -145,7 +145,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var name = runtimeEntityType.FindProperty("Name")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var collectionNavigation = runtimeEntityType.FindNavigation("CollectionNavigation")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity4EntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity4EntityType.cs
index 4284c78f93..68c7b57f3c 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity4EntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_manual/LazyProxiesEntity4EntityType.cs
@@ -129,6 +129,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "ReferenceNavigationId",
                 typeof(int),
                 sentinel: 0);
+            referenceNavigationId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(2) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(2) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(referenceNavigationId, 2),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(referenceNavigationId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             referenceNavigationId.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -234,17 +240,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 propertyAccessMode: PropertyAccessMode.Field);
 
             referenceNavigation.SetGetter(
-                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity),
-                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity) == null,
-                (CompiledModelInMemoryTest.LazyProxiesEntity4 instance) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(instance),
-                (CompiledModelInMemoryTest.LazyProxiesEntity4 instance) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(instance) == null);
+                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity),
+                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity) == null,
+                (CompiledModelInMemoryTest.LazyProxiesEntity4 instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(instance),
+                (CompiledModelInMemoryTest.LazyProxiesEntity4 instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(instance) == null);
             referenceNavigation.SetSetter(
-                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity, CompiledModelInMemoryTest.LazyProxiesEntity3 value) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity) = value);
+                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity, CompiledModelInMemoryTest.LazyProxiesEntity3 value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity) = value);
             referenceNavigation.SetMaterializationSetter(
-                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity, CompiledModelInMemoryTest.LazyProxiesEntity3 value) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity) = value);
+                (CompiledModelInMemoryTest.LazyProxiesEntity4 entity, CompiledModelInMemoryTest.LazyProxiesEntity3 value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation(entity) = value);
             referenceNavigation.SetAccessors(
-                (InternalEntityEntry entry) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity4)entry.Entity),
-                (InternalEntityEntry entry) => LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity4)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity4)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity4)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelInMemoryTest.LazyProxiesEntity3>(referenceNavigation),
                 null);
@@ -254,6 +260,7 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            referenceNavigation.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("LazyProxiesEntity4EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity4__referenceNavigation", "TestNamespace") });
             var collectionNavigation = principalEntityType.AddNavigation("CollectionNavigation",
                 runtimeForeignKey,
                 onDependent: false,
@@ -300,7 +307,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var referenceNavigationId = runtimeEntityType.FindProperty("ReferenceNavigationId")!;
             var title = runtimeEntityType.FindProperty("Title")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var referenceNavigation = runtimeEntityType.FindNavigation("ReferenceNavigation")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity1EntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity1EntityType.cs
index 03f1a77ca7..2527c6ffd4 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity1EntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity1EntityType.cs
@@ -87,6 +87,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "ReferenceNavigationId",
                 typeof(int?),
                 nullable: true);
+            referenceNavigationId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Nullable<int>>(1) : entry.FlaggedAsTemporary(1) && !entry.ReadShadowValue<Nullable<int>>(0).HasValue ? entry.ReadTemporaryValue<Nullable<int>>(1) : entry.ReadShadowValue<Nullable<int>>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<int>>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Nullable<int>>(referenceNavigationId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Nullable<int>>(referenceNavigationId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             referenceNavigationId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -148,17 +154,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 propertyAccessMode: PropertyAccessMode.Field);
 
             referenceNavigation.SetGetter(
-                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity),
-                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity) == null,
-                (CompiledModelInMemoryTest.LazyProxiesEntity1 instance) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(instance),
-                (CompiledModelInMemoryTest.LazyProxiesEntity1 instance) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(instance) == null);
+                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity),
+                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity) == null,
+                (CompiledModelInMemoryTest.LazyProxiesEntity1 instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(instance),
+                (CompiledModelInMemoryTest.LazyProxiesEntity1 instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(instance) == null);
             referenceNavigation.SetSetter(
-                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity, CompiledModelInMemoryTest.LazyProxiesEntity2 value) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity) = value);
+                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity, CompiledModelInMemoryTest.LazyProxiesEntity2 value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity) = value);
             referenceNavigation.SetMaterializationSetter(
-                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity, CompiledModelInMemoryTest.LazyProxiesEntity2 value) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity) = value);
+                (CompiledModelInMemoryTest.LazyProxiesEntity1 entity, CompiledModelInMemoryTest.LazyProxiesEntity2 value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation(entity) = value);
             referenceNavigation.SetAccessors(
-                (InternalEntityEntry entry) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity1)entry.Entity),
-                (InternalEntityEntry entry) => LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity1)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity1)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation((CompiledModelInMemoryTest.LazyProxiesEntity1)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelInMemoryTest.LazyProxiesEntity2>(referenceNavigation),
                 null);
@@ -168,6 +174,7 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            referenceNavigation.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("LazyProxiesEntity1EntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyProxiesEntity1_ReferenceNavigation", "TestNamespace") });
             var collectionNavigation = principalEntityType.AddNavigation("CollectionNavigation",
                 runtimeForeignKey,
                 onDependent: false,
@@ -211,7 +218,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var referenceNavigationId = runtimeEntityType.FindProperty("ReferenceNavigationId")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var referenceNavigation = runtimeEntityType.FindNavigation("ReferenceNavigation")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity2EntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity2EntityType.cs
index 8a61db6c10..82f3924627 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity2EntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Lazy_loading_proxies/LazyProxiesEntity2EntityType.cs
@@ -101,7 +101,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var collectionNavigation = runtimeEntityType.FindNavigation("CollectionNavigation")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyConstructorEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyConstructorEntityEntityType.cs
index ebe9d59d34..1ac539dcbb 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyConstructorEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyConstructorEntityEntityType.cs
@@ -101,7 +101,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         {
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var lazyPropertyDelegateEntity = runtimeEntityType.FindNavigation("LazyPropertyDelegateEntity")!;
             var lazyPropertyEntity = runtimeEntityType.FindNavigation("LazyPropertyEntity")!;
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyDelegateEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyDelegateEntityEntityType.cs
index d066f8120b..333a0af238 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyDelegateEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyDelegateEntityEntityType.cs
@@ -178,17 +178,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 propertyAccessMode: PropertyAccessMode.Field);
 
             lazyConstructorEntity.SetGetter(
-                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity),
-                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity) == null,
-                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity instance) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(instance),
-                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity instance) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(instance) == null);
+                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity),
+                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity) == null,
+                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(instance),
+                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(instance) == null);
             lazyConstructorEntity.SetSetter(
-                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity) = value);
+                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity) = value);
             lazyConstructorEntity.SetMaterializationSetter(
-                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity) = value);
+                (CompiledModelInMemoryTest.LazyPropertyDelegateEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity(entity) = value);
             lazyConstructorEntity.SetAccessors(
-                (InternalEntityEntry entry) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyDelegateEntity)entry.Entity),
-                (InternalEntityEntry entry) => LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyDelegateEntity)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyDelegateEntity)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyDelegateEntity)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelInMemoryTest.LazyConstructorEntity>(lazyConstructorEntity),
                 null);
@@ -198,6 +198,7 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            lazyConstructorEntity.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("LazyPropertyDelegateEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyDelegateEntity_LazyConstructorEntity", "TestNamespace") });
             var lazyPropertyDelegateEntity = principalEntityType.AddNavigation("LazyPropertyDelegateEntity",
                 runtimeForeignKey,
                 onDependent: false,
@@ -236,7 +237,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var lazyConstructorEntityId = runtimeEntityType.FindProperty("LazyConstructorEntityId")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var lazyConstructorEntity = runtimeEntityType.FindNavigation("LazyConstructorEntity")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyEntityEntityType.cs
index 93a4f0ec77..63f5988f80 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Manual_lazy_loading/LazyPropertyEntityEntityType.cs
@@ -167,17 +167,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 propertyAccessMode: PropertyAccessMode.Field);
 
             lazyConstructorEntity.SetGetter(
-                (CompiledModelInMemoryTest.LazyPropertyEntity entity) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity),
-                (CompiledModelInMemoryTest.LazyPropertyEntity entity) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity) == null,
-                (CompiledModelInMemoryTest.LazyPropertyEntity instance) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(instance),
-                (CompiledModelInMemoryTest.LazyPropertyEntity instance) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(instance) == null);
+                (CompiledModelInMemoryTest.LazyPropertyEntity entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity),
+                (CompiledModelInMemoryTest.LazyPropertyEntity entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity) == null,
+                (CompiledModelInMemoryTest.LazyPropertyEntity instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(instance),
+                (CompiledModelInMemoryTest.LazyPropertyEntity instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(instance) == null);
             lazyConstructorEntity.SetSetter(
-                (CompiledModelInMemoryTest.LazyPropertyEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity) = value);
+                (CompiledModelInMemoryTest.LazyPropertyEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity) = value);
             lazyConstructorEntity.SetMaterializationSetter(
-                (CompiledModelInMemoryTest.LazyPropertyEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity) = value);
+                (CompiledModelInMemoryTest.LazyPropertyEntity entity, CompiledModelInMemoryTest.LazyConstructorEntity value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity(entity) = value);
             lazyConstructorEntity.SetAccessors(
-                (InternalEntityEntry entry) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyEntity)entry.Entity),
-                (InternalEntityEntry entry) => LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyEntity)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyEntity)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity((CompiledModelInMemoryTest.LazyPropertyEntity)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelInMemoryTest.LazyConstructorEntity>(lazyConstructorEntity),
                 null);
@@ -187,6 +187,7 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            lazyConstructorEntity.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("LazyPropertyEntityEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_LazyPropertyEntity_LazyConstructorEntity", "TestNamespace") });
             var lazyPropertyEntity = principalEntityType.AddNavigation("LazyPropertyEntity",
                 runtimeForeignKey,
                 onDependent: false,
@@ -225,7 +226,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var lazyConstructorEntityId = runtimeEntityType.FindProperty("LazyConstructorEntityId")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             var lazyConstructorEntity = runtimeEntityType.FindNavigation("LazyConstructorEntity")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/DependentBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/DependentBaseEntityType.cs
index 16fccb28d3..9e0ee04fa8 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/DependentBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/DependentBaseEntityType.cs
@@ -86,6 +86,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<long>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(1) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -136,17 +142,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<long?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             principal.SetGetter(
-                (CompiledModelTestBase.DependentBase<Nullable<long>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
-                (CompiledModelTestBase.DependentBase<Nullable<long>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
-                (CompiledModelTestBase.DependentBase<Nullable<long>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
-                (CompiledModelTestBase.DependentBase<Nullable<long>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
+                (CompiledModelTestBase.DependentBase<Nullable<long>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
+                (CompiledModelTestBase.DependentBase<Nullable<long>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
+                (CompiledModelTestBase.DependentBase<Nullable<long>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
+                (CompiledModelTestBase.DependentBase<Nullable<long>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
             principal.SetSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<long>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<long>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<long>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<long>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetMaterializationSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<long>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<long>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<long>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<long>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetAccessors(
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<long>>)entry.Entity),
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<long>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<long>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<long>>)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<long>>>>(principal),
                 null);
@@ -156,6 +162,7 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            principal.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal", "TestNamespace") });
             var dependent = principalEntityType.AddNavigation("Dependent",
                 runtimeForeignKey,
                 onDependent: false,
@@ -192,10 +199,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var principalId = runtimeEntityType.FindProperty("PrincipalId")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var key0 = runtimeEntityType.FindKey(new[] { principalId });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<long>(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long>(key0));
             var principal = runtimeEntityType.FindNavigation("Principal")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs
index 21b49ed582..cecad1d8ae 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/RelationshipCycles/PrincipalBaseEntityType.cs
@@ -91,6 +91,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(string),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 1),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             discriminator.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -252,6 +258,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(5) ? entry.ReadStoreGeneratedValue<long>(1) : entry.FlaggedAsTemporary(5) && entry.ReadShadowValue<long>(1) == 0L ? entry.ReadTemporaryValue<long>(1) : entry.ReadShadowValue<long>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalId, 5),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[5]);
             principalId.SetPropertyIndexes(
                 index: 5,
                 originalValueIndex: 5,
@@ -830,10 +842,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var key0 = runtimeEntityType.FindKey(new[] { principalId });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<long>(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long>(key0));
             var deriveds = runtimeEntityType.FindNavigation("Deriveds")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Self_referential_property/SelfReferentialEntityEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Self_referential_property/SelfReferentialEntityEntityType.cs
index f45338523d..97219ad4ce 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Self_referential_property/SelfReferentialEntityEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/Self_referential_property/SelfReferentialEntityEntityType.cs
@@ -141,7 +141,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var collection = runtimeEntityType.FindProperty("Collection")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
index a69890de60..745633e560 100644
--- a/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
+++ b/test/EFCore.InMemory.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
@@ -132,7 +132,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var data = runtimeEntityType.FindProperty("Data")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
@@ -169,7 +169,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
-        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentDerived<int> @this);
+        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentBase<int> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Data>k__BackingField")]
         public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentDerived1_Data(CompiledModelTestBase.DependentDerived<int> @this);
diff --git a/test/EFCore.NativeAotTests/CompiledModels/UserEntityType.cs b/test/EFCore.NativeAotTests/CompiledModels/UserEntityType.cs
index bc62e4f8e4..bab54e46fe 100644
--- a/test/EFCore.NativeAotTests/CompiledModels/UserEntityType.cs
+++ b/test/EFCore.NativeAotTests/CompiledModels/UserEntityType.cs
@@ -71,9 +71,7 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType? ba
             name.TypeMapping = SqlServerStringTypeMapping.Default;
             name.AddAnnotation("SqlServer:ValueGenerationStrategy", SqlServerValueGenerationStrategy.None);
 
-            var key = runtimeEntityType.AddKey(
-                new[] { id });
-            // TODO: Also set DependentKeyValueFactory on the referencing FKs
+            var key = runtimeEntityType.AddKey(new[] { id });
             key.SetPrincipalKeyValueFactory(new SimplePrincipalKeyValueFactory<int>(key));
             key.SetIdentityMapFactory(sensitiveLoggingEnabled =>
                 new IdentityMap<int>(key, ((IRuntimeKey)key).GetPrincipalKeyValueFactory<int>(), sensitiveLoggingEnabled));
diff --git a/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs b/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
index 9aa7a729f1..4607bdbad9 100644
--- a/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
+++ b/test/EFCore.Specification.Tests/Scaffolding/CompiledModelTestBase.cs
@@ -1326,6 +1326,7 @@ protected override string StoreName
         build.References.Add(BuildReference.ByName("System.Linq"));
         build.References.Add(BuildReference.ByName("System.Net.Primitives"));
         build.References.Add(BuildReference.ByName("System.Net.NetworkInformation"));
+        build.References.Add(BuildReference.ByName("System.Text.Json"));
         build.References.Add(BuildReference.ByName("System.Threading.Thread"));
         build.References.Add(BuildReference.ByName("Microsoft.EntityFrameworkCore"));
         build.References.Add(BuildReference.ByName("Microsoft.EntityFrameworkCore.Abstractions"));
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs
index 92100e91fd..a47b5b3109 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs
@@ -6,6 +6,7 @@
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -100,41 +101,31 @@ private IRelationalModel CreateRelationalModel()
             var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
             var principalIdColumn = new Column("PrincipalId", "bigint", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
+            principalIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalIdColumn);
             var principalAlternateIdColumn = new Column("PrincipalAlternateId", "uniqueidentifier", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
+            principalAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalAlternateIdColumn);
             var dataColumn = new Column("Data", "char(20)", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Data", dataColumn);
+            dataColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dataColumn);
             var enumDiscriminatorColumn = new Column("EnumDiscriminator", "int", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
+            enumDiscriminatorColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumDiscriminatorColumn);
             var idColumn = new Column("Id", "tinyint", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(idColumn);
             var moneyColumn = new Column("Money", "decimal(9,3)", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Money", moneyColumn);
-            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
-            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
-            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId", "PrincipalAlternateId" });
-            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
-            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
-            var iX_DependentBasebyte_PrincipalId = new TableIndex(
-            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
-            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId" });
-            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
-            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
+            moneyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(moneyColumn);
             relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
             var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
             {
@@ -175,6 +166,24 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);
+            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
+            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
+            pK_DependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_DependentBasebyte));
+            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId", "PrincipalAlternateId" });
+            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
+            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
+            var iX_DependentBasebyte_PrincipalId = new TableIndex(
+            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
+            iX_DependentBasebyte_PrincipalId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_DependentBasebyte_PrincipalId));
+            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId" });
+            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
+            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
 
             var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes")!;
 
@@ -1088,651 +1097,901 @@ private IRelationalModel CreateRelationalModel()
             var manyTypesTable = new Table("ManyTypes", null, relationalModel);
             var idColumn0 = new Column("Id", "int", manyTypesTable);
             manyTypesTable.Columns.Add("Id", idColumn0);
+            idColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn0);
             var boolColumn = new Column("Bool", "bit", manyTypesTable);
             manyTypesTable.Columns.Add("Bool", boolColumn);
+            boolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(boolColumn);
             var boolArrayColumn = new Column("BoolArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
+            boolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolArrayColumn);
             var boolNestedCollectionColumn = new Column("BoolNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BoolNestedCollection", boolNestedCollectionColumn);
+            boolNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolNestedCollectionColumn);
             var boolToStringConverterPropertyColumn = new Column("BoolToStringConverterProperty", "nvarchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToStringConverterProperty", boolToStringConverterPropertyColumn);
+            boolToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolToStringConverterPropertyColumn);
             var boolToTwoValuesConverterPropertyColumn = new Column("BoolToTwoValuesConverterProperty", "tinyint", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToTwoValuesConverterProperty", boolToTwoValuesConverterPropertyColumn);
+            boolToTwoValuesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(boolToTwoValuesConverterPropertyColumn);
             var boolToZeroOneConverterPropertyColumn = new Column("BoolToZeroOneConverterProperty", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToZeroOneConverterProperty", boolToZeroOneConverterPropertyColumn);
+            boolToZeroOneConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(boolToZeroOneConverterPropertyColumn);
             var bytesColumn = new Column("Bytes", "varbinary(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Bytes", bytesColumn);
+            bytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(bytesColumn);
             var bytesArrayColumn = new Column("BytesArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
+            bytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesArrayColumn);
             var bytesNestedCollectionColumn = new Column("BytesNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BytesNestedCollection", bytesNestedCollectionColumn);
+            bytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesNestedCollectionColumn);
             var bytesToStringConverterPropertyColumn = new Column("BytesToStringConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BytesToStringConverterProperty", bytesToStringConverterPropertyColumn);
+            bytesToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesToStringConverterPropertyColumn);
             var castingConverterPropertyColumn = new Column("CastingConverterProperty", "decimal(18,2)", manyTypesTable);
             manyTypesTable.Columns.Add("CastingConverterProperty", castingConverterPropertyColumn);
+            castingConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(castingConverterPropertyColumn);
             var charColumn = new Column("Char", "nvarchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("Char", charColumn);
+            charColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charColumn);
             var charArrayColumn = new Column("CharArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("CharArray", charArrayColumn);
+            charArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charArrayColumn);
             var charNestedCollectionColumn = new Column("CharNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("CharNestedCollection", charNestedCollectionColumn);
+            charNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charNestedCollectionColumn);
             var charToStringConverterPropertyColumn = new Column("CharToStringConverterProperty", "nchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("CharToStringConverterProperty", charToStringConverterPropertyColumn);
+            charToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charToStringConverterPropertyColumn);
             var dateOnlyColumn = new Column("DateOnly", "date", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
+            dateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(dateOnlyColumn);
             var dateOnlyArrayColumn = new Column("DateOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
+            dateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyArrayColumn);
             var dateOnlyToStringConverterPropertyColumn = new Column("DateOnlyToStringConverterProperty", "nvarchar(10)", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyToStringConverterProperty", dateOnlyToStringConverterPropertyColumn);
+            dateOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyToStringConverterPropertyColumn);
             var dateTimeColumn = new Column("DateTime", "datetime2", manyTypesTable);
             manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
+            dateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeColumn);
             var dateTimeArrayColumn = new Column("DateTimeArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
+            dateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeArrayColumn);
             var dateTimeOffsetToBinaryConverterPropertyColumn = new Column("DateTimeOffsetToBinaryConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBinaryConverterProperty", dateTimeOffsetToBinaryConverterPropertyColumn);
+            dateTimeOffsetToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeOffsetToBinaryConverterPropertyColumn);
             var dateTimeOffsetToBytesConverterPropertyColumn = new Column("DateTimeOffsetToBytesConverterProperty", "varbinary(12)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBytesConverterProperty", dateTimeOffsetToBytesConverterPropertyColumn);
+            dateTimeOffsetToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(dateTimeOffsetToBytesConverterPropertyColumn);
             var dateTimeOffsetToStringConverterPropertyColumn = new Column("DateTimeOffsetToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToStringConverterProperty", dateTimeOffsetToStringConverterPropertyColumn);
+            dateTimeOffsetToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeOffsetToStringConverterPropertyColumn);
             var dateTimeToBinaryConverterPropertyColumn = new Column("DateTimeToBinaryConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToBinaryConverterProperty", dateTimeToBinaryConverterPropertyColumn);
+            dateTimeToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeToBinaryConverterPropertyColumn);
             var dateTimeToStringConverterPropertyColumn = new Column("DateTimeToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToStringConverterProperty", dateTimeToStringConverterPropertyColumn);
+            dateTimeToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeToStringConverterPropertyColumn);
             var dateTimeToTicksConverterPropertyColumn = new Column("DateTimeToTicksConverterProperty", "datetime2", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToTicksConverterProperty", dateTimeToTicksConverterPropertyColumn);
+            dateTimeToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeToTicksConverterPropertyColumn);
             var decimalColumn = new Column("Decimal", "decimal(18,2)", manyTypesTable);
             manyTypesTable.Columns.Add("Decimal", decimalColumn);
+            decimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(decimalColumn);
             var decimalArrayColumn = new Column("DecimalArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
+            decimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalArrayColumn);
             var decimalNumberToBytesConverterPropertyColumn = new Column("DecimalNumberToBytesConverterProperty", "varbinary(16)", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToBytesConverterProperty", decimalNumberToBytesConverterPropertyColumn);
+            decimalNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(decimalNumberToBytesConverterPropertyColumn);
             var decimalNumberToStringConverterPropertyColumn = new Column("DecimalNumberToStringConverterProperty", "nvarchar(64)", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToStringConverterProperty", decimalNumberToStringConverterPropertyColumn);
+            decimalNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalNumberToStringConverterPropertyColumn);
             var doubleColumn = new Column("Double", "float", manyTypesTable);
             manyTypesTable.Columns.Add("Double", doubleColumn);
+            doubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(doubleColumn);
             var doubleArrayColumn = new Column("DoubleArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
+            doubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleArrayColumn);
             var doubleNumberToBytesConverterPropertyColumn = new Column("DoubleNumberToBytesConverterProperty", "varbinary(8)", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToBytesConverterProperty", doubleNumberToBytesConverterPropertyColumn);
+            doubleNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(doubleNumberToBytesConverterPropertyColumn);
             var doubleNumberToStringConverterPropertyColumn = new Column("DoubleNumberToStringConverterProperty", "nvarchar(64)", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToStringConverterProperty", doubleNumberToStringConverterPropertyColumn);
+            doubleNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleNumberToStringConverterPropertyColumn);
             var enum16Column = new Column("Enum16", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16", enum16Column);
+            enum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(enum16Column);
             var enum16ArrayColumn = new Column("Enum16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Array", enum16ArrayColumn);
+            enum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16ArrayColumn);
             var enum16AsStringColumn = new Column("Enum16AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsString", enum16AsStringColumn);
+            enum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringColumn);
             var enum16AsStringArrayColumn = new Column("Enum16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringArray", enum16AsStringArrayColumn);
+            enum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringArrayColumn);
             var enum16AsStringCollectionColumn = new Column("Enum16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringCollection", enum16AsStringCollectionColumn);
+            enum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringCollectionColumn);
             var enum16CollectionColumn = new Column("Enum16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Collection", enum16CollectionColumn);
+            enum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16CollectionColumn);
             var enum32Column = new Column("Enum32", "int", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32", enum32Column);
+            enum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum32Column);
             var enum32ArrayColumn = new Column("Enum32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Array", enum32ArrayColumn);
+            enum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32ArrayColumn);
             var enum32AsStringColumn = new Column("Enum32AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsString", enum32AsStringColumn);
+            enum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringColumn);
             var enum32AsStringArrayColumn = new Column("Enum32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringArray", enum32AsStringArrayColumn);
+            enum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringArrayColumn);
             var enum32AsStringCollectionColumn = new Column("Enum32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringCollection", enum32AsStringCollectionColumn);
+            enum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringCollectionColumn);
             var enum32CollectionColumn = new Column("Enum32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Collection", enum32CollectionColumn);
+            enum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32CollectionColumn);
             var enum32NestedCollectionColumn = new Column("Enum32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32NestedCollection", enum32NestedCollectionColumn);
+            enum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32NestedCollectionColumn);
             var enum64Column = new Column("Enum64", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64", enum64Column);
+            enum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(enum64Column);
             var enum64ArrayColumn = new Column("Enum64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Array", enum64ArrayColumn);
+            enum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64ArrayColumn);
             var enum64AsStringColumn = new Column("Enum64AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsString", enum64AsStringColumn);
+            enum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringColumn);
             var enum64AsStringArrayColumn = new Column("Enum64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringArray", enum64AsStringArrayColumn);
+            enum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringArrayColumn);
             var enum64AsStringCollectionColumn = new Column("Enum64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringCollection", enum64AsStringCollectionColumn);
+            enum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringCollectionColumn);
             var enum64CollectionColumn = new Column("Enum64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Collection", enum64CollectionColumn);
+            enum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64CollectionColumn);
             var enum8Column = new Column("Enum8", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8", enum8Column);
+            enum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(enum8Column);
             var enum8ArrayColumn = new Column("Enum8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Array", enum8ArrayColumn);
+            enum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8ArrayColumn);
             var enum8AsStringColumn = new Column("Enum8AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsString", enum8AsStringColumn);
+            enum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringColumn);
             var enum8AsStringArrayColumn = new Column("Enum8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringArray", enum8AsStringArrayColumn);
+            enum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringArrayColumn);
             var enum8AsStringCollectionColumn = new Column("Enum8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringCollection", enum8AsStringCollectionColumn);
+            enum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringCollectionColumn);
             var enum8CollectionColumn = new Column("Enum8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Collection", enum8CollectionColumn);
+            enum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8CollectionColumn);
             var enum8NestedCollectionColumn = new Column("Enum8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8NestedCollection", enum8NestedCollectionColumn);
+            enum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8NestedCollectionColumn);
             var enumToNumberConverterPropertyColumn = new Column("EnumToNumberConverterProperty", "int", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToNumberConverterProperty", enumToNumberConverterPropertyColumn);
+            enumToNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumToNumberConverterPropertyColumn);
             var enumToStringConverterPropertyColumn = new Column("EnumToStringConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToStringConverterProperty", enumToStringConverterPropertyColumn);
+            enumToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumToStringConverterPropertyColumn);
             var enumU16Column = new Column("EnumU16", "int", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16", enumU16Column);
+            enumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumU16Column);
             var enumU16ArrayColumn = new Column("EnumU16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Array", enumU16ArrayColumn);
+            enumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16ArrayColumn);
             var enumU16AsStringColumn = new Column("EnumU16AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsString", enumU16AsStringColumn);
+            enumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringColumn);
             var enumU16AsStringArrayColumn = new Column("EnumU16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringArray", enumU16AsStringArrayColumn);
+            enumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringArrayColumn);
             var enumU16AsStringCollectionColumn = new Column("EnumU16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringCollection", enumU16AsStringCollectionColumn);
+            enumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringCollectionColumn);
             var enumU16CollectionColumn = new Column("EnumU16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Collection", enumU16CollectionColumn);
+            enumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16CollectionColumn);
             var enumU32Column = new Column("EnumU32", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32", enumU32Column);
+            enumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(enumU32Column);
             var enumU32ArrayColumn = new Column("EnumU32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Array", enumU32ArrayColumn);
+            enumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32ArrayColumn);
             var enumU32AsStringColumn = new Column("EnumU32AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsString", enumU32AsStringColumn);
+            enumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringColumn);
             var enumU32AsStringArrayColumn = new Column("EnumU32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringArray", enumU32AsStringArrayColumn);
+            enumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringArrayColumn);
             var enumU32AsStringCollectionColumn = new Column("EnumU32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringCollection", enumU32AsStringCollectionColumn);
+            enumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringCollectionColumn);
             var enumU32CollectionColumn = new Column("EnumU32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Collection", enumU32CollectionColumn);
+            enumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32CollectionColumn);
             var enumU64Column = new Column("EnumU64", "decimal(20,0)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64", enumU64Column);
+            enumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(enumU64Column);
             var enumU64ArrayColumn = new Column("EnumU64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Array", enumU64ArrayColumn);
+            enumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64ArrayColumn);
             var enumU64AsStringColumn = new Column("EnumU64AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsString", enumU64AsStringColumn);
+            enumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringColumn);
             var enumU64AsStringArrayColumn = new Column("EnumU64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringArray", enumU64AsStringArrayColumn);
+            enumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringArrayColumn);
             var enumU64AsStringCollectionColumn = new Column("EnumU64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringCollection", enumU64AsStringCollectionColumn);
+            enumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringCollectionColumn);
             var enumU64CollectionColumn = new Column("EnumU64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Collection", enumU64CollectionColumn);
+            enumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64CollectionColumn);
             var enumU64NestedCollectionColumn = new Column("EnumU64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64NestedCollection", enumU64NestedCollectionColumn);
+            enumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64NestedCollectionColumn);
             var enumU8Column = new Column("EnumU8", "tinyint", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8", enumU8Column);
+            enumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(enumU8Column);
             var enumU8ArrayColumn = new Column("EnumU8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Array", enumU8ArrayColumn);
+            enumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8ArrayColumn);
             var enumU8AsStringColumn = new Column("EnumU8AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsString", enumU8AsStringColumn);
+            enumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringColumn);
             var enumU8AsStringArrayColumn = new Column("EnumU8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringArray", enumU8AsStringArrayColumn);
+            enumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringArrayColumn);
             var enumU8AsStringCollectionColumn = new Column("EnumU8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringCollection", enumU8AsStringCollectionColumn);
+            enumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringCollectionColumn);
             var enumU8CollectionColumn = new Column("EnumU8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Collection", enumU8CollectionColumn);
+            enumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8CollectionColumn);
             var floatColumn = new Column("Float", "real", manyTypesTable);
             manyTypesTable.Columns.Add("Float", floatColumn);
+            floatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(floatColumn);
             var floatArrayColumn = new Column("FloatArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
+            floatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(floatArrayColumn);
             var guidColumn = new Column("Guid", "uniqueidentifier", manyTypesTable);
             manyTypesTable.Columns.Add("Guid", guidColumn);
+            guidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(guidColumn);
             var guidArrayColumn = new Column("GuidArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
+            guidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidArrayColumn);
             var guidNestedCollectionColumn = new Column("GuidNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidNestedCollection", guidNestedCollectionColumn);
+            guidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidNestedCollectionColumn);
             var guidToBytesConverterPropertyColumn = new Column("GuidToBytesConverterProperty", "varbinary(16)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToBytesConverterProperty", guidToBytesConverterPropertyColumn);
+            guidToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(guidToBytesConverterPropertyColumn);
             var guidToStringConverterPropertyColumn = new Column("GuidToStringConverterProperty", "nvarchar(36)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToStringConverterProperty", guidToStringConverterPropertyColumn);
+            guidToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidToStringConverterPropertyColumn);
             var iPAddressColumn = new Column("IPAddress", "nvarchar(45)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
+            iPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressColumn);
             var iPAddressArrayColumn = new Column("IPAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
+            iPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressArrayColumn);
             var iPAddressToBytesConverterPropertyColumn = new Column("IPAddressToBytesConverterProperty", "varbinary(16)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToBytesConverterProperty", iPAddressToBytesConverterPropertyColumn);
+            iPAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(iPAddressToBytesConverterPropertyColumn);
             var iPAddressToStringConverterPropertyColumn = new Column("IPAddressToStringConverterProperty", "nvarchar(45)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToStringConverterProperty", iPAddressToStringConverterPropertyColumn);
+            iPAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressToStringConverterPropertyColumn);
             var int16Column = new Column("Int16", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Int16", int16Column);
+            int16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(int16Column);
             var int16ArrayColumn = new Column("Int16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
+            int16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int16ArrayColumn);
             var int32Column = new Column("Int32", "int", manyTypesTable);
             manyTypesTable.Columns.Add("Int32", int32Column);
+            int32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(int32Column);
             var int32ArrayColumn = new Column("Int32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
+            int32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32ArrayColumn);
             var int32NestedCollectionColumn = new Column("Int32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int32NestedCollection", int32NestedCollectionColumn);
+            int32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32NestedCollectionColumn);
             var int64Column = new Column("Int64", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("Int64", int64Column);
+            int64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(int64Column);
             var int64ArrayColumn = new Column("Int64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
+            int64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64ArrayColumn);
             var int64NestedCollectionColumn = new Column("Int64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int64NestedCollection", int64NestedCollectionColumn);
+            int64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64NestedCollectionColumn);
             var int8Column = new Column("Int8", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Int8", int8Column);
+            int8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(int8Column);
             var int8ArrayColumn = new Column("Int8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
+            int8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8ArrayColumn);
             var int8NestedCollectionColumn = new Column("Int8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int8NestedCollection", int8NestedCollectionColumn);
+            int8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8NestedCollectionColumn);
             var intNumberToBytesConverterPropertyColumn = new Column("IntNumberToBytesConverterProperty", "varbinary(4)", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToBytesConverterProperty", intNumberToBytesConverterPropertyColumn);
+            intNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(intNumberToBytesConverterPropertyColumn);
             var intNumberToStringConverterPropertyColumn = new Column("IntNumberToStringConverterProperty", "nvarchar(64)", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToStringConverterProperty", intNumberToStringConverterPropertyColumn);
+            intNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(intNumberToStringConverterPropertyColumn);
             var nullIntToNullStringConverterPropertyColumn = new Column("NullIntToNullStringConverterProperty", "nvarchar(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullIntToNullStringConverterProperty", nullIntToNullStringConverterPropertyColumn);
+            nullIntToNullStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullIntToNullStringConverterPropertyColumn);
             var nullableBoolColumn = new Column("NullableBool", "bit", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
+            nullableBoolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(nullableBoolColumn);
             var nullableBoolArrayColumn = new Column("NullableBoolArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
+            nullableBoolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBoolArrayColumn);
             var nullableBytesColumn = new Column("NullableBytes", "varbinary(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
+            nullableBytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(nullableBytesColumn);
             var nullableBytesArrayColumn = new Column("NullableBytesArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
+            nullableBytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesArrayColumn);
             var nullableBytesNestedCollectionColumn = new Column("NullableBytesNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesNestedCollection", nullableBytesNestedCollectionColumn);
+            nullableBytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesNestedCollectionColumn);
             var nullableCharColumn = new Column("NullableChar", "nvarchar(1)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
+            nullableCharColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableCharColumn);
             var nullableCharArrayColumn = new Column("NullableCharArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
+            nullableCharArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableCharArrayColumn);
             var nullableDateOnlyColumn = new Column("NullableDateOnly", "date", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
+            nullableDateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(nullableDateOnlyColumn);
             var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
+            nullableDateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateOnlyArrayColumn);
             var nullableDateTimeColumn = new Column("NullableDateTime", "datetime2", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
+            nullableDateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(nullableDateTimeColumn);
             var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
+            nullableDateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateTimeArrayColumn);
             var nullableDecimalColumn = new Column("NullableDecimal", "decimal(18,2)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
+            nullableDecimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableDecimalColumn);
             var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
+            nullableDecimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDecimalArrayColumn);
             var nullableDoubleColumn = new Column("NullableDouble", "float", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
+            nullableDoubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(nullableDoubleColumn);
             var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
+            nullableDoubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDoubleArrayColumn);
             var nullableEnum16Column = new Column("NullableEnum16", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16", nullableEnum16Column);
+            nullableEnum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16Column);
             var nullableEnum16ArrayColumn = new Column("NullableEnum16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Array", nullableEnum16ArrayColumn);
+            nullableEnum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16ArrayColumn);
             var nullableEnum16AsStringColumn = new Column("NullableEnum16AsString", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16AsString", nullableEnum16AsStringColumn);
+            nullableEnum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16AsStringColumn);
             var nullableEnum16AsStringArrayColumn = new Column("NullableEnum16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringArray", nullableEnum16AsStringArrayColumn);
+            nullableEnum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringArrayColumn);
             var nullableEnum16AsStringCollectionColumn = new Column("NullableEnum16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringCollection", nullableEnum16AsStringCollectionColumn);
+            nullableEnum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringCollectionColumn);
             var nullableEnum16CollectionColumn = new Column("NullableEnum16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Collection", nullableEnum16CollectionColumn);
+            nullableEnum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16CollectionColumn);
             var nullableEnum32Column = new Column("NullableEnum32", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32", nullableEnum32Column);
+            nullableEnum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32Column);
             var nullableEnum32ArrayColumn = new Column("NullableEnum32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Array", nullableEnum32ArrayColumn);
+            nullableEnum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32ArrayColumn);
             var nullableEnum32AsStringColumn = new Column("NullableEnum32AsString", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32AsString", nullableEnum32AsStringColumn);
+            nullableEnum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32AsStringColumn);
             var nullableEnum32AsStringArrayColumn = new Column("NullableEnum32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringArray", nullableEnum32AsStringArrayColumn);
+            nullableEnum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringArrayColumn);
             var nullableEnum32AsStringCollectionColumn = new Column("NullableEnum32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringCollection", nullableEnum32AsStringCollectionColumn);
+            nullableEnum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringCollectionColumn);
             var nullableEnum32CollectionColumn = new Column("NullableEnum32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Collection", nullableEnum32CollectionColumn);
+            nullableEnum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32CollectionColumn);
             var nullableEnum32NestedCollectionColumn = new Column("NullableEnum32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32NestedCollection", nullableEnum32NestedCollectionColumn);
+            nullableEnum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32NestedCollectionColumn);
             var nullableEnum64Column = new Column("NullableEnum64", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64", nullableEnum64Column);
+            nullableEnum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64Column);
             var nullableEnum64ArrayColumn = new Column("NullableEnum64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Array", nullableEnum64ArrayColumn);
+            nullableEnum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64ArrayColumn);
             var nullableEnum64AsStringColumn = new Column("NullableEnum64AsString", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64AsString", nullableEnum64AsStringColumn);
+            nullableEnum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64AsStringColumn);
             var nullableEnum64AsStringArrayColumn = new Column("NullableEnum64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringArray", nullableEnum64AsStringArrayColumn);
+            nullableEnum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringArrayColumn);
             var nullableEnum64AsStringCollectionColumn = new Column("NullableEnum64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringCollection", nullableEnum64AsStringCollectionColumn);
+            nullableEnum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringCollectionColumn);
             var nullableEnum64CollectionColumn = new Column("NullableEnum64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Collection", nullableEnum64CollectionColumn);
+            nullableEnum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64CollectionColumn);
             var nullableEnum8Column = new Column("NullableEnum8", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8", nullableEnum8Column);
+            nullableEnum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum8Column);
             var nullableEnum8ArrayColumn = new Column("NullableEnum8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Array", nullableEnum8ArrayColumn);
+            nullableEnum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8ArrayColumn);
             var nullableEnum8AsStringColumn = new Column("NullableEnum8AsString", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8AsString", nullableEnum8AsStringColumn);
+            nullableEnum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum8AsStringColumn);
             var nullableEnum8AsStringArrayColumn = new Column("NullableEnum8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringArray", nullableEnum8AsStringArrayColumn);
+            nullableEnum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringArrayColumn);
             var nullableEnum8AsStringCollectionColumn = new Column("NullableEnum8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringCollection", nullableEnum8AsStringCollectionColumn);
+            nullableEnum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringCollectionColumn);
             var nullableEnum8CollectionColumn = new Column("NullableEnum8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Collection", nullableEnum8CollectionColumn);
+            nullableEnum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8CollectionColumn);
             var nullableEnum8NestedCollectionColumn = new Column("NullableEnum8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8NestedCollection", nullableEnum8NestedCollectionColumn);
+            nullableEnum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8NestedCollectionColumn);
             var nullableEnumU16Column = new Column("NullableEnumU16", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16", nullableEnumU16Column);
+            nullableEnumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnumU16Column);
             var nullableEnumU16ArrayColumn = new Column("NullableEnumU16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Array", nullableEnumU16ArrayColumn);
+            nullableEnumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16ArrayColumn);
             var nullableEnumU16AsStringColumn = new Column("NullableEnumU16AsString", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16AsString", nullableEnumU16AsStringColumn);
+            nullableEnumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnumU16AsStringColumn);
             var nullableEnumU16AsStringArrayColumn = new Column("NullableEnumU16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringArray", nullableEnumU16AsStringArrayColumn);
+            nullableEnumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringArrayColumn);
             var nullableEnumU16AsStringCollectionColumn = new Column("NullableEnumU16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringCollection", nullableEnumU16AsStringCollectionColumn);
+            nullableEnumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringCollectionColumn);
             var nullableEnumU16CollectionColumn = new Column("NullableEnumU16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Collection", nullableEnumU16CollectionColumn);
+            nullableEnumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16CollectionColumn);
             var nullableEnumU32Column = new Column("NullableEnumU32", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32", nullableEnumU32Column);
+            nullableEnumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnumU32Column);
             var nullableEnumU32ArrayColumn = new Column("NullableEnumU32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Array", nullableEnumU32ArrayColumn);
+            nullableEnumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32ArrayColumn);
             var nullableEnumU32AsStringColumn = new Column("NullableEnumU32AsString", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32AsString", nullableEnumU32AsStringColumn);
+            nullableEnumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnumU32AsStringColumn);
             var nullableEnumU32AsStringArrayColumn = new Column("NullableEnumU32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringArray", nullableEnumU32AsStringArrayColumn);
+            nullableEnumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringArrayColumn);
             var nullableEnumU32AsStringCollectionColumn = new Column("NullableEnumU32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringCollection", nullableEnumU32AsStringCollectionColumn);
+            nullableEnumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringCollectionColumn);
             var nullableEnumU32CollectionColumn = new Column("NullableEnumU32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Collection", nullableEnumU32CollectionColumn);
+            nullableEnumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32CollectionColumn);
             var nullableEnumU64Column = new Column("NullableEnumU64", "decimal(20,0)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64", nullableEnumU64Column);
+            nullableEnumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableEnumU64Column);
             var nullableEnumU64ArrayColumn = new Column("NullableEnumU64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Array", nullableEnumU64ArrayColumn);
+            nullableEnumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64ArrayColumn);
             var nullableEnumU64AsStringColumn = new Column("NullableEnumU64AsString", "decimal(20,0)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64AsString", nullableEnumU64AsStringColumn);
+            nullableEnumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableEnumU64AsStringColumn);
             var nullableEnumU64AsStringArrayColumn = new Column("NullableEnumU64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringArray", nullableEnumU64AsStringArrayColumn);
+            nullableEnumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringArrayColumn);
             var nullableEnumU64AsStringCollectionColumn = new Column("NullableEnumU64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringCollection", nullableEnumU64AsStringCollectionColumn);
+            nullableEnumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringCollectionColumn);
             var nullableEnumU64CollectionColumn = new Column("NullableEnumU64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Collection", nullableEnumU64CollectionColumn);
+            nullableEnumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64CollectionColumn);
             var nullableEnumU64NestedCollectionColumn = new Column("NullableEnumU64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64NestedCollection", nullableEnumU64NestedCollectionColumn);
+            nullableEnumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64NestedCollectionColumn);
             var nullableEnumU8Column = new Column("NullableEnumU8", "tinyint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8", nullableEnumU8Column);
+            nullableEnumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8Column);
             var nullableEnumU8ArrayColumn = new Column("NullableEnumU8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Array", nullableEnumU8ArrayColumn);
+            nullableEnumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8ArrayColumn);
             var nullableEnumU8AsStringColumn = new Column("NullableEnumU8AsString", "tinyint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8AsString", nullableEnumU8AsStringColumn);
+            nullableEnumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8AsStringColumn);
             var nullableEnumU8AsStringArrayColumn = new Column("NullableEnumU8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringArray", nullableEnumU8AsStringArrayColumn);
+            nullableEnumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringArrayColumn);
             var nullableEnumU8AsStringCollectionColumn = new Column("NullableEnumU8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringCollection", nullableEnumU8AsStringCollectionColumn);
+            nullableEnumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringCollectionColumn);
             var nullableEnumU8CollectionColumn = new Column("NullableEnumU8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Collection", nullableEnumU8CollectionColumn);
+            nullableEnumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8CollectionColumn);
             var nullableFloatColumn = new Column("NullableFloat", "real", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
+            nullableFloatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(nullableFloatColumn);
             var nullableFloatArrayColumn = new Column("NullableFloatArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
+            nullableFloatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableFloatArrayColumn);
             var nullableGuidColumn = new Column("NullableGuid", "uniqueidentifier", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
+            nullableGuidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(nullableGuidColumn);
             var nullableGuidArrayColumn = new Column("NullableGuidArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
+            nullableGuidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidArrayColumn);
             var nullableGuidNestedCollectionColumn = new Column("NullableGuidNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidNestedCollection", nullableGuidNestedCollectionColumn);
+            nullableGuidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidNestedCollectionColumn);
             var nullableIPAddressColumn = new Column("NullableIPAddress", "nvarchar(45)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
+            nullableIPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressColumn);
             var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
+            nullableIPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressArrayColumn);
             var nullableInt16Column = new Column("NullableInt16", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
+            nullableInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableInt16Column);
             var nullableInt16ArrayColumn = new Column("NullableInt16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
+            nullableInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt16ArrayColumn);
             var nullableInt32Column = new Column("NullableInt32", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
+            nullableInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableInt32Column);
             var nullableInt32ArrayColumn = new Column("NullableInt32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
+            nullableInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32ArrayColumn);
             var nullableInt32NestedCollectionColumn = new Column("NullableInt32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32NestedCollection", nullableInt32NestedCollectionColumn);
+            nullableInt32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32NestedCollectionColumn);
             var nullableInt64Column = new Column("NullableInt64", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
+            nullableInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableInt64Column);
             var nullableInt64ArrayColumn = new Column("NullableInt64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
+            nullableInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64ArrayColumn);
             var nullableInt64NestedCollectionColumn = new Column("NullableInt64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64NestedCollection", nullableInt64NestedCollectionColumn);
+            nullableInt64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64NestedCollectionColumn);
             var nullableInt8Column = new Column("NullableInt8", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
+            nullableInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableInt8Column);
             var nullableInt8ArrayColumn = new Column("NullableInt8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
+            nullableInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt8ArrayColumn);
             var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "nvarchar(20)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
+            nullablePhysicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressColumn);
             var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
+            nullablePhysicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressArrayColumn);
             var nullablePhysicalAddressNestedCollectionColumn = new Column("NullablePhysicalAddressNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressNestedCollection", nullablePhysicalAddressNestedCollectionColumn);
+            nullablePhysicalAddressNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressNestedCollectionColumn);
             var nullableStringColumn = new Column("NullableString", "nvarchar(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
+            nullableStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringColumn);
             var nullableStringArrayColumn = new Column("NullableStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
+            nullableStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringArrayColumn);
             var nullableStringNestedCollectionColumn = new Column("NullableStringNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringNestedCollection", nullableStringNestedCollectionColumn);
+            nullableStringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringNestedCollectionColumn);
             var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "time", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
+            nullableTimeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(nullableTimeOnlyColumn);
             var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
+            nullableTimeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeOnlyArrayColumn);
             var nullableTimeSpanColumn = new Column("NullableTimeSpan", "time", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
+            nullableTimeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(nullableTimeSpanColumn);
             var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
+            nullableTimeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeSpanArrayColumn);
             var nullableUInt16Column = new Column("NullableUInt16", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
+            nullableUInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableUInt16Column);
             var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
+            nullableUInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt16ArrayColumn);
             var nullableUInt32Column = new Column("NullableUInt32", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
+            nullableUInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableUInt32Column);
             var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
+            nullableUInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt32ArrayColumn);
             var nullableUInt64Column = new Column("NullableUInt64", "decimal(20,0)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
+            nullableUInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableUInt64Column);
             var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
+            nullableUInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt64ArrayColumn);
             var nullableUInt8Column = new Column("NullableUInt8", "tinyint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
+            nullableUInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableUInt8Column);
             var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
+            nullableUInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8ArrayColumn);
             var nullableUInt8NestedCollectionColumn = new Column("NullableUInt8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8NestedCollection", nullableUInt8NestedCollectionColumn);
+            nullableUInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8NestedCollectionColumn);
             var nullableUriColumn = new Column("NullableUri", "nvarchar(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
+            nullableUriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriColumn);
             var nullableUriArrayColumn = new Column("NullableUriArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
+            nullableUriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriArrayColumn);
             var physicalAddressColumn = new Column("PhysicalAddress", "nvarchar(20)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
+            physicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressColumn);
             var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
+            physicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressArrayColumn);
             var physicalAddressToBytesConverterPropertyColumn = new Column("PhysicalAddressToBytesConverterProperty", "varbinary(8)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToBytesConverterProperty", physicalAddressToBytesConverterPropertyColumn);
+            physicalAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(physicalAddressToBytesConverterPropertyColumn);
             var physicalAddressToStringConverterPropertyColumn = new Column("PhysicalAddressToStringConverterProperty", "nvarchar(20)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToStringConverterProperty", physicalAddressToStringConverterPropertyColumn);
+            physicalAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressToStringConverterPropertyColumn);
             var stringColumn = new Column("String", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("String", stringColumn);
+            stringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringColumn);
             var stringArrayColumn = new Column("StringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
+            stringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringArrayColumn);
             var stringNestedCollectionColumn = new Column("StringNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringNestedCollection", stringNestedCollectionColumn);
+            stringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringNestedCollectionColumn);
             var stringToBoolConverterPropertyColumn = new Column("StringToBoolConverterProperty", "bit", manyTypesTable);
             manyTypesTable.Columns.Add("StringToBoolConverterProperty", stringToBoolConverterPropertyColumn);
+            stringToBoolConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(stringToBoolConverterPropertyColumn);
             var stringToBytesConverterPropertyColumn = new Column("StringToBytesConverterProperty", "varbinary(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("StringToBytesConverterProperty", stringToBytesConverterPropertyColumn);
+            stringToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(stringToBytesConverterPropertyColumn);
             var stringToCharConverterPropertyColumn = new Column("StringToCharConverterProperty", "nvarchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToCharConverterProperty", stringToCharConverterPropertyColumn);
+            stringToCharConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToCharConverterPropertyColumn);
             var stringToDateOnlyConverterPropertyColumn = new Column("StringToDateOnlyConverterProperty", "date", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateOnlyConverterProperty", stringToDateOnlyConverterPropertyColumn);
+            stringToDateOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(stringToDateOnlyConverterPropertyColumn);
             var stringToDateTimeConverterPropertyColumn = new Column("StringToDateTimeConverterProperty", "datetime2", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeConverterProperty", stringToDateTimeConverterPropertyColumn);
+            stringToDateTimeConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(stringToDateTimeConverterPropertyColumn);
             var stringToDateTimeOffsetConverterPropertyColumn = new Column("StringToDateTimeOffsetConverterProperty", "datetimeoffset", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeOffsetConverterProperty", stringToDateTimeOffsetConverterPropertyColumn);
+            stringToDateTimeOffsetConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTimeOffset>(stringToDateTimeOffsetConverterPropertyColumn);
             var stringToDecimalNumberConverterPropertyColumn = new Column("StringToDecimalNumberConverterProperty", "decimal(18,2)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDecimalNumberConverterProperty", stringToDecimalNumberConverterPropertyColumn);
+            stringToDecimalNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(stringToDecimalNumberConverterPropertyColumn);
             var stringToDoubleNumberConverterPropertyColumn = new Column("StringToDoubleNumberConverterProperty", "float", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDoubleNumberConverterProperty", stringToDoubleNumberConverterPropertyColumn);
+            stringToDoubleNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(stringToDoubleNumberConverterPropertyColumn);
             var stringToEnumConverterPropertyColumn = new Column("StringToEnumConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("StringToEnumConverterProperty", stringToEnumConverterPropertyColumn);
+            stringToEnumConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(stringToEnumConverterPropertyColumn);
             var stringToGuidConverterPropertyColumn = new Column("StringToGuidConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToGuidConverterProperty", stringToGuidConverterPropertyColumn);
+            stringToGuidConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToGuidConverterPropertyColumn);
             var stringToIntNumberConverterPropertyColumn = new Column("StringToIntNumberConverterProperty", "int", manyTypesTable);
             manyTypesTable.Columns.Add("StringToIntNumberConverterProperty", stringToIntNumberConverterPropertyColumn);
+            stringToIntNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(stringToIntNumberConverterPropertyColumn);
             var stringToTimeOnlyConverterPropertyColumn = new Column("StringToTimeOnlyConverterProperty", "time", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeOnlyConverterProperty", stringToTimeOnlyConverterPropertyColumn);
+            stringToTimeOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(stringToTimeOnlyConverterPropertyColumn);
             var stringToTimeSpanConverterPropertyColumn = new Column("StringToTimeSpanConverterProperty", "time", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeSpanConverterProperty", stringToTimeSpanConverterPropertyColumn);
+            stringToTimeSpanConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(stringToTimeSpanConverterPropertyColumn);
             var stringToUriConverterPropertyColumn = new Column("StringToUriConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToUriConverterProperty", stringToUriConverterPropertyColumn);
+            stringToUriConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToUriConverterPropertyColumn);
             var timeOnlyColumn = new Column("TimeOnly", "time", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
+            timeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(timeOnlyColumn);
             var timeOnlyArrayColumn = new Column("TimeOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
+            timeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyArrayColumn);
             var timeOnlyToStringConverterPropertyColumn = new Column("TimeOnlyToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToStringConverterProperty", timeOnlyToStringConverterPropertyColumn);
+            timeOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyToStringConverterPropertyColumn);
             var timeOnlyToTicksConverterPropertyColumn = new Column("TimeOnlyToTicksConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToTicksConverterProperty", timeOnlyToTicksConverterPropertyColumn);
+            timeOnlyToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeOnlyToTicksConverterPropertyColumn);
             var timeSpanColumn = new Column("TimeSpan", "time", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
+            timeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(timeSpanColumn);
             var timeSpanArrayColumn = new Column("TimeSpanArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
+            timeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanArrayColumn);
             var timeSpanToStringConverterPropertyColumn = new Column("TimeSpanToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToStringConverterProperty", timeSpanToStringConverterPropertyColumn);
+            timeSpanToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanToStringConverterPropertyColumn);
             var timeSpanToTicksConverterPropertyColumn = new Column("TimeSpanToTicksConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToTicksConverterProperty", timeSpanToTicksConverterPropertyColumn);
+            timeSpanToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeSpanToTicksConverterPropertyColumn);
             var uInt16Column = new Column("UInt16", "int", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16", uInt16Column);
+            uInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(uInt16Column);
             var uInt16ArrayColumn = new Column("UInt16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
+            uInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt16ArrayColumn);
             var uInt32Column = new Column("UInt32", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32", uInt32Column);
+            uInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(uInt32Column);
             var uInt32ArrayColumn = new Column("UInt32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
+            uInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt32ArrayColumn);
             var uInt64Column = new Column("UInt64", "decimal(20,0)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64", uInt64Column);
+            uInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(uInt64Column);
             var uInt64ArrayColumn = new Column("UInt64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
+            uInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt64ArrayColumn);
             var uInt8Column = new Column("UInt8", "tinyint", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8", uInt8Column);
+            uInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(uInt8Column);
             var uInt8ArrayColumn = new Column("UInt8Array", "varbinary(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
+            uInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(uInt8ArrayColumn);
             var uInt8NestedCollectionColumn = new Column("UInt8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8NestedCollection", uInt8NestedCollectionColumn);
+            uInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt8NestedCollectionColumn);
             var uriColumn = new Column("Uri", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Uri", uriColumn);
+            uriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriColumn);
             var uriArrayColumn = new Column("UriArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
+            uriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriArrayColumn);
             var uriToStringConverterPropertyColumn = new Column("UriToStringConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UriToStringConverterProperty", uriToStringConverterPropertyColumn);
-            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn0 });
-            manyTypesTable.PrimaryKey = pK_ManyTypes;
-            var pK_ManyTypesKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
-                new[] { "Id" });
-            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
-            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
+            uriToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriToStringConverterPropertyColumn);
             relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
             var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, null);
             manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
@@ -1995,6 +2254,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriToStringConverterPropertyColumn, manyTypes.FindProperty("UriToStringConverterProperty")!, manyTypesTableMapping);
+            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn0 });
+            manyTypesTable.PrimaryKey = pK_ManyTypes;
+            pK_ManyTypes.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_ManyTypes));
+            var pK_ManyTypesKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
+                new[] { "Id" });
+            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
+            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
 
             var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase")!;
 
@@ -2080,129 +2348,124 @@ private IRelationalModel CreateRelationalModel()
             var principalBaseTable = new Table("PrincipalBase", "mySchema", relationalModel);
             var idColumn1 = new Column("Id", "bigint", principalBaseTable);
             principalBaseTable.Columns.Add("Id", idColumn1);
+            idColumn1.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(idColumn1);
             var alternateIdColumn = new Column("AlternateId", "uniqueidentifier", principalBaseTable);
             principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
+            alternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(alternateIdColumn);
             var enum1Column = new Column("Enum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Enum1", enum1Column);
+            enum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum1Column);
             var enum2Column = new Column("Enum2", "int", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Enum2", enum2Column);
+            enum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum2Column);
             var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
+            flagsEnum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum1Column);
             var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
+            flagsEnum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum2Column);
             var owned_NumberColumn = new Column("Owned_Number", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Owned_Number", owned_NumberColumn);
+            owned_NumberColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(owned_NumberColumn);
             var owned_RefTypeArrayColumn = new Column("Owned_RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeArray", owned_RefTypeArrayColumn);
+            owned_RefTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeArrayColumn);
             var owned_RefTypeEnumerableColumn = new Column("Owned_RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeEnumerable", owned_RefTypeEnumerableColumn);
+            owned_RefTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeEnumerableColumn);
             var owned_RefTypeIListColumn = new Column("Owned_RefTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeIList", owned_RefTypeIListColumn);
+            owned_RefTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeIListColumn);
             var owned_RefTypeListColumn = new Column("Owned_RefTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeList", owned_RefTypeListColumn);
+            owned_RefTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeListColumn);
             var owned_ValueTypeArrayColumn = new Column("Owned_ValueTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeArray", owned_ValueTypeArrayColumn);
+            owned_ValueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeArrayColumn);
             var owned_ValueTypeEnumerableColumn = new Column("Owned_ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeEnumerable", owned_ValueTypeEnumerableColumn);
+            owned_ValueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeEnumerableColumn);
             var owned_ValueTypeIListColumn = new Column("Owned_ValueTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeIList", owned_ValueTypeIListColumn);
+            owned_ValueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeIListColumn);
             var owned_ValueTypeListColumn = new Column("Owned_ValueTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeList", owned_ValueTypeListColumn);
+            owned_ValueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeListColumn);
             var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
+            refTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn);
             var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
+            refTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn);
             var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
+            refTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn);
             var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
+            refTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn);
             var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
+            valueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn);
             var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
+            valueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn);
             var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
+            valueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn);
             var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
-            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn1 });
-            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id" });
-            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
-            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
-            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
-            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn1, alternateIdColumn });
-            principalBaseTable.PrimaryKey = pK;
-            var pKKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id", "AlternateId" });
-            pK.MappedKeys.Add(pKKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
-            var pKKey0 = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType",
-                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
-            pK.MappedKeys.Add(pKKey0);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey0).Add(pK);
-            principalBaseTable.UniqueConstraints.Add("PK", pK);
-            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
-            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn1 }, false);
-            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "AlternateId", "Id" });
-            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
-            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
+            valueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn);
             relationalModel.Tables.Add(("PrincipalBase", "mySchema"), principalBaseTable);
             var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
             {
@@ -2326,18 +2589,16 @@ private IRelationalModel CreateRelationalModel()
             var detailsTable = new Table("Details", null, relationalModel);
             var principalBaseIdColumn = new Column("PrincipalBaseId", "bigint", detailsTable);
             detailsTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
+            principalBaseIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalBaseIdColumn);
             var principalBaseAlternateIdColumn = new Column("PrincipalBaseAlternateId", "uniqueidentifier", detailsTable);
             detailsTable.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumn);
+            principalBaseAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalBaseAlternateIdColumn);
             var detailsColumn = new Column("Details", "nvarchar(max)", detailsTable)
             {
                 IsNullable = true
             };
             detailsTable.Columns.Add("Details", detailsColumn);
-            var pK_Details = new UniqueConstraint("PK_Details", detailsTable, new[] { principalBaseIdColumn, principalBaseAlternateIdColumn });
-            detailsTable.PrimaryKey = pK_Details;
-            pK_Details.MappedKeys.Add(pKKey0);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey0).Add(pK_Details);
-            detailsTable.UniqueConstraints.Add("PK_Details", pK_Details);
+            detailsColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(detailsColumn);
             relationalModel.Tables.Add(("Details", null), detailsTable);
             var detailsTableMapping = new TableMapping(ownedType, detailsTable, null)
             {
@@ -2348,6 +2609,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(principalBaseAlternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, detailsTableMapping);
             RelationalModel.CreateColumnMapping(principalBaseIdColumn, ownedType.FindProperty("PrincipalBaseId")!, detailsTableMapping);
             RelationalModel.CreateColumnMapping(detailsColumn, ownedType.FindProperty("Details")!, detailsTableMapping);
+            var pK_Details = new UniqueConstraint("PK_Details", detailsTable, new[] { principalBaseIdColumn, principalBaseAlternateIdColumn });
+            detailsTable.PrimaryKey = pK_Details;
+            pK_Details.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_Details));
+            var pK_DetailsKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType",
+                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
+            pK_Details.MappedKeys.Add(pK_DetailsKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DetailsKey).Add(pK_Details);
+            detailsTable.UniqueConstraints.Add("PK_Details", pK_Details);
 
             var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>")!;
 
@@ -2404,31 +2674,64 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping1);
             RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping1);
             RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping1);
+            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn1 });
+            aK_PrincipalBase_Id.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(aK_PrincipalBase_Id));
+            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id" });
+            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
+            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
+            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
+            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn1, alternateIdColumn });
+            principalBaseTable.PrimaryKey = pK;
+            pK.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK));
+            var pKKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id", "AlternateId" });
+            pK.MappedKeys.Add(pKKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
+            pK.MappedKeys.Add(pK_DetailsKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DetailsKey).Add(pK);
+            principalBaseTable.UniqueConstraints.Add("PK", pK);
+            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
+            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn1 }, false);
+            iX_PrincipalBase_AlternateId_Id.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBase_AlternateId_Id));
+            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "AlternateId", "Id" });
+            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
+            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
             var principalDerivedTable = new Table("PrincipalDerived", null, relationalModel);
             var derivedIdColumn = new Column("DerivedId", "bigint", principalDerivedTable);
             principalDerivedTable.Columns.Add("DerivedId", derivedIdColumn);
+            derivedIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(derivedIdColumn);
             var alternateIdColumn0 = new Column("AlternateId", "uniqueidentifier", principalDerivedTable);
             principalDerivedTable.Columns.Add("AlternateId", alternateIdColumn0);
+            alternateIdColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(alternateIdColumn0);
+            relationalModel.Tables.Add(("PrincipalDerived", null), principalDerivedTable);
+            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, null);
+            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
+            tableMappings4.Add(principalDerivedTableMapping);
+            RelationalModel.CreateColumnMapping(alternateIdColumn0, principalDerived.FindProperty("AlternateId")!, principalDerivedTableMapping);
+            RelationalModel.CreateColumnMapping(derivedIdColumn, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);
             var aK_PrincipalDerived_DerivedId = new UniqueConstraint("AK_PrincipalDerived_DerivedId", principalDerivedTable, new[] { derivedIdColumn });
+            aK_PrincipalDerived_DerivedId.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(aK_PrincipalDerived_DerivedId));
             aK_PrincipalDerived_DerivedId.MappedKeys.Add(aK_PrincipalBase_IdKey);
             RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalDerived_DerivedId);
             principalDerivedTable.UniqueConstraints.Add("AK_PrincipalDerived_DerivedId", aK_PrincipalDerived_DerivedId);
             var pK0 = new UniqueConstraint("PK", principalDerivedTable, new[] { derivedIdColumn, alternateIdColumn0 });
             principalDerivedTable.PrimaryKey = pK0;
+            pK0.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK0));
             pK0.MappedKeys.Add(pKKey);
             RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK0);
             principalDerivedTable.UniqueConstraints.Add("PK", pK0);
             var iX_PrincipalDerived_AlternateId_DerivedId = new TableIndex(
             "IX_PrincipalDerived_AlternateId_DerivedId", principalDerivedTable, new[] { alternateIdColumn0, derivedIdColumn }, false);
+            iX_PrincipalDerived_AlternateId_DerivedId.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalDerived_AlternateId_DerivedId));
             iX_PrincipalDerived_AlternateId_DerivedId.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
             RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalDerived_AlternateId_DerivedId);
             principalDerivedTable.Indexes.Add("IX_PrincipalDerived_AlternateId_DerivedId", iX_PrincipalDerived_AlternateId_DerivedId);
-            relationalModel.Tables.Add(("PrincipalDerived", null), principalDerivedTable);
-            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, null);
-            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
-            tableMappings4.Add(principalDerivedTableMapping);
-            RelationalModel.CreateColumnMapping(alternateIdColumn0, principalDerived.FindProperty("AlternateId")!, principalDerivedTableMapping);
-            RelationalModel.CreateColumnMapping(derivedIdColumn, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);
 
             var ownedType0 = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType")!;
 
@@ -2511,65 +2814,70 @@ private IRelationalModel CreateRelationalModel()
             var manyOwnedTable = new Table("ManyOwned", null, relationalModel);
             var principalDerivedDependentBasebyteIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>Id", "bigint", manyOwnedTable);
             manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn);
+            principalDerivedDependentBasebyteIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalDerivedDependentBasebyteIdColumn);
             var principalDerivedDependentBasebyteAlternateIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>AlternateId", "uniqueidentifier", manyOwnedTable);
             manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumn);
+            principalDerivedDependentBasebyteAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalDerivedDependentBasebyteAlternateIdColumn);
             var idColumn2 = new Column("Id", "int", manyOwnedTable);
             manyOwnedTable.Columns.Add("Id", idColumn2);
+            idColumn2.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn2);
             var detailsColumn0 = new Column("Details", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("Details", detailsColumn0);
+            detailsColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(detailsColumn0);
             var numberColumn = new Column("Number", "int", manyOwnedTable);
             manyOwnedTable.Columns.Add("Number", numberColumn);
+            numberColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(numberColumn);
             var refTypeArrayColumn0 = new Column("RefTypeArray", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeArray", refTypeArrayColumn0);
+            refTypeArrayColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn0);
             var refTypeEnumerableColumn0 = new Column("RefTypeEnumerable", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn0);
+            refTypeEnumerableColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn0);
             var refTypeIListColumn0 = new Column("RefTypeIList", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeIList", refTypeIListColumn0);
+            refTypeIListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn0);
             var refTypeListColumn0 = new Column("RefTypeList", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeList", refTypeListColumn0);
+            refTypeListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn0);
             var valueTypeArrayColumn0 = new Column("ValueTypeArray", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn0);
+            valueTypeArrayColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn0);
             var valueTypeEnumerableColumn0 = new Column("ValueTypeEnumerable", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn0);
+            valueTypeEnumerableColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn0);
             var valueTypeIListColumn0 = new Column("ValueTypeIList", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeIList", valueTypeIListColumn0);
+            valueTypeIListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn0);
             var valueTypeListColumn0 = new Column("ValueTypeList", "nvarchar(max)", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeList", valueTypeListColumn0);
-            var pK_ManyOwned = new UniqueConstraint("PK_ManyOwned", manyOwnedTable, new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn, idColumn2 });
-            manyOwnedTable.PrimaryKey = pK_ManyOwned;
-            var pK_ManyOwnedKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType",
-                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId", "Id" });
-            pK_ManyOwned.MappedKeys.Add(pK_ManyOwnedKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyOwnedKey).Add(pK_ManyOwned);
-            manyOwnedTable.UniqueConstraints.Add("PK_ManyOwned", pK_ManyOwned);
+            valueTypeListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn0);
             relationalModel.Tables.Add(("ManyOwned", null), manyOwnedTable);
             var manyOwnedTableMapping = new TableMapping(ownedType0, manyOwnedTable, null);
             manyOwnedTable.AddTypeMapping(manyOwnedTableMapping, false);
@@ -2587,6 +2895,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn0, ownedType0.FindProperty("ValueTypeEnumerable")!, manyOwnedTableMapping);
             RelationalModel.CreateColumnMapping(valueTypeIListColumn0, ownedType0.FindProperty("ValueTypeIList")!, manyOwnedTableMapping);
             RelationalModel.CreateColumnMapping(valueTypeListColumn0, ownedType0.FindProperty("ValueTypeList")!, manyOwnedTableMapping);
+            var pK_ManyOwned = new UniqueConstraint("PK_ManyOwned", manyOwnedTable, new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn, idColumn2 });
+            manyOwnedTable.PrimaryKey = pK_ManyOwned;
+            pK_ManyOwned.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_ManyOwned));
+            var pK_ManyOwnedKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType",
+                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId", "Id" });
+            pK_ManyOwned.MappedKeys.Add(pK_ManyOwnedKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyOwnedKey).Add(pK_ManyOwned);
+            manyOwnedTable.UniqueConstraints.Add("PK_ManyOwned", pK_ManyOwned);
 
             var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;
 
@@ -2621,19 +2938,34 @@ private IRelationalModel CreateRelationalModel()
             var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
             var derivedsIdColumn = new Column("DerivedsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
+            derivedsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(derivedsIdColumn);
             var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
+            derivedsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(derivedsAlternateIdColumn);
             var principalsIdColumn = new Column("PrincipalsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
+            principalsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalsIdColumn);
             var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
+            principalsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalsAlternateIdColumn);
             var rowidColumn = new Column("rowid", "rowversion", principalBasePrincipalDerivedDependentBasebyteTable)
             {
                 IsNullable = true
             };
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
+            rowidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(rowidColumn);
+            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
+            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
+            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
+            tableMappings6.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
             principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
+            pK_PrincipalBasePrincipalDerivedDependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_PrincipalBasePrincipalDerivedDependentBasebyte));
             var pK_PrincipalBasePrincipalDerivedDependentBasebyteKey = RelationalModel.GetKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
@@ -2642,25 +2974,18 @@ private IRelationalModel CreateRelationalModel()
             principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
             "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
+            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId));
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" });
             iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
             RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
             principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
-            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
-            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
-            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
-            tableMappings6.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                 "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                 new[] { principalIdColumn },
                 principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
+            fK_DependentBasebyte_PrincipalBase_PrincipalId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_DependentBasebyte_PrincipalBase_PrincipalId));
             var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId" },
@@ -2674,6 +2999,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_DependentBase<byte?>_PrincipalDerived_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalDerivedTable,
                 new[] { principalIdColumn, principalAlternateIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
+            fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId));
             var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId", "PrincipalAlternateId" },
@@ -2687,6 +3013,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId", detailsTable, principalBaseTable,
                 new[] { principalBaseIdColumn, principalBaseAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId));
             var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType",
                 new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
@@ -2700,6 +3027,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_ManyOwned_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id_PrincipalDerived<DependentBase<byte?>>AlternateId", manyOwnedTable, principalDerivedTable,
                 new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId));
             var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType",
                 new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
@@ -2713,6 +3041,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                 new[] { principalsIdColumn, principalsAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" },
@@ -2726,6 +3055,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalDerived_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalDerivedTable,
                 new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId" },
@@ -2739,6 +3069,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId", principalDerivedTable, principalBaseTable,
                 new[] { derivedIdColumn, alternateIdColumn0 },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId));
             var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>",
                 new[] { "Id", "AlternateId" },
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
index 49765b5253..f057e7ef99 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
@@ -44,6 +44,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -71,6 +77,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -100,6 +112,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum1),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            enumDiscriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum1>(enumDiscriminator, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum1>(enumDiscriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             enumDiscriminator.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -215,17 +233,17 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             principal.SetGetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
             principal.SetSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetMaterializationSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetAccessors(
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>>(principal),
                 null);
@@ -235,6 +253,7 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            principal.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal", "TestNamespace") });
             var dependent = principalEntityType.AddNavigation("Dependent",
                 runtimeForeignKey,
                 onDependent: false,
@@ -275,7 +294,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var enumDiscriminator = runtimeEntityType.FindProperty("EnumDiscriminator")!;
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { principalId, principalAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             var principal = runtimeEntityType.FindNavigation("Principal")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
index 55ebcd5628..a9a85f6f7c 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
@@ -87,6 +87,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 precision: 9,
                 scale: 3,
                 sentinel: 0m);
+            money.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(money, 5),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(money),
+                (ValueBuffer valueBuffer) => valueBuffer[5]);
             money.SetPropertyIndexes(
                 index: 5,
                 originalValueIndex: 5,
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
index 54c7e07cbb..2d40767a42 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
@@ -17695,7 +17695,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var uriArray = runtimeEntityType.FindProperty("UriArray")!;
             var uriToStringConverterProperty = runtimeEntityType.FindProperty("UriToStringConverterProperty")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<CompiledModelTestBase.ManyTypesId>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<CompiledModelTestBase.ManyTypesId>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<CompiledModelTestBase.ManyTypesId>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
index c7b1e2d3ef..44ca177bc4 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
@@ -41,6 +41,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalDerivedId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalDerivedId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalDerivedId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalDerivedId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -68,6 +74,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalDerivedAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalDerivedAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalDerivedAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalDerivedAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -98,6 +110,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(2) ? entry.ReadStoreGeneratedValue<int>(2) : entry.FlaggedAsTemporary(2) && entry.ReadShadowValue<int>(2) == 0 ? entry.ReadTemporaryValue<int>(2) : entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 2),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 2),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             id.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -863,7 +881,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalDerivedId, principalDerivedAlternateId, id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
index 122a2f7bf3..fa1a8c1fc4 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
@@ -44,6 +44,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalBaseId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalBaseId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalBaseId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalBaseId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -83,6 +89,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalBaseAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalBaseAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalBaseAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalBaseAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -881,7 +893,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalBaseId, principalBaseAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
index e57e12aedf..36345d1545 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
@@ -1005,10 +1005,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var key0 = runtimeEntityType.FindKey(new[] { id, alternateId });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key0));
             var owned = runtimeEntityType.FindNavigation("Owned")!;
             runtimeEntityType.SetOriginalValuesFactory(
@@ -1094,10 +1094,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeList>k__BackingField")]
         public static extern ref List<short> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_ValueTypeList(CompiledModelTestBase.PrincipalBase @this);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_ownedField")]
         public static extern ref CompiledModelTestBase.OwnedType UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase__ownedField(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
     }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
index f6b4ef2d63..df9543d726 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
@@ -392,7 +392,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var principalsAlternateId = runtimeEntityType.FindProperty("PrincipalsAlternateId")!;
             var rowid = runtimeEntityType.FindProperty("rowid")!;
             var key = runtimeEntityType.FindKey(new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
index a9517d2483..8b887e27f2 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
@@ -159,13 +159,13 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
 
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Dependent>k__BackingField")]
         public static extern ref CompiledModelTestBase.DependentBase<byte?> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Dependent(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "ManyOwned")]
         public static extern ref ICollection<CompiledModelTestBase.OwnedType> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_ManyOwned(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
     }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
index 73be2fb9d2..146f9b6f48 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
@@ -1,11 +1,13 @@
 // <auto-generated />
 using System;
 using System.Collections.Generic;
+using System.Text.Json;
 using Microsoft.EntityFrameworkCore;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -98,41 +100,31 @@ private IRelationalModel CreateRelationalModel()
             var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
             var principalIdColumn = new Column("PrincipalId", "bigint", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
+            principalIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalIdColumn);
             var principalAlternateIdColumn = new Column("PrincipalAlternateId", "uniqueidentifier", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
+            principalAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalAlternateIdColumn);
             var dataColumn = new Column("Data", "char(20)", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Data", dataColumn);
+            dataColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dataColumn);
             var enumDiscriminatorColumn = new Column("EnumDiscriminator", "int", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
+            enumDiscriminatorColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumDiscriminatorColumn);
             var idColumn = new Column("Id", "tinyint", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(idColumn);
             var moneyColumn = new Column("Money", "decimal(9,3)", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Money", moneyColumn);
-            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
-            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
-            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId", "PrincipalAlternateId" });
-            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
-            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
-            var iX_DependentBasebyte_PrincipalId = new TableIndex(
-            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
-            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId" });
-            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
-            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
+            moneyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(moneyColumn);
             relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
             var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
             {
@@ -173,6 +165,24 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);
+            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
+            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
+            pK_DependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_DependentBasebyte));
+            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId", "PrincipalAlternateId" });
+            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
+            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
+            var iX_DependentBasebyte_PrincipalId = new TableIndex(
+            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
+            iX_DependentBasebyte_PrincipalId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_DependentBasebyte_PrincipalId));
+            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId" });
+            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
+            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
 
             var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes")!;
 
@@ -1086,651 +1096,901 @@ private IRelationalModel CreateRelationalModel()
             var manyTypesTable = new Table("ManyTypes", null, relationalModel);
             var idColumn0 = new Column("Id", "int", manyTypesTable);
             manyTypesTable.Columns.Add("Id", idColumn0);
+            idColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn0);
             var boolColumn = new Column("Bool", "bit", manyTypesTable);
             manyTypesTable.Columns.Add("Bool", boolColumn);
+            boolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(boolColumn);
             var boolArrayColumn = new Column("BoolArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
+            boolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolArrayColumn);
             var boolNestedCollectionColumn = new Column("BoolNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BoolNestedCollection", boolNestedCollectionColumn);
+            boolNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolNestedCollectionColumn);
             var boolToStringConverterPropertyColumn = new Column("BoolToStringConverterProperty", "nvarchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToStringConverterProperty", boolToStringConverterPropertyColumn);
+            boolToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolToStringConverterPropertyColumn);
             var boolToTwoValuesConverterPropertyColumn = new Column("BoolToTwoValuesConverterProperty", "tinyint", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToTwoValuesConverterProperty", boolToTwoValuesConverterPropertyColumn);
+            boolToTwoValuesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(boolToTwoValuesConverterPropertyColumn);
             var boolToZeroOneConverterPropertyColumn = new Column("BoolToZeroOneConverterProperty", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToZeroOneConverterProperty", boolToZeroOneConverterPropertyColumn);
+            boolToZeroOneConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(boolToZeroOneConverterPropertyColumn);
             var bytesColumn = new Column("Bytes", "varbinary(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Bytes", bytesColumn);
+            bytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(bytesColumn);
             var bytesArrayColumn = new Column("BytesArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
+            bytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesArrayColumn);
             var bytesNestedCollectionColumn = new Column("BytesNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BytesNestedCollection", bytesNestedCollectionColumn);
+            bytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesNestedCollectionColumn);
             var bytesToStringConverterPropertyColumn = new Column("BytesToStringConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("BytesToStringConverterProperty", bytesToStringConverterPropertyColumn);
+            bytesToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesToStringConverterPropertyColumn);
             var castingConverterPropertyColumn = new Column("CastingConverterProperty", "decimal(18,2)", manyTypesTable);
             manyTypesTable.Columns.Add("CastingConverterProperty", castingConverterPropertyColumn);
+            castingConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(castingConverterPropertyColumn);
             var charColumn = new Column("Char", "nvarchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("Char", charColumn);
+            charColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charColumn);
             var charArrayColumn = new Column("CharArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("CharArray", charArrayColumn);
+            charArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charArrayColumn);
             var charNestedCollectionColumn = new Column("CharNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("CharNestedCollection", charNestedCollectionColumn);
+            charNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charNestedCollectionColumn);
             var charToStringConverterPropertyColumn = new Column("CharToStringConverterProperty", "nchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("CharToStringConverterProperty", charToStringConverterPropertyColumn);
+            charToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charToStringConverterPropertyColumn);
             var dateOnlyColumn = new Column("DateOnly", "date", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
+            dateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(dateOnlyColumn);
             var dateOnlyArrayColumn = new Column("DateOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
+            dateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyArrayColumn);
             var dateOnlyToStringConverterPropertyColumn = new Column("DateOnlyToStringConverterProperty", "nvarchar(10)", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyToStringConverterProperty", dateOnlyToStringConverterPropertyColumn);
+            dateOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyToStringConverterPropertyColumn);
             var dateTimeColumn = new Column("DateTime", "datetime2", manyTypesTable);
             manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
+            dateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeColumn);
             var dateTimeArrayColumn = new Column("DateTimeArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
+            dateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeArrayColumn);
             var dateTimeOffsetToBinaryConverterPropertyColumn = new Column("DateTimeOffsetToBinaryConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBinaryConverterProperty", dateTimeOffsetToBinaryConverterPropertyColumn);
+            dateTimeOffsetToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeOffsetToBinaryConverterPropertyColumn);
             var dateTimeOffsetToBytesConverterPropertyColumn = new Column("DateTimeOffsetToBytesConverterProperty", "varbinary(12)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBytesConverterProperty", dateTimeOffsetToBytesConverterPropertyColumn);
+            dateTimeOffsetToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(dateTimeOffsetToBytesConverterPropertyColumn);
             var dateTimeOffsetToStringConverterPropertyColumn = new Column("DateTimeOffsetToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToStringConverterProperty", dateTimeOffsetToStringConverterPropertyColumn);
+            dateTimeOffsetToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeOffsetToStringConverterPropertyColumn);
             var dateTimeToBinaryConverterPropertyColumn = new Column("DateTimeToBinaryConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToBinaryConverterProperty", dateTimeToBinaryConverterPropertyColumn);
+            dateTimeToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeToBinaryConverterPropertyColumn);
             var dateTimeToStringConverterPropertyColumn = new Column("DateTimeToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToStringConverterProperty", dateTimeToStringConverterPropertyColumn);
+            dateTimeToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeToStringConverterPropertyColumn);
             var dateTimeToTicksConverterPropertyColumn = new Column("DateTimeToTicksConverterProperty", "datetime2", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToTicksConverterProperty", dateTimeToTicksConverterPropertyColumn);
+            dateTimeToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeToTicksConverterPropertyColumn);
             var decimalColumn = new Column("Decimal", "decimal(18,2)", manyTypesTable);
             manyTypesTable.Columns.Add("Decimal", decimalColumn);
+            decimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(decimalColumn);
             var decimalArrayColumn = new Column("DecimalArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
+            decimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalArrayColumn);
             var decimalNumberToBytesConverterPropertyColumn = new Column("DecimalNumberToBytesConverterProperty", "varbinary(16)", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToBytesConverterProperty", decimalNumberToBytesConverterPropertyColumn);
+            decimalNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(decimalNumberToBytesConverterPropertyColumn);
             var decimalNumberToStringConverterPropertyColumn = new Column("DecimalNumberToStringConverterProperty", "nvarchar(64)", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToStringConverterProperty", decimalNumberToStringConverterPropertyColumn);
+            decimalNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalNumberToStringConverterPropertyColumn);
             var doubleColumn = new Column("Double", "float", manyTypesTable);
             manyTypesTable.Columns.Add("Double", doubleColumn);
+            doubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(doubleColumn);
             var doubleArrayColumn = new Column("DoubleArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
+            doubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleArrayColumn);
             var doubleNumberToBytesConverterPropertyColumn = new Column("DoubleNumberToBytesConverterProperty", "varbinary(8)", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToBytesConverterProperty", doubleNumberToBytesConverterPropertyColumn);
+            doubleNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(doubleNumberToBytesConverterPropertyColumn);
             var doubleNumberToStringConverterPropertyColumn = new Column("DoubleNumberToStringConverterProperty", "nvarchar(64)", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToStringConverterProperty", doubleNumberToStringConverterPropertyColumn);
+            doubleNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleNumberToStringConverterPropertyColumn);
             var enum16Column = new Column("Enum16", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16", enum16Column);
+            enum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(enum16Column);
             var enum16ArrayColumn = new Column("Enum16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Array", enum16ArrayColumn);
+            enum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16ArrayColumn);
             var enum16AsStringColumn = new Column("Enum16AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsString", enum16AsStringColumn);
+            enum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringColumn);
             var enum16AsStringArrayColumn = new Column("Enum16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringArray", enum16AsStringArrayColumn);
+            enum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringArrayColumn);
             var enum16AsStringCollectionColumn = new Column("Enum16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringCollection", enum16AsStringCollectionColumn);
+            enum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringCollectionColumn);
             var enum16CollectionColumn = new Column("Enum16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Collection", enum16CollectionColumn);
+            enum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16CollectionColumn);
             var enum32Column = new Column("Enum32", "int", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32", enum32Column);
+            enum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum32Column);
             var enum32ArrayColumn = new Column("Enum32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Array", enum32ArrayColumn);
+            enum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32ArrayColumn);
             var enum32AsStringColumn = new Column("Enum32AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsString", enum32AsStringColumn);
+            enum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringColumn);
             var enum32AsStringArrayColumn = new Column("Enum32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringArray", enum32AsStringArrayColumn);
+            enum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringArrayColumn);
             var enum32AsStringCollectionColumn = new Column("Enum32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringCollection", enum32AsStringCollectionColumn);
+            enum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringCollectionColumn);
             var enum32CollectionColumn = new Column("Enum32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Collection", enum32CollectionColumn);
+            enum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32CollectionColumn);
             var enum32NestedCollectionColumn = new Column("Enum32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32NestedCollection", enum32NestedCollectionColumn);
+            enum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32NestedCollectionColumn);
             var enum64Column = new Column("Enum64", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64", enum64Column);
+            enum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(enum64Column);
             var enum64ArrayColumn = new Column("Enum64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Array", enum64ArrayColumn);
+            enum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64ArrayColumn);
             var enum64AsStringColumn = new Column("Enum64AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsString", enum64AsStringColumn);
+            enum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringColumn);
             var enum64AsStringArrayColumn = new Column("Enum64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringArray", enum64AsStringArrayColumn);
+            enum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringArrayColumn);
             var enum64AsStringCollectionColumn = new Column("Enum64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringCollection", enum64AsStringCollectionColumn);
+            enum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringCollectionColumn);
             var enum64CollectionColumn = new Column("Enum64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Collection", enum64CollectionColumn);
+            enum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64CollectionColumn);
             var enum8Column = new Column("Enum8", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8", enum8Column);
+            enum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(enum8Column);
             var enum8ArrayColumn = new Column("Enum8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Array", enum8ArrayColumn);
+            enum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8ArrayColumn);
             var enum8AsStringColumn = new Column("Enum8AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsString", enum8AsStringColumn);
+            enum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringColumn);
             var enum8AsStringArrayColumn = new Column("Enum8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringArray", enum8AsStringArrayColumn);
+            enum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringArrayColumn);
             var enum8AsStringCollectionColumn = new Column("Enum8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringCollection", enum8AsStringCollectionColumn);
+            enum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringCollectionColumn);
             var enum8CollectionColumn = new Column("Enum8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Collection", enum8CollectionColumn);
+            enum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8CollectionColumn);
             var enum8NestedCollectionColumn = new Column("Enum8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8NestedCollection", enum8NestedCollectionColumn);
+            enum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8NestedCollectionColumn);
             var enumToNumberConverterPropertyColumn = new Column("EnumToNumberConverterProperty", "int", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToNumberConverterProperty", enumToNumberConverterPropertyColumn);
+            enumToNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumToNumberConverterPropertyColumn);
             var enumToStringConverterPropertyColumn = new Column("EnumToStringConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToStringConverterProperty", enumToStringConverterPropertyColumn);
+            enumToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumToStringConverterPropertyColumn);
             var enumU16Column = new Column("EnumU16", "int", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16", enumU16Column);
+            enumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumU16Column);
             var enumU16ArrayColumn = new Column("EnumU16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Array", enumU16ArrayColumn);
+            enumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16ArrayColumn);
             var enumU16AsStringColumn = new Column("EnumU16AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsString", enumU16AsStringColumn);
+            enumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringColumn);
             var enumU16AsStringArrayColumn = new Column("EnumU16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringArray", enumU16AsStringArrayColumn);
+            enumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringArrayColumn);
             var enumU16AsStringCollectionColumn = new Column("EnumU16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringCollection", enumU16AsStringCollectionColumn);
+            enumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringCollectionColumn);
             var enumU16CollectionColumn = new Column("EnumU16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Collection", enumU16CollectionColumn);
+            enumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16CollectionColumn);
             var enumU32Column = new Column("EnumU32", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32", enumU32Column);
+            enumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(enumU32Column);
             var enumU32ArrayColumn = new Column("EnumU32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Array", enumU32ArrayColumn);
+            enumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32ArrayColumn);
             var enumU32AsStringColumn = new Column("EnumU32AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsString", enumU32AsStringColumn);
+            enumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringColumn);
             var enumU32AsStringArrayColumn = new Column("EnumU32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringArray", enumU32AsStringArrayColumn);
+            enumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringArrayColumn);
             var enumU32AsStringCollectionColumn = new Column("EnumU32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringCollection", enumU32AsStringCollectionColumn);
+            enumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringCollectionColumn);
             var enumU32CollectionColumn = new Column("EnumU32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Collection", enumU32CollectionColumn);
+            enumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32CollectionColumn);
             var enumU64Column = new Column("EnumU64", "decimal(20,0)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64", enumU64Column);
+            enumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(enumU64Column);
             var enumU64ArrayColumn = new Column("EnumU64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Array", enumU64ArrayColumn);
+            enumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64ArrayColumn);
             var enumU64AsStringColumn = new Column("EnumU64AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsString", enumU64AsStringColumn);
+            enumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringColumn);
             var enumU64AsStringArrayColumn = new Column("EnumU64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringArray", enumU64AsStringArrayColumn);
+            enumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringArrayColumn);
             var enumU64AsStringCollectionColumn = new Column("EnumU64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringCollection", enumU64AsStringCollectionColumn);
+            enumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringCollectionColumn);
             var enumU64CollectionColumn = new Column("EnumU64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Collection", enumU64CollectionColumn);
+            enumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64CollectionColumn);
             var enumU64NestedCollectionColumn = new Column("EnumU64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64NestedCollection", enumU64NestedCollectionColumn);
+            enumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64NestedCollectionColumn);
             var enumU8Column = new Column("EnumU8", "tinyint", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8", enumU8Column);
+            enumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(enumU8Column);
             var enumU8ArrayColumn = new Column("EnumU8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Array", enumU8ArrayColumn);
+            enumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8ArrayColumn);
             var enumU8AsStringColumn = new Column("EnumU8AsString", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsString", enumU8AsStringColumn);
+            enumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringColumn);
             var enumU8AsStringArrayColumn = new Column("EnumU8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringArray", enumU8AsStringArrayColumn);
+            enumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringArrayColumn);
             var enumU8AsStringCollectionColumn = new Column("EnumU8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringCollection", enumU8AsStringCollectionColumn);
+            enumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringCollectionColumn);
             var enumU8CollectionColumn = new Column("EnumU8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Collection", enumU8CollectionColumn);
+            enumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8CollectionColumn);
             var floatColumn = new Column("Float", "real", manyTypesTable);
             manyTypesTable.Columns.Add("Float", floatColumn);
+            floatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(floatColumn);
             var floatArrayColumn = new Column("FloatArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
+            floatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(floatArrayColumn);
             var guidColumn = new Column("Guid", "uniqueidentifier", manyTypesTable);
             manyTypesTable.Columns.Add("Guid", guidColumn);
+            guidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(guidColumn);
             var guidArrayColumn = new Column("GuidArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
+            guidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidArrayColumn);
             var guidNestedCollectionColumn = new Column("GuidNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidNestedCollection", guidNestedCollectionColumn);
+            guidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidNestedCollectionColumn);
             var guidToBytesConverterPropertyColumn = new Column("GuidToBytesConverterProperty", "varbinary(16)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToBytesConverterProperty", guidToBytesConverterPropertyColumn);
+            guidToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(guidToBytesConverterPropertyColumn);
             var guidToStringConverterPropertyColumn = new Column("GuidToStringConverterProperty", "nvarchar(36)", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToStringConverterProperty", guidToStringConverterPropertyColumn);
+            guidToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidToStringConverterPropertyColumn);
             var iPAddressColumn = new Column("IPAddress", "nvarchar(45)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
+            iPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressColumn);
             var iPAddressArrayColumn = new Column("IPAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
+            iPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressArrayColumn);
             var iPAddressToBytesConverterPropertyColumn = new Column("IPAddressToBytesConverterProperty", "varbinary(16)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToBytesConverterProperty", iPAddressToBytesConverterPropertyColumn);
+            iPAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(iPAddressToBytesConverterPropertyColumn);
             var iPAddressToStringConverterPropertyColumn = new Column("IPAddressToStringConverterProperty", "nvarchar(45)", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToStringConverterProperty", iPAddressToStringConverterPropertyColumn);
+            iPAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressToStringConverterPropertyColumn);
             var int16Column = new Column("Int16", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Int16", int16Column);
+            int16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(int16Column);
             var int16ArrayColumn = new Column("Int16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
+            int16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int16ArrayColumn);
             var int32Column = new Column("Int32", "int", manyTypesTable);
             manyTypesTable.Columns.Add("Int32", int32Column);
+            int32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(int32Column);
             var int32ArrayColumn = new Column("Int32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
+            int32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32ArrayColumn);
             var int32NestedCollectionColumn = new Column("Int32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int32NestedCollection", int32NestedCollectionColumn);
+            int32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32NestedCollectionColumn);
             var int64Column = new Column("Int64", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("Int64", int64Column);
+            int64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(int64Column);
             var int64ArrayColumn = new Column("Int64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
+            int64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64ArrayColumn);
             var int64NestedCollectionColumn = new Column("Int64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int64NestedCollection", int64NestedCollectionColumn);
+            int64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64NestedCollectionColumn);
             var int8Column = new Column("Int8", "smallint", manyTypesTable);
             manyTypesTable.Columns.Add("Int8", int8Column);
+            int8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(int8Column);
             var int8ArrayColumn = new Column("Int8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
+            int8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8ArrayColumn);
             var int8NestedCollectionColumn = new Column("Int8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Int8NestedCollection", int8NestedCollectionColumn);
+            int8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8NestedCollectionColumn);
             var intNumberToBytesConverterPropertyColumn = new Column("IntNumberToBytesConverterProperty", "varbinary(4)", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToBytesConverterProperty", intNumberToBytesConverterPropertyColumn);
+            intNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(intNumberToBytesConverterPropertyColumn);
             var intNumberToStringConverterPropertyColumn = new Column("IntNumberToStringConverterProperty", "nvarchar(64)", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToStringConverterProperty", intNumberToStringConverterPropertyColumn);
+            intNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(intNumberToStringConverterPropertyColumn);
             var nullIntToNullStringConverterPropertyColumn = new Column("NullIntToNullStringConverterProperty", "nvarchar(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullIntToNullStringConverterProperty", nullIntToNullStringConverterPropertyColumn);
+            nullIntToNullStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullIntToNullStringConverterPropertyColumn);
             var nullableBoolColumn = new Column("NullableBool", "bit", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
+            nullableBoolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(nullableBoolColumn);
             var nullableBoolArrayColumn = new Column("NullableBoolArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
+            nullableBoolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBoolArrayColumn);
             var nullableBytesColumn = new Column("NullableBytes", "varbinary(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
+            nullableBytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(nullableBytesColumn);
             var nullableBytesArrayColumn = new Column("NullableBytesArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
+            nullableBytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesArrayColumn);
             var nullableBytesNestedCollectionColumn = new Column("NullableBytesNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesNestedCollection", nullableBytesNestedCollectionColumn);
+            nullableBytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesNestedCollectionColumn);
             var nullableCharColumn = new Column("NullableChar", "nvarchar(1)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
+            nullableCharColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableCharColumn);
             var nullableCharArrayColumn = new Column("NullableCharArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
+            nullableCharArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableCharArrayColumn);
             var nullableDateOnlyColumn = new Column("NullableDateOnly", "date", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
+            nullableDateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(nullableDateOnlyColumn);
             var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
+            nullableDateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateOnlyArrayColumn);
             var nullableDateTimeColumn = new Column("NullableDateTime", "datetime2", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
+            nullableDateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(nullableDateTimeColumn);
             var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
+            nullableDateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateTimeArrayColumn);
             var nullableDecimalColumn = new Column("NullableDecimal", "decimal(18,2)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
+            nullableDecimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableDecimalColumn);
             var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
+            nullableDecimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDecimalArrayColumn);
             var nullableDoubleColumn = new Column("NullableDouble", "float", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
+            nullableDoubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(nullableDoubleColumn);
             var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
+            nullableDoubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDoubleArrayColumn);
             var nullableEnum16Column = new Column("NullableEnum16", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16", nullableEnum16Column);
+            nullableEnum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16Column);
             var nullableEnum16ArrayColumn = new Column("NullableEnum16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Array", nullableEnum16ArrayColumn);
+            nullableEnum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16ArrayColumn);
             var nullableEnum16AsStringColumn = new Column("NullableEnum16AsString", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16AsString", nullableEnum16AsStringColumn);
+            nullableEnum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16AsStringColumn);
             var nullableEnum16AsStringArrayColumn = new Column("NullableEnum16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringArray", nullableEnum16AsStringArrayColumn);
+            nullableEnum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringArrayColumn);
             var nullableEnum16AsStringCollectionColumn = new Column("NullableEnum16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringCollection", nullableEnum16AsStringCollectionColumn);
+            nullableEnum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringCollectionColumn);
             var nullableEnum16CollectionColumn = new Column("NullableEnum16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Collection", nullableEnum16CollectionColumn);
+            nullableEnum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16CollectionColumn);
             var nullableEnum32Column = new Column("NullableEnum32", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32", nullableEnum32Column);
+            nullableEnum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32Column);
             var nullableEnum32ArrayColumn = new Column("NullableEnum32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Array", nullableEnum32ArrayColumn);
+            nullableEnum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32ArrayColumn);
             var nullableEnum32AsStringColumn = new Column("NullableEnum32AsString", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32AsString", nullableEnum32AsStringColumn);
+            nullableEnum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32AsStringColumn);
             var nullableEnum32AsStringArrayColumn = new Column("NullableEnum32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringArray", nullableEnum32AsStringArrayColumn);
+            nullableEnum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringArrayColumn);
             var nullableEnum32AsStringCollectionColumn = new Column("NullableEnum32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringCollection", nullableEnum32AsStringCollectionColumn);
+            nullableEnum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringCollectionColumn);
             var nullableEnum32CollectionColumn = new Column("NullableEnum32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Collection", nullableEnum32CollectionColumn);
+            nullableEnum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32CollectionColumn);
             var nullableEnum32NestedCollectionColumn = new Column("NullableEnum32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32NestedCollection", nullableEnum32NestedCollectionColumn);
+            nullableEnum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32NestedCollectionColumn);
             var nullableEnum64Column = new Column("NullableEnum64", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64", nullableEnum64Column);
+            nullableEnum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64Column);
             var nullableEnum64ArrayColumn = new Column("NullableEnum64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Array", nullableEnum64ArrayColumn);
+            nullableEnum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64ArrayColumn);
             var nullableEnum64AsStringColumn = new Column("NullableEnum64AsString", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64AsString", nullableEnum64AsStringColumn);
+            nullableEnum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64AsStringColumn);
             var nullableEnum64AsStringArrayColumn = new Column("NullableEnum64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringArray", nullableEnum64AsStringArrayColumn);
+            nullableEnum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringArrayColumn);
             var nullableEnum64AsStringCollectionColumn = new Column("NullableEnum64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringCollection", nullableEnum64AsStringCollectionColumn);
+            nullableEnum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringCollectionColumn);
             var nullableEnum64CollectionColumn = new Column("NullableEnum64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Collection", nullableEnum64CollectionColumn);
+            nullableEnum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64CollectionColumn);
             var nullableEnum8Column = new Column("NullableEnum8", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8", nullableEnum8Column);
+            nullableEnum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum8Column);
             var nullableEnum8ArrayColumn = new Column("NullableEnum8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Array", nullableEnum8ArrayColumn);
+            nullableEnum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8ArrayColumn);
             var nullableEnum8AsStringColumn = new Column("NullableEnum8AsString", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8AsString", nullableEnum8AsStringColumn);
+            nullableEnum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum8AsStringColumn);
             var nullableEnum8AsStringArrayColumn = new Column("NullableEnum8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringArray", nullableEnum8AsStringArrayColumn);
+            nullableEnum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringArrayColumn);
             var nullableEnum8AsStringCollectionColumn = new Column("NullableEnum8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringCollection", nullableEnum8AsStringCollectionColumn);
+            nullableEnum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringCollectionColumn);
             var nullableEnum8CollectionColumn = new Column("NullableEnum8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Collection", nullableEnum8CollectionColumn);
+            nullableEnum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8CollectionColumn);
             var nullableEnum8NestedCollectionColumn = new Column("NullableEnum8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8NestedCollection", nullableEnum8NestedCollectionColumn);
+            nullableEnum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8NestedCollectionColumn);
             var nullableEnumU16Column = new Column("NullableEnumU16", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16", nullableEnumU16Column);
+            nullableEnumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnumU16Column);
             var nullableEnumU16ArrayColumn = new Column("NullableEnumU16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Array", nullableEnumU16ArrayColumn);
+            nullableEnumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16ArrayColumn);
             var nullableEnumU16AsStringColumn = new Column("NullableEnumU16AsString", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16AsString", nullableEnumU16AsStringColumn);
+            nullableEnumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnumU16AsStringColumn);
             var nullableEnumU16AsStringArrayColumn = new Column("NullableEnumU16AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringArray", nullableEnumU16AsStringArrayColumn);
+            nullableEnumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringArrayColumn);
             var nullableEnumU16AsStringCollectionColumn = new Column("NullableEnumU16AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringCollection", nullableEnumU16AsStringCollectionColumn);
+            nullableEnumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringCollectionColumn);
             var nullableEnumU16CollectionColumn = new Column("NullableEnumU16Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Collection", nullableEnumU16CollectionColumn);
+            nullableEnumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16CollectionColumn);
             var nullableEnumU32Column = new Column("NullableEnumU32", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32", nullableEnumU32Column);
+            nullableEnumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnumU32Column);
             var nullableEnumU32ArrayColumn = new Column("NullableEnumU32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Array", nullableEnumU32ArrayColumn);
+            nullableEnumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32ArrayColumn);
             var nullableEnumU32AsStringColumn = new Column("NullableEnumU32AsString", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32AsString", nullableEnumU32AsStringColumn);
+            nullableEnumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnumU32AsStringColumn);
             var nullableEnumU32AsStringArrayColumn = new Column("NullableEnumU32AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringArray", nullableEnumU32AsStringArrayColumn);
+            nullableEnumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringArrayColumn);
             var nullableEnumU32AsStringCollectionColumn = new Column("NullableEnumU32AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringCollection", nullableEnumU32AsStringCollectionColumn);
+            nullableEnumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringCollectionColumn);
             var nullableEnumU32CollectionColumn = new Column("NullableEnumU32Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Collection", nullableEnumU32CollectionColumn);
+            nullableEnumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32CollectionColumn);
             var nullableEnumU64Column = new Column("NullableEnumU64", "decimal(20,0)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64", nullableEnumU64Column);
+            nullableEnumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableEnumU64Column);
             var nullableEnumU64ArrayColumn = new Column("NullableEnumU64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Array", nullableEnumU64ArrayColumn);
+            nullableEnumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64ArrayColumn);
             var nullableEnumU64AsStringColumn = new Column("NullableEnumU64AsString", "decimal(20,0)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64AsString", nullableEnumU64AsStringColumn);
+            nullableEnumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableEnumU64AsStringColumn);
             var nullableEnumU64AsStringArrayColumn = new Column("NullableEnumU64AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringArray", nullableEnumU64AsStringArrayColumn);
+            nullableEnumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringArrayColumn);
             var nullableEnumU64AsStringCollectionColumn = new Column("NullableEnumU64AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringCollection", nullableEnumU64AsStringCollectionColumn);
+            nullableEnumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringCollectionColumn);
             var nullableEnumU64CollectionColumn = new Column("NullableEnumU64Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Collection", nullableEnumU64CollectionColumn);
+            nullableEnumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64CollectionColumn);
             var nullableEnumU64NestedCollectionColumn = new Column("NullableEnumU64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64NestedCollection", nullableEnumU64NestedCollectionColumn);
+            nullableEnumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64NestedCollectionColumn);
             var nullableEnumU8Column = new Column("NullableEnumU8", "tinyint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8", nullableEnumU8Column);
+            nullableEnumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8Column);
             var nullableEnumU8ArrayColumn = new Column("NullableEnumU8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Array", nullableEnumU8ArrayColumn);
+            nullableEnumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8ArrayColumn);
             var nullableEnumU8AsStringColumn = new Column("NullableEnumU8AsString", "tinyint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8AsString", nullableEnumU8AsStringColumn);
+            nullableEnumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8AsStringColumn);
             var nullableEnumU8AsStringArrayColumn = new Column("NullableEnumU8AsStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringArray", nullableEnumU8AsStringArrayColumn);
+            nullableEnumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringArrayColumn);
             var nullableEnumU8AsStringCollectionColumn = new Column("NullableEnumU8AsStringCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringCollection", nullableEnumU8AsStringCollectionColumn);
+            nullableEnumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringCollectionColumn);
             var nullableEnumU8CollectionColumn = new Column("NullableEnumU8Collection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Collection", nullableEnumU8CollectionColumn);
+            nullableEnumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8CollectionColumn);
             var nullableFloatColumn = new Column("NullableFloat", "real", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
+            nullableFloatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(nullableFloatColumn);
             var nullableFloatArrayColumn = new Column("NullableFloatArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
+            nullableFloatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableFloatArrayColumn);
             var nullableGuidColumn = new Column("NullableGuid", "uniqueidentifier", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
+            nullableGuidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(nullableGuidColumn);
             var nullableGuidArrayColumn = new Column("NullableGuidArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
+            nullableGuidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidArrayColumn);
             var nullableGuidNestedCollectionColumn = new Column("NullableGuidNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidNestedCollection", nullableGuidNestedCollectionColumn);
+            nullableGuidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidNestedCollectionColumn);
             var nullableIPAddressColumn = new Column("NullableIPAddress", "nvarchar(45)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
+            nullableIPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressColumn);
             var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
+            nullableIPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressArrayColumn);
             var nullableInt16Column = new Column("NullableInt16", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
+            nullableInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableInt16Column);
             var nullableInt16ArrayColumn = new Column("NullableInt16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
+            nullableInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt16ArrayColumn);
             var nullableInt32Column = new Column("NullableInt32", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
+            nullableInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableInt32Column);
             var nullableInt32ArrayColumn = new Column("NullableInt32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
+            nullableInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32ArrayColumn);
             var nullableInt32NestedCollectionColumn = new Column("NullableInt32NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32NestedCollection", nullableInt32NestedCollectionColumn);
+            nullableInt32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32NestedCollectionColumn);
             var nullableInt64Column = new Column("NullableInt64", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
+            nullableInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableInt64Column);
             var nullableInt64ArrayColumn = new Column("NullableInt64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
+            nullableInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64ArrayColumn);
             var nullableInt64NestedCollectionColumn = new Column("NullableInt64NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64NestedCollection", nullableInt64NestedCollectionColumn);
+            nullableInt64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64NestedCollectionColumn);
             var nullableInt8Column = new Column("NullableInt8", "smallint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
+            nullableInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableInt8Column);
             var nullableInt8ArrayColumn = new Column("NullableInt8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
+            nullableInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt8ArrayColumn);
             var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "nvarchar(20)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
+            nullablePhysicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressColumn);
             var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
+            nullablePhysicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressArrayColumn);
             var nullablePhysicalAddressNestedCollectionColumn = new Column("NullablePhysicalAddressNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressNestedCollection", nullablePhysicalAddressNestedCollectionColumn);
+            nullablePhysicalAddressNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressNestedCollectionColumn);
             var nullableStringColumn = new Column("NullableString", "nvarchar(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
+            nullableStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringColumn);
             var nullableStringArrayColumn = new Column("NullableStringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
+            nullableStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringArrayColumn);
             var nullableStringNestedCollectionColumn = new Column("NullableStringNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringNestedCollection", nullableStringNestedCollectionColumn);
+            nullableStringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringNestedCollectionColumn);
             var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "time", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
+            nullableTimeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(nullableTimeOnlyColumn);
             var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
+            nullableTimeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeOnlyArrayColumn);
             var nullableTimeSpanColumn = new Column("NullableTimeSpan", "time", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
+            nullableTimeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(nullableTimeSpanColumn);
             var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
+            nullableTimeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeSpanArrayColumn);
             var nullableUInt16Column = new Column("NullableUInt16", "int", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
+            nullableUInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableUInt16Column);
             var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
+            nullableUInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt16ArrayColumn);
             var nullableUInt32Column = new Column("NullableUInt32", "bigint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
+            nullableUInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableUInt32Column);
             var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
+            nullableUInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt32ArrayColumn);
             var nullableUInt64Column = new Column("NullableUInt64", "decimal(20,0)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
+            nullableUInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableUInt64Column);
             var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
+            nullableUInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt64ArrayColumn);
             var nullableUInt8Column = new Column("NullableUInt8", "tinyint", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
+            nullableUInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableUInt8Column);
             var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
+            nullableUInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8ArrayColumn);
             var nullableUInt8NestedCollectionColumn = new Column("NullableUInt8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8NestedCollection", nullableUInt8NestedCollectionColumn);
+            nullableUInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8NestedCollectionColumn);
             var nullableUriColumn = new Column("NullableUri", "nvarchar(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
+            nullableUriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriColumn);
             var nullableUriArrayColumn = new Column("NullableUriArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
+            nullableUriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriArrayColumn);
             var physicalAddressColumn = new Column("PhysicalAddress", "nvarchar(20)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
+            physicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressColumn);
             var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
+            physicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressArrayColumn);
             var physicalAddressToBytesConverterPropertyColumn = new Column("PhysicalAddressToBytesConverterProperty", "varbinary(8)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToBytesConverterProperty", physicalAddressToBytesConverterPropertyColumn);
+            physicalAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(physicalAddressToBytesConverterPropertyColumn);
             var physicalAddressToStringConverterPropertyColumn = new Column("PhysicalAddressToStringConverterProperty", "nvarchar(20)", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToStringConverterProperty", physicalAddressToStringConverterPropertyColumn);
+            physicalAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressToStringConverterPropertyColumn);
             var stringColumn = new Column("String", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("String", stringColumn);
+            stringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringColumn);
             var stringArrayColumn = new Column("StringArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
+            stringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringArrayColumn);
             var stringNestedCollectionColumn = new Column("StringNestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringNestedCollection", stringNestedCollectionColumn);
+            stringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringNestedCollectionColumn);
             var stringToBoolConverterPropertyColumn = new Column("StringToBoolConverterProperty", "bit", manyTypesTable);
             manyTypesTable.Columns.Add("StringToBoolConverterProperty", stringToBoolConverterPropertyColumn);
+            stringToBoolConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(stringToBoolConverterPropertyColumn);
             var stringToBytesConverterPropertyColumn = new Column("StringToBytesConverterProperty", "varbinary(max)", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("StringToBytesConverterProperty", stringToBytesConverterPropertyColumn);
+            stringToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(stringToBytesConverterPropertyColumn);
             var stringToCharConverterPropertyColumn = new Column("StringToCharConverterProperty", "nvarchar(1)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToCharConverterProperty", stringToCharConverterPropertyColumn);
+            stringToCharConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToCharConverterPropertyColumn);
             var stringToDateOnlyConverterPropertyColumn = new Column("StringToDateOnlyConverterProperty", "date", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateOnlyConverterProperty", stringToDateOnlyConverterPropertyColumn);
+            stringToDateOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(stringToDateOnlyConverterPropertyColumn);
             var stringToDateTimeConverterPropertyColumn = new Column("StringToDateTimeConverterProperty", "datetime2", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeConverterProperty", stringToDateTimeConverterPropertyColumn);
+            stringToDateTimeConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(stringToDateTimeConverterPropertyColumn);
             var stringToDateTimeOffsetConverterPropertyColumn = new Column("StringToDateTimeOffsetConverterProperty", "datetimeoffset", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeOffsetConverterProperty", stringToDateTimeOffsetConverterPropertyColumn);
+            stringToDateTimeOffsetConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTimeOffset>(stringToDateTimeOffsetConverterPropertyColumn);
             var stringToDecimalNumberConverterPropertyColumn = new Column("StringToDecimalNumberConverterProperty", "decimal(18,2)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDecimalNumberConverterProperty", stringToDecimalNumberConverterPropertyColumn);
+            stringToDecimalNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(stringToDecimalNumberConverterPropertyColumn);
             var stringToDoubleNumberConverterPropertyColumn = new Column("StringToDoubleNumberConverterProperty", "float", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDoubleNumberConverterProperty", stringToDoubleNumberConverterPropertyColumn);
+            stringToDoubleNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(stringToDoubleNumberConverterPropertyColumn);
             var stringToEnumConverterPropertyColumn = new Column("StringToEnumConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("StringToEnumConverterProperty", stringToEnumConverterPropertyColumn);
+            stringToEnumConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(stringToEnumConverterPropertyColumn);
             var stringToGuidConverterPropertyColumn = new Column("StringToGuidConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToGuidConverterProperty", stringToGuidConverterPropertyColumn);
+            stringToGuidConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToGuidConverterPropertyColumn);
             var stringToIntNumberConverterPropertyColumn = new Column("StringToIntNumberConverterProperty", "int", manyTypesTable);
             manyTypesTable.Columns.Add("StringToIntNumberConverterProperty", stringToIntNumberConverterPropertyColumn);
+            stringToIntNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(stringToIntNumberConverterPropertyColumn);
             var stringToTimeOnlyConverterPropertyColumn = new Column("StringToTimeOnlyConverterProperty", "time", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeOnlyConverterProperty", stringToTimeOnlyConverterPropertyColumn);
+            stringToTimeOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(stringToTimeOnlyConverterPropertyColumn);
             var stringToTimeSpanConverterPropertyColumn = new Column("StringToTimeSpanConverterProperty", "time", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeSpanConverterProperty", stringToTimeSpanConverterPropertyColumn);
+            stringToTimeSpanConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(stringToTimeSpanConverterPropertyColumn);
             var stringToUriConverterPropertyColumn = new Column("StringToUriConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("StringToUriConverterProperty", stringToUriConverterPropertyColumn);
+            stringToUriConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToUriConverterPropertyColumn);
             var timeOnlyColumn = new Column("TimeOnly", "time", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
+            timeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(timeOnlyColumn);
             var timeOnlyArrayColumn = new Column("TimeOnlyArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
+            timeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyArrayColumn);
             var timeOnlyToStringConverterPropertyColumn = new Column("TimeOnlyToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToStringConverterProperty", timeOnlyToStringConverterPropertyColumn);
+            timeOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyToStringConverterPropertyColumn);
             var timeOnlyToTicksConverterPropertyColumn = new Column("TimeOnlyToTicksConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToTicksConverterProperty", timeOnlyToTicksConverterPropertyColumn);
+            timeOnlyToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeOnlyToTicksConverterPropertyColumn);
             var timeSpanColumn = new Column("TimeSpan", "time", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
+            timeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(timeSpanColumn);
             var timeSpanArrayColumn = new Column("TimeSpanArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
+            timeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanArrayColumn);
             var timeSpanToStringConverterPropertyColumn = new Column("TimeSpanToStringConverterProperty", "nvarchar(48)", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToStringConverterProperty", timeSpanToStringConverterPropertyColumn);
+            timeSpanToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanToStringConverterPropertyColumn);
             var timeSpanToTicksConverterPropertyColumn = new Column("TimeSpanToTicksConverterProperty", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToTicksConverterProperty", timeSpanToTicksConverterPropertyColumn);
+            timeSpanToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeSpanToTicksConverterPropertyColumn);
             var uInt16Column = new Column("UInt16", "int", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16", uInt16Column);
+            uInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(uInt16Column);
             var uInt16ArrayColumn = new Column("UInt16Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
+            uInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt16ArrayColumn);
             var uInt32Column = new Column("UInt32", "bigint", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32", uInt32Column);
+            uInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(uInt32Column);
             var uInt32ArrayColumn = new Column("UInt32Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
+            uInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt32ArrayColumn);
             var uInt64Column = new Column("UInt64", "decimal(20,0)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64", uInt64Column);
+            uInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(uInt64Column);
             var uInt64ArrayColumn = new Column("UInt64Array", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
+            uInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt64ArrayColumn);
             var uInt8Column = new Column("UInt8", "tinyint", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8", uInt8Column);
+            uInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(uInt8Column);
             var uInt8ArrayColumn = new Column("UInt8Array", "varbinary(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
+            uInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(uInt8ArrayColumn);
             var uInt8NestedCollectionColumn = new Column("UInt8NestedCollection", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8NestedCollection", uInt8NestedCollectionColumn);
+            uInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt8NestedCollectionColumn);
             var uriColumn = new Column("Uri", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("Uri", uriColumn);
+            uriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriColumn);
             var uriArrayColumn = new Column("UriArray", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
+            uriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriArrayColumn);
             var uriToStringConverterPropertyColumn = new Column("UriToStringConverterProperty", "nvarchar(max)", manyTypesTable);
             manyTypesTable.Columns.Add("UriToStringConverterProperty", uriToStringConverterPropertyColumn);
-            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn0 });
-            manyTypesTable.PrimaryKey = pK_ManyTypes;
-            var pK_ManyTypesKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
-                new[] { "Id" });
-            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
-            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
+            uriToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriToStringConverterPropertyColumn);
             relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
             var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, null);
             manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
@@ -1993,6 +2253,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriToStringConverterPropertyColumn, manyTypes.FindProperty("UriToStringConverterProperty")!, manyTypesTableMapping);
+            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn0 });
+            manyTypesTable.PrimaryKey = pK_ManyTypes;
+            pK_ManyTypes.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_ManyTypes));
+            var pK_ManyTypesKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
+                new[] { "Id" });
+            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
+            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
 
             var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase")!;
 
@@ -2081,91 +2350,85 @@ private IRelationalModel CreateRelationalModel()
             var principalBaseTable = new Table("PrincipalBase", null, relationalModel);
             var idColumn1 = new Column("Id", "bigint", principalBaseTable);
             principalBaseTable.Columns.Add("Id", idColumn1);
+            idColumn1.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(idColumn1);
             var alternateIdColumn = new Column("AlternateId", "uniqueidentifier", principalBaseTable);
             principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
+            alternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(alternateIdColumn);
             var discriminatorColumn = new Column("Discriminator", "nvarchar(55)", principalBaseTable);
             principalBaseTable.Columns.Add("Discriminator", discriminatorColumn);
+            discriminatorColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(discriminatorColumn);
             var enum1Column = new Column("Enum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Enum1", enum1Column);
+            enum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum1Column);
             var enum2Column = new Column("Enum2", "int", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Enum2", enum2Column);
+            enum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum2Column);
             var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
+            flagsEnum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum1Column);
             var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
+            flagsEnum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum2Column);
             var manyOwnedColumn = new JsonColumn("ManyOwned", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ManyOwned", manyOwnedColumn);
+            manyOwnedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(manyOwnedColumn);
             var ownedColumn = new JsonColumn("Owned", "nvarchar(max)", principalBaseTable);
             principalBaseTable.Columns.Add("Owned", ownedColumn);
+            ownedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(ownedColumn);
             var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
+            refTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn);
             var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
+            refTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn);
             var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
+            refTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn);
             var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
+            refTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn);
             var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
+            valueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn);
             var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
+            valueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn);
             var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
+            valueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn);
             var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
-            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn1 });
-            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id" });
-            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
-            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
-            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
-            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn1, alternateIdColumn });
-            principalBaseTable.PrimaryKey = pK;
-            var pKKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id", "AlternateId" });
-            pK.MappedKeys.Add(pKKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
-            principalBaseTable.UniqueConstraints.Add("PK", pK);
-            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
-            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn1 }, false);
-            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "AlternateId", "Id" });
-            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
-            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
+            valueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn);
             relationalModel.Tables.Add(("PrincipalBase", null), principalBaseTable);
             var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
             {
@@ -2290,6 +2553,32 @@ private IRelationalModel CreateRelationalModel()
                 new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>",
                 new[] { "Id", "AlternateId" }));
+            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn1 });
+            aK_PrincipalBase_Id.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(aK_PrincipalBase_Id));
+            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id" });
+            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
+            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
+            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
+            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn1, alternateIdColumn });
+            principalBaseTable.PrimaryKey = pK;
+            pK.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK));
+            var pKKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id", "AlternateId" });
+            pK.MappedKeys.Add(pKKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
+            principalBaseTable.UniqueConstraints.Add("PK", pK);
+            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
+            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn1 }, false);
+            iX_PrincipalBase_AlternateId_Id.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBase_AlternateId_Id));
+            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "AlternateId", "Id" });
+            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
+            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
 
             var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;
 
@@ -2324,19 +2613,34 @@ private IRelationalModel CreateRelationalModel()
             var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
             var derivedsIdColumn = new Column("DerivedsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
+            derivedsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(derivedsIdColumn);
             var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
+            derivedsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(derivedsAlternateIdColumn);
             var principalsIdColumn = new Column("PrincipalsId", "bigint", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
+            principalsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalsIdColumn);
             var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "uniqueidentifier", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
+            principalsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalsAlternateIdColumn);
             var rowidColumn = new Column("rowid", "rowversion", principalBasePrincipalDerivedDependentBasebyteTable)
             {
                 IsNullable = true
             };
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
+            rowidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(rowidColumn);
+            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
+            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
+            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
+            tableMappings6.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
             principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
+            pK_PrincipalBasePrincipalDerivedDependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_PrincipalBasePrincipalDerivedDependentBasebyte));
             var pK_PrincipalBasePrincipalDerivedDependentBasebyteKey = RelationalModel.GetKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
@@ -2345,25 +2649,18 @@ private IRelationalModel CreateRelationalModel()
             principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
             "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
+            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId));
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" });
             iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
             RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
             principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
-            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
-            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
-            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
-            tableMappings6.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                 "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                 new[] { principalIdColumn },
                 principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
+            fK_DependentBasebyte_PrincipalBase_PrincipalId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_DependentBasebyte_PrincipalBase_PrincipalId));
             var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId" },
@@ -2377,6 +2674,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_DependentBase<byte?>_PrincipalBase_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalBaseTable,
                 new[] { principalIdColumn, principalAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
+            fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId));
             var fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId", "PrincipalAlternateId" },
@@ -2390,6 +2688,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                 new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId" },
@@ -2403,6 +2702,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                 new[] { principalsIdColumn, principalsAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" },
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs
index 49765b5253..f057e7ef99 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs
@@ -44,6 +44,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -71,6 +77,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -100,6 +112,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum1),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            enumDiscriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum1>(enumDiscriminator, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum1>(enumDiscriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             enumDiscriminator.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -215,17 +233,17 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             principal.SetGetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
             principal.SetSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetMaterializationSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetAccessors(
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>>(principal),
                 null);
@@ -235,6 +253,7 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            principal.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal", "TestNamespace") });
             var dependent = principalEntityType.AddNavigation("Dependent",
                 runtimeForeignKey,
                 onDependent: false,
@@ -275,7 +294,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var enumDiscriminator = runtimeEntityType.FindProperty("EnumDiscriminator")!;
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { principalId, principalAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             var principal = runtimeEntityType.FindNavigation("Principal")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs
index 55ebcd5628..a9a85f6f7c 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs
@@ -87,6 +87,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 precision: 9,
                 scale: 3,
                 sentinel: 0m);
+            money.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(money, 5),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(money),
+                (ValueBuffer valueBuffer) => valueBuffer[5]);
             money.SetPropertyIndexes(
                 index: 5,
                 originalValueIndex: 5,
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
index 54c7e07cbb..2d40767a42 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
@@ -17695,7 +17695,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var uriArray = runtimeEntityType.FindProperty("UriArray")!;
             var uriToStringConverterProperty = runtimeEntityType.FindProperty("UriToStringConverterProperty")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<CompiledModelTestBase.ManyTypesId>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<CompiledModelTestBase.ManyTypesId>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<CompiledModelTestBase.ManyTypesId>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
index 04df8e29e8..2da0de34cf 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
@@ -41,6 +41,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalDerivedId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalDerivedId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalDerivedId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalDerivedId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -68,6 +74,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalDerivedAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalDerivedAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalDerivedAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalDerivedAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -98,6 +110,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(2) ? entry.ReadStoreGeneratedValue<int>(2) : entry.FlaggedAsTemporary(2) && entry.ReadShadowValue<int>(2) == 0 ? entry.ReadTemporaryValue<int>(2) : entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 2),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 2),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             id.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -863,7 +881,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalDerivedId, principalDerivedAlternateId, id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
index 0e50748cb3..52355cff60 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
@@ -43,6 +43,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalBaseId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalBaseId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalBaseId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalBaseId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -71,6 +77,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalBaseAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalBaseAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalBaseAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalBaseAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -846,7 +858,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalBaseId, principalBaseAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
index 7a662f00ba..dd1666e028 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
@@ -139,6 +139,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 maxLength: 55,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             discriminator.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -1029,10 +1035,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var key0 = runtimeEntityType.FindKey(new[] { id, alternateId });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key0));
             var owned = runtimeEntityType.FindNavigation("Owned")!;
             runtimeEntityType.SetOriginalValuesFactory(
@@ -1118,10 +1124,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeList>k__BackingField")]
         public static extern ref List<short> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_ValueTypeList(CompiledModelTestBase.PrincipalBase @this);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_ownedField")]
         public static extern ref CompiledModelTestBase.OwnedType UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase__ownedField(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
     }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
index f6b4ef2d63..df9543d726 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
@@ -392,7 +392,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var principalsAlternateId = runtimeEntityType.FindProperty("PrincipalsAlternateId")!;
             var rowid = runtimeEntityType.FindProperty("rowid")!;
             var key = runtimeEntityType.FindKey(new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs
index a366d574f1..13e46dbe5b 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs
@@ -147,13 +147,13 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
 
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Dependent>k__BackingField")]
         public static extern ref CompiledModelTestBase.DependentBase<byte?> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Dependent(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "ManyOwned")]
         public static extern ref ICollection<CompiledModelTestBase.OwnedType> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_ManyOwned(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
     }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs
index c81d59bd9e..867dfdd0fa 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs
@@ -37,6 +37,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -117,7 +123,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs
index 9aca8579fa..a3416159e7 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -57,25 +58,28 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "int", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/DbContextModelBuilder.cs
index 5de6d2e252..1019047df8 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/DbContextModelBuilder.cs
@@ -9,6 +9,7 @@
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
 using Microsoft.EntityFrameworkCore.Scaffolding;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -247,185 +248,208 @@ private IRelationalModel CreateRelationalModel()
             var principalBaseTable = new Table("PrincipalBase", null, relationalModel);
             var idColumn = new Column("Id", "bigint", principalBaseTable);
             principalBaseTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(idColumn);
             var deetsColumn = new Column("Deets", "varchar(64)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Deets", deetsColumn);
+            deetsColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(deetsColumn);
             var discriminatorColumn = new Column("Discriminator", "nvarchar(55)", principalBaseTable);
             principalBaseTable.Columns.Add("Discriminator", discriminatorColumn);
+            discriminatorColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(discriminatorColumn);
             var enum1Column = new Column("Enum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Enum1", enum1Column);
+            enum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum1Column);
             var enum2Column = new Column("Enum2", "int", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Enum2", enum2Column);
+            enum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum2Column);
             var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
+            flagsEnum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum1Column);
             var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
+            flagsEnum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum2Column);
             var owned_NumberColumn = new Column("Owned_Number", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Owned_Number", owned_NumberColumn);
+            owned_NumberColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(owned_NumberColumn);
             var owned_Principal_AlternateIdColumn = new Column("Owned_Principal_AlternateId", "uniqueidentifier", principalBaseTable);
             principalBaseTable.Columns.Add("Owned_Principal_AlternateId", owned_Principal_AlternateIdColumn);
+            owned_Principal_AlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(owned_Principal_AlternateIdColumn);
             var owned_Principal_Enum1Column = new Column("Owned_Principal_Enum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Owned_Principal_Enum1", owned_Principal_Enum1Column);
+            owned_Principal_Enum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(owned_Principal_Enum1Column);
             var owned_Principal_Enum2Column = new Column("Owned_Principal_Enum2", "int", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_Enum2", owned_Principal_Enum2Column);
+            owned_Principal_Enum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(owned_Principal_Enum2Column);
             var owned_Principal_FlagsEnum1Column = new Column("Owned_Principal_FlagsEnum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Owned_Principal_FlagsEnum1", owned_Principal_FlagsEnum1Column);
+            owned_Principal_FlagsEnum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(owned_Principal_FlagsEnum1Column);
             var owned_Principal_FlagsEnum2Column = new Column("Owned_Principal_FlagsEnum2", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Owned_Principal_FlagsEnum2", owned_Principal_FlagsEnum2Column);
+            owned_Principal_FlagsEnum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(owned_Principal_FlagsEnum2Column);
             var owned_Principal_IdColumn = new Column("Owned_Principal_Id", "bigint", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_Id", owned_Principal_IdColumn);
+            owned_Principal_IdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(owned_Principal_IdColumn);
             var owned_Principal_RefTypeArrayColumn = new Column("Owned_Principal_RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_RefTypeArray", owned_Principal_RefTypeArrayColumn);
+            owned_Principal_RefTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_RefTypeArrayColumn);
             var owned_Principal_RefTypeEnumerableColumn = new Column("Owned_Principal_RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_RefTypeEnumerable", owned_Principal_RefTypeEnumerableColumn);
+            owned_Principal_RefTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_RefTypeEnumerableColumn);
             var owned_Principal_RefTypeIListColumn = new Column("Owned_Principal_RefTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_RefTypeIList", owned_Principal_RefTypeIListColumn);
+            owned_Principal_RefTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_RefTypeIListColumn);
             var owned_Principal_RefTypeListColumn = new Column("Owned_Principal_RefTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_RefTypeList", owned_Principal_RefTypeListColumn);
+            owned_Principal_RefTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_RefTypeListColumn);
             var owned_Principal_ValueTypeArrayColumn = new Column("Owned_Principal_ValueTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_ValueTypeArray", owned_Principal_ValueTypeArrayColumn);
+            owned_Principal_ValueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_ValueTypeArrayColumn);
             var owned_Principal_ValueTypeEnumerableColumn = new Column("Owned_Principal_ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_ValueTypeEnumerable", owned_Principal_ValueTypeEnumerableColumn);
+            owned_Principal_ValueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_ValueTypeEnumerableColumn);
             var owned_Principal_ValueTypeIListColumn = new Column("Owned_Principal_ValueTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_ValueTypeIList", owned_Principal_ValueTypeIListColumn);
+            owned_Principal_ValueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_ValueTypeIListColumn);
             var owned_Principal_ValueTypeListColumn = new Column("Owned_Principal_ValueTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_Principal_ValueTypeList", owned_Principal_ValueTypeListColumn);
+            owned_Principal_ValueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_Principal_ValueTypeListColumn);
             var owned_RefTypeArrayColumn = new Column("Owned_RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeArray", owned_RefTypeArrayColumn);
+            owned_RefTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeArrayColumn);
             var owned_RefTypeEnumerableColumn = new Column("Owned_RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeEnumerable", owned_RefTypeEnumerableColumn);
+            owned_RefTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeEnumerableColumn);
             var owned_RefTypeIListColumn = new Column("Owned_RefTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeIList", owned_RefTypeIListColumn);
+            owned_RefTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeIListColumn);
             var owned_RefTypeListColumn = new Column("Owned_RefTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeList", owned_RefTypeListColumn);
+            owned_RefTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeListColumn);
             var owned_ValueTypeArrayColumn = new Column("Owned_ValueTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeArray", owned_ValueTypeArrayColumn);
+            owned_ValueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeArrayColumn);
             var owned_ValueTypeEnumerableColumn = new Column("Owned_ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeEnumerable", owned_ValueTypeEnumerableColumn);
+            owned_ValueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeEnumerableColumn);
             var owned_ValueTypeIListColumn = new Column("Owned_ValueTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeIList", owned_ValueTypeIListColumn);
+            owned_ValueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeIListColumn);
             var owned_ValueTypeListColumn = new Column("Owned_ValueTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeList", owned_ValueTypeListColumn);
+            owned_ValueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeListColumn);
             var principalBaseIdColumn = new Column("PrincipalBaseId", "bigint", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
+            principalBaseIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalBaseIdColumn);
             var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
+            refTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn);
             var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
+            refTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn);
             var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
+            refTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn);
             var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
+            refTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn);
             var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
+            valueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn);
             var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
+            valueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn);
             var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
+            valueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn);
             var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
-            var pK_PrincipalBase = new UniqueConstraint("PK_PrincipalBase", principalBaseTable, new[] { idColumn });
-            principalBaseTable.PrimaryKey = pK_PrincipalBase;
-            var pK_PrincipalBaseKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id" });
-            pK_PrincipalBase.MappedKeys.Add(pK_PrincipalBaseKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBaseKey).Add(pK_PrincipalBase);
-            principalBaseTable.UniqueConstraints.Add("PK_PrincipalBase", pK_PrincipalBase);
-            var iX_PrincipalBase_PrincipalBaseId = new TableIndex(
-            "IX_PrincipalBase_PrincipalBaseId", principalBaseTable, new[] { principalBaseIdColumn }, false);
-            var iX_PrincipalBase_PrincipalBaseIdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "PrincipalBaseId" });
-            iX_PrincipalBase_PrincipalBaseId.MappedIndexes.Add(iX_PrincipalBase_PrincipalBaseIdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_PrincipalBaseIdIx).Add(iX_PrincipalBase_PrincipalBaseId);
-            principalBaseTable.Indexes.Add("IX_PrincipalBase_PrincipalBaseId", iX_PrincipalBase_PrincipalBaseId);
+            valueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn);
             relationalModel.Tables.Add(("PrincipalBase", null), principalBaseTable);
             var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
             {
@@ -1010,6 +1034,24 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping2);
             RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping2);
             RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping2);
+            var pK_PrincipalBase = new UniqueConstraint("PK_PrincipalBase", principalBaseTable, new[] { idColumn });
+            principalBaseTable.PrimaryKey = pK_PrincipalBase;
+            pK_PrincipalBase.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(pK_PrincipalBase));
+            var pK_PrincipalBaseKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id" });
+            pK_PrincipalBase.MappedKeys.Add(pK_PrincipalBaseKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBaseKey).Add(pK_PrincipalBase);
+            principalBaseTable.UniqueConstraints.Add("PK_PrincipalBase", pK_PrincipalBase);
+            var iX_PrincipalBase_PrincipalBaseId = new TableIndex(
+            "IX_PrincipalBase_PrincipalBaseId", principalBaseTable, new[] { principalBaseIdColumn }, false);
+            iX_PrincipalBase_PrincipalBaseId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_PrincipalBase_PrincipalBaseId));
+            var iX_PrincipalBase_PrincipalBaseIdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "PrincipalBaseId" });
+            iX_PrincipalBase_PrincipalBaseId.MappedIndexes.Add(iX_PrincipalBase_PrincipalBaseIdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_PrincipalBaseIdIx).Add(iX_PrincipalBase_PrincipalBaseId);
+            principalBaseTable.Indexes.Add("IX_PrincipalBase_PrincipalBaseId", iX_PrincipalBase_PrincipalBaseId);
 
             var sqlQueryMappings0 = new List<SqlQueryMapping>();
             principalDerived.SetRuntimeAnnotation("Relational:SqlQueryMappings", sqlQueryMappings0);
@@ -1087,6 +1129,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBase_PrincipalBase_PrincipalBaseId", principalBaseTable, principalBaseTable,
                 new[] { principalBaseIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK_PrincipalBase")!, ReferentialAction.NoAction);
+            fK_PrincipalBase_PrincipalBase_PrincipalBaseId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_PrincipalBase_PrincipalBase_PrincipalBaseId));
             var fK_PrincipalBase_PrincipalBase_PrincipalBaseIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
                 new[] { "PrincipalBaseId" },
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
index 3b341b4ff6..decb61c9ad 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/ComplexTypes/PrincipalBaseEntityType.cs
@@ -94,6 +94,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 maxLength: 55,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 1),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             discriminator.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -330,6 +336,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "PrincipalBaseId",
                 typeof(long?),
                 nullable: true);
+            principalBaseId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(6) ? entry.ReadStoreGeneratedValue<Nullable<long>>(1) : entry.FlaggedAsTemporary(6) && !entry.ReadShadowValue<Nullable<long>>(1).HasValue ? entry.ReadTemporaryValue<Nullable<long>>(1) : entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Nullable<long>>(principalBaseId, 6),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Nullable<long>>(principalBaseId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[6]);
             principalBaseId.SetPropertyIndexes(
                 index: 6,
                 originalValueIndex: 6,
@@ -2892,17 +2904,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             deriveds.SetGetter(
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) == null,
-                (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance),
-                (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance) == null);
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) == null,
+                (CompiledModelTestBase.PrincipalBase instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance),
+                (CompiledModelTestBase.PrincipalBase instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance) == null);
             deriveds.SetSetter(
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
             deriveds.SetMaterializationSetter(
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
             deriveds.SetAccessors(
-                (InternalEntityEntry entry) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
-                (InternalEntityEntry entry) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<CompiledModelTestBase.PrincipalBase>>(deriveds),
                 null);
@@ -2913,11 +2925,12 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
             deriveds.SetCollectionAccessor<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
                 (CompiledModelTestBase.PrincipalBase entity, Action<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(entity, setter),
                 () => (ICollection<CompiledModelTestBase.PrincipalBase>)(ICollection<CompiledModelTestBase.PrincipalBase>)new HashSet<CompiledModelTestBase.PrincipalBase>(ReferenceEqualityComparer.Instance));
+            deriveds.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds", "TestNamespace") });
             return runtimeForeignKey;
         }
 
@@ -2967,7 +2980,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList1 = principalBase.FindProperty("ValueTypeIList")!;
             var valueTypeList1 = principalBase.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var deriveds = runtimeEntityType.FindNavigation("Deriveds")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs
index c81d59bd9e..867dfdd0fa 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs
@@ -37,6 +37,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -117,7 +123,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs
index 9aca8579fa..a3416159e7 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -57,25 +58,28 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "int", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DataEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DataEntityType.cs
index 17d29be689..ac6a93a00e 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DataEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DataEntityType.cs
@@ -37,6 +37,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -119,7 +125,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DbContextModelBuilder.cs
index 8db299ef42..ebc7ed2b93 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_HiLo_sequence/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -68,25 +69,28 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "int", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DataEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DataEntityType.cs
index 26eec5cc4d..0e79bab11f 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DataEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DataEntityType.cs
@@ -37,6 +37,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -120,7 +126,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DbContextModelBuilder.cs
index 47022523ee..8e827f6b70 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Key_sequence/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -67,25 +68,28 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "int", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs
index 292272fe62..b108f051e4 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -57,25 +58,28 @@ private IRelationalModel CreateRelationalModel()
             var dependentDerivedintTable = new Table("DependentDerived<int>", null, relationalModel);
             var idColumn = new Column("Id", "int", dependentDerivedintTable);
             dependentDerivedintTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var dataColumn = new Column("Data", "nvarchar(max)", dependentDerivedintTable)
             {
                 IsNullable = true
             };
             dependentDerivedintTable.Columns.Add("Data", dataColumn);
+            dataColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dataColumn);
+            relationalModel.Tables.Add(("DependentDerived<int>", null), dependentDerivedintTable);
+            var dependentDerivedintTableMapping = new TableMapping(dependentDerived, dependentDerivedintTable, null);
+            dependentDerivedintTable.AddTypeMapping(dependentDerivedintTableMapping, false);
+            tableMappings.Add(dependentDerivedintTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentDerivedintTableMapping);
+            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentDerivedintTableMapping);
             var pK_DependentDerivedint = new UniqueConstraint("PK_DependentDerived<int>", dependentDerivedintTable, new[] { idColumn });
             dependentDerivedintTable.PrimaryKey = pK_DependentDerivedint;
+            pK_DependentDerivedint.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_DependentDerivedint));
             var pK_DependentDerivedintKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentDerived<int>",
                 new[] { "Id" });
             pK_DependentDerivedint.MappedKeys.Add(pK_DependentDerivedintKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DependentDerivedintKey).Add(pK_DependentDerivedint);
             dependentDerivedintTable.UniqueConstraints.Add("PK_DependentDerived<int>", pK_DependentDerivedint);
-            relationalModel.Tables.Add(("DependentDerived<int>", null), dependentDerivedintTable);
-            var dependentDerivedintTableMapping = new TableMapping(dependentDerived, dependentDerivedintTable, null);
-            dependentDerivedintTable.AddTypeMapping(dependentDerivedintTableMapping, false);
-            tableMappings.Add(dependentDerivedintTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentDerivedintTableMapping);
-            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentDerivedintTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
index e1f2efe2aa..21108823b1 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
@@ -134,7 +134,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var data = runtimeEntityType.FindProperty("Data")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
@@ -177,7 +177,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
-        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentDerived<int> @this);
+        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentBase<int> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Data>k__BackingField")]
         public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentDerived1_Data(CompiledModelTestBase.DependentDerived<int> @this);
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/DbContextModelBuilder.cs
index 1326e686ea..ca89c19500 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/DbContextModelBuilder.cs
@@ -5,6 +5,8 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
+using NetTopologySuite.Geometries;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -57,25 +59,28 @@ private IRelationalModel CreateRelationalModel()
             var spatialTypesTable = new Table("SpatialTypes", null, relationalModel);
             var idColumn = new Column("Id", "int", spatialTypesTable);
             spatialTypesTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var pointColumn = new Column("Point", "geometry", spatialTypesTable)
             {
                 IsNullable = true
             };
             spatialTypesTable.Columns.Add("Point", pointColumn);
+            pointColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Point>(pointColumn);
+            relationalModel.Tables.Add(("SpatialTypes", null), spatialTypesTable);
+            var spatialTypesTableMapping = new TableMapping(spatialTypes, spatialTypesTable, null);
+            spatialTypesTable.AddTypeMapping(spatialTypesTableMapping, false);
+            tableMappings.Add(spatialTypesTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, spatialTypes.FindProperty("Id")!, spatialTypesTableMapping);
+            RelationalModel.CreateColumnMapping(pointColumn, spatialTypes.FindProperty("Point")!, spatialTypesTableMapping);
             var pK_SpatialTypes = new UniqueConstraint("PK_SpatialTypes", spatialTypesTable, new[] { idColumn });
             spatialTypesTable.PrimaryKey = pK_SpatialTypes;
+            pK_SpatialTypes.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_SpatialTypes));
             var pK_SpatialTypesKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelRelationalTestBase+SpatialTypes",
                 new[] { "Id" });
             pK_SpatialTypes.MappedKeys.Add(pK_SpatialTypesKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_SpatialTypesKey).Add(pK_SpatialTypes);
             spatialTypesTable.UniqueConstraints.Add("PK_SpatialTypes", pK_SpatialTypes);
-            relationalModel.Tables.Add(("SpatialTypes", null), spatialTypesTable);
-            var spatialTypesTableMapping = new TableMapping(spatialTypes, spatialTypesTable, null);
-            spatialTypesTable.AddTypeMapping(spatialTypesTableMapping, false);
-            tableMappings.Add(spatialTypesTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, spatialTypes.FindProperty("Id")!, spatialTypesTableMapping);
-            RelationalModel.CreateColumnMapping(pointColumn, spatialTypes.FindProperty("Point")!, spatialTypesTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/SpatialTypesEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/SpatialTypesEntityType.cs
index c85a029d02..262890e035 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/SpatialTypesEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/SpatialTypesTest/SpatialTypesEntityType.cs
@@ -84,6 +84,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueConverter: new CastingConverter<Point, Point>(),
                 valueComparer: new CompiledModelTestBase.CustomValueComparer<Point>(),
                 providerValueComparer: new CompiledModelTestBase.CustomValueComparer<Point>());
+            point.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Point>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Point>(0) == null ? entry.ReadTemporaryValue<Point>(1) : entry.ReadShadowValue<Point>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Point>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Point>(point, 1),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<Point>(point),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             point.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -107,7 +113,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var point = runtimeEntityType.FindProperty("Point")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
@@ -150,6 +156,6 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
-        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_AbstractBase_Id(CompiledModelRelationalTestBase.SpatialTypes @this);
+        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_AbstractBase_Id(CompiledModelTestBase.AbstractBase @this);
     }
 }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DbContextModelBuilder.cs
index cea523d602..7ab94e2823 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DbContextModelBuilder.cs
@@ -6,6 +6,7 @@
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -67,13 +68,22 @@ private IRelationalModel CreateRelationalModel()
             var dependentBasebyteTable = new Table("DependentBase<byte?>", "TPC", relationalModel);
             var idColumn = new Column("Id", "tinyint", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(idColumn);
             var principalIdColumn = new Column("PrincipalId", "bigint", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
+            principalIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalIdColumn);
+            relationalModel.Tables.Add(("DependentBase<byte?>", "TPC"), dependentBasebyteTable);
+            var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, null);
+            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping, false);
+            tableMappings.Add(dependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, dependentBase.FindProperty("Id")!, dependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalIdColumn, dependentBase.FindProperty("PrincipalId")!, dependentBasebyteTableMapping);
             var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { idColumn });
             dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
+            pK_DependentBasebyte.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<byte>(pK_DependentBasebyte));
             var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "Id" });
@@ -82,18 +92,13 @@ private IRelationalModel CreateRelationalModel()
             dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
             var iX_DependentBasebyte_PrincipalId = new TableIndex(
             "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
+            iX_DependentBasebyte_PrincipalId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_DependentBasebyte_PrincipalId));
             var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId" });
             iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
             RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
             dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
-            relationalModel.Tables.Add(("DependentBase<byte?>", "TPC"), dependentBasebyteTable);
-            var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, null);
-            dependentBasebyteTable.AddTypeMapping(dependentBasebyteTableMapping, false);
-            tableMappings.Add(dependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, dependentBase.FindProperty("Id")!, dependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalIdColumn, dependentBase.FindProperty("PrincipalId")!, dependentBasebyteTableMapping);
 
             var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase")!;
 
@@ -188,69 +193,104 @@ private IRelationalModel CreateRelationalModel()
             var principalBaseTable = new Table("PrincipalBase", "TPC", relationalModel);
             var idColumn0 = new Column("Id", "bigint", principalBaseTable);
             principalBaseTable.Columns.Add("Id", idColumn0);
+            idColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(idColumn0);
             var enum1Column = new Column("Enum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("Enum1", enum1Column);
+            enum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum1Column);
             var enum2Column = new Column("Enum2", "int", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Enum2", enum2Column);
+            enum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum2Column);
             var flagsEnum1Column = new Column("FlagsEnum1", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
+            flagsEnum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum1Column);
             var flagsEnum2Column = new Column("FlagsEnum2", "int", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
+            flagsEnum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum2Column);
             var principalBaseIdColumn = new Column("PrincipalBaseId", "bigint", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
+            principalBaseIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalBaseIdColumn);
             var principalDerivedDependentBasebyteIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>Id", "bigint", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn);
+            principalDerivedDependentBasebyteIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalDerivedDependentBasebyteIdColumn);
             var refTypeArrayColumn = new Column("RefTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
+            refTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn);
             var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
+            refTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn);
             var refTypeIListColumn = new Column("RefTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
+            refTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn);
             var refTypeListColumn = new Column("RefTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
+            refTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn);
             var valueTypeArrayColumn = new Column("ValueTypeArray", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
+            valueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn);
             var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
+            valueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn);
             var valueTypeIListColumn = new Column("ValueTypeIList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
+            valueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn);
             var valueTypeListColumn = new Column("ValueTypeList", "nvarchar(max)", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
+            valueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn);
+            relationalModel.Tables.Add(("PrincipalBase", "TPC"), principalBaseTable);
+            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, false);
+            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
+            tableMappings0.Add(principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn0, principalBase.FindProperty("Id")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(principalBaseIdColumn, principalBase.FindProperty("PrincipalBaseId")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteIdColumn, principalBase.FindProperty("PrincipalDerivedId")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
+            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);
             var pK_PrincipalBase = new UniqueConstraint("PK_PrincipalBase", principalBaseTable, new[] { idColumn0 });
             principalBaseTable.PrimaryKey = pK_PrincipalBase;
+            pK_PrincipalBase.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(pK_PrincipalBase));
             var pK_PrincipalBaseKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
                 new[] { "Id" });
@@ -259,6 +299,7 @@ private IRelationalModel CreateRelationalModel()
             principalBaseTable.UniqueConstraints.Add("PK_PrincipalBase", pK_PrincipalBase);
             var iX_PrincipalBase_PrincipalDerivedDependentBasebyteId = new TableIndex(
             "IX_PrincipalBase_PrincipalDerived<DependentBase<byte?>>Id", principalBaseTable, new[] { principalDerivedDependentBasebyteIdColumn }, false);
+            iX_PrincipalBase_PrincipalDerivedDependentBasebyteId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_PrincipalBase_PrincipalDerivedDependentBasebyteId));
             var iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx = RelationalModel.GetIndex(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
                 new[] { "PrincipalDerivedId" });
@@ -267,31 +308,13 @@ private IRelationalModel CreateRelationalModel()
             principalBaseTable.Indexes.Add("IX_PrincipalBase_PrincipalDerived<DependentBase<byte?>>Id", iX_PrincipalBase_PrincipalDerivedDependentBasebyteId);
             var pIX = new TableIndex(
             "PIX", principalBaseTable, new[] { principalBaseIdColumn }, true);
+            pIX.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(pIX));
             var pIXIx = RelationalModel.GetIndex(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
                 "PrincipalIndex");
             pIX.MappedIndexes.Add(pIXIx);
             RelationalModel.GetOrCreateTableIndexes(pIXIx).Add(pIX);
             principalBaseTable.Indexes.Add("PIX", pIX);
-            relationalModel.Tables.Add(("PrincipalBase", "TPC"), principalBaseTable);
-            var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, false);
-            principalBaseTable.AddTypeMapping(principalBaseTableMapping, false);
-            tableMappings0.Add(principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn0, principalBase.FindProperty("Id")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(enum1Column, principalBase.FindProperty("Enum1")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(enum2Column, principalBase.FindProperty("Enum2")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(flagsEnum1Column, principalBase.FindProperty("FlagsEnum1")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(flagsEnum2Column, principalBase.FindProperty("FlagsEnum2")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(principalBaseIdColumn, principalBase.FindProperty("PrincipalBaseId")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(principalDerivedDependentBasebyteIdColumn, principalBase.FindProperty("PrincipalDerivedId")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(refTypeArrayColumn, principalBase.FindProperty("RefTypeArray")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(refTypeEnumerableColumn, principalBase.FindProperty("RefTypeEnumerable")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(refTypeIListColumn, principalBase.FindProperty("RefTypeIList")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(refTypeListColumn, principalBase.FindProperty("RefTypeList")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(valueTypeArrayColumn, principalBase.FindProperty("ValueTypeArray")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalBase.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalBase.FindProperty("ValueTypeIList")!, principalBaseTableMapping);
-            RelationalModel.CreateColumnMapping(valueTypeListColumn, principalBase.FindProperty("ValueTypeList")!, principalBaseTableMapping);
 
             var viewMappings = new List<ViewMapping>();
             principalBase.SetRuntimeAnnotation("Relational:ViewMappings", viewMappings);
@@ -665,82 +688,82 @@ private IRelationalModel CreateRelationalModel()
             var principalDerivedTable = new Table("PrincipalDerived", "TPC", relationalModel);
             var idColumn1 = new Column("Id", "bigint", principalDerivedTable);
             principalDerivedTable.Columns.Add("Id", idColumn1);
+            idColumn1.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(idColumn1);
             var enum1Column0 = new Column("Enum1", "int", principalDerivedTable);
             principalDerivedTable.Columns.Add("Enum1", enum1Column0);
+            enum1Column0.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum1Column0);
             var enum2Column0 = new Column("Enum2", "int", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("Enum2", enum2Column0);
+            enum2Column0.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum2Column0);
             var flagsEnum1Column0 = new Column("FlagsEnum1", "int", principalDerivedTable);
             principalDerivedTable.Columns.Add("FlagsEnum1", flagsEnum1Column0);
+            flagsEnum1Column0.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum1Column0);
             var flagsEnum2Column0 = new Column("FlagsEnum2", "int", principalDerivedTable);
             principalDerivedTable.Columns.Add("FlagsEnum2", flagsEnum2Column0);
+            flagsEnum2Column0.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum2Column0);
             var principalBaseIdColumn0 = new Column("PrincipalBaseId", "bigint", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn0);
+            principalBaseIdColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalBaseIdColumn0);
             var principalDerivedDependentBasebyteIdColumn0 = new Column("PrincipalDerived<DependentBase<byte?>>Id", "bigint", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn0);
+            principalDerivedDependentBasebyteIdColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalDerivedDependentBasebyteIdColumn0);
             var refTypeArrayColumn0 = new Column("RefTypeArray", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("RefTypeArray", refTypeArrayColumn0);
+            refTypeArrayColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn0);
             var refTypeEnumerableColumn0 = new Column("RefTypeEnumerable", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn0);
+            refTypeEnumerableColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn0);
             var refTypeIListColumn0 = new Column("RefTypeIList", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("RefTypeIList", refTypeIListColumn0);
+            refTypeIListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn0);
             var refTypeListColumn0 = new Column("RefTypeList", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("RefTypeList", refTypeListColumn0);
+            refTypeListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn0);
             var valueTypeArrayColumn0 = new Column("ValueTypeArray", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn0);
+            valueTypeArrayColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn0);
             var valueTypeEnumerableColumn0 = new Column("ValueTypeEnumerable", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn0);
+            valueTypeEnumerableColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn0);
             var valueTypeIListColumn0 = new Column("ValueTypeIList", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("ValueTypeIList", valueTypeIListColumn0);
+            valueTypeIListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn0);
             var valueTypeListColumn0 = new Column("ValueTypeList", "nvarchar(max)", principalDerivedTable)
             {
                 IsNullable = true
             };
             principalDerivedTable.Columns.Add("ValueTypeList", valueTypeListColumn0);
-            var pK_PrincipalDerived = new UniqueConstraint("PK_PrincipalDerived", principalDerivedTable, new[] { idColumn1 });
-            principalDerivedTable.PrimaryKey = pK_PrincipalDerived;
-            pK_PrincipalDerived.MappedKeys.Add(pK_PrincipalBaseKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBaseKey).Add(pK_PrincipalDerived);
-            principalDerivedTable.UniqueConstraints.Add("PK_PrincipalDerived", pK_PrincipalDerived);
-            var iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId = new TableIndex(
-            "IX_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", principalDerivedTable, new[] { principalDerivedDependentBasebyteIdColumn0 }, false);
-            iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId.MappedIndexes.Add(iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx).Add(iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
-            principalDerivedTable.Indexes.Add("IX_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
-            var pIX0 = new TableIndex(
-            "PIX", principalDerivedTable, new[] { principalBaseIdColumn0 }, true);
-            pIX0.MappedIndexes.Add(pIXIx);
-            RelationalModel.GetOrCreateTableIndexes(pIXIx).Add(pIX0);
-            principalDerivedTable.Indexes.Add("PIX", pIX0);
+            valueTypeListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn0);
             relationalModel.Tables.Add(("PrincipalDerived", "TPC"), principalDerivedTable);
             var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, null);
             principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
@@ -760,6 +783,24 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn0, principalDerived.FindProperty("ValueTypeEnumerable")!, principalDerivedTableMapping);
             RelationalModel.CreateColumnMapping(valueTypeIListColumn0, principalDerived.FindProperty("ValueTypeIList")!, principalDerivedTableMapping);
             RelationalModel.CreateColumnMapping(valueTypeListColumn0, principalDerived.FindProperty("ValueTypeList")!, principalDerivedTableMapping);
+            var pK_PrincipalDerived = new UniqueConstraint("PK_PrincipalDerived", principalDerivedTable, new[] { idColumn1 });
+            principalDerivedTable.PrimaryKey = pK_PrincipalDerived;
+            pK_PrincipalDerived.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(pK_PrincipalDerived));
+            pK_PrincipalDerived.MappedKeys.Add(pK_PrincipalBaseKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_PrincipalBaseKey).Add(pK_PrincipalDerived);
+            principalDerivedTable.UniqueConstraints.Add("PK_PrincipalDerived", pK_PrincipalDerived);
+            var iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId = new TableIndex(
+            "IX_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", principalDerivedTable, new[] { principalDerivedDependentBasebyteIdColumn0 }, false);
+            iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId));
+            iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId.MappedIndexes.Add(iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_PrincipalDerivedDependentBasebyteIdIx).Add(iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
+            principalDerivedTable.Indexes.Add("IX_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", iX_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
+            var pIX0 = new TableIndex(
+            "PIX", principalDerivedTable, new[] { principalBaseIdColumn0 }, true);
+            pIX0.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(pIX0));
+            pIX0.MappedIndexes.Add(pIXIx);
+            RelationalModel.GetOrCreateTableIndexes(pIXIx).Add(pIX0);
+            principalDerivedTable.Indexes.Add("PIX", pIX0);
 
             var viewMappings0 = new List<ViewMapping>();
             principalDerived.SetRuntimeAnnotation("Relational:ViewMappings", viewMappings0);
@@ -1042,6 +1083,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_DependentBase<byte?>_PrincipalDerived_PrincipalId", dependentBasebyteTable, principalDerivedTable,
                 new[] { principalIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK_PrincipalDerived")!, ReferentialAction.NoAction);
+            fK_DependentBasebyte_PrincipalDerived_PrincipalId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_DependentBasebyte_PrincipalDerived_PrincipalId));
             var fK_DependentBasebyte_PrincipalDerived_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId" },
@@ -1055,6 +1097,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBase_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", principalBaseTable, principalDerivedTable,
                 new[] { principalDerivedDependentBasebyteIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK_PrincipalDerived")!, ReferentialAction.NoAction);
+            fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteId));
             var fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
                 new[] { "PrincipalDerivedId" },
@@ -1068,6 +1111,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalDerived_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id", principalDerivedTable, principalDerivedTable,
                 new[] { principalDerivedDependentBasebyteIdColumn0 },
                 principalDerivedTable.FindUniqueConstraint("PK_PrincipalDerived")!, ReferentialAction.NoAction);
+            fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId));
             fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId.MappedForeignKeys.Add(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk);
             RelationalModel.GetOrCreateForeignKeyConstraints(fK_PrincipalBase_PrincipalDerived_PrincipalDerivedDependentBasebyteIdFk).Add(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
             principalDerivedTable.ForeignKeyConstraints.Add(fK_PrincipalDerived_PrincipalDerived_PrincipalDerivedDependentBasebyteId);
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DependentBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DependentBaseEntityType.cs
index 0580e5ef41..ee2625a94b 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DependentBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/DependentBaseEntityType.cs
@@ -83,6 +83,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "PrincipalId",
                 typeof(long?),
                 nullable: true);
+            principalId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Nullable<long>>(0) : entry.FlaggedAsTemporary(1) && !entry.ReadShadowValue<Nullable<long>>(0).HasValue ? entry.ReadTemporaryValue<Nullable<long>>(0) : entry.ReadShadowValue<Nullable<long>>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<long>>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Nullable<long>>(principalId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Nullable<long>>(principalId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -136,17 +142,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             principal.SetGetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
             principal.SetSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetMaterializationSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetAccessors(
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>>(principal),
                 null);
@@ -156,6 +162,7 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            principal.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal", "TestNamespace") });
             var dependent = principalEntityType.AddNavigation("Dependent",
                 runtimeForeignKey,
                 onDependent: false,
@@ -192,7 +199,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var principalId = runtimeEntityType.FindProperty("PrincipalId")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<byte?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<byte?, byte>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<byte?>(key));
             var principal = runtimeEntityType.FindNavigation("Principal")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs
index 072df712f1..234680bb09 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Tpc_Sprocs/PrincipalBaseEntityType.cs
@@ -317,6 +317,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "PrincipalBaseId",
                 typeof(long?),
                 nullable: true);
+            principalBaseId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(5) ? entry.ReadStoreGeneratedValue<Nullable<long>>(1) : entry.FlaggedAsTemporary(5) && !entry.ReadShadowValue<Nullable<long>>(0).HasValue ? entry.ReadTemporaryValue<Nullable<long>>(1) : entry.ReadShadowValue<Nullable<long>>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<long>>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Nullable<long>>(principalBaseId, 5),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Nullable<long>>(principalBaseId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[5]);
             principalBaseId.SetPropertyIndexes(
                 index: 5,
                 originalValueIndex: 5,
@@ -345,6 +351,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "PrincipalDerivedId",
                 typeof(long?),
                 nullable: true);
+            principalDerivedId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(6) ? entry.ReadStoreGeneratedValue<Nullable<long>>(2) : entry.FlaggedAsTemporary(6) && !entry.ReadShadowValue<Nullable<long>>(1).HasValue ? entry.ReadTemporaryValue<Nullable<long>>(2) : entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Nullable<long>>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Nullable<long>>(principalDerivedId, 6),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Nullable<long>>(principalDerivedId, 2),
+                (ValueBuffer valueBuffer) => valueBuffer[6]);
             principalDerivedId.SetPropertyIndexes(
                 index: 6,
                 originalValueIndex: 6,
@@ -972,17 +984,17 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.PrincipalBase).GetField("<Deriveds>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             deriveds.SetGetter(
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) == null,
-                (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance),
-                (CompiledModelTestBase.PrincipalBase instance) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance) == null);
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) == null,
+                (CompiledModelTestBase.PrincipalBase instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance),
+                (CompiledModelTestBase.PrincipalBase instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(instance) == null);
             deriveds.SetSetter(
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
             deriveds.SetMaterializationSetter(
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = value);
             deriveds.SetAccessors(
-                (InternalEntityEntry entry) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
-                (InternalEntityEntry entry) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds((CompiledModelTestBase.PrincipalBase)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<ICollection<CompiledModelTestBase.PrincipalBase>>(deriveds),
                 null);
@@ -993,11 +1005,12 @@ public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEnt
                 relationshipIndex: 3,
                 storeGenerationIndex: -1);
             deriveds.SetCollectionAccessor<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(
-                (CompiledModelTestBase.PrincipalBase entity) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
-                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
+                (CompiledModelTestBase.PrincipalBase entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity),
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
+                (CompiledModelTestBase.PrincipalBase entity, ICollection<CompiledModelTestBase.PrincipalBase> collection) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(entity) = (ICollection<CompiledModelTestBase.PrincipalBase>)collection,
                 (CompiledModelTestBase.PrincipalBase entity, Action<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>> setter) => ClrCollectionAccessorFactory.CreateAndSetHashSet<CompiledModelTestBase.PrincipalBase, ICollection<CompiledModelTestBase.PrincipalBase>, CompiledModelTestBase.PrincipalBase>(entity, setter),
                 () => (ICollection<CompiledModelTestBase.PrincipalBase>)(ICollection<CompiledModelTestBase.PrincipalBase>)new HashSet<CompiledModelTestBase.PrincipalBase>(ReferenceEqualityComparer.Instance));
+            deriveds.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("PrincipalBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds", "TestNamespace") });
             return runtimeForeignKey;
         }
 
@@ -1062,7 +1075,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var deriveds = runtimeEntityType.FindNavigation("Deriveds")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs
index bfb31d3048..564bf8bbcf 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs
@@ -38,6 +38,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -124,7 +130,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs
index 47cd51ca00..4da62fe9d9 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -57,13 +58,22 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "int", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "varbinary(max)", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
@@ -72,12 +82,6 @@ private IRelationalModel CreateRelationalModel()
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
             dataTable.Triggers.Add("Trigger1", data.FindDeclaredTrigger("Trigger1"));
             dataTable.Triggers.Add("Trigger2", data.FindDeclaredTrigger("Trigger2"));
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.SqlServer.FunctionalTests/Update/MismatchedKeyTypesSqlServerTest.cs b/test/EFCore.SqlServer.FunctionalTests/Update/MismatchedKeyTypesSqlServerTest.cs
index 684c25c2cc..621d1edc67 100644
--- a/test/EFCore.SqlServer.FunctionalTests/Update/MismatchedKeyTypesSqlServerTest.cs
+++ b/test/EFCore.SqlServer.FunctionalTests/Update/MismatchedKeyTypesSqlServerTest.cs
@@ -353,7 +353,7 @@ public virtual void Queries_work_but_SaveChanges_fails_when_keys_incompatible_in
         Assert.Equal(
             RelationalStrings.StoredKeyTypesNotConvertable(
                 nameof(OptionalSingleBad.PrincipalId), "uniqueidentifier", "bigint", nameof(PrincipalBad.Id)),
-            Assert.Throws<TargetInvocationException>(() => context.SaveChanges()).InnerException!.InnerException!.Message);
+            Assert.Throws<InvalidOperationException>(() => context.SaveChanges()).Message);
     }
 
     protected class MismatchedKeyTypesContextNoFks(MismatchedKeyTypesSqlServerFixture fixture) : MismatchedKeyTypesContext(fixture)
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DataEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DataEntityType.cs
index 60423e36a2..0fcded4aa9 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DataEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DataEntityType.cs
@@ -38,6 +38,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -107,6 +113,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "Point",
                 typeof(Point),
                 nullable: true);
+            point.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Point>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Point>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Point>(point, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<Point>(point),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             point.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -128,7 +140,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var point = runtimeEntityType.FindProperty("Point")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs
index 0734f649de..e5aea091df 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DbContextModelBuilder.cs
@@ -6,6 +6,8 @@
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Update.Internal;
+using NetTopologySuite.Geometries;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -90,31 +92,35 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "INTEGER", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "BLOB", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
             var pointColumn = new Column("Point", "POINT", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Point", pointColumn);
+            pointColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Point>(pointColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(pointColumn, data.FindProperty("Point")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(pointColumn, data.FindProperty("Point")!, dataTableMapping);
 
             var dependentBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>")!;
 
@@ -156,41 +162,31 @@ private IRelationalModel CreateRelationalModel()
             var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
             var principalIdColumn = new Column("PrincipalId", "INTEGER", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
+            principalIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalIdColumn);
             var principalAlternateIdColumn = new Column("PrincipalAlternateId", "TEXT", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
+            principalAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalAlternateIdColumn);
             var dataColumn = new Column("Data", "TEXT", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Data", dataColumn);
+            dataColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dataColumn);
             var enumDiscriminatorColumn = new Column("EnumDiscriminator", "INTEGER", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
+            enumDiscriminatorColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumDiscriminatorColumn);
             var idColumn0 = new Column("Id", "INTEGER", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Id", idColumn0);
+            idColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(idColumn0);
             var moneyColumn = new Column("Money", "TEXT", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Money", moneyColumn);
-            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
-            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
-            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId", "PrincipalAlternateId" });
-            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
-            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
-            var iX_DependentBasebyte_PrincipalId = new TableIndex(
-            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
-            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId" });
-            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
-            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
+            moneyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(moneyColumn);
             relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
             var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
             {
@@ -231,6 +227,24 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(idColumn0, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);
+            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
+            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
+            pK_DependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_DependentBasebyte));
+            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId", "PrincipalAlternateId" });
+            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
+            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
+            var iX_DependentBasebyte_PrincipalId = new TableIndex(
+            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
+            iX_DependentBasebyte_PrincipalId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_DependentBasebyte_PrincipalId));
+            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId" });
+            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
+            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
 
             var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes")!;
 
@@ -1144,651 +1158,901 @@ private IRelationalModel CreateRelationalModel()
             var manyTypesTable = new Table("ManyTypes", null, relationalModel);
             var idColumn1 = new Column("Id", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Id", idColumn1);
+            idColumn1.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn1);
             var boolColumn = new Column("Bool", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Bool", boolColumn);
+            boolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(boolColumn);
             var boolArrayColumn = new Column("BoolArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
+            boolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolArrayColumn);
             var boolNestedCollectionColumn = new Column("BoolNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BoolNestedCollection", boolNestedCollectionColumn);
+            boolNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolNestedCollectionColumn);
             var boolToStringConverterPropertyColumn = new Column("BoolToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToStringConverterProperty", boolToStringConverterPropertyColumn);
+            boolToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolToStringConverterPropertyColumn);
             var boolToTwoValuesConverterPropertyColumn = new Column("BoolToTwoValuesConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToTwoValuesConverterProperty", boolToTwoValuesConverterPropertyColumn);
+            boolToTwoValuesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(boolToTwoValuesConverterPropertyColumn);
             var boolToZeroOneConverterPropertyColumn = new Column("BoolToZeroOneConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToZeroOneConverterProperty", boolToZeroOneConverterPropertyColumn);
+            boolToZeroOneConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(boolToZeroOneConverterPropertyColumn);
             var bytesColumn = new Column("Bytes", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("Bytes", bytesColumn);
+            bytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(bytesColumn);
             var bytesArrayColumn = new Column("BytesArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
+            bytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesArrayColumn);
             var bytesNestedCollectionColumn = new Column("BytesNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BytesNestedCollection", bytesNestedCollectionColumn);
+            bytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesNestedCollectionColumn);
             var bytesToStringConverterPropertyColumn = new Column("BytesToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BytesToStringConverterProperty", bytesToStringConverterPropertyColumn);
+            bytesToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesToStringConverterPropertyColumn);
             var castingConverterPropertyColumn = new Column("CastingConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CastingConverterProperty", castingConverterPropertyColumn);
+            castingConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(castingConverterPropertyColumn);
             var charColumn = new Column("Char", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Char", charColumn);
+            charColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<char>(charColumn);
             var charArrayColumn = new Column("CharArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CharArray", charArrayColumn);
+            charArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charArrayColumn);
             var charNestedCollectionColumn = new Column("CharNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CharNestedCollection", charNestedCollectionColumn);
+            charNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charNestedCollectionColumn);
             var charToStringConverterPropertyColumn = new Column("CharToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CharToStringConverterProperty", charToStringConverterPropertyColumn);
+            charToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charToStringConverterPropertyColumn);
             var dateOnlyColumn = new Column("DateOnly", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
+            dateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(dateOnlyColumn);
             var dateOnlyArrayColumn = new Column("DateOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
+            dateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyArrayColumn);
             var dateOnlyToStringConverterPropertyColumn = new Column("DateOnlyToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyToStringConverterProperty", dateOnlyToStringConverterPropertyColumn);
+            dateOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyToStringConverterPropertyColumn);
             var dateTimeColumn = new Column("DateTime", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
+            dateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeColumn);
             var dateTimeArrayColumn = new Column("DateTimeArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
+            dateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeArrayColumn);
             var dateTimeOffsetToBinaryConverterPropertyColumn = new Column("DateTimeOffsetToBinaryConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBinaryConverterProperty", dateTimeOffsetToBinaryConverterPropertyColumn);
+            dateTimeOffsetToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeOffsetToBinaryConverterPropertyColumn);
             var dateTimeOffsetToBytesConverterPropertyColumn = new Column("DateTimeOffsetToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBytesConverterProperty", dateTimeOffsetToBytesConverterPropertyColumn);
+            dateTimeOffsetToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(dateTimeOffsetToBytesConverterPropertyColumn);
             var dateTimeOffsetToStringConverterPropertyColumn = new Column("DateTimeOffsetToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToStringConverterProperty", dateTimeOffsetToStringConverterPropertyColumn);
+            dateTimeOffsetToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeOffsetToStringConverterPropertyColumn);
             var dateTimeToBinaryConverterPropertyColumn = new Column("DateTimeToBinaryConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToBinaryConverterProperty", dateTimeToBinaryConverterPropertyColumn);
+            dateTimeToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeToBinaryConverterPropertyColumn);
             var dateTimeToStringConverterPropertyColumn = new Column("DateTimeToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToStringConverterProperty", dateTimeToStringConverterPropertyColumn);
+            dateTimeToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeToStringConverterPropertyColumn);
             var dateTimeToTicksConverterPropertyColumn = new Column("DateTimeToTicksConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToTicksConverterProperty", dateTimeToTicksConverterPropertyColumn);
+            dateTimeToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeToTicksConverterPropertyColumn);
             var decimalColumn = new Column("Decimal", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Decimal", decimalColumn);
+            decimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(decimalColumn);
             var decimalArrayColumn = new Column("DecimalArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
+            decimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalArrayColumn);
             var decimalNumberToBytesConverterPropertyColumn = new Column("DecimalNumberToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToBytesConverterProperty", decimalNumberToBytesConverterPropertyColumn);
+            decimalNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(decimalNumberToBytesConverterPropertyColumn);
             var decimalNumberToStringConverterPropertyColumn = new Column("DecimalNumberToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToStringConverterProperty", decimalNumberToStringConverterPropertyColumn);
+            decimalNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalNumberToStringConverterPropertyColumn);
             var doubleColumn = new Column("Double", "REAL", manyTypesTable);
             manyTypesTable.Columns.Add("Double", doubleColumn);
+            doubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(doubleColumn);
             var doubleArrayColumn = new Column("DoubleArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
+            doubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleArrayColumn);
             var doubleNumberToBytesConverterPropertyColumn = new Column("DoubleNumberToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToBytesConverterProperty", doubleNumberToBytesConverterPropertyColumn);
+            doubleNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(doubleNumberToBytesConverterPropertyColumn);
             var doubleNumberToStringConverterPropertyColumn = new Column("DoubleNumberToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToStringConverterProperty", doubleNumberToStringConverterPropertyColumn);
+            doubleNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleNumberToStringConverterPropertyColumn);
             var enum16Column = new Column("Enum16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16", enum16Column);
+            enum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(enum16Column);
             var enum16ArrayColumn = new Column("Enum16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Array", enum16ArrayColumn);
+            enum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16ArrayColumn);
             var enum16AsStringColumn = new Column("Enum16AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsString", enum16AsStringColumn);
+            enum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringColumn);
             var enum16AsStringArrayColumn = new Column("Enum16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringArray", enum16AsStringArrayColumn);
+            enum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringArrayColumn);
             var enum16AsStringCollectionColumn = new Column("Enum16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringCollection", enum16AsStringCollectionColumn);
+            enum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringCollectionColumn);
             var enum16CollectionColumn = new Column("Enum16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Collection", enum16CollectionColumn);
+            enum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16CollectionColumn);
             var enum32Column = new Column("Enum32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32", enum32Column);
+            enum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum32Column);
             var enum32ArrayColumn = new Column("Enum32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Array", enum32ArrayColumn);
+            enum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32ArrayColumn);
             var enum32AsStringColumn = new Column("Enum32AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsString", enum32AsStringColumn);
+            enum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringColumn);
             var enum32AsStringArrayColumn = new Column("Enum32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringArray", enum32AsStringArrayColumn);
+            enum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringArrayColumn);
             var enum32AsStringCollectionColumn = new Column("Enum32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringCollection", enum32AsStringCollectionColumn);
+            enum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringCollectionColumn);
             var enum32CollectionColumn = new Column("Enum32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Collection", enum32CollectionColumn);
+            enum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32CollectionColumn);
             var enum32NestedCollectionColumn = new Column("Enum32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32NestedCollection", enum32NestedCollectionColumn);
+            enum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32NestedCollectionColumn);
             var enum64Column = new Column("Enum64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64", enum64Column);
+            enum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(enum64Column);
             var enum64ArrayColumn = new Column("Enum64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Array", enum64ArrayColumn);
+            enum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64ArrayColumn);
             var enum64AsStringColumn = new Column("Enum64AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsString", enum64AsStringColumn);
+            enum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringColumn);
             var enum64AsStringArrayColumn = new Column("Enum64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringArray", enum64AsStringArrayColumn);
+            enum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringArrayColumn);
             var enum64AsStringCollectionColumn = new Column("Enum64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringCollection", enum64AsStringCollectionColumn);
+            enum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringCollectionColumn);
             var enum64CollectionColumn = new Column("Enum64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Collection", enum64CollectionColumn);
+            enum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64CollectionColumn);
             var enum8Column = new Column("Enum8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8", enum8Column);
+            enum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(enum8Column);
             var enum8ArrayColumn = new Column("Enum8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Array", enum8ArrayColumn);
+            enum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8ArrayColumn);
             var enum8AsStringColumn = new Column("Enum8AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsString", enum8AsStringColumn);
+            enum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringColumn);
             var enum8AsStringArrayColumn = new Column("Enum8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringArray", enum8AsStringArrayColumn);
+            enum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringArrayColumn);
             var enum8AsStringCollectionColumn = new Column("Enum8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringCollection", enum8AsStringCollectionColumn);
+            enum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringCollectionColumn);
             var enum8CollectionColumn = new Column("Enum8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Collection", enum8CollectionColumn);
+            enum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8CollectionColumn);
             var enum8NestedCollectionColumn = new Column("Enum8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8NestedCollection", enum8NestedCollectionColumn);
+            enum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8NestedCollectionColumn);
             var enumToNumberConverterPropertyColumn = new Column("EnumToNumberConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToNumberConverterProperty", enumToNumberConverterPropertyColumn);
+            enumToNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumToNumberConverterPropertyColumn);
             var enumToStringConverterPropertyColumn = new Column("EnumToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToStringConverterProperty", enumToStringConverterPropertyColumn);
+            enumToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumToStringConverterPropertyColumn);
             var enumU16Column = new Column("EnumU16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16", enumU16Column);
+            enumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(enumU16Column);
             var enumU16ArrayColumn = new Column("EnumU16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Array", enumU16ArrayColumn);
+            enumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16ArrayColumn);
             var enumU16AsStringColumn = new Column("EnumU16AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsString", enumU16AsStringColumn);
+            enumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringColumn);
             var enumU16AsStringArrayColumn = new Column("EnumU16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringArray", enumU16AsStringArrayColumn);
+            enumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringArrayColumn);
             var enumU16AsStringCollectionColumn = new Column("EnumU16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringCollection", enumU16AsStringCollectionColumn);
+            enumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringCollectionColumn);
             var enumU16CollectionColumn = new Column("EnumU16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Collection", enumU16CollectionColumn);
+            enumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16CollectionColumn);
             var enumU32Column = new Column("EnumU32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32", enumU32Column);
+            enumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(enumU32Column);
             var enumU32ArrayColumn = new Column("EnumU32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Array", enumU32ArrayColumn);
+            enumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32ArrayColumn);
             var enumU32AsStringColumn = new Column("EnumU32AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsString", enumU32AsStringColumn);
+            enumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringColumn);
             var enumU32AsStringArrayColumn = new Column("EnumU32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringArray", enumU32AsStringArrayColumn);
+            enumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringArrayColumn);
             var enumU32AsStringCollectionColumn = new Column("EnumU32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringCollection", enumU32AsStringCollectionColumn);
+            enumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringCollectionColumn);
             var enumU32CollectionColumn = new Column("EnumU32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Collection", enumU32CollectionColumn);
+            enumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32CollectionColumn);
             var enumU64Column = new Column("EnumU64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64", enumU64Column);
+            enumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(enumU64Column);
             var enumU64ArrayColumn = new Column("EnumU64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Array", enumU64ArrayColumn);
+            enumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64ArrayColumn);
             var enumU64AsStringColumn = new Column("EnumU64AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsString", enumU64AsStringColumn);
+            enumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringColumn);
             var enumU64AsStringArrayColumn = new Column("EnumU64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringArray", enumU64AsStringArrayColumn);
+            enumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringArrayColumn);
             var enumU64AsStringCollectionColumn = new Column("EnumU64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringCollection", enumU64AsStringCollectionColumn);
+            enumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringCollectionColumn);
             var enumU64CollectionColumn = new Column("EnumU64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Collection", enumU64CollectionColumn);
+            enumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64CollectionColumn);
             var enumU64NestedCollectionColumn = new Column("EnumU64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64NestedCollection", enumU64NestedCollectionColumn);
+            enumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64NestedCollectionColumn);
             var enumU8Column = new Column("EnumU8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8", enumU8Column);
+            enumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(enumU8Column);
             var enumU8ArrayColumn = new Column("EnumU8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Array", enumU8ArrayColumn);
+            enumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8ArrayColumn);
             var enumU8AsStringColumn = new Column("EnumU8AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsString", enumU8AsStringColumn);
+            enumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringColumn);
             var enumU8AsStringArrayColumn = new Column("EnumU8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringArray", enumU8AsStringArrayColumn);
+            enumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringArrayColumn);
             var enumU8AsStringCollectionColumn = new Column("EnumU8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringCollection", enumU8AsStringCollectionColumn);
+            enumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringCollectionColumn);
             var enumU8CollectionColumn = new Column("EnumU8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Collection", enumU8CollectionColumn);
+            enumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8CollectionColumn);
             var floatColumn = new Column("Float", "REAL", manyTypesTable);
             manyTypesTable.Columns.Add("Float", floatColumn);
+            floatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(floatColumn);
             var floatArrayColumn = new Column("FloatArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
+            floatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(floatArrayColumn);
             var guidColumn = new Column("Guid", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Guid", guidColumn);
+            guidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(guidColumn);
             var guidArrayColumn = new Column("GuidArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
+            guidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidArrayColumn);
             var guidNestedCollectionColumn = new Column("GuidNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("GuidNestedCollection", guidNestedCollectionColumn);
+            guidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidNestedCollectionColumn);
             var guidToBytesConverterPropertyColumn = new Column("GuidToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToBytesConverterProperty", guidToBytesConverterPropertyColumn);
+            guidToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(guidToBytesConverterPropertyColumn);
             var guidToStringConverterPropertyColumn = new Column("GuidToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToStringConverterProperty", guidToStringConverterPropertyColumn);
+            guidToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidToStringConverterPropertyColumn);
             var iPAddressColumn = new Column("IPAddress", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
+            iPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressColumn);
             var iPAddressArrayColumn = new Column("IPAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
+            iPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressArrayColumn);
             var iPAddressToBytesConverterPropertyColumn = new Column("IPAddressToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToBytesConverterProperty", iPAddressToBytesConverterPropertyColumn);
+            iPAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(iPAddressToBytesConverterPropertyColumn);
             var iPAddressToStringConverterPropertyColumn = new Column("IPAddressToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToStringConverterProperty", iPAddressToStringConverterPropertyColumn);
+            iPAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressToStringConverterPropertyColumn);
             var int16Column = new Column("Int16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int16", int16Column);
+            int16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(int16Column);
             var int16ArrayColumn = new Column("Int16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
+            int16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int16ArrayColumn);
             var int32Column = new Column("Int32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int32", int32Column);
+            int32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(int32Column);
             var int32ArrayColumn = new Column("Int32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
+            int32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32ArrayColumn);
             var int32NestedCollectionColumn = new Column("Int32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int32NestedCollection", int32NestedCollectionColumn);
+            int32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32NestedCollectionColumn);
             var int64Column = new Column("Int64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int64", int64Column);
+            int64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(int64Column);
             var int64ArrayColumn = new Column("Int64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
+            int64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64ArrayColumn);
             var int64NestedCollectionColumn = new Column("Int64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int64NestedCollection", int64NestedCollectionColumn);
+            int64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64NestedCollectionColumn);
             var int8Column = new Column("Int8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int8", int8Column);
+            int8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(int8Column);
             var int8ArrayColumn = new Column("Int8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
+            int8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8ArrayColumn);
             var int8NestedCollectionColumn = new Column("Int8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int8NestedCollection", int8NestedCollectionColumn);
+            int8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8NestedCollectionColumn);
             var intNumberToBytesConverterPropertyColumn = new Column("IntNumberToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToBytesConverterProperty", intNumberToBytesConverterPropertyColumn);
+            intNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(intNumberToBytesConverterPropertyColumn);
             var intNumberToStringConverterPropertyColumn = new Column("IntNumberToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToStringConverterProperty", intNumberToStringConverterPropertyColumn);
+            intNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(intNumberToStringConverterPropertyColumn);
             var nullIntToNullStringConverterPropertyColumn = new Column("NullIntToNullStringConverterProperty", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullIntToNullStringConverterProperty", nullIntToNullStringConverterPropertyColumn);
+            nullIntToNullStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullIntToNullStringConverterPropertyColumn);
             var nullableBoolColumn = new Column("NullableBool", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
+            nullableBoolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(nullableBoolColumn);
             var nullableBoolArrayColumn = new Column("NullableBoolArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
+            nullableBoolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBoolArrayColumn);
             var nullableBytesColumn = new Column("NullableBytes", "BLOB", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
+            nullableBytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(nullableBytesColumn);
             var nullableBytesArrayColumn = new Column("NullableBytesArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
+            nullableBytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesArrayColumn);
             var nullableBytesNestedCollectionColumn = new Column("NullableBytesNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesNestedCollection", nullableBytesNestedCollectionColumn);
+            nullableBytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesNestedCollectionColumn);
             var nullableCharColumn = new Column("NullableChar", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
+            nullableCharColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<char>(nullableCharColumn);
             var nullableCharArrayColumn = new Column("NullableCharArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
+            nullableCharArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableCharArrayColumn);
             var nullableDateOnlyColumn = new Column("NullableDateOnly", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
+            nullableDateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(nullableDateOnlyColumn);
             var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
+            nullableDateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateOnlyArrayColumn);
             var nullableDateTimeColumn = new Column("NullableDateTime", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
+            nullableDateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(nullableDateTimeColumn);
             var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
+            nullableDateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateTimeArrayColumn);
             var nullableDecimalColumn = new Column("NullableDecimal", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
+            nullableDecimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableDecimalColumn);
             var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
+            nullableDecimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDecimalArrayColumn);
             var nullableDoubleColumn = new Column("NullableDouble", "REAL", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
+            nullableDoubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(nullableDoubleColumn);
             var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
+            nullableDoubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDoubleArrayColumn);
             var nullableEnum16Column = new Column("NullableEnum16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16", nullableEnum16Column);
+            nullableEnum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16Column);
             var nullableEnum16ArrayColumn = new Column("NullableEnum16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Array", nullableEnum16ArrayColumn);
+            nullableEnum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16ArrayColumn);
             var nullableEnum16AsStringColumn = new Column("NullableEnum16AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16AsString", nullableEnum16AsStringColumn);
+            nullableEnum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16AsStringColumn);
             var nullableEnum16AsStringArrayColumn = new Column("NullableEnum16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringArray", nullableEnum16AsStringArrayColumn);
+            nullableEnum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringArrayColumn);
             var nullableEnum16AsStringCollectionColumn = new Column("NullableEnum16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringCollection", nullableEnum16AsStringCollectionColumn);
+            nullableEnum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringCollectionColumn);
             var nullableEnum16CollectionColumn = new Column("NullableEnum16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Collection", nullableEnum16CollectionColumn);
+            nullableEnum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16CollectionColumn);
             var nullableEnum32Column = new Column("NullableEnum32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32", nullableEnum32Column);
+            nullableEnum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32Column);
             var nullableEnum32ArrayColumn = new Column("NullableEnum32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Array", nullableEnum32ArrayColumn);
+            nullableEnum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32ArrayColumn);
             var nullableEnum32AsStringColumn = new Column("NullableEnum32AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32AsString", nullableEnum32AsStringColumn);
+            nullableEnum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32AsStringColumn);
             var nullableEnum32AsStringArrayColumn = new Column("NullableEnum32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringArray", nullableEnum32AsStringArrayColumn);
+            nullableEnum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringArrayColumn);
             var nullableEnum32AsStringCollectionColumn = new Column("NullableEnum32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringCollection", nullableEnum32AsStringCollectionColumn);
+            nullableEnum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringCollectionColumn);
             var nullableEnum32CollectionColumn = new Column("NullableEnum32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Collection", nullableEnum32CollectionColumn);
+            nullableEnum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32CollectionColumn);
             var nullableEnum32NestedCollectionColumn = new Column("NullableEnum32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32NestedCollection", nullableEnum32NestedCollectionColumn);
+            nullableEnum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32NestedCollectionColumn);
             var nullableEnum64Column = new Column("NullableEnum64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64", nullableEnum64Column);
+            nullableEnum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64Column);
             var nullableEnum64ArrayColumn = new Column("NullableEnum64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Array", nullableEnum64ArrayColumn);
+            nullableEnum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64ArrayColumn);
             var nullableEnum64AsStringColumn = new Column("NullableEnum64AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64AsString", nullableEnum64AsStringColumn);
+            nullableEnum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64AsStringColumn);
             var nullableEnum64AsStringArrayColumn = new Column("NullableEnum64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringArray", nullableEnum64AsStringArrayColumn);
+            nullableEnum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringArrayColumn);
             var nullableEnum64AsStringCollectionColumn = new Column("NullableEnum64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringCollection", nullableEnum64AsStringCollectionColumn);
+            nullableEnum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringCollectionColumn);
             var nullableEnum64CollectionColumn = new Column("NullableEnum64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Collection", nullableEnum64CollectionColumn);
+            nullableEnum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64CollectionColumn);
             var nullableEnum8Column = new Column("NullableEnum8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8", nullableEnum8Column);
+            nullableEnum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(nullableEnum8Column);
             var nullableEnum8ArrayColumn = new Column("NullableEnum8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Array", nullableEnum8ArrayColumn);
+            nullableEnum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8ArrayColumn);
             var nullableEnum8AsStringColumn = new Column("NullableEnum8AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8AsString", nullableEnum8AsStringColumn);
+            nullableEnum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(nullableEnum8AsStringColumn);
             var nullableEnum8AsStringArrayColumn = new Column("NullableEnum8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringArray", nullableEnum8AsStringArrayColumn);
+            nullableEnum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringArrayColumn);
             var nullableEnum8AsStringCollectionColumn = new Column("NullableEnum8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringCollection", nullableEnum8AsStringCollectionColumn);
+            nullableEnum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringCollectionColumn);
             var nullableEnum8CollectionColumn = new Column("NullableEnum8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Collection", nullableEnum8CollectionColumn);
+            nullableEnum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8CollectionColumn);
             var nullableEnum8NestedCollectionColumn = new Column("NullableEnum8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8NestedCollection", nullableEnum8NestedCollectionColumn);
+            nullableEnum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8NestedCollectionColumn);
             var nullableEnumU16Column = new Column("NullableEnumU16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16", nullableEnumU16Column);
+            nullableEnumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(nullableEnumU16Column);
             var nullableEnumU16ArrayColumn = new Column("NullableEnumU16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Array", nullableEnumU16ArrayColumn);
+            nullableEnumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16ArrayColumn);
             var nullableEnumU16AsStringColumn = new Column("NullableEnumU16AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16AsString", nullableEnumU16AsStringColumn);
+            nullableEnumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(nullableEnumU16AsStringColumn);
             var nullableEnumU16AsStringArrayColumn = new Column("NullableEnumU16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringArray", nullableEnumU16AsStringArrayColumn);
+            nullableEnumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringArrayColumn);
             var nullableEnumU16AsStringCollectionColumn = new Column("NullableEnumU16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringCollection", nullableEnumU16AsStringCollectionColumn);
+            nullableEnumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringCollectionColumn);
             var nullableEnumU16CollectionColumn = new Column("NullableEnumU16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Collection", nullableEnumU16CollectionColumn);
+            nullableEnumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16CollectionColumn);
             var nullableEnumU32Column = new Column("NullableEnumU32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32", nullableEnumU32Column);
+            nullableEnumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(nullableEnumU32Column);
             var nullableEnumU32ArrayColumn = new Column("NullableEnumU32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Array", nullableEnumU32ArrayColumn);
+            nullableEnumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32ArrayColumn);
             var nullableEnumU32AsStringColumn = new Column("NullableEnumU32AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32AsString", nullableEnumU32AsStringColumn);
+            nullableEnumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(nullableEnumU32AsStringColumn);
             var nullableEnumU32AsStringArrayColumn = new Column("NullableEnumU32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringArray", nullableEnumU32AsStringArrayColumn);
+            nullableEnumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringArrayColumn);
             var nullableEnumU32AsStringCollectionColumn = new Column("NullableEnumU32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringCollection", nullableEnumU32AsStringCollectionColumn);
+            nullableEnumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringCollectionColumn);
             var nullableEnumU32CollectionColumn = new Column("NullableEnumU32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Collection", nullableEnumU32CollectionColumn);
+            nullableEnumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32CollectionColumn);
             var nullableEnumU64Column = new Column("NullableEnumU64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64", nullableEnumU64Column);
+            nullableEnumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(nullableEnumU64Column);
             var nullableEnumU64ArrayColumn = new Column("NullableEnumU64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Array", nullableEnumU64ArrayColumn);
+            nullableEnumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64ArrayColumn);
             var nullableEnumU64AsStringColumn = new Column("NullableEnumU64AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64AsString", nullableEnumU64AsStringColumn);
+            nullableEnumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(nullableEnumU64AsStringColumn);
             var nullableEnumU64AsStringArrayColumn = new Column("NullableEnumU64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringArray", nullableEnumU64AsStringArrayColumn);
+            nullableEnumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringArrayColumn);
             var nullableEnumU64AsStringCollectionColumn = new Column("NullableEnumU64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringCollection", nullableEnumU64AsStringCollectionColumn);
+            nullableEnumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringCollectionColumn);
             var nullableEnumU64CollectionColumn = new Column("NullableEnumU64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Collection", nullableEnumU64CollectionColumn);
+            nullableEnumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64CollectionColumn);
             var nullableEnumU64NestedCollectionColumn = new Column("NullableEnumU64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64NestedCollection", nullableEnumU64NestedCollectionColumn);
+            nullableEnumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64NestedCollectionColumn);
             var nullableEnumU8Column = new Column("NullableEnumU8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8", nullableEnumU8Column);
+            nullableEnumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8Column);
             var nullableEnumU8ArrayColumn = new Column("NullableEnumU8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Array", nullableEnumU8ArrayColumn);
+            nullableEnumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8ArrayColumn);
             var nullableEnumU8AsStringColumn = new Column("NullableEnumU8AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8AsString", nullableEnumU8AsStringColumn);
+            nullableEnumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8AsStringColumn);
             var nullableEnumU8AsStringArrayColumn = new Column("NullableEnumU8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringArray", nullableEnumU8AsStringArrayColumn);
+            nullableEnumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringArrayColumn);
             var nullableEnumU8AsStringCollectionColumn = new Column("NullableEnumU8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringCollection", nullableEnumU8AsStringCollectionColumn);
+            nullableEnumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringCollectionColumn);
             var nullableEnumU8CollectionColumn = new Column("NullableEnumU8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Collection", nullableEnumU8CollectionColumn);
+            nullableEnumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8CollectionColumn);
             var nullableFloatColumn = new Column("NullableFloat", "REAL", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
+            nullableFloatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(nullableFloatColumn);
             var nullableFloatArrayColumn = new Column("NullableFloatArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
+            nullableFloatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableFloatArrayColumn);
             var nullableGuidColumn = new Column("NullableGuid", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
+            nullableGuidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(nullableGuidColumn);
             var nullableGuidArrayColumn = new Column("NullableGuidArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
+            nullableGuidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidArrayColumn);
             var nullableGuidNestedCollectionColumn = new Column("NullableGuidNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidNestedCollection", nullableGuidNestedCollectionColumn);
+            nullableGuidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidNestedCollectionColumn);
             var nullableIPAddressColumn = new Column("NullableIPAddress", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
+            nullableIPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressColumn);
             var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
+            nullableIPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressArrayColumn);
             var nullableInt16Column = new Column("NullableInt16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
+            nullableInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableInt16Column);
             var nullableInt16ArrayColumn = new Column("NullableInt16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
+            nullableInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt16ArrayColumn);
             var nullableInt32Column = new Column("NullableInt32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
+            nullableInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableInt32Column);
             var nullableInt32ArrayColumn = new Column("NullableInt32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
+            nullableInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32ArrayColumn);
             var nullableInt32NestedCollectionColumn = new Column("NullableInt32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32NestedCollection", nullableInt32NestedCollectionColumn);
+            nullableInt32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32NestedCollectionColumn);
             var nullableInt64Column = new Column("NullableInt64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
+            nullableInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableInt64Column);
             var nullableInt64ArrayColumn = new Column("NullableInt64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
+            nullableInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64ArrayColumn);
             var nullableInt64NestedCollectionColumn = new Column("NullableInt64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64NestedCollection", nullableInt64NestedCollectionColumn);
+            nullableInt64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64NestedCollectionColumn);
             var nullableInt8Column = new Column("NullableInt8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
+            nullableInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(nullableInt8Column);
             var nullableInt8ArrayColumn = new Column("NullableInt8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
+            nullableInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt8ArrayColumn);
             var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
+            nullablePhysicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressColumn);
             var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
+            nullablePhysicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressArrayColumn);
             var nullablePhysicalAddressNestedCollectionColumn = new Column("NullablePhysicalAddressNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressNestedCollection", nullablePhysicalAddressNestedCollectionColumn);
+            nullablePhysicalAddressNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressNestedCollectionColumn);
             var nullableStringColumn = new Column("NullableString", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
+            nullableStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringColumn);
             var nullableStringArrayColumn = new Column("NullableStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
+            nullableStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringArrayColumn);
             var nullableStringNestedCollectionColumn = new Column("NullableStringNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringNestedCollection", nullableStringNestedCollectionColumn);
+            nullableStringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringNestedCollectionColumn);
             var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
+            nullableTimeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(nullableTimeOnlyColumn);
             var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
+            nullableTimeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeOnlyArrayColumn);
             var nullableTimeSpanColumn = new Column("NullableTimeSpan", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
+            nullableTimeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(nullableTimeSpanColumn);
             var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
+            nullableTimeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeSpanArrayColumn);
             var nullableUInt16Column = new Column("NullableUInt16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
+            nullableUInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(nullableUInt16Column);
             var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
+            nullableUInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt16ArrayColumn);
             var nullableUInt32Column = new Column("NullableUInt32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
+            nullableUInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(nullableUInt32Column);
             var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
+            nullableUInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt32ArrayColumn);
             var nullableUInt64Column = new Column("NullableUInt64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
+            nullableUInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(nullableUInt64Column);
             var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
+            nullableUInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt64ArrayColumn);
             var nullableUInt8Column = new Column("NullableUInt8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
+            nullableUInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableUInt8Column);
             var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
+            nullableUInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8ArrayColumn);
             var nullableUInt8NestedCollectionColumn = new Column("NullableUInt8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8NestedCollection", nullableUInt8NestedCollectionColumn);
+            nullableUInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8NestedCollectionColumn);
             var nullableUriColumn = new Column("NullableUri", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
+            nullableUriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriColumn);
             var nullableUriArrayColumn = new Column("NullableUriArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
+            nullableUriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriArrayColumn);
             var physicalAddressColumn = new Column("PhysicalAddress", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
+            physicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressColumn);
             var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
+            physicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressArrayColumn);
             var physicalAddressToBytesConverterPropertyColumn = new Column("PhysicalAddressToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToBytesConverterProperty", physicalAddressToBytesConverterPropertyColumn);
+            physicalAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(physicalAddressToBytesConverterPropertyColumn);
             var physicalAddressToStringConverterPropertyColumn = new Column("PhysicalAddressToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToStringConverterProperty", physicalAddressToStringConverterPropertyColumn);
+            physicalAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressToStringConverterPropertyColumn);
             var stringColumn = new Column("String", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("String", stringColumn);
+            stringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringColumn);
             var stringArrayColumn = new Column("StringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
+            stringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringArrayColumn);
             var stringNestedCollectionColumn = new Column("StringNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringNestedCollection", stringNestedCollectionColumn);
+            stringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringNestedCollectionColumn);
             var stringToBoolConverterPropertyColumn = new Column("StringToBoolConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("StringToBoolConverterProperty", stringToBoolConverterPropertyColumn);
+            stringToBoolConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(stringToBoolConverterPropertyColumn);
             var stringToBytesConverterPropertyColumn = new Column("StringToBytesConverterProperty", "BLOB", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("StringToBytesConverterProperty", stringToBytesConverterPropertyColumn);
+            stringToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(stringToBytesConverterPropertyColumn);
             var stringToCharConverterPropertyColumn = new Column("StringToCharConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToCharConverterProperty", stringToCharConverterPropertyColumn);
+            stringToCharConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<char>(stringToCharConverterPropertyColumn);
             var stringToDateOnlyConverterPropertyColumn = new Column("StringToDateOnlyConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateOnlyConverterProperty", stringToDateOnlyConverterPropertyColumn);
+            stringToDateOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(stringToDateOnlyConverterPropertyColumn);
             var stringToDateTimeConverterPropertyColumn = new Column("StringToDateTimeConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeConverterProperty", stringToDateTimeConverterPropertyColumn);
+            stringToDateTimeConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(stringToDateTimeConverterPropertyColumn);
             var stringToDateTimeOffsetConverterPropertyColumn = new Column("StringToDateTimeOffsetConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeOffsetConverterProperty", stringToDateTimeOffsetConverterPropertyColumn);
+            stringToDateTimeOffsetConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTimeOffset>(stringToDateTimeOffsetConverterPropertyColumn);
             var stringToDecimalNumberConverterPropertyColumn = new Column("StringToDecimalNumberConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDecimalNumberConverterProperty", stringToDecimalNumberConverterPropertyColumn);
+            stringToDecimalNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(stringToDecimalNumberConverterPropertyColumn);
             var stringToDoubleNumberConverterPropertyColumn = new Column("StringToDoubleNumberConverterProperty", "REAL", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDoubleNumberConverterProperty", stringToDoubleNumberConverterPropertyColumn);
+            stringToDoubleNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(stringToDoubleNumberConverterPropertyColumn);
             var stringToEnumConverterPropertyColumn = new Column("StringToEnumConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("StringToEnumConverterProperty", stringToEnumConverterPropertyColumn);
+            stringToEnumConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(stringToEnumConverterPropertyColumn);
             var stringToGuidConverterPropertyColumn = new Column("StringToGuidConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToGuidConverterProperty", stringToGuidConverterPropertyColumn);
+            stringToGuidConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToGuidConverterPropertyColumn);
             var stringToIntNumberConverterPropertyColumn = new Column("StringToIntNumberConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("StringToIntNumberConverterProperty", stringToIntNumberConverterPropertyColumn);
+            stringToIntNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(stringToIntNumberConverterPropertyColumn);
             var stringToTimeOnlyConverterPropertyColumn = new Column("StringToTimeOnlyConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeOnlyConverterProperty", stringToTimeOnlyConverterPropertyColumn);
+            stringToTimeOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(stringToTimeOnlyConverterPropertyColumn);
             var stringToTimeSpanConverterPropertyColumn = new Column("StringToTimeSpanConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeSpanConverterProperty", stringToTimeSpanConverterPropertyColumn);
+            stringToTimeSpanConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(stringToTimeSpanConverterPropertyColumn);
             var stringToUriConverterPropertyColumn = new Column("StringToUriConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToUriConverterProperty", stringToUriConverterPropertyColumn);
+            stringToUriConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToUriConverterPropertyColumn);
             var timeOnlyColumn = new Column("TimeOnly", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
+            timeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(timeOnlyColumn);
             var timeOnlyArrayColumn = new Column("TimeOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
+            timeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyArrayColumn);
             var timeOnlyToStringConverterPropertyColumn = new Column("TimeOnlyToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToStringConverterProperty", timeOnlyToStringConverterPropertyColumn);
+            timeOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyToStringConverterPropertyColumn);
             var timeOnlyToTicksConverterPropertyColumn = new Column("TimeOnlyToTicksConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToTicksConverterProperty", timeOnlyToTicksConverterPropertyColumn);
+            timeOnlyToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeOnlyToTicksConverterPropertyColumn);
             var timeSpanColumn = new Column("TimeSpan", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
+            timeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(timeSpanColumn);
             var timeSpanArrayColumn = new Column("TimeSpanArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
+            timeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanArrayColumn);
             var timeSpanToStringConverterPropertyColumn = new Column("TimeSpanToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToStringConverterProperty", timeSpanToStringConverterPropertyColumn);
+            timeSpanToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanToStringConverterPropertyColumn);
             var timeSpanToTicksConverterPropertyColumn = new Column("TimeSpanToTicksConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToTicksConverterProperty", timeSpanToTicksConverterPropertyColumn);
+            timeSpanToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeSpanToTicksConverterPropertyColumn);
             var uInt16Column = new Column("UInt16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16", uInt16Column);
+            uInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(uInt16Column);
             var uInt16ArrayColumn = new Column("UInt16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
+            uInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt16ArrayColumn);
             var uInt32Column = new Column("UInt32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32", uInt32Column);
+            uInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(uInt32Column);
             var uInt32ArrayColumn = new Column("UInt32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
+            uInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt32ArrayColumn);
             var uInt64Column = new Column("UInt64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64", uInt64Column);
+            uInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(uInt64Column);
             var uInt64ArrayColumn = new Column("UInt64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
+            uInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt64ArrayColumn);
             var uInt8Column = new Column("UInt8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8", uInt8Column);
+            uInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(uInt8Column);
             var uInt8ArrayColumn = new Column("UInt8Array", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
+            uInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(uInt8ArrayColumn);
             var uInt8NestedCollectionColumn = new Column("UInt8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8NestedCollection", uInt8NestedCollectionColumn);
+            uInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt8NestedCollectionColumn);
             var uriColumn = new Column("Uri", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Uri", uriColumn);
+            uriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriColumn);
             var uriArrayColumn = new Column("UriArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
+            uriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriArrayColumn);
             var uriToStringConverterPropertyColumn = new Column("UriToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UriToStringConverterProperty", uriToStringConverterPropertyColumn);
-            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn1 });
-            manyTypesTable.PrimaryKey = pK_ManyTypes;
-            var pK_ManyTypesKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
-                new[] { "Id" });
-            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
-            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
+            uriToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriToStringConverterPropertyColumn);
             relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
             var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, null);
             manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
@@ -2051,6 +2315,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriToStringConverterPropertyColumn, manyTypes.FindProperty("UriToStringConverterProperty")!, manyTypesTableMapping);
+            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn1 });
+            manyTypesTable.PrimaryKey = pK_ManyTypes;
+            pK_ManyTypes.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_ManyTypes));
+            var pK_ManyTypesKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
+                new[] { "Id" });
+            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
+            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
 
             var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase")!;
 
@@ -2142,134 +2415,130 @@ private IRelationalModel CreateRelationalModel()
             var principalBaseTable = new Table("PrincipalBase", "mySchema", relationalModel);
             var idColumn2 = new Column("Id", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("Id", idColumn2);
+            idColumn2.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(idColumn2);
             var alternateIdColumn = new Column("AlternateId", "TEXT", principalBaseTable);
             principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
+            alternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(alternateIdColumn);
             var enum1Column = new Column("Enum1", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("Enum1", enum1Column);
+            enum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum1Column);
             var enum2Column = new Column("Enum2", "INTEGER", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Enum2", enum2Column);
+            enum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum2Column);
             var flagsEnum1Column = new Column("FlagsEnum1", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
+            flagsEnum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum1Column);
             var flagsEnum2Column = new Column("FlagsEnum2", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
+            flagsEnum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum2Column);
             var owned_NumberColumn = new Column("Owned_Number", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("Owned_Number", owned_NumberColumn);
+            owned_NumberColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(owned_NumberColumn);
             var owned_RefTypeArrayColumn = new Column("Owned_RefTypeArray", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeArray", owned_RefTypeArrayColumn);
+            owned_RefTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeArrayColumn);
             var owned_RefTypeEnumerableColumn = new Column("Owned_RefTypeEnumerable", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeEnumerable", owned_RefTypeEnumerableColumn);
+            owned_RefTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeEnumerableColumn);
             var owned_RefTypeIListColumn = new Column("Owned_RefTypeIList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeIList", owned_RefTypeIListColumn);
+            owned_RefTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeIListColumn);
             var owned_RefTypeListColumn = new Column("Owned_RefTypeList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_RefTypeList", owned_RefTypeListColumn);
+            owned_RefTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_RefTypeListColumn);
             var owned_ValueTypeArrayColumn = new Column("Owned_ValueTypeArray", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeArray", owned_ValueTypeArrayColumn);
+            owned_ValueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeArrayColumn);
             var owned_ValueTypeEnumerableColumn = new Column("Owned_ValueTypeEnumerable", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeEnumerable", owned_ValueTypeEnumerableColumn);
+            owned_ValueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeEnumerableColumn);
             var owned_ValueTypeIListColumn = new Column("Owned_ValueTypeIList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeIList", owned_ValueTypeIListColumn);
+            owned_ValueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeIListColumn);
             var owned_ValueTypeListColumn = new Column("Owned_ValueTypeList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Owned_ValueTypeList", owned_ValueTypeListColumn);
+            owned_ValueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(owned_ValueTypeListColumn);
             var pointColumn0 = new Column("Point", "geometry", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Point", pointColumn0);
+            pointColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<Point>(pointColumn0);
             var refTypeArrayColumn = new Column("RefTypeArray", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
+            refTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn);
             var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
+            refTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn);
             var refTypeIListColumn = new Column("RefTypeIList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
+            refTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn);
             var refTypeListColumn = new Column("RefTypeList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
+            refTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn);
             var valueTypeArrayColumn = new Column("ValueTypeArray", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
+            valueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn);
             var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
+            valueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn);
             var valueTypeIListColumn = new Column("ValueTypeIList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
+            valueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn);
             var valueTypeListColumn = new Column("ValueTypeList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
-            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn2 });
-            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id" });
-            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
-            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
-            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
-            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn2, alternateIdColumn });
-            principalBaseTable.PrimaryKey = pK;
-            var pKKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id", "AlternateId" });
-            pK.MappedKeys.Add(pKKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
-            var pKKey0 = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType",
-                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
-            pK.MappedKeys.Add(pKKey0);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey0).Add(pK);
-            principalBaseTable.UniqueConstraints.Add("PK", pK);
-            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
-            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn2 }, false);
-            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "AlternateId", "Id" });
-            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
-            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
+            valueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn);
             relationalModel.Tables.Add(("PrincipalBase", "mySchema"), principalBaseTable);
             var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
             {
@@ -2394,18 +2663,16 @@ private IRelationalModel CreateRelationalModel()
             var detailsTable = new Table("Details", null, relationalModel);
             var principalBaseIdColumn = new Column("PrincipalBaseId", "INTEGER", detailsTable);
             detailsTable.Columns.Add("PrincipalBaseId", principalBaseIdColumn);
+            principalBaseIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalBaseIdColumn);
             var principalBaseAlternateIdColumn = new Column("PrincipalBaseAlternateId", "TEXT", detailsTable);
             detailsTable.Columns.Add("PrincipalBaseAlternateId", principalBaseAlternateIdColumn);
+            principalBaseAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalBaseAlternateIdColumn);
             var detailsColumn = new Column("Details", "TEXT", detailsTable)
             {
                 IsNullable = true
             };
             detailsTable.Columns.Add("Details", detailsColumn);
-            var pK_Details = new UniqueConstraint("PK_Details", detailsTable, new[] { principalBaseIdColumn, principalBaseAlternateIdColumn });
-            detailsTable.PrimaryKey = pK_Details;
-            pK_Details.MappedKeys.Add(pKKey0);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey0).Add(pK_Details);
-            detailsTable.UniqueConstraints.Add("PK_Details", pK_Details);
+            detailsColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(detailsColumn);
             relationalModel.Tables.Add(("Details", null), detailsTable);
             var detailsTableMapping = new TableMapping(ownedType, detailsTable, null)
             {
@@ -2416,6 +2683,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(principalBaseAlternateIdColumn, ownedType.FindProperty("PrincipalBaseAlternateId")!, detailsTableMapping);
             RelationalModel.CreateColumnMapping(principalBaseIdColumn, ownedType.FindProperty("PrincipalBaseId")!, detailsTableMapping);
             RelationalModel.CreateColumnMapping(detailsColumn, ownedType.FindProperty("Details")!, detailsTableMapping);
+            var pK_Details = new UniqueConstraint("PK_Details", detailsTable, new[] { principalBaseIdColumn, principalBaseAlternateIdColumn });
+            detailsTable.PrimaryKey = pK_Details;
+            pK_Details.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_Details));
+            var pK_DetailsKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType",
+                new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" });
+            pK_Details.MappedKeys.Add(pK_DetailsKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DetailsKey).Add(pK_Details);
+            detailsTable.UniqueConstraints.Add("PK_Details", pK_Details);
 
             var principalDerived = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>")!;
 
@@ -2474,31 +2750,64 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn, principalDerived.FindProperty("ValueTypeEnumerable")!, principalBaseTableMapping1);
             RelationalModel.CreateColumnMapping(valueTypeIListColumn, principalDerived.FindProperty("ValueTypeIList")!, principalBaseTableMapping1);
             RelationalModel.CreateColumnMapping(valueTypeListColumn, principalDerived.FindProperty("ValueTypeList")!, principalBaseTableMapping1);
+            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn2 });
+            aK_PrincipalBase_Id.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(aK_PrincipalBase_Id));
+            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id" });
+            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
+            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
+            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
+            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn2, alternateIdColumn });
+            principalBaseTable.PrimaryKey = pK;
+            pK.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK));
+            var pKKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id", "AlternateId" });
+            pK.MappedKeys.Add(pKKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
+            pK.MappedKeys.Add(pK_DetailsKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DetailsKey).Add(pK);
+            principalBaseTable.UniqueConstraints.Add("PK", pK);
+            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
+            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn2 }, false);
+            iX_PrincipalBase_AlternateId_Id.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBase_AlternateId_Id));
+            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "AlternateId", "Id" });
+            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
+            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
             var principalDerivedTable = new Table("PrincipalDerived", null, relationalModel);
             var derivedIdColumn = new Column("DerivedId", "INTEGER", principalDerivedTable);
             principalDerivedTable.Columns.Add("DerivedId", derivedIdColumn);
+            derivedIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(derivedIdColumn);
             var alternateIdColumn0 = new Column("AlternateId", "TEXT", principalDerivedTable);
             principalDerivedTable.Columns.Add("AlternateId", alternateIdColumn0);
+            alternateIdColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(alternateIdColumn0);
+            relationalModel.Tables.Add(("PrincipalDerived", null), principalDerivedTable);
+            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, null);
+            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
+            tableMappings5.Add(principalDerivedTableMapping);
+            RelationalModel.CreateColumnMapping(alternateIdColumn0, principalDerived.FindProperty("AlternateId")!, principalDerivedTableMapping);
+            RelationalModel.CreateColumnMapping(derivedIdColumn, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);
             var aK_PrincipalDerived_DerivedId = new UniqueConstraint("AK_PrincipalDerived_DerivedId", principalDerivedTable, new[] { derivedIdColumn });
+            aK_PrincipalDerived_DerivedId.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(aK_PrincipalDerived_DerivedId));
             aK_PrincipalDerived_DerivedId.MappedKeys.Add(aK_PrincipalBase_IdKey);
             RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalDerived_DerivedId);
             principalDerivedTable.UniqueConstraints.Add("AK_PrincipalDerived_DerivedId", aK_PrincipalDerived_DerivedId);
             var pK0 = new UniqueConstraint("PK", principalDerivedTable, new[] { derivedIdColumn, alternateIdColumn0 });
             principalDerivedTable.PrimaryKey = pK0;
+            pK0.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK0));
             pK0.MappedKeys.Add(pKKey);
             RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK0);
             principalDerivedTable.UniqueConstraints.Add("PK", pK0);
             var iX_PrincipalDerived_AlternateId_DerivedId = new TableIndex(
             "IX_PrincipalDerived_AlternateId_DerivedId", principalDerivedTable, new[] { alternateIdColumn0, derivedIdColumn }, false);
+            iX_PrincipalDerived_AlternateId_DerivedId.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalDerived_AlternateId_DerivedId));
             iX_PrincipalDerived_AlternateId_DerivedId.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
             RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalDerived_AlternateId_DerivedId);
             principalDerivedTable.Indexes.Add("IX_PrincipalDerived_AlternateId_DerivedId", iX_PrincipalDerived_AlternateId_DerivedId);
-            relationalModel.Tables.Add(("PrincipalDerived", null), principalDerivedTable);
-            var principalDerivedTableMapping = new TableMapping(principalDerived, principalDerivedTable, null);
-            principalDerivedTable.AddTypeMapping(principalDerivedTableMapping, false);
-            tableMappings5.Add(principalDerivedTableMapping);
-            RelationalModel.CreateColumnMapping(alternateIdColumn0, principalDerived.FindProperty("AlternateId")!, principalDerivedTableMapping);
-            RelationalModel.CreateColumnMapping(derivedIdColumn, principalDerived.FindProperty("Id")!, principalDerivedTableMapping);
 
             var ownedType0 = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType")!;
 
@@ -2581,65 +2890,70 @@ private IRelationalModel CreateRelationalModel()
             var manyOwnedTable = new Table("ManyOwned", null, relationalModel);
             var principalDerivedDependentBasebyteIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>Id", "INTEGER", manyOwnedTable);
             manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>Id", principalDerivedDependentBasebyteIdColumn);
+            principalDerivedDependentBasebyteIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalDerivedDependentBasebyteIdColumn);
             var principalDerivedDependentBasebyteAlternateIdColumn = new Column("PrincipalDerived<DependentBase<byte?>>AlternateId", "TEXT", manyOwnedTable);
             manyOwnedTable.Columns.Add("PrincipalDerived<DependentBase<byte?>>AlternateId", principalDerivedDependentBasebyteAlternateIdColumn);
+            principalDerivedDependentBasebyteAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalDerivedDependentBasebyteAlternateIdColumn);
             var idColumn3 = new Column("Id", "INTEGER", manyOwnedTable);
             manyOwnedTable.Columns.Add("Id", idColumn3);
+            idColumn3.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn3);
             var detailsColumn0 = new Column("Details", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("Details", detailsColumn0);
+            detailsColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(detailsColumn0);
             var numberColumn = new Column("Number", "INTEGER", manyOwnedTable);
             manyOwnedTable.Columns.Add("Number", numberColumn);
+            numberColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(numberColumn);
             var refTypeArrayColumn0 = new Column("RefTypeArray", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeArray", refTypeArrayColumn0);
+            refTypeArrayColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn0);
             var refTypeEnumerableColumn0 = new Column("RefTypeEnumerable", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn0);
+            refTypeEnumerableColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn0);
             var refTypeIListColumn0 = new Column("RefTypeIList", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeIList", refTypeIListColumn0);
+            refTypeIListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn0);
             var refTypeListColumn0 = new Column("RefTypeList", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("RefTypeList", refTypeListColumn0);
+            refTypeListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn0);
             var valueTypeArrayColumn0 = new Column("ValueTypeArray", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn0);
+            valueTypeArrayColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn0);
             var valueTypeEnumerableColumn0 = new Column("ValueTypeEnumerable", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn0);
+            valueTypeEnumerableColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn0);
             var valueTypeIListColumn0 = new Column("ValueTypeIList", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeIList", valueTypeIListColumn0);
+            valueTypeIListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn0);
             var valueTypeListColumn0 = new Column("ValueTypeList", "TEXT", manyOwnedTable)
             {
                 IsNullable = true
             };
             manyOwnedTable.Columns.Add("ValueTypeList", valueTypeListColumn0);
-            var pK_ManyOwned = new UniqueConstraint("PK_ManyOwned", manyOwnedTable, new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn, idColumn3 });
-            manyOwnedTable.PrimaryKey = pK_ManyOwned;
-            var pK_ManyOwnedKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType",
-                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId", "Id" });
-            pK_ManyOwned.MappedKeys.Add(pK_ManyOwnedKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyOwnedKey).Add(pK_ManyOwned);
-            manyOwnedTable.UniqueConstraints.Add("PK_ManyOwned", pK_ManyOwned);
+            valueTypeListColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn0);
             relationalModel.Tables.Add(("ManyOwned", null), manyOwnedTable);
             var manyOwnedTableMapping = new TableMapping(ownedType0, manyOwnedTable, null);
             manyOwnedTable.AddTypeMapping(manyOwnedTableMapping, false);
@@ -2657,6 +2971,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(valueTypeEnumerableColumn0, ownedType0.FindProperty("ValueTypeEnumerable")!, manyOwnedTableMapping);
             RelationalModel.CreateColumnMapping(valueTypeIListColumn0, ownedType0.FindProperty("ValueTypeIList")!, manyOwnedTableMapping);
             RelationalModel.CreateColumnMapping(valueTypeListColumn0, ownedType0.FindProperty("ValueTypeList")!, manyOwnedTableMapping);
+            var pK_ManyOwned = new UniqueConstraint("PK_ManyOwned", manyOwnedTable, new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn, idColumn3 });
+            manyOwnedTable.PrimaryKey = pK_ManyOwned;
+            pK_ManyOwned.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_ManyOwned));
+            var pK_ManyOwnedKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType",
+                new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId", "Id" });
+            pK_ManyOwned.MappedKeys.Add(pK_ManyOwnedKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyOwnedKey).Add(pK_ManyOwned);
+            manyOwnedTable.UniqueConstraints.Add("PK_ManyOwned", pK_ManyOwned);
 
             var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;
 
@@ -2691,19 +3014,34 @@ private IRelationalModel CreateRelationalModel()
             var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
             var derivedsIdColumn = new Column("DerivedsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
+            derivedsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(derivedsIdColumn);
             var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
+            derivedsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(derivedsAlternateIdColumn);
             var principalsIdColumn = new Column("PrincipalsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
+            principalsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalsIdColumn);
             var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
+            principalsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalsAlternateIdColumn);
             var rowidColumn = new Column("rowid", "BLOB", principalBasePrincipalDerivedDependentBasebyteTable)
             {
                 IsNullable = true
             };
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
+            rowidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(rowidColumn);
+            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
+            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
+            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
+            tableMappings7.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
             principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
+            pK_PrincipalBasePrincipalDerivedDependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_PrincipalBasePrincipalDerivedDependentBasebyte));
             var pK_PrincipalBasePrincipalDerivedDependentBasebyteKey = RelationalModel.GetKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
@@ -2712,25 +3050,18 @@ private IRelationalModel CreateRelationalModel()
             principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
             "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
+            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId));
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" });
             iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
             RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
             principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
-            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
-            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
-            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
-            tableMappings7.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                 "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                 new[] { principalIdColumn },
                 principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
+            fK_DependentBasebyte_PrincipalBase_PrincipalId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_DependentBasebyte_PrincipalBase_PrincipalId));
             var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId" },
@@ -2744,6 +3075,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_DependentBase<byte?>_PrincipalDerived_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalDerivedTable,
                 new[] { principalIdColumn, principalAlternateIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
+            fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateId));
             var fK_DependentBasebyte_PrincipalDerived_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId", "PrincipalAlternateId" },
@@ -2757,6 +3089,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId", detailsTable, principalBaseTable,
                 new[] { principalBaseIdColumn, principalBaseAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateId));
             var fK_Details_PrincipalBase_PrincipalBaseId_PrincipalBaseAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase.Owned#OwnedType",
                 new[] { "PrincipalBaseId", "PrincipalBaseAlternateId" },
@@ -2770,6 +3103,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_ManyOwned_PrincipalDerived_PrincipalDerived<DependentBase<byte?>>Id_PrincipalDerived<DependentBase<byte?>>AlternateId", manyOwnedTable, principalDerivedTable,
                 new[] { principalDerivedDependentBasebyteIdColumn, principalDerivedDependentBasebyteAlternateIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateId));
             var fK_ManyOwned_PrincipalDerived_PrincipalDerivedDependentBasebyteId_PrincipalDerivedDependentBasebyteAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>.ManyOwned#OwnedType",
                 new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
@@ -2783,6 +3117,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                 new[] { principalsIdColumn, principalsAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" },
@@ -2796,6 +3131,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalDerived_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalDerivedTable,
                 new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                 principalDerivedTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalDerived_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId" },
@@ -2809,6 +3145,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId", principalDerivedTable, principalBaseTable,
                 new[] { derivedIdColumn, alternateIdColumn0 },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateId));
             var fK_PrincipalDerived_PrincipalBase_DerivedId_AlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>",
                 new[] { "Id", "AlternateId" },
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
index ac6e3a3d9a..fed8607aef 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentBaseEntityType.cs
@@ -44,6 +44,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -72,6 +78,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -86,6 +98,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum1),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            enumDiscriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum1>(enumDiscriminator, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum1>(enumDiscriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             enumDiscriminator.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -203,17 +221,17 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             principal.SetGetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
             principal.SetSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetMaterializationSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetAccessors(
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>>(principal),
                 null);
@@ -223,6 +241,7 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            principal.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal", "TestNamespace") });
             var dependent = principalEntityType.AddNavigation("Dependent",
                 runtimeForeignKey,
                 onDependent: false,
@@ -263,7 +282,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var enumDiscriminator = runtimeEntityType.FindProperty("EnumDiscriminator")!;
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { principalId, principalAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             var principal = runtimeEntityType.FindNavigation("Principal")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
index 024698d8e4..e234c20e6f 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/DependentDerivedEntityType.cs
@@ -69,6 +69,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 precision: 9,
                 scale: 3,
                 sentinel: 0m);
+            money.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(money, 5),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(money),
+                (ValueBuffer valueBuffer) => valueBuffer[5]);
             money.SetPropertyIndexes(
                 index: 5,
                 originalValueIndex: 5,
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
index 45a0e6bdbb..849e4e248b 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/ManyTypesEntityType.cs
@@ -15805,7 +15805,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var uriArray = runtimeEntityType.FindProperty("UriArray")!;
             var uriToStringConverterProperty = runtimeEntityType.FindProperty("UriToStringConverterProperty")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<CompiledModelTestBase.ManyTypesId>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<CompiledModelTestBase.ManyTypesId>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<CompiledModelTestBase.ManyTypesId>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
index 569f6adbd3..f7988939e9 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedType0EntityType.cs
@@ -42,6 +42,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalDerivedId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalDerivedId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalDerivedId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalDerivedId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -70,6 +76,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalDerivedAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalDerivedAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalDerivedAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalDerivedAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -85,6 +97,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(2) ? entry.ReadStoreGeneratedValue<int>(2) : entry.FlaggedAsTemporary(2) && entry.ReadShadowValue<int>(2) == 0 ? entry.ReadTemporaryValue<int>(2) : entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 2),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 2),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             id.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -740,7 +758,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalDerivedId, principalDerivedAlternateId, id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
index 0cb3fa819f..7f3848c7b6 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/OwnedTypeEntityType.cs
@@ -44,6 +44,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalBaseId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalBaseId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalBaseId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalBaseId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -83,6 +89,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalBaseAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalBaseAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalBaseAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalBaseAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -755,7 +767,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalBaseId, principalBaseAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
index e988b1d900..9f805b594c 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBaseEntityType.cs
@@ -348,6 +348,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueConverter: new CastingConverter<Point, Point>(),
                 valueComparer: new CompiledModelTestBase.CustomValueComparer<Point>(),
                 providerValueComparer: new CompiledModelTestBase.CustomValueComparer<Point>());
+            point.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(6) ? entry.ReadStoreGeneratedValue<Point>(2) : entry.FlaggedAsTemporary(6) && entry.ReadShadowValue<Point>(0) == null ? entry.ReadTemporaryValue<Point>(2) : entry.ReadShadowValue<Point>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Point>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Point>(point, 6),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<Point>(point),
+                (ValueBuffer valueBuffer) => valueBuffer[6]);
             point.SetPropertyIndexes(
                 index: 6,
                 originalValueIndex: 6,
@@ -921,10 +927,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var key0 = runtimeEntityType.FindKey(new[] { id, alternateId });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key0));
             var owned = runtimeEntityType.FindNavigation("Owned")!;
             runtimeEntityType.SetOriginalValuesFactory(
@@ -1010,10 +1016,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeList>k__BackingField")]
         public static extern ref List<short> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_ValueTypeList(CompiledModelTestBase.PrincipalBase @this);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_ownedField")]
         public static extern ref CompiledModelTestBase.OwnedType UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase__ownedField(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
     }
 }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
index 189a57b733..c04d9f0141 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
@@ -359,7 +359,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var principalsAlternateId = runtimeEntityType.FindProperty("PrincipalsAlternateId")!;
             var rowid = runtimeEntityType.FindProperty("rowid")!;
             var key = runtimeEntityType.FindKey(new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
index 2b8ac46007..413b6a9e95 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel/PrincipalDerivedEntityType.cs
@@ -161,13 +161,13 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
 
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Dependent>k__BackingField")]
         public static extern ref CompiledModelTestBase.DependentBase<byte?> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Dependent(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "ManyOwned")]
         public static extern ref ICollection<CompiledModelTestBase.OwnedType> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_ManyOwned(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
     }
 }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DataEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DataEntityType.cs
index 60423e36a2..0fcded4aa9 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DataEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DataEntityType.cs
@@ -38,6 +38,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -107,6 +113,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 "Point",
                 typeof(Point),
                 nullable: true);
+            point.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Point>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Point>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Point>(point, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<Point>(point),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             point.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -128,7 +140,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var point = runtimeEntityType.FindProperty("Point")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
index adb08e8fde..1e536c4f00 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DbContextModelBuilder.cs
@@ -1,11 +1,14 @@
 // <auto-generated />
 using System;
 using System.Collections.Generic;
+using System.Text.Json;
 using Microsoft.EntityFrameworkCore;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
 using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Update.Internal;
+using NetTopologySuite.Geometries;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -88,31 +91,35 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "INTEGER", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "BLOB", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
             var pointColumn = new Column("Point", "POINT", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Point", pointColumn);
+            pointColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Point>(pointColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(pointColumn, data.FindProperty("Point")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(pointColumn, data.FindProperty("Point")!, dataTableMapping);
 
             var dependentBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>")!;
 
@@ -154,41 +161,31 @@ private IRelationalModel CreateRelationalModel()
             var dependentBasebyteTable = new Table("DependentBase<byte?>", null, relationalModel);
             var principalIdColumn = new Column("PrincipalId", "INTEGER", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalId", principalIdColumn);
+            principalIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalIdColumn);
             var principalAlternateIdColumn = new Column("PrincipalAlternateId", "TEXT", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("PrincipalAlternateId", principalAlternateIdColumn);
+            principalAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalAlternateIdColumn);
             var dataColumn = new Column("Data", "TEXT", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Data", dataColumn);
+            dataColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dataColumn);
             var enumDiscriminatorColumn = new Column("EnumDiscriminator", "INTEGER", dependentBasebyteTable);
             dependentBasebyteTable.Columns.Add("EnumDiscriminator", enumDiscriminatorColumn);
+            enumDiscriminatorColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumDiscriminatorColumn);
             var idColumn0 = new Column("Id", "INTEGER", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Id", idColumn0);
+            idColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(idColumn0);
             var moneyColumn = new Column("Money", "TEXT", dependentBasebyteTable)
             {
                 IsNullable = true
             };
             dependentBasebyteTable.Columns.Add("Money", moneyColumn);
-            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
-            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
-            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId", "PrincipalAlternateId" });
-            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
-            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
-            var iX_DependentBasebyte_PrincipalId = new TableIndex(
-            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
-            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
-                new[] { "PrincipalId" });
-            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
-            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
+            moneyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(moneyColumn);
             relationalModel.Tables.Add(("DependentBase<byte?>", null), dependentBasebyteTable);
             var dependentBasebyteTableMapping = new TableMapping(dependentBase, dependentBasebyteTable, true)
             {
@@ -229,6 +226,24 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(enumDiscriminatorColumn, dependentDerived.FindProperty("EnumDiscriminator")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(idColumn0, dependentDerived.FindProperty("Id")!, dependentBasebyteTableMapping0);
             RelationalModel.CreateColumnMapping(moneyColumn, dependentDerived.FindProperty("Money")!, dependentBasebyteTableMapping0);
+            var pK_DependentBasebyte = new UniqueConstraint("PK_DependentBase<byte?>", dependentBasebyteTable, new[] { principalIdColumn, principalAlternateIdColumn });
+            dependentBasebyteTable.PrimaryKey = pK_DependentBasebyte;
+            pK_DependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_DependentBasebyte));
+            var pK_DependentBasebyteKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId", "PrincipalAlternateId" });
+            pK_DependentBasebyte.MappedKeys.Add(pK_DependentBasebyteKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_DependentBasebyteKey).Add(pK_DependentBasebyte);
+            dependentBasebyteTable.UniqueConstraints.Add("PK_DependentBase<byte?>", pK_DependentBasebyte);
+            var iX_DependentBasebyte_PrincipalId = new TableIndex(
+            "IX_DependentBase<byte?>_PrincipalId", dependentBasebyteTable, new[] { principalIdColumn }, true);
+            iX_DependentBasebyte_PrincipalId.SetRowIndexValueFactory(new SimpleRowIndexValueFactory<long>(iX_DependentBasebyte_PrincipalId));
+            var iX_DependentBasebyte_PrincipalIdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
+                new[] { "PrincipalId" });
+            iX_DependentBasebyte_PrincipalId.MappedIndexes.Add(iX_DependentBasebyte_PrincipalIdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_DependentBasebyte_PrincipalIdIx).Add(iX_DependentBasebyte_PrincipalId);
+            dependentBasebyteTable.Indexes.Add("IX_DependentBase<byte?>_PrincipalId", iX_DependentBasebyte_PrincipalId);
 
             var manyTypes = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes")!;
 
@@ -1142,651 +1157,901 @@ private IRelationalModel CreateRelationalModel()
             var manyTypesTable = new Table("ManyTypes", null, relationalModel);
             var idColumn1 = new Column("Id", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Id", idColumn1);
+            idColumn1.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn1);
             var boolColumn = new Column("Bool", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Bool", boolColumn);
+            boolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(boolColumn);
             var boolArrayColumn = new Column("BoolArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BoolArray", boolArrayColumn);
+            boolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolArrayColumn);
             var boolNestedCollectionColumn = new Column("BoolNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BoolNestedCollection", boolNestedCollectionColumn);
+            boolNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolNestedCollectionColumn);
             var boolToStringConverterPropertyColumn = new Column("BoolToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToStringConverterProperty", boolToStringConverterPropertyColumn);
+            boolToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(boolToStringConverterPropertyColumn);
             var boolToTwoValuesConverterPropertyColumn = new Column("BoolToTwoValuesConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToTwoValuesConverterProperty", boolToTwoValuesConverterPropertyColumn);
+            boolToTwoValuesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(boolToTwoValuesConverterPropertyColumn);
             var boolToZeroOneConverterPropertyColumn = new Column("BoolToZeroOneConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("BoolToZeroOneConverterProperty", boolToZeroOneConverterPropertyColumn);
+            boolToZeroOneConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(boolToZeroOneConverterPropertyColumn);
             var bytesColumn = new Column("Bytes", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("Bytes", bytesColumn);
+            bytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(bytesColumn);
             var bytesArrayColumn = new Column("BytesArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BytesArray", bytesArrayColumn);
+            bytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesArrayColumn);
             var bytesNestedCollectionColumn = new Column("BytesNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BytesNestedCollection", bytesNestedCollectionColumn);
+            bytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesNestedCollectionColumn);
             var bytesToStringConverterPropertyColumn = new Column("BytesToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("BytesToStringConverterProperty", bytesToStringConverterPropertyColumn);
+            bytesToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(bytesToStringConverterPropertyColumn);
             var castingConverterPropertyColumn = new Column("CastingConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CastingConverterProperty", castingConverterPropertyColumn);
+            castingConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(castingConverterPropertyColumn);
             var charColumn = new Column("Char", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Char", charColumn);
+            charColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<char>(charColumn);
             var charArrayColumn = new Column("CharArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CharArray", charArrayColumn);
+            charArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charArrayColumn);
             var charNestedCollectionColumn = new Column("CharNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CharNestedCollection", charNestedCollectionColumn);
+            charNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charNestedCollectionColumn);
             var charToStringConverterPropertyColumn = new Column("CharToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("CharToStringConverterProperty", charToStringConverterPropertyColumn);
+            charToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(charToStringConverterPropertyColumn);
             var dateOnlyColumn = new Column("DateOnly", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnly", dateOnlyColumn);
+            dateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(dateOnlyColumn);
             var dateOnlyArrayColumn = new Column("DateOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyArray", dateOnlyArrayColumn);
+            dateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyArrayColumn);
             var dateOnlyToStringConverterPropertyColumn = new Column("DateOnlyToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateOnlyToStringConverterProperty", dateOnlyToStringConverterPropertyColumn);
+            dateOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateOnlyToStringConverterPropertyColumn);
             var dateTimeColumn = new Column("DateTime", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTime", dateTimeColumn);
+            dateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeColumn);
             var dateTimeArrayColumn = new Column("DateTimeArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeArray", dateTimeArrayColumn);
+            dateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeArrayColumn);
             var dateTimeOffsetToBinaryConverterPropertyColumn = new Column("DateTimeOffsetToBinaryConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBinaryConverterProperty", dateTimeOffsetToBinaryConverterPropertyColumn);
+            dateTimeOffsetToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeOffsetToBinaryConverterPropertyColumn);
             var dateTimeOffsetToBytesConverterPropertyColumn = new Column("DateTimeOffsetToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToBytesConverterProperty", dateTimeOffsetToBytesConverterPropertyColumn);
+            dateTimeOffsetToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(dateTimeOffsetToBytesConverterPropertyColumn);
             var dateTimeOffsetToStringConverterPropertyColumn = new Column("DateTimeOffsetToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeOffsetToStringConverterProperty", dateTimeOffsetToStringConverterPropertyColumn);
+            dateTimeOffsetToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeOffsetToStringConverterPropertyColumn);
             var dateTimeToBinaryConverterPropertyColumn = new Column("DateTimeToBinaryConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToBinaryConverterProperty", dateTimeToBinaryConverterPropertyColumn);
+            dateTimeToBinaryConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(dateTimeToBinaryConverterPropertyColumn);
             var dateTimeToStringConverterPropertyColumn = new Column("DateTimeToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToStringConverterProperty", dateTimeToStringConverterPropertyColumn);
+            dateTimeToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dateTimeToStringConverterPropertyColumn);
             var dateTimeToTicksConverterPropertyColumn = new Column("DateTimeToTicksConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DateTimeToTicksConverterProperty", dateTimeToTicksConverterPropertyColumn);
+            dateTimeToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(dateTimeToTicksConverterPropertyColumn);
             var decimalColumn = new Column("Decimal", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Decimal", decimalColumn);
+            decimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(decimalColumn);
             var decimalArrayColumn = new Column("DecimalArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalArray", decimalArrayColumn);
+            decimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalArrayColumn);
             var decimalNumberToBytesConverterPropertyColumn = new Column("DecimalNumberToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToBytesConverterProperty", decimalNumberToBytesConverterPropertyColumn);
+            decimalNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(decimalNumberToBytesConverterPropertyColumn);
             var decimalNumberToStringConverterPropertyColumn = new Column("DecimalNumberToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DecimalNumberToStringConverterProperty", decimalNumberToStringConverterPropertyColumn);
+            decimalNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(decimalNumberToStringConverterPropertyColumn);
             var doubleColumn = new Column("Double", "REAL", manyTypesTable);
             manyTypesTable.Columns.Add("Double", doubleColumn);
+            doubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(doubleColumn);
             var doubleArrayColumn = new Column("DoubleArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleArray", doubleArrayColumn);
+            doubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleArrayColumn);
             var doubleNumberToBytesConverterPropertyColumn = new Column("DoubleNumberToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToBytesConverterProperty", doubleNumberToBytesConverterPropertyColumn);
+            doubleNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(doubleNumberToBytesConverterPropertyColumn);
             var doubleNumberToStringConverterPropertyColumn = new Column("DoubleNumberToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("DoubleNumberToStringConverterProperty", doubleNumberToStringConverterPropertyColumn);
+            doubleNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(doubleNumberToStringConverterPropertyColumn);
             var enum16Column = new Column("Enum16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16", enum16Column);
+            enum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(enum16Column);
             var enum16ArrayColumn = new Column("Enum16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Array", enum16ArrayColumn);
+            enum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16ArrayColumn);
             var enum16AsStringColumn = new Column("Enum16AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsString", enum16AsStringColumn);
+            enum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringColumn);
             var enum16AsStringArrayColumn = new Column("Enum16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringArray", enum16AsStringArrayColumn);
+            enum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringArrayColumn);
             var enum16AsStringCollectionColumn = new Column("Enum16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16AsStringCollection", enum16AsStringCollectionColumn);
+            enum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16AsStringCollectionColumn);
             var enum16CollectionColumn = new Column("Enum16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum16Collection", enum16CollectionColumn);
+            enum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum16CollectionColumn);
             var enum32Column = new Column("Enum32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32", enum32Column);
+            enum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum32Column);
             var enum32ArrayColumn = new Column("Enum32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Array", enum32ArrayColumn);
+            enum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32ArrayColumn);
             var enum32AsStringColumn = new Column("Enum32AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsString", enum32AsStringColumn);
+            enum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringColumn);
             var enum32AsStringArrayColumn = new Column("Enum32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringArray", enum32AsStringArrayColumn);
+            enum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringArrayColumn);
             var enum32AsStringCollectionColumn = new Column("Enum32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32AsStringCollection", enum32AsStringCollectionColumn);
+            enum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32AsStringCollectionColumn);
             var enum32CollectionColumn = new Column("Enum32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32Collection", enum32CollectionColumn);
+            enum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32CollectionColumn);
             var enum32NestedCollectionColumn = new Column("Enum32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum32NestedCollection", enum32NestedCollectionColumn);
+            enum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum32NestedCollectionColumn);
             var enum64Column = new Column("Enum64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64", enum64Column);
+            enum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(enum64Column);
             var enum64ArrayColumn = new Column("Enum64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Array", enum64ArrayColumn);
+            enum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64ArrayColumn);
             var enum64AsStringColumn = new Column("Enum64AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsString", enum64AsStringColumn);
+            enum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringColumn);
             var enum64AsStringArrayColumn = new Column("Enum64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringArray", enum64AsStringArrayColumn);
+            enum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringArrayColumn);
             var enum64AsStringCollectionColumn = new Column("Enum64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64AsStringCollection", enum64AsStringCollectionColumn);
+            enum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64AsStringCollectionColumn);
             var enum64CollectionColumn = new Column("Enum64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum64Collection", enum64CollectionColumn);
+            enum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum64CollectionColumn);
             var enum8Column = new Column("Enum8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8", enum8Column);
+            enum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(enum8Column);
             var enum8ArrayColumn = new Column("Enum8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Array", enum8ArrayColumn);
+            enum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8ArrayColumn);
             var enum8AsStringColumn = new Column("Enum8AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsString", enum8AsStringColumn);
+            enum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringColumn);
             var enum8AsStringArrayColumn = new Column("Enum8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringArray", enum8AsStringArrayColumn);
+            enum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringArrayColumn);
             var enum8AsStringCollectionColumn = new Column("Enum8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8AsStringCollection", enum8AsStringCollectionColumn);
+            enum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8AsStringCollectionColumn);
             var enum8CollectionColumn = new Column("Enum8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8Collection", enum8CollectionColumn);
+            enum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8CollectionColumn);
             var enum8NestedCollectionColumn = new Column("Enum8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Enum8NestedCollection", enum8NestedCollectionColumn);
+            enum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enum8NestedCollectionColumn);
             var enumToNumberConverterPropertyColumn = new Column("EnumToNumberConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToNumberConverterProperty", enumToNumberConverterPropertyColumn);
+            enumToNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enumToNumberConverterPropertyColumn);
             var enumToStringConverterPropertyColumn = new Column("EnumToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumToStringConverterProperty", enumToStringConverterPropertyColumn);
+            enumToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumToStringConverterPropertyColumn);
             var enumU16Column = new Column("EnumU16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16", enumU16Column);
+            enumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(enumU16Column);
             var enumU16ArrayColumn = new Column("EnumU16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Array", enumU16ArrayColumn);
+            enumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16ArrayColumn);
             var enumU16AsStringColumn = new Column("EnumU16AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsString", enumU16AsStringColumn);
+            enumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringColumn);
             var enumU16AsStringArrayColumn = new Column("EnumU16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringArray", enumU16AsStringArrayColumn);
+            enumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringArrayColumn);
             var enumU16AsStringCollectionColumn = new Column("EnumU16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16AsStringCollection", enumU16AsStringCollectionColumn);
+            enumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16AsStringCollectionColumn);
             var enumU16CollectionColumn = new Column("EnumU16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU16Collection", enumU16CollectionColumn);
+            enumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU16CollectionColumn);
             var enumU32Column = new Column("EnumU32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32", enumU32Column);
+            enumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(enumU32Column);
             var enumU32ArrayColumn = new Column("EnumU32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Array", enumU32ArrayColumn);
+            enumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32ArrayColumn);
             var enumU32AsStringColumn = new Column("EnumU32AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsString", enumU32AsStringColumn);
+            enumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringColumn);
             var enumU32AsStringArrayColumn = new Column("EnumU32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringArray", enumU32AsStringArrayColumn);
+            enumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringArrayColumn);
             var enumU32AsStringCollectionColumn = new Column("EnumU32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32AsStringCollection", enumU32AsStringCollectionColumn);
+            enumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32AsStringCollectionColumn);
             var enumU32CollectionColumn = new Column("EnumU32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU32Collection", enumU32CollectionColumn);
+            enumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU32CollectionColumn);
             var enumU64Column = new Column("EnumU64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64", enumU64Column);
+            enumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(enumU64Column);
             var enumU64ArrayColumn = new Column("EnumU64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Array", enumU64ArrayColumn);
+            enumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64ArrayColumn);
             var enumU64AsStringColumn = new Column("EnumU64AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsString", enumU64AsStringColumn);
+            enumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringColumn);
             var enumU64AsStringArrayColumn = new Column("EnumU64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringArray", enumU64AsStringArrayColumn);
+            enumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringArrayColumn);
             var enumU64AsStringCollectionColumn = new Column("EnumU64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64AsStringCollection", enumU64AsStringCollectionColumn);
+            enumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64AsStringCollectionColumn);
             var enumU64CollectionColumn = new Column("EnumU64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64Collection", enumU64CollectionColumn);
+            enumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64CollectionColumn);
             var enumU64NestedCollectionColumn = new Column("EnumU64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU64NestedCollection", enumU64NestedCollectionColumn);
+            enumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU64NestedCollectionColumn);
             var enumU8Column = new Column("EnumU8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8", enumU8Column);
+            enumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(enumU8Column);
             var enumU8ArrayColumn = new Column("EnumU8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Array", enumU8ArrayColumn);
+            enumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8ArrayColumn);
             var enumU8AsStringColumn = new Column("EnumU8AsString", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsString", enumU8AsStringColumn);
+            enumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringColumn);
             var enumU8AsStringArrayColumn = new Column("EnumU8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringArray", enumU8AsStringArrayColumn);
+            enumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringArrayColumn);
             var enumU8AsStringCollectionColumn = new Column("EnumU8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8AsStringCollection", enumU8AsStringCollectionColumn);
+            enumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8AsStringCollectionColumn);
             var enumU8CollectionColumn = new Column("EnumU8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("EnumU8Collection", enumU8CollectionColumn);
+            enumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(enumU8CollectionColumn);
             var floatColumn = new Column("Float", "REAL", manyTypesTable);
             manyTypesTable.Columns.Add("Float", floatColumn);
+            floatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(floatColumn);
             var floatArrayColumn = new Column("FloatArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("FloatArray", floatArrayColumn);
+            floatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(floatArrayColumn);
             var guidColumn = new Column("Guid", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Guid", guidColumn);
+            guidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(guidColumn);
             var guidArrayColumn = new Column("GuidArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("GuidArray", guidArrayColumn);
+            guidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidArrayColumn);
             var guidNestedCollectionColumn = new Column("GuidNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("GuidNestedCollection", guidNestedCollectionColumn);
+            guidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidNestedCollectionColumn);
             var guidToBytesConverterPropertyColumn = new Column("GuidToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToBytesConverterProperty", guidToBytesConverterPropertyColumn);
+            guidToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(guidToBytesConverterPropertyColumn);
             var guidToStringConverterPropertyColumn = new Column("GuidToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("GuidToStringConverterProperty", guidToStringConverterPropertyColumn);
+            guidToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(guidToStringConverterPropertyColumn);
             var iPAddressColumn = new Column("IPAddress", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddress", iPAddressColumn);
+            iPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressColumn);
             var iPAddressArrayColumn = new Column("IPAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressArray", iPAddressArrayColumn);
+            iPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressArrayColumn);
             var iPAddressToBytesConverterPropertyColumn = new Column("IPAddressToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToBytesConverterProperty", iPAddressToBytesConverterPropertyColumn);
+            iPAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(iPAddressToBytesConverterPropertyColumn);
             var iPAddressToStringConverterPropertyColumn = new Column("IPAddressToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IPAddressToStringConverterProperty", iPAddressToStringConverterPropertyColumn);
+            iPAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(iPAddressToStringConverterPropertyColumn);
             var int16Column = new Column("Int16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int16", int16Column);
+            int16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(int16Column);
             var int16ArrayColumn = new Column("Int16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int16Array", int16ArrayColumn);
+            int16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int16ArrayColumn);
             var int32Column = new Column("Int32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int32", int32Column);
+            int32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(int32Column);
             var int32ArrayColumn = new Column("Int32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int32Array", int32ArrayColumn);
+            int32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32ArrayColumn);
             var int32NestedCollectionColumn = new Column("Int32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int32NestedCollection", int32NestedCollectionColumn);
+            int32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int32NestedCollectionColumn);
             var int64Column = new Column("Int64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int64", int64Column);
+            int64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(int64Column);
             var int64ArrayColumn = new Column("Int64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int64Array", int64ArrayColumn);
+            int64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64ArrayColumn);
             var int64NestedCollectionColumn = new Column("Int64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int64NestedCollection", int64NestedCollectionColumn);
+            int64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int64NestedCollectionColumn);
             var int8Column = new Column("Int8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("Int8", int8Column);
+            int8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(int8Column);
             var int8ArrayColumn = new Column("Int8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int8Array", int8ArrayColumn);
+            int8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8ArrayColumn);
             var int8NestedCollectionColumn = new Column("Int8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Int8NestedCollection", int8NestedCollectionColumn);
+            int8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(int8NestedCollectionColumn);
             var intNumberToBytesConverterPropertyColumn = new Column("IntNumberToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToBytesConverterProperty", intNumberToBytesConverterPropertyColumn);
+            intNumberToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(intNumberToBytesConverterPropertyColumn);
             var intNumberToStringConverterPropertyColumn = new Column("IntNumberToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("IntNumberToStringConverterProperty", intNumberToStringConverterPropertyColumn);
+            intNumberToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(intNumberToStringConverterPropertyColumn);
             var nullIntToNullStringConverterPropertyColumn = new Column("NullIntToNullStringConverterProperty", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullIntToNullStringConverterProperty", nullIntToNullStringConverterPropertyColumn);
+            nullIntToNullStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullIntToNullStringConverterPropertyColumn);
             var nullableBoolColumn = new Column("NullableBool", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBool", nullableBoolColumn);
+            nullableBoolColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(nullableBoolColumn);
             var nullableBoolArrayColumn = new Column("NullableBoolArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBoolArray", nullableBoolArrayColumn);
+            nullableBoolArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBoolArrayColumn);
             var nullableBytesColumn = new Column("NullableBytes", "BLOB", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableBytes", nullableBytesColumn);
+            nullableBytesColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(nullableBytesColumn);
             var nullableBytesArrayColumn = new Column("NullableBytesArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesArray", nullableBytesArrayColumn);
+            nullableBytesArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesArrayColumn);
             var nullableBytesNestedCollectionColumn = new Column("NullableBytesNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableBytesNestedCollection", nullableBytesNestedCollectionColumn);
+            nullableBytesNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableBytesNestedCollectionColumn);
             var nullableCharColumn = new Column("NullableChar", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableChar", nullableCharColumn);
+            nullableCharColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<char>(nullableCharColumn);
             var nullableCharArrayColumn = new Column("NullableCharArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableCharArray", nullableCharArrayColumn);
+            nullableCharArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableCharArrayColumn);
             var nullableDateOnlyColumn = new Column("NullableDateOnly", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateOnly", nullableDateOnlyColumn);
+            nullableDateOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(nullableDateOnlyColumn);
             var nullableDateOnlyArrayColumn = new Column("NullableDateOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateOnlyArray", nullableDateOnlyArrayColumn);
+            nullableDateOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateOnlyArrayColumn);
             var nullableDateTimeColumn = new Column("NullableDateTime", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDateTime", nullableDateTimeColumn);
+            nullableDateTimeColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(nullableDateTimeColumn);
             var nullableDateTimeArrayColumn = new Column("NullableDateTimeArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDateTimeArray", nullableDateTimeArrayColumn);
+            nullableDateTimeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDateTimeArrayColumn);
             var nullableDecimalColumn = new Column("NullableDecimal", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDecimal", nullableDecimalColumn);
+            nullableDecimalColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(nullableDecimalColumn);
             var nullableDecimalArrayColumn = new Column("NullableDecimalArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDecimalArray", nullableDecimalArrayColumn);
+            nullableDecimalArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDecimalArrayColumn);
             var nullableDoubleColumn = new Column("NullableDouble", "REAL", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableDouble", nullableDoubleColumn);
+            nullableDoubleColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(nullableDoubleColumn);
             var nullableDoubleArrayColumn = new Column("NullableDoubleArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableDoubleArray", nullableDoubleArrayColumn);
+            nullableDoubleArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableDoubleArrayColumn);
             var nullableEnum16Column = new Column("NullableEnum16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16", nullableEnum16Column);
+            nullableEnum16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16Column);
             var nullableEnum16ArrayColumn = new Column("NullableEnum16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Array", nullableEnum16ArrayColumn);
+            nullableEnum16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16ArrayColumn);
             var nullableEnum16AsStringColumn = new Column("NullableEnum16AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum16AsString", nullableEnum16AsStringColumn);
+            nullableEnum16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableEnum16AsStringColumn);
             var nullableEnum16AsStringArrayColumn = new Column("NullableEnum16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringArray", nullableEnum16AsStringArrayColumn);
+            nullableEnum16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringArrayColumn);
             var nullableEnum16AsStringCollectionColumn = new Column("NullableEnum16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16AsStringCollection", nullableEnum16AsStringCollectionColumn);
+            nullableEnum16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16AsStringCollectionColumn);
             var nullableEnum16CollectionColumn = new Column("NullableEnum16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum16Collection", nullableEnum16CollectionColumn);
+            nullableEnum16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum16CollectionColumn);
             var nullableEnum32Column = new Column("NullableEnum32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32", nullableEnum32Column);
+            nullableEnum32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32Column);
             var nullableEnum32ArrayColumn = new Column("NullableEnum32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Array", nullableEnum32ArrayColumn);
+            nullableEnum32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32ArrayColumn);
             var nullableEnum32AsStringColumn = new Column("NullableEnum32AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum32AsString", nullableEnum32AsStringColumn);
+            nullableEnum32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableEnum32AsStringColumn);
             var nullableEnum32AsStringArrayColumn = new Column("NullableEnum32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringArray", nullableEnum32AsStringArrayColumn);
+            nullableEnum32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringArrayColumn);
             var nullableEnum32AsStringCollectionColumn = new Column("NullableEnum32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32AsStringCollection", nullableEnum32AsStringCollectionColumn);
+            nullableEnum32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32AsStringCollectionColumn);
             var nullableEnum32CollectionColumn = new Column("NullableEnum32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32Collection", nullableEnum32CollectionColumn);
+            nullableEnum32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32CollectionColumn);
             var nullableEnum32NestedCollectionColumn = new Column("NullableEnum32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum32NestedCollection", nullableEnum32NestedCollectionColumn);
+            nullableEnum32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum32NestedCollectionColumn);
             var nullableEnum64Column = new Column("NullableEnum64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64", nullableEnum64Column);
+            nullableEnum64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64Column);
             var nullableEnum64ArrayColumn = new Column("NullableEnum64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Array", nullableEnum64ArrayColumn);
+            nullableEnum64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64ArrayColumn);
             var nullableEnum64AsStringColumn = new Column("NullableEnum64AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum64AsString", nullableEnum64AsStringColumn);
+            nullableEnum64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableEnum64AsStringColumn);
             var nullableEnum64AsStringArrayColumn = new Column("NullableEnum64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringArray", nullableEnum64AsStringArrayColumn);
+            nullableEnum64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringArrayColumn);
             var nullableEnum64AsStringCollectionColumn = new Column("NullableEnum64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64AsStringCollection", nullableEnum64AsStringCollectionColumn);
+            nullableEnum64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64AsStringCollectionColumn);
             var nullableEnum64CollectionColumn = new Column("NullableEnum64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum64Collection", nullableEnum64CollectionColumn);
+            nullableEnum64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum64CollectionColumn);
             var nullableEnum8Column = new Column("NullableEnum8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8", nullableEnum8Column);
+            nullableEnum8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(nullableEnum8Column);
             var nullableEnum8ArrayColumn = new Column("NullableEnum8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Array", nullableEnum8ArrayColumn);
+            nullableEnum8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8ArrayColumn);
             var nullableEnum8AsStringColumn = new Column("NullableEnum8AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnum8AsString", nullableEnum8AsStringColumn);
+            nullableEnum8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(nullableEnum8AsStringColumn);
             var nullableEnum8AsStringArrayColumn = new Column("NullableEnum8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringArray", nullableEnum8AsStringArrayColumn);
+            nullableEnum8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringArrayColumn);
             var nullableEnum8AsStringCollectionColumn = new Column("NullableEnum8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8AsStringCollection", nullableEnum8AsStringCollectionColumn);
+            nullableEnum8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8AsStringCollectionColumn);
             var nullableEnum8CollectionColumn = new Column("NullableEnum8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8Collection", nullableEnum8CollectionColumn);
+            nullableEnum8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8CollectionColumn);
             var nullableEnum8NestedCollectionColumn = new Column("NullableEnum8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnum8NestedCollection", nullableEnum8NestedCollectionColumn);
+            nullableEnum8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnum8NestedCollectionColumn);
             var nullableEnumU16Column = new Column("NullableEnumU16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16", nullableEnumU16Column);
+            nullableEnumU16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(nullableEnumU16Column);
             var nullableEnumU16ArrayColumn = new Column("NullableEnumU16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Array", nullableEnumU16ArrayColumn);
+            nullableEnumU16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16ArrayColumn);
             var nullableEnumU16AsStringColumn = new Column("NullableEnumU16AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU16AsString", nullableEnumU16AsStringColumn);
+            nullableEnumU16AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(nullableEnumU16AsStringColumn);
             var nullableEnumU16AsStringArrayColumn = new Column("NullableEnumU16AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringArray", nullableEnumU16AsStringArrayColumn);
+            nullableEnumU16AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringArrayColumn);
             var nullableEnumU16AsStringCollectionColumn = new Column("NullableEnumU16AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16AsStringCollection", nullableEnumU16AsStringCollectionColumn);
+            nullableEnumU16AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16AsStringCollectionColumn);
             var nullableEnumU16CollectionColumn = new Column("NullableEnumU16Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU16Collection", nullableEnumU16CollectionColumn);
+            nullableEnumU16CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU16CollectionColumn);
             var nullableEnumU32Column = new Column("NullableEnumU32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32", nullableEnumU32Column);
+            nullableEnumU32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(nullableEnumU32Column);
             var nullableEnumU32ArrayColumn = new Column("NullableEnumU32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Array", nullableEnumU32ArrayColumn);
+            nullableEnumU32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32ArrayColumn);
             var nullableEnumU32AsStringColumn = new Column("NullableEnumU32AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU32AsString", nullableEnumU32AsStringColumn);
+            nullableEnumU32AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(nullableEnumU32AsStringColumn);
             var nullableEnumU32AsStringArrayColumn = new Column("NullableEnumU32AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringArray", nullableEnumU32AsStringArrayColumn);
+            nullableEnumU32AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringArrayColumn);
             var nullableEnumU32AsStringCollectionColumn = new Column("NullableEnumU32AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32AsStringCollection", nullableEnumU32AsStringCollectionColumn);
+            nullableEnumU32AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32AsStringCollectionColumn);
             var nullableEnumU32CollectionColumn = new Column("NullableEnumU32Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU32Collection", nullableEnumU32CollectionColumn);
+            nullableEnumU32CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU32CollectionColumn);
             var nullableEnumU64Column = new Column("NullableEnumU64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64", nullableEnumU64Column);
+            nullableEnumU64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(nullableEnumU64Column);
             var nullableEnumU64ArrayColumn = new Column("NullableEnumU64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Array", nullableEnumU64ArrayColumn);
+            nullableEnumU64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64ArrayColumn);
             var nullableEnumU64AsStringColumn = new Column("NullableEnumU64AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU64AsString", nullableEnumU64AsStringColumn);
+            nullableEnumU64AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(nullableEnumU64AsStringColumn);
             var nullableEnumU64AsStringArrayColumn = new Column("NullableEnumU64AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringArray", nullableEnumU64AsStringArrayColumn);
+            nullableEnumU64AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringArrayColumn);
             var nullableEnumU64AsStringCollectionColumn = new Column("NullableEnumU64AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64AsStringCollection", nullableEnumU64AsStringCollectionColumn);
+            nullableEnumU64AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64AsStringCollectionColumn);
             var nullableEnumU64CollectionColumn = new Column("NullableEnumU64Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64Collection", nullableEnumU64CollectionColumn);
+            nullableEnumU64CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64CollectionColumn);
             var nullableEnumU64NestedCollectionColumn = new Column("NullableEnumU64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU64NestedCollection", nullableEnumU64NestedCollectionColumn);
+            nullableEnumU64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU64NestedCollectionColumn);
             var nullableEnumU8Column = new Column("NullableEnumU8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8", nullableEnumU8Column);
+            nullableEnumU8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8Column);
             var nullableEnumU8ArrayColumn = new Column("NullableEnumU8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Array", nullableEnumU8ArrayColumn);
+            nullableEnumU8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8ArrayColumn);
             var nullableEnumU8AsStringColumn = new Column("NullableEnumU8AsString", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableEnumU8AsString", nullableEnumU8AsStringColumn);
+            nullableEnumU8AsStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableEnumU8AsStringColumn);
             var nullableEnumU8AsStringArrayColumn = new Column("NullableEnumU8AsStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringArray", nullableEnumU8AsStringArrayColumn);
+            nullableEnumU8AsStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringArrayColumn);
             var nullableEnumU8AsStringCollectionColumn = new Column("NullableEnumU8AsStringCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8AsStringCollection", nullableEnumU8AsStringCollectionColumn);
+            nullableEnumU8AsStringCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8AsStringCollectionColumn);
             var nullableEnumU8CollectionColumn = new Column("NullableEnumU8Collection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableEnumU8Collection", nullableEnumU8CollectionColumn);
+            nullableEnumU8CollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableEnumU8CollectionColumn);
             var nullableFloatColumn = new Column("NullableFloat", "REAL", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableFloat", nullableFloatColumn);
+            nullableFloatColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<float>(nullableFloatColumn);
             var nullableFloatArrayColumn = new Column("NullableFloatArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableFloatArray", nullableFloatArrayColumn);
+            nullableFloatArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableFloatArrayColumn);
             var nullableGuidColumn = new Column("NullableGuid", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableGuid", nullableGuidColumn);
+            nullableGuidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(nullableGuidColumn);
             var nullableGuidArrayColumn = new Column("NullableGuidArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidArray", nullableGuidArrayColumn);
+            nullableGuidArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidArrayColumn);
             var nullableGuidNestedCollectionColumn = new Column("NullableGuidNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableGuidNestedCollection", nullableGuidNestedCollectionColumn);
+            nullableGuidNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableGuidNestedCollectionColumn);
             var nullableIPAddressColumn = new Column("NullableIPAddress", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableIPAddress", nullableIPAddressColumn);
+            nullableIPAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressColumn);
             var nullableIPAddressArrayColumn = new Column("NullableIPAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableIPAddressArray", nullableIPAddressArrayColumn);
+            nullableIPAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableIPAddressArrayColumn);
             var nullableInt16Column = new Column("NullableInt16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt16", nullableInt16Column);
+            nullableInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<short>(nullableInt16Column);
             var nullableInt16ArrayColumn = new Column("NullableInt16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt16Array", nullableInt16ArrayColumn);
+            nullableInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt16ArrayColumn);
             var nullableInt32Column = new Column("NullableInt32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt32", nullableInt32Column);
+            nullableInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(nullableInt32Column);
             var nullableInt32ArrayColumn = new Column("NullableInt32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32Array", nullableInt32ArrayColumn);
+            nullableInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32ArrayColumn);
             var nullableInt32NestedCollectionColumn = new Column("NullableInt32NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt32NestedCollection", nullableInt32NestedCollectionColumn);
+            nullableInt32NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt32NestedCollectionColumn);
             var nullableInt64Column = new Column("NullableInt64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt64", nullableInt64Column);
+            nullableInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(nullableInt64Column);
             var nullableInt64ArrayColumn = new Column("NullableInt64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64Array", nullableInt64ArrayColumn);
+            nullableInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64ArrayColumn);
             var nullableInt64NestedCollectionColumn = new Column("NullableInt64NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt64NestedCollection", nullableInt64NestedCollectionColumn);
+            nullableInt64NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt64NestedCollectionColumn);
             var nullableInt8Column = new Column("NullableInt8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableInt8", nullableInt8Column);
+            nullableInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<sbyte>(nullableInt8Column);
             var nullableInt8ArrayColumn = new Column("NullableInt8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableInt8Array", nullableInt8ArrayColumn);
+            nullableInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableInt8ArrayColumn);
             var nullablePhysicalAddressColumn = new Column("NullablePhysicalAddress", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullablePhysicalAddress", nullablePhysicalAddressColumn);
+            nullablePhysicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressColumn);
             var nullablePhysicalAddressArrayColumn = new Column("NullablePhysicalAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressArray", nullablePhysicalAddressArrayColumn);
+            nullablePhysicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressArrayColumn);
             var nullablePhysicalAddressNestedCollectionColumn = new Column("NullablePhysicalAddressNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullablePhysicalAddressNestedCollection", nullablePhysicalAddressNestedCollectionColumn);
+            nullablePhysicalAddressNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullablePhysicalAddressNestedCollectionColumn);
             var nullableStringColumn = new Column("NullableString", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableString", nullableStringColumn);
+            nullableStringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringColumn);
             var nullableStringArrayColumn = new Column("NullableStringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringArray", nullableStringArrayColumn);
+            nullableStringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringArrayColumn);
             var nullableStringNestedCollectionColumn = new Column("NullableStringNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableStringNestedCollection", nullableStringNestedCollectionColumn);
+            nullableStringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableStringNestedCollectionColumn);
             var nullableTimeOnlyColumn = new Column("NullableTimeOnly", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeOnly", nullableTimeOnlyColumn);
+            nullableTimeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(nullableTimeOnlyColumn);
             var nullableTimeOnlyArrayColumn = new Column("NullableTimeOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeOnlyArray", nullableTimeOnlyArrayColumn);
+            nullableTimeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeOnlyArrayColumn);
             var nullableTimeSpanColumn = new Column("NullableTimeSpan", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableTimeSpan", nullableTimeSpanColumn);
+            nullableTimeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(nullableTimeSpanColumn);
             var nullableTimeSpanArrayColumn = new Column("NullableTimeSpanArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableTimeSpanArray", nullableTimeSpanArrayColumn);
+            nullableTimeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableTimeSpanArrayColumn);
             var nullableUInt16Column = new Column("NullableUInt16", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt16", nullableUInt16Column);
+            nullableUInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(nullableUInt16Column);
             var nullableUInt16ArrayColumn = new Column("NullableUInt16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt16Array", nullableUInt16ArrayColumn);
+            nullableUInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt16ArrayColumn);
             var nullableUInt32Column = new Column("NullableUInt32", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt32", nullableUInt32Column);
+            nullableUInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(nullableUInt32Column);
             var nullableUInt32ArrayColumn = new Column("NullableUInt32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt32Array", nullableUInt32ArrayColumn);
+            nullableUInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt32ArrayColumn);
             var nullableUInt64Column = new Column("NullableUInt64", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt64", nullableUInt64Column);
+            nullableUInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(nullableUInt64Column);
             var nullableUInt64ArrayColumn = new Column("NullableUInt64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt64Array", nullableUInt64ArrayColumn);
+            nullableUInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt64ArrayColumn);
             var nullableUInt8Column = new Column("NullableUInt8", "INTEGER", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUInt8", nullableUInt8Column);
+            nullableUInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(nullableUInt8Column);
             var nullableUInt8ArrayColumn = new Column("NullableUInt8Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8Array", nullableUInt8ArrayColumn);
+            nullableUInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8ArrayColumn);
             var nullableUInt8NestedCollectionColumn = new Column("NullableUInt8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUInt8NestedCollection", nullableUInt8NestedCollectionColumn);
+            nullableUInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUInt8NestedCollectionColumn);
             var nullableUriColumn = new Column("NullableUri", "TEXT", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("NullableUri", nullableUriColumn);
+            nullableUriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriColumn);
             var nullableUriArrayColumn = new Column("NullableUriArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("NullableUriArray", nullableUriArrayColumn);
+            nullableUriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(nullableUriArrayColumn);
             var physicalAddressColumn = new Column("PhysicalAddress", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddress", physicalAddressColumn);
+            physicalAddressColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressColumn);
             var physicalAddressArrayColumn = new Column("PhysicalAddressArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressArray", physicalAddressArrayColumn);
+            physicalAddressArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressArrayColumn);
             var physicalAddressToBytesConverterPropertyColumn = new Column("PhysicalAddressToBytesConverterProperty", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToBytesConverterProperty", physicalAddressToBytesConverterPropertyColumn);
+            physicalAddressToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(physicalAddressToBytesConverterPropertyColumn);
             var physicalAddressToStringConverterPropertyColumn = new Column("PhysicalAddressToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("PhysicalAddressToStringConverterProperty", physicalAddressToStringConverterPropertyColumn);
+            physicalAddressToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(physicalAddressToStringConverterPropertyColumn);
             var stringColumn = new Column("String", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("String", stringColumn);
+            stringColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringColumn);
             var stringArrayColumn = new Column("StringArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringArray", stringArrayColumn);
+            stringArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringArrayColumn);
             var stringNestedCollectionColumn = new Column("StringNestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringNestedCollection", stringNestedCollectionColumn);
+            stringNestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringNestedCollectionColumn);
             var stringToBoolConverterPropertyColumn = new Column("StringToBoolConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("StringToBoolConverterProperty", stringToBoolConverterPropertyColumn);
+            stringToBoolConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<bool>(stringToBoolConverterPropertyColumn);
             var stringToBytesConverterPropertyColumn = new Column("StringToBytesConverterProperty", "BLOB", manyTypesTable)
             {
                 IsNullable = true
             };
             manyTypesTable.Columns.Add("StringToBytesConverterProperty", stringToBytesConverterPropertyColumn);
+            stringToBytesConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(stringToBytesConverterPropertyColumn);
             var stringToCharConverterPropertyColumn = new Column("StringToCharConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToCharConverterProperty", stringToCharConverterPropertyColumn);
+            stringToCharConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<char>(stringToCharConverterPropertyColumn);
             var stringToDateOnlyConverterPropertyColumn = new Column("StringToDateOnlyConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateOnlyConverterProperty", stringToDateOnlyConverterPropertyColumn);
+            stringToDateOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateOnly>(stringToDateOnlyConverterPropertyColumn);
             var stringToDateTimeConverterPropertyColumn = new Column("StringToDateTimeConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeConverterProperty", stringToDateTimeConverterPropertyColumn);
+            stringToDateTimeConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTime>(stringToDateTimeConverterPropertyColumn);
             var stringToDateTimeOffsetConverterPropertyColumn = new Column("StringToDateTimeOffsetConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDateTimeOffsetConverterProperty", stringToDateTimeOffsetConverterPropertyColumn);
+            stringToDateTimeOffsetConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<DateTimeOffset>(stringToDateTimeOffsetConverterPropertyColumn);
             var stringToDecimalNumberConverterPropertyColumn = new Column("StringToDecimalNumberConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDecimalNumberConverterProperty", stringToDecimalNumberConverterPropertyColumn);
+            stringToDecimalNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<decimal>(stringToDecimalNumberConverterPropertyColumn);
             var stringToDoubleNumberConverterPropertyColumn = new Column("StringToDoubleNumberConverterProperty", "REAL", manyTypesTable);
             manyTypesTable.Columns.Add("StringToDoubleNumberConverterProperty", stringToDoubleNumberConverterPropertyColumn);
+            stringToDoubleNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<double>(stringToDoubleNumberConverterPropertyColumn);
             var stringToEnumConverterPropertyColumn = new Column("StringToEnumConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("StringToEnumConverterProperty", stringToEnumConverterPropertyColumn);
+            stringToEnumConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(stringToEnumConverterPropertyColumn);
             var stringToGuidConverterPropertyColumn = new Column("StringToGuidConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToGuidConverterProperty", stringToGuidConverterPropertyColumn);
+            stringToGuidConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToGuidConverterPropertyColumn);
             var stringToIntNumberConverterPropertyColumn = new Column("StringToIntNumberConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("StringToIntNumberConverterProperty", stringToIntNumberConverterPropertyColumn);
+            stringToIntNumberConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(stringToIntNumberConverterPropertyColumn);
             var stringToTimeOnlyConverterPropertyColumn = new Column("StringToTimeOnlyConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeOnlyConverterProperty", stringToTimeOnlyConverterPropertyColumn);
+            stringToTimeOnlyConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(stringToTimeOnlyConverterPropertyColumn);
             var stringToTimeSpanConverterPropertyColumn = new Column("StringToTimeSpanConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToTimeSpanConverterProperty", stringToTimeSpanConverterPropertyColumn);
+            stringToTimeSpanConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(stringToTimeSpanConverterPropertyColumn);
             var stringToUriConverterPropertyColumn = new Column("StringToUriConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("StringToUriConverterProperty", stringToUriConverterPropertyColumn);
+            stringToUriConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(stringToUriConverterPropertyColumn);
             var timeOnlyColumn = new Column("TimeOnly", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnly", timeOnlyColumn);
+            timeOnlyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeOnly>(timeOnlyColumn);
             var timeOnlyArrayColumn = new Column("TimeOnlyArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyArray", timeOnlyArrayColumn);
+            timeOnlyArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyArrayColumn);
             var timeOnlyToStringConverterPropertyColumn = new Column("TimeOnlyToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToStringConverterProperty", timeOnlyToStringConverterPropertyColumn);
+            timeOnlyToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeOnlyToStringConverterPropertyColumn);
             var timeOnlyToTicksConverterPropertyColumn = new Column("TimeOnlyToTicksConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("TimeOnlyToTicksConverterProperty", timeOnlyToTicksConverterPropertyColumn);
+            timeOnlyToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeOnlyToTicksConverterPropertyColumn);
             var timeSpanColumn = new Column("TimeSpan", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpan", timeSpanColumn);
+            timeSpanColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<TimeSpan>(timeSpanColumn);
             var timeSpanArrayColumn = new Column("TimeSpanArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanArray", timeSpanArrayColumn);
+            timeSpanArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanArrayColumn);
             var timeSpanToStringConverterPropertyColumn = new Column("TimeSpanToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToStringConverterProperty", timeSpanToStringConverterPropertyColumn);
+            timeSpanToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(timeSpanToStringConverterPropertyColumn);
             var timeSpanToTicksConverterPropertyColumn = new Column("TimeSpanToTicksConverterProperty", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("TimeSpanToTicksConverterProperty", timeSpanToTicksConverterPropertyColumn);
+            timeSpanToTicksConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(timeSpanToTicksConverterPropertyColumn);
             var uInt16Column = new Column("UInt16", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16", uInt16Column);
+            uInt16Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ushort>(uInt16Column);
             var uInt16ArrayColumn = new Column("UInt16Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt16Array", uInt16ArrayColumn);
+            uInt16ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt16ArrayColumn);
             var uInt32Column = new Column("UInt32", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32", uInt32Column);
+            uInt32Column.Accessors = ColumnAccessorsFactory.CreateGeneric<uint>(uInt32Column);
             var uInt32ArrayColumn = new Column("UInt32Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt32Array", uInt32ArrayColumn);
+            uInt32ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt32ArrayColumn);
             var uInt64Column = new Column("UInt64", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64", uInt64Column);
+            uInt64Column.Accessors = ColumnAccessorsFactory.CreateGeneric<ulong>(uInt64Column);
             var uInt64ArrayColumn = new Column("UInt64Array", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt64Array", uInt64ArrayColumn);
+            uInt64ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt64ArrayColumn);
             var uInt8Column = new Column("UInt8", "INTEGER", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8", uInt8Column);
+            uInt8Column.Accessors = ColumnAccessorsFactory.CreateGeneric<byte>(uInt8Column);
             var uInt8ArrayColumn = new Column("UInt8Array", "BLOB", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8Array", uInt8ArrayColumn);
+            uInt8ArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(uInt8ArrayColumn);
             var uInt8NestedCollectionColumn = new Column("UInt8NestedCollection", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UInt8NestedCollection", uInt8NestedCollectionColumn);
+            uInt8NestedCollectionColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uInt8NestedCollectionColumn);
             var uriColumn = new Column("Uri", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("Uri", uriColumn);
+            uriColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriColumn);
             var uriArrayColumn = new Column("UriArray", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UriArray", uriArrayColumn);
+            uriArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriArrayColumn);
             var uriToStringConverterPropertyColumn = new Column("UriToStringConverterProperty", "TEXT", manyTypesTable);
             manyTypesTable.Columns.Add("UriToStringConverterProperty", uriToStringConverterPropertyColumn);
-            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn1 });
-            manyTypesTable.PrimaryKey = pK_ManyTypes;
-            var pK_ManyTypesKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
-                new[] { "Id" });
-            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
-            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
+            uriToStringConverterPropertyColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(uriToStringConverterPropertyColumn);
             relationalModel.Tables.Add(("ManyTypes", null), manyTypesTable);
             var manyTypesTableMapping = new TableMapping(manyTypes, manyTypesTable, null);
             manyTypesTable.AddTypeMapping(manyTypesTableMapping, false);
@@ -2049,6 +2314,15 @@ private IRelationalModel CreateRelationalModel()
             RelationalModel.CreateColumnMapping(uriColumn, manyTypes.FindProperty("Uri")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriArrayColumn, manyTypes.FindProperty("UriArray")!, manyTypesTableMapping);
             RelationalModel.CreateColumnMapping(uriToStringConverterPropertyColumn, manyTypes.FindProperty("UriToStringConverterProperty")!, manyTypesTableMapping);
+            var pK_ManyTypes = new UniqueConstraint("PK_ManyTypes", manyTypesTable, new[] { idColumn1 });
+            manyTypesTable.PrimaryKey = pK_ManyTypes;
+            pK_ManyTypes.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_ManyTypes));
+            var pK_ManyTypesKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+ManyTypes",
+                new[] { "Id" });
+            pK_ManyTypes.MappedKeys.Add(pK_ManyTypesKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pK_ManyTypesKey).Add(pK_ManyTypes);
+            manyTypesTable.UniqueConstraints.Add("PK_ManyTypes", pK_ManyTypes);
 
             var principalBase = FindEntityType("Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase")!;
 
@@ -2143,96 +2417,91 @@ private IRelationalModel CreateRelationalModel()
             var principalBaseTable = new Table("PrincipalBase", null, relationalModel);
             var idColumn2 = new Column("Id", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("Id", idColumn2);
+            idColumn2.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(idColumn2);
             var alternateIdColumn = new Column("AlternateId", "TEXT", principalBaseTable);
             principalBaseTable.Columns.Add("AlternateId", alternateIdColumn);
+            alternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(alternateIdColumn);
             var discriminatorColumn = new Column("Discriminator", "TEXT", principalBaseTable);
             principalBaseTable.Columns.Add("Discriminator", discriminatorColumn);
+            discriminatorColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(discriminatorColumn);
             var enum1Column = new Column("Enum1", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("Enum1", enum1Column);
+            enum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum1Column);
             var enum2Column = new Column("Enum2", "INTEGER", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Enum2", enum2Column);
+            enum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(enum2Column);
             var flagsEnum1Column = new Column("FlagsEnum1", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum1", flagsEnum1Column);
+            flagsEnum1Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum1Column);
             var flagsEnum2Column = new Column("FlagsEnum2", "INTEGER", principalBaseTable);
             principalBaseTable.Columns.Add("FlagsEnum2", flagsEnum2Column);
+            flagsEnum2Column.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(flagsEnum2Column);
             var manyOwnedColumn = new JsonColumn("ManyOwned", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ManyOwned", manyOwnedColumn);
+            manyOwnedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(manyOwnedColumn);
             var ownedColumn = new JsonColumn("Owned", "TEXT", principalBaseTable);
             principalBaseTable.Columns.Add("Owned", ownedColumn);
+            ownedColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<JsonElement>(ownedColumn);
             var pointColumn0 = new Column("Point", "geometry", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("Point", pointColumn0);
+            pointColumn0.Accessors = ColumnAccessorsFactory.CreateGeneric<Point>(pointColumn0);
             var refTypeArrayColumn = new Column("RefTypeArray", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeArray", refTypeArrayColumn);
+            refTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeArrayColumn);
             var refTypeEnumerableColumn = new Column("RefTypeEnumerable", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeEnumerable", refTypeEnumerableColumn);
+            refTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeEnumerableColumn);
             var refTypeIListColumn = new Column("RefTypeIList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeIList", refTypeIListColumn);
+            refTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeIListColumn);
             var refTypeListColumn = new Column("RefTypeList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("RefTypeList", refTypeListColumn);
+            refTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(refTypeListColumn);
             var valueTypeArrayColumn = new Column("ValueTypeArray", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeArray", valueTypeArrayColumn);
+            valueTypeArrayColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeArrayColumn);
             var valueTypeEnumerableColumn = new Column("ValueTypeEnumerable", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeEnumerable", valueTypeEnumerableColumn);
+            valueTypeEnumerableColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeEnumerableColumn);
             var valueTypeIListColumn = new Column("ValueTypeIList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeIList", valueTypeIListColumn);
+            valueTypeIListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeIListColumn);
             var valueTypeListColumn = new Column("ValueTypeList", "TEXT", principalBaseTable)
             {
                 IsNullable = true
             };
             principalBaseTable.Columns.Add("ValueTypeList", valueTypeListColumn);
-            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn2 });
-            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id" });
-            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
-            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
-            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
-            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn2, alternateIdColumn });
-            principalBaseTable.PrimaryKey = pK;
-            var pKKey = RelationalModel.GetKey(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "Id", "AlternateId" });
-            pK.MappedKeys.Add(pKKey);
-            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
-            principalBaseTable.UniqueConstraints.Add("PK", pK);
-            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
-            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn2 }, false);
-            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
-                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
-                new[] { "AlternateId", "Id" });
-            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
-            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
-            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
+            valueTypeListColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(valueTypeListColumn);
             relationalModel.Tables.Add(("PrincipalBase", null), principalBaseTable);
             var principalBaseTableMapping = new TableMapping(principalBase, principalBaseTable, true)
             {
@@ -2360,6 +2629,32 @@ private IRelationalModel CreateRelationalModel()
                 new[] { "PrincipalDerivedId", "PrincipalDerivedAlternateId" },
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalDerived<Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>>",
                 new[] { "Id", "AlternateId" }));
+            var aK_PrincipalBase_Id = new UniqueConstraint("AK_PrincipalBase_Id", principalBaseTable, new[] { idColumn2 });
+            aK_PrincipalBase_Id.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<long>(aK_PrincipalBase_Id));
+            var aK_PrincipalBase_IdKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id" });
+            aK_PrincipalBase_Id.MappedKeys.Add(aK_PrincipalBase_IdKey);
+            RelationalModel.GetOrCreateUniqueConstraints(aK_PrincipalBase_IdKey).Add(aK_PrincipalBase_Id);
+            principalBaseTable.UniqueConstraints.Add("AK_PrincipalBase_Id", aK_PrincipalBase_Id);
+            var pK = new UniqueConstraint("PK", principalBaseTable, new[] { idColumn2, alternateIdColumn });
+            principalBaseTable.PrimaryKey = pK;
+            pK.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK));
+            var pKKey = RelationalModel.GetKey(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "Id", "AlternateId" });
+            pK.MappedKeys.Add(pKKey);
+            RelationalModel.GetOrCreateUniqueConstraints(pKKey).Add(pK);
+            principalBaseTable.UniqueConstraints.Add("PK", pK);
+            var iX_PrincipalBase_AlternateId_Id = new TableIndex(
+            "IX_PrincipalBase_AlternateId_Id", principalBaseTable, new[] { alternateIdColumn, idColumn2 }, false);
+            iX_PrincipalBase_AlternateId_Id.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBase_AlternateId_Id));
+            var iX_PrincipalBase_AlternateId_IdIx = RelationalModel.GetIndex(this,
+                "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+PrincipalBase",
+                new[] { "AlternateId", "Id" });
+            iX_PrincipalBase_AlternateId_Id.MappedIndexes.Add(iX_PrincipalBase_AlternateId_IdIx);
+            RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBase_AlternateId_IdIx).Add(iX_PrincipalBase_AlternateId_Id);
+            principalBaseTable.Indexes.Add("IX_PrincipalBase_AlternateId_Id", iX_PrincipalBase_AlternateId_Id);
 
             var principalBasePrincipalDerivedDependentBasebyte = FindEntityType("PrincipalBasePrincipalDerived<DependentBase<byte?>>")!;
 
@@ -2394,19 +2689,34 @@ private IRelationalModel CreateRelationalModel()
             var principalBasePrincipalDerivedDependentBasebyteTable = new Table("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null, relationalModel);
             var derivedsIdColumn = new Column("DerivedsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsId", derivedsIdColumn);
+            derivedsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(derivedsIdColumn);
             var derivedsAlternateIdColumn = new Column("DerivedsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("DerivedsAlternateId", derivedsAlternateIdColumn);
+            derivedsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(derivedsAlternateIdColumn);
             var principalsIdColumn = new Column("PrincipalsId", "INTEGER", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsId", principalsIdColumn);
+            principalsIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<long>(principalsIdColumn);
             var principalsAlternateIdColumn = new Column("PrincipalsAlternateId", "TEXT", principalBasePrincipalDerivedDependentBasebyteTable);
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("PrincipalsAlternateId", principalsAlternateIdColumn);
+            principalsAlternateIdColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<Guid>(principalsAlternateIdColumn);
             var rowidColumn = new Column("rowid", "BLOB", principalBasePrincipalDerivedDependentBasebyteTable)
             {
                 IsNullable = true
             };
             principalBasePrincipalDerivedDependentBasebyteTable.Columns.Add("rowid", rowidColumn);
+            rowidColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(rowidColumn);
+            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
+            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
+            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
+            tableMappings7.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
+            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var pK_PrincipalBasePrincipalDerivedDependentBasebyte = new UniqueConstraint("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", principalBasePrincipalDerivedDependentBasebyteTable, new[] { derivedsIdColumn, derivedsAlternateIdColumn, principalsIdColumn, principalsAlternateIdColumn });
             principalBasePrincipalDerivedDependentBasebyteTable.PrimaryKey = pK_PrincipalBasePrincipalDerivedDependentBasebyte;
+            pK_PrincipalBasePrincipalDerivedDependentBasebyte.SetRowKeyValueFactory(new CompositeRowKeyValueFactory(pK_PrincipalBasePrincipalDerivedDependentBasebyte));
             var pK_PrincipalBasePrincipalDerivedDependentBasebyteKey = RelationalModel.GetKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId", "PrincipalsId", "PrincipalsAlternateId" });
@@ -2415,25 +2725,18 @@ private IRelationalModel CreateRelationalModel()
             principalBasePrincipalDerivedDependentBasebyteTable.UniqueConstraints.Add("PK_PrincipalBasePrincipalDerived<DependentBase<byte?>>", pK_PrincipalBasePrincipalDerivedDependentBasebyte);
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId = new TableIndex(
             "IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, new[] { principalsIdColumn, principalsAlternateIdColumn }, false);
+            iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.SetRowIndexValueFactory(new CompositeRowIndexValueFactory(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId));
             var iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx = RelationalModel.GetIndex(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" });
             iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId.MappedIndexes.Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx);
             RelationalModel.GetOrCreateTableIndexes(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateIdIx).Add(iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
             principalBasePrincipalDerivedDependentBasebyteTable.Indexes.Add("IX_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalsId_PrincipalsAlternateId", iX_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalsId_PrincipalsAlternateId);
-            relationalModel.Tables.Add(("PrincipalBasePrincipalDerived<DependentBase<byte?>>", null), principalBasePrincipalDerivedDependentBasebyteTable);
-            var principalBasePrincipalDerivedDependentBasebyteTableMapping = new TableMapping(principalBasePrincipalDerivedDependentBasebyte, principalBasePrincipalDerivedDependentBasebyteTable, null);
-            principalBasePrincipalDerivedDependentBasebyteTable.AddTypeMapping(principalBasePrincipalDerivedDependentBasebyteTableMapping, false);
-            tableMappings7.Add(principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(derivedsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("DerivedsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsAlternateIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsAlternateId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(principalsIdColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("PrincipalsId")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
-            RelationalModel.CreateColumnMapping(rowidColumn, principalBasePrincipalDerivedDependentBasebyte.FindProperty("rowid")!, principalBasePrincipalDerivedDependentBasebyteTableMapping);
             var fK_DependentBasebyte_PrincipalBase_PrincipalId = new ForeignKeyConstraint(
                 "FK_DependentBase<byte?>_PrincipalBase_PrincipalId", dependentBasebyteTable, principalBaseTable,
                 new[] { principalIdColumn },
                 principalBaseTable.FindUniqueConstraint("AK_PrincipalBase_Id")!, ReferentialAction.Cascade);
+            fK_DependentBasebyte_PrincipalBase_PrincipalId.SetRowForeignKeyValueFactory(RowForeignKeyValueFactoryFactory.CreateSimpleNonNullableFactory<long, long>(fK_DependentBasebyte_PrincipalBase_PrincipalId));
             var fK_DependentBasebyte_PrincipalBase_PrincipalIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId" },
@@ -2447,6 +2750,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_DependentBase<byte?>_PrincipalBase_PrincipalId_PrincipalAlternateId", dependentBasebyteTable, principalBaseTable,
                 new[] { principalIdColumn, principalAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.NoAction);
+            fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateId));
             var fK_DependentBasebyte_PrincipalBase_PrincipalId_PrincipalAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentBase<byte?>",
                 new[] { "PrincipalId", "PrincipalAlternateId" },
@@ -2460,6 +2764,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_DerivedsId_DerivedsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                 new[] { derivedsIdColumn, derivedsAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_DerivedsId_DerivedsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "DerivedsId", "DerivedsAlternateId" },
@@ -2473,6 +2778,7 @@ private IRelationalModel CreateRelationalModel()
                 "FK_PrincipalBasePrincipalDerived<DependentBase<byte?>>_PrincipalBase_PrincipalsId_PrincipalsAlternateId", principalBasePrincipalDerivedDependentBasebyteTable, principalBaseTable,
                 new[] { principalsIdColumn, principalsAlternateIdColumn },
                 principalBaseTable.FindUniqueConstraint("PK")!, ReferentialAction.Cascade);
+            fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId.SetRowForeignKeyValueFactory(new CompositeRowForeignKeyValueFactory(fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateId));
             var fK_PrincipalBasePrincipalDerivedDependentBasebyte_PrincipalBase_PrincipalsId_PrincipalsAlternateIdFk = RelationalModel.GetForeignKey(this,
                 "PrincipalBasePrincipalDerived<DependentBase<byte?>>",
                 new[] { "PrincipalsId", "PrincipalsAlternateId" },
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs
index ac6e3a3d9a..fed8607aef 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentBaseEntityType.cs
@@ -44,6 +44,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -72,6 +78,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -86,6 +98,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(CompiledModelTestBase.Enum1),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            enumDiscriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<CompiledModelTestBase.Enum1>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<CompiledModelTestBase.Enum1>(enumDiscriminator, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.Enum1>(enumDiscriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             enumDiscriminator.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -203,17 +221,17 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 fieldInfo: typeof(CompiledModelTestBase.DependentBase<byte?>).GetField("<Principal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
 
             principal.SetGetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) == null,
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance),
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> instance) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(instance) == null);
             principal.SetSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetMaterializationSetter(
-                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
+                (CompiledModelTestBase.DependentBase<Nullable<byte>> entity, CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>> value) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal(entity) = value);
             principal.SetAccessors(
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
-                (InternalEntityEntry entry) => DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
+                (InternalEntityEntry entry) => UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal((CompiledModelTestBase.DependentBase<Nullable<byte>>)entry.Entity),
                 null,
                 (InternalEntityEntry entry) => entry.GetCurrentValue<CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<Nullable<byte>>>>(principal),
                 null);
@@ -223,6 +241,7 @@ public static RuntimeForeignKey CreateForeignKey2(RuntimeEntityType declaringEnt
                 shadowIndex: -1,
                 relationshipIndex: 2,
                 storeGenerationIndex: -1);
+            principal.AddRuntimeAnnotation("UnsafeAccessors", new[] { ("DependentBaseEntityType.UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Principal", "TestNamespace") });
             var dependent = principalEntityType.AddNavigation("Dependent",
                 runtimeForeignKey,
                 onDependent: false,
@@ -263,7 +282,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var enumDiscriminator = runtimeEntityType.FindProperty("EnumDiscriminator")!;
             var id = runtimeEntityType.FindProperty("Id")!;
             var key = runtimeEntityType.FindKey(new[] { principalId, principalAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             var principal = runtimeEntityType.FindNavigation("Principal")!;
             runtimeEntityType.SetOriginalValuesFactory(
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs
index 024698d8e4..e234c20e6f 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/DependentDerivedEntityType.cs
@@ -69,6 +69,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 precision: 9,
                 scale: 3,
                 sentinel: 0m);
+            money.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<decimal>(3),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<decimal>(money, 5),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<decimal>(money),
+                (ValueBuffer valueBuffer) => valueBuffer[5]);
             money.SetPropertyIndexes(
                 index: 5,
                 originalValueIndex: 5,
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
index 45a0e6bdbb..849e4e248b 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/ManyTypesEntityType.cs
@@ -15805,7 +15805,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var uriArray = runtimeEntityType.FindProperty("UriArray")!;
             var uriToStringConverterProperty = runtimeEntityType.FindProperty("UriToStringConverterProperty")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<CompiledModelTestBase.ManyTypesId>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<CompiledModelTestBase.ManyTypesId>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<CompiledModelTestBase.ManyTypesId>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
index 1770f4357a..b843f97d86 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedType0EntityType.cs
@@ -42,6 +42,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(long),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalDerivedId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalDerivedId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalDerivedId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalDerivedId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -70,6 +76,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 typeof(Guid),
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalDerivedAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalDerivedAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalDerivedAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalDerivedAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -85,6 +97,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(2) ? entry.ReadStoreGeneratedValue<int>(2) : entry.FlaggedAsTemporary(2) && entry.ReadShadowValue<int>(2) == 0 ? entry.ReadTemporaryValue<int>(2) : entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(2),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 2),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 2),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             id.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -740,7 +758,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalDerivedId, principalDerivedAlternateId, id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
index 6e6fc09b23..2becfb8e68 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/OwnedTypeEntityType.cs
@@ -44,6 +44,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0L);
+            principalBaseId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<long>(0) == 0L ? entry.ReadTemporaryValue<long>(0) : entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<long>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<long>(principalBaseId, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<long>(principalBaseId, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             principalBaseId.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -73,6 +79,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 propertyAccessMode: PropertyAccessMode.Field,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
+            principalBaseAlternateId.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(1) ? entry.ReadStoreGeneratedValue<Guid>(1) : entry.FlaggedAsTemporary(1) && entry.ReadShadowValue<Guid>(1) == new Guid("00000000-0000-0000-0000-000000000000") ? entry.ReadTemporaryValue<Guid>(1) : entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Guid>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Guid>(principalBaseAlternateId, 1),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<Guid>(principalBaseAlternateId, 1),
+                (ValueBuffer valueBuffer) => valueBuffer[1]);
             principalBaseAlternateId.SetPropertyIndexes(
                 index: 1,
                 originalValueIndex: 1,
@@ -722,7 +734,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { principalBaseId, principalBaseAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
index 07a1461769..710532ba67 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBaseEntityType.cs
@@ -127,6 +127,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 maxLength: 55,
                 valueGeneratorFactory: new DiscriminatorValueGeneratorFactory().Create);
+            discriminator.SetAccessors(
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<string>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<string>(discriminator, 2),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<string>(discriminator),
+                (ValueBuffer valueBuffer) => valueBuffer[2]);
             discriminator.SetPropertyIndexes(
                 index: 2,
                 originalValueIndex: 2,
@@ -354,6 +360,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueConverter: new CastingConverter<Point, Point>(),
                 valueComparer: new CompiledModelTestBase.CustomValueComparer<Point>(),
                 providerValueComparer: new CompiledModelTestBase.CustomValueComparer<Point>());
+            point.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(7) ? entry.ReadStoreGeneratedValue<Point>(0) : entry.FlaggedAsTemporary(7) && entry.ReadShadowValue<Point>(1) == null ? entry.ReadTemporaryValue<Point>(0) : entry.ReadShadowValue<Point>(1),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<Point>(1),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<Point>(point, 7),
+                (InternalEntityEntry entry) => entry.GetCurrentValue<Point>(point),
+                (ValueBuffer valueBuffer) => valueBuffer[7]);
             point.SetPropertyIndexes(
                 index: 7,
                 originalValueIndex: 7,
@@ -928,10 +940,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var valueTypeIList = runtimeEntityType.FindProperty("ValueTypeIList")!;
             var valueTypeList = runtimeEntityType.FindProperty("ValueTypeList")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<long?>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNullableFactory<long?, long>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long?>(key));
             var key0 = runtimeEntityType.FindKey(new[] { id, alternateId });
-            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key0));
+            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key0));
             key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key0));
             var owned = runtimeEntityType.FindNavigation("Owned")!;
             runtimeEntityType.SetOriginalValuesFactory(
@@ -1017,10 +1029,10 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<ValueTypeList>k__BackingField")]
         public static extern ref List<short> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_ValueTypeList(CompiledModelTestBase.PrincipalBase @this);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "_ownedField")]
         public static extern ref CompiledModelTestBase.OwnedType UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase__ownedField(CompiledModelTestBase.PrincipalBase @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Deriveds>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalBase_Deriveds(CompiledModelTestBase.PrincipalBase @this);
     }
 }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
index 189a57b733..c04d9f0141 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalBasePrincipalDerivedDependentBasebyteEntityType.cs
@@ -359,7 +359,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var principalsAlternateId = runtimeEntityType.FindProperty("PrincipalsAlternateId")!;
             var rowid = runtimeEntityType.FindProperty("rowid")!;
             var key = runtimeEntityType.FindKey(new[] { derivedsId, derivedsAlternateId, principalsId, principalsAlternateId });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<IReadOnlyList<object>>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateCompositeFactory(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<IReadOnlyList<object>>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs
index defc39d712..02c2e38b09 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/BigModel_with_JSON_columns/PrincipalDerivedEntityType.cs
@@ -149,13 +149,13 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
 
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
-        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
-        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
-
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Dependent>k__BackingField")]
         public static extern ref CompiledModelTestBase.DependentBase<byte?> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Dependent(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "ManyOwned")]
         public static extern ref ICollection<CompiledModelTestBase.OwnedType> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_ManyOwned(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
+
+        [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Principals>k__BackingField")]
+        public static extern ref ICollection<CompiledModelTestBase.PrincipalBase> UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_PrincipalDerived1_Principals(CompiledModelTestBase.PrincipalDerived<CompiledModelTestBase.DependentBase<byte?>> @this);
     }
 }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs
index 87adb35ca5..704fba39a2 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DataEntityType.cs
@@ -37,6 +37,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -114,7 +120,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs
index 96a2fed56d..61f71ff418 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/CheckConstraints/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -55,25 +56,28 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "INTEGER", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "BLOB", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs
index 87adb35ca5..704fba39a2 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DataEntityType.cs
@@ -37,6 +37,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -114,7 +120,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs
index 96a2fed56d..61f71ff418 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Dynamic_schema/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -55,25 +56,28 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "INTEGER", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "BLOB", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
             pK_Data.MappedKeys.Add(pK_DataKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DataKey).Add(pK_Data);
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs
index a89c1101ac..caf73910c8 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -55,25 +56,28 @@ private IRelationalModel CreateRelationalModel()
             var dependentDerivedintTable = new Table("DependentDerived<int>", null, relationalModel);
             var idColumn = new Column("Id", "INTEGER", dependentDerivedintTable);
             dependentDerivedintTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var dataColumn = new Column("Data", "TEXT", dependentDerivedintTable)
             {
                 IsNullable = true
             };
             dependentDerivedintTable.Columns.Add("Data", dataColumn);
+            dataColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<string>(dataColumn);
+            relationalModel.Tables.Add(("DependentDerived<int>", null), dependentDerivedintTable);
+            var dependentDerivedintTableMapping = new TableMapping(dependentDerived, dependentDerivedintTable, null);
+            dependentDerivedintTable.AddTypeMapping(dependentDerivedintTableMapping, false);
+            tableMappings.Add(dependentDerivedintTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentDerivedintTableMapping);
+            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentDerivedintTableMapping);
             var pK_DependentDerivedint = new UniqueConstraint("PK_DependentDerived<int>", dependentDerivedintTable, new[] { idColumn });
             dependentDerivedintTable.PrimaryKey = pK_DependentDerivedint;
+            pK_DependentDerivedint.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_DependentDerivedint));
             var pK_DependentDerivedintKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+DependentDerived<int>",
                 new[] { "Id" });
             pK_DependentDerivedint.MappedKeys.Add(pK_DependentDerivedintKey);
             RelationalModel.GetOrCreateUniqueConstraints(pK_DependentDerivedintKey).Add(pK_DependentDerivedint);
             dependentDerivedintTable.UniqueConstraints.Add("PK_DependentDerived<int>", pK_DependentDerivedint);
-            relationalModel.Tables.Add(("DependentDerived<int>", null), dependentDerivedintTable);
-            var dependentDerivedintTableMapping = new TableMapping(dependentDerived, dependentDerivedintTable, null);
-            dependentDerivedintTable.AddTypeMapping(dependentDerivedintTableMapping, false);
-            tableMappings.Add(dependentDerivedintTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, dependentDerived.FindProperty("Id")!, dependentDerivedintTableMapping);
-            RelationalModel.CreateColumnMapping(dataColumn, dependentDerived.FindProperty("Data")!, dependentDerivedintTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
index 77b8e4cd26..a8a511c8dc 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/SimpleModel/DependentDerivedEntityType.cs
@@ -117,7 +117,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var data = runtimeEntityType.FindProperty("Data")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
@@ -160,7 +160,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
         static partial void Customize(RuntimeEntityType runtimeEntityType);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Id>k__BackingField")]
-        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentDerived<int> @this);
+        public static extern ref int UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentBase1_Id(CompiledModelTestBase.DependentBase<int> @this);
 
         [UnsafeAccessor(UnsafeAccessorKind.Field, Name = "<Data>k__BackingField")]
         public static extern ref string UnsafeAccessor_Microsoft_EntityFrameworkCore_Scaffolding_DependentDerived1_Data(CompiledModelTestBase.DependentDerived<int> @this);
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs
index 9345f59c30..5601ff4739 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DataEntityType.cs
@@ -38,6 +38,12 @@ public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType bas
                 valueGenerated: ValueGenerated.OnAdd,
                 afterSaveBehavior: PropertySaveBehavior.Throw,
                 sentinel: 0);
+            id.SetAccessors(
+                (InternalEntityEntry entry) => entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<int>(0) : entry.FlaggedAsTemporary(0) && entry.ReadShadowValue<int>(0) == 0 ? entry.ReadTemporaryValue<int>(0) : entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadShadowValue<int>(0),
+                (InternalEntityEntry entry) => entry.ReadOriginalValue<int>(id, 0),
+                (InternalEntityEntry entry) => entry.ReadRelationshipSnapshotValue<int>(id, 0),
+                (ValueBuffer valueBuffer) => valueBuffer[0]);
             id.SetPropertyIndexes(
                 index: 0,
                 originalValueIndex: 0,
@@ -121,7 +127,7 @@ public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
             var id = runtimeEntityType.FindProperty("Id")!;
             var blob = runtimeEntityType.FindProperty("Blob")!;
             var key = runtimeEntityType.FindKey(new[] { id });
-            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.Create<int>(key));
+            key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<int>(key));
             key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<int>(key));
             runtimeEntityType.SetOriginalValuesFactory(
                 (InternalEntityEntry source) =>
diff --git a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs
index 940c4912a0..3e6447a50d 100644
--- a/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs
+++ b/test/EFCore.Sqlite.FunctionalTests/Scaffolding/Baselines/Triggers/DbContextModelBuilder.cs
@@ -5,6 +5,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Update.Internal;
 
 #pragma warning disable 219, 612, 618
 #nullable disable
@@ -55,13 +56,22 @@ private IRelationalModel CreateRelationalModel()
             var dataTable = new Table("Data", null, relationalModel);
             var idColumn = new Column("Id", "INTEGER", dataTable);
             dataTable.Columns.Add("Id", idColumn);
+            idColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<int>(idColumn);
             var blobColumn = new Column("Blob", "BLOB", dataTable)
             {
                 IsNullable = true
             };
             dataTable.Columns.Add("Blob", blobColumn);
+            blobColumn.Accessors = ColumnAccessorsFactory.CreateGeneric<byte[]>(blobColumn);
+            relationalModel.Tables.Add(("Data", null), dataTable);
+            var dataTableMapping = new TableMapping(data, dataTable, null);
+            dataTable.AddTypeMapping(dataTableMapping, false);
+            tableMappings.Add(dataTableMapping);
+            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
+            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             var pK_Data = new UniqueConstraint("PK_Data", dataTable, new[] { idColumn });
             dataTable.PrimaryKey = pK_Data;
+            pK_Data.SetRowKeyValueFactory(new SimpleRowKeyValueFactory<int>(pK_Data));
             var pK_DataKey = RelationalModel.GetKey(this,
                 "Microsoft.EntityFrameworkCore.Scaffolding.CompiledModelTestBase+Data",
                 new[] { "Id" });
@@ -70,12 +80,6 @@ private IRelationalModel CreateRelationalModel()
             dataTable.UniqueConstraints.Add("PK_Data", pK_Data);
             dataTable.Triggers.Add("Trigger1", data.FindDeclaredTrigger("Trigger1"));
             dataTable.Triggers.Add("Trigger2", data.FindDeclaredTrigger("Trigger2"));
-            relationalModel.Tables.Add(("Data", null), dataTable);
-            var dataTableMapping = new TableMapping(data, dataTable, null);
-            dataTable.AddTypeMapping(dataTableMapping, false);
-            tableMappings.Add(dataTableMapping);
-            RelationalModel.CreateColumnMapping(idColumn, data.FindProperty("Id")!, dataTableMapping);
-            RelationalModel.CreateColumnMapping(blobColumn, data.FindProperty("Blob")!, dataTableMapping);
             return relationalModel.MakeReadOnly();
         }
     }
