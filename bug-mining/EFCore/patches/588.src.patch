diff --git a/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs b/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs
index 9b446a7815..7ad49bd00c 100644
--- a/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs
+++ b/src/EFCore.Cosmos/Query/Internal/CosmosQueryableMethodTranslatingExpressionVisitor.cs
@@ -16,6 +16,9 @@ namespace Microsoft.EntityFrameworkCore.Cosmos.Query.Internal;
 /// </summary>
 public class CosmosQueryableMethodTranslatingExpressionVisitor : QueryableMethodTranslatingExpressionVisitor
 {
+    private static readonly bool UseOldBehavior35094 =
+        AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue35094", out var enabled) && enabled;
+
     private readonly CosmosQueryCompilationContext _queryCompilationContext;
     private readonly ISqlExpressionFactory _sqlExpressionFactory;
     private readonly ITypeMappingSource _typeMappingSource;
@@ -445,23 +448,29 @@ private ShapedQueryExpression CreateShapedQueryExpression(SelectExpression selec
     /// </summary>
     protected override ShapedQueryExpression? TranslateAverage(ShapedQueryExpression source, LambdaExpression? selector, Type resultType)
     {
-        var selectExpression = (SelectExpression)source.QueryExpression;
-        if (selectExpression.IsDistinct
-            || selectExpression.Limit != null
-            || selectExpression.Offset != null)
+        if (UseOldBehavior35094)
         {
-            return null;
-        }
+            var selectExpression = (SelectExpression)source.QueryExpression;
+            if (selectExpression.IsDistinct
+                || selectExpression.Limit != null
+                || selectExpression.Offset != null)
+            {
+                return null;
+            }
 
-        if (selector != null)
-        {
-            source = TranslateSelect(source, selector);
-        }
+            if (selector != null)
+            {
+                source = TranslateSelect(source, selector);
+            }
 
-        var projection = (SqlExpression)selectExpression.GetMappedProjection(new ProjectionMember());
-        projection = _sqlExpressionFactory.Function("AVG", new[] { projection }, projection.Type, projection.TypeMapping);
+            var projection = (SqlExpression)selectExpression.GetMappedProjection(new ProjectionMember());
+            projection = _sqlExpressionFactory.Function("AVG", new[] { projection }, projection.Type, projection.TypeMapping);
 
-        return AggregateResultShaper(source, projection, throwOnNullResult: true, resultType);
+            return AggregateResultShaper(source, projection, throwOnNullResult: true, resultType);
+
+        }
+
+        return TranslateAggregate(source, selector, resultType, "AVG");
     }
 
     /// <summary>
@@ -843,24 +852,29 @@ protected override ShapedQueryExpression TranslateCast(ShapedQueryExpression sou
     /// </summary>
     protected override ShapedQueryExpression? TranslateMax(ShapedQueryExpression source, LambdaExpression? selector, Type resultType)
     {
-        var selectExpression = (SelectExpression)source.QueryExpression;
-        if (selectExpression.IsDistinct
-            || selectExpression.Limit != null
-            || selectExpression.Offset != null)
+        if (UseOldBehavior35094)
         {
-            return null;
-        }
+            var selectExpression = (SelectExpression)source.QueryExpression;
+            if (selectExpression.IsDistinct
+                || selectExpression.Limit != null
+                || selectExpression.Offset != null)
+            {
+                return null;
+            }
 
-        if (selector != null)
-        {
-            source = TranslateSelect(source, selector);
-        }
+            if (selector != null)
+            {
+                source = TranslateSelect(source, selector);
+            }
 
-        var projection = (SqlExpression)selectExpression.GetMappedProjection(new ProjectionMember());
+            var projection = (SqlExpression)selectExpression.GetMappedProjection(new ProjectionMember());
 
-        projection = _sqlExpressionFactory.Function("MAX", new[] { projection }, resultType, projection.TypeMapping);
+            projection = _sqlExpressionFactory.Function("MAX", new[] { projection }, resultType, projection.TypeMapping);
 
-        return AggregateResultShaper(source, projection, throwOnNullResult: true, resultType);
+            return AggregateResultShaper(source, projection, throwOnNullResult: true, resultType);
+        }
+
+        return TranslateAggregate(source, selector, resultType, "MAX");
     }
 
     /// <summary>
@@ -871,24 +885,29 @@ protected override ShapedQueryExpression TranslateCast(ShapedQueryExpression sou
     /// </summary>
     protected override ShapedQueryExpression? TranslateMin(ShapedQueryExpression source, LambdaExpression? selector, Type resultType)
     {
-        var selectExpression = (SelectExpression)source.QueryExpression;
-        if (selectExpression.IsDistinct
-            || selectExpression.Limit != null
-            || selectExpression.Offset != null)
+        if (UseOldBehavior35094)
         {
-            return null;
-        }
+            var selectExpression = (SelectExpression)source.QueryExpression;
+            if (selectExpression.IsDistinct
+                || selectExpression.Limit != null
+                || selectExpression.Offset != null)
+            {
+                return null;
+            }
 
-        if (selector != null)
-        {
-            source = TranslateSelect(source, selector);
-        }
+            if (selector != null)
+            {
+                source = TranslateSelect(source, selector);
+            }
 
-        var projection = (SqlExpression)selectExpression.GetMappedProjection(new ProjectionMember());
+            var projection = (SqlExpression)selectExpression.GetMappedProjection(new ProjectionMember());
 
-        projection = _sqlExpressionFactory.Function("MIN", new[] { projection }, resultType, projection.TypeMapping);
+            projection = _sqlExpressionFactory.Function("MIN", new[] { projection }, resultType, projection.TypeMapping);
 
-        return AggregateResultShaper(source, projection, throwOnNullResult: true, resultType);
+            return AggregateResultShaper(source, projection, throwOnNullResult: true, resultType);
+        }
+
+        return TranslateAggregate(source, selector, resultType, "MIN");
     }
 
     /// <summary>
@@ -1520,6 +1539,35 @@ protected override ShapedQueryExpression TranslateSelect(ShapedQueryExpression s
 
     #endregion Queryable collection support
 
+    private ShapedQueryExpression? TranslateAggregate(ShapedQueryExpression source, LambdaExpression? selector, Type resultType, string functionName)
+    {
+        var selectExpression = (SelectExpression)source.QueryExpression;
+        if (selectExpression.IsDistinct
+            || selectExpression.Limit != null
+            || selectExpression.Offset != null)
+        {
+            return null;
+        }
+
+        if (selector != null)
+        {
+            source = TranslateSelect(source, selector);
+        }
+
+        if (!_subquery && resultType.IsNullableType())
+        {
+            // For nullable types, we want to return null from Max, Min, and Average, rather than throwing. See Issue #35094.
+            // Note that relational databases typically return null, which propagates. Cosmos will instead return no elements,
+            // and hence for Cosmos only we need to change no elements into null.
+            source = source.UpdateResultCardinality(ResultCardinality.SingleOrDefault);
+        }
+
+        var projection = (SqlExpression)selectExpression.GetMappedProjection(new ProjectionMember());
+        projection = _sqlExpressionFactory.Function(functionName, [projection], resultType, _typeMappingSource.FindMapping(resultType));
+
+        return AggregateResultShaper(source, projection, throwOnNullResult: true, resultType);
+    }
+
     private bool TryApplyPredicate(ShapedQueryExpression source, LambdaExpression predicate)
     {
         var select = (SelectExpression)source.QueryExpression;
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/AdHocMiscellaneousQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/AdHocMiscellaneousQueryCosmosTest.cs
index 7fc328c16f..e2dd2b9090 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/AdHocMiscellaneousQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/AdHocMiscellaneousQueryCosmosTest.cs
@@ -1,6 +1,8 @@
 // Licensed to the .NET Foundation under one or more agreements.
 // The .NET Foundation licenses this file to you under the MIT license.
 
+using System.ComponentModel.DataAnnotations.Schema;
+
 namespace Microsoft.EntityFrameworkCore.Query;
 
 #nullable disable
@@ -50,6 +52,115 @@ public enum MemberType
 
     #endregion 34911
 
+    #region 35094
+
+    // TODO: Move these tests to a better location. They require nullable properties with nulls in the database.
+
+    [ConditionalFact]
+    public virtual async Task Min_over_value_type_containing_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().MinAsync(p => p.NullableVal));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Min_over_value_type_containing_all_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().Where(e => e.NullableVal == null).MinAsync(p => p.NullableVal));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Min_over_reference_type_containing_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().MinAsync(p => p.NullableRef));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Min_over_reference_type_containing_all_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().Where(e => e.NullableRef == null).MinAsync(p => p.NullableRef));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Min_over_reference_type_containing_no_data()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().Where(e => e.Id < 0).MinAsync(p => p.NullableRef));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Max_over_value_type_containing_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Equal(3.14, await context.Set<Context35094.Product>().MaxAsync(p => p.NullableVal));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Max_over_value_type_containing_all_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().Where(e => e.NullableVal == null).MaxAsync(p => p.NullableVal));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Max_over_reference_type_containing_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Equal("Value", await context.Set<Context35094.Product>().MaxAsync(p => p.NullableRef));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Max_over_reference_type_containing_all_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().Where(e => e.NullableRef == null).MaxAsync(p => p.NullableRef));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Max_over_reference_type_containing_no_data()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().Where(e => e.Id < 0).MaxAsync(p => p.NullableRef));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Average_over_value_type_containing_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().AverageAsync(p => p.NullableVal));
+    }
+
+    [ConditionalFact]
+    public virtual async Task Average_over_value_type_containing_all_nulls()
+    {
+        await using var context = (await InitializeAsync<Context35094>()).CreateContext();
+        Assert.Null(await context.Set<Context35094.Product>().Where(e => e.NullableVal == null).AverageAsync(p => p.NullableVal));
+    }
+
+    protected class Context35094(DbContextOptions options) : DbContext(options)
+    {
+        public DbSet<Product> Products { get; set; }
+
+        protected override void OnModelCreating(ModelBuilder modelBuilder)
+            => modelBuilder.Entity<Product>().HasData(
+                new Product { Id = 1, NullableRef = "Value", NullableVal = 3.14 },
+                new Product { Id = 2, NullableVal = 3.14 },
+                new Product { Id = 3, NullableRef = "Value" });
+
+        public class Product
+        {
+            [DatabaseGenerated(DatabaseGeneratedOption.None)]
+            public int Id { get; set; }
+            public double? NullableVal { get; set; }
+            public string NullableRef { get; set; }
+        }
+    }
+
+    #endregion 35094
+
     protected override string StoreName
         => "AdHocMiscellaneousQueryTests";
 
diff --git a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindAggregateOperatorsQueryCosmosTest.cs b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindAggregateOperatorsQueryCosmosTest.cs
index 2d30fc87c9..6f1291dbec 100644
--- a/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindAggregateOperatorsQueryCosmosTest.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/Query/NorthwindAggregateOperatorsQueryCosmosTest.cs
@@ -555,49 +555,33 @@ public override async Task Average_no_data(bool async)
         }
     }
 
-    public override async Task Average_no_data_nullable(bool async)
-    {
-        // Sync always throws before getting to exception being tested.
-        if (async)
-        {
-            await Fixture.NoSyncTest(
-                async, async a =>
-                {
-                    Assert.Equal(
-                        CoreStrings.SequenceContainsNoElements,
-                        (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Average_no_data_nullable(a))).Message);
+    public override Task Average_no_data_nullable(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Average_no_data_nullable(a);
 
-                    AssertSql(
-                        """
+                AssertSql(
+                    """
 SELECT VALUE AVG(c["SupplierID"])
 FROM root c
 WHERE ((c["$type"] = "Product") AND (c["SupplierID"] = -1))
 """);
-                });
-        }
-    }
+            });
 
-    public override async Task Average_no_data_cast_to_nullable(bool async)
-    {
-        // Sync always throws before getting to exception being tested.
-        if (async)
-        {
-            await Fixture.NoSyncTest(
-                async, async a =>
-                {
-                    Assert.Equal(
-                        CoreStrings.SequenceContainsNoElements,
-                        (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Average_no_data_cast_to_nullable(a))).Message);
+    public override Task Average_no_data_cast_to_nullable(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Average_no_data_cast_to_nullable(a);
 
-                    AssertSql(
-                        """
+                AssertSql(
+                    """
 SELECT VALUE AVG(c["OrderID"])
 FROM root c
 WHERE ((c["$type"] = "Order") AND (c["OrderID"] = -1))
 """);
-                });
-        }
-    }
+            });
 
     public override async Task Min_no_data(bool async)
     {
@@ -647,49 +631,33 @@ public override async Task Max_no_data_subquery(bool async)
         AssertSql();
     }
 
-    public override async Task Max_no_data_nullable(bool async)
-    {
-        // Sync always throws before getting to exception being tested.
-        if (async)
-        {
-            await Fixture.NoSyncTest(
-                async, async a =>
-                {
-                    Assert.Equal(
-                        CoreStrings.SequenceContainsNoElements,
-                        (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Max_no_data_nullable(a))).Message);
+    public override Task Max_no_data_nullable(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Max_no_data_nullable(a);
 
-                    AssertSql(
-                        """
+                AssertSql(
+                    """
 SELECT VALUE MAX(c["SupplierID"])
 FROM root c
 WHERE ((c["$type"] = "Product") AND (c["SupplierID"] = -1))
 """);
-                });
-        }
-    }
+            });
 
-    public override async Task Max_no_data_cast_to_nullable(bool async)
-    {
-        // Sync always throws before getting to exception being tested.
-        if (async)
-        {
-            await Fixture.NoSyncTest(
-                async, async a =>
-                {
-                    Assert.Equal(
-                        CoreStrings.SequenceContainsNoElements,
-                        (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Max_no_data_cast_to_nullable(a))).Message);
+    public override Task Max_no_data_cast_to_nullable(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Max_no_data_cast_to_nullable(a);
 
-                    AssertSql(
-                        """
+                AssertSql(
+                    """
 SELECT VALUE MAX(c["OrderID"])
 FROM root c
 WHERE ((c["$type"] = "Order") AND (c["OrderID"] = -1))
 """);
-                });
-        }
-    }
+            });
 
     public override async Task Min_no_data_subquery(bool async)
     {
@@ -699,22 +667,19 @@ public override async Task Min_no_data_subquery(bool async)
         AssertSql();
     }
 
-    public override async Task Average_with_no_arg(bool async)
-    {
-        // Always throws for sync.
-        if (async)
-        {
-            // Average truncates. Issue #26378.
-            await Assert.ThrowsAsync<EqualException>(async () => await base.Average_with_no_arg(async));
+    public override Task Average_with_no_arg(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Average_with_no_arg(a);
 
-            AssertSql(
-                """
+                AssertSql(
+                    """
 SELECT VALUE AVG(c["OrderID"])
 FROM root c
 WHERE (c["$type"] = "Order")
 """);
-        }
-    }
+            });
 
     public override Task Average_with_binary_expression(bool async)
         => Fixture.NoSyncTest(
@@ -730,22 +695,19 @@ public override Task Average_with_binary_expression(bool async)
 """);
             });
 
-    public override async Task Average_with_arg(bool async)
-    {
-        // Always throws for sync.
-        if (async)
-        {
-            // Average truncates. Issue #26378.
-            await Assert.ThrowsAsync<EqualException>(async () => await base.Average_with_arg(async));
+    public override Task Average_with_arg(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Average_with_arg(a);
 
-            AssertSql(
-                """
+                AssertSql(
+                    """
 SELECT VALUE AVG(c["OrderID"])
 FROM root c
 WHERE (c["$type"] = "Order")
 """);
-        }
-    }
+            });
 
     public override Task Average_with_arg_expression(bool async)
         => Fixture.NoSyncTest(
@@ -874,49 +836,33 @@ public override Task Min_with_arg(bool async)
 """);
             });
 
-    public override async Task Min_no_data_nullable(bool async)
-    {
-        // Sync always throws before getting to exception being tested.
-        if (async)
-        {
-            await Fixture.NoSyncTest(
-                async, async a =>
-                {
-                    Assert.Equal(
-                        CoreStrings.SequenceContainsNoElements,
-                        (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Min_no_data_nullable(a))).Message);
+    public override  Task Min_no_data_nullable(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Min_no_data_nullable(a);
 
-                    AssertSql(
-                        """
+                AssertSql(
+                    """
 SELECT VALUE MIN(c["SupplierID"])
 FROM root c
 WHERE ((c["$type"] = "Product") AND (c["SupplierID"] = -1))
 """);
-                });
-        }
-    }
+            });
 
-    public override async Task Min_no_data_cast_to_nullable(bool async)
-    {
-        // Sync always throws before getting to exception being tested.
-        if (async)
-        {
-            await Fixture.NoSyncTest(
-                async, async a =>
-                {
-                    Assert.Equal(
-                        CoreStrings.SequenceContainsNoElements,
-                        (await Assert.ThrowsAsync<InvalidOperationException>(() => base.Min_no_data_cast_to_nullable(a))).Message);
+    public override Task Min_no_data_cast_to_nullable(bool async)
+        => Fixture.NoSyncTest(
+            async, async a =>
+            {
+                await base.Min_no_data_cast_to_nullable(a);
 
-                    AssertSql(
-                        """
+                AssertSql(
+                    """
 SELECT VALUE MIN(c["OrderID"])
 FROM root c
 WHERE ((c["$type"] = "Order") AND (c["OrderID"] = -1))
 """);
-                });
-        }
-    }
+            });
 
     public override Task Min_with_coalesce(bool async)
         => Fixture.NoSyncTest(
