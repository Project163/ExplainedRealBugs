diff --git a/src/EFCore.Sqlite.Core/Migrations/SqliteMigrationsSqlGenerator.cs b/src/EFCore.Sqlite.Core/Migrations/SqliteMigrationsSqlGenerator.cs
index a795487e7e..d55783c7d9 100644
--- a/src/EFCore.Sqlite.Core/Migrations/SqliteMigrationsSqlGenerator.cs
+++ b/src/EFCore.Sqlite.Core/Migrations/SqliteMigrationsSqlGenerator.cs
@@ -312,7 +312,7 @@ private bool IsSpatialiteColumn(AddColumnOperation operation, IModel? model)
                     createTableOperation.PrimaryKey = AddPrimaryKeyOperation.CreateFrom(primaryKey);
                 }
 
-                foreach (var column in table.Columns.Where(c => c.Order.HasValue).OrderBy(c => c.Order.Value)
+                foreach (var column in table.Columns.Where(c => c.Order.HasValue).OrderBy(c => c.Order!.Value)
                     .Concat(table.Columns.Where(c => !c.Order.HasValue)))
                 {
                     if (!column.TryGetDefaultValue(out var defaultValue))
diff --git a/src/EFCore/ChangeTracking/Internal/ArrayPropertyValues.cs b/src/EFCore/ChangeTracking/Internal/ArrayPropertyValues.cs
index 37057dd792..3d73296372 100644
--- a/src/EFCore/ChangeTracking/Internal/ArrayPropertyValues.cs
+++ b/src/EFCore/ChangeTracking/Internal/ArrayPropertyValues.cs
@@ -42,7 +42,7 @@ public ArrayPropertyValues(InternalEntityEntry internalEntry, object?[] values)
         ///     doing so can result in application failures when updating to a new Entity Framework Core release.
         /// </summary>
         public override object ToObject()
-            => MaterializerSource.GetMaterializer(EntityType)(
+            => EntityType.GetOrCreateMaterializer(MaterializerSource)(
                 new MaterializationContext(
                     new ValueBuffer(_values),
                     InternalEntry.StateManager.Context));
diff --git a/src/EFCore/ChangeTracking/Internal/StateManager.cs b/src/EFCore/ChangeTracking/Internal/StateManager.cs
index d917b18555..5c6e4d6578 100644
--- a/src/EFCore/ChangeTracking/Internal/StateManager.cs
+++ b/src/EFCore/ChangeTracking/Internal/StateManager.cs
@@ -319,7 +319,7 @@ public virtual InternalEntityEntry CreateEntry(IDictionary<string, object?> valu
             }
 
             var valueBuffer = new ValueBuffer(valuesArray);
-            var entity = EntityMaterializerSource.GetMaterializer(entityType)(new MaterializationContext(valueBuffer, Context));
+            var entity = entityType.GetOrCreateMaterializer(EntityMaterializerSource)(new MaterializationContext(valueBuffer, Context));
 
             var shadowPropertyValueBuffer = new ValueBuffer(shadowPropertyValuesArray);
             var entry = new InternalEntityEntry(this, entityType, entity, shadowPropertyValueBuffer);
diff --git a/src/EFCore/Metadata/IReadOnlyEntityType.cs b/src/EFCore/Metadata/IReadOnlyEntityType.cs
index 9ac725b545..9a0de40860 100644
--- a/src/EFCore/Metadata/IReadOnlyEntityType.cs
+++ b/src/EFCore/Metadata/IReadOnlyEntityType.cs
@@ -12,6 +12,8 @@
 using Microsoft.EntityFrameworkCore.Diagnostics;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Query;
+using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Utilities;
 
 namespace Microsoft.EntityFrameworkCore.Metadata
@@ -803,6 +805,15 @@ IReadOnlyProperty GetProperty(string name)
         /// <returns>The service properties defined on this entity type.</returns>
         IEnumerable<IReadOnlyServiceProperty> GetServiceProperties();
 
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        [EntityFrameworkInternal]
+        Func<MaterializationContext, object> GetOrCreateMaterializer(IEntityMaterializerSource source);
+
         /// <summary>
         ///     <para>
         ///         Creates a human-readable representation of the given metadata.
diff --git a/src/EFCore/Metadata/Internal/EntityType.cs b/src/EFCore/Metadata/Internal/EntityType.cs
index 0fc132447e..79e4df70da 100644
--- a/src/EFCore/Metadata/Internal/EntityType.cs
+++ b/src/EFCore/Metadata/Internal/EntityType.cs
@@ -13,6 +13,7 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Builders;
+using Microsoft.EntityFrameworkCore.Query;
 using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
 using Microsoft.EntityFrameworkCore.Utilities;
@@ -3551,6 +3552,16 @@ private void UpdateServiceOnlyConstructorBindingConfigurationSource(Configuratio
             => _serviceOnlyConstructorBindingConfigurationSource =
                 configurationSource.Max(_serviceOnlyConstructorBindingConfigurationSource);
 
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        [EntityFrameworkInternal]
+        public virtual Func<MaterializationContext, object> GetOrCreateMaterializer(IEntityMaterializerSource source)
+            => source.GetMaterializer(this);
+
         #endregion
 
         #region Explicit interface implementations
diff --git a/src/EFCore/Metadata/RuntimeEntityType.cs b/src/EFCore/Metadata/RuntimeEntityType.cs
index 6bed5afc9e..73d0255f8c 100644
--- a/src/EFCore/Metadata/RuntimeEntityType.cs
+++ b/src/EFCore/Metadata/RuntimeEntityType.cs
@@ -13,6 +13,8 @@
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Internal;
 using Microsoft.EntityFrameworkCore.Metadata.Internal;
+using Microsoft.EntityFrameworkCore.Query;
+using Microsoft.EntityFrameworkCore.Query.Internal;
 using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
 using Microsoft.EntityFrameworkCore.ValueGeneration;
@@ -72,6 +74,7 @@ public class RuntimeEntityType : AnnotatableBase, IRuntimeEntityType
         private Func<MaterializationContext, object>? _instanceFactory;
         private IProperty[]? _foreignKeyProperties;
         private IProperty[]? _valueGeneratingProperties;
+        private Func<MaterializationContext, object>? _materializer;
 
         /// <summary>
         ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
@@ -814,6 +817,20 @@ private IEnumerable<RuntimeServiceProperty> GetDerivedServiceProperties()
         public static PropertyInfo? FindIndexerProperty(Type type)
             => type.FindIndexerProperty();
 
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        [EntityFrameworkInternal]
+        public virtual Func<MaterializationContext, object> GetOrCreateMaterializer(IEntityMaterializerSource source)
+            => EntityMaterializerSource.UseOldBehavior31866
+                ? source.GetMaterializer(this)
+                : NonCapturingLazyInitializer.EnsureInitialized(
+                    ref _materializer, this, source,
+                    static (e, s) => s.GetMaterializer(e));
+
         /// <summary>
         ///     Returns a string that represents the current object.
         /// </summary>
diff --git a/src/EFCore/Query/Internal/EntityMaterializerSource.cs b/src/EFCore/Query/Internal/EntityMaterializerSource.cs
index ceeaaff771..ac34d6b1e4 100644
--- a/src/EFCore/Query/Internal/EntityMaterializerSource.cs
+++ b/src/EFCore/Query/Internal/EntityMaterializerSource.cs
@@ -31,6 +31,15 @@ namespace Microsoft.EntityFrameworkCore.Query.Internal
     /// </summary>
     public class EntityMaterializerSource : IEntityMaterializerSource
     {
+        /// <summary>
+        ///     This is an internal API that supports the Entity Framework Core infrastructure and not subject to
+        ///     the same compatibility standards as public APIs. It may be changed or removed without notice in
+        ///     any release. You should only use it directly in your code with extreme caution and knowing that
+        ///     doing so can result in application failures when updating to a new Entity Framework Core release.
+        /// </summary>
+        public static readonly bool UseOldBehavior31866 =
+            AppContext.TryGetSwitch("Microsoft.EntityFrameworkCore.Issue31866", out var enabled31866) && enabled31866;
+
         private ConcurrentDictionary<IEntityType, Func<MaterializationContext, object>>? _materializers;
 
         /// <summary>
@@ -146,16 +155,21 @@ static Expression CreateMemberAssignment(Expression parameter, MemberInfo member
         ///     doing so can result in application failures when updating to a new Entity Framework Core release.
         /// </summary>
         public virtual Func<MaterializationContext, object> GetMaterializer(IEntityType entityType)
-            => Materializers.GetOrAdd(
-                entityType, e =>
-                    {
-                        var materializationContextParameter
-                            = Expression.Parameter(typeof(MaterializationContext), "materializationContext");
-
-                        return Expression.Lambda<Func<MaterializationContext, object>>(
-                                CreateMaterializeExpression(e, "instance", materializationContextParameter),
-                                materializationContextParameter)
-                            .Compile();
-                    });
+        {
+            return UseOldBehavior31866
+                ? Materializers.GetOrAdd(entityType, static (e, s) => CreateMaterializer(s, e), this)
+                : CreateMaterializer(this, entityType);
+
+            static Func<MaterializationContext, object> CreateMaterializer(EntityMaterializerSource self, IEntityType e)
+            {
+                var materializationContextParameter
+                    = Expression.Parameter(typeof(MaterializationContext), "materializationContext");
+
+                return Expression.Lambda<Func<MaterializationContext, object>>(
+                        self.CreateMaterializeExpression(e, "instance", materializationContextParameter),
+                        materializationContextParameter)
+                    .Compile();
+            }
+        }
     }
 }
diff --git a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
index 1bdbb0b6f4..33e8aa9d9c 100644
--- a/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
+++ b/test/EFCore.Cosmos.FunctionalTests/TestUtilities/CosmosTestStore.cs
@@ -15,6 +15,7 @@
 using Microsoft.EntityFrameworkCore.Cosmos.Storage.Internal;
 using Microsoft.EntityFrameworkCore.Infrastructure;
 using Microsoft.EntityFrameworkCore.Metadata;
+using Microsoft.EntityFrameworkCore.Query;
 using Microsoft.EntityFrameworkCore.Storage;
 using Microsoft.EntityFrameworkCore.Update;
 using Newtonsoft.Json;
@@ -562,6 +563,9 @@ public IEnumerable<IForeignKey> GetReferencingForeignKeys()
             public IEnumerable<IServiceProperty> GetServiceProperties()
                 => throw new NotImplementedException();
 
+            public Func<MaterializationContext, object> GetOrCreateMaterializer(IEntityMaterializerSource source)
+                => throw new NotImplementedException();
+
             public IEnumerable<ISkipNavigation> GetSkipNavigations()
                 => throw new NotImplementedException();
 
