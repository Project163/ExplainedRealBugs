diff --git a/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java b/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
index 497a1516..fc1b2c02 100644
--- a/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
+++ b/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
@@ -72,44 +72,62 @@ public class FTPTimestampParserImpl implements
 	public Calendar parseTimestamp(String timestampStr) throws ParseException {
 		Calendar now = Calendar.getInstance();
 		now.setTimeZone(this.getServerTimeZone());
-		
+
 		Calendar working = Calendar.getInstance();
-		working.setTimeZone(this.getServerTimeZone());
+		working.setTimeZone(getServerTimeZone());
 		ParsePosition pp = new ParsePosition(0);
 
 		Date parsed = null;
-		if (this.recentDateFormat != null) {
+		if (recentDateFormat != null) {
 			parsed = recentDateFormat.parse(timestampStr, pp);
 		}
 		if (parsed != null && pp.getIndex() == timestampStr.length()) 
 		{
 			working.setTime(parsed);
 			working.set(Calendar.YEAR, now.get(Calendar.YEAR));
-			
-			if (this.lenientFutureDates) {
-			    // add a day to "now" so that "slop" doesn't cause a date 
-			    // slightly in the future to roll back a full year.  (Bug 35181)
-			    now.add(Calendar.DATE, 1);
+
+			if (lenientFutureDates) {
+				// add a day to "now" so that "slop" doesn't cause a date 
+				// slightly in the future to roll back a full year.  (Bug 35181)
+				now.add(Calendar.DATE, 1);
 			}    
 			if (working.after(now)) {
 				working.add(Calendar.YEAR, -1);
 			}
 		} else {
-			pp = new ParsePosition(0);
-			parsed = defaultDateFormat.parse(timestampStr, pp);
-			// note, length checks are mandatory for us since
-			// SimpleDateFormat methods will succeed if less than
-			// full string is matched.  They will also accept, 
-			// despite "leniency" setting, a two-digit number as
-			// a valid year (e.g. 22:04 will parse as 22 A.D.) 
-			// so could mistakenly confuse an hour with a year, 
-			// if we don't insist on full length parsing.
-			if (parsed != null && pp.getIndex() == timestampStr.length()) {
+			// Temporarily add the current year to the short date time
+			// to cope with short-date leap year strings.
+			// e.g. Java's DateFormatter will assume that "Feb 29 12:00" refers to 
+			// Feb 29 1970 (an invalid date) rather than a potentially valid leap year date.
+			// TODO This is a HORRENDOUS hack. Remove at first opportunity.
+			if (recentDateFormat != null) {
+				pp = new ParsePosition(0);
+				int year = Calendar.getInstance().get(Calendar.YEAR);
+				String timeStampStrPlusYear = timestampStr + " " + year;
+				SimpleDateFormat hackFormatter = new SimpleDateFormat(recentDateFormat.toPattern() + " yyyy");
+				hackFormatter.setLenient(false);
+				parsed = hackFormatter.parse(timeStampStrPlusYear, pp);
+			}
+			if (parsed != null && pp.getIndex() == timestampStr.length() + 5) {
 				working.setTime(parsed);
-			} else {
-				throw new ParseException(
-					"Timestamp could not be parsed with older or recent DateFormat", 
-					pp.getIndex());
+			}
+			else {
+				pp = new ParsePosition(0);
+				parsed = defaultDateFormat.parse(timestampStr, pp);
+				// note, length checks are mandatory for us since
+				// SimpleDateFormat methods will succeed if less than
+				// full string is matched.  They will also accept, 
+				// despite "leniency" setting, a two-digit number as
+				// a valid year (e.g. 22:04 will parse as 22 A.D.) 
+				// so could mistakenly confuse an hour with a year, 
+				// if we don't insist on full length parsing.
+				if (parsed != null && pp.getIndex() == timestampStr.length()) {
+					working.setTime(parsed);
+				} else {
+					throw new ParseException(
+							"Timestamp could not be parsed with older or recent DateFormat", 
+							pp.getIndex());
+				}
 			}
 		}
 		return working;
