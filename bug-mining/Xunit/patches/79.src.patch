diff --git a/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs b/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
index c8d9557d..532e75f6 100644
--- a/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
+++ b/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
@@ -32,12 +32,11 @@ public IEnumerable<IXunitTestCase> Discover(ITestFrameworkDiscoveryOptions disco
             if (factAttribute.GetNamedArgument<string>("Skip") != null)
                 return new[] { new XunitTestCase(diagnosticMessageSink, defaultMethodDisplay, testMethod) };
 
-            var dataAttributes = testMethod.Method.GetCustomAttributes(typeof(DataAttribute));
-
             if (discoveryOptions.PreEnumerateTheoriesOrDefault())
             {
                 try
                 {
+                    var dataAttributes = testMethod.Method.GetCustomAttributes(typeof(DataAttribute));
                     var results = new List<XunitTestCase>();
 
                     foreach (var dataAttribute in dataAttributes)
@@ -51,8 +50,8 @@ public IEnumerable<IXunitTestCase> Discover(ITestFrameworkDiscoveryOptions disco
                         // down below so that we get the composite test case.
                         foreach (var dataRow in discoverer.GetData(dataAttribute, testMethod.Method))
                         {
-                            // Determine whether we can serialize the test case, since we need a way to uniquely 
-                            // identify a test and serialization is the best way to do that. If it's not serializable, 
+                            // Determine whether we can serialize the test case, since we need a way to uniquely
+                            // identify a test and serialization is the best way to do that. If it's not serializable,
                             // this will throw and we will fall back to a single theory test case that gets its data at runtime.
                             var testCase = new XunitTestCase(diagnosticMessageSink, defaultMethodDisplay, testMethod, dataRow);
                             if (!SerializationHelper.IsSerializable(dataRow))
diff --git a/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs b/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
index 95b8f7bf..01218a87 100644
--- a/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
+++ b/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
@@ -2,8 +2,10 @@
 using System.Collections;
 using System.Collections.Generic;
 using System.Linq;
+using System.Reflection;
 using Xunit;
 using Xunit.Abstractions;
+using Xunit.Sdk;
 
 public class Xunit2TheoryAcceptanceTests
 {
@@ -680,6 +682,38 @@ class ClassWithBaseClassData : BaseClass
         }
     }
 
+    public class CustomDataTests : AcceptanceTestV2
+    {
+        [Fact]
+        public void TestDataWithInternalConstructor_ReturnsSingleFailingTheory()
+        {
+            var testMessages = Run<IMessageSinkMessage>(typeof(ClassWithCustomDataWithInternalDataCtor));
+
+            var types = testMessages.Select(t => t.GetType()).ToList();
+
+            Assert.Collection(testMessages.OfType<ITestFailed>().OrderBy(t => t.TestCase.DisplayName),
+                failed => Assert.Equal("Constructor on type 'Xunit2TheoryAcceptanceTests+CustomDataTests+MyCustomData' not found.", failed.Messages[0])
+            );
+            Assert.Empty(testMessages.OfType<ITestPassed>());
+            Assert.Empty(testMessages.OfType<ITestSkipped>());
+        }
+
+        internal class MyCustomData : DataAttribute
+        {
+            internal MyCustomData() { }
+
+            public override IEnumerable<object[]> GetData(MethodInfo testMethod)
+                => new[] { new object[] { 42 }, new object[] { 2112 } };
+        }
+
+        class ClassWithCustomDataWithInternalDataCtor
+        {
+            [Theory]
+            [MyCustomData]
+            public void Passing(int unused) { }
+        }
+    }
+
     public class ErrorAggregation : AcceptanceTestV2
     {
         [Fact]
