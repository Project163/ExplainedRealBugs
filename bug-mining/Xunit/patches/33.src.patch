diff --git a/src/common/TestOptionsNames.cs b/src/common/TestOptionsNames.cs
index a9a92cd9..94c4831a 100644
--- a/src/common/TestOptionsNames.cs
+++ b/src/common/TestOptionsNames.cs
@@ -15,7 +15,7 @@ internal static class Discovery
         public static readonly string DiagnosticMessages = "xunit.discovery.DiagnosticMessages";
         public static readonly string MethodDisplay = "xunit.discovery.MethodDisplay";
         public static readonly string PreEnumerateTheories = "xunit.discovery.PreEnumerateTheories";
-        public static readonly string SynchronousMessageReporting = "xunit.SynchronousMessageReporting";
+        public static readonly string SynchronousMessageReporting = "xunit.discovery.SynchronousMessageReporting";
     }
 
     internal static class Execution
diff --git a/src/xunit.execution/Sdk/Frameworks/TestFrameworkDiscoverer.cs b/src/xunit.execution/Sdk/Frameworks/TestFrameworkDiscoverer.cs
index 237824f0..99ffe6a3 100644
--- a/src/xunit.execution/Sdk/Frameworks/TestFrameworkDiscoverer.cs
+++ b/src/xunit.execution/Sdk/Frameworks/TestFrameworkDiscoverer.cs
@@ -108,12 +108,10 @@ public void Find(bool includeSourceInformation, IMessageSink messageSink, ITestF
             });
         }
 
-        private IMessageBus CreateMessageBus(IMessageSink messageSink, ITestFrameworkOptions options)
+        private static IMessageBus CreateMessageBus(IMessageSink messageSink, ITestFrameworkOptions options)
         {
             if (options.GetValue(TestOptionsNames.Discovery.SynchronousMessageReporting, false))
-            {
                 return new SynchronousMessageBus(messageSink);
-            }
 
             return new MessageBus(messageSink);
         }
diff --git a/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs b/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
index 3c070846..0464e8da 100644
--- a/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
+++ b/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
@@ -28,35 +28,38 @@ public IEnumerable<IXunitTestCase> Discover(ITestFrameworkDiscoveryOptions disco
             {
                 try
                 {
-                    var results = new List<XunitTestCase>();
-
-                    foreach (var dataAttribute in dataAttributes)
+                    using (var memoryStream = new MemoryStream())
                     {
-                        var discovererAttribute = dataAttribute.GetCustomAttributes(typeof(DataDiscovererAttribute)).First();
-                        var discoverer = ExtensibilityPointFactory.GetDataDiscoverer(discovererAttribute);
-                        if (!discoverer.SupportsDiscoveryEnumeration(dataAttribute, testMethod.Method))
-                            return new XunitTestCase[] { new XunitTheoryTestCase(defaultMethodDisplay, testMethod) };
+                        var results = new List<XunitTestCase>();
 
-                        // GetData may return null, but that's okay; we'll let the NullRef happen and then catch it
-                        // down below so that we get the composite test case.
-                        foreach (var dataRow in discoverer.GetData(dataAttribute, testMethod.Method))
+                        foreach (var dataAttribute in dataAttributes)
                         {
-                            // Attempt to serialize the test case, since we need a way to uniquely identify a test
-                            // and serialization is the best way to do that. If it's not serializable, this will
-                            // throw and we will fall back to a single theory test case that gets its data
-                            // at runtime.
-                            var testCase = new XunitTestCase(defaultMethodDisplay, testMethod, dataRow);
-                            SerializationHelper.Serialize(testCase);
-                            results.Add(testCase);
+                            var discovererAttribute = dataAttribute.GetCustomAttributes(typeof(DataDiscovererAttribute)).First();
+                            var discoverer = ExtensibilityPointFactory.GetDataDiscoverer(discovererAttribute);
+                            if (!discoverer.SupportsDiscoveryEnumeration(dataAttribute, testMethod.Method))
+                                return new XunitTestCase[] { new XunitTheoryTestCase(defaultMethodDisplay, testMethod) };
+
+                            // GetData may return null, but that's okay; we'll let the NullRef happen and then catch it
+                            // down below so that we get the composite test case.
+                            foreach (var dataRow in discoverer.GetData(dataAttribute, testMethod.Method))
+                            {
+                                // Attempt to serialize the test case, since we need a way to uniquely identify a test
+                                // and serialization is the best way to do that. If it's not serializable, this will
+                                // throw and we will fall back to a single theory test case that gets its data
+                                // at runtime.
+                                var testCase = new XunitTestCase(defaultMethodDisplay, testMethod, dataRow);
+                                SerializationHelper.Serialize(testCase);
+                                results.Add(testCase);
+                            }
                         }
-                    }
 
-                    // REVIEW: Could we re-write LambdaTestCase to just be for exceptions?
-                    if (results.Count == 0)
-                        results.Add(new LambdaTestCase(defaultMethodDisplay, testMethod,
-                                                       () => { throw new InvalidOperationException(String.Format("No data found for {0}.{1}", testMethod.TestClass.Class.Name, testMethod.Method.Name)); }));
+                        // REVIEW: Could we re-write LambdaTestCase to just be for exceptions?
+                        if (results.Count == 0)
+                            results.Add(new LambdaTestCase(defaultMethodDisplay, testMethod,
+                                                           () => { throw new InvalidOperationException(String.Format("No data found for {0}.{1}", testMethod.TestClass.Class.Name, testMethod.Method.Name)); }));
 
-                    return results;
+                        return results;
+                    }
                 }
                 catch { }
             }
