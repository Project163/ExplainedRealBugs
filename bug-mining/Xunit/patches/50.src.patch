diff --git a/src/common/NewReflectionExtensions.cs b/src/common/NewReflectionExtensions.cs
index 150b9e4b..08bee062 100644
--- a/src/common/NewReflectionExtensions.cs
+++ b/src/common/NewReflectionExtensions.cs
@@ -26,6 +26,25 @@ public static bool IsEnum(this Type type)
 #endif
     }
 
+    public static bool IsFromLocalAssembly(this Type type)
+    {
+        var assemblyName = type.GetAssembly().GetName().Name;
+
+        try
+        {
+#if NEW_REFLECTION
+            Assembly.Load(new AssemblyName { Name = assemblyName });
+#else
+            Assembly.Load(assemblyName);
+#endif
+            return true;
+        }
+        catch
+        {
+            return false;
+        }
+    }
+
     public static bool IsGenericType(this Type type)
     {
 #if NEW_REFLECTION
diff --git a/src/common/XunitSerializationInfo.cs b/src/common/XunitSerializationInfo.cs
index f94e521c..cc57e5ae 100644
--- a/src/common/XunitSerializationInfo.cs
+++ b/src/common/XunitSerializationInfo.cs
@@ -230,10 +230,19 @@ public static string Serialize(object value)
 
             var typeData = value as Type;
             if (typeData != null)
+            {
+                if (!typeData.IsFromLocalAssembly())
+                    throw new ArgumentException(String.Format("We cannot serialize type {0} because it lives in the GAC", typeData.FullName), "value");
                 return SerializationHelper.GetTypeNameForSerialization(typeData);
+            }
 
-            if (value.GetType().IsEnum())
+            var valueType = value.GetType();
+            if (valueType.IsEnum())
+            {
+                if (!valueType.IsFromLocalAssembly())
+                    throw new ArgumentException(String.Format("We cannot serialize enum {0}.{1} because it lives in the GAC", valueType.FullName, value), "value");
                 return value.ToString();
+            }
 
             var array = value as object[];
             if (array != null)
@@ -244,7 +253,7 @@ public static string Serialize(object value)
                 return info.ToSerializedString();
             }
 
-            throw new ArgumentException("We don't know how to serialize type " + value.GetType().FullName, "value");
+            throw new ArgumentException("We don't know how to serialize type " + valueType.FullName, "value");
         }
 
         static readonly Type[] supportedSerializationTypes = new[] {
diff --git a/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs b/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
index b868b945..16012e65 100644
--- a/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
+++ b/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
@@ -525,7 +525,6 @@ public void TestViaMethodData(int x, double y, string z)
                 Assert.NotNull(z);
             }
         }
-
     }
 
     public class PropertyDataTests : AcceptanceTest
diff --git a/test/test.xunit.execution/Common/SerializationHelperTests.cs b/test/test.xunit.execution/Common/SerializationHelperTests.cs
index 58022dc2..1ffa09f1 100644
--- a/test/test.xunit.execution/Common/SerializationHelperTests.cs
+++ b/test/test.xunit.execution/Common/SerializationHelperTests.cs
@@ -27,7 +27,7 @@ public static void CanRoundTripSerializedTypeNames(Type type, string expectedNam
     {
         var name = SerializationHelper.GetTypeNameForSerialization(type);
 
-        Assert.Equal<object>(expectedName, name);
+        Assert.Equal(expectedName, name);
 
         var deserializedType = SerializationHelper.GetType(name);
 
diff --git a/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs b/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
index fa1953e7..f1a69b07 100644
--- a/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
+++ b/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
@@ -1,6 +1,7 @@
 ï»¿using System;
 using System.Collections.Generic;
 using System.Net;
+using System.Xml;
 using Xunit;
 using Xunit.Abstractions;
 using Xunit.Serialization;
@@ -32,9 +33,9 @@ public static IEnumerable<object[]> SupportedIntrinsics
             yield return new object[] { typeof(bool), true };
             yield return new object[] { typeof(bool?), false };
             yield return new object[] { typeof(bool?), null };
-            yield return new object[] { typeof(HttpStatusCode), HttpStatusCode.OK };
-            yield return new object[] { typeof(HttpStatusCode?), HttpStatusCode.PartialContent };
-            yield return new object[] { typeof(HttpStatusCode?), null };
+            yield return new object[] { typeof(MyEnum), MyEnum.SomeValue };
+            yield return new object[] { typeof(MyEnum?), MyEnum.SomeValue };
+            yield return new object[] { typeof(MyEnum?), null };
             yield return new object[] { typeof(DateTime), DateTime.Now };
             yield return new object[] { typeof(DateTime?), DateTime.UtcNow };
             yield return new object[] { typeof(DateTime?), null };
@@ -43,10 +44,12 @@ public static IEnumerable<object[]> SupportedIntrinsics
             yield return new object[] { typeof(DateTimeOffset?), null };
             yield return new object[] { typeof(Type), typeof(object) };
             yield return new object[] { typeof(Type), null };
-            yield return new object[] { typeof(object[]), new object[] { int.MinValue, long.MaxValue, null, "", 1.1f, -2.2, decimal.MaxValue, true, HttpStatusCode.OK, DateTime.Now, DateTimeOffset.UtcNow, typeof(decimal) } };
+            yield return new object[] { typeof(object[]), new object[] { int.MinValue, long.MaxValue, null, "", 1.1f, -2.2, decimal.MaxValue, true, MyEnum.SomeValue, DateTime.Now, DateTimeOffset.UtcNow, typeof(decimal) } };
         }
     }
 
+    enum MyEnum { SomeValue }
+
     public class Serialize
     {
         [Theory]
@@ -78,6 +81,70 @@ public static void UnsupportedTypeThrows()
             Assert.Equal("value", argEx.ParamName);
             Assert.StartsWith("We don't know how to serialize type System.Object", argEx.Message);
         }
+
+        [Fact]
+        public static void CanSerializeEnumFromMscorlib()
+        {
+            var data = Base64FormattingOptions.InsertLineBreaks;
+
+            var result = XunitSerializationInfo.Serialize(data);
+
+            Assert.Equal("InsertLineBreaks", result);
+        }
+
+        [Fact]
+        public static void CanSerializeEnumFromLocalAssembly()
+        {
+            var data = MyEnum.SomeValue;
+
+            var result = XunitSerializationInfo.Serialize(data);
+
+            Assert.Equal("SomeValue", result);
+        }
+
+        [Fact]
+        public static void CannotSerializeEnumFromGAC()
+        {
+            var data = ConformanceLevel.Auto;
+
+            var ex = Record.Exception(() => XunitSerializationInfo.Serialize(data));
+
+            var argEx = Assert.IsType<ArgumentException>(ex);
+            Assert.Equal("value", argEx.ParamName);
+            Assert.StartsWith("We cannot serialize enum System.Xml.ConformanceLevel.Auto because it lives in the GAC", argEx.Message);
+        }
+
+        [Fact]
+        public static void CanSerializeTypeFromMscorlib()
+        {
+            var data = typeof(string);
+
+            var result = XunitSerializationInfo.Serialize(data);
+
+            Assert.Equal("System.String", result);
+        }
+
+        [Fact]
+        public static void CanSerializeTypeFromLocalAssembly()
+        {
+            var data = typeof(XunitSerializationInfo);
+
+            var result = XunitSerializationInfo.Serialize(data);
+
+            Assert.Equal("Xunit.Serialization.XunitSerializationInfo, test.xunit.execution", result);
+        }
+
+        [Fact]
+        public static void CannotSerializeTypeFromGAC()
+        {
+            var data = typeof(XmlDocument);
+
+            var ex = Record.Exception(() => XunitSerializationInfo.Serialize(data));
+
+            var argEx = Assert.IsType<ArgumentException>(ex);
+            Assert.Equal("value", argEx.ParamName);
+            Assert.StartsWith("We cannot serialize type System.Xml.XmlDocument because it lives in the GAC", argEx.Message);
+        }
     }
 
     public class SerializeTriple
diff --git a/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs b/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs
index b7fd52ca..29d03196 100644
--- a/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs
+++ b/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs
@@ -2,6 +2,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
+using System.Xml;
 using Xunit;
 using Xunit.Abstractions;
 using Xunit.Sdk;
@@ -167,6 +168,28 @@ class NonSerializableDataClass
         public void TheoryMethod(object a) { }
     }
 
+    [Fact]
+    public void TheoryWithNonSerializableEnumYieldsSingleTheoryTestCase()
+    {
+        var discoverer = TestableTheoryDiscoverer.Create();
+        var testMethod = Mocks.TestMethod(typeof(NonSerializableEnumDataClass), "TheTest");
+        var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();
+
+        var testCases = discoverer.Discover(discoveryOptions, testMethod, factAttribute);
+
+        var testCase = Assert.Single(testCases);
+        var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);
+        Assert.Equal("TheoryDiscovererTests+NonSerializableEnumDataClass.TheTest", theoryTestCase.DisplayName);
+    }
+
+    public class NonSerializableEnumDataClass
+    {
+        [Theory]
+        [InlineData(42)]
+        [InlineData(ConformanceLevel.Auto)]
+        public void TheTest(object x) { }
+    }
+
     [Fact]
     public void NonDiscoveryEnumeratedDataYieldsSingleTheoryTestCase()
     {
