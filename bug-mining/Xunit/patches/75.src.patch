diff --git a/src/xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandler.cs b/src/xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandler.cs
index 4218bf6e..29a4fbc1 100644
--- a/src/xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandler.cs
+++ b/src/xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandler.cs
@@ -1,6 +1,8 @@
 using System;
+using System.Collections.Generic;
 using System.IO;
 using System.Linq;
+using System.Threading;
 using Xunit.Abstractions;
 
 namespace Xunit
@@ -12,6 +14,8 @@ namespace Xunit
     public class DefaultRunnerReporterMessageHandler : TestMessageVisitor
     {
         readonly string defaultDirectory = null;
+        readonly ITestFrameworkExecutionOptions defaultExecutionOptions = TestFrameworkOptions.ForExecution();
+        readonly Dictionary<string, ITestFrameworkExecutionOptions> executionOptionsByAssembly = new Dictionary<string, ITestFrameworkExecutionOptions>(StringComparer.OrdinalIgnoreCase);
 
         /// <summary>
         /// Initializes a new instance of the <see cref="DefaultRunnerReporterMessageHandler"/> class.
@@ -31,6 +35,12 @@ public DefaultRunnerReporterMessageHandler(IRunnerLogger logger)
         /// </summary>
         protected IRunnerLogger Logger { get; private set; }
 
+        void AddExecutionOptions(string assemblyFilename, ITestFrameworkExecutionOptions executionOptions)
+        {
+            using (ReaderWriterLockWrapper.WriteLock())
+                executionOptionsByAssembly[assemblyFilename] = executionOptions;
+        }
+
         /// <summary>
         /// Escapes text for display purposes.
         /// </summary>
@@ -64,6 +74,23 @@ protected virtual string GetAssemblyDisplayName(XunitProjectAssembly assembly)
             return Path.GetFileNameWithoutExtension(assembly.AssemblyFilename);
         }
 
+        /// <summary>
+        /// Get the test framework options for the given assembly. If it cannot find them, then it
+        /// returns a default set of options.
+        /// </summary>
+        /// <param name="assemblyFilename">The test assembly filename</param>
+        /// <returns></returns>
+        protected ITestFrameworkExecutionOptions GetExecutionOptions(string assemblyFilename)
+        {
+            ITestFrameworkExecutionOptions result;
+
+            using (ReaderWriterLockWrapper.ReadLock())
+                if (!executionOptionsByAssembly.TryGetValue(assemblyFilename, out result))
+                    result = defaultExecutionOptions;
+
+            return result;
+        }
+
         /// <summary>
         /// Logs an error message to the logger.
         /// </summary>
@@ -71,10 +98,10 @@ protected virtual string GetAssemblyDisplayName(XunitProjectAssembly assembly)
         /// <param name="failureInfo">The failure information</param>
         protected void LogError(string failureType, IFailureInformation failureInfo)
         {
+            var frameInfo = StackFrameInfo.FromFailure(failureInfo);
+
             lock (Logger.LockObject)
             {
-                var frameInfo = StackFrameInfo.FromFailure(failureInfo);
-
                 Logger.LogError(frameInfo, "    [{0}] {1}", failureType, Escape(failureInfo.ExceptionTypes.FirstOrDefault() ?? "(Unknown Exception Type)"));
 
                 foreach (var messageLine in ExceptionUtility.CombineMessages(failureInfo).Split(new[] { Environment.NewLine }, StringSplitOptions.None))
@@ -98,6 +125,31 @@ protected virtual void LogStackTrace(StackFrameInfo frameInfo, string stackTrace
                 Logger.LogImportantMessage(frameInfo, "        {0}", StackFrameTransformer.TransformFrame(stackFrame, defaultDirectory));
         }
 
+        /// <summary>
+        /// Lots test output to the logger.
+        /// </summary>
+        protected virtual void LogOutput(StackFrameInfo frameInfo, string output)
+        {
+            if (string.IsNullOrEmpty(output))
+                return;
+
+            // ITestOutputHelper terminates everything with NewLine, but we really don't need that
+            // extra blank line in our output.
+            if (output.EndsWith(Environment.NewLine))
+                output = output.Substring(0, output.Length - Environment.NewLine.Length);
+
+            Logger.LogMessage(frameInfo, "      Output:");
+
+            foreach (var line in output.Split(new[] { Environment.NewLine }, StringSplitOptions.None))
+                Logger.LogImportantMessage(frameInfo, "        {0}", line);
+        }
+
+        void RemoveExecutionOptions(string assemblyFilename)
+        {
+            using (ReaderWriterLockWrapper.WriteLock())
+                executionOptionsByAssembly.Remove(assemblyFilename);
+        }
+
         /// <inheritdoc/>
         protected override bool Visit(IErrorMessage error)
         {
@@ -146,12 +198,16 @@ protected override bool Visit(ITestAssemblyExecutionFinished executionFinished)
         {
             Logger.LogImportantMessage("  Finished:    {0}", GetAssemblyDisplayName(executionFinished.Assembly));
 
+            RemoveExecutionOptions(executionFinished.Assembly.AssemblyFilename);
+
             return base.Visit(executionFinished);
         }
 
         /// <inheritdoc/>
         protected override bool Visit(ITestAssemblyExecutionStarting executionStarting)
         {
+            AddExecutionOptions(executionStarting.Assembly.AssemblyFilename, executionStarting.ExecutionOptions);
+
             var assemblyDisplayName = GetAssemblyDisplayName(executionStarting.Assembly);
 
             if (executionStarting.ExecutionOptions.GetDiagnosticMessagesOrDefault())
@@ -216,16 +272,17 @@ protected override bool Visit(ITestExecutionSummary executionSummary)
         /// <inheritdoc/>
         protected override bool Visit(ITestFailed testFailed)
         {
+            var frameInfo = StackFrameInfo.FromFailure(testFailed);
+
             lock (Logger.LockObject)
             {
-                var frameInfo = StackFrameInfo.FromFailure(testFailed);
-
                 Logger.LogError(frameInfo, "    {0} [FAIL]", Escape(testFailed.Test.DisplayName));
 
                 foreach (var messageLine in ExceptionUtility.CombineMessages(testFailed).Split(new[] { Environment.NewLine }, StringSplitOptions.None))
                     Logger.LogImportantMessage(frameInfo, "      {0}", messageLine);
 
                 LogStackTrace(frameInfo, ExceptionUtility.CombineStackTraces(testFailed));
+                LogOutput(frameInfo, testFailed.Output);
             }
 
             return base.Visit(testFailed);
@@ -239,6 +296,22 @@ protected override bool Visit(ITestMethodCleanupFailure cleanupFailure)
             return base.Visit(cleanupFailure);
         }
 
+        /// <inheritdoc/>
+        protected override bool Visit(ITestPassed testPassed)
+        {
+            if (!string.IsNullOrEmpty(testPassed.Output) &&
+                GetExecutionOptions(testPassed.TestAssembly.Assembly.AssemblyPath).GetDiagnosticMessagesOrDefault())
+            {
+                lock (Logger.LockObject)
+                {
+                    Logger.LogImportantMessage("    {0} [PASS]", Escape(testPassed.Test.DisplayName));
+                    LogOutput(StackFrameInfo.None, testPassed.Output);
+                }
+            }
+
+            return base.Visit(testPassed);
+        }
+
         /// <inheritdoc/>
         protected override bool Visit(ITestSkipped testSkipped)
         {
@@ -307,5 +380,36 @@ public static void WriteDefaultSummary(IRunnerLogger logger, ITestExecutionSumma
                                            executionSummary.ElapsedClockTime.TotalSeconds.ToString("0.000s"));
             }
         }
+
+        class ReaderWriterLockWrapper : IDisposable
+        {
+            static readonly ReaderWriterLockSlim @lock = new ReaderWriterLockSlim();
+            static readonly ReaderWriterLockWrapper lockForRead = new ReaderWriterLockWrapper(() => @lock.ExitReadLock());
+            static readonly ReaderWriterLockWrapper lockForWrite = new ReaderWriterLockWrapper(() => @lock.ExitWriteLock());
+
+            readonly Action unlock;
+
+            ReaderWriterLockWrapper(Action unlock)
+            {
+                this.unlock = unlock;
+            }
+
+            public void Dispose()
+            {
+                unlock();
+            }
+
+            public static IDisposable ReadLock()
+            {
+                @lock.EnterReadLock();
+                return lockForRead;
+            }
+
+            public static IDisposable WriteLock()
+            {
+                @lock.EnterWriteLock();
+                return lockForWrite;
+            }
+        }
     }
 }
diff --git a/src/xunit.runner.utility/Extensibility/IRunnerReporter.cs b/src/xunit.runner.utility/Extensibility/IRunnerReporter.cs
index 107195d9..f404ca3a 100644
--- a/src/xunit.runner.utility/Extensibility/IRunnerReporter.cs
+++ b/src/xunit.runner.utility/Extensibility/IRunnerReporter.cs
@@ -1,5 +1,3 @@
-using System;
-using System.Collections.Generic;
 using Xunit.Abstractions;
 
 namespace Xunit
diff --git a/test/test.utility/Mocks.cs b/test/test.utility/Mocks.cs
index 0534d405..b99f2804 100644
--- a/test/test.utility/Mocks.cs
+++ b/test/test.utility/Mocks.cs
@@ -235,9 +235,9 @@ public static ITestAssemblyExecutionFinished TestAssemblyExecutionFinished(bool
         return result;
     }
 
-    public static ITestAssemblyExecutionStarting TestAssemblyExecutionStarting(bool diagnosticMessages = false)
+    public static ITestAssemblyExecutionStarting TestAssemblyExecutionStarting(bool diagnosticMessages = false, string assemblyFilename = null)
     {
-        var assembly = new XunitProjectAssembly { AssemblyFilename = "testAssembly.dll", ConfigFilename = "testAssembly.dll.config", ShadowCopy = true };
+        var assembly = new XunitProjectAssembly { AssemblyFilename = assemblyFilename ?? "testAssembly.dll", ConfigFilename = "testAssembly.dll.config", ShadowCopy = true };
         var config = new TestAssemblyConfiguration { DiagnosticMessages = diagnosticMessages, MethodDisplay = Xunit.TestMethodDisplay.ClassAndMethod, MaxParallelThreads = 42, ParallelizeTestCollections = true };
         var result = Substitute.For<ITestAssemblyExecutionStarting, InterfaceProxy<ITestAssemblyExecutionStarting>>();
         result.Assembly.Returns(assembly);
diff --git a/test/test.xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandlerTests.cs b/test/test.xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandlerTests.cs
index 0f8f682b..b290decc 100644
--- a/test/test.xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandlerTests.cs
+++ b/test/test.xunit.runner.utility/Extensibility/DefaultRunnerReporterMessageHandlerTests.cs
@@ -207,7 +207,7 @@ public class OnMessage_ITestFailed : DefaultRunnerReporterMessageHandlerTests
         [Fact]
         public void LogsTestNameWithExceptionAndStackTraceAndOutput()
         {
-            var message = Mocks.TestFailed("This is my display name \t\r\n", 1.2345M, output: "This is\t\r\noutput");
+            var message = Mocks.TestFailed("This is my display name \t\r\n", 1.2345M, output: "This is\t" + Environment.NewLine + "output");
             SetupFailureInformation(message);
             var handler = TestableDefaultRunnerReporterMessageHandler.Create();
 
@@ -220,7 +220,42 @@ public void LogsTestNameWithExceptionAndStackTraceAndOutput()
                 msg => Assert.Equal("[--- @ SomeFolder\\SomeClass.cs:18] =>       Stack Trace:", msg),
                 msg => Assert.Equal("[Imp @ SomeFolder\\SomeClass.cs:18] =>         Line 1", msg),
                 msg => Assert.Equal("[Imp @ SomeFolder\\SomeClass.cs:18] =>         SomeFolder\\SomeClass.cs(18,0): at SomeClass.SomeMethod()", msg),
-                msg => Assert.Equal("[Imp @ SomeFolder\\SomeClass.cs:18] =>         Line 3", msg)
+                msg => Assert.Equal("[Imp @ SomeFolder\\SomeClass.cs:18] =>         Line 3", msg),
+                msg => Assert.Equal("[--- @ SomeFolder\\SomeClass.cs:18] =>       Output:", msg),
+                msg => Assert.Equal("[Imp @ SomeFolder\\SomeClass.cs:18] =>         This is\t", msg),
+                msg => Assert.Equal("[Imp @ SomeFolder\\SomeClass.cs:18] =>         output", msg)
+            );
+        }
+    }
+
+    public class OnMessage_ITestPassed
+    {
+        [Fact]
+        public void DoesNotLogOutputByDefault()
+        {
+            var message = Mocks.TestPassed("This is my display name \t\r\n", output: "This is\t" + Environment.NewLine + "output");
+            var handler = TestableDefaultRunnerReporterMessageHandler.Create();
+
+            handler.OnMessage(message);
+
+            Assert.Empty(handler.Messages);
+        }
+
+        [Fact]
+        public void LogsOutputWhenDiagnosticsAreEnabled()
+        {
+            var message = Mocks.TestPassed("This is my display name \t\r\n", output: "This is\t" + Environment.NewLine + "output");
+            var handler = TestableDefaultRunnerReporterMessageHandler.Create();
+            handler.OnMessage(Mocks.TestAssemblyExecutionStarting(diagnosticMessages: true, assemblyFilename: message.TestAssembly.Assembly.AssemblyPath));
+            handler.Messages.Clear();  // Ignore any output from the "assembly execution starting" message
+
+            handler.OnMessage(message);
+
+            Assert.Collection(handler.Messages,
+                msg => Assert.Equal("[Imp] =>     This is my display name \\t\\r\\n [PASS]", msg),
+                msg => Assert.Equal("[---] =>       Output:", msg),
+                msg => Assert.Equal("[Imp] =>         This is\t", msg),
+                msg => Assert.Equal("[Imp] =>         output", msg)
             );
         }
     }
@@ -246,7 +281,7 @@ public static void LogsTestNameAsWarning()
 
     class TestableDefaultRunnerReporterMessageHandler : DefaultRunnerReporterMessageHandler
     {
-        public IReadOnlyList<string> Messages;
+        public List<string> Messages;
 
         TestableDefaultRunnerReporterMessageHandler(SpyRunnerLogger logger)
             : base(logger)
