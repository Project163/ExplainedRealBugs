diff --git a/NuGet.Config b/NuGet.Config
index 2d54ae1f..f3b47050 100644
--- a/NuGet.Config
+++ b/NuGet.Config
@@ -1,12 +1,11 @@
-<?xml version="1.0" encoding="utf-8"?>
+ï»¿<?xml version="1.0" encoding="utf-8"?>
 <configuration>
+  <activePackageSource>
+    <add key="All" value="(Aggregate source)" />
+  </activePackageSource>
   <packageSources>
     <add key="Public Feed" value="https://nuget.org/api/v2/" />
     <add key="Dev Packages (xunit)" value="http://www.myget.org/F/b4ff5f68eccf4f6bbfed74f055f88d8f/" />
     <add key="CI Packages (aspnetrelease)" value="http://www.myget.org/F/aspnetrelease/" />
   </packageSources>
-  <disabledPackageSources />
-  <activePackageSource>
-    <add key="All" value="(Aggregate source)"  />
-  </activePackageSource>
 </configuration>
diff --git a/src/xunit.core/IClassFixture.cs b/src/xunit.core/IClassFixture.cs
index 66ff9a89..38314681 100644
--- a/src/xunit.core/IClassFixture.cs
+++ b/src/xunit.core/IClassFixture.cs
@@ -6,8 +6,10 @@
     /// the first test in the class is run, and if it implements IDisposable, is disposed
     /// after the last test in the class is run. To gain access to the fixture data from
     /// inside the test, a constructor argument should be added to the test class which
-    /// exactly matches the <typeparamref name="TFixture"/>.
+    /// exactly matches the <typeparamref name="TFixture"/>. Class fixtures must have a
+    /// single parameterless constructor, and may take collection fixture types as constructor
+    /// arguments.
     /// </summary>
     /// <typeparam name="TFixture">The type of the fixture.</typeparam>
-    public interface IClassFixture<TFixture> where TFixture : class, new() { }
+    public interface IClassFixture<TFixture> where TFixture : class { }
 }
diff --git a/src/xunit.core/ICollectionFixture.cs b/src/xunit.core/ICollectionFixture.cs
index 4492130e..ffa61fde 100644
--- a/src/xunit.core/ICollectionFixture.cs
+++ b/src/xunit.core/ICollectionFixture.cs
@@ -9,5 +9,5 @@
     /// exactly matches the <typeparamref name="TFixture"/>.
     /// </summary>
     /// <typeparam name="TFixture">The type of the fixture.</typeparam>
-    public interface ICollectionFixture<TFixture> where TFixture : class, new() { }
+    public interface ICollectionFixture<TFixture> where TFixture : class { }
 }
diff --git a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs
index 3cda36d4..6184efe6 100644
--- a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs
+++ b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs
@@ -48,10 +48,43 @@ public class XunitTestClassRunner : TestClassRunner<IXunitTestCase>
         /// </summary>
         protected Dictionary<Type, object> ClassFixtureMappings { get; set; }
 
-        void CreateFixture(Type fixtureGenericInterfaceType)
+        /// <summary>
+        /// Creates the instance of a class fixture type to be used by the test class. If the fixture can be created,
+        /// it should be placed into the <see cref="ClassFixtureMappings"/> dictionary; if it cannot, then the method
+        /// should record the error by calling <code>Aggregator.Add</code>.
+        /// </summary>
+        /// <param name="fixtureType">The type of the fixture to be created</param>
+        protected virtual void CreateClassFixture(Type fixtureType)
         {
-            var fixtureType = fixtureGenericInterfaceType.GetTypeInfo().GenericTypeArguments.Single();
-            Aggregator.Run(() => ClassFixtureMappings[fixtureType] = Activator.CreateInstance(fixtureType));
+            var ctors = fixtureType.GetTypeInfo()
+                                   .DeclaredConstructors
+                                   .Where(ci => !ci.IsStatic && ci.IsPublic)
+                                   .ToList();
+
+            if (ctors.Count != 1)
+            {
+                Aggregator.Add(new TestClassException(string.Format("Class fixture type '{0}' may only define a single public constructor.", fixtureType.FullName)));
+                return;
+            }
+
+            var ctor = ctors[0];
+            var missingParameters = new List<ParameterInfo>();
+            var ctorArgs = ctor.GetParameters().Select(p =>
+            {
+                object arg;
+                if (!collectionFixtureMappings.TryGetValue(p.ParameterType, out arg))
+                    missingParameters.Add(p);
+                return arg;
+            }).ToArray();
+
+            if (missingParameters.Count > 0)
+                Aggregator.Add(new TestClassException(
+                    string.Format("Class fixture type '{0}' had one or more unresolved constructor arguments: {1}",
+                                    fixtureType.FullName,
+                                    string.Join(", ", missingParameters.Select(p => string.Format("{0} {1}", p.ParameterType.Name, p.Name))))
+                ));
+            else
+                Aggregator.Run(() => ClassFixtureMappings[fixtureType] = ctor.Invoke(ctorArgs));
         }
 
         /// <inheritdoc/>
@@ -91,13 +124,13 @@ protected override Task AfterTestClassStartingAsync()
                 Aggregator.Add(new TestClassException("A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead)."));
 
             foreach (var interfaceType in testClassTypeInfo.ImplementedInterfaces.Where(i => i.GetTypeInfo().IsGenericType && i.GetGenericTypeDefinition() == typeof(IClassFixture<>)))
-                CreateFixture(interfaceType);
+                CreateClassFixture(interfaceType.GetTypeInfo().GenericTypeArguments.Single());
 
             if (TestClass.TestCollection.CollectionDefinition != null)
             {
                 var declarationType = ((IReflectionTypeInfo)TestClass.TestCollection.CollectionDefinition).Type;
                 foreach (var interfaceType in declarationType.GetTypeInfo().ImplementedInterfaces.Where(i => i.GetTypeInfo().IsGenericType && i.GetGenericTypeDefinition() == typeof(IClassFixture<>)))
-                    CreateFixture(interfaceType);
+                    CreateClassFixture(interfaceType.GetTypeInfo().GenericTypeArguments.Single());
             }
 
             return CommonTasks.Completed;
diff --git a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs
index 8353dec9..e6a0ff40 100644
--- a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs
+++ b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs
@@ -44,9 +44,14 @@ public class XunitTestCollectionRunner : TestCollectionRunner<IXunitTestCase>
         /// </summary>
         protected Dictionary<Type, object> CollectionFixtureMappings { get; set; }
 
-        void CreateFixture(Type fixtureGenericInterfaceType)
+        /// <summary>
+        /// Creates the instance of a collection fixture type to be used by the test collection. If the fixture can be created,
+        /// it should be placed into the <see cref="CollectionFixtureMappings"/> dictionary; if it cannot, then the method
+        /// should record the error by calling <code>Aggregator.Add</code>.
+        /// </summary>
+        /// <param name="fixtureType">The type of the fixture to be created</param>
+        protected virtual void CreateCollectionFixture(Type fixtureType)
         {
-            var fixtureType = fixtureGenericInterfaceType.GenericTypeArguments.Single();
             Aggregator.Run(() => CollectionFixtureMappings[fixtureType] = Activator.CreateInstance(fixtureType));
         }
 
@@ -57,7 +62,7 @@ protected override Task AfterTestCollectionStartingAsync()
             {
                 var declarationType = ((IReflectionTypeInfo)TestCollection.CollectionDefinition).Type;
                 foreach (var interfaceType in declarationType.GetTypeInfo().ImplementedInterfaces.Where(i => i.GetTypeInfo().IsGenericType && i.GetGenericTypeDefinition() == typeof(ICollectionFixture<>)))
-                    CreateFixture(interfaceType);
+                    CreateCollectionFixture(interfaceType.GenericTypeArguments.Single());
 
                 var ordererAttribute = TestCollection.CollectionDefinition.GetCustomAttributes(typeof(TestCaseOrdererAttribute)).SingleOrDefault();
                 if (ordererAttribute != null)
diff --git a/test/test.xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunnerTests.cs b/test/test.xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunnerTests.cs
index c96fdb86..8c5a7b1e 100644
--- a/test/test.xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunnerTests.cs
+++ b/test/test.xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunnerTests.cs
@@ -99,7 +99,7 @@ public static async void CreatesFixturesFromClassAndCollection()
 
         Assert.Collection(runner.ClassFixtureMappings.OrderBy(mapping => mapping.Key.Name),
             mapping => Assert.IsType<FixtureUnderTest>(mapping.Value),
-            mapping => Assert.IsType<Object>(mapping.Value)
+            mapping => Assert.IsType<object>(mapping.Value)
         );
     }
 
@@ -115,6 +115,74 @@ public static async void DisposesFixtures()
         Assert.True(fixtureUnderTest.Disposed);
     }
 
+    [Fact]
+    public static async void MultiplePublicConstructorsOnClassFixture_ReturnsError()
+    {
+        var testCase = Mocks.XunitTestCase<TestClassWithMultiCtorClassFixture>("Passing");
+        var runner = TestableXunitTestClassRunner.Create(testCase);
+
+        await runner.RunAsync();
+
+        var ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);
+        Assert.Equal("Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithMultipleConstructors' may only define a single public constructor.", ex.Message);
+    }
+
+    class ClassFixtureWithMultipleConstructors
+    {
+        public ClassFixtureWithMultipleConstructors() { }
+        public ClassFixtureWithMultipleConstructors(int unused) { }
+    }
+
+    class TestClassWithMultiCtorClassFixture : IClassFixture<ClassFixtureWithMultipleConstructors>
+    {
+        [Fact]
+        public void Passing() { }
+    }
+
+    [Fact]
+    public static async void UnresolvedConstructorParameterOnClassFixture_ReturnsError()
+    {
+        var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>("Passing");
+        var runner = TestableXunitTestClassRunner.Create(testCase);
+
+        await runner.RunAsync();
+
+        var ex = Assert.IsType<TestClassException>(runner.RunTestMethodAsync_AggregatorResult);
+        Assert.Equal("Class fixture type 'XunitTestClassRunnerTests+ClassFixtureWithCollectionFixtureDependency' had one or more unresolved constructor arguments: DependentCollectionFixture collectionFixture", ex.Message);
+    }
+
+    [Fact]
+    public static async void CanInjectCollectionFixtureIntoClassFixture()
+    {
+        var testCase = Mocks.XunitTestCase<TestClassWithClassFixtureWithDependency>("Passing");
+        var collectionFixture = new DependentCollectionFixture();
+        var runner = TestableXunitTestClassRunner.Create(testCase, collectionFixture);
+
+        await runner.RunAsync();
+
+        Assert.Null(runner.RunTestMethodAsync_AggregatorResult);
+        var classFixture = runner.ClassFixtureMappings.Values.OfType<ClassFixtureWithCollectionFixtureDependency>().Single();
+        Assert.Same(collectionFixture, classFixture.CollectionFixture);
+    }
+
+    class DependentCollectionFixture { }
+
+    class ClassFixtureWithCollectionFixtureDependency
+    {
+        public DependentCollectionFixture CollectionFixture;
+
+        public ClassFixtureWithCollectionFixtureDependency(DependentCollectionFixture collectionFixture)
+        {
+            CollectionFixture = collectionFixture;
+        }
+    }
+
+    class TestClassWithClassFixtureWithDependency : IClassFixture<ClassFixtureWithCollectionFixtureDependency>
+    {
+        [Fact]
+        public void Passing() { }
+    }
+
     public class TestCaseOrderer
     {
         [Fact]
@@ -176,9 +244,7 @@ public MyCtorThrowingTestCaseOrderer()
             }
 
             public IEnumerable<TTestCase> OrderTestCases<TTestCase>(IEnumerable<TTestCase> testCases) where TTestCase : ITestCase
-            {
-                return Enumerable.Empty<TTestCase>();
-            }
+                => Enumerable.Empty<TTestCase>();
         }
     }
 
@@ -221,11 +287,8 @@ class ClassUnderTest : IClassFixture<FixtureUnderTest>
 
     class CustomTestCaseOrderer : ITestCaseOrderer
     {
-        public IEnumerable<TTestCase> OrderTestCases<TTestCase>(IEnumerable<TTestCase> testCases)
-            where TTestCase : ITestCase
-        {
-            return testCases;
-        }
+        public IEnumerable<TTestCase> OrderTestCases<TTestCase>(IEnumerable<TTestCase> testCases) where TTestCase : ITestCase
+            => testCases;
     }
 
     class TestableXunitTestClassRunner : XunitTestClassRunner
@@ -249,18 +312,13 @@ class TestableXunitTestClassRunner : XunitTestClassRunner
         }
 
         public new Dictionary<Type, object> ClassFixtureMappings
-        {
-            get { return base.ClassFixtureMappings; }
-        }
+            => base.ClassFixtureMappings;
 
         public new ITestCaseOrderer TestCaseOrderer
-        {
-            get { return base.TestCaseOrderer; }
-        }
+            => base.TestCaseOrderer;
 
         public static TestableXunitTestClassRunner Create(IXunitTestCase testCase, params object[] collectionFixtures)
-        {
-            return new TestableXunitTestClassRunner(
+            => new TestableXunitTestClassRunner(
                 testCase.TestMethod.TestClass,
                 (IReflectionTypeInfo)testCase.TestMethod.TestClass.Class,
                 new[] { testCase },
@@ -271,7 +329,6 @@ public static TestableXunitTestClassRunner Create(IXunitTestCase testCase, param
                 new CancellationTokenSource(),
                 collectionFixtures.ToDictionary(fixture => fixture.GetType())
             );
-        }
 
         protected override Task<RunSummary> RunTestMethodAsync(ITestMethod testMethod, IReflectionMethodInfo method, IEnumerable<IXunitTestCase> testCases, object[] constructorArguments)
         {
