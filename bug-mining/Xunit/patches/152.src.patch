diff --git a/src/xunit.v3.common/Internal/AssemblyExtensions.cs b/src/xunit.v3.common/Internal/AssemblyExtensions.cs
index fb54c15c..9c97c91f 100644
--- a/src/xunit.v3.common/Internal/AssemblyExtensions.cs
+++ b/src/xunit.v3.common/Internal/AssemblyExtensions.cs
@@ -21,7 +21,7 @@ public static class AssemblyExtensions
 		/// <summary/>
 		[return: NotNullIfNotNull("assembly")]
 		public static string? GetLocalCodeBase(this Assembly? assembly) =>
-			GetLocalCodeBase(assembly?.CodeBase, Path.DirectorySeparatorChar);
+			GetLocalCodeBase(assembly?.GetSafeCodeBase(), Path.DirectorySeparatorChar);
 
 		/// <summary/>
 		[return: NotNullIfNotNull("codeBase")]
@@ -61,6 +61,24 @@ public static class AssemblyExtensions
 			throw new ArgumentException($"Unknown directory separator '{directorySeparator}'; must be one of '/' or '\\'.", nameof(directorySeparator));
 		}
 
+		/// <summary>
+		/// Safely gets the code base of an assembly.
+		/// </summary>
+		/// <param name="assembly">The assembly.</param>
+		/// <returns>If the assembly is null, or is dynamic, then it returns <c>null</c>; otherwise, it returns the value
+		/// from <see cref="Assembly.CodeBase"/>.</returns>
+		public static string? GetSafeCodeBase(this Assembly? assembly) =>
+			assembly == null || assembly.IsDynamic ? null : assembly.CodeBase;
+
+		/// <summary>
+		/// Safely gets the location of an assembly.
+		/// </summary>
+		/// <param name="assembly">The assembly.</param>
+		/// <returns>If the assembly is null, or is dynamic, then it returns <c>null</c>; otherwise, it returns the value
+		/// from <see cref="Assembly.Location"/>.</returns>
+		public static string? GetSafeLocation(this Assembly? assembly) =>
+			assembly == null || assembly.IsDynamic ? null : assembly.Location;
+
 		/// <summary>
 		/// Gets the target framework name for the given assembly.
 		/// </summary>
diff --git a/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs b/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs
index 52d81cf7..ba6a16ef 100644
--- a/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs
+++ b/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs
@@ -83,22 +83,25 @@ public IReadOnlyCollection<_IAttributeInfo> GetCustomAttributes(string assemblyQ
 		/// <inheritdoc/>
 		public IReadOnlyCollection<_ITypeInfo> GetTypes(bool includePrivateTypes)
 		{
-			var selector = includePrivateTypes ? Assembly.DefinedTypes.Select(t => t.AsType()) : Assembly.ExportedTypes;
-
 			try
 			{
-				return selector
-					.Select(t => Reflector.Wrap(t))
-					.Cast<_ITypeInfo>()
-					.CastOrToReadOnlyCollection();
+				return
+					Assembly
+						.DefinedTypes
+						.Where(t => includePrivateTypes || t.IsPublic || t.IsNestedPublic)
+						.Select(t => Reflector.Wrap(t.AsType()))
+						.Cast<_ITypeInfo>()
+						.CastOrToReadOnlyCollection();
 			}
 			catch (ReflectionTypeLoadException ex)
 			{
-				return ex.Types
-					.WhereNotNull()
-					.Select(t => Reflector.Wrap(t))
-					.Cast<_ITypeInfo>()
-					.CastOrToReadOnlyCollection();
+				return
+					ex
+						.Types
+						.WhereNotNull()
+						.Select(t => Reflector.Wrap(t))
+						.Cast<_ITypeInfo>()
+						.CastOrToReadOnlyCollection();
 			}
 		}
 
diff --git a/src/xunit.v3.core.tests/Acceptance/DynamicAssemblyAcceptanceTests.cs b/src/xunit.v3.core.tests/Acceptance/DynamicAssemblyAcceptanceTests.cs
new file mode 100644
index 00000000..d4b522c9
--- /dev/null
+++ b/src/xunit.v3.core.tests/Acceptance/DynamicAssemblyAcceptanceTests.cs
@@ -0,0 +1,99 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Reflection;
+using System.Reflection.Emit;
+using Xunit;
+using Xunit.Runner.Common;
+using Xunit.Sdk;
+using Xunit.v3;
+
+public class DynamicAssemblyAcceptanceTests : IClassFixture<DynamicAssemblyFixture>
+{
+	readonly DynamicAssemblyFixture fixture;
+
+	public DynamicAssemblyAcceptanceTests(DynamicAssemblyFixture fixture)
+	{
+		this.fixture = fixture;
+	}
+
+	[Fact]
+	public async void CanDiscoverTests()
+	{
+		var assemblyInfo = new ReflectionAssemblyInfo(fixture.Assembly);
+
+		await using var disposalTracker = new DisposalTracker();
+		var testFramework = ExtensibilityPointFactory.GetTestFramework(_NullMessageSink.Instance, assemblyInfo);
+		disposalTracker.Add(testFramework);
+
+		var testCases = new List<_ITestCase>();
+		var testDiscoverer = testFramework.GetDiscoverer(assemblyInfo);
+		await testDiscoverer.Find(testCase => { testCases.Add(testCase); return new(true); }, _TestFrameworkOptions.ForDiscovery());
+
+		Assert.Collection(
+			testCases.OrderBy(tc => tc.TestCaseDisplayName),
+			testCase => Assert.Equal("UnitTests.Failing", testCase.TestCaseDisplayName),
+			testCase => Assert.Equal("UnitTests.Passing", testCase.TestCaseDisplayName)
+		);
+	}
+
+	[Fact]
+	public async void CanRunTests()
+	{
+		var assemblyInfo = new ReflectionAssemblyInfo(fixture.Assembly);
+
+		await using var disposalTracker = new DisposalTracker();
+		var testFramework = ExtensibilityPointFactory.GetTestFramework(_NullMessageSink.Instance, assemblyInfo);
+		disposalTracker.Add(testFramework);
+
+		var messages = new List<_MessageSinkMessage>();
+		var testExecutor = testFramework.GetExecutor(assemblyInfo);
+		await testExecutor.RunAll(SpyMessageSink.Create(messages: messages), _TestFrameworkOptions.ForDiscovery(), _TestFrameworkOptions.ForExecution());
+
+		var assemblyStarting = Assert.Single(messages.OfType<_TestAssemblyStarting>());
+		Assert.Equal("DynamicAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null", assemblyStarting.AssemblyName);
+		Assert.Null(assemblyStarting.AssemblyPath);
+		Assert.Null(assemblyStarting.ConfigFilePath);
+
+		Assert.Single(messages.OfType<_TestFailed>());
+		Assert.Single(messages.OfType<_TestPassed>());
+		Assert.Empty(messages.OfType<_TestSkipped>());
+	}
+}
+
+public class DynamicAssemblyFixture
+{
+	public DynamicAssemblyFixture()
+	{
+		var assertTrue = typeof(Assert).GetMethod(nameof(Assert.True), new[] { typeof(bool) });
+		Assert.NotNull(assertTrue);
+
+		var factAttributeCtor = typeof(FactAttribute).GetConstructor(Array.Empty<Type>());
+		Assert.NotNull(factAttributeCtor);
+
+		var assemblyName = new AssemblyName("DynamicAssembly");
+		var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
+		var moduleBuilder = assemblyBuilder.DefineDynamicModule("DynamicAssembly");
+		var typeBuilder = moduleBuilder.DefineType("UnitTests", TypeAttributes.Public);
+
+		var passingTestBuilder = typeBuilder.DefineMethod("Passing", MethodAttributes.Public);
+		passingTestBuilder.SetCustomAttribute(new CustomAttributeBuilder(factAttributeCtor, Array.Empty<object>()));
+		var passingILGenerator = passingTestBuilder.GetILGenerator();
+		passingILGenerator.Emit(OpCodes.Ldc_I4_1);
+		passingILGenerator.Emit(OpCodes.Call, assertTrue);
+		passingILGenerator.Emit(OpCodes.Ret);
+
+		var failingTestBuilder = typeBuilder.DefineMethod("Failing", MethodAttributes.Public);
+		failingTestBuilder.SetCustomAttribute(new CustomAttributeBuilder(factAttributeCtor, Array.Empty<object>()));
+		var failingILGenerator = failingTestBuilder.GetILGenerator();
+		failingILGenerator.Emit(OpCodes.Ldc_I4_0);
+		failingILGenerator.Emit(OpCodes.Call, assertTrue);
+		failingILGenerator.Emit(OpCodes.Ret);
+
+		typeBuilder.CreateType();
+
+		Assembly = assemblyBuilder;
+	}
+
+	public Assembly Assembly { get; }
+}
diff --git a/src/xunit.v3.runner.common.tests/Frameworks/XunitProjectAssemblyTests.cs b/src/xunit.v3.runner.common.tests/Frameworks/XunitProjectAssemblyTests.cs
index 8fc8e1c1..7748a29a 100644
--- a/src/xunit.v3.runner.common.tests/Frameworks/XunitProjectAssemblyTests.cs
+++ b/src/xunit.v3.runner.common.tests/Frameworks/XunitProjectAssemblyTests.cs
@@ -6,18 +6,32 @@ public class XunitProjectAssemblyTests
 	public class AssemblyDisplayName
 	{
 		[Fact]
-		public void WhenAssemblyFilenameIsNotSet_ReturnsDynamic()
+		public void WhenAssemblyFileNameIsNotSet_AndAssemblyIsNotSet_ReturnsDynamic()
 		{
 			var project = new XunitProject();
 			var projectAssembly = new XunitProjectAssembly(project);
 
 			var displayName = projectAssembly.AssemblyDisplayName;
 
-			Assert.Equal("<dynamic>", displayName);
+			Assert.Equal("<unnamed dynamic assembly>", displayName);
 		}
 
 		[Fact]
-		public void WhenAssemblyFilenameIsSet_ReturnsFileNameWithoutExtension()
+		public void WhenAssemblyFileNameIsNotSet_AndAssemblyIsSet_ReturnsAssemblyName()
+		{
+			var project = new XunitProject();
+			var projectAssembly = new XunitProjectAssembly(project)
+			{
+				Assembly = typeof(XunitProjectAssemblyTests).Assembly
+			};
+
+			var displayName = projectAssembly.AssemblyDisplayName;
+
+			Assert.Equal(typeof(XunitProjectAssemblyTests).Assembly.GetName().Name, displayName);
+		}
+
+		[Fact]
+		public void WhenAssemblyFileNameIsSet_ReturnsFileNameWithoutExtension()
 		{
 			var project = new XunitProject();
 			var projectAssembly = new XunitProjectAssembly(project)
diff --git a/src/xunit.v3.runner.common.tests/Reporters/DefaultRunnerReporterMessageHandlerTests.cs b/src/xunit.v3.runner.common.tests/Reporters/DefaultRunnerReporterMessageHandlerTests.cs
index 702da0a2..44fe60f9 100644
--- a/src/xunit.v3.runner.common.tests/Reporters/DefaultRunnerReporterMessageHandlerTests.cs
+++ b/src/xunit.v3.runner.common.tests/Reporters/DefaultRunnerReporterMessageHandlerTests.cs
@@ -319,7 +319,7 @@ public void SingleAssembly()
 		{
 			var clockTime = TimeSpan.FromSeconds(12.3456);
 			var summary = new ExecutionSummary { Total = 2112, Errors = 6, Failed = 42, Skipped = 8, Time = 1.2345M };
-			var assemblyStartingMessage = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-id", assemblyPath: "assembly.dll");
+			var assemblyStartingMessage = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-id", assemblyName: "assembly");
 			var summaryMessage = TestData.TestExecutionSummaries(clockTime, "asm-id", summary);
 			var handler = TestableDefaultRunnerReporterMessageHandler.Create();
 
@@ -341,9 +341,9 @@ public void MultipleAssemblies()
 			var @short = new ExecutionSummary { Total = 2112, Errors = 6, Failed = 42, Skipped = 8, Time = 1.2345M };
 			var nothing = new ExecutionSummary { Total = 0 };
 			var longerName = new ExecutionSummary { Total = 10240, Errors = 7, Failed = 96, Skipped = 4, Time = 3.4567M };
-			var assemblyShortStarting = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-short", assemblyPath: "short.dll");
-			var assemblyNothingStarting = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-nothing", assemblyPath: "nothing.exe");
-			var assemblyLongerStarting = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-longer", assemblyPath: "longerName.dll");
+			var assemblyShortStarting = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-short", assemblyName: "short");
+			var assemblyNothingStarting = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-nothing", assemblyName: "nothing");
+			var assemblyLongerStarting = TestData.TestAssemblyStarting(assemblyUniqueID: "asm-longer", assemblyName: "longerName");
 			var summaryMessage = TestData.TestExecutionSummaries(clockTime, ("asm-short", @short), ("asm-nothing", nothing), ("asm-longer", longerName));
 			var handler = TestableDefaultRunnerReporterMessageHandler.Create();
 
diff --git a/src/xunit.v3.runner.common/Frameworks/XunitProjectAssembly.cs b/src/xunit.v3.runner.common/Frameworks/XunitProjectAssembly.cs
index d5405f1c..00064cbc 100644
--- a/src/xunit.v3.runner.common/Frameworks/XunitProjectAssembly.cs
+++ b/src/xunit.v3.runner.common/Frameworks/XunitProjectAssembly.cs
@@ -1,4 +1,5 @@
-﻿using System.IO;
+﻿using System;
+using System.IO;
 using System.Reflection;
 using Xunit.Internal;
 
@@ -9,7 +10,6 @@ namespace Xunit.Runner.Common
 	/// </summary>
 	public class XunitProjectAssembly
 	{
-		string? assemblyFileName;
 		string? targetFramework;
 
 		/// <summary>
@@ -32,17 +32,21 @@ public XunitProjectAssembly(XunitProject project)
 		/// Gets the assembly display name. Will return the value "&lt;dynamic&gt;" if the
 		/// assembly does not have a file name.
 		/// </summary>
-		public string AssemblyDisplayName =>
-			AssemblyFileName == string.Empty ? "<dynamic>" : Path.GetFileNameWithoutExtension(AssemblyFileName);
+		public string AssemblyDisplayName
+		{
+			get
+			{
+				if (AssemblyFileName != null)
+					return Path.GetFileNameWithoutExtension(AssemblyFileName);
+
+				return Assembly?.GetName()?.Name ?? "<unnamed dynamic assembly>";
+			}
+		}
 
 		/// <summary>
 		/// Gets or sets the assembly file name.
 		/// </summary>
-		public string AssemblyFileName
-		{
-			get => assemblyFileName ?? string.Empty;
-			set => assemblyFileName = value;
-		}
+		public string? AssemblyFileName { get; set; }
 
 		/// <summary>
 		/// Gets or sets the config file name.
@@ -54,6 +58,24 @@ public string AssemblyFileName
 		/// </summary>
 		public TestAssemblyConfiguration Configuration { get; } = new();
 
+		/// <summary>
+		/// Gets an identifier for the current assembly. This is guaranteed to be unique, but not necessarily repeatable
+		/// across runs (because it relies on <see cref="Assembly.GetHashCode"/>).
+		/// </summary>
+		public string Identifier
+		{
+			get
+			{
+				if (AssemblyFileName != null)
+					return AssemblyFileName;
+
+				if (Assembly == null)
+					throw new InvalidOperationException($"Cannot get the UniqueID of a {GetType().FullName} instance when both {nameof(Assembly)} and {nameof(AssemblyFileName)} are null");
+
+				return $"{Assembly.FullName ?? "<unnamed dynamic assembly>"}::{Assembly.GetHashCode()}";
+			}
+		}
+
 		/// <summary>
 		/// Gets the project that this project assembly belongs to.
 		/// </summary>
diff --git a/src/xunit.v3.runner.common/Parsers/CommandLineParserBase.cs b/src/xunit.v3.runner.common/Parsers/CommandLineParserBase.cs
index 014e4a84..0ed7e10e 100644
--- a/src/xunit.v3.runner.common/Parsers/CommandLineParserBase.cs
+++ b/src/xunit.v3.runner.common/Parsers/CommandLineParserBase.cs
@@ -28,7 +28,7 @@ public abstract class CommandLineParserBase
 		Args = args;
 
 		if (string.IsNullOrWhiteSpace(this.reporterFolder))
-			this.reporterFolder = Assembly.GetEntryAssembly()?.Location;
+			this.reporterFolder = Path.GetDirectoryName(Assembly.GetEntryAssembly()?.Location);
 
 		// General options
 		AddParser(
diff --git a/src/xunit.v3.runner.common/Reporters/DefaultRunnerReporterMessageHandler.cs b/src/xunit.v3.runner.common/Reporters/DefaultRunnerReporterMessageHandler.cs
index e49f87f8..2cc27c0b 100644
--- a/src/xunit.v3.runner.common/Reporters/DefaultRunnerReporterMessageHandler.cs
+++ b/src/xunit.v3.runner.common/Reporters/DefaultRunnerReporterMessageHandler.cs
@@ -77,13 +77,11 @@ public DefaultRunnerReporterMessageHandler(IRunnerLogger logger)
 		protected MessageMetadataCache MetadataCache { get; } = new();
 
 		void AddExecutionOptions(
-			string? assemblyFilename,
+			string assemblyIdentifier,
 			_ITestFrameworkExecutionOptions executionOptions)
 		{
-			Guard.NotNull("Attempted to log messages for an XunitProjectAssembly without first setting AssemblyFilename", assemblyFilename);
-
 			using (ReaderWriterLockWrapper.WriteLock())
-				executionOptionsByAssembly[assemblyFilename] = executionOptions;
+				executionOptionsByAssembly[assemblyIdentifier] = executionOptions;
 		}
 
 		/// <summary>
@@ -209,12 +207,10 @@ protected _ITestFrameworkExecutionOptions GetExecutionOptions(string? assemblyFi
 				Logger.LogImportantMessage(frameInfo, $"        {line}");
 		}
 
-		void RemoveExecutionOptions(string? assemblyFilename)
+		void RemoveExecutionOptions(string assemblyIdentifier)
 		{
-			Guard.NotNull("Attempted to log messages for an XunitProjectAssembly without first setting AssemblyFilename", assemblyFilename);
-
 			using (ReaderWriterLockWrapper.WriteLock())
-				executionOptionsByAssembly.Remove(assemblyFilename);
+				executionOptionsByAssembly.Remove(assemblyIdentifier);
 		}
 
 		/// <summary>
@@ -289,7 +285,7 @@ protected virtual void HandleTestAssemblyExecutionFinished(MessageHandlerArgs<Te
 			var executionFinished = args.Message;
 			Logger.LogImportantMessage($"  Finished:    {GetAssemblyDisplayName(executionFinished.Assembly)}");
 
-			RemoveExecutionOptions(executionFinished.Assembly.AssemblyFileName);
+			RemoveExecutionOptions(executionFinished.Assembly.Identifier);
 		}
 
 		/// <summary>
@@ -301,7 +297,7 @@ protected virtual void HandleTestAssemblyExecutionStarting(MessageHandlerArgs<Te
 			Guard.ArgumentNotNull(args);
 
 			var executionStarting = args.Message;
-			AddExecutionOptions(executionStarting.Assembly.AssemblyFileName, executionStarting.ExecutionOptions);
+			AddExecutionOptions(executionStarting.Assembly.Identifier, executionStarting.ExecutionOptions);
 
 			var assemblyDisplayName = GetAssemblyDisplayName(executionStarting.Assembly);
 
@@ -647,7 +643,7 @@ public void WriteDefaultSummary(IRunnerLogger logger, TestExecutionSummaries sum
 						summary => (
 							summary.Summary,
 							summary.AssemblyUniqueID,
-							AssemblyDisplayName: Path.GetFileNameWithoutExtension(MetadataCache.TryGetAssemblyMetadata(summary.AssemblyUniqueID)?.AssemblyPath) ?? "<unknown assembly>"
+							AssemblyDisplayName: MetadataCache.TryGetAssemblyMetadata(summary.AssemblyUniqueID)?.SimpleAssemblyName() ?? "<unknown assembly>"
 						)
 					).OrderBy(summary => summary.AssemblyDisplayName)
 					.ToList();
diff --git a/src/xunit.v3.runner.inproc.console/CommandLine.cs b/src/xunit.v3.runner.inproc.console/CommandLine.cs
index 63a74472..93d8e3ee 100644
--- a/src/xunit.v3.runner.inproc.console/CommandLine.cs
+++ b/src/xunit.v3.runner.inproc.console/CommandLine.cs
@@ -11,7 +11,7 @@ namespace Xunit.Runner.InProc.SystemConsole;
 public class CommandLine : CommandLineParserBase
 {
 	readonly Assembly assembly;
-	readonly string assemblyFileName;
+	readonly string? assemblyFileName;
 
 	/// <summary/>
 	public CommandLine(
@@ -19,10 +19,10 @@ public class CommandLine : CommandLineParserBase
 		string[] args,
 		IReadOnlyList<IRunnerReporter>? runnerReporters = null,
 		string? reporterFolder = null)
-			: base(runnerReporters, reporterFolder ?? Path.GetDirectoryName(assembly.Location), args)
+			: base(runnerReporters, reporterFolder ?? Path.GetDirectoryName(assembly.GetSafeLocation()), args)
 	{
 		this.assembly = assembly;
-		assemblyFileName = assembly.Location;
+		assemblyFileName = assembly.GetSafeLocation();
 
 		// General options
 		AddParser(
@@ -35,11 +35,10 @@ public class CommandLine : CommandLineParserBase
 
 	void AddAssembly(
 		Assembly assembly,
-		string assemblyFileName,
+		string? assemblyFileName,
 		string? configFileName)
 	{
-		// Assembly.Location will return string.Empty for assemblies not on disk
-		if (assemblyFileName != string.Empty && !FileExists(assemblyFileName))
+		if (assemblyFileName != null && !FileExists(assemblyFileName))
 			throw new ArgumentException($"assembly not found: {assemblyFileName}");
 		if (configFileName != null && !FileExists(configFileName))
 			throw new ArgumentException($"config file not found: {configFileName}");
