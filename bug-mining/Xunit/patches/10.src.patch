diff --git a/src/xunit.execution/Sdk/Frameworks/XunitTestCase.cs b/src/xunit.execution/Sdk/Frameworks/XunitTestCase.cs
index fe8ac72e..1f4ba766 100644
--- a/src/xunit.execution/Sdk/Frameworks/XunitTestCase.cs
+++ b/src/xunit.execution/Sdk/Frameworks/XunitTestCase.cs
@@ -22,9 +22,6 @@ namespace Xunit.Sdk
     [Serializable]
     public class XunitTestCase : LongLivedMarshalByRefObject, IXunitTestCase, ISerializable
     {
-        readonly static object[] EmptyArray = new object[0];
-        readonly static MethodInfo EnumerableCast = typeof(Enumerable).GetMethod("Cast");
-        readonly static MethodInfo EnumerableToArray = typeof(Enumerable).GetMethod("ToArray");
         readonly static HashAlgorithm Hasher = new SHA1Managed();
         readonly static ITypeInfo ObjectTypeInfo = Reflector.Wrap(typeof(object));
 
@@ -135,31 +132,6 @@ void Initialize(ITestCollection testCollection, IAssemblyInfo assembly, ITypeInf
         /// <inheritdoc/>
         public string UniqueID { get { return uniqueID.Value; } }
 
-        /// <summary>
-        /// Converts arguments into their target types.
-        /// </summary>
-        /// <param name="args">The arguments to be converted.</param>
-        /// <param name="types">The target types for the conversion.</param>
-        /// <returns>The converted arguments.</returns>
-        protected object[] ConvertArguments(object[] args, Type[] types)
-        {
-            if (args.Length == types.Length)
-                for (int idx = 0; idx < args.Length; idx++)
-                {
-                    Type type = types[idx];
-                    if (type.IsArray && args[idx] != null && args[idx].GetType() != type)
-                    {
-                        var elementType = type.GetElementType();
-                        var arg = (IEnumerable<object>)args[idx];
-                        var castMethod = EnumerableCast.MakeGenericMethod(elementType);
-                        var toArrayMethod = EnumerableToArray.MakeGenericMethod(elementType);
-                        args[idx] = toArrayMethod.Invoke(null, new object[] { castMethod.Invoke(null, new object[] { arg }) });
-                    }
-                }
-
-            return args;
-        }
-
         /// <inheritdoc/>
         public void Dispose()
         {
@@ -536,7 +508,7 @@ protected virtual Task RunTestsAsync(IMessageBus messageBus, object[] constructo
 
                                             await aggregator.RunAsync(async () =>
                                             {
-                                                var result = methodUnderTest.Invoke(testClass, ConvertArguments(testMethodArguments ?? EmptyArray, parameterTypes));
+                                                var result = methodUnderTest.Invoke(testClass, Reflector.ConvertArguments(testMethodArguments, parameterTypes));
                                                 var task = result as Task;
                                                 if (task != null)
                                                     await task;
diff --git a/src/xunit.execution/Sdk/Reflection/ReflectionAttributeInfo.cs b/src/xunit.execution/Sdk/Reflection/ReflectionAttributeInfo.cs
index 92adb929..91e89cd7 100644
--- a/src/xunit.execution/Sdk/Reflection/ReflectionAttributeInfo.cs
+++ b/src/xunit.execution/Sdk/Reflection/ReflectionAttributeInfo.cs
@@ -104,9 +104,11 @@ public TValue GetNamedArgument<TValue>(string propertyName)
 
         Attribute Instantiate(CustomAttributeData attributeData)
         {
-            Attribute attribute = (Attribute)Activator.CreateInstance(attributeData.Constructor.ReflectedType, GetConstructorArguments().ToArray());
+            var ctorArgs = GetConstructorArguments().ToArray();
+            var ctorArgTypes = attributeData.Constructor.GetParameters().Select(p => p.ParameterType).ToArray();
+            var attribute = (Attribute)Activator.CreateInstance(attributeData.Constructor.ReflectedType, Reflector.ConvertArguments(ctorArgs, ctorArgTypes));
 
-            foreach (CustomAttributeNamedArgument namedArg in attributeData.NamedArguments)
+            foreach (var namedArg in attributeData.NamedArguments)
                 ((PropertyInfo)namedArg.MemberInfo).SetValue(attribute, namedArg.TypedValue.Value, index: null);
 
             return attribute;
diff --git a/src/xunit.execution/Sdk/Reflection/Reflector.cs b/src/xunit.execution/Sdk/Reflection/Reflector.cs
index bc33681c..165682b8 100644
--- a/src/xunit.execution/Sdk/Reflection/Reflector.cs
+++ b/src/xunit.execution/Sdk/Reflection/Reflector.cs
@@ -1,4 +1,5 @@
 using System;
+using System.Collections.Generic;
 using System.Linq;
 using System.Reflection;
 using Xunit.Abstractions;
@@ -10,6 +11,42 @@ namespace Xunit.Sdk
     /// </summary>
     public static class Reflector
     {
+        readonly static object[] EmptyArgs = new object[0];
+        readonly static Type[] EmptyTypes = new Type[0];
+        readonly static MethodInfo EnumerableCast = typeof(Enumerable).GetMethod("Cast");
+        readonly static MethodInfo EnumerableToArray = typeof(Enumerable).GetMethod("ToArray");
+
+        /// <summary>
+        /// Converts arguments into their target types. Can be particularly useful when pulling attribute
+        /// constructor arguments, whose types may not strictly match the parameter types.
+        /// </summary>
+        /// <param name="args">The arguments to be converted.</param>
+        /// <param name="types">The target types for the conversion.</param>
+        /// <returns>The converted arguments.</returns>
+        public static object[] ConvertArguments(object[] args, Type[] types)
+        {
+            if (args == null)
+                args = EmptyArgs;
+            if (types == null)
+                types = EmptyTypes;
+
+            if (args.Length == types.Length)
+                for (int idx = 0; idx < args.Length; idx++)
+                {
+                    var type = types[idx];
+                    if (type.IsArray && args[idx] != null && args[idx].GetType() != type)
+                    {
+                        var elementType = type.GetElementType();
+                        var arg = (IEnumerable<object>)args[idx];
+                        var castMethod = EnumerableCast.MakeGenericMethod(elementType);
+                        var toArrayMethod = EnumerableToArray.MakeGenericMethod(elementType);
+                        args[idx] = toArrayMethod.Invoke(null, new object[] { castMethod.Invoke(null, new object[] { arg }) });
+                    }
+                }
+
+            return args;
+        }
+
         /// <summary>
         /// Converts an <see cref="Assembly"/> into an <see cref="IReflectionAssemblyInfo"/>.
         /// </summary>
diff --git a/test/test.xunit.execution/Acceptance/Xunit2AcceptanceTests.cs b/test/test.xunit.execution/Acceptance/Xunit2AcceptanceTests.cs
index 86c58153..d65eea2d 100644
--- a/test/test.xunit.execution/Acceptance/Xunit2AcceptanceTests.cs
+++ b/test/test.xunit.execution/Acceptance/Xunit2AcceptanceTests.cs
@@ -350,6 +350,48 @@ public IEnumerable<IXunitTestCase> OrderTestCases(IEnumerable<IXunitTestCase> te
         }
     }
 
+    public class CustomFacts : AcceptanceTest
+    {
+        [Fact]
+        public void CanUseCustomFactAttribute()
+        {
+            var msgs = Run<ITestPassed>(typeof(ClassWithCustomFact));
+
+            Assert.Collection(msgs,
+                msg => Assert.Equal("Xunit2AcceptanceTests+CustomFacts+ClassWithCustomFact.Passing", msg.TestDisplayName)
+            );
+        }
+
+        class MyCustomFact : FactAttribute { }
+
+        class ClassWithCustomFact
+        {
+            [MyCustomFact]
+            public void Passing() { }
+        }
+
+        [Fact]
+        public void CanUseCustomFactWithArrayParameters()
+        {
+            var msgs = Run<ITestPassed>(typeof(ClassWithCustomArrayFact));
+
+            Assert.Collection(msgs,
+                msg => Assert.Equal("Xunit2AcceptanceTests+CustomFacts+ClassWithCustomArrayFact.Passing", msg.TestDisplayName)
+            );
+        }
+
+        class MyCustomArrayFact : FactAttribute
+        {
+            public MyCustomArrayFact(params string[] values) { }
+        }
+
+        class ClassWithCustomArrayFact
+        {
+            [MyCustomArrayFact("1", "2", "3")]
+            public void Passing() { }
+        }
+    }
+
     class NoTestsClass { }
 
     class SinglePassingTestClass
