diff --git a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs
index a236ca45..dfa197c9 100644
--- a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs
+++ b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestClassRunner.cs
@@ -46,6 +46,11 @@ public class XunitTestClassRunner : TestClassRunner<IXunitTestCase>
         /// </summary>
         protected Dictionary<Type, object> ClassFixtureMappings { get; set; } = new Dictionary<Type, object>();
 
+        /// <summary>
+        /// Gets the already initialized async fixtures <see cref="CreateClassFixtureAsync"/>.
+        /// </summary>
+        protected HashSet<IAsyncLifetime> InitializedAsyncFixtures { get; set; } = new HashSet<IAsyncLifetime>();
+
         /// <summary>
         /// Creates the instance of a class fixture type to be used by the test class. If the fixture can be created,
         /// it should be placed into the <see cref="ClassFixtureMappings"/> dictionary; if it cannot, then the method
@@ -88,9 +93,13 @@ protected virtual void CreateClassFixture(Type fixtureType)
         async Task CreateClassFixtureAsync(Type fixtureType)
         {
             CreateClassFixture(fixtureType);
-            foreach(var uninitializedFixture in ClassFixtureMappings.Values.OfType<IAsyncLifetime>())
-                await Aggregator.RunAsync(uninitializedFixture.InitializeAsync);
-            
+            var uninitializedFixtures = ClassFixtureMappings.Values
+                                        .OfType<IAsyncLifetime>()
+                                        .Where(fixture => !InitializedAsyncFixtures.Contains(fixture))
+                                        .ToList();
+
+            InitializedAsyncFixtures.UnionWith(uninitializedFixtures);
+            await Task.WhenAll(uninitializedFixtures.Select(fixture => Aggregator.RunAsync(fixture.InitializeAsync)));
         }
 
         /// <inheritdoc/>
@@ -126,25 +135,29 @@ protected override async Task AfterTestClassStartingAsync()
             if (testClassTypeInfo.ImplementedInterfaces.Any(i => i.GetTypeInfo().IsGenericType && i.GetGenericTypeDefinition() == typeof(ICollectionFixture<>)))
                 Aggregator.Add(new TestClassException("A test class may not be decorated with ICollectionFixture<> (decorate the test collection class instead)."));
 
+            var createClassFixtureAsyncTasks = new List<Task>();
             foreach (var interfaceType in testClassTypeInfo.ImplementedInterfaces.Where(i => i.GetTypeInfo().IsGenericType && i.GetGenericTypeDefinition() == typeof(IClassFixture<>)))
-                await CreateClassFixtureAsync(interfaceType.GetTypeInfo().GenericTypeArguments.Single());
+                createClassFixtureAsyncTasks.Add(CreateClassFixtureAsync(interfaceType.GetTypeInfo().GenericTypeArguments.Single()));
 
             if (TestClass.TestCollection.CollectionDefinition != null)
             {
                 var declarationType = ((IReflectionTypeInfo)TestClass.TestCollection.CollectionDefinition).Type;
                 foreach (var interfaceType in declarationType.GetTypeInfo().ImplementedInterfaces.Where(i => i.GetTypeInfo().IsGenericType && i.GetGenericTypeDefinition() == typeof(IClassFixture<>)))
-                    await CreateClassFixtureAsync(interfaceType.GetTypeInfo().GenericTypeArguments.Single());
+                    createClassFixtureAsyncTasks.Add(CreateClassFixtureAsync(interfaceType.GetTypeInfo().GenericTypeArguments.Single()));
             }
+
+            await Task.WhenAll(createClassFixtureAsyncTasks);
         }
 
         /// <inheritdoc/>
         protected override async Task BeforeTestClassFinishedAsync()
         {
-            foreach (var fixture in ClassFixtureMappings.Values.OfType<IAsyncLifetime>())
-                await Aggregator.RunAsync(fixture.DisposeAsync);
+            var disposeAsyncTasks = ClassFixtureMappings.Values.OfType<IAsyncLifetime>().Select(fixture => Aggregator.RunAsync(fixture.DisposeAsync)).ToList();
 
             foreach (var fixture in ClassFixtureMappings.Values.OfType<IDisposable>())
                 Aggregator.Run(fixture.Dispose);
+
+            await Task.WhenAll(disposeAsyncTasks);
         }
 
         /// <inheritdoc/>
diff --git a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs
index 74b58073..9d293d3a 100644
--- a/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs
+++ b/src/xunit.execution/Sdk/Frameworks/Runners/XunitTestCollectionRunner.cs
@@ -52,11 +52,12 @@ protected override async Task AfterTestCollectionStartingAsync()
         /// <inheritdoc/>
         protected override async Task BeforeTestCollectionFinishedAsync()
         {
-            foreach (var fixture in CollectionFixtureMappings.Values.OfType<IAsyncLifetime>())
-                await Aggregator.RunAsync(fixture.DisposeAsync);
+            var disposeAsyncTasks = CollectionFixtureMappings.Values.OfType<IAsyncLifetime>().Select(fixture => Aggregator.RunAsync(fixture.DisposeAsync)).ToList();
 
             foreach (var fixture in CollectionFixtureMappings.Values.OfType<IDisposable>())
                 Aggregator.Run(fixture.Dispose);
+
+            await Task.WhenAll(disposeAsyncTasks);
         }
 
         /// <summary>
@@ -77,12 +78,10 @@ async Task CreateCollectionFixturesAsync()
                 {
                     var fixtureType = interfaceType.GenericTypeArguments.Single();
                     CreateCollectionFixture(fixtureType);
-                    foreach (var asyncFixture in CollectionFixtureMappings.Values.OfType<IAsyncLifetime>())
-                    {
-                        await Aggregator.RunAsync(asyncFixture.InitializeAsync);
-                    }
                 }
 
+                var initializeAsyncTasks = CollectionFixtureMappings.Values.OfType<IAsyncLifetime>().Select(fixture => Aggregator.RunAsync(fixture.InitializeAsync)).ToList();
+                await Task.WhenAll(initializeAsyncTasks);
             }
         }
 
diff --git a/test/test.xunit.execution/Acceptance/FixtureAcceptanceTests.cs b/test/test.xunit.execution/Acceptance/FixtureAcceptanceTests.cs
index 06175a87..f1058142 100644
--- a/test/test.xunit.execution/Acceptance/FixtureAcceptanceTests.cs
+++ b/test/test.xunit.execution/Acceptance/FixtureAcceptanceTests.cs
@@ -162,22 +162,30 @@ public void FixtureDataShouldHaveBeenSetup()
             Assert.Single(messages);
         }
 
-        class FixtureSpy : IClassFixture<ThrowIfNotCompleted>
+        class Alpha { }
+        class Beta { }
+
+        /// <remarks>
+        /// We include two class fixtures and test that each one is only initialised once.
+        /// Regression testing for https://github.com/xunit/xunit/issues/869
+        /// </remarks>
+        class FixtureSpy : IClassFixture<ThrowIfNotCompleted<Alpha>>, IClassFixture<ThrowIfNotCompleted<Beta>>
         {
-            public FixtureSpy(ThrowIfNotCompleted data)
+            public FixtureSpy(ThrowIfNotCompleted<Alpha> alpha, ThrowIfNotCompleted<Beta> beta)
             {
-                Assert.True(data.SetupComplete);
+                Assert.Equal(1, alpha.SetupCalls);
+                Assert.Equal(1, beta.SetupCalls);
             }
 
             [Fact]
             public void TheTest() { }
         }
 
-        class ThrowIfNotCompleted : IAsyncLifetime
+        class ThrowIfNotCompleted<T> : IAsyncLifetime
         {
             public Task InitializeAsync()
             {
-                SetupComplete = true;
+                ++SetupCalls;
                 return Task.FromResult(0);
             }
 
@@ -186,7 +194,7 @@ public Task DisposeAsync()
                 return Task.FromResult(0);
             }
 
-            public bool SetupComplete = false;
+            public int SetupCalls = 0;
         }
 
         [Fact]
@@ -526,15 +534,23 @@ public void CollectionFixtureAsyncSetupShouldOnlyRunOnce()
             Assert.Equal(2, results.Count);
         }
 
+        class Alpha { }
+        class Beta { }
+
+        /// <remarks>
+        /// We include two class fixtures and test that each one is only initialised once.
+        /// Regression testing for https://github.com/xunit/xunit/issues/869
+        /// </remarks>
         [CollectionDefinition("Async once")]
-        public class AsyncOnceCollection : ICollectionFixture<CountedAsyncFixture> { }
+        public class AsyncOnceCollection : ICollectionFixture<CountedAsyncFixture<Alpha>>, ICollectionFixture<CountedAsyncFixture<Beta>> { }
 
         [Collection("Async once")]
         class Fixture1
         {
-            public Fixture1(CountedAsyncFixture fixture)
+            public Fixture1(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
             {
-                Assert.Equal(1, fixture.Count);
+                Assert.Equal(1, alpha.Count);
+                Assert.Equal(1, beta.Count);
             }
 
             [Fact]
@@ -544,16 +560,17 @@ public Fixture1(CountedAsyncFixture fixture)
         [Collection("Async once")]
         class Fixture2
         {
-            public Fixture2(CountedAsyncFixture fixture)
+            public Fixture2(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
             {
-                Assert.Equal(1, fixture.Count);
+                Assert.Equal(1, alpha.Count);
+                Assert.Equal(1, beta.Count);
             }
 
             [Fact]
             public void TheTest() { }
         }
 
-        class CountedAsyncFixture : IAsyncLifetime
+        class CountedAsyncFixture<T> : IAsyncLifetime
         {
             public int Count = 0;
             public Task InitializeAsync()
