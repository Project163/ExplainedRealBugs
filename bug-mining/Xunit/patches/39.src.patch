diff --git a/src/common/NewReflectionExtensions.cs b/src/common/NewReflectionExtensions.cs
new file mode 100644
index 00000000..395fd426
--- /dev/null
+++ b/src/common/NewReflectionExtensions.cs
@@ -0,0 +1,61 @@
+using System;
+using System.Reflection;
+
+/// <summary>
+/// Methods which help bridge and contain the differences between Type and TypeInfo.
+/// </summary>
+internal static class NewReflectionExtensions
+{
+    // New methods
+
+    public static Assembly GetAssembly(this Type type)
+    {
+#if NEW_REFLECTION
+        return type.GetTypeInfo().Assembly;
+#else
+        return type.Assembly;
+#endif
+    }
+
+    public static MethodInfo GetDeclaredMethod(this Type type, string methodName)
+    {
+#if NEW_REFLECTION
+        return type.GetTypeInfo().GetDeclaredMethod(methodName);
+#else
+        return type.GetMethod(methodName);
+#endif
+    }
+
+
+    public static bool IsGenericType(this Type type)
+    {
+#if NEW_REFLECTION
+        return type.GetTypeInfo().IsGenericType;
+#else
+        return type.IsGenericType;
+#endif
+    }
+
+    public static bool IsValueType(this Type type)
+    {
+#if NEW_REFLECTION
+        return type.GetTypeInfo().IsValueType;
+#else
+        return type.IsValueType;
+#endif
+    }
+
+    // Existing methods
+
+#if NEW_REFLECTION
+    public static Type[] GetGenericArguments(this Type type)
+    {
+        return type.GetTypeInfo().GenericTypeArguments;
+    }
+
+    public static bool IsAssignableFrom(this Type type, Type otherType)
+    {
+        return type.GetTypeInfo().IsAssignableFrom(otherType.GetTypeInfo());
+    }
+#endif
+}
\ No newline at end of file
diff --git a/src/common/SerializationHelper.cs b/src/common/SerializationHelper.cs
index ce4bea6b..c8e8eb26 100644
--- a/src/common/SerializationHelper.cs
+++ b/src/common/SerializationHelper.cs
@@ -1,4 +1,6 @@
 ﻿using System;
+using System.Collections.Generic;
+using System.IO;
 using System.Linq;
 using System.Reflection;
 using Xunit.Abstractions;
@@ -30,13 +32,8 @@ public static T Deserialize<T>(string serializedValue)
             if (deserializedType == null)
                 throw new ArgumentException("Could not load type " + pieces[0], "serializedValue");
 
-#if NEW_REFLECTION
-            if (!typeof(IXunitSerializable).GetTypeInfo().IsAssignableFrom(deserializedType.GetTypeInfo()))
-                throw new ArgumentException("Cannot de-serialize an object that does not implement " + typeof(IXunitSerializable).FullName, "T");
-#else
             if (!typeof(IXunitSerializable).IsAssignableFrom(deserializedType))
                 throw new ArgumentException("Cannot de-serialize an object that does not implement " + typeof(IXunitSerializable).FullName, "T");
-#endif
 
             var obj = XunitSerializationInfo.Deserialize(deserializedType, pieces[1]);
             if (obj is XunitSerializationInfo.ArraySerializer)
@@ -74,7 +71,68 @@ public static string Serialize(object value)
         /// <returns>The instance of the <see cref="Type"/>, if available; <c>null</c>, otherwise.</returns>
         public static Type GetType(string assemblyQualifiedTypeName)
         {
-            var parts = assemblyQualifiedTypeName.Split(new[] { ',' }).Select(x => x.Trim()).ToList();
+            var firstOpenSquare = assemblyQualifiedTypeName.IndexOf('[');
+            if (firstOpenSquare > 0)
+            {
+                var backtick = assemblyQualifiedTypeName.IndexOf('`');
+                if (backtick > 0 && backtick < firstOpenSquare)
+                {
+                    // Run the string looking for the matching closing square brace. Can't just assume the last one
+                    // is the end, since the type could be trailed by array designators.
+                    var depth = 1;
+                    var lastOpenSquare = firstOpenSquare + 1;
+                    var sawNonArrayDesignator = false;
+                    for (; depth > 0 && lastOpenSquare < assemblyQualifiedTypeName.Length; ++lastOpenSquare)
+                    {
+                        switch (assemblyQualifiedTypeName[lastOpenSquare])
+                        {
+                            case '[': ++depth; break;
+                            case ']': --depth; break;
+                            case ',': break;
+                            default: sawNonArrayDesignator = true; break;
+                        }
+                    }
+
+                    if (sawNonArrayDesignator)
+                    {
+                        if (depth != 0)  // Malformed, because we never closed what we opened
+                            return null;
+
+                        var genericArgument = assemblyQualifiedTypeName.Substring(firstOpenSquare + 1, lastOpenSquare - firstOpenSquare - 2);  // Strip surrounding [ and ]
+                        var innerTypeNames = SplitAtOuterCommas(genericArgument).Select(x => x.Substring(1, x.Length - 2)).ToArray();  // Strip surrounding [ and ] from each type name
+                        var innerTypes = innerTypeNames.Select(GetType).ToArray();
+                        if (innerTypes.Any(t => t == null))
+                            return null;
+
+                        var genericDefinitionName = assemblyQualifiedTypeName.Substring(0, firstOpenSquare) + assemblyQualifiedTypeName.Substring(lastOpenSquare);
+                        var genericDefinition = GetType(genericDefinitionName);
+                        if (genericDefinition == null)
+                            return null;
+
+                        // Push array ranks so we can get down to the actual generic definition
+                        var arrayRanks = new Stack<int>();
+                        while (genericDefinition.IsArray)
+                        {
+                            arrayRanks.Push(genericDefinition.GetArrayRank());
+                            genericDefinition = genericDefinition.GetElementType();
+                        }
+
+                        var closedGenericType = genericDefinition.MakeGenericType(innerTypes);
+                        while (arrayRanks.Count > 0)
+                        {
+                            var rank = arrayRanks.Pop();
+                            if (rank > 1)
+                                closedGenericType = closedGenericType.MakeArrayType(rank);
+                            else
+                                closedGenericType = closedGenericType.MakeArrayType();
+                        }
+
+                        return closedGenericType;
+                    }
+                }
+            }
+
+            var parts = SplitAtOuterCommas(assemblyQualifiedTypeName).Select(x => x.Trim()).ToList();
             if (parts.Count == 0)
                 return null;
 
@@ -131,14 +189,69 @@ public static Type GetType(string assemblyName, string typeName)
         /// </summary>
         public static string GetTypeNameForSerialization(Type type)
         {
-            var pieces = type.AssemblyQualifiedName.Split(',').Select(p => p.Trim()).ToArray();
-            if (pieces.Length < 2 || String.Equals(pieces[1], "mscorlib", StringComparison.OrdinalIgnoreCase))
-                return pieces[0];
+            var typeName = type.FullName;
+            var assemblyName = type.GetAssembly().FullName.Split(',')[0];
+
+            var arrayRanks = new Stack<int>();
+            while (type.IsArray)
+            {
+                arrayRanks.Push(type.GetArrayRank());
+                type = type.GetElementType();
+            }
+
+            if (type.IsGenericType())
+            {
+                var typeDefinition = type.GetGenericTypeDefinition();
+                var innerTypes = type.GetGenericArguments().Select(t => String.Format("[{0}]", GetTypeNameForSerialization(t))).ToArray();
+                typeName = String.Format("{0}[{1}]", typeDefinition.FullName, String.Join(",", innerTypes));
+
+                while (arrayRanks.Count > 0)
+                {
+                    typeName += '[';
+                    for (var commas = arrayRanks.Pop() - 1; commas > 0; --commas)
+                        typeName += ',';
+                    typeName += ']';
+                }
+            }
+
+            if (String.Equals(assemblyName, "mscorlib", StringComparison.OrdinalIgnoreCase))
+                return typeName;
+
+            if (String.Equals(assemblyName, ExecutionHelper.AssemblyName, StringComparison.OrdinalIgnoreCase))
+                assemblyName = "xunit.execution";
+
+            return String.Format("{0}, {1}", typeName, assemblyName);
+        }
+
+        private static IList<string> SplitAtOuterCommas(string value)
+        {
+            List<string> results = new List<string>();
+
+            var startIndex = 0;
+            var endIndex = 0;
+            var depth = 0;
+
+            for (; endIndex < value.Length; ++endIndex)
+            {
+                switch (value[endIndex])
+                {
+                    case '[': ++depth; break;
+                    case ']': --depth; break;
+                    case ',':
+                        if (depth == 0)
+                        {
+                            results.Add(value.Substring(startIndex, endIndex - startIndex));
+                            startIndex = endIndex + 1;
+                        }
+                        break;
+                }
+            }
 
-            if (String.Equals(pieces[1], ExecutionHelper.AssemblyName, StringComparison.OrdinalIgnoreCase))
-                pieces[1] = "xunit.execution";
+            if (depth != 0 || startIndex >= endIndex)
+                return new List<string>();
 
-            return String.Format("{0}, {1}", pieces[0], pieces[1]);
+            results.Add(value.Substring(startIndex, endIndex - startIndex));
+            return results;
         }
     }
 }
diff --git a/src/common/XunitSerializationInfo.cs b/src/common/XunitSerializationInfo.cs
index 8243ec7f..3f5e15db 100644
--- a/src/common/XunitSerializationInfo.cs
+++ b/src/common/XunitSerializationInfo.cs
@@ -14,7 +14,7 @@ namespace Xunit.Serialization
     /// </summary>
     internal class XunitSerializationInfo : IXunitSerializationInfo
     {
-        private readonly IDictionary<string, SerializationData> data = new Dictionary<string, SerializationData>();
+        private readonly IDictionary<string, XunitSerializationTriple> data = new Dictionary<string, XunitSerializationTriple>();
 
         /// <summary>
         /// Initializes a new instance of the <see cref="XunitSerializationInfo"/> class.
@@ -32,7 +32,7 @@ public void AddValue(string key, object value, Type type = null)
             if (type == null)
                 type = value == null ? typeof(object) : value.GetType();
 
-            data[key] = new SerializationData(value, type);
+            data[key] = new XunitSerializationTriple(key, value, type);
         }
 
         /// <inheritdoc/>
@@ -44,18 +44,13 @@ public T GetValue<T>(string key)
         /// <inheritdoc/>
         public object GetValue(string key, Type type)
         {
-            SerializationData val;
+            XunitSerializationTriple val;
 
             if (data.TryGetValue(key, out val))
                 return val.Value;
 
-#if NEW_REFLECTION
-            if (type.GetTypeInfo().IsValueType)
+            if (type.IsValueType())
                 return Activator.CreateInstance(type);
-#else
-            if (type.IsValueType)
-                return Activator.CreateInstance(type);
-#endif
 
             return null;
         }
@@ -63,11 +58,38 @@ public object GetValue(string key, Type type)
         /// <summary>
         /// Returns BASE64 encoded string that represents the entirety of the data.
         /// </summary>
-        /// <returns></returns>
         public string ToSerializedString()
         {
-            var valueTree = String.Join("\n", data.Select(kvp => String.Format("{0}:{1}:{2}", kvp.Key, SerializationHelper.GetTypeNameForSerialization(kvp.Value.Type), Serialize(kvp.Value.Value))).ToArray());
-            return ToBase64(valueTree);
+            return ToBase64(String.Join("\n", data.Select(kvp => SerializeTriple(kvp.Value)).ToArray()));
+        }
+
+        /// <summary>
+        /// Returns a triple for a key/value pair of data in a complex object
+        /// </summary>
+        /// <param name="triple">The triple to be serialized</param>
+        /// <returns>The serialized version of the triple</returns>
+        public static string SerializeTriple(XunitSerializationTriple triple)
+        {
+            var serializedType = SerializationHelper.GetTypeNameForSerialization(triple.Type);
+            var serializedValue = Serialize(triple.Value);
+            return String.Format("{0}:{1}:{2}", triple.Key, serializedType, serializedValue);
+        }
+
+        /// <summary>
+        /// Returns the triple values out of a serialized triple.
+        /// </summary>
+        /// <param name="value">The serialized triple</param>
+        /// <returns>The de-serialized triple</returns>
+        public static XunitSerializationTriple DeserializeTriple(string value)
+        {
+            var pieces = value.Split(new[] { ':' }, 3);
+            if (pieces.Length != 3)
+                throw new ArgumentException("Data does not appear to be a valid serialized triple: " + value);
+
+            var pieceType = SerializationHelper.GetType(pieces[1]);
+            object deserializedValue = Deserialize(pieceType, pieces[2]);
+
+            return new XunitSerializationTriple(pieces[0], deserializedValue, pieceType);
         }
 
         /// <summary>
@@ -81,13 +103,8 @@ public static object Deserialize(Type type, string serializedValue)
             if (serializedValue == "")
                 return null;
 
-#if NEW_REFLECTION
-            if (typeof(IXunitSerializable).GetTypeInfo().IsAssignableFrom(type.GetTypeInfo()))
-                return DeserializeSerializable(type, serializedValue);
-#else
             if (typeof(IXunitSerializable).IsAssignableFrom(type))
                 return DeserializeSerializable(type, serializedValue);
-#endif
 
             if (type == typeof(string))
                 return FromBase64(serializedValue);
@@ -123,12 +140,8 @@ static IXunitSerializable DeserializeSerializable(Type type, string serializedVa
 
             foreach (var element in elements)
             {
-                var pieces = element.Split(new[] { ':' }, 3);
-                if (pieces.Length != 3)
-                    throw new ArgumentException("Could not split element into 3 pieces: " + element);
-
-                var pieceType = SerializationHelper.GetType(pieces[1]);
-                serializationInfo.data[pieces[0]] = new SerializationData(Deserialize(pieceType, pieces[2]), pieceType);
+                var triple = DeserializeTriple(element);
+                serializationInfo.data[triple.Key] = triple;
             }
 
             var value = (IXunitSerializable)Activator.CreateInstance(type);
@@ -209,14 +222,8 @@ private static bool CanSerializeObject(object value)
             if (valueType.IsArray)
                 return ((object[])value).All(CanSerializeObject);
 
-#if NEW_REFLECTION
-            var typeInfo = valueType.GetTypeInfo();
-            if (supportedSerializationTypes.Any(supportedType => supportedType.GetTypeInfo().IsAssignableFrom(typeInfo)))
-                return true;
-#else
             if (supportedSerializationTypes.Any(supportedType => supportedType.IsAssignableFrom(valueType)))
                 return true;
-#endif
 
             return false;
         }
@@ -274,17 +281,40 @@ public void Deserialize(IXunitSerializationInfo info)
                     array[i] = info.GetValue("Item" + i, arrType);
             }
         }
+    }
 
-        class SerializationData
-        {
-            public object Value;
-            public Type Type;
+    /// <summary>
+    /// Represents a triple of information used when serializing complex types: the property name,
+    /// the value to be serialized, and the value's type.
+    /// </summary>
+    internal class XunitSerializationTriple
+    {
+        /// <summary>
+        /// Gets the triple's key
+        /// </summary>
+        public readonly string Key;
 
-            public SerializationData(object value, Type type)
-            {
-                Value = value;
-                Type = type;
-            }
+        /// <summary>
+        /// Gets the triple's value
+        /// </summary>
+        public readonly object Value;
+
+        /// <summary>
+        /// Gets the triple's value type
+        /// </summary>
+        public readonly Type Type;
+
+        /// <summary>
+        /// Initializes a new instance of the <see cref="XunitSerializationTriple"/> class.
+        /// </summary>
+        /// <param name="key">The triple's key</param>
+        /// <param name="value">The triple's value</param>
+        /// <param name="type">The triple's value type</param>
+        public XunitSerializationTriple(string key, object value, Type type)
+        {
+            Key = key;
+            Value = value;
+            Type = type;
         }
     }
 }
\ No newline at end of file
diff --git a/src/xunit.execution.AspNet/project.json b/src/xunit.execution.AspNet/project.json
index 291e7d5f..8eabedbc 100644
--- a/src/xunit.execution.AspNet/project.json
+++ b/src/xunit.execution.AspNet/project.json
@@ -38,6 +38,7 @@
         "../common/GlobalAssemblyInfo.cs",
         "../common/Guard.cs",
         "../common/LongLivedMarshalByRefObject_Execution_NoAppDomain.cs",
+        "../common/NewReflectionExtensions.cs",
         "../common/NullMessageSink.cs",
         "../common/SerializationHelper.cs",
         "../common/SourceInformation.cs",
diff --git a/src/xunit.execution.MonoAndroid/xunit.execution.MonoAndroid.csproj b/src/xunit.execution.MonoAndroid/xunit.execution.MonoAndroid.csproj
index 4a47be99..08a3d811 100644
--- a/src/xunit.execution.MonoAndroid/xunit.execution.MonoAndroid.csproj
+++ b/src/xunit.execution.MonoAndroid/xunit.execution.MonoAndroid.csproj
@@ -68,6 +68,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.execution.MonoTouch/xunit.execution.MonoTouch.csproj b/src/xunit.execution.MonoTouch/xunit.execution.MonoTouch.csproj
index a77bb066..4eb8db0b 100644
--- a/src/xunit.execution.MonoTouch/xunit.execution.MonoTouch.csproj
+++ b/src/xunit.execution.MonoTouch/xunit.execution.MonoTouch.csproj
@@ -80,6 +80,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.execution.desktop/xunit.execution.desktop.csproj b/src/xunit.execution.desktop/xunit.execution.desktop.csproj
index 98bd53fa..f4683b3e 100644
--- a/src/xunit.execution.desktop/xunit.execution.desktop.csproj
+++ b/src/xunit.execution.desktop/xunit.execution.desktop.csproj
@@ -64,6 +64,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Execution.cs">
       <Link>Common\LongLivedMarshalByRefObject_Execution.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.execution.ios-universal/xunit.execution.ios-universal.csproj b/src/xunit.execution.ios-universal/xunit.execution.ios-universal.csproj
index 61442489..69b6621e 100644
--- a/src/xunit.execution.ios-universal/xunit.execution.ios-universal.csproj
+++ b/src/xunit.execution.ios-universal/xunit.execution.ios-universal.csproj
@@ -77,6 +77,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.execution.universal/xunit.execution.universal.csproj b/src/xunit.execution.universal/xunit.execution.universal.csproj
index 574ac88b..277e7a1c 100644
--- a/src/xunit.execution.universal/xunit.execution.universal.csproj
+++ b/src/xunit.execution.universal/xunit.execution.universal.csproj
@@ -114,6 +114,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.execution.win8/xunit.execution.win8.csproj b/src/xunit.execution.win8/xunit.execution.win8.csproj
index bbcc6e5c..f363f5c0 100644
--- a/src/xunit.execution.win8/xunit.execution.win8.csproj
+++ b/src/xunit.execution.win8/xunit.execution.win8.csproj
@@ -66,6 +66,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.execution.wp8/xunit.execution.wp8.csproj b/src/xunit.execution.wp8/xunit.execution.wp8.csproj
index 4a3aeecf..5fc1bf01 100644
--- a/src/xunit.execution.wp8/xunit.execution.wp8.csproj
+++ b/src/xunit.execution.wp8/xunit.execution.wp8.csproj
@@ -107,6 +107,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Execution_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.AspNet/project.json b/src/xunit.runner.utility.AspNet/project.json
index e5e194ef..97ccc1a1 100644
--- a/src/xunit.runner.utility.AspNet/project.json
+++ b/src/xunit.runner.utility.AspNet/project.json
@@ -36,6 +36,7 @@
         "../common/GlobalAssemblyInfo.cs",
         "../common/Guard.cs",
         "../common/LongLivedMarshalByRefObject_Runner_NoAppDomain.cs",
+        "../common/NewReflectionExtensions.cs",
         "../common/NullMessageSink.cs",
         "../common/RemoteAppDomainManager_NoAppDomain.cs",
         "../common/SerializationInfoExtensions.cs",
diff --git a/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj b/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj
index bc5b4ea5..c5c6dd88 100644
--- a/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj
+++ b/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj
@@ -77,6 +77,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj b/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj
index 7fa5e5e7..0e720f4f 100644
--- a/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj
+++ b/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj
@@ -71,6 +71,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj b/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj
index 6e1773b1..9570f969 100644
--- a/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj
+++ b/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj
@@ -78,6 +78,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Runner.cs">
       <Link>Common\LongLivedMarshalByRefObject_Runner.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj b/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj
index f3c4e308..753f8ca1 100644
--- a/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj
+++ b/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj
@@ -77,6 +77,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj b/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj
index e0bd4717..8d4427ac 100644
--- a/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj
+++ b/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj
@@ -123,6 +123,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.win8/xunit.runner.utility.win8.csproj b/src/xunit.runner.utility.win8/xunit.runner.utility.win8.csproj
index ff24167f..3c688e08 100644
--- a/src/xunit.runner.utility.win8/xunit.runner.utility.win8.csproj
+++ b/src/xunit.runner.utility.win8/xunit.runner.utility.win8.csproj
@@ -82,6 +82,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj b/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj
index fc2c692d..b1a92aa1 100644
--- a/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj
+++ b/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj
@@ -126,6 +126,9 @@
     <Compile Include="..\common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs">
       <Link>Common\LongLivedMarshalByRefObject_Runner_NoAppDomain.cs</Link>
     </Compile>
+    <Compile Include="..\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\common\NullMessageSink.cs">
       <Link>Common\NullMessageSink.cs</Link>
     </Compile>
diff --git a/test/test.xunit.execution/Common/SerializationHelperTests.cs b/test/test.xunit.execution/Common/SerializationHelperTests.cs
new file mode 100644
index 00000000..58022dc2
--- /dev/null
+++ b/test/test.xunit.execution/Common/SerializationHelperTests.cs
@@ -0,0 +1,36 @@
+﻿using System;
+using Xunit;
+using Xunit.Sdk;
+
+public class SerializationHelperTests
+{
+    [Theory]
+    // Types in mscorlib show up as simple names
+    [InlineData(typeof(object), "System.Object")]
+    // Types outside of mscorlib include their assembly name
+    [InlineData(typeof(FactAttribute), "Xunit.FactAttribute, xunit.core")]
+    // Types in device-specific execution library show up in xunit.execution
+    [InlineData(typeof(XunitTestFramework), "Xunit.Sdk.XunitTestFramework, xunit.execution")]
+    // Array types
+    [InlineData(typeof(FactAttribute[]), "Xunit.FactAttribute[], xunit.core")]
+    // Array of arrays with multi-dimensions
+    [InlineData(typeof(FactAttribute[][,]), "Xunit.FactAttribute[,][], xunit.core")]
+    // Single-nested generic type (both in mscorlib)
+    [InlineData(typeof(Action<object>), "System.Action`1[[System.Object]]")]
+    // Single-nested generic type (non-mscorlib)
+    [InlineData(typeof(TestMethodRunner<XunitTestCase>), "Xunit.Sdk.TestMethodRunner`1[[Xunit.Sdk.XunitTestCase, xunit.execution]], xunit.execution")]
+    // Multiply-nested generic types
+    [InlineData(typeof(Action<Tuple<object, FactAttribute>, XunitTestFramework>), "System.Action`2[[System.Tuple`2[[System.Object],[Xunit.FactAttribute, xunit.core]]],[Xunit.Sdk.XunitTestFramework, xunit.execution]]")]
+    // Generics and arrays, living together, like cats and dogs
+    [InlineData(typeof(Action<XunitTestCase[,][]>[][,]), "System.Action`1[[Xunit.Sdk.XunitTestCase[][,], xunit.execution]][,][]")]
+    public static void CanRoundTripSerializedTypeNames(Type type, string expectedName)
+    {
+        var name = SerializationHelper.GetTypeNameForSerialization(type);
+
+        Assert.Equal<object>(expectedName, name);
+
+        var deserializedType = SerializationHelper.GetType(name);
+
+        Assert.Same(type, deserializedType);
+    }
+}
diff --git a/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs b/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
new file mode 100644
index 00000000..7283a8a9
--- /dev/null
+++ b/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
@@ -0,0 +1,127 @@
+﻿using System;
+using System.Collections.Generic;
+using Xunit;
+using Xunit.Abstractions;
+using Xunit.Serialization;
+
+public class XunitSerializationInfoTests
+{
+    public static IEnumerable<object[]> SupportedIntrinsics
+    {
+        get
+        {
+            yield return new object[] { typeof(string), "Hello, world!" };
+            yield return new object[] { typeof(string), null };
+            yield return new object[] { typeof(int), int.MaxValue };
+            yield return new object[] { typeof(int?), int.MinValue };
+            yield return new object[] { typeof(int?), null };
+            yield return new object[] { typeof(long), long.MaxValue };
+            yield return new object[] { typeof(long?), long.MinValue };
+            yield return new object[] { typeof(long?), null };
+            yield return new object[] { typeof(float), 1.1f };
+            yield return new object[] { typeof(float?), -1.1f };
+            yield return new object[] { typeof(float?), null };
+            yield return new object[] { typeof(double), 2.2 };
+            yield return new object[] { typeof(double?), -2.2 };
+            yield return new object[] { typeof(double?), null };
+            yield return new object[] { typeof(decimal), decimal.MaxValue };
+            yield return new object[] { typeof(decimal?), decimal.MinValue };
+            yield return new object[] { typeof(decimal?), null };
+            yield return new object[] { typeof(object[]), new object[] { int.MinValue, long.MaxValue, null, 1.1f, -2.2, decimal.MaxValue } };
+        }
+    }
+
+    public class Serialize
+    {
+        [Theory]
+        [MemberData("SupportedIntrinsics", MemberType = typeof(XunitSerializationInfoTests))]
+        public static void CanRoundTripIntrinsics(Type dataType, object data)
+        {
+            Assert.Equal(data, XunitSerializationInfo.Deserialize(dataType, XunitSerializationInfo.Serialize(data)));
+        }
+
+        [Fact]
+        public static void CanRoundTypeIXunitSerializable()
+        {
+            var data = new MySerializable { IntValue = 42, StringValue = "Hello\r\nworld!" };
+
+            var deserialized = (MySerializable)XunitSerializationInfo.Deserialize(typeof(MySerializable), XunitSerializationInfo.Serialize(data));
+
+            Assert.Equal(42, deserialized.IntValue);
+            Assert.Equal("Hello\r\nworld!", deserialized.StringValue);
+        }
+
+        [Fact]
+        public static void UnsupportedTypeThrows()
+        {
+            var data = new object();
+
+            var ex = Record.Exception(() => XunitSerializationInfo.Serialize(data));
+
+            var argEx = Assert.IsType<ArgumentException>(ex);
+            Assert.Equal("value", argEx.ParamName);
+            Assert.StartsWith("We don't know how to serialize type System.Object", argEx.Message);
+        }
+    }
+
+    public class SerializeTriple
+    {
+        [Theory]
+        [MemberData("SupportedIntrinsics", MemberType = typeof(XunitSerializationInfoTests))]
+        public static void CanRoundTripIntrinsics(Type dataType, object data)
+        {
+            var triple = new XunitSerializationTriple(Guid.NewGuid().ToString(), data, dataType);
+            var serialized = XunitSerializationInfo.SerializeTriple(triple);
+            var deserialized = XunitSerializationInfo.DeserializeTriple(serialized);
+
+            Assert.Equal(triple.Key, deserialized.Key);
+            Assert.Equal(triple.Type, deserialized.Type);
+            Assert.Equal(triple.Value, deserialized.Value);
+        }
+
+        [Fact]
+        public static void CanRoundTypeIXunitSerializable()
+        {
+            var data = new MySerializable { IntValue = 42, StringValue = "Hello\r\nworld!" };
+            var triple = new XunitSerializationTriple(Guid.NewGuid().ToString(), data, data.GetType());
+            var serialized = XunitSerializationInfo.SerializeTriple(triple);
+            var deserialized = XunitSerializationInfo.DeserializeTriple(serialized);
+
+            Assert.Equal(triple.Key, deserialized.Key);
+            Assert.Equal(triple.Type, deserialized.Type);
+            var deserializedInner = (MySerializable)deserialized.Value;
+            Assert.Equal(42, deserializedInner.IntValue);
+            Assert.Equal("Hello\r\nworld!", deserializedInner.StringValue);
+        }
+
+        [Fact]
+        public static void UnsupportedTypeThrows()
+        {
+            var triple = new XunitSerializationTriple(Guid.NewGuid().ToString(), new object(), typeof(object));
+
+            var ex = Record.Exception(() => XunitSerializationInfo.SerializeTriple(triple));
+
+            var argEx = Assert.IsType<ArgumentException>(ex);
+            Assert.Equal("value", argEx.ParamName);
+            Assert.StartsWith("We don't know how to serialize type System.Object", argEx.Message);
+        }
+    }
+
+    class MySerializable : IXunitSerializable
+    {
+        public int IntValue;
+        public string StringValue;
+
+        public void Deserialize(IXunitSerializationInfo info)
+        {
+            IntValue = info.GetValue<int>("IntValue");
+            StringValue = info.GetValue<string>("StringValue");
+        }
+
+        public void Serialize(IXunitSerializationInfo info)
+        {
+            info.AddValue("IntValue", IntValue);
+            info.AddValue("StringValue", StringValue);
+        }
+    }
+}
diff --git a/test/test.xunit.execution/test.xunit.execution.csproj b/test/test.xunit.execution/test.xunit.execution.csproj
index 71a027cf..5eeb3719 100644
--- a/test/test.xunit.execution/test.xunit.execution.csproj
+++ b/test/test.xunit.execution/test.xunit.execution.csproj
@@ -55,6 +55,9 @@
     <Compile Include="..\..\src\common\Guard.cs">
       <Link>Common\Guard.cs</Link>
     </Compile>
+    <Compile Include="..\..\src\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\..\src\common\SerializationHelper.cs">
       <Link>Common\SerializationHelper.cs</Link>
     </Compile>
@@ -78,10 +81,12 @@
     <Compile Include="Acceptance\FixtureAcceptanceTests.cs" />
     <Compile Include="Acceptance\Xunit2AcceptanceTests.cs" />
     <Compile Include="Acceptance\Xunit2TheoryAcceptanceTests.cs" />
+    <Compile Include="Common\SerializationHelperTests.cs" />
     <Compile Include="Common\XmlTestExecutionVisitorTests.cs" />
     <Compile Include="..\GlobalTestAssemblyInfo.cs">
       <Link>Properties\GlobalTestAssemblyInfo.cs</Link>
     </Compile>
+    <Compile Include="Common\XunitSerializationInfoTests.cs" />
     <Compile Include="Extensions\ReflectionAbstractionExtensionsTests.cs" />
     <Compile Include="Sdk\ArgumentFormatterTests.cs" />
     <Compile Include="Sdk\DefaultTestCaseOrdererTests.cs" />
diff --git a/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj b/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj
index 19adade9..8c4e0611 100644
--- a/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj
+++ b/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj
@@ -58,6 +58,9 @@
     <Compile Include="..\..\src\common\Guard.cs">
       <Link>Common\Guard.cs</Link>
     </Compile>
+    <Compile Include="..\..\src\common\NewReflectionExtensions.cs">
+      <Link>Common\NewReflectionExtensions.cs</Link>
+    </Compile>
     <Compile Include="..\..\src\common\SerializationHelper.cs">
       <Link>Common\SerializationHelper.cs</Link>
     </Compile>
diff --git a/test/test.xunit1/test.xunit1.csproj b/test/test.xunit1/test.xunit1.csproj
index cb7e2367..15298cc4 100644
--- a/test/test.xunit1/test.xunit1.csproj
+++ b/test/test.xunit1/test.xunit1.csproj
@@ -171,4 +171,4 @@
   <Target Name="AfterBuild">
   </Target>
   -->
-</Project>
+</Project>
\ No newline at end of file
