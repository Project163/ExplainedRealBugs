diff --git a/src/common/XunitSerializationInfo.cs b/src/common/XunitSerializationInfo.cs
index cc57e5ae..ea46a997 100644
--- a/src/common/XunitSerializationInfo.cs
+++ b/src/common/XunitSerializationInfo.cs
@@ -2,7 +2,6 @@
 using System.Collections.Generic;
 using System.Globalization;
 using System.Linq;
-using System.Reflection;
 using System.Text;
 using Xunit.Abstractions;
 using Xunit.Sdk;
@@ -110,15 +109,33 @@ public static object Deserialize(Type type, string serializedValue)
             if (typeof(IXunitSerializable).IsAssignableFrom(type))
                 return DeserializeSerializable(type, serializedValue);
 
+            if (type == typeof(char?) || type == typeof(char))
+                return (char)UInt16.Parse(serializedValue, CultureInfo.InvariantCulture);
+
             if (type == typeof(string))
                 return FromBase64(serializedValue);
 
+            if (type == typeof(byte?) || type == typeof(byte))
+                return Byte.Parse(serializedValue, CultureInfo.InvariantCulture);
+
+            if (type == typeof(short?) || type == typeof(short))
+                return Int16.Parse(serializedValue, CultureInfo.InvariantCulture);
+
+            if (type == typeof(ushort?) || type == typeof(ushort))
+                return UInt16.Parse(serializedValue, CultureInfo.InvariantCulture);
+
             if (type == typeof(int?) || type == typeof(int))
                 return Int32.Parse(serializedValue, CultureInfo.InvariantCulture);
 
+            if (type == typeof(uint?) || type == typeof(uint))
+                return UInt32.Parse(serializedValue, CultureInfo.InvariantCulture);
+
             if (type == typeof(long?) || type == typeof(long))
                 return Int64.Parse(serializedValue, CultureInfo.InvariantCulture);
 
+            if (type == typeof(ulong?) || type == typeof(ulong))
+                return UInt64.Parse(serializedValue, CultureInfo.InvariantCulture);
+
             if (type == typeof(float?) || type == typeof(float))
                 return Single.Parse(serializedValue, CultureInfo.InvariantCulture);
 
@@ -192,14 +209,38 @@ public static string Serialize(object value)
                 return info.ToSerializedString();
             }
 
+            var charData = value as char?;
+            if (charData != null)
+                return ((ushort)charData.GetValueOrDefault()).ToString(CultureInfo.InvariantCulture);
+
             var stringData = value as string;
             if (stringData != null)
                 return ToBase64(stringData);
 
+            var byteData = value as byte?;
+            if (byteData != null)
+                return byteData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);
+
+            var ushortData = value as ushort?;
+            if (ushortData != null)
+                return ushortData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);
+
+            var shortData = value as short?;
+            if (shortData != null)
+                return shortData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);
+
+            var uintData = value as uint?;
+            if (uintData != null)
+                return uintData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);
+
             var intData = value as int?;
             if (intData != null)
                 return intData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);
 
+            var ulongData = value as ulong?;
+            if (ulongData != null)
+                return ulongData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);
+
             var longData = value as long?;
             if (longData != null)
                 return longData.GetValueOrDefault().ToString(CultureInfo.InvariantCulture);
@@ -258,10 +299,16 @@ public static string Serialize(object value)
 
         static readonly Type[] supportedSerializationTypes = new[] {
             typeof(IXunitSerializable),
+            typeof(char),           typeof(char?),
             typeof(string),
             typeof(Type),
+            typeof(byte),           typeof(byte?),
+            typeof(short),          typeof(short?),
+            typeof(ushort),         typeof(ushort?),
             typeof(int),            typeof(int?),
+            typeof(uint),           typeof(uint?),
             typeof(long),           typeof(long?),
+            typeof(ulong),          typeof(ulong?),
             typeof(float),          typeof(float?),
             typeof(double),         typeof(double?),
             typeof(decimal),        typeof(decimal?),
diff --git a/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs b/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
index f1a69b07..d1f66802 100644
--- a/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
+++ b/test/test.xunit.execution/Common/XunitSerializationInfoTests.cs
@@ -12,15 +12,33 @@ public static IEnumerable<object[]> SupportedIntrinsics
     {
         get
         {
+            yield return new object[] { typeof(char), char.MaxValue };
+            yield return new object[] { typeof(char?), char.MinValue };
+            yield return new object[] { typeof(char?), null };
             yield return new object[] { typeof(string), "Hello, world!" };
             yield return new object[] { typeof(string), "" };
             yield return new object[] { typeof(string), null };
+            yield return new object[] { typeof(byte), byte.MaxValue };
+            yield return new object[] { typeof(byte?), byte.MinValue };
+            yield return new object[] { typeof(byte?), null };
+            yield return new object[] { typeof(short), short.MaxValue };
+            yield return new object[] { typeof(short?), short.MinValue };
+            yield return new object[] { typeof(short?), null };
+            yield return new object[] { typeof(ushort), ushort.MaxValue };
+            yield return new object[] { typeof(ushort?), ushort.MinValue };
+            yield return new object[] { typeof(ushort?), null };
             yield return new object[] { typeof(int), int.MaxValue };
             yield return new object[] { typeof(int?), int.MinValue };
             yield return new object[] { typeof(int?), null };
+            yield return new object[] { typeof(uint), uint.MaxValue };
+            yield return new object[] { typeof(uint?), uint.MinValue };
+            yield return new object[] { typeof(uint?), null };
             yield return new object[] { typeof(long), long.MaxValue };
             yield return new object[] { typeof(long?), long.MinValue };
             yield return new object[] { typeof(long?), null };
+            yield return new object[] { typeof(ulong), ulong.MaxValue };
+            yield return new object[] { typeof(ulong?), ulong.MinValue };
+            yield return new object[] { typeof(ulong?), null };
             yield return new object[] { typeof(float), 1.1f };
             yield return new object[] { typeof(float?), -1.1f };
             yield return new object[] { typeof(float?), null };
@@ -44,7 +62,7 @@ public static IEnumerable<object[]> SupportedIntrinsics
             yield return new object[] { typeof(DateTimeOffset?), null };
             yield return new object[] { typeof(Type), typeof(object) };
             yield return new object[] { typeof(Type), null };
-            yield return new object[] { typeof(object[]), new object[] { int.MinValue, long.MaxValue, null, "", 1.1f, -2.2, decimal.MaxValue, true, MyEnum.SomeValue, DateTime.Now, DateTimeOffset.UtcNow, typeof(decimal) } };
+            yield return new object[] { typeof(object[]), new object[] { char.MaxValue, byte.MaxValue, short.MinValue, ushort.MaxValue, int.MinValue, uint.MaxValue, long.MinValue, ulong.MaxValue, null, "", 1.1f, -2.2, decimal.MaxValue, true, MyEnum.SomeValue, DateTime.Now, DateTimeOffset.UtcNow, typeof(decimal) } };
         }
     }
 
