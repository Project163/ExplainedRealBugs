diff --git a/src/xunit.core/MemberDataAttribute.cs b/src/xunit.core/MemberDataAttribute.cs
index 5dab7522..d0349900 100644
--- a/src/xunit.core/MemberDataAttribute.cs
+++ b/src/xunit.core/MemberDataAttribute.cs
@@ -15,6 +15,7 @@ namespace Xunit
     /// The member must return something compatible with IEnumerable&lt;object[]&gt; with the test data.
     /// </summary>
     [CLSCompliant(false)]
+    [DataDiscoverer("Xunit.Sdk.MemberDataDiscoverer", "xunit.core")]
     [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
     public sealed class MemberDataAttribute : DataAttribute
     {
@@ -29,6 +30,13 @@ public MemberDataAttribute(string memberName, params object[] parameters)
             Parameters = parameters;
         }
 
+        /// <summary>
+        /// Returns <c>true</c> if the data attribute wants to skip enumerating data during discovery.
+        /// This will cause the theory to yield a single test case for all data, and the data discovery
+        /// will be during during test execution instead of discovery.
+        /// </summary>
+        public bool DisableDiscoveryEnumeration { get; set; }
+
         /// <summary>
         /// Gets the member name.
         /// </summary>
diff --git a/src/xunit.core/Sdk/DataDiscoverer.cs b/src/xunit.core/Sdk/DataDiscoverer.cs
index 571d5809..fcc5227c 100644
--- a/src/xunit.core/Sdk/DataDiscoverer.cs
+++ b/src/xunit.core/Sdk/DataDiscoverer.cs
@@ -1,4 +1,5 @@
-﻿using System.Collections.Generic;
+﻿using System;
+using System.Collections.Generic;
 using Xunit.Abstractions;
 
 namespace Xunit.Sdk
@@ -21,5 +22,11 @@ public virtual IEnumerable<object[]> GetData(IAttributeInfo dataAttribute, IMeth
 
             return null;
         }
+
+        /// <inheritdoc/>
+        public virtual bool SupportsDiscoveryEnumeration(IAttributeInfo dataAttribute, IMethodInfo testMethod)
+        {
+            return true;
+        }
     }
 }
\ No newline at end of file
diff --git a/src/xunit.core/Sdk/IDataDiscoverer.cs b/src/xunit.core/Sdk/IDataDiscoverer.cs
index 2e78b5f6..9d8e7a2f 100644
--- a/src/xunit.core/Sdk/IDataDiscoverer.cs
+++ b/src/xunit.core/Sdk/IDataDiscoverer.cs
@@ -31,5 +31,12 @@ public interface IDataDiscoverer
         /// <returns>The theory data (or null during discovery, if not enough
         /// information is available to enumerate the data)</returns>
         IEnumerable<object[]> GetData(IAttributeInfo dataAttribute, IMethodInfo testMethod);
+
+        /// <summary>
+        /// Returns <c>true</c> if the data attribute supports enumeration during
+        /// discovery; <c>false</c> otherwise. Data attributes with expensive computational
+        /// costs should return <c>false</c>.
+        /// </summary>
+        bool SupportsDiscoveryEnumeration(IAttributeInfo dataAttribute, IMethodInfo testMethod);
     }
 }
\ No newline at end of file
diff --git a/src/xunit.core/Sdk/InlineDataDiscoverer.cs b/src/xunit.core/Sdk/InlineDataDiscoverer.cs
index cd41ec6b..9b1c58b5 100644
--- a/src/xunit.core/Sdk/InlineDataDiscoverer.cs
+++ b/src/xunit.core/Sdk/InlineDataDiscoverer.cs
@@ -24,5 +24,11 @@ public virtual IEnumerable<object[]> GetData(IAttributeInfo dataAttribute, IMeth
             var args = (IEnumerable<object>)dataAttribute.GetConstructorArguments().Single() ?? new object[] { null };
             return new[] { args.ToArray() };
         }
+
+        /// <inheritdoc/>
+        public virtual bool SupportsDiscoveryEnumeration(IAttributeInfo dataAttribute, IMethodInfo testMethod)
+        {
+            return true;
+        }
     }
 }
\ No newline at end of file
diff --git a/src/xunit.core/Sdk/MemberDataDiscoverer.cs b/src/xunit.core/Sdk/MemberDataDiscoverer.cs
new file mode 100644
index 00000000..6541f525
--- /dev/null
+++ b/src/xunit.core/Sdk/MemberDataDiscoverer.cs
@@ -0,0 +1,16 @@
+﻿using Xunit.Abstractions;
+
+namespace Xunit.Sdk
+{
+    /// <summary>
+    /// Implementation of <see cref="IDataDiscoverer"/> for discovering <see cref="MemberDataAttribute"/>.
+    /// </summary>
+    public class MemberDataDiscoverer : DataDiscoverer
+    {
+        /// <inheritdoc/>
+        public override bool SupportsDiscoveryEnumeration(IAttributeInfo dataAttribute, IMethodInfo testMethod)
+        {
+            return !dataAttribute.GetNamedArgument<bool>("DisableDiscoveryEnumeration");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/xunit.core/xunit.core.csproj b/src/xunit.core/xunit.core.csproj
index c07c1ef3..46504710 100644
--- a/src/xunit.core/xunit.core.csproj
+++ b/src/xunit.core/xunit.core.csproj
@@ -66,6 +66,7 @@
     <Compile Include="Sdk\ArgumentFormatter.cs" />
     <Compile Include="Sdk\BeforeAfterTestAttribute.cs" />
     <Compile Include="Sdk\DataAttribute.cs" />
+    <Compile Include="Sdk\MemberDataDiscoverer.cs" />
     <Compile Include="Sdk\DataDiscoverer.cs" />
     <Compile Include="Sdk\DataDiscovererAttribute.cs" />
     <Compile Include="Sdk\ExceptionAggregator.cs" />
diff --git a/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs b/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
index ee2b07a5..80762226 100644
--- a/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
+++ b/src/xunit.execution/Sdk/Frameworks/TheoryDiscoverer.cs
@@ -20,17 +20,20 @@ public IEnumerable<IXunitTestCase> Discover(ITestMethod testMethod, IAttributeIn
             if (factAttribute.GetNamedArgument<string>("Skip") != null)
                 return new[] { new XunitTestCase(testMethod) };
 
+            var dataAttributes = testMethod.Method.GetCustomAttributes(typeof(DataAttribute));
+
             try
             {
                 using (var memoryStream = new MemoryStream())
                 {
                     var results = new List<XunitTestCase>();
 
-                    var dataAttributes = testMethod.Method.GetCustomAttributes(typeof(DataAttribute));
                     foreach (var dataAttribute in dataAttributes)
                     {
                         var discovererAttribute = dataAttribute.GetCustomAttributes(typeof(DataDiscovererAttribute)).First();
                         var discoverer = ExtensibilityPointFactory.GetDataDiscoverer(discovererAttribute);
+                        if (!discoverer.SupportsDiscoveryEnumeration(dataAttribute, testMethod.Method))
+                            return new XunitTestCase[] { new XunitTheoryTestCase(testMethod) };
 
                         // GetData may return null, but that's okay; we'll let the NullRef happen and then catch it
                         // down below so that we get the composite test case.
diff --git a/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs b/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs
index 55bc3396..6cec7c60 100644
--- a/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs
+++ b/test/test.xunit.execution/Sdk/Frameworks/TheoryDiscovererTests.cs
@@ -145,6 +145,56 @@ class NonSerializableDataClass
         public void TheoryMethod(object a) { }
     }
 
+    [Fact]
+    public static void NonDiscoveryEnumeratedDataYieldsSingleTheoryTestCase()
+    {
+        var discoverer = new TheoryDiscoverer();
+        var testMethod = Mocks.TestMethod(typeof(NonDiscoveryEnumeratedData), "TheoryMethod");
+        var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();
+
+        var testCases = discoverer.Discover(testMethod, factAttribute);
+
+        var testCase = Assert.Single(testCases);
+        var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);
+        Assert.Equal("TheoryDiscovererTests+NonDiscoveryEnumeratedData.TheoryMethod", theoryTestCase.DisplayName);
+    }
+
+    class NonDiscoveryEnumeratedData
+    {
+        public static IEnumerable<object[]> foo { get { return Enumerable.Empty<object[]>(); } }
+        public static IEnumerable<object[]> bar { get { return Enumerable.Empty<object[]>(); } }
+
+        [Theory]
+        [MemberData("foo", DisableDiscoveryEnumeration = true)]
+        [MemberData("bar", DisableDiscoveryEnumeration = true)]
+        public static void TheoryMethod(int x) { }
+    }
+
+    [Fact]
+    public static void MixedDiscoveryEnumerationDataYieldSingleTheoryTestCase()
+    {
+        var discoverer = new TheoryDiscoverer();
+        var testMethod = Mocks.TestMethod(typeof(MixedDiscoveryEnumeratedData), "TheoryMethod");
+        var factAttribute = testMethod.Method.GetCustomAttributes(typeof(FactAttribute)).Single();
+
+        var testCases = discoverer.Discover(testMethod, factAttribute);
+
+        var testCase = Assert.Single(testCases);
+        var theoryTestCase = Assert.IsType<XunitTheoryTestCase>(testCase);
+        Assert.Equal("TheoryDiscovererTests+MixedDiscoveryEnumeratedData.TheoryMethod", theoryTestCase.DisplayName);
+    }
+
+    class MixedDiscoveryEnumeratedData
+    {
+        public static IEnumerable<object[]> foo { get { return Enumerable.Empty<object[]>(); } }
+        public static IEnumerable<object[]> bar { get { return Enumerable.Empty<object[]>(); } }
+
+        [Theory]
+        [MemberData("foo", DisableDiscoveryEnumeration = false)]
+        [MemberData("bar", DisableDiscoveryEnumeration = true)]
+        public static void TheoryMethod(int x) { }
+    }
+
     [Fact]
     public void SkippedTheoryWithNoData()
     {
