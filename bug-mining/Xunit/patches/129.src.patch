diff --git a/src/common/Microsoft.Extensions.DependencyModel/DependencyContextPaths.cs b/src/common/Microsoft.Extensions.DependencyModel/DependencyContextPaths.cs
index f93104aa..0e05c482 100644
--- a/src/common/Microsoft.Extensions.DependencyModel/DependencyContextPaths.cs
+++ b/src/common/Microsoft.Extensions.DependencyModel/DependencyContextPaths.cs
@@ -34,7 +34,7 @@ internal class DependencyContextPaths
 
         private static DependencyContextPaths GetCurrent()
         {
-#if NETCOREAPP1_0
+#if NETCOREAPP1_0 || NETCOREAPP2_0
             var deps = AppContext.GetData(DepsFilesProperty);
             var fxDeps = AppContext.GetData(FxDepsFileProperty);
 #elif NET452
diff --git a/src/common/Microsoft.Extensions.DependencyModel/Resolution/ResolverUtils.cs b/src/common/Microsoft.Extensions.DependencyModel/Resolution/ResolverUtils.cs
index 9e6700fd..82d3920b 100644
--- a/src/common/Microsoft.Extensions.DependencyModel/Resolution/ResolverUtils.cs
+++ b/src/common/Microsoft.Extensions.DependencyModel/Resolution/ResolverUtils.cs
@@ -28,7 +28,7 @@ internal static bool TryResolvePackagePath(IFileSystem fileSystem, CompilationLi
 
         internal static bool TryResolveAssemblyFile(IFileSystem fileSystem, string basePath, string assemblyPath, out string fullName)
         {
-            fullName = Path.Combine(basePath, assemblyPath);
+            fullName = Path.GetFullPath(Path.Combine(basePath, assemblyPath));
             if (fileSystem.File.Exists(fullName))
             {
                 return true;
diff --git a/src/common/Microsoft.Extensions.DependencyModel/TargetInfo.cs b/src/common/Microsoft.Extensions.DependencyModel/TargetInfo.cs
index 60896eed..a72c22c6 100644
--- a/src/common/Microsoft.Extensions.DependencyModel/TargetInfo.cs
+++ b/src/common/Microsoft.Extensions.DependencyModel/TargetInfo.cs
@@ -32,7 +32,6 @@ internal class TargetInfo
         public string RuntimeSignature { get; }
 
         public bool IsPortable { get; }
-
     }
 }
 
diff --git a/src/xunit.runner.utility/Utility/DependencyContextAssemblyCache.cs b/src/xunit.runner.utility/Utility/DependencyContextAssemblyCache.cs
index 8c940c27..7607850a 100644
--- a/src/xunit.runner.utility/Utility/DependencyContextAssemblyCache.cs
+++ b/src/xunit.runner.utility/Utility/DependencyContextAssemblyCache.cs
@@ -1,11 +1,12 @@
-﻿#if NET452 || NETCOREAPP1_0
+﻿#if NET452 || NETCOREAPP1_0 || NETCOREAPP2_0
 
 using System;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Reflection;
-using System.Runtime.InteropServices;
+using System.Text.RegularExpressions;
+using Internal.Microsoft.DotNet.PlatformAbstractions;
 using Internal.Microsoft.Extensions.DependencyModel;
 using Xunit.Abstractions;
 using RuntimeEnvironment = Internal.Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment;
@@ -14,39 +15,43 @@ namespace Xunit
 {
     class DependencyContextAssemblyCache
     {
-        static readonly string[] ManagedAssemblyExtensions = new[] { ".dll", ".exe" };
+        static readonly RuntimeFallbacks AnyAndBase = new RuntimeFallbacks("unknown", "any", "base");
+        static readonly string[] ManagedAssemblyExtensions = { ".dll", ".exe" };
         static readonly Tuple<string, Assembly> ManagedAssemblyNotFound = new Tuple<string, Assembly>(null, null);
+        static readonly Regex RuntimeIdRegex = new Regex(@"(?<os>[A-Za-z0-9]+)(\.(?<version>[0-9\.]+))?(?<arch>\-[A-Za-z0-9]+)?(?<extra>\-[A-Za-z0-9]+)?");
 
         readonly string assemblyFolder;
         readonly XunitPackageCompilationAssemblyResolver assemblyResolver;
+        readonly string currentRuntimeIdentifier;
         readonly DependencyContext dependencyContext;
+        readonly Lazy<string> fallbackRuntimeIdentifier;
+        readonly IFileSystem fileSystem;
         readonly IMessageSink internalDiagnosticsMessageSink;
         readonly Dictionary<string, Assembly> managedAssemblyCache;
         readonly Dictionary<string, Tuple<RuntimeLibrary, RuntimeAssetGroup>> managedAssemblyMap;
+        readonly Platform operatingSystemPlatform;
 
         public DependencyContextAssemblyCache(string assemblyFolder,
                                               DependencyContext dependencyContext,
-                                              IMessageSink internalDiagnosticsMessageSink)
+                                              IMessageSink internalDiagnosticsMessageSink,
+                                              Platform? operatingSystemPlatform = null,
+                                              string currentRuntimeIdentifier = null,
+                                              IFileSystem fileSystem = null)
         {
             this.assemblyFolder = assemblyFolder;
             this.dependencyContext = dependencyContext;
             this.internalDiagnosticsMessageSink = internalDiagnosticsMessageSink;
+            this.operatingSystemPlatform = operatingSystemPlatform ?? RuntimeEnvironment.OperatingSystemPlatform;
+            this.currentRuntimeIdentifier = currentRuntimeIdentifier ?? RuntimeEnvironment.GetRuntimeIdentifier();
+            this.fileSystem = fileSystem ?? new FileSystemWrapper();
 
-            assemblyResolver = new XunitPackageCompilationAssemblyResolver(internalDiagnosticsMessageSink);
+            fallbackRuntimeIdentifier = new Lazy<string>(() => GetFallbackRuntime(currentRuntimeIdentifier));
+            assemblyResolver = new XunitPackageCompilationAssemblyResolver(internalDiagnosticsMessageSink, fileSystem);
 
             if (internalDiagnosticsMessageSink != null)
                 internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache..ctor] Runtime graph: [{string.Join(",", dependencyContext.RuntimeGraph.Select(x => $"'{x.Runtime}'"))}]"));
 
-            var compatibleRuntimes = default(HashSet<string>);
-            var currentRuntime = RuntimeEnvironment.GetRuntimeIdentifier();
-            var fallbacks = dependencyContext.RuntimeGraph.FirstOrDefault(x => string.Equals(x.Runtime, currentRuntime, StringComparison.OrdinalIgnoreCase));
-            if (fallbacks != null)
-                compatibleRuntimes = new HashSet<string>(fallbacks.Fallbacks, StringComparer.OrdinalIgnoreCase);
-            else
-                compatibleRuntimes = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
-
-            compatibleRuntimes.Add(currentRuntime);
-            compatibleRuntimes.Add(string.Empty);
+            var compatibleRuntimes = GetCompatibleRuntimes(dependencyContext);
 
             if (internalDiagnosticsMessageSink != null)
                 internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache..ctor] Compatible runtimes: [{string.Join(",", compatibleRuntimes.Select(x => $"'{x}'"))}]"));
@@ -55,29 +60,81 @@ class DependencyContextAssemblyCache
             managedAssemblyMap =
                 dependencyContext.RuntimeLibraries
                                  .Where(lib => lib.RuntimeAssemblyGroups?.Count > 0)
-                                 .Select(lib => Tuple.Create(lib, lib.RuntimeAssemblyGroups.FirstOrDefault(libGroup => compatibleRuntimes.Contains(libGroup.Runtime))))
-                                 .Where(tuple => tuple.Item2?.AssetPaths != null)
-                                 .SelectMany(tuple => tuple.Item2.AssetPaths.Where(x => x != null).Select(path => Tuple.Create(Path.GetFileNameWithoutExtension(path), Tuple.Create(tuple.Item1, tuple.Item2))))
+                                 .Select(lib => compatibleRuntimes.Select(runtime => Tuple.Create(lib, lib.RuntimeAssemblyGroups.FirstOrDefault(libGroup => string.Equals(libGroup.Runtime, runtime))))
+                                                                  .FirstOrDefault(tuple => tuple.Item2?.AssetPaths != null))
+                                 .Where(tuple => tuple != null)
+                                 .SelectMany(tuple => tuple.Item2.AssetPaths.Where(x => x != null)
+                                                                            .Select(path => Tuple.Create(Path.GetFileNameWithoutExtension(path), Tuple.Create(tuple.Item1, tuple.Item2))))
                                  .ToDictionaryIgnoringDuplicateKeys(tuple => tuple.Item1, tuple => tuple.Item2, StringComparer.OrdinalIgnoreCase);
 
             if (internalDiagnosticsMessageSink != null)
-                internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache..ctor] Managed assembly map includes: {string.Join(",", managedAssemblyMap.Keys.Select(k => $"'{k}'").OrderBy(k => k, StringComparer.OrdinalIgnoreCase))}"));
+                internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache..ctor] Managed assembly map: [{string.Join(",", managedAssemblyMap.Keys.Select(k => $"'{k}'").OrderBy(k => k, StringComparer.OrdinalIgnoreCase))}]"));
 
-#if NETCOREAPP1_0
+#if NETCOREAPP1_0 || NETCOREAPP2_0
+            unmanagedDllFormats = GetUnmanagedDllFormats().ToArray();
             unmanagedAssemblyCache = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
             unmanagedAssemblyMap =
                 dependencyContext.RuntimeLibraries
-                                 .Where(lib => lib.NativeLibraryGroups?.Count > 0)
-                                 .Select(lib => Tuple.Create(lib, lib.NativeLibraryGroups.FirstOrDefault(libGroup => compatibleRuntimes.Contains(libGroup.Runtime))))
-                                 .Where(tuple => tuple.Item2?.AssetPaths != null)
-                                 .SelectMany(tuple => tuple.Item2.AssetPaths.Where(x => x != null).Select(path => Tuple.Create(Path.GetFileName(path), Tuple.Create(tuple.Item1, tuple.Item2))))
+                                 .Select(lib => compatibleRuntimes.Select(runtime => Tuple.Create(lib, lib.NativeLibraryGroups.FirstOrDefault(libGroup => string.Equals(libGroup.Runtime, runtime))))
+                                                                  .FirstOrDefault(tuple => tuple.Item2?.AssetPaths != null))
+                                 .Where(tuple => tuple != null)
+                                 .SelectMany(tuple => tuple.Item2.AssetPaths.Where(x => x != null)
+                                                                            .Select(path => Tuple.Create(Path.GetFileName(path), Tuple.Create(tuple.Item1, tuple.Item2))))
                                  .ToDictionaryIgnoringDuplicateKeys(tuple => tuple.Item1, tuple => tuple.Item2, StringComparer.OrdinalIgnoreCase);
 
             if (internalDiagnosticsMessageSink != null)
-                internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache..ctor] Unmanaged assembly map includes: {string.Join(",", unmanagedAssemblyMap.Keys.Select(k => $"'{k}'").OrderBy(k => k, StringComparer.OrdinalIgnoreCase))}"));
+                internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache..ctor] Unmanaged assembly map: [{string.Join(",", unmanagedAssemblyMap.Keys.Select(k => $"'{k}'").OrderBy(k => k, StringComparer.OrdinalIgnoreCase))}]"));
+#else
+            if (internalDiagnosticsMessageSink != null)
+                internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage("[DependencyContextAssemblyCache..ctor] Unmanaged assembly map: []"));
 #endif
         }
 
+        List<string> GetCompatibleRuntimes(DependencyContext dependencyContext)
+        {
+            var result = new List<string>(GetFallbacks(dependencyContext.RuntimeGraph).Fallbacks);
+            result.Insert(0, fallbackRuntimeIdentifier.IsValueCreated ? fallbackRuntimeIdentifier.Value : currentRuntimeIdentifier);
+            result.Add(string.Empty);
+            return result;
+        }
+
+        RuntimeFallbacks GetFallbacks(IReadOnlyList<RuntimeFallbacks> runtimeGraph)
+            => runtimeGraph.FirstOrDefault(x => string.Equals(x.Runtime, currentRuntimeIdentifier, StringComparison.OrdinalIgnoreCase))
+            ?? runtimeGraph.FirstOrDefault(x => string.Equals(x.Runtime, fallbackRuntimeIdentifier.Value, StringComparison.OrdinalIgnoreCase))
+            ?? AnyAndBase;
+
+        // This mimics the behavior of https://github.com/dotnet/core-setup/blob/863047f3ca16bada3ffc82493d1dbad6e560b80a/src/corehost/common/pal.h#L53-L73
+        string GetFallbackRuntime(string runtime)
+        {
+            var match = RuntimeIdRegex.Match(runtime);
+            var arch = match.Groups?["arch"]?.Value;
+            var result = default(string);
+
+            switch (operatingSystemPlatform)
+            {
+                case Platform.Windows:
+                    result = "win10" + arch;
+                    break;
+
+                case Platform.Darwin:
+                    result = "osx.10.12" + arch;
+                    break;
+
+                case Platform.Linux:
+                    result = "linux" + arch;
+                    break;
+
+                default:
+                    result = "unknown";
+                    break;
+            }
+
+            if (internalDiagnosticsMessageSink != null)
+                internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.GetFallbackRuntime] Could not find runtime '{runtime}', falling back to '{result}'"));
+
+            return result;
+        }
+
         public Assembly LoadManagedDll(string assemblyName, Func<string, Assembly> managedAssemblyLoader)
         {
             if (!managedAssemblyCache.TryGetValue(assemblyName, out var result))
@@ -102,13 +159,13 @@ public Assembly LoadManagedDll(string assemblyName, Func<string, Assembly> manag
         Tuple<string, Assembly> ResolveManagedAssembly(string assemblyName, Func<string, Assembly> managedAssemblyLoader)
         {
             // Try to find dependency in the local folder
-            var assemblyPath = Path.Combine(assemblyFolder, assemblyName);
+            var assemblyPath = Path.Combine(Path.GetFullPath(assemblyFolder), assemblyName);
 
             foreach (var extension in ManagedAssemblyExtensions)
                 try
                 {
                     var resolvedAssemblyPath = assemblyPath + extension;
-                    if (File.Exists(resolvedAssemblyPath))
+                    if (fileSystem.File.Exists(resolvedAssemblyPath))
                     {
                         var assembly = managedAssemblyLoader(resolvedAssemblyPath);
                         if (assembly != null)
@@ -123,7 +180,8 @@ public Assembly LoadManagedDll(string assemblyName, Func<string, Assembly> manag
                 var library = libraryTuple.Item1;
                 var assetGroup = libraryTuple.Item2;
                 var wrapper = new CompilationLibrary(library.Type, library.Name, library.Version, library.Hash,
-                                                     assetGroup.AssetPaths, library.Dependencies, library.Serviceable);
+                                                     assetGroup.AssetPaths, library.Dependencies, library.Serviceable,
+                                                     library.Path, library.HashPath);
 
                 var assemblies = new List<string>();
                 if (assemblyResolver.TryResolveAssemblyPaths(wrapper, assemblies))
@@ -156,58 +214,68 @@ public Assembly LoadManagedDll(string assemblyName, Func<string, Assembly> manag
             return ManagedAssemblyNotFound;
         }
 
-#if NETCOREAPP1_0
+#if NETCOREAPP1_0 || NETCOREAPP2_0
         // Unmanaged DLL support
 
-        static readonly string[] UnmanagedDllFormats = GetUnmanagedDllFormats().ToArray();
+        readonly string[] unmanagedDllFormats;
 
         readonly Dictionary<string, string> unmanagedAssemblyCache;
         readonly Dictionary<string, Tuple<RuntimeLibrary, RuntimeAssetGroup>> unmanagedAssemblyMap;
 
-        static IEnumerable<string> GetUnmanagedDllFormats()
+        IEnumerable<string> GetUnmanagedDllFormats()
         {
             yield return "{0}";
 
-            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
+            if (operatingSystemPlatform == Platform.Windows)
             {
                 yield return "{0}.dll";
             }
-            else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
+            else if (operatingSystemPlatform == Platform.Darwin)
             {
                 yield return "lib{0}.dylib";
                 yield return "{0}.dylib";
             }
-            else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux))
+            else if (operatingSystemPlatform == Platform.Linux)
             {
                 yield return "lib{0}.so";
                 yield return "{0}.so";
             }
         }
 
-        public IntPtr LoadUnmanagedDll(string unmanagedDllName, Func<string, IntPtr> unmanagedAssemblyLoader)
+        public IntPtr LoadUnmanagedLibrary(string unmanagedLibraryName, Func<string, IntPtr> unmanagedAssemblyLoader)
         {
-            if (!unmanagedAssemblyCache.TryGetValue(unmanagedDllName, out var resolvedAssemblyPath))
+            var result = default(IntPtr);
+            var needDiagnostics = false;
+
+            if (!unmanagedAssemblyCache.TryGetValue(unmanagedLibraryName, out var resolvedAssemblyPath))
             {
-                resolvedAssemblyPath = ResolveUnmanagedAssembly(unmanagedDllName);
-                unmanagedAssemblyCache[unmanagedDllName] = resolvedAssemblyPath;
+                resolvedAssemblyPath = ResolveUnmanagedLibrary(unmanagedLibraryName);
+                unmanagedAssemblyCache[unmanagedLibraryName] = resolvedAssemblyPath;
+                needDiagnostics = true;
+            }
 
-                if (internalDiagnosticsMessageSink != null)
+            if (resolvedAssemblyPath != null)
+                result = unmanagedAssemblyLoader(resolvedAssemblyPath);
+
+            if (needDiagnostics && internalDiagnosticsMessageSink != null)
+                if (result != default)
+                    internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.LoadUnmanagedLibrary] Resolved '{unmanagedLibraryName}' to '{resolvedAssemblyPath}'"));
+                else
                 {
-                    if (resolvedAssemblyPath == null)
-                        internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.LoadManagedDll] Resolution for '{unmanagedDllName}' failed, passed down to next resolver"));
-                    else
-                        internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved '{unmanagedDllName}' to '{resolvedAssemblyPath}'"));
+                    if (resolvedAssemblyPath != null)
+                        internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.LoadUnmanagedLibrary] Resolving '{unmanagedLibraryName}', found assembly path '{resolvedAssemblyPath}' but the assembly would not load"));
+
+                    internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.LoadUnmanagedLibrary] Resolution for '{unmanagedLibraryName}' failed, passed down to next resolver"));
                 }
-            }
 
-            return resolvedAssemblyPath != null ? unmanagedAssemblyLoader(resolvedAssemblyPath) : default;
+            return result;
         }
 
-        public string ResolveUnmanagedAssembly(string unmanagedDllName)
+        public string ResolveUnmanagedLibrary(string unmanagedLibraryName)
         {
-            foreach (var format in UnmanagedDllFormats)
+            foreach (var format in unmanagedDllFormats)
             {
-                var formattedUnmanagedDllName = string.Format(format, unmanagedDllName);
+                var formattedUnmanagedDllName = string.Format(format, unmanagedLibraryName);
 
                 if (unmanagedAssemblyMap.TryGetValue(formattedUnmanagedDllName, out var libraryTuple))
                 {
@@ -223,12 +291,12 @@ public string ResolveUnmanagedAssembly(string unmanagedDllName)
                             return Path.GetFullPath(resolvedAssemblyPath);
 
                         if (internalDiagnosticsMessageSink != null)
-                            internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.ResolveUnmanagedDll] Found a resolved path, but could not map a filename in [{string.Join(",", assemblies.OrderBy(k => k, StringComparer.OrdinalIgnoreCase).Select(k => $"'{k}'"))}]"));
+                            internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.ResolveUnmanagedLibrary] Found a resolved path, but could not map a filename in [{string.Join(",", assemblies.OrderBy(k => k, StringComparer.OrdinalIgnoreCase).Select(k => $"'{k}'"))}]"));
                     }
                     else
                     {
                         if (internalDiagnosticsMessageSink != null)
-                            internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.ResolveUnmanagedDll] Found in dependency map, but unable to resolve a path in [{string.Join(",", assetGroup.AssetPaths.OrderBy(k => k, StringComparer.OrdinalIgnoreCase).Select(k => $"'{k}'"))}]"));
+                            internalDiagnosticsMessageSink.OnMessage(new DiagnosticMessage($"[DependencyContextAssemblyCache.ResolveUnmanagedLibrary] Found in dependency map, but unable to resolve a path in [{string.Join(",", assetGroup.AssetPaths.OrderBy(k => k, StringComparer.OrdinalIgnoreCase).Select(k => $"'{k}'"))}]"));
                     }
                 }
             }
diff --git a/src/xunit.runner.utility/Utility/DependencyModel/XunitPackageCompilationAssemblyResolver.cs b/src/xunit.runner.utility/Utility/DependencyModel/XunitPackageCompilationAssemblyResolver.cs
index c7041160..aa87ad76 100644
--- a/src/xunit.runner.utility/Utility/DependencyModel/XunitPackageCompilationAssemblyResolver.cs
+++ b/src/xunit.runner.utility/Utility/DependencyModel/XunitPackageCompilationAssemblyResolver.cs
@@ -1,4 +1,4 @@
-﻿#if NET452 || NETCOREAPP1_0
+﻿#if NET452 || NETCOREAPP1_0 || NETCOREAPP2_0
 
 // Adapted from https://github.com/dotnet/core-setup/blob/652b680dff6b1afb9cd26cc3c2e883a664c209fd/src/managed/Microsoft.Extensions.DependencyModel/Resolution/PackageCompilationAssemblyResolver.cs
 
@@ -15,12 +15,14 @@ namespace Xunit
 {
     class XunitPackageCompilationAssemblyResolver : ICompilationAssemblyResolver
     {
-        static readonly IFileSystem fileSystem = new FileSystemWrapper();
+        readonly IFileSystem fileSystem;
         readonly List<string> nugetPackageDirectories;
 
-        public XunitPackageCompilationAssemblyResolver(IMessageSink internalDiagnosticsMessageSink)
+        public XunitPackageCompilationAssemblyResolver(IMessageSink internalDiagnosticsMessageSink,
+                                                       IFileSystem fileSystem = null)
         {
             nugetPackageDirectories = GetDefaultProbeDirectories(internalDiagnosticsMessageSink);
+            this.fileSystem = fileSystem ?? new FileSystemWrapper();
         }
 
         static List<string> GetDefaultProbeDirectories(IMessageSink internalDiagnosticsMessageSink) =>
diff --git a/src/xunit.runner.utility/Utility/NetCoreAssemblyDependencyResolver.cs b/src/xunit.runner.utility/Utility/NetCoreAssemblyDependencyResolver.cs
index e10a3fdf..bd6c6831 100644
--- a/src/xunit.runner.utility/Utility/NetCoreAssemblyDependencyResolver.cs
+++ b/src/xunit.runner.utility/Utility/NetCoreAssemblyDependencyResolver.cs
@@ -54,7 +54,7 @@ protected override Assembly Load(AssemblyName assemblyName)
         /// <inheritdoc/>
         protected override IntPtr LoadUnmanagedDll(string unmanagedDllName)
         {
-            var result = assemblyCache.LoadUnmanagedDll(unmanagedDllName, path => LoadUnmanagedDllFromPath(path));
+            var result = assemblyCache.LoadUnmanagedLibrary(unmanagedDllName, path => LoadUnmanagedDllFromPath(path));
             if (result == default)
                 result = base.LoadUnmanagedDll(unmanagedDllName);
 
diff --git a/test/GlobalTestAssemblyInfo.cs b/test/GlobalTestAssemblyInfo.cs
index 5fb769d2..80d3ecb6 100644
--- a/test/GlobalTestAssemblyInfo.cs
+++ b/test/GlobalTestAssemblyInfo.cs
@@ -1,7 +1,9 @@
 using System.Reflection;
+using System.Runtime.CompilerServices;
 using Xunit;
 
 [assembly: AssemblyVersion("99.99.99.0")]
+[assembly: InternalsVisibleTo("DynamicProxyGenAssembly2")]
 
 #if !NET40
 [assembly: AssemblyTrait("Assembly", "Trait")]
diff --git a/test/test.xunit.runner.utility/TestDoubles/DummyAssembly.cs b/test/test.xunit.runner.utility/TestDoubles/DummyAssembly.cs
new file mode 100644
index 00000000..5e2ddf99
--- /dev/null
+++ b/test/test.xunit.runner.utility/TestDoubles/DummyAssembly.cs
@@ -0,0 +1,11 @@
+﻿using System.Reflection;
+
+class DummyAssembly : Assembly
+{
+    readonly string location;
+
+    public DummyAssembly(string location)
+        => this.location = location;
+
+    public override string Location => location;
+}
diff --git a/test/test.xunit.runner.utility/TestDoubles/NuGetHelper.cs b/test/test.xunit.runner.utility/TestDoubles/NuGetHelper.cs
new file mode 100644
index 00000000..02becf68
--- /dev/null
+++ b/test/test.xunit.runner.utility/TestDoubles/NuGetHelper.cs
@@ -0,0 +1,16 @@
+﻿using System;
+using System.IO;
+
+static class NuGetHelper
+{
+    static NuGetHelper()
+    {
+        var homePath = Environment.GetEnvironmentVariable("USERPROFILE")
+                    ?? Environment.GetEnvironmentVariable("HOME")
+                    ?? throw new InvalidOperationException("Cannot find the home path for the current user");
+
+        PackageCachePath = Path.Combine(homePath, ".nuget", "packages");
+    }
+
+    public static readonly string PackageCachePath;
+}
diff --git a/test/test.xunit.runner.utility/TestDoubles/TestableDependencyContext.cs b/test/test.xunit.runner.utility/TestDoubles/TestableDependencyContext.cs
new file mode 100644
index 00000000..a236e4b6
--- /dev/null
+++ b/test/test.xunit.runner.utility/TestDoubles/TestableDependencyContext.cs
@@ -0,0 +1,19 @@
+﻿using System.Collections.Generic;
+using System.Linq;
+using Internal.Microsoft.Extensions.DependencyModel;
+
+class TestableDependencyContext : DependencyContext
+{
+    static readonly TargetInfo DummyTargetInfo = new TargetInfo("framework", "runtime", "runtime-signature", isPortable: true);
+    static readonly IEnumerable<CompilationLibrary> EmptyCompilationLibraries = Enumerable.Empty<CompilationLibrary>();
+
+    public List<RuntimeFallbacks> InnerRuntimeGraph;
+    public List<RuntimeLibrary> InnerRuntimeLibraries;
+
+    public TestableDependencyContext(List<RuntimeLibrary> runtimeLibraries, List<RuntimeFallbacks> runtimeGraph)
+        : base(DummyTargetInfo, CompilationOptions.Default, EmptyCompilationLibraries, runtimeLibraries, runtimeGraph)
+    {
+        InnerRuntimeLibraries = runtimeLibraries;
+        InnerRuntimeGraph = runtimeGraph;
+    }
+}
diff --git a/test/test.xunit.runner.utility/TestDoubles/TestableDependencyContextAssemblyCache.cs b/test/test.xunit.runner.utility/TestDoubles/TestableDependencyContextAssemblyCache.cs
new file mode 100644
index 00000000..7a1721cc
--- /dev/null
+++ b/test/test.xunit.runner.utility/TestDoubles/TestableDependencyContextAssemblyCache.cs
@@ -0,0 +1,149 @@
+﻿using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Linq;
+using System.Reflection;
+using Internal.Microsoft.DotNet.PlatformAbstractions;
+using Internal.Microsoft.Extensions.DependencyModel;
+using NSubstitute;
+using Xunit;
+using Xunit.Abstractions;
+
+class TestableDependencyContextAssemblyCache : DependencyContextAssemblyCache
+{
+    static readonly string[] AnyRuntimes = new[] { "any", "base" };
+    static readonly IEnumerable<Dependency> EmptyDependencies = Enumerable.Empty<Dependency>();
+    static readonly IEnumerable<ResourceAssembly> EmptyResourceAssemblies = Enumerable.Empty<ResourceAssembly>();
+    static readonly Dictionary<Platform, List<RuntimeFallbacks>> RuntimeGraphs = new Dictionary<Platform, List<RuntimeFallbacks>>
+    {
+        // These aren't required to be full lists, just known quanitities. The Darwin list is more complete because it's
+        // used for the platform-dependent unit tests. The Windows and Linux lists are just full enough to test fallback logic.
+        {
+            Platform.Darwin,
+            new List<RuntimeFallbacks>
+            {
+                new RuntimeFallbacks("osx.10.12-x64", "osx.10.12", "osx.10.11-x64", "osx.10.11", "osx.10.10-x64", "osx.10.10", "osx-x64", "osx", "unix-x64", "unix", "any", "base"),
+                new RuntimeFallbacks("osx.10.12", "osx.10.11", "osx.10.10", "osx", "unix", "any", "base"),
+                new RuntimeFallbacks("osx.10.11-x64", "osx.10.11", "osx.10.10-x64", "osx.10.10", "osx-x64", "osx", "unix-x64", "unix", "any", "base"),
+                new RuntimeFallbacks("osx.10.11", "osx.10.10", "osx", "unix", "any", "base"),
+                new RuntimeFallbacks("osx.10.10-x64", "osx.10.10", "osx-x64", "osx", "unix-x64", "unix", "any", "base"),
+                new RuntimeFallbacks("osx.10.10", "osx", "unix", "any", "base"),
+                new RuntimeFallbacks("osx-x64", "osx", "unix-x64", "unix", "any", "base"),
+                new RuntimeFallbacks("osx", "unix", "any", "base"),
+            }
+        },
+        {
+            Platform.Linux,
+            new List<RuntimeFallbacks>
+            {
+                new RuntimeFallbacks("ubuntu.16.04-x64", "ubuntu.16.04", "ubuntu-x64", "ubuntu", "linux-x64", "linux", "unix-x64", "unix", "any", "base"),
+                new RuntimeFallbacks("ubuntu.16.04", "ubuntu", "linux", "unix", "any", "base"),
+                new RuntimeFallbacks("linux-x64", "linux", "unix-x64", "unix", "any", "base"),
+                new RuntimeFallbacks("linux", "unix", "any", "base"),
+            }
+        },
+        {
+            Platform.Windows,
+            new List<RuntimeFallbacks>
+            {
+                new RuntimeFallbacks("win10-x64", "win10", "win8-x64", "win8", "win7-x64", "win7", "win", "any", "base"),
+                new RuntimeFallbacks("win10", "win8", "win7", "win", "any", "base"),
+            }
+        },
+        { Platform.Unknown, new List<RuntimeFallbacks>() }
+    };
+
+    readonly TestableDependencyContext dependencyContext;
+    readonly SpyMessageSink<IDiagnosticMessage> internalDiagnosticsMessageSink;
+
+    TestableDependencyContextAssemblyCache(TestableDependencyContext dependencyContext,
+                                           SpyMessageSink<IDiagnosticMessage> internalDiagnosticsMessageSink,
+                                           Platform operatingSystemPlatform,
+                                           string currentRuntimeIdentifier,
+                                           IFileSystem fileSystem,
+                                           string assemblyFolder = "/assembly/root")
+        : base(assemblyFolder, dependencyContext, internalDiagnosticsMessageSink, operatingSystemPlatform, currentRuntimeIdentifier, fileSystem)
+    {
+        this.dependencyContext = dependencyContext;
+        this.internalDiagnosticsMessageSink = internalDiagnosticsMessageSink;
+
+        AssemblyFolder = Path.GetFullPath(assemblyFolder);
+
+        FileSystem = fileSystem;
+        FileSystem.File.Returns(Substitute.For<IFile>());
+        FileSystem.Directory.Returns(Substitute.For<IDirectory>());
+        FileSystem.Directory.Exists(Path.GetFullPath(AssemblyFolder)).Returns(true);
+
+        OperatingSystemPlatform = operatingSystemPlatform;
+    }
+
+    public string AssemblyFolder { get; }
+    public IFileSystem FileSystem { get; }
+    public List<string> MissingFileNames = new List<string>();
+    public Platform OperatingSystemPlatform { get; }
+    public List<RuntimeFallbacks> RuntimeGraph => dependencyContext.InnerRuntimeGraph;
+    public List<RuntimeLibrary> RuntimeLibraries => dependencyContext.InnerRuntimeLibraries;
+
+    public List<string> GetAndClearDiagnosticMessages()
+    {
+        var result = internalDiagnosticsMessageSink.Messages.OfType<IDiagnosticMessage>().Select(_ => _.Message).ToList();
+        internalDiagnosticsMessageSink.Messages.Clear();
+        return result;
+    }
+
+    public Assembly LoadManagedDll(string assemblyName)
+        => LoadManagedDll(assemblyName, location => new DummyAssembly(location));
+
+#if NETCOREAPP2_0
+    public IntPtr LoadUnmanagedLibrary(string unmanagedLibraryName)
+        => LoadUnmanagedLibrary(unmanagedLibraryName, location => new IntPtr(42));
+#endif
+
+    public void MockAllLibrariesPresentInNuGetCache()
+    {
+        foreach (var runtimeLibrary in RuntimeLibraries)
+        {
+            var packagePath = Path.GetFullPath(Path.Combine(NuGetHelper.PackageCachePath, runtimeLibrary.Name.ToLowerInvariant(), runtimeLibrary.Version.ToLowerInvariant()));
+            FileSystem.Directory.Exists(packagePath).Returns(true);
+
+            foreach (var assetPath in runtimeLibrary.RuntimeAssemblyGroups.SelectMany(group => group.AssetPaths)
+                              .Concat(runtimeLibrary.NativeLibraryGroups.SelectMany(group => group.AssetPaths)))
+            {
+                FileSystem.File.Exists(Path.GetFullPath(Path.Combine(packagePath, assetPath))).Returns(true);
+            }
+        }
+    }
+
+    public static TestableDependencyContextAssemblyCache Create(Platform platform = Platform.Windows, string runtime = "win10-x64", params string[] compatibleRuntimes)
+    {
+        if (compatibleRuntimes == null || compatibleRuntimes.Length == 0)
+            compatibleRuntimes = AnyRuntimes;
+
+        var runtimeAssemblyGroups = compatibleRuntimes.Select(r => new RuntimeAssetGroup(r, $"runtime/{r}/managed.ref1.dll", $"runtime/{r}/managed.ref2.dll")).ToList();
+        var nativeLibraryGroups = new[]
+        {
+            new RuntimeAssetGroup("win", "native/win/dependency1.dll", "native/win/dependency2.dll"),
+            new RuntimeAssetGroup("osx", "native/osx/dependency1.dylib", "native/osx/libdependency2.dylib"),
+            new RuntimeAssetGroup("linux", "native/linux/dependency1.so", "native/linux/libdependency2.so"),
+        };
+        var runtimeLibraries = new List<RuntimeLibrary>
+        {
+            new RuntimeLibrary("package", "PackageName", "1.2.3.4", "abcdef1234567890", runtimeAssemblyGroups, nativeLibraryGroups, EmptyResourceAssemblies, EmptyDependencies, true),
+        };
+
+        var runtimeGraph = RuntimeGraphs[platform];
+
+        return new TestableDependencyContextAssemblyCache(new TestableDependencyContext(runtimeLibraries, runtimeGraph),
+                                                          new SpyMessageSink<IDiagnosticMessage>(),
+                                                          platform,
+                                                          runtime,
+                                                          Substitute.For<IFileSystem>());
+    }
+
+    public static TestableDependencyContextAssemblyCache CreateEmpty()
+        => new TestableDependencyContextAssemblyCache(new TestableDependencyContext(new List<RuntimeLibrary>(), new List<RuntimeFallbacks>()),
+                                                      new SpyMessageSink<IDiagnosticMessage>(),
+                                                      Platform.Unknown,
+                                                      "unknown",
+                                                      Substitute.For<IFileSystem>());
+}
diff --git a/test/test.xunit.runner.utility/Utility/DependencyContextAssemblyCacheTests.cs b/test/test.xunit.runner.utility/Utility/DependencyContextAssemblyCacheTests.cs
new file mode 100644
index 00000000..5d37ba24
--- /dev/null
+++ b/test/test.xunit.runner.utility/Utility/DependencyContextAssemblyCacheTests.cs
@@ -0,0 +1,348 @@
+﻿using System;
+using System.IO;
+using Internal.Microsoft.DotNet.PlatformAbstractions;
+using NSubstitute;
+using Xunit;
+
+public static class DependencyContextAssemblyCacheTests
+{
+    public class Initialization
+    {
+        [Theory]
+        [InlineData(Platform.Darwin,
+                    "osx.10.10-x64",
+                    "['osx.10.12-x64','osx.10.12','osx.10.11-x64','osx.10.11','osx.10.10-x64','osx.10.10','osx-x64','osx']",
+                    "['osx.10.10-x64','osx.10.10','osx-x64','osx','unix-x64','unix','any','base','']",
+#if NETCOREAPP2_0
+                    "['dependency1.dylib','libdependency2.dylib']"
+#else
+                    "[]"
+#endif
+        )]
+        [InlineData(Platform.Linux,
+                    "ubuntu.16.04-x64",
+                    "['ubuntu.16.04-x64','ubuntu.16.04','linux-x64','linux']",
+                    "['ubuntu.16.04-x64','ubuntu.16.04','ubuntu-x64','ubuntu','linux-x64','linux','unix-x64','unix','any','base','']",
+#if NETCOREAPP2_0
+                    "['dependency1.so','libdependency2.so']"
+#else
+                    "[]"
+#endif
+        )]
+        [InlineData(Platform.Windows,
+                    "win10-x64",
+                    "['win10-x64','win10']",
+                    "['win10-x64','win10','win8-x64','win8','win7-x64','win7','win','any','base','']",
+#if NETCOREAPP2_0
+                    "['dependency1.dll','dependency2.dll']"
+#else
+                    "[]"
+#endif
+        )]
+        internal void KnownRuntime(Platform platform, string runtime, string expectedRuntimeGraph, string expectedCompatibleRuntimes, string expectedUnmanagedMap)
+        {
+            var cache = TestableDependencyContextAssemblyCache.Create(platform, runtime);
+
+            Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                message => Assert.Equal<object>($"[XunitPackageCompilationAssemblyResolver.GetDefaultProbeDirectories] returns: ['{NuGetHelper.PackageCachePath}']", message),
+                message => Assert.Equal<object>($"[DependencyContextAssemblyCache..ctor] Runtime graph: {expectedRuntimeGraph}", message),
+                message => Assert.Equal<object>($"[DependencyContextAssemblyCache..ctor] Compatible runtimes: {expectedCompatibleRuntimes}", message),
+                message => Assert.Equal<object>("[DependencyContextAssemblyCache..ctor] Managed assembly map: ['managed.ref1','managed.ref2']", message),
+                message => Assert.Equal<object>($"[DependencyContextAssemblyCache..ctor] Unmanaged assembly map: {expectedUnmanagedMap}", message)
+            );
+        }
+
+        [Theory]
+        [InlineData(Platform.Darwin,
+                    "rush.21.12-x64",
+                    "osx.10.12-x64",
+                    "['osx.10.12-x64','osx.10.12','osx.10.11-x64','osx.10.11','osx.10.10-x64','osx.10.10','osx-x64','osx','unix-x64','unix','any','base','']")]
+        [InlineData(Platform.Darwin,
+                    "rush.21.12",
+                    "osx.10.12",
+                    "['osx.10.12','osx.10.11','osx.10.10','osx','unix','any','base','']")]
+        [InlineData(Platform.Linux,
+                    "rush.21.12-x64",
+                    "linux-x64",
+                    "['linux-x64','linux','unix-x64','unix','any','base','']")]
+        [InlineData(Platform.Linux,
+                    "rush.21.12",
+                    "linux",
+                    "['linux','unix','any','base','']")]
+        [InlineData(Platform.Windows,
+                    "rush.21.12-x64",
+                    "win10-x64",
+                    "['win10-x64','win10','win8-x64','win8','win7-x64','win7','win','any','base','']")]
+        [InlineData(Platform.Windows,
+                    "rush.21.12",
+                    "win10",
+                    "['win10','win8','win7','win','any','base','']")]
+        internal void UnknownRuntime(Platform platform, string runtime, string expectedFallbackRuntime, string expectedCompatibleRuntimes)
+        {
+            var cache = TestableDependencyContextAssemblyCache.Create(platform, runtime);
+
+            Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                message => { },  // NuGet path is same as known runtime
+                message => { },  // Runtime graph is same as known runtime
+                message => Assert.Equal($"[DependencyContextAssemblyCache.GetFallbackRuntime] Could not find runtime '{runtime}', falling back to '{expectedFallbackRuntime}'", message),
+                message => Assert.Equal($"[DependencyContextAssemblyCache..ctor] Compatible runtimes: {expectedCompatibleRuntimes}", message),
+                message => { },  // Managed assembly map is the same as known runtime
+                message => { }   // Unmanaged assembly map is the same as known runtime
+            );
+        }
+    }
+
+    public class EmptyCache
+    {
+        [Fact]
+        public void UnknownAssembly_ReturnsNull()
+        {
+            var cache = TestableDependencyContextAssemblyCache.CreateEmpty();
+            cache.GetAndClearDiagnosticMessages();
+
+            var result = cache.LoadManagedDll("foo");
+
+            Assert.Null(result);
+            Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                message => Assert.Equal("[DependencyContextAssemblyCache.LoadManagedDll] Resolution for 'foo' failed, passed down to next resolver", message)
+            );
+        }
+
+        [Fact]
+        public void LocalAssembly_LoadsFromOutputLocation()
+        {
+            var cache = TestableDependencyContextAssemblyCache.CreateEmpty();
+            cache.GetAndClearDiagnosticMessages();
+            var expectedPath = Path.GetFullPath(Path.Combine(cache.AssemblyFolder, "foo.dll"));
+            cache.FileSystem.File.Exists(expectedPath).Returns(true);
+
+            var result = cache.LoadManagedDll("foo");
+
+            Assert.Equal(expectedPath, result.Location);
+            Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                message => Assert.Equal($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved 'foo' to '{expectedPath}'", message)
+            );
+        }
+    }
+
+    public class ManagedAssembly
+    {
+        public class PlatformDependent
+        {
+            [Fact]
+            public void WithNoSuitableRuntime()
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create(Platform.Darwin, "osx.10.10-x64", "osx.10.12-x64");
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+
+                var result = cache.LoadManagedDll("managed.ref1");
+
+                Assert.Null(result);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal("[DependencyContextAssemblyCache.LoadManagedDll] Resolution for 'managed.ref1' failed, passed down to next resolver", message)
+                );
+            }
+
+            [Theory]
+            [InlineData("managed.ref1")]
+            [InlineData("managed.ref2")]
+            public void WithExactMatchRuntime(string assemblyName)
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create(Platform.Darwin, "osx.10.12-x64", "osx.10.11-x64", "osx.10.12-x64");
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+                var expectedPath = Path.GetFullPath(Path.Combine(NuGetHelper.PackageCachePath, $"packagename/1.2.3.4/runtime/osx.10.12-x64/{assemblyName}.dll"));
+
+                var result = cache.LoadManagedDll(assemblyName);
+
+                Assert.NotNull(result);
+                Assert.Equal(expectedPath, result.Location);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved '{assemblyName}' to '{expectedPath}'", message)
+                );
+            }
+
+            [Fact]
+            public void WithDownlevelRuntime()
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create(Platform.Darwin, "osx.10.12-x64", "osx.10.11-x64");
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+                var expectedPath = Path.GetFullPath(Path.Combine(NuGetHelper.PackageCachePath, "packagename/1.2.3.4/runtime/osx.10.11-x64/managed.ref1.dll"));
+
+                var result = cache.LoadManagedDll("managed.ref1");
+
+                Assert.NotNull(result);
+                Assert.Equal(expectedPath, result.Location);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved 'managed.ref1' to '{expectedPath}'", message)
+                );
+            }
+
+            [Fact]
+            public void PresentLocallyWithMatch()
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create(Platform.Darwin, "osx.10.12-x64", "osx.10.12-x64");
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+                var expectedPath = Path.GetFullPath(Path.Combine(cache.AssemblyFolder, "managed.ref1.dll"));
+                cache.FileSystem.File.Exists(expectedPath).Returns(true);
+
+                var result = cache.LoadManagedDll("managed.ref1");
+
+                Assert.NotNull(result);
+                Assert.Equal(expectedPath, result.Location);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved 'managed.ref1' to '{expectedPath}'", message)
+                );
+            }
+
+            [Fact]
+            public void PresentLocallyWithoutMatch()
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create(Platform.Darwin, "osx.10.10-x64", "osx.10.12-x64");
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+                var expectedPath = Path.GetFullPath(Path.Combine(cache.AssemblyFolder, "managed.ref1.dll"));
+                cache.FileSystem.File.Exists(expectedPath).Returns(true);
+
+                var result = cache.LoadManagedDll("managed.ref1");
+
+                Assert.NotNull(result);
+                Assert.Equal(expectedPath, result.Location);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved 'managed.ref1' to '{expectedPath}'", message)
+                );
+            }
+        }
+
+        public class PlatformIndependent
+        {
+            [Fact]
+            public void NotInCache()
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create();
+                cache.GetAndClearDiagnosticMessages();
+
+                var result = cache.LoadManagedDll("managed.ref1");
+
+                Assert.Null(result);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal<object>("[DependencyContextAssemblyCache.ResolveManagedAssembly] Resolving 'managed.ref1', found in dependency map, but unable to resolve a path in ['runtime/any/managed.ref1.dll','runtime/any/managed.ref2.dll']", message),
+                    message => Assert.Equal<object>("[DependencyContextAssemblyCache.LoadManagedDll] Resolution for 'managed.ref1' failed, passed down to next resolver", message)
+                );
+            }
+
+            [Fact]
+            public void WontLoad()
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create();
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+                var expectedPath = Path.GetFullPath(Path.Combine(NuGetHelper.PackageCachePath, "packagename/1.2.3.4/runtime/any/managed.ref1.dll"));
+
+                var result = cache.LoadManagedDll("managed.ref1", _ => null);
+
+                Assert.Null(result);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal($"[DependencyContextAssemblyCache.ResolveManagedAssembly] Resolving 'managed.ref1', found assembly path '{expectedPath}' but the assembly would not load", message),
+                    message => Assert.Equal("[DependencyContextAssemblyCache.LoadManagedDll] Resolution for 'managed.ref1' failed, passed down to next resolver", message)
+                );
+            }
+
+            [Theory]
+            [InlineData("runtime/any/managed.ref1.dll")]
+            [InlineData("runtime/any/managed.ref2.dll")]
+            public void InCache(string relativePath)
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create();
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+                var fileName = Path.GetFileNameWithoutExtension(relativePath);
+                var expectedPath = Path.GetFullPath(Path.Combine(NuGetHelper.PackageCachePath, "packagename/1.2.3.4", relativePath));
+
+                var result = cache.LoadManagedDll(fileName);
+
+                Assert.Equal(expectedPath, result.Location);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved '{fileName}' to '{expectedPath}'", message)
+                );
+            }
+
+            [Fact]
+            public void PresentLocally()
+            {
+                var cache = TestableDependencyContextAssemblyCache.Create();
+                cache.GetAndClearDiagnosticMessages();
+                cache.MockAllLibrariesPresentInNuGetCache();
+                var expectedPath = Path.GetFullPath(Path.Combine(cache.AssemblyFolder, "managed.ref1.dll"));
+                cache.FileSystem.File.Exists(expectedPath).Returns(true);
+
+                var result = cache.LoadManagedDll("managed.ref1");
+
+                Assert.Equal(expectedPath, result.Location);
+                Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                    message => Assert.Equal($"[DependencyContextAssemblyCache.LoadManagedDll] Resolved 'managed.ref1' to '{expectedPath}'", message)
+                );
+            }
+        }
+    }
+
+#if NETCOREAPP2_0
+    public class UnmanagedLibrary
+    {
+        [Fact]
+        public void NotInCache()
+        {
+            var cache = TestableDependencyContextAssemblyCache.Create();
+            cache.GetAndClearDiagnosticMessages();
+
+            var result = cache.LoadUnmanagedLibrary("dependency1");
+
+            Assert.Equal(IntPtr.Zero, result);
+            Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                message => Assert.Equal("[DependencyContextAssemblyCache.ResolveUnmanagedLibrary] Found in dependency map, but unable to resolve a path in ['native/win/dependency1.dll','native/win/dependency2.dll']", message),
+                message => Assert.Equal("[DependencyContextAssemblyCache.LoadUnmanagedLibrary] Resolution for 'dependency1' failed, passed down to next resolver", message)
+            );
+        }
+
+        [Fact]
+        public void WontLoad()
+        {
+            var cache = TestableDependencyContextAssemblyCache.Create();
+            cache.GetAndClearDiagnosticMessages();
+            cache.MockAllLibrariesPresentInNuGetCache();
+            var expectedPath = Path.GetFullPath(Path.Combine(NuGetHelper.PackageCachePath, "packagename/1.2.3.4/native/win/dependency1.dll"));
+
+            var result = cache.LoadUnmanagedLibrary("dependency1", _ => IntPtr.Zero);
+
+            Assert.Collection(cache.GetAndClearDiagnosticMessages(),
+                message => Assert.Equal($"[DependencyContextAssemblyCache.LoadUnmanagedLibrary] Resolving 'dependency1', found assembly path '{expectedPath}' but the assembly would not load", message),
+                message => Assert.Equal("[DependencyContextAssemblyCache.LoadUnmanagedLibrary] Resolution for 'dependency1' failed, passed down to next resolver", message)
+            );
+        }
+
+        [Theory]
+        [InlineData(Platform.Darwin, "osx.10.12-x64", "dependency1", "native/osx/dependency1.dylib")]
+        [InlineData(Platform.Darwin, "osx.10.12-x64", "dependency2", "native/osx/libdependency2.dylib")]
+        [InlineData(Platform.Linux, "ubuntu.16.04-x64", "dependency1", "native/linux/dependency1.so")]
+        [InlineData(Platform.Linux, "ubuntu.16.04-x64", "dependency2", "native/linux/libdependency2.so")]
+        [InlineData(Platform.Windows, "win10-x64", "dependency1", "native/win/dependency1.dll")]
+        [InlineData(Platform.Windows, "win10-x64", "dependency2", "native/win/dependency2.dll")]
+        internal void InCache(Platform platform, string runtime, string unmanagedLibraryName, string relativePath)
+        {
+            var cache = TestableDependencyContextAssemblyCache.Create(platform, runtime);
+            cache.GetAndClearDiagnosticMessages();
+            cache.MockAllLibrariesPresentInNuGetCache();
+            var expectedPath = Path.GetFullPath(Path.Combine(NuGetHelper.PackageCachePath, "packagename/1.2.3.4", relativePath));
+
+            var result = cache.LoadUnmanagedLibrary(unmanagedLibraryName);
+
+            Assert.NotEqual(IntPtr.Zero, result);
+            var message = Assert.Single(cache.GetAndClearDiagnosticMessages());
+            Assert.Equal($"[DependencyContextAssemblyCache.LoadUnmanagedLibrary] Resolved '{unmanagedLibraryName}' to '{expectedPath}'", message);
+        }
+    }
+#endif
+}
diff --git a/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj b/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj
index 0fba8366..ff034ce5 100644
--- a/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj
+++ b/test/test.xunit.runner.utility/test.xunit.runner.utility.csproj
@@ -1,8 +1,9 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
 
   <PropertyGroup>
-    <TargetFrameworks>net452;netcoreapp2.0</TargetFrameworks>
+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
     <DefineConstants>$(DefineConstants);UNIT_TEST</DefineConstants>
+    <TargetFrameworks>net452;netcoreapp2.0</TargetFrameworks>
   </PropertyGroup>
 
   <ItemGroup>
@@ -10,11 +11,16 @@
     <Compile Include="..\..\src\common\DictionaryExtensions.cs" LinkBase="Common" />
     <Compile Include="..\..\src\common\ExecutionHelper.cs" LinkBase="Common" />
     <Compile Include="..\..\src\common\Guard.cs" LinkBase="Common" />
+    <Compile Include="..\..\src\common\Json.cs" LinkBase="Common" />
     <Compile Include="..\..\src\common\NewReflectionExtensions.cs" LinkBase="Common" />
     <Compile Include="..\..\src\common\SerializationHelper.cs" LinkBase="Common" />
     <Compile Include="..\..\src\common\TestOptionsNames.cs" LinkBase="Common" />
     <Compile Include="..\..\src\common\XunitSerializationInfo.cs" LinkBase="Common" />
+    <Compile Include="..\..\src\common\Microsoft.DotNet.PlatformAbstractions\**\*.cs" LinkBase="Common\Microsoft.DotNet.PlatformAbstractions" />
+    <Compile Include="..\..\src\common\Microsoft.Extensions.DependencyModel\**\*.cs" LinkBase="Common\Microsoft.Extensions.DependencyModel" />
     <Compile Include="..\..\src\xunit.runner.utility\Frameworks\v1\Xunit1ExceptionUtility.cs" LinkBase="Common\RunnerUtility" />
+    <Compile Include="..\..\src\xunit.runner.utility\Utility\DependencyContextAssemblyCache.cs" LinkBase="Common\RunnerUtility" />
+    <Compile Include="..\..\src\xunit.runner.utility\Utility\DependencyModel\XunitPackageCompilationAssemblyResolver.cs" LinkBase="Common\RunnerUtility" />
   </ItemGroup>
 
   <ItemGroup>
