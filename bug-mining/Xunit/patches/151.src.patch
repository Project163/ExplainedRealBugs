diff --git a/src/common.tests/AcceptanceTests/AcceptanceTestV3.cs b/src/common.tests/AcceptanceTests/AcceptanceTestV3.cs
index f93773e6..173600f4 100644
--- a/src/common.tests/AcceptanceTests/AcceptanceTestV3.cs
+++ b/src/common.tests/AcceptanceTests/AcceptanceTestV3.cs
@@ -13,12 +13,14 @@ public class AcceptanceTestV3
 {
 	public Task<List<_MessageSinkMessage>> RunAsync(
 		Type type,
-		bool preEnumerateTheories = true) =>
-			RunAsync(new[] { type }, preEnumerateTheories);
+		bool preEnumerateTheories = true,
+		params _IReflectionAttributeInfo[] additionalAssemblyAttributes) =>
+			RunAsync(new[] { type }, preEnumerateTheories, additionalAssemblyAttributes);
 
 	public Task<List<_MessageSinkMessage>> RunAsync(
 		Type[] types,
-		bool preEnumerateTheories = true)
+		bool preEnumerateTheories = true,
+		params _IReflectionAttributeInfo[] additionalAssemblyAttributes)
 	{
 		var tcs = new TaskCompletionSource<List<_MessageSinkMessage>>();
 
@@ -29,7 +31,7 @@ public class AcceptanceTestV3
 				var diagnosticMessageSink = _NullMessageSink.Instance;
 				await using var testFramework = new XunitTestFramework(diagnosticMessageSink, configFileName: null);
 
-				var assemblyInfo = Reflector.Wrap(Assembly.GetEntryAssembly()!);
+				var assemblyInfo = Reflector.Wrap(Assembly.GetEntryAssembly()!, additionalAssemblyAttributes);
 				var discoverer = testFramework.GetDiscoverer(assemblyInfo);
 				var testCases = new List<_ITestCase>();
 				await discoverer.Find(testCase => { testCases.Add(testCase); return new(true); }, _TestFrameworkOptions.ForDiscovery(preEnumerateTheories: preEnumerateTheories), types);
@@ -51,27 +53,30 @@ public class AcceptanceTestV3
 
 	public async Task<List<TMessageType>> RunAsync<TMessageType>(
 		Type type,
-		bool preEnumerateTheories = true)
+		bool preEnumerateTheories = true,
+		params _IReflectionAttributeInfo[] additionalAssemblyAttributes)
 			where TMessageType : _MessageSinkMessage
 	{
-		var results = await RunAsync(type, preEnumerateTheories);
+		var results = await RunAsync(type, preEnumerateTheories, additionalAssemblyAttributes);
 		return results.OfType<TMessageType>().ToList();
 	}
 
 	public async Task<List<TMessageType>> RunAsync<TMessageType>(
 		Type[] types,
-		bool preEnumerateTheories = true)
+		bool preEnumerateTheories = true,
+		params _IReflectionAttributeInfo[] additionalAssemblyAttributes)
 			where TMessageType : _MessageSinkMessage
 	{
-		var results = await RunAsync(types, preEnumerateTheories);
+		var results = await RunAsync(types, preEnumerateTheories, additionalAssemblyAttributes);
 		return results.OfType<TMessageType>().ToList();
 	}
 
 	public async Task<List<ITestResultWithDisplayName>> RunForResultsAsync(
 		Type type,
-		bool preEnumerateTheories = true)
+		bool preEnumerateTheories = true,
+		params _IReflectionAttributeInfo[] additionalAssemblyAttributes)
 	{
-		var results = await RunAsync(type, preEnumerateTheories);
+		var results = await RunAsync(type, preEnumerateTheories, additionalAssemblyAttributes);
 		return
 			results
 				.OfType<_TestResultMessage>()
@@ -82,10 +87,11 @@ public class AcceptanceTestV3
 
 	public async Task<List<TResult>> RunForResultsAsync<TResult>(
 		Type type,
-		bool preEnumerateTheories = true)
+		bool preEnumerateTheories = true,
+		params _IReflectionAttributeInfo[] additionalAssemblyAttributes)
 			where TResult : ITestResultWithDisplayName
 	{
-		var results = await RunForResultsAsync(type, preEnumerateTheories);
+		var results = await RunForResultsAsync(type, preEnumerateTheories, additionalAssemblyAttributes);
 		return results.OfType<TResult>().ToList();
 	}
 
diff --git a/src/common.tests/TestDoubles/Mocks.Attributes.cs b/src/common.tests/TestDoubles/Mocks.Attributes.cs
index 434e0953..eca88f18 100644
--- a/src/common.tests/TestDoubles/Mocks.Attributes.cs
+++ b/src/common.tests/TestDoubles/Mocks.Attributes.cs
@@ -16,6 +16,14 @@ public static partial class Mocks
 		static readonly _IReflectionParameterInfo[] EmptyParameterInfos = new _IReflectionParameterInfo[0];
 		static readonly _IReflectionTypeInfo[] EmptyTypeInfos = new _IReflectionTypeInfo[0];
 
+		public static _IReflectionAttributeInfo AssemblyFixtureAttribute(Type fixtureType)
+		{
+			var result = Substitute.For<_IReflectionAttributeInfo, InterfaceProxy<_IReflectionAttributeInfo>>();
+			result.Attribute.Returns(new AssemblyFixtureAttribute(fixtureType));
+			result.GetConstructorArguments().Returns(new[] { fixtureType });
+			return result;
+		}
+
 		public static _IReflectionAttributeInfo CollectionAttribute(string collectionName)
 		{
 			var result = Substitute.For<_IReflectionAttributeInfo, InterfaceProxy<_IReflectionAttributeInfo>>();
diff --git a/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs b/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs
index 2e7868b7..7d9257f8 100644
--- a/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs
+++ b/src/xunit.v3.common/Reflection/ReflectionAssemblyInfo.cs
@@ -12,13 +12,21 @@ namespace Xunit.Sdk
 	/// </summary>
 	public class ReflectionAssemblyInfo : _IReflectionAssemblyInfo
 	{
+		_IReflectionAttributeInfo[] additionalAssemblyAttributes;
+
 		/// <summary>
 		/// Initializes a new instance of the <see cref="ReflectionAssemblyInfo"/> class.
 		/// </summary>
 		/// <param name="assembly">The assembly to be wrapped.</param>
-		public ReflectionAssemblyInfo(Assembly assembly)
+		/// <param name="additionalAssemblyAttributes">Additional custom attributes to return for this assembly. These
+		/// attributes will be added to the existing assembly-level attributes that already exist. This is typically
+		/// only used for unit/acceptance testing purposes.</param>
+		public ReflectionAssemblyInfo(
+			Assembly assembly,
+			params _IReflectionAttributeInfo[] additionalAssemblyAttributes)
 		{
 			Assembly = Guard.ArgumentNotNull(nameof(assembly), assembly);
+			this.additionalAssemblyAttributes = Guard.ArgumentNotNull(nameof(additionalAssemblyAttributes), additionalAssemblyAttributes);
 		}
 
 		/// <inheritdoc/>
@@ -51,12 +59,16 @@ public IReadOnlyCollection<_IAttributeInfo> GetCustomAttributes(string assemblyQ
 			Guard.ArgumentValidNotNull(nameof(assemblyQualifiedAttributeTypeName), $"Could not load type: '{assemblyQualifiedAttributeTypeName}'", attributeType);
 
 			return
-				Assembly
-					.CustomAttributes
-					.Where(attr => attributeType.IsAssignableFrom(attr.AttributeType))
-					.OrderBy(attr => attr.AttributeType.Name)
-					.Select(a => Reflector.Wrap(a))
-					.Cast<_IAttributeInfo>()
+				additionalAssemblyAttributes
+					.Where(customAttribute => attributeType.IsAssignableFrom(customAttribute.Attribute.GetType()))
+					.Concat(
+						Assembly
+							.CustomAttributes
+							.Where(attr => attributeType.IsAssignableFrom(attr.AttributeType))
+							.OrderBy(attr => attr.AttributeType.Name)
+							.Select(a => Reflector.Wrap(a))
+							.Cast<_IAttributeInfo>()
+					)
 					.CastOrToReadOnlyCollection();
 		}
 
diff --git a/src/xunit.v3.common/Reflection/Reflector.cs b/src/xunit.v3.common/Reflection/Reflector.cs
index f08f6116..58656155 100644
--- a/src/xunit.v3.common/Reflection/Reflector.cs
+++ b/src/xunit.v3.common/Reflection/Reflector.cs
@@ -97,10 +97,15 @@ public static class Reflector
 		/// Converts an <see cref="Assembly"/> into an <see cref="_IReflectionAssemblyInfo"/>.
 		/// </summary>
 		/// <param name="assembly">The assembly to wrap.</param>
+		/// <param name="additionalAssemblyAttributes">Additional custom attributes to return for this assembly. These
+		/// attributes will be added to the existing assembly-level attributes that already exist. This is typically
+		/// only used for unit/acceptance testing purposes.</param>
 		/// <returns>The wrapper</returns>
 		[return: NotNullIfNotNull("assembly")]
-		public static _IReflectionAssemblyInfo? Wrap(Assembly? assembly) =>
-			assembly == null ? null : new ReflectionAssemblyInfo(assembly);
+		public static _IReflectionAssemblyInfo? Wrap(
+			Assembly? assembly,
+			params _IReflectionAttributeInfo[] additionalAssemblyAttributes) =>
+				assembly == null ? null : new ReflectionAssemblyInfo(assembly, additionalAssemblyAttributes);
 
 		/// <summary>
 		/// Converts an <see cref="Attribute"/> into an <see cref="_IAttributeInfo"/> using reflection.
diff --git a/src/xunit.v3.common/v3/Messages/_TestAssemblyCleanupFailure.cs b/src/xunit.v3.common/v3/Messages/_TestAssemblyCleanupFailure.cs
index e3615856..f619db9c 100644
--- a/src/xunit.v3.common/v3/Messages/_TestAssemblyCleanupFailure.cs
+++ b/src/xunit.v3.common/v3/Messages/_TestAssemblyCleanupFailure.cs
@@ -5,7 +5,7 @@
 namespace Xunit.v3
 {
 	/// <summary>
-	/// This message indicates that an error has occurred in test assembly cleanup. 
+	/// This message indicates that an error has occurred in test assembly cleanup.
 	/// </summary>
 	public class _TestAssemblyCleanupFailure : _TestAssemblyMessage, _IErrorMetadata
 	{
diff --git a/src/xunit.v3.common/v3/Messages/_TestFailed.cs b/src/xunit.v3.common/v3/Messages/_TestFailed.cs
index 5c9a77e8..d571bc79 100644
--- a/src/xunit.v3.common/v3/Messages/_TestFailed.cs
+++ b/src/xunit.v3.common/v3/Messages/_TestFailed.cs
@@ -57,7 +57,7 @@ public string[] Messages
 		}
 
 		/// <summary>
-		/// Creates a new <see cref="_TestAssemblyCleanupFailure"/> constructed from an <see cref="Exception"/> object.
+		/// Creates a new <see cref="_TestFailed"/> constructed from an <see cref="Exception"/> object.
 		/// </summary>
 		/// <param name="ex">The exception to use</param>
 		/// <param name="assemblyUniqueID">The unique ID of the assembly</param>
diff --git a/src/xunit.v3.core.tests/Acceptance/FixtureAcceptanceTests.cs b/src/xunit.v3.core.tests/Acceptance/FixtureAcceptanceTests.cs
index 9505f03f..d4cafbd0 100644
--- a/src/xunit.v3.core.tests/Acceptance/FixtureAcceptanceTests.cs
+++ b/src/xunit.v3.core.tests/Acceptance/FixtureAcceptanceTests.cs
@@ -110,7 +110,12 @@ public async void TestClassWithThrowingFixtureConstructorResultsInFailedTest()
 			var messages = await RunAsync<_TestFailed>(typeof(ClassWithThrowingFixtureCtor));
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestClassException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Class fixture type 'FixtureAcceptanceTests+ThrowingCtorFixture' threw in its constructor", msg.Messages.First());
 		}
 
 		class ClassWithThrowingFixtureCtor : IClassFixture<ThrowingCtorFixture>
@@ -125,7 +130,12 @@ public async void TestClassWithThrowingFixtureDisposeResultsInFailedTest()
 			var messages = await RunAsync<_TestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestFixtureCleanupException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Class fixture type 'FixtureAcceptanceTests+ThrowingDisposeFixture' threw in Dispose", msg.Messages.First());
 		}
 
 		class ClassWithThrowingFixtureDispose : IClassFixture<ThrowingDisposeFixture>
@@ -267,89 +277,48 @@ public ValueTask DisposeAsync()
 		}
 
 		[Fact]
-		public async void ThrowingAsyncSetupShouldResultInFailedTest()
+		public async void ThrowingFixtureInitializeAsyncShouldResultInFailedTest()
 		{
-			var messages = await RunAsync<_TestFailed>(typeof(ClassWithThrowingFixtureSetup));
+			var messages = await RunAsync<_TestFailed>(typeof(ClassWithThrowingFixtureInitializeAsync));
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestClassException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Class fixture type 'FixtureAcceptanceTests+ThrowingInitializeAsyncFixture' threw in InitializeAsync", msg.Messages.First());
 		}
 
-		class ClassWithThrowingFixtureSetup : IClassFixture<ThrowingSetup>
+		class ClassWithThrowingFixtureInitializeAsync : IClassFixture<ThrowingInitializeAsyncFixture>
 		{
-			public ClassWithThrowingFixtureSetup(ThrowingSetup ignored) { }
+			public ClassWithThrowingFixtureInitializeAsync(ThrowingInitializeAsyncFixture ignored) { }
 
 			[Fact]
 			public void TheTest() { }
 		}
 
-		class ThrowingSetup : IAsyncLifetime
-		{
-			public ValueTask InitializeAsync()
-			{
-				throw new DivideByZeroException();
-			}
-
-			public ValueTask DisposeAsync()
-			{
-				return default;
-			}
-		}
-
 		[Fact]
 		public async void TestClassWithThrowingFixtureAsyncDisposeResultsInFailedTest()
 		{
 			var messages = await RunAsync<_TestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDisposeAsync));
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
-		}
-
-		class ClassWithThrowingFixtureDisposeAsync : IClassFixture<ThrowingDisposeAsync>
-		{
-			public ClassWithThrowingFixtureDisposeAsync(ThrowingDisposeAsync ignore) { }
-
-			[Fact]
-			public void TheTest() { }
-		}
-
-		class ThrowingDisposeAsync : IAsyncLifetime
-		{
-			public ValueTask InitializeAsync()
-			{
-				return default;
-			}
-
-			public ValueTask DisposeAsync()
-			{
-				throw new DivideByZeroException();
-			}
-		}
-
-		[Fact]
-		public async void TestClassWithThrowingFixtureAsyncDisposeResultsInFailedTest_Disposable()
-		{
-			var messages = await RunAsync<_TestClassCleanupFailure>(typeof(ClassWithThrowingFixtureDisposeAsync));
-
-			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestFixtureCleanupException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Class fixture type 'FixtureAcceptanceTests+ThrowingDisposeAsyncFixture' threw in DisposeAsync", msg.Messages.First());
 		}
 
-		class ClassWithThrowingFixtureDisposeAsync_Disposable : IClassFixture<ThrowingDisposeAsync_Disposable>
+		class ClassWithThrowingFixtureDisposeAsync : IClassFixture<ThrowingDisposeAsyncFixture>
 		{
-			public ClassWithThrowingFixtureDisposeAsync_Disposable(ThrowingDisposeAsync_Disposable ignore) { }
+			public ClassWithThrowingFixtureDisposeAsync(ThrowingDisposeAsyncFixture ignore) { }
 
 			[Fact]
 			public void TheTest() { }
 		}
-
-		class ThrowingDisposeAsync_Disposable : IAsyncDisposable
-		{
-			public ValueTask DisposeAsync()
-			{
-				throw new DivideByZeroException();
-			}
-		}
 	}
 
 	public class CollectionFixture : AcceptanceTestV3
@@ -417,7 +386,12 @@ public async void TestClassWithThrowingFixtureConstructorResultsInFailedTest()
 			var messages = await RunAsync<_TestFailed>(typeof(ClassWithThrowingFixtureCtor));
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestClassException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Collection fixture type 'FixtureAcceptanceTests+ThrowingCtorFixture' threw in its constructor", msg.Messages.First());
 		}
 
 		[CollectionDefinition("Collection with throwing constructor")]
@@ -438,7 +412,12 @@ public async void TestClassWithThrowingCollectionFixtureDisposeResultsInFailedTe
 			var messages = await RunAsync<_TestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureDispose));
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestFixtureCleanupException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Collection fixture type 'FixtureAcceptanceTests+ThrowingDisposeFixture' threw in Dispose", msg.Messages.First());
 		}
 
 		[CollectionDefinition("Collection with throwing dispose")]
@@ -560,27 +539,101 @@ public class AsyncCollectionFixture : AcceptanceTestV3
 		[Fact]
 		public async void TestClassWithThrowingCollectionFixtureSetupAsyncResultsInFailedTest()
 		{
-			var messages = await RunAsync<_TestFailed>(typeof(ClassWithThrowingFixtureSetupAsync));
+			var messages = await RunAsync<_TestFailed>(typeof(ClassWithThrowingFixtureInitializeAsync));
+
+			var msg = Assert.Single(messages);
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestClassException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Collection fixture type 'FixtureAcceptanceTests+ThrowingInitializeAsyncFixture' threw in InitializeAsync", msg.Messages.First());
+		}
+
+		[CollectionDefinition("Collection with throwing InitializeAsync")]
+		public class CollectionWithThrowingInitializeAsync : ICollectionFixture<ThrowingInitializeAsyncFixture> { }
+
+		[Collection("Collection with throwing InitializeAsync")]
+		class ClassWithThrowingFixtureInitializeAsync
+		{
+			[Fact]
+			public void TheTest() { }
+		}
+
+		[Fact]
+		public async void TestClassWithThrowingCollectionFixtureDisposeAsyncResultsInFailedTest()
+		{
+			var messages = await RunAsync<_TestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureDisposeAsync));
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestFixtureCleanupException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Collection fixture type 'FixtureAcceptanceTests+ThrowingDisposeAsyncFixture' threw in DisposeAsync", msg.Messages.First());
 		}
 
-		[CollectionDefinition("Collection with throwing async setup")]
-		public class CollectionWithThrowingSetupAsync : ICollectionFixture<ThrowingSetupAsync> { }
+		[CollectionDefinition("Collection with throwing DisposeAsync")]
+		public class CollectionWithThrowingDisposeAsync : ICollectionFixture<ThrowingDisposeAsyncFixture> { }
 
-		[Collection("Collection with throwing async setup")]
-		class ClassWithThrowingFixtureSetupAsync
+		[Collection("Collection with throwing DisposeAsync")]
+		class ClassWithThrowingFixtureDisposeAsync
 		{
 			[Fact]
 			public void TheTest() { }
 		}
 
-		class ThrowingSetupAsync : IAsyncLifetime
+		[Fact]
+		public async void CollectionFixtureAsyncSetupShouldOnlyRunOnce()
 		{
+			var results = await RunAsync<_TestPassed>(new[] { typeof(Fixture1), typeof(Fixture2) });
+			Assert.Equal(2, results.Count);
+		}
+
+		class Alpha { }
+		class Beta { }
+
+		/// <remarks>
+		/// We include two class fixtures and test that each one is only initialised once.
+		/// Regression testing for https://github.com/xunit/xunit/issues/869
+		/// </remarks>
+		[CollectionDefinition("Async once")]
+		public class AsyncOnceCollection : ICollectionFixture<CountedAsyncFixture<Alpha>>, ICollectionFixture<CountedAsyncFixture<Beta>> { }
+
+		[Collection("Async once")]
+		class Fixture1
+		{
+			public Fixture1(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
+			{
+				Assert.Equal(1, alpha.Count);
+				Assert.Equal(1, beta.Count);
+			}
+
+			[Fact]
+			public void TheTest() { }
+		}
+
+		[Collection("Async once")]
+		class Fixture2
+		{
+			public Fixture2(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
+			{
+				Assert.Equal(1, alpha.Count);
+				Assert.Equal(1, beta.Count);
+			}
+
+			[Fact]
+			public void TheTest() { }
+		}
+
+		class CountedAsyncFixture<T> : IAsyncLifetime
+		{
+			public int Count = 0;
 			public ValueTask InitializeAsync()
 			{
-				throw new DivideByZeroException();
+				Count += 1;
+				return default;
 			}
 
 			public ValueTask DisposeAsync()
@@ -588,87 +641,227 @@ public ValueTask DisposeAsync()
 				return default;
 			}
 		}
+	}
 
+	public class AssemblyFixture : AcceptanceTestV3
+	{
 		[Fact]
-		public async void TestClassWithThrowingCollectionFixtureDisposeAsyncResultsInFailedTest()
+		public async void TestClassWithExtraArgumentToConstructorResultsInFailedTest()
 		{
-			var messages = await RunAsync<_TestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureAsyncDispose));
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(EmptyFixtureData));
+			var messages = await RunAsync<_TestFailed>(typeof(ClassWithExtraCtorArg), additionalAssemblyAttributes: assemblyAttribute);
 
 			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			Assert.Equal(typeof(TestClassException).FullName, msg.ExceptionTypes.Single());
+			Assert.Equal("The following constructor parameters did not have matching fixture data: Int32 arg1, String arg2", msg.Messages.Single());
 		}
 
-		[CollectionDefinition("Collection with throwing async Dispose")]
-		public class CollectionWithThrowingAsyncDispose : ICollectionFixture<ThrowingDisposeAsync> { }
+		class ClassWithExtraCtorArg
+		{
+			public ClassWithExtraCtorArg(int arg1, EmptyFixtureData fixture, string arg2) { }
+
+			[Fact]
+			public void TheTest() { }
+		}
+
+		[Fact]
+		public async void TestClassWithMissingArgumentToConstructorIsAcceptable()
+		{
+			var emptyFixtureAttribute = Mocks.AssemblyFixtureAttribute(typeof(EmptyFixtureData));
+			var objectFixtureAttribute = Mocks.AssemblyFixtureAttribute(typeof(object));
+			var messages = await RunAsync<_TestPassed>(typeof(ClassWithMissingCtorArg), additionalAssemblyAttributes: new[] { emptyFixtureAttribute, objectFixtureAttribute });
+
+			Assert.Single(messages);
+		}
 
-		[Collection("Collection with throwing async Dispose")]
-		class ClassWithThrowingFixtureAsyncDispose
+		class ClassWithMissingCtorArg
 		{
+			public ClassWithMissingCtorArg(EmptyFixtureData fixture) { }
+
 			[Fact]
 			public void TheTest() { }
 		}
 
-		class ThrowingDisposeAsync : IAsyncLifetime
+		[Fact]
+		public async void TestClassWithThrowingFixtureConstructorResultsInFailedTest()
 		{
-			public ValueTask InitializeAsync()
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(ThrowingCtorFixture));
+			var messages = await RunAsync<_TestFailed>(typeof(PlainTestClass), additionalAssemblyAttributes: assemblyAttribute);
+
+			var msg = Assert.Single(messages);
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestClassException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Assembly fixture type 'FixtureAcceptanceTests+ThrowingCtorFixture' threw in its constructor", msg.Messages.First());
+		}
+
+
+		[Fact]
+		public async void TestClassWithThrowingFixtureDisposeResultsInFailedTest()
+		{
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(ThrowingDisposeFixture));
+			var messages = await RunAsync<_TestAssemblyCleanupFailure>(typeof(PlainTestClass), additionalAssemblyAttributes: assemblyAttribute);
+
+			var msg = Assert.Single(messages);
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestFixtureCleanupException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Assembly fixture type 'FixtureAcceptanceTests+ThrowingDisposeFixture' threw in Dispose", msg.Messages.First());
+		}
+
+		class PlainTestClass
+		{
+			[Fact]
+			public void TheTest() { }
+		}
+
+		[Fact]
+		public async void FixtureDataIsPassedToConstructor()
+		{
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(EmptyFixtureData));
+			var messages = await RunAsync<_TestPassed>(typeof(FixtureSpy), additionalAssemblyAttributes: assemblyAttribute);
+
+			Assert.Single(messages);
+		}
+
+		class FixtureSpy
+		{
+			public FixtureSpy(EmptyFixtureData data)
 			{
-				return default;
+				Assert.NotNull(data);
 			}
 
-			public ValueTask DisposeAsync()
+			[Fact]
+			public void TheTest() { }
+		}
+
+		[Fact]
+		public async void TestClassWithDefaultParameter()
+		{
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(EmptyFixtureData));
+			var messages = await RunForResultsAsync<TestPassedWithDisplayName>(typeof(ClassWithDefaultCtorArg), additionalAssemblyAttributes: assemblyAttribute);
+
+			var message = Assert.Single(messages);
+			Assert.Equal("FixtureAcceptanceTests+AssemblyFixture+ClassWithDefaultCtorArg.TheTest", message.TestDisplayName);
+		}
+
+		class ClassWithDefaultCtorArg
+		{
+			public ClassWithDefaultCtorArg(EmptyFixtureData fixture, int x = 0)
 			{
-				throw new DivideByZeroException();
+				Assert.NotNull(fixture);
+				Assert.Equal(0, x);
 			}
+
+			[Fact]
+			public void TheTest() { }
 		}
 
 		[Fact]
-		public async void TestClassWithThrowingCollectionFixtureDisposeAsyncResultsInFailedTest_Disposable()
+		public async void TestClassWithOptionalParameter()
 		{
-			var messages = await RunAsync<_TestCollectionCleanupFailure>(typeof(ClassWithThrowingFixtureAsyncDispose_Disposable));
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(EmptyFixtureData));
+			var messages = await RunForResultsAsync<TestPassedWithDisplayName>(typeof(ClassWithOptionalCtorArg), additionalAssemblyAttributes: assemblyAttribute);
 
-			var msg = Assert.Single(messages);
-			Assert.Equal(typeof(DivideByZeroException).FullName, msg.ExceptionTypes.Single());
+			var message = Assert.Single(messages);
+			Assert.Equal("FixtureAcceptanceTests+AssemblyFixture+ClassWithOptionalCtorArg.TheTest", message.TestDisplayName);
 		}
 
-		[CollectionDefinition("Collection with throwing async Dispose (Disposable)")]
-		public class CollectionWithThrowingAsyncDispose_Disposable : ICollectionFixture<ThrowingDisposeAsync_Disposable> { }
-
-		[Collection("Collection with throwing async Dispose (Disposable)")]
-		class ClassWithThrowingFixtureAsyncDispose_Disposable
+		class ClassWithOptionalCtorArg
 		{
+			public ClassWithOptionalCtorArg(EmptyFixtureData fixture, [Optional] int x, [Optional] object y)
+			{
+				Assert.NotNull(fixture);
+				Assert.Equal(0, x);
+				Assert.Null(y);
+			}
+
 			[Fact]
 			public void TheTest() { }
 		}
 
-		class ThrowingDisposeAsync_Disposable : IAsyncDisposable
+		[Fact]
+		public async void TestClassWithParamsParameter()
 		{
-			public ValueTask DisposeAsync()
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(EmptyFixtureData));
+			var messages = await RunForResultsAsync<TestPassedWithDisplayName>(typeof(ClassWithParamsArg), additionalAssemblyAttributes: assemblyAttribute);
+
+			var message = Assert.Single(messages);
+			Assert.Equal("FixtureAcceptanceTests+AssemblyFixture+ClassWithParamsArg.TheTest", message.TestDisplayName);
+		}
+
+		class ClassWithParamsArg
+		{
+			public ClassWithParamsArg(EmptyFixtureData fixture, params object[] x)
 			{
-				throw new DivideByZeroException();
+				Assert.NotNull(fixture);
+				Assert.Empty(x);
 			}
+
+			[Fact]
+			public void TheTest() { }
 		}
+	}
 
+	public class AsyncAssemblyFixture : AcceptanceTestV3
+	{
 		[Fact]
-		public async void CollectionFixtureAsyncSetupShouldOnlyRunOnce()
+		public async void TestClassWithThrowingFixtureInitializeAsyncResultsInFailedTest()
 		{
-			var results = await RunAsync<_TestPassed>(new[] { typeof(Fixture1), typeof(Fixture2) });
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(ThrowingInitializeAsyncFixture));
+			var messages = await RunAsync<_TestFailed>(typeof(PlainTestClass), additionalAssemblyAttributes: assemblyAttribute);
+
+			var msg = Assert.Single(messages);
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestClassException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Assembly fixture type 'FixtureAcceptanceTests+ThrowingInitializeAsyncFixture' threw in InitializeAsync", msg.Messages.First());
+		}
+
+		[Fact]
+		public async void TestClassWithThrowingFixtureDisposeAsyncResultsInFailedTest()
+		{
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(ThrowingDisposeAsyncFixture));
+			var messages = await RunAsync<_TestAssemblyCleanupFailure>(typeof(PlainTestClass), additionalAssemblyAttributes: assemblyAttribute);
+
+			var msg = Assert.Single(messages);
+			Assert.Collection(
+				msg.ExceptionTypes,
+				exceptionTypeName => Assert.Equal(typeof(TestFixtureCleanupException).FullName, exceptionTypeName),
+				exceptionTypeName => Assert.Equal(typeof(DivideByZeroException).FullName, exceptionTypeName)
+			);
+			Assert.Equal("Assembly fixture type 'FixtureAcceptanceTests+ThrowingDisposeAsyncFixture' threw in DisposeAsync", msg.Messages.First());
+		}
+
+		class PlainTestClass
+		{
+			[Fact]
+			public void TheTest() { }
+		}
+
+		[Fact]
+		public async void AssemblyFixtureAsyncSetupShouldOnlyRunOnce()
+		{
+			var alphaFixture = Mocks.AssemblyFixtureAttribute(typeof(CountedAsyncFixture<Alpha>));
+			var betaFixture = Mocks.AssemblyFixtureAttribute(typeof(CountedAsyncFixture<Beta>));
+			var results = await RunAsync<_TestPassed>(new[] { typeof(TestClass1), typeof(TestClass2) }, additionalAssemblyAttributes: new[] { alphaFixture, betaFixture });
+
 			Assert.Equal(2, results.Count);
 		}
 
 		class Alpha { }
 		class Beta { }
 
-		/// <remarks>
-		/// We include two class fixtures and test that each one is only initialised once.
-		/// Regression testing for https://github.com/xunit/xunit/issues/869
-		/// </remarks>
-		[CollectionDefinition("Async once")]
-		public class AsyncOnceCollection : ICollectionFixture<CountedAsyncFixture<Alpha>>, ICollectionFixture<CountedAsyncFixture<Beta>> { }
-
-		[Collection("Async once")]
-		class Fixture1
+		[Collection("Assembly async once")]
+		class TestClass1
 		{
-			public Fixture1(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
+			public TestClass1(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
 			{
 				Assert.Equal(1, alpha.Count);
 				Assert.Equal(1, beta.Count);
@@ -678,10 +871,10 @@ public Fixture1(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta
 			public void TheTest() { }
 		}
 
-		[Collection("Async once")]
-		class Fixture2
+		[Collection("Assembly async once")]
+		class TestClass2
 		{
-			public Fixture2(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
+			public TestClass2(CountedAsyncFixture<Alpha> alpha, CountedAsyncFixture<Beta> beta)
 			{
 				Assert.Equal(1, alpha.Count);
 				Assert.Equal(1, beta.Count);
@@ -707,32 +900,149 @@ public ValueTask DisposeAsync()
 		}
 	}
 
+	public class FixtureComposition : AcceptanceTestV3
+	{
+		[Fact]
+		public async void ClassFixtureComposition()
+		{
+			var assemblyAttribute = Mocks.AssemblyFixtureAttribute(typeof(ComposedAssemblyFixture));
+			var messages = await RunAsync(typeof(TestClassWithClassFixtureComposition), additionalAssemblyAttributes: assemblyAttribute);
+
+			Assert.Single(messages.OfType<_TestPassed>());
+		}
+
+		[CollectionDefinition(nameof(TestClassWithClassFixtureCompositionCollection))]
+		public class TestClassWithClassFixtureCompositionCollection : ICollectionFixture<ComposedCollectionFixture>
+		{ }
+
+		[Collection(nameof(TestClassWithClassFixtureCompositionCollection))]
+		class TestClassWithClassFixtureComposition : IClassFixture<ComposedClassFixture>
+		{
+			readonly ComposedAssemblyFixture assemblyFixture;
+			readonly ComposedClassFixture classFixture;
+			readonly ComposedCollectionFixture collectionFixture;
+			readonly ITestContextAccessor testContextAccessor;
+
+			public TestClassWithClassFixtureComposition(
+				ComposedClassFixture classFixture,
+				ComposedCollectionFixture collectionFixture,
+				ComposedAssemblyFixture assemblyFixture,
+				ITestContextAccessor testContextAccessor)
+			{
+				this.classFixture = classFixture;
+				this.collectionFixture = collectionFixture;
+				this.assemblyFixture = assemblyFixture;
+				this.testContextAccessor = testContextAccessor;
+			}
+
+			[Fact]
+			public void TheTest()
+			{
+				Assert.NotNull(classFixture);
+				Assert.NotNull(collectionFixture);
+				Assert.NotNull(assemblyFixture);
+
+				Assert.Same(collectionFixture, classFixture.CollectionFixture);
+				Assert.Same(assemblyFixture, classFixture.AssemblyFixture);
+				Assert.Same(assemblyFixture, collectionFixture.AssemblyFixture);
+
+				var diagnosticMessageSink = classFixture.DiagnosticMessageSink;
+				Assert.NotNull(diagnosticMessageSink);
+				Assert.Same(diagnosticMessageSink, collectionFixture.DiagnosticMessageSink);
+				Assert.Same(diagnosticMessageSink, assemblyFixture.DiagnosticMessageSink);
+
+				Assert.NotNull(testContextAccessor);
+				Assert.NotNull(classFixture.TestContextAccessor);
+				Assert.NotNull(collectionFixture.TestContextAccessor);
+				Assert.NotNull(assemblyFixture.TestContextAccessor);
+				var testContext = testContextAccessor.Current;
+				Assert.Same(testContext, classFixture.TestContextAccessor.Current);
+				Assert.Same(testContext, collectionFixture.TestContextAccessor.Current);
+				Assert.Same(testContext, assemblyFixture.TestContextAccessor.Current);
+			}
+		}
+
+		class ComposedClassFixture
+		{
+			public ComposedClassFixture(
+				ComposedCollectionFixture collectionFixture,
+				ComposedAssemblyFixture assemblyFixture,
+				_IMessageSink diagnosticMessageSink,
+				ITestContextAccessor testContextAccessor)
+			{
+				CollectionFixture = collectionFixture;
+				AssemblyFixture = assemblyFixture;
+				DiagnosticMessageSink = diagnosticMessageSink;
+				TestContextAccessor = testContextAccessor;
+			}
+
+			public ComposedAssemblyFixture AssemblyFixture { get; }
+			public ComposedCollectionFixture CollectionFixture { get; }
+			public _IMessageSink DiagnosticMessageSink { get; }
+			public ITestContextAccessor TestContextAccessor { get; }
+		}
+
+		class ComposedCollectionFixture
+		{
+			public ComposedCollectionFixture(
+				ComposedAssemblyFixture assemblyFixture,
+				_IMessageSink diagnosticMessageSink,
+				ITestContextAccessor testContextAccessor)
+			{
+				AssemblyFixture = assemblyFixture;
+				DiagnosticMessageSink = diagnosticMessageSink;
+				TestContextAccessor = testContextAccessor;
+			}
+
+			public ComposedAssemblyFixture AssemblyFixture { get; }
+			public _IMessageSink DiagnosticMessageSink { get; }
+			public ITestContextAccessor TestContextAccessor { get; }
+		}
+
+		class ComposedAssemblyFixture
+		{
+			public ComposedAssemblyFixture(
+				_IMessageSink diagnosticMessageSink,
+				ITestContextAccessor testContextAccessor)
+			{
+				DiagnosticMessageSink = diagnosticMessageSink;
+				TestContextAccessor = testContextAccessor;
+			}
+
+			public _IMessageSink DiagnosticMessageSink { get; }
+			public ITestContextAccessor TestContextAccessor { get; }
+		}
+	}
+
 	class EmptyFixtureData { }
 
 	class ThrowingCtorFixture
 	{
-		public ThrowingCtorFixture()
-		{
-			throw new DivideByZeroException();
-		}
+		public ThrowingCtorFixture() => throw new DivideByZeroException();
+	}
+
+	class ThrowingInitializeAsyncFixture : IAsyncLifetime
+	{
+		public ValueTask DisposeAsync() => default;
+
+		public ValueTask InitializeAsync() => throw new DivideByZeroException();
 	}
 
 	class ThrowingDisposeFixture : IDisposable
 	{
-		public void Dispose()
-		{
-			throw new DivideByZeroException();
-		}
+		public void Dispose() => throw new DivideByZeroException();
+	}
+
+	class ThrowingDisposeAsyncFixture : IAsyncDisposable
+	{
+		public ValueTask DisposeAsync() => throw new DivideByZeroException();
 	}
 
 	class CountedFixture
 	{
 		static int counter = 0;
 
-		public CountedFixture()
-		{
-			Identity = ++counter;
-		}
+		public CountedFixture() => Identity = ++counter;
 
 		public readonly int Identity;
 	}
diff --git a/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestClassRunnerTests.cs b/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestClassRunnerTests.cs
index 4f700d1b..1638c1ca 100644
--- a/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestClassRunnerTests.cs
+++ b/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestClassRunnerTests.cs
@@ -402,8 +402,9 @@ class TestableXunitTestClassRunner : XunitTestClassRunner
 			ITestCaseOrderer testCaseOrderer,
 			ExceptionAggregator aggregator,
 			CancellationTokenSource cancellationTokenSource,
+			IDictionary<Type, object> assemblyFixtureMappings,
 			IDictionary<Type, object> collectionFixtureMappings)
-				: base(testClass, @class, testCases, SpyMessageSink.Create(messages: diagnosticMessages), messageBus, testCaseOrderer, aggregator, cancellationTokenSource, collectionFixtureMappings)
+				: base(testClass, @class, testCases, SpyMessageSink.Create(messages: diagnosticMessages), messageBus, testCaseOrderer, aggregator, cancellationTokenSource, assemblyFixtureMappings, collectionFixtureMappings)
 		{
 			DiagnosticMessages = diagnosticMessages;
 		}
@@ -426,6 +427,7 @@ class TestableXunitTestClassRunner : XunitTestClassRunner
 					new MockTestCaseOrderer(),
 					new ExceptionAggregator(),
 					new CancellationTokenSource(),
+					new Dictionary<Type, object>(),  // TODO: Do we need this as an additional argument for testing purposes?
 					collectionFixtures.ToDictionary(fixture => fixture.GetType())
 				);
 
diff --git a/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestCollectionRunnerTests.cs b/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestCollectionRunnerTests.cs
index 199c11b2..b86e5894 100644
--- a/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestCollectionRunnerTests.cs
+++ b/src/xunit.v3.core.tests/Sdk/v3/Runners/XunitTestCollectionRunnerTests.cs
@@ -271,22 +271,26 @@ class TestableXunitTestCollectionRunner : XunitTestCollectionRunner
 			IMessageBus messageBus,
 			ITestCaseOrderer testCaseOrderer,
 			ExceptionAggregator aggregator,
-			CancellationTokenSource cancellationTokenSource)
-				: base(testCollection, testCases, SpyMessageSink.Create(messages: diagnosticMessages), messageBus, testCaseOrderer, aggregator, cancellationTokenSource)
+			CancellationTokenSource cancellationTokenSource,
+			IDictionary<Type, object> assemblyFixtureMappings)
+				: base(testCollection, testCases, SpyMessageSink.Create(messages: diagnosticMessages), messageBus, testCaseOrderer, aggregator, cancellationTokenSource, assemblyFixtureMappings)
 		{
 			DiagnosticMessages = diagnosticMessages;
 		}
 
-		public static TestableXunitTestCollectionRunner Create(IXunitTestCase testCase) =>
-			new(
-				testCase.TestCollection,
-				new[] { testCase },
-				new List<_MessageSinkMessage>(),
-				new SpyMessageBus(),
-				new MockTestCaseOrderer(),
-				new ExceptionAggregator(),
-				new CancellationTokenSource()
-			);
+		public static TestableXunitTestCollectionRunner Create(
+			IXunitTestCase testCase,
+			params object[] assemblyFixtures) =>
+				new(
+					testCase.TestCollection,
+					new[] { testCase },
+					new List<_MessageSinkMessage>(),
+					new SpyMessageBus(),
+					new MockTestCaseOrderer(),
+					new ExceptionAggregator(),
+					new CancellationTokenSource(),
+					assemblyFixtures.ToDictionary(fixture => fixture.GetType())
+				);
 
 		public new Dictionary<Type, object> CollectionFixtureMappings => base.CollectionFixtureMappings;
 
diff --git a/src/xunit.v3.core/AssemblyFixtureAttribute.cs b/src/xunit.v3.core/AssemblyFixtureAttribute.cs
new file mode 100644
index 00000000..5441f0ca
--- /dev/null
+++ b/src/xunit.v3.core/AssemblyFixtureAttribute.cs
@@ -0,0 +1,25 @@
+﻿using System;
+
+namespace Xunit
+{
+	/// <summary>
+	/// Used to decorate xUnit.net test assemblies to indicate per-assembly fixture data. An instance of
+	/// the fixture data is initialized before any test in the assembly are run (including
+	/// <see cref="IAsyncLifetime.InitializeAsync"/> if it's implemented). After all the tests in the
+	/// assembly have been run, it is cleaned up by calling <see cref="IAsyncDisposable.DisposeAsync"/>
+	/// if it's implemented, or it falls back to <see cref="IDisposable.Dispose"/> if that's implemented.
+	/// Assembly fixtures must have a public parameterless constructor. To gain access to the fixture data
+	/// from inside the test, a constructor argument should be added to the test class which exactly
+	/// matches the fixture type.
+	/// </summary>
+	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
+	public class AssemblyFixtureAttribute : Attribute
+	{
+		/// <summary>
+		/// Initializes a new instance of the <see cref="AssemblyFixtureAttribute"/> class.
+		/// </summary>
+		/// <param name="assemblyFixtureType">The assembly fixture class type</param>
+		public AssemblyFixtureAttribute(Type assemblyFixtureType)
+		{ }
+	}
+}
diff --git a/src/xunit.v3.core/Sdk/v3/Runners/XunitTestAssemblyRunner.cs b/src/xunit.v3.core/Sdk/v3/Runners/XunitTestAssemblyRunner.cs
index 4b5888f7..80d47846 100644
--- a/src/xunit.v3.core/Sdk/v3/Runners/XunitTestAssemblyRunner.cs
+++ b/src/xunit.v3.core/Sdk/v3/Runners/XunitTestAssemblyRunner.cs
@@ -1,9 +1,11 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Reflection;
 using System.Security;
 using System.Threading;
 using System.Threading.Tasks;
+using Xunit.Internal;
 using Xunit.Sdk;
 
 namespace Xunit.v3
@@ -13,6 +15,7 @@ namespace Xunit.v3
 	/// </summary>
 	public class XunitTestAssemblyRunner : TestAssemblyRunner<IXunitTestCase>
 	{
+		Dictionary<Type, object> assemblyFixtureMappings = new();
 		_IAttributeInfo? collectionBehaviorAttribute;
 		bool disableParallelization;
 		bool initialized;
@@ -37,6 +40,15 @@ public class XunitTestAssemblyRunner : TestAssemblyRunner<IXunitTestCase>
 				: base(testAssembly, testCases, diagnosticMessageSink, executionMessageSink, executionOptions)
 		{ }
 
+		/// <summary>
+		/// Gets the fixture mappings that were created during <see cref="AfterTestAssemblyStartingAsync"/>.
+		/// </summary>
+		protected Dictionary<Type, object> AssemblyFixtureMappings
+		{
+			get => assemblyFixtureMappings;
+			set => assemblyFixtureMappings = Guard.ArgumentNotNull(nameof(AssemblyFixtureMappings), value);
+		}
+
 		/// <inheritdoc/>
 		public override async ValueTask DisposeAsync()
 		{
@@ -148,19 +160,134 @@ protected void Initialize()
 		}
 
 		/// <inheritdoc/>
-		protected override ValueTask AfterTestAssemblyStartingAsync()
+		protected override async ValueTask AfterTestAssemblyStartingAsync()
 		{
 			Initialize();
 
-			return base.AfterTestAssemblyStartingAsync();
+			await CreateAssemblyFixturesAsync();
+			await base.AfterTestAssemblyStartingAsync();
 		}
 
 		/// <inheritdoc/>
-		protected override ValueTask BeforeTestAssemblyFinishedAsync()
+		protected override async ValueTask BeforeTestAssemblyFinishedAsync()
 		{
+			var disposeAsyncTasks =
+				AssemblyFixtureMappings
+					.Values
+					.OfType<IAsyncDisposable>()
+					.Select(fixture => Aggregator.RunAsync(async () =>
+					{
+						try
+						{
+							await fixture.DisposeAsync();
+						}
+						catch (Exception ex)
+						{
+							throw new TestFixtureCleanupException($"Assembly fixture type '{fixture.GetType().FullName}' threw in DisposeAsync", ex.Unwrap());
+						}
+					}).AsTask())
+					.ToList();
+
+			await Task.WhenAll(disposeAsyncTasks);
+
+			foreach (var fixture in AssemblyFixtureMappings.Values.OfType<IDisposable>())
+				Aggregator.Run(() =>
+				{
+					try
+					{
+						fixture.Dispose();
+					}
+					catch (Exception ex)
+					{
+						throw new TestFixtureCleanupException($"Assembly fixture type '{fixture.GetType().FullName}' threw in Dispose", ex.Unwrap());
+					}
+				});
+
 			SetSynchronizationContext(originalSyncContext);
+			await base.BeforeTestAssemblyFinishedAsync();
+		}
+
+		/// <summary>
+		/// Creates the instance of a assembly fixture type to be used by the test assembly. If the fixture can be created,
+		/// it should be placed into the <see cref="AssemblyFixtureMappings"/> dictionary; if it cannot, then the method
+		/// should record the error by calling <code>Aggregator.Add</code>.
+		/// </summary>
+		/// <param name="fixtureType">The type of the fixture to be created</param>
+		protected virtual void CreateAssemblyFixture(Type fixtureType)
+		{
+			var ctors =
+				fixtureType
+					.GetConstructors()
+					.Where(ci => !ci.IsStatic && ci.IsPublic)
+					.ToList();
+
+			if (ctors.Count != 1)
+			{
+				Aggregator.Add(new TestClassException($"Assembly fixture type '{fixtureType.FullName}' may only define a single public constructor."));
+				return;
+			}
+
+			var ctor = ctors[0];
+			var missingParameters = new List<ParameterInfo>();
+			var ctorArgs = ctor.GetParameters().Select(p =>
+			{
+				object? arg = null;
+				if (p.ParameterType == typeof(_IMessageSink))
+					arg = DiagnosticMessageSink;
+				else if (p.ParameterType == typeof(ITestContextAccessor))
+					arg = TestContextAccessor.Instance;
+				else
+					missingParameters.Add(p);
+				return arg;
+			}).ToArray();
+
+			if (missingParameters.Count > 0)
+				Aggregator.Add(new TestClassException(
+					$"Assembly fixture type '{fixtureType.FullName}' had one or more unresolved constructor arguments: {string.Join(", ", missingParameters.Select(p => $"{p.ParameterType.Name} {p.Name}"))}"
+				));
+			else
+				Aggregator.Run(() =>
+				{
+					try
+					{
+						AssemblyFixtureMappings[fixtureType] = ctor.Invoke(ctorArgs);
+					}
+					catch (Exception ex)
+					{
+						throw new TestClassException($"Assembly fixture type '{fixtureType.FullName}' threw in its constructor", ex.Unwrap());
+					}
+				});
+		}
+
+		ValueTask CreateAssemblyFixturesAsync()
+		{
+			foreach (var attributeInfo in TestAssembly.Assembly.GetCustomAttributes(typeof(AssemblyFixtureAttribute)))
+			{
+				var fixtureType = attributeInfo.GetConstructorArguments().Single() as Type;
+				if (fixtureType != null)
+					CreateAssemblyFixture(fixtureType);
+			}
+
+			var initializeAsyncTasks =
+				AssemblyFixtureMappings
+					.Values
+					.OfType<IAsyncLifetime>()
+					.Select(
+						fixture => Aggregator.RunAsync(async () =>
+						{
+							try
+							{
+								await fixture.InitializeAsync();
+							}
+							catch (Exception ex)
+							{
+								throw new TestClassException($"Assembly fixture type '{fixture.GetType().FullName}' threw in InitializeAsync", ex.Unwrap());
+							}
+						}).AsTask()
+					)
+					.ToList();
 
-			return base.BeforeTestAssemblyFinishedAsync();
+			return new(Task.WhenAll(initializeAsyncTasks));
 		}
 
 		/// <inheritdoc/>
@@ -246,7 +373,8 @@ protected override ValueTask BeforeTestAssemblyFinishedAsync()
 					messageBus,
 					TestCaseOrderer,
 					new ExceptionAggregator(Aggregator),
-					cancellationTokenSource
+					cancellationTokenSource,
+					AssemblyFixtureMappings
 				).RunAsync();
 
 		[SecuritySafeCritical]
diff --git a/src/xunit.v3.core/Sdk/v3/Runners/XunitTestClassRunner.cs b/src/xunit.v3.core/Sdk/v3/Runners/XunitTestClassRunner.cs
index 45806938..8a899f4a 100644
--- a/src/xunit.v3.core/Sdk/v3/Runners/XunitTestClassRunner.cs
+++ b/src/xunit.v3.core/Sdk/v3/Runners/XunitTestClassRunner.cs
@@ -15,9 +15,9 @@ namespace Xunit.v3
 	/// </summary>
 	public class XunitTestClassRunner : TestClassRunner<IXunitTestCase>
 	{
-		readonly IDictionary<Type, object> collectionFixtureMappings;
-
+		readonly IDictionary<Type, object> assemblyFixtureMappings;
 		Dictionary<Type, object> classFixtureMappings = new();
+		readonly IDictionary<Type, object> collectionFixtureMappings;
 		HashSet<IAsyncLifetime> initializedAsyncFixtures = new();
 
 		/// <summary>
@@ -33,6 +33,7 @@ public class XunitTestClassRunner : TestClassRunner<IXunitTestCase>
 		/// <param name="testCaseOrderer">The test case orderer that will be used to decide how to order the test.</param>
 		/// <param name="aggregator">The exception aggregator used to run code and collect exceptions.</param>
 		/// <param name="cancellationTokenSource">The task cancellation token source, used to cancel the test run.</param>
+		/// <param name="assemblyFixtureMappings">The mapping of assembly fixture types to fixtures.</param>
 		/// <param name="collectionFixtureMappings">The mapping of collection fixture types to fixtures.</param>
 		public XunitTestClassRunner(
 			_ITestClass? testClass,
@@ -43,9 +44,11 @@ public class XunitTestClassRunner : TestClassRunner<IXunitTestCase>
 			ITestCaseOrderer testCaseOrderer,
 			ExceptionAggregator aggregator,
 			CancellationTokenSource cancellationTokenSource,
+			IDictionary<Type, object> assemblyFixtureMappings,
 			IDictionary<Type, object> collectionFixtureMappings)
 				: base(testClass, @class, testCases, diagnosticMessageSink, messageBus, testCaseOrderer, aggregator, cancellationTokenSource)
 		{
+			this.assemblyFixtureMappings = Guard.ArgumentNotNull(nameof(assemblyFixtureMappings), assemblyFixtureMappings);
 			this.collectionFixtureMappings = Guard.ArgumentNotNull(nameof(collectionFixtureMappings), collectionFixtureMappings);
 		}
 
@@ -94,8 +97,9 @@ protected virtual void CreateClassFixture(Type fixtureType)
 				object? arg;
 				if (p.ParameterType == typeof(_IMessageSink))
 					arg = DiagnosticMessageSink;
-				else
-				if (!collectionFixtureMappings.TryGetValue(p.ParameterType, out arg))
+				else if (p.ParameterType == typeof(ITestContextAccessor))
+					arg = TestContextAccessor.Instance;
+				else if (!collectionFixtureMappings.TryGetValue(p.ParameterType, out arg) && !assemblyFixtureMappings.TryGetValue(p.ParameterType, out arg))
 					missingParameters.Add(p);
 				return arg;
 			}).ToArray();
@@ -105,7 +109,17 @@ protected virtual void CreateClassFixture(Type fixtureType)
 					$"Class fixture type '{fixtureType.FullName}' had one or more unresolved constructor arguments: {string.Join(", ", missingParameters.Select(p => $"{p.ParameterType.Name} {p.Name}"))}"
 				));
 			else
-				Aggregator.Run(() => ClassFixtureMappings[fixtureType] = ctor.Invoke(ctorArgs));
+				Aggregator.Run(() =>
+				{
+					try
+					{
+						ClassFixtureMappings[fixtureType] = ctor.Invoke(ctorArgs);
+					}
+					catch (Exception ex)
+					{
+						throw new TestClassException($"Class fixture type '{fixtureType.FullName}' threw in its constructor", ex.Unwrap());
+					}
+				});
 		}
 
 		ValueTask CreateClassFixtureAsync(Type fixtureType)
@@ -121,7 +135,24 @@ ValueTask CreateClassFixtureAsync(Type fixtureType)
 
 			InitializedAsyncFixtures.UnionWith(uninitializedFixtures);
 
-			return new(Task.WhenAll(uninitializedFixtures.Select(fixture => Aggregator.RunAsync(fixture.InitializeAsync).AsTask())));
+			var initializeAsyncTasks =
+				uninitializedFixtures
+					.Select(
+						fixture => Aggregator.RunAsync(async () =>
+						{
+							try
+							{
+								await fixture.InitializeAsync();
+							}
+							catch (Exception ex)
+							{
+								throw new TestClassException($"Class fixture type '{fixture.GetType().FullName}' threw in InitializeAsync", ex.Unwrap());
+							}
+						}).AsTask()
+					)
+					.ToList();
+
+			return new(Task.WhenAll(initializeAsyncTasks));
 		}
 
 		/// <inheritdoc/>
@@ -183,13 +214,33 @@ protected override async ValueTask BeforeTestClassFinishedAsync()
 				ClassFixtureMappings
 					.Values
 					.OfType<IAsyncDisposable>()
-					.Select(fixture => Aggregator.RunAsync(fixture.DisposeAsync).AsTask())
+					.Select(fixture => Aggregator.RunAsync(async () =>
+					{
+						try
+						{
+							await fixture.DisposeAsync();
+						}
+						catch (Exception ex)
+						{
+							throw new TestFixtureCleanupException($"Class fixture type '{fixture.GetType().FullName}' threw in DisposeAsync", ex.Unwrap());
+						}
+					}).AsTask())
 					.ToList();
 
 			await Task.WhenAll(disposeAsyncTasks);
 
 			foreach (var fixture in ClassFixtureMappings.Values.OfType<IDisposable>())
-				Aggregator.Run(fixture.Dispose);
+				Aggregator.Run(() =>
+				{
+					try
+					{
+						fixture.Dispose();
+					}
+					catch (Exception ex)
+					{
+						throw new TestFixtureCleanupException($"Class fixture type '{fixture.GetType().FullName}' threw in Dispose", ex.Unwrap());
+					}
+				});
 		}
 
 		/// <inheritdoc/>
@@ -250,7 +301,8 @@ protected override async ValueTask BeforeTestClassFinishedAsync()
 			}
 
 			return ClassFixtureMappings.TryGetValue(parameter.ParameterType, out argumentValue)
-				|| collectionFixtureMappings.TryGetValue(parameter.ParameterType, out argumentValue);
+				|| collectionFixtureMappings.TryGetValue(parameter.ParameterType, out argumentValue)
+				|| assemblyFixtureMappings.TryGetValue(parameter.ParameterType, out argumentValue);
 		}
 	}
 }
diff --git a/src/xunit.v3.core/Sdk/v3/Runners/XunitTestCollectionRunner.cs b/src/xunit.v3.core/Sdk/v3/Runners/XunitTestCollectionRunner.cs
index 6cee6afa..668b3c80 100644
--- a/src/xunit.v3.core/Sdk/v3/Runners/XunitTestCollectionRunner.cs
+++ b/src/xunit.v3.core/Sdk/v3/Runners/XunitTestCollectionRunner.cs
@@ -14,6 +14,7 @@ namespace Xunit.v3
 	/// </summary>
 	public class XunitTestCollectionRunner : TestCollectionRunner<IXunitTestCase>
 	{
+		readonly IDictionary<Type, object> assemblyFixtureMappings;
 		Dictionary<Type, object> collectionFixtureMappings = new();
 
 		/// <summary>
@@ -26,6 +27,7 @@ public class XunitTestCollectionRunner : TestCollectionRunner<IXunitTestCase>
 		/// <param name="testCaseOrderer">The test case orderer that will be used to decide how to order the test.</param>
 		/// <param name="aggregator">The exception aggregator used to run code and collect exceptions.</param>
 		/// <param name="cancellationTokenSource">The task cancellation token source, used to cancel the test run.</param>
+		/// <param name="assemblyFixtureMappings">The assembly level fixtures</param>
 		public XunitTestCollectionRunner(
 			_ITestCollection testCollection,
 			IReadOnlyCollection<IXunitTestCase> testCases,
@@ -33,10 +35,12 @@ public class XunitTestCollectionRunner : TestCollectionRunner<IXunitTestCase>
 			IMessageBus messageBus,
 			ITestCaseOrderer testCaseOrderer,
 			ExceptionAggregator aggregator,
-			CancellationTokenSource cancellationTokenSource)
+			CancellationTokenSource cancellationTokenSource,
+			IDictionary<Type, object> assemblyFixtureMappings)
 				: base(testCollection, testCases, messageBus, testCaseOrderer, aggregator, cancellationTokenSource)
 		{
 			DiagnosticMessageSink = Guard.ArgumentNotNull(nameof(diagnosticMessageSink), diagnosticMessageSink);
+			this.assemblyFixtureMappings = Guard.ArgumentNotNull(nameof(assemblyFixtureMappings), assemblyFixtureMappings);
 		}
 
 		/// <summary>
@@ -67,13 +71,33 @@ protected override async ValueTask BeforeTestCollectionFinishedAsync()
 				CollectionFixtureMappings
 					.Values
 					.OfType<IAsyncDisposable>()
-					.Select(fixture => Aggregator.RunAsync(fixture.DisposeAsync).AsTask())
+					.Select(fixture => Aggregator.RunAsync(async () =>
+					{
+						try
+						{
+							await fixture.DisposeAsync();
+						}
+						catch (Exception ex)
+						{
+							throw new TestFixtureCleanupException($"Collection fixture type '{fixture.GetType().FullName}' threw in DisposeAsync", ex.Unwrap());
+						}
+					}).AsTask())
 					.ToList();
 
 			await Task.WhenAll(disposeAsyncTasks);
 
 			foreach (var fixture in CollectionFixtureMappings.Values.OfType<IDisposable>())
-				Aggregator.Run(fixture.Dispose);
+				Aggregator.Run(() =>
+				{
+					try
+					{
+						fixture.Dispose();
+					}
+					catch (Exception ex)
+					{
+						throw new TestFixtureCleanupException($"Collection fixture type '{fixture.GetType().FullName}' threw in Dispose", ex.Unwrap());
+					}
+				});
 		}
 
 		/// <summary>
@@ -103,7 +127,9 @@ protected virtual void CreateCollectionFixture(Type fixtureType)
 				object? arg = null;
 				if (p.ParameterType == typeof(_IMessageSink))
 					arg = DiagnosticMessageSink;
-				else
+				else if (p.ParameterType == typeof(ITestContextAccessor))
+					arg = TestContextAccessor.Instance;
+				else if (!assemblyFixtureMappings.TryGetValue(p.ParameterType, out arg))
 					missingParameters.Add(p);
 				return arg;
 			}).ToArray();
@@ -113,7 +139,17 @@ protected virtual void CreateCollectionFixture(Type fixtureType)
 					$"Collection fixture type '{fixtureType.FullName}' had one or more unresolved constructor arguments: {string.Join(", ", missingParameters.Select(p => $"{p.ParameterType.Name} {p.Name}"))}"
 				));
 			else
-				Aggregator.Run(() => CollectionFixtureMappings[fixtureType] = ctor.Invoke(ctorArgs));
+				Aggregator.Run(() =>
+				{
+					try
+					{
+						CollectionFixtureMappings[fixtureType] = ctor.Invoke(ctorArgs);
+					}
+					catch (Exception ex)
+					{
+						throw new TestClassException($"Collection fixture type '{fixtureType.FullName}' threw in its constructor", ex.Unwrap());
+					}
+				});
 		}
 
 		ValueTask CreateCollectionFixturesAsync()
@@ -132,7 +168,19 @@ ValueTask CreateCollectionFixturesAsync()
 				CollectionFixtureMappings
 					.Values
 					.OfType<IAsyncLifetime>()
-					.Select(fixture => Aggregator.RunAsync(fixture.InitializeAsync).AsTask())
+					.Select(
+						fixture => Aggregator.RunAsync(async () =>
+						{
+							try
+							{
+								await fixture.InitializeAsync();
+							}
+							catch (Exception ex)
+							{
+								throw new TestClassException($"Collection fixture type '{fixture.GetType().FullName}' threw in InitializeAsync", ex.Unwrap());
+							}
+						}).AsTask()
+					)
 					.ToList();
 
 			return new(Task.WhenAll(initializeAsyncTasks));
@@ -185,6 +233,7 @@ ValueTask CreateCollectionFixturesAsync()
 					TestCaseOrderer,
 					new ExceptionAggregator(Aggregator),
 					CancellationTokenSource,
+					assemblyFixtureMappings,
 					CollectionFixtureMappings
 				).RunAsync();
 	}
diff --git a/src/xunit.v3.core/Sdk/v3/Utility/TestClassException.cs b/src/xunit.v3.core/Sdk/v3/Utility/TestClassException.cs
index a4502b5d..50434e98 100644
--- a/src/xunit.v3.core/Sdk/v3/Utility/TestClassException.cs
+++ b/src/xunit.v3.core/Sdk/v3/Utility/TestClassException.cs
@@ -19,6 +19,17 @@ public TestClassException(string message)
 			: base(message)
 		{ }
 
+		/// <summary>
+		/// Initializes a new instance of the <see cref="TestClassException"/> class.
+		/// </summary>
+		/// <param name="message">The exception message.</param>
+		/// <param name="innerException">The inner exception that is being reported.</param>
+		public TestClassException(
+			string message,
+			Exception innerException)
+				: base(message, innerException)
+		{ }
+
 		/// <inheritdoc/>
 		protected TestClassException(
 			SerializationInfo info,
diff --git a/src/xunit.v3.core/Sdk/v3/Utility/TestFixtureCleanupException.cs b/src/xunit.v3.core/Sdk/v3/Utility/TestFixtureCleanupException.cs
new file mode 100644
index 00000000..7085e347
--- /dev/null
+++ b/src/xunit.v3.core/Sdk/v3/Utility/TestFixtureCleanupException.cs
@@ -0,0 +1,30 @@
+﻿using System;
+using System.Runtime.Serialization;
+
+namespace Xunit.v3
+{
+	/// <summary>
+	/// Represents an exception that happened during cleanup of a test fixture.
+	/// </summary>
+	[Serializable]
+	public class TestFixtureCleanupException : Exception
+	{
+		/// <summary>
+		/// Initializes a new instance of the <see cref="TestFixtureCleanupException"/> class.
+		/// </summary>
+		/// <param name="message">The exception message.</param>
+		/// <param name="innerException">The inner exception that is being reported.</param>
+		public TestFixtureCleanupException(
+			string message,
+			Exception innerException)
+				: base(message, innerException)
+		{ }
+
+		/// <inheritdoc/>
+		protected TestFixtureCleanupException(
+			SerializationInfo info,
+			StreamingContext context)
+				: base(info, context)
+		{ }
+	}
+}
