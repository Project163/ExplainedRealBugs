diff --git a/src/xunit.core/MemberDataAttributeBase.cs b/src/xunit.core/MemberDataAttributeBase.cs
index 577ceca6..e13269f1 100644
--- a/src/xunit.core/MemberDataAttributeBase.cs
+++ b/src/xunit.core/MemberDataAttributeBase.cs
@@ -1,6 +1,5 @@
 using System;
 using System.Collections.Generic;
-using System.Globalization;
 using System.Linq;
 using System.Reflection;
 using Xunit.Sdk;
@@ -57,7 +56,10 @@ public override IEnumerable<object[]> GetData(MethodInfo testMethod)
             var type = MemberType ?? testMethod.DeclaringType;
             var accessor = GetPropertyAccessor(type) ?? GetFieldAccessor(type) ?? GetMethodAccessor(type);
             if (accessor == null)
-                throw new ArgumentException($"Could not find public static member (property, field, or method) named '{MemberName}' on {type.FullName}");
+            {
+                var parameterText = Parameters?.Length > 0 ? $" with parameter types: {string.Join(", ", Parameters.Select(p => p?.GetType().FullName ?? "(null)"))}" : "";
+                throw new ArgumentException($"Could not find public static member (property, field, or method) named '{MemberName}' on {type.FullName}{parameterText}");
+            }
 
             var obj = accessor();
             if (obj == null)
@@ -97,10 +99,11 @@ Func<object> GetFieldAccessor(Type type)
         Func<object> GetMethodAccessor(Type type)
         {
             MethodInfo methodInfo = null;
-            var parameterTypes = Parameters == null ? new Type[0] : Parameters.Select(ToParameterType).ToArray();
+            var parameterTypes = Parameters == null ? new Type[0] : Parameters.Select(p => p?.GetType()).ToArray();
             for (var reflectionType = type; reflectionType != null; reflectionType = reflectionType.GetTypeInfo().BaseType)
             {
-                methodInfo = reflectionType.GetRuntimeMethod(MemberName, parameterTypes);
+                methodInfo = reflectionType.GetRuntimeMethods()
+                                           .FirstOrDefault(m => m.Name == MemberName && ParameterTypesCompatible(m.GetParameters(), parameterTypes));
                 if (methodInfo != null)
                     break;
             }
@@ -127,9 +130,16 @@ Func<object> GetPropertyAccessor(Type type)
             return () => propInfo.GetValue(null, null);
         }
 
-        Type ToParameterType(object value)
+        static bool ParameterTypesCompatible(ParameterInfo[] parameters, Type[] parameterTypes)
         {
-            return value == null ? typeof(object) : value.GetType();
+            if (parameters?.Length != parameterTypes.Length)
+                return false;
+
+            for (int idx = 0; idx < parameters.Length; ++idx)
+                if (parameterTypes[idx] != null && !parameters[idx].ParameterType.GetTypeInfo().IsAssignableFrom(parameterTypes[idx].GetTypeInfo()))
+                    return false;
+
+            return true;
         }
     }
 }
\ No newline at end of file
diff --git a/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs b/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
index c4ef8427..f0e90ccc 100644
--- a/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
+++ b/test/test.xunit.execution/Acceptance/Xunit2TheoryAcceptanceTests.cs
@@ -525,13 +525,51 @@ public void NonStaticMethodDataThrows()
 
         class ClassWithNonStaticMethodData
         {
-            public IEnumerable<object[]> DataSource() { return null; }
+            public IEnumerable<object[]> DataSource() => null;
 
             [Theory]
             [MemberData("DataSource")]
             public void TestViaMethodData(int x, double y, string z) { }
         }
 
+        [Fact]
+        public void NonMatchingMethodInputDataThrows()
+        {
+            var testMessages = Run<ITestResultMessage>(typeof(ClassWithMismatchedMethodData));
+
+            var failed = Assert.Single(testMessages.Cast<ITestFailed>());
+            Assert.Equal("Xunit2TheoryAcceptanceTests+MethodDataTests+ClassWithMismatchedMethodData.TestViaMethodData", failed.Test.DisplayName);
+            Assert.Equal("System.ArgumentException", failed.ExceptionTypes.Single());
+            Assert.Equal("Could not find public static member (property, field, or method) named 'DataSource' on Xunit2TheoryAcceptanceTests+MethodDataTests+ClassWithMismatchedMethodData with parameter types: System.Double", failed.Messages.Single());
+        }
+
+        class ClassWithMismatchedMethodData
+        {
+            public static IEnumerable<object[]> DataSource(int x) => null;
+
+            [Theory]
+            [MemberData("DataSource", 21.12)]
+            public void TestViaMethodData(int x, double y, string z) { }
+        }
+
+        [Fact]
+        public void CanDowncastMethodData()
+        {
+            var testMessages = Run<ITestResultMessage>(typeof(ClassWithDowncastedMethodData));
+
+            Assert.True(testMessages.All(m => m is ITestPassed));
+        }
+
+        class ClassWithDowncastedMethodData
+        {
+            public static IEnumerable<object[]> DataSource(object x, string y) { yield return new object[] { 42, 21.12, "Hello world" }; }
+
+            [Theory]
+            [MemberData("DataSource", 42, "Hello world")]
+            [MemberData("DataSource", 21.12, null)]
+            public void TestViaMethodData(int x, double y, string z) { }
+        }
+
         [Fact]
         public void CanUseMethodDataFromBaseType()
         {
