diff --git a/src/xunit.runner.utility.DotNetCore/xunit.runner.utility.DotNetCore.csproj b/src/xunit.runner.utility.DotNetCore/xunit.runner.utility.DotNetCore.csproj
index deee5eb2..9f61cc34 100644
--- a/src/xunit.runner.utility.DotNetCore/xunit.runner.utility.DotNetCore.csproj
+++ b/src/xunit.runner.utility.DotNetCore/xunit.runner.utility.DotNetCore.csproj
@@ -106,6 +106,9 @@
     <Compile Include="..\common\XunitSerializationInfo.cs">
       <Link>Common\XunitSerializationInfo.cs</Link>
     </Compile>
+    <Compile Include="..\common\XunitWorkerThread_Task.cs">
+      <Link>Common\XunitWorkerThread_Task.cs</Link>
+    </Compile>
     <Compile Include="..\xunit.runner.utility\**\*.cs">
       <Link>%(RecursiveDir)%(Filename)%(Extension)</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj b/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj
index ea46b845..99a6396b 100644
--- a/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj
+++ b/src/xunit.runner.utility.MonoAndroid/xunit.runner.utility.MonoAndroid.csproj
@@ -118,6 +118,9 @@
     <Compile Include="..\common\XunitSerializationInfo.cs">
       <Link>Common\XunitSerializationInfo.cs</Link>
     </Compile>
+    <Compile Include="..\common\XunitWorkerThread_Thread.cs">
+      <Link>Common\XunitWorkerThread_Thread.cs</Link>
+    </Compile>
     <Compile Include="Resources\Resource.Designer.cs" />
   </ItemGroup>
   <ItemGroup>
diff --git a/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj b/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj
index d5286871..68f8fe1e 100644
--- a/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj
+++ b/src/xunit.runner.utility.MonoTouch/xunit.runner.utility.MonoTouch.csproj
@@ -107,6 +107,9 @@
     <Compile Include="..\common\XunitSerializationInfo.cs">
       <Link>Common\XunitSerializationInfo.cs</Link>
     </Compile>
+    <Compile Include="..\common\XunitWorkerThread_Thread.cs">
+      <Link>Common\XunitWorkerThread_Thread.cs</Link>
+    </Compile>
     <Compile Include="..\xunit.runner.utility\**\*.cs">
       <Link>%(RecursiveDir)%(Filename)%(Extension)</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj b/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj
index 60e54d77..f81ff221 100644
--- a/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj
+++ b/src/xunit.runner.utility.desktop/xunit.runner.utility.desktop.csproj
@@ -117,6 +117,9 @@
     <Compile Include="..\common\XunitSerializationInfo.cs">
       <Link>Common\XunitSerializationInfo.cs</Link>
     </Compile>
+    <Compile Include="..\common\XunitWorkerThread_Thread.cs">
+      <Link>Common\XunitWorkerThread_Thread.cs</Link>
+    </Compile>
     <Compile Include="Configuration\ConfigReader_Configuration.cs" />
     <Compile Include="Frameworks\v1\IXunit1Executor.cs" />
     <Compile Include="Frameworks\v1\TestClassCallbackHandler.cs" />
diff --git a/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj b/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj
index 46ae7dae..7419a4de 100644
--- a/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj
+++ b/src/xunit.runner.utility.ios-universal/xunit.runner.utility.ios-universal.csproj
@@ -119,6 +119,9 @@
     <Compile Include="..\common\XunitSerializationInfo.cs">
       <Link>Common\XunitSerializationInfo.cs</Link>
     </Compile>
+    <Compile Include="..\common\XunitWorkerThread_Thread.cs">
+      <Link>Common\XunitWorkerThread_Thread.cs</Link>
+    </Compile>
     <Compile Include="..\xunit.runner.utility\**\*.cs">
       <Link>%(RecursiveDir)%(Filename)%(Extension)</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.nuspec b/src/xunit.runner.utility.nuspec
index cd8dc206..a56e0416 100644
--- a/src/xunit.runner.utility.nuspec
+++ b/src/xunit.runner.utility.nuspec
@@ -55,6 +55,7 @@ Supported platforms:
         <dependency id="System.Text.Encoding" version="4.0.0" />
         <dependency id="System.Text.RegularExpressions" version="4.0.0" />
         <dependency id="System.Threading" version="4.0.0" />
+        <dependency id="System.Threading.Tasks" version="4.0.0" />
         <dependency id="xunit.abstractions" version="2.0.0" />
       </group>
       <group targetFramework="dnx451">
@@ -70,6 +71,7 @@ Supported platforms:
         <dependency id="System.Text.Encoding" version="4.0.0" />
         <dependency id="System.Text.RegularExpressions" version="4.0.0" />
         <dependency id="System.Threading" version="4.0.0" />
+        <dependency id="System.Threading.Tasks" version="4.0.0" />
         <dependency id="xunit.abstractions" version="2.0.0" />
       </group>
     </dependencies>
diff --git a/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj b/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj
index c2c9c7b7..3a70022b 100644
--- a/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj
+++ b/src/xunit.runner.utility.universal/xunit.runner.utility.universal.csproj
@@ -159,6 +159,9 @@
     <Compile Include="..\common\XunitSerializationInfo.cs">
       <Link>Common\XunitSerializationInfo.cs</Link>
     </Compile>
+    <Compile Include="..\common\XunitWorkerThread_ThreadPool.cs">
+      <Link>Common\XunitWorkerThread_ThreadPool.cs</Link>
+    </Compile>
     <Compile Include="..\xunit.runner.utility\**\*.cs">
       <Link>%(RecursiveDir)%(Filename)%(Extension)</Link>
     </Compile>
diff --git a/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj b/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj
index f69ba440..29dddf79 100644
--- a/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj
+++ b/src/xunit.runner.utility.wp8/xunit.runner.utility.wp8.csproj
@@ -156,6 +156,9 @@
     <Compile Include="..\common\XunitSerializationInfo.cs">
       <Link>Common\XunitSerializationInfo.cs</Link>
     </Compile>
+    <Compile Include="..\common\XunitWorkerThread_ThreadPool.cs">
+      <Link>Common\XunitWorkerThread_ThreadPool.cs</Link>
+    </Compile>
     <Compile Include="..\xunit.runner.utility\**\*.cs">
       <Link>%(RecursiveDir)%(Filename)%(Extension)</Link>
     </Compile>
diff --git a/src/xunit.runner.utility/Runners/AssemblyRunner.cs b/src/xunit.runner.utility/Runners/AssemblyRunner.cs
new file mode 100644
index 00000000..a730bbeb
--- /dev/null
+++ b/src/xunit.runner.utility/Runners/AssemblyRunner.cs
@@ -0,0 +1,377 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+using System.Threading;
+using Xunit.Abstractions;
+using Xunit.Sdk;
+
+namespace Xunit
+{
+    /// <summary>
+    /// An enumeration which describes the current state of the system
+    /// </summary>
+    public enum AssemblyRunnerStatus
+    {
+        /// <summary>The system is not discovering or executing tests</summary>
+        Idle = 1,
+
+        /// <summary>The system is discovering tests</summary>
+        Discovering = 2,
+
+        /// <summary>The system is executing tests</summary>
+        Executing = 3,
+    }
+
+    /// <summary>
+    /// An enumeration which indicates the type of error message (for <see cref="AssemblyRunner.OnErrorMessage"/>).
+    /// </summary>
+    public enum ErrorMessageType
+    {
+        /// <summary>An unhandled exception occurred that disrupted the execution engine</summary>
+        CatastrophicError = 1,
+
+        /// <summary>An unhandled exception happened while cleaning up from the test assembly</summary>
+        TestAssemblyCleanupFailure = 10,
+
+        /// <summary>An unhandled exception happened while cleaning up from the test collection</summary>
+        TestCollectionCleanupFailure = 20,
+
+        /// <summary>An unhandled exception happened while cleaning up from the test class</summary>
+        TestClassCleanupFailure = 30,
+
+        /// <summary>An unhandled exception happened while cleaning up from the test method</summary>
+        TestMethodCleanupFailure = 40,
+
+        /// <summary>An unhandled exception happened while cleaning up from the test case</summary>
+        TestCaseCleanupFailure = 50,
+
+        /// <summary>An unhandled exception happened while cleaning up from the test</summary>
+        TestCleanupFailure = 60,
+    }
+
+    /// <summary>
+    /// A class which makes it simpler for casual runner authors to find and run tests and get results.
+    /// </summary>
+    public class AssemblyRunner : LongLivedMarshalByRefObject, IDisposable, IMessageSink
+    {
+        volatile bool cancelled;
+        bool disposed;
+        readonly TestAssemblyConfiguration configuration;
+        readonly IFrontController controller;
+        readonly ManualResetEvent discoveryCompleteEvent = new ManualResetEvent(true);
+        readonly ManualResetEvent executionCompleteEvent = new ManualResetEvent(true);
+        readonly object statusLock = new object();
+        int testCasesDiscovered;
+        readonly List<ITestCase> testCasesToRun = new List<ITestCase>();
+
+        AssemblyRunner(bool useAppDomain,
+                       string assemblyFileName,
+                       string configFileName = null,
+                       bool shadowCopy = true,
+                       string shadowCopyFolder = null)
+        {
+            controller = new XunitFrontController(useAppDomain, assemblyFileName, configFileName, shadowCopy, shadowCopyFolder, diagnosticMessageSink: this);
+            configuration = ConfigReader.Load(assemblyFileName, configFileName);
+        }
+
+        /// <summary>
+        /// Set to get notification of diagnostic messages.
+        /// </summary>
+        public DiagnosticMessageHandler OnDiagnosticMessage { get; set; }
+
+        /// <summary>
+        /// Set to get notification of when test discovery is complete.
+        /// </summary>
+        public DiscoveryCompleteHandler OnDiscoveryComplete { get; set; }
+
+        /// <summary>
+        /// Set to get notification of error messages (unhandled exceptions outside of tests).
+        /// </summary>
+        public ErrorMessageHandler OnErrorMessage { get; set; }
+
+        /// <summary>
+        /// Set to get notification of when test execution is complete.
+        /// </summary>
+        public ExecutionCompleteHandler OnExecutionComplete { get; set; }
+
+        /// <summary>
+        /// Set to get notification of failed tests.
+        /// </summary>
+        public TestFailedHandler OnTestFailed { get; set; }
+
+        /// <summary>
+        /// Set to get notification of finished tests (regardless of outcome).
+        /// </summary>
+        public TestFinishedHandler OnTestFinished { get; set; }
+
+        /// <summary>
+        /// Set to get real-time notification of test output (for xUnit.net v2 tests only).
+        /// Note that output is captured and reported back to all the test completion handlers
+        /// in addition to being sent to this handler.
+        /// </summary>
+        public TestOutputHandler OnTestOutput { get; set; }
+
+        /// <summary>
+        /// Set to get notification of passing tests.
+        /// </summary>
+        public TestPassedHandler OnTestPassed { get; set; }
+
+        /// <summary>
+        /// Set to get notification of skipped tests.
+        /// </summary>
+        public TestSkippedHandler OnTestSkipped { get; set; }
+
+        /// <summary>
+        /// Set to get notification of when tests start running.
+        /// </summary>
+        public TestStartingHandler OnTestStarting { get; set; }
+
+        /// <summary>
+        /// Gets the current status of the assembly runner
+        /// </summary>
+        public AssemblyRunnerStatus Status
+        {
+            get
+            {
+                if (!discoveryCompleteEvent.WaitOne(0))
+                    return AssemblyRunnerStatus.Discovering;
+                if (!executionCompleteEvent.WaitOne(0))
+                    return AssemblyRunnerStatus.Executing;
+
+                return AssemblyRunnerStatus.Idle;
+            }
+        }
+
+        /// <summary>
+        /// Set to be able to filter the test cases to decide which ones to run. If this is not set,
+        /// then all test cases will be run.
+        /// </summary>
+        public Func<ITestCase, bool> TestCaseFilter { get; set; }
+
+        /// <summary>
+        /// Call to request that the current run be cancelled. Note that cancellation may not be
+        /// instantaneous, and even after cancellation has been acknowledged, you can expect to
+        /// receive all the cleanup-related messages.
+        /// </summary>
+        public void Cancel()
+        {
+            cancelled = true;
+        }
+
+        /// <inheritdoc/>
+        public void Dispose()
+        {
+            lock (statusLock)
+            {
+                if (disposed)
+                    return;
+
+                if (Status != AssemblyRunnerStatus.Idle)
+                    throw new InvalidOperationException("Cannot dispose the assembly runner when it's not idle");
+
+                disposed = true;
+            }
+
+            controller.SafeDispose();
+            discoveryCompleteEvent.SafeDispose();
+            executionCompleteEvent.SafeDispose();
+        }
+
+        ITestFrameworkDiscoveryOptions GetDiscoveryOptions(bool? diagnosticMessages, TestMethodDisplay? methodDisplay, bool? preEnumerateTheories)
+        {
+            var discoveryOptions = TestFrameworkOptions.ForDiscovery(configuration);
+            discoveryOptions.SetSynchronousMessageReporting(true);
+
+            if (diagnosticMessages.HasValue)
+                discoveryOptions.SetDiagnosticMessages(diagnosticMessages);
+            if (methodDisplay.HasValue)
+                discoveryOptions.SetMethodDisplay(methodDisplay);
+            if (preEnumerateTheories.HasValue)
+                discoveryOptions.SetPreEnumerateTheories(preEnumerateTheories);
+
+            return discoveryOptions;
+        }
+
+        ITestFrameworkExecutionOptions GetExecutionOptions(bool? diagnosticMessages, bool? parallel, int? maxParallelThreads)
+        {
+            var executionOptions = TestFrameworkOptions.ForExecution(configuration);
+            executionOptions.SetSynchronousMessageReporting(true);
+
+            if (diagnosticMessages.HasValue)
+                executionOptions.SetDiagnosticMessages(diagnosticMessages);
+            if (parallel.HasValue)
+                executionOptions.SetDisableParallelization(!parallel.GetValueOrDefault());
+            if (maxParallelThreads.HasValue)
+                executionOptions.SetMaxParallelThreads(maxParallelThreads);
+
+            return executionOptions;
+        }
+
+        /// <summary>
+        /// Starts running tests from a single type (if provided) or the whole assembly (if not). This call returns
+        /// immediately, and status results are dispatched to the handlers on this class. Callers can check <see cref="Status"/>
+        /// to find out the current status.
+        /// </summary>
+        /// <param name="typeName">The (optional) type name of the single test class to run</param>
+        /// <param name="diagnosticMessages">Set to <c>true</c> to enable diagnostic messages; set to <c>false</c> to disable them.
+        /// By default, uses the value from the assembly configuration file.</param>
+        /// <param name="methodDisplay">Set to choose the default display name style for test methods.
+        /// By default, uses the value from the assembly configuration file. (This parameter is ignored for xUnit.net v1 tests.)</param>
+        /// <param name="preEnumerateTheories">Set to <c>true</c> to pre-enumerate individual theory tests; set to <c>false</c> to use
+        /// a single test case for the theory. By default, uses the value from the assembly configuration file. (This parameter is ignored
+        /// for xUnit.net v1 tests.)</param>
+        /// <param name="parallel">Set to <c>true</c> to run test collections in parallel; set to <c>false</c> to run them sequentially.
+        /// By default, uses the value from the assembly configuration file. (This parameter is ignored for xUnit.net v1 tests.)</param>
+        /// <param name="maxParallelThreads">Set to 0 to use unlimited threads; set to any other positive integer to limit to an exact number
+        /// of threads. By default, uses the value from the assembly configuration file. (This parameter is ignored for xUnit.net v1 tests.)</param>
+        public void Start(string typeName = null,
+                          bool? diagnosticMessages = null,
+                          TestMethodDisplay? methodDisplay = null,
+                          bool? preEnumerateTheories = null,
+                          bool? parallel = null,
+                          int? maxParallelThreads = null)
+        {
+            lock (statusLock)
+            {
+                if (Status != AssemblyRunnerStatus.Idle)
+                    throw new InvalidOperationException("Calling Start is not valid when the current status is not idle.");
+
+                cancelled = false;
+                testCasesDiscovered = 0;
+                testCasesToRun.Clear();
+                discoveryCompleteEvent.Reset();
+                executionCompleteEvent.Reset();
+            }
+
+            XunitWorkerThread.QueueUserWorkItem(() =>
+            {
+                var discoveryOptions = GetDiscoveryOptions(diagnosticMessages, methodDisplay, preEnumerateTheories);
+                if (typeName != null)
+                    controller.Find(typeName, false, this, discoveryOptions);
+                else
+                    controller.Find(false, this, discoveryOptions);
+
+                discoveryCompleteEvent.WaitOne();
+                if (cancelled)
+                {
+                    // Synthesize the execution complete message, since we're not going to run at all
+                    if (OnExecutionComplete != null)
+                        OnExecutionComplete(0, 0, 0, 0M);
+                    return;
+                }
+
+                var executionOptions = GetExecutionOptions(diagnosticMessages, parallel, maxParallelThreads);
+                controller.RunTests(testCasesToRun, this, executionOptions);
+                executionCompleteEvent.WaitOne();
+            });
+        }
+
+        /// <summary>
+        /// Creates an assembly runner that discovers and run tests in a separate app domain.
+        /// </summary>
+        /// <param name="assemblyFileName">The test assembly.</param>
+        /// <param name="configFileName">The test assembly configuration file.</param>
+        /// <param name="shadowCopy">If set to <c>true</c>, runs tests in a shadow copied app domain, which allows
+        /// tests to be discovered and run without locking assembly files on disk.</param>
+        /// <param name="shadowCopyFolder">The path on disk to use for shadow copying; if <c>null</c>, a folder
+        /// will be automatically (randomly) generated</param>
+        public static AssemblyRunner WithAppDomain(string assemblyFileName,
+                                                   string configFileName = null,
+                                                   bool shadowCopy = true,
+                                                   string shadowCopyFolder = null)
+        {
+            Guard.ArgumentValid(nameof(shadowCopyFolder), "Cannot set shadowCopyFolder if shadowCopy is false", shadowCopy == true || shadowCopyFolder == null);
+
+            return new AssemblyRunner(true, assemblyFileName, configFileName, shadowCopy, shadowCopyFolder);
+        }
+
+        /// <summary>
+        /// Creates an assembly runner that discovers and runs tests without a separate app domain.
+        /// </summary>
+        /// <param name="assemblyFileName">The test assembly.</param>
+        public static AssemblyRunner WithoutAppDomain(string assemblyFileName)
+        {
+            return new AssemblyRunner(false, assemblyFileName);
+        }
+
+        bool DispatchMessage<TMessage>(IMessageSinkMessage message, Action<TMessage> handler)
+            where TMessage : class
+        {
+            var tmessage = message as TMessage;
+            if (tmessage == null)
+                return false;
+
+            handler(tmessage);
+            return true;
+        }
+
+        bool IMessageSink.OnMessage(IMessageSinkMessage message)
+        {
+            if (DispatchMessage<ITestCaseDiscoveryMessage>(message, testDiscovered =>
+            {
+                ++testCasesDiscovered;
+                if (TestCaseFilter == null || TestCaseFilter(testDiscovered.TestCase))
+                    testCasesToRun.Add(testDiscovered.TestCase);
+            }))
+                return !cancelled;
+
+            if (DispatchMessage<IDiscoveryCompleteMessage>(message, discoveryComplete =>
+            {
+                if (OnDiscoveryComplete != null)
+                    OnDiscoveryComplete(testCasesDiscovered, testCasesToRun.Count);
+                discoveryCompleteEvent.Set();
+            }))
+                return !cancelled;
+
+            if (DispatchMessage<ITestAssemblyFinished>(message, assemblyFinished =>
+            {
+                if (OnExecutionComplete != null)
+                    OnExecutionComplete(assemblyFinished.TestsRun, assemblyFinished.TestsFailed, assemblyFinished.TestsSkipped, assemblyFinished.ExecutionTime);
+                executionCompleteEvent.Set();
+            }))
+                return !cancelled;
+
+            if (OnDiagnosticMessage != null)
+                if (DispatchMessage<IDiagnosticMessage>(message, m => OnDiagnosticMessage(m.Message)))
+                    return !cancelled;
+            if (OnTestFailed != null)
+                if (DispatchMessage<ITestFailed>(message, m => OnTestFailed(m.TestClass.Class.Name, m.TestMethod.Method.Name, m.TestCase.Traits, m.Test.DisplayName, m.TestCollection.DisplayName, m.ExecutionTime, m.Output, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+            if (OnTestFinished != null)
+                if (DispatchMessage<ITestFinished>(message, m => OnTestFinished(m.TestClass.Class.Name, m.TestMethod.Method.Name, m.TestCase.Traits, m.Test.DisplayName, m.TestCollection.DisplayName, m.ExecutionTime, m.Output)))
+                    return !cancelled;
+            if (OnTestOutput != null)
+                if (DispatchMessage<ITestOutput>(message, m => OnTestOutput(m.TestClass.Class.Name, m.TestMethod.Method.Name, m.TestCase.Traits, m.Test.DisplayName, m.TestCollection.DisplayName, m.Output)))
+                    return !cancelled;
+            if (OnTestPassed != null)
+                if (DispatchMessage<ITestPassed>(message, m => OnTestPassed(m.TestClass.Class.Name, m.TestMethod.Method.Name, m.TestCase.Traits, m.Test.DisplayName, m.TestCollection.DisplayName, m.ExecutionTime, m.Output)))
+                    return !cancelled;
+            if (OnTestSkipped != null)
+                if (DispatchMessage<ITestSkipped>(message, m => OnTestSkipped(m.TestClass.Class.Name, m.TestMethod.Method.Name, m.TestCase.Traits, m.Test.DisplayName, m.TestCollection.DisplayName, m.Reason)))
+                    return !cancelled;
+            if (OnTestStarting != null)
+                if (DispatchMessage<ITestStarting>(message, m => OnTestStarting(m.TestClass.Class.Name, m.TestMethod.Method.Name, m.TestCase.Traits, m.Test.DisplayName, m.TestCollection.DisplayName)))
+                    return !cancelled;
+
+            if (OnErrorMessage != null)
+            {
+                if (DispatchMessage<IErrorMessage>(message, m => OnErrorMessage(ErrorMessageType.CatastrophicError, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+                if (DispatchMessage<ITestAssemblyCleanupFailure>(message, m => OnErrorMessage(ErrorMessageType.TestAssemblyCleanupFailure, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+                if (DispatchMessage<ITestCaseCleanupFailure>(message, m => OnErrorMessage(ErrorMessageType.TestCaseCleanupFailure, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+                if (DispatchMessage<ITestClassCleanupFailure>(message, m => OnErrorMessage(ErrorMessageType.TestClassCleanupFailure, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+                if (DispatchMessage<ITestCleanupFailure>(message, m => OnErrorMessage(ErrorMessageType.TestCleanupFailure, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+                if (DispatchMessage<ITestCollectionCleanupFailure>(message, m => OnErrorMessage(ErrorMessageType.TestCollectionCleanupFailure, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+                if (DispatchMessage<ITestMethodCleanupFailure>(message, m => OnErrorMessage(ErrorMessageType.TestMethodCleanupFailure, m.ExceptionTypes.FirstOrDefault(), m.Messages.FirstOrDefault(), m.StackTraces.FirstOrDefault())))
+                    return !cancelled;
+            }
+
+            return !cancelled;
+        }
+    }
+}
diff --git a/src/xunit.runner.utility/Runners/AssemblyRunnerDelegates.cs b/src/xunit.runner.utility/Runners/AssemblyRunnerDelegates.cs
new file mode 100644
index 00000000..0172f001
--- /dev/null
+++ b/src/xunit.runner.utility/Runners/AssemblyRunnerDelegates.cs
@@ -0,0 +1,108 @@
+using System.Collections.Generic;
+
+namespace Xunit
+{
+    /// <summary>
+    /// Called when a diagnostic message was issued.
+    /// </summary>
+    /// <param name="message">The diagnostic message</param>
+    public delegate void DiagnosticMessageHandler(string message);
+
+    /// <summary>
+    /// Called when test discovery has been completed.
+    /// </summary>
+    /// <param name="testCasesDiscovered">The number of test cases discovered</param>
+    /// <param name="testCasesToRun">The number of test cases to be run (after filtering was applied)</param>
+    public delegate void DiscoveryCompleteHandler(int testCasesDiscovered, int testCasesToRun);
+
+    /// <summary>
+    /// Called when an error (which isn't a test failure) was encountered.
+    /// </summary>
+    /// <param name="messageType">When the error condition was encountered</param>
+    /// <param name="exceptionType">The type of the exception thrown</param>
+    /// <param name="message">The exception message</param>
+    /// <param name="stackTrace">The stack trace</param>
+    public delegate void ErrorMessageHandler(ErrorMessageType messageType, string exceptionType, string message, string stackTrace);
+
+    /// <summary>
+    /// Called when test execution has been completed.
+    /// </summary>
+    /// <param name="totalTests">The total number of tests run</param>
+    /// <param name="testsFailed">The number of tests which failed</param>
+    /// <param name="testsSkipped">The number of tests which were skipped</param>
+    /// <param name="executionTime">The execution time taken to run all the tests</param>
+    public delegate void ExecutionCompleteHandler(int totalTests, int testsFailed, int testsSkipped, decimal executionTime);
+
+    /// <summary>
+    /// Called when a failing test has finished executing.
+    /// </summary>
+    /// <param name="typeName">The full name of the type that contains the test</param>
+    /// <param name="methodName">The name of the method that contains the test</param>
+    /// <param name="traits">The traits associated with the test</param>
+    /// <param name="testDisplayName">The display name of the test</param>
+    /// <param name="testCollectionDisplayName">The display name of the test collect the test belongs to</param>
+    /// <param name="executionTime">The execution time, in seconds</param>
+    /// <param name="output">The output from the test, if any</param>
+    /// <param name="exceptionType">The type of the exception thrown</param>
+    /// <param name="message">The exception message</param>
+    /// <param name="stackTrace">The stack trace</param>
+    public delegate void TestFailedHandler(string typeName, string methodName, Dictionary<string, List<string>> traits, string testDisplayName, string testCollectionDisplayName, decimal executionTime, string output, string exceptionType, string message, string stackTrace);
+
+    /// <summary>
+    /// Called when a test has finished executing (regardless of outcome).
+    /// </summary>
+    /// <param name="typeName">The full name of the type that contains the test</param>
+    /// <param name="methodName">The name of the method that contains the test</param>
+    /// <param name="traits">The traits associated with the test</param>
+    /// <param name="testDisplayName">The display name of the test</param>
+    /// <param name="testCollectionDisplayName">The display name of the test collect the test belongs to</param>
+    /// <param name="executionTime">The execution time, in seconds</param>
+    /// <param name="output">The output from the test, if any</param>
+    public delegate void TestFinishedHandler(string typeName, string methodName, Dictionary<string, List<string>> traits, string testDisplayName, string testCollectionDisplayName, decimal executionTime, string output);
+
+    /// <summary>
+    /// Called when a line of output was written by a test. This is called when the actual output happened.
+    /// The output is also collected and passed back during the test completion message(s). Note that live
+    /// output is only supported by xUnit.net v2 unit tests.
+    /// </summary>
+    /// <param name="typeName">The full name of the type that contains the test</param>
+    /// <param name="methodName">The name of the method that contains the test</param>
+    /// <param name="traits">The traits associated with the test</param>
+    /// <param name="testDisplayName">The display name of the test</param>
+    /// <param name="testCollectionDisplayName">The display name of the test collect the test belongs to</param>
+    /// <param name="output">The output from the test</param>
+    public delegate void TestOutputHandler(string typeName, string methodName, Dictionary<string, List<string>> traits, string testDisplayName, string testCollectionDisplayName, string output);
+
+    /// <summary>
+    /// Called when a passing test has finished executing.
+    /// </summary>
+    /// <param name="typeName">The full name of the type that contains the test</param>
+    /// <param name="methodName">The name of the method that contains the test</param>
+    /// <param name="traits">The traits associated with the test</param>
+    /// <param name="testDisplayName">The display name of the test</param>
+    /// <param name="testCollectionDisplayName">The display name of the test collect the test belongs to</param>
+    /// <param name="executionTime">The execution time, in seconds</param>
+    /// <param name="output">The output from the test, if any</param>
+    public delegate void TestPassedHandler(string typeName, string methodName, Dictionary<string, List<string>> traits, string testDisplayName, string testCollectionDisplayName, decimal executionTime, string output);
+
+    /// <summary>
+    /// Called when a test was skipped.
+    /// </summary>
+    /// <param name="typeName">The full name of the type that contains the test</param>
+    /// <param name="methodName">The name of the method that contains the test</param>
+    /// <param name="traits">The traits associated with the test</param>
+    /// <param name="testDisplayName">The display name of the test</param>
+    /// <param name="testCollectionDisplayName">The display name of the test collect the test belongs to</param>
+    /// <param name="skipReason">The reason the test was skipped</param>
+    public delegate void TestSkippedHandler(string typeName, string methodName, Dictionary<string, List<string>> traits, string testDisplayName, string testCollectionDisplayName, string skipReason);
+
+    /// <summary>
+    /// Called when a test starts executing.
+    /// </summary>
+    /// <param name="typeName">The full name of the type that contains the test</param>
+    /// <param name="methodName">The name of the method that contains the test</param>
+    /// <param name="traits">The traits associated with the test</param>
+    /// <param name="testDisplayName">The display name of the test</param>
+    /// <param name="testCollectionDisplayName">The display name of the test collect the test belongs to</param>
+    public delegate void TestStartingHandler(string typeName, string methodName, Dictionary<string, List<string>> traits, string testDisplayName, string testCollectionDisplayName);
+}
