diff --git a/src/xunit.assert/Asserts/Sdk/ArgumentFormatter.cs b/src/xunit.assert/Asserts/Sdk/ArgumentFormatter.cs
index d40dad47..0dfcfca8 100644
--- a/src/xunit.assert/Asserts/Sdk/ArgumentFormatter.cs
+++ b/src/xunit.assert/Asserts/Sdk/ArgumentFormatter.cs
@@ -20,6 +20,26 @@ internal static class ArgumentFormatter
         static readonly object[] EmptyObjects = new object[0];
         static readonly Type[] EmptyTypes = new Type[0];
 
+        // List of system types => C# type names
+        static readonly Dictionary<TypeInfo, string> TypeMappings = new Dictionary<TypeInfo, string>
+        {
+            { typeof(bool).GetTypeInfo(), "bool" },
+            { typeof(byte).GetTypeInfo(), "byte" },
+            { typeof(sbyte).GetTypeInfo(), "sbyte" },
+            { typeof(char).GetTypeInfo(), "char" },
+            { typeof(decimal).GetTypeInfo(), "decimal" },
+            { typeof(double).GetTypeInfo(), "double" },
+            { typeof(float).GetTypeInfo(), "float" },
+            { typeof(int).GetTypeInfo(), "int" },
+            { typeof(uint).GetTypeInfo(), "uint" },
+            { typeof(long).GetTypeInfo(), "long" },
+            { typeof(ulong).GetTypeInfo(), "ulong" },
+            { typeof(object).GetTypeInfo(), "object" },
+            { typeof(short).GetTypeInfo(), "short" },
+            { typeof(ushort).GetTypeInfo(), "ushort" },
+            { typeof(string).GetTypeInfo(), "string" },
+        };
+
         /// <summary>
         /// Format the value for presentation.
         /// </summary>
@@ -37,7 +57,7 @@ private static string Format(object value, int depth)
 
             var valueAsType = value as Type;
             if (valueAsType != null)
-                return String.Format("typeof({0})", valueAsType.FullName);
+                return String.Format("typeof({0})", FormatTypeName(valueAsType));
 
             if (value is char)
             {
@@ -122,6 +142,43 @@ private static string FormatEnumerable(IEnumerable<object> enumerableValues, int
             return String.Format("[{0}]", printedValues);
         }
 
+        private static string FormatTypeName(Type type)
+        {
+            var typeInfo = type.GetTypeInfo();
+            var arraySuffix = "";
+
+            // Deconstruct and re-construct array
+            while (typeInfo.IsArray)
+            {
+                var rank = typeInfo.GetArrayRank();
+                arraySuffix += string.Format("[{0}]", new String(',', rank - 1));
+                typeInfo = typeInfo.GetElementType().GetTypeInfo();
+            }
+
+            // Map C# built-in type names
+            string result;
+            if (TypeMappings.TryGetValue(typeInfo, out result))
+                return result + arraySuffix;
+
+            // Strip off generic suffix
+            var name = typeInfo.FullName;
+            var tickIdx = name.IndexOf('`');
+            if (tickIdx > 0)
+                name = name.Substring(0, tickIdx);
+
+            if (typeInfo.IsGenericTypeDefinition)
+                name = String.Format("{0}<{1}>", name, new string(',', typeInfo.GenericTypeParameters.Length - 1));
+            else if (typeInfo.IsGenericType)
+            {
+                if (typeInfo.GetGenericTypeDefinition() == typeof(Nullable<>))
+                    name = FormatTypeName(typeInfo.GenericTypeArguments[0]) + "?";
+                else
+                    name = String.Format("{0}<{1}>", name, string.Join(", ", typeInfo.GenericTypeArguments.Select(FormatTypeName)));
+            }
+
+            return name + arraySuffix;
+        }
+
         private static string WrapAndGetFormattedValue(Func<object> getter, int depth)
         {
             try
diff --git a/test/test.xunit.execution/Sdk/ArgumentFormatterTests.cs b/test/test.xunit.execution/Sdk/ArgumentFormatterTests.cs
index 008d4887..6cbbb7fe 100644
--- a/test/test.xunit.execution/Sdk/ArgumentFormatterTests.cs
+++ b/test/test.xunit.execution/Sdk/ArgumentFormatterTests.cs
@@ -1,4 +1,5 @@
 ï»¿using System;
+using System.Collections.Generic;
 using System.Linq;
 using Xunit;
 using Xunit.Sdk;
@@ -64,10 +65,21 @@ public static void DateTimeOffsetValue()
             Assert.Equal(now.ToString("o"), ArgumentFormatter.Format(now));
         }
 
-        [CulturedFact]
-        public static void TypeValue()
-        {
-            Assert.Equal("typeof(System.String)", ArgumentFormatter.Format(typeof(string)));
+        [Theory]
+        [InlineData(typeof(string), "typeof(string)")]
+        [InlineData(typeof(int[]), "typeof(int[])")]
+        [InlineData(typeof(DateTime[,]), "typeof(System.DateTime[,])")]
+        [InlineData(typeof(decimal[][,]), "typeof(decimal[][,])")]
+        [InlineData(typeof(IEnumerable<>), "typeof(System.Collections.Generic.IEnumerable<>)")]
+        [InlineData(typeof(IEnumerable<int>), "typeof(System.Collections.Generic.IEnumerable<int>)")]
+        [InlineData(typeof(IDictionary<,>), "typeof(System.Collections.Generic.IDictionary<,>)")]
+        [InlineData(typeof(IDictionary<string, DateTime>), "typeof(System.Collections.Generic.IDictionary<string, System.DateTime>)")]
+        [InlineData(typeof(IDictionary<string[,], DateTime[,][]>), "typeof(System.Collections.Generic.IDictionary<string[,], System.DateTime[,][]>)")]
+        [InlineData(typeof(bool?), "typeof(bool?)")]
+        [InlineData(typeof(bool?[]), "typeof(bool?[])")]
+        public static void TypeValue(Type type, string expected)
+        {
+            Assert.Equal(expected, ArgumentFormatter.Format(type));
         }
     }
 
