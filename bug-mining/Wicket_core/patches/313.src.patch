diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java
index eb1e01b8c6..ebb9734618 100644
--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java
+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java
@@ -16,67 +16,50 @@
  */
 package org.apache.wicket.pageStore;
 
-import java.util.Iterator;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionHandler;
+import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.wicket.util.lang.Args;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Facade for {@link IDataStore} that does the actual saving in worker thread.
+ * Facade for {@link IDataStore} that does the actual saving asynchronously (in non-httpWorker
+ * thread).
  * <p>
- * Creates an {@link Entry} for each triple (sessionId, pageId, data) and puts it in
- * {@link #entries} queue if there is room. Acts as producer.<br/>
- * Later {@link PageSavingRunnable} reads in blocking manner from {@link #entries} and saves each
- * entry. Acts as consumer.
- * </p>
- * It starts only one instance of {@link PageSavingRunnable} because all we need is to make the page
- * storing asynchronous. We don't want to write concurrently in the wrapped {@link IDataStore},
- * though it may happen in the extreme case when the queue is full. These cases should be avoided.
+ * Creates an {@link Entry} for each triple (sessionId, pageId, data). Entry are saved using a
+ * {@link java.lang.Runnable} implementation called StoreEntryRunnable. Tasks running and thread
+ * coordination is managed using a {@linkjava.util.concurrent.ThreadPoolExecutor}
+ * 
  * 
  * @author Matej Knopp
+ * @author Andrea Del Bene
  */
 public class AsynchronousDataStore implements IDataStore
 {
-	/** Log for reporting. */
-	private static final Logger log = LoggerFactory.getLogger(AsynchronousDataStore.class);
-
-	/**
-	 * The time to wait when adding an {@link Entry} into the entries. In millis.
-	 */
-	private static final long OFFER_WAIT = 30L;
 
-	/**
-	 * The time to wait for an entry to save with the wrapped {@link IDataStore}. In millis.
-	 */
-	private static final long POLL_WAIT = 1000L;
+	/** Log for reporting. */
+	private static final Logger log = LoggerFactory.getLogger(AsyncDataStore.class);
 
 	/**
-	 * A flag indicating that this {@link IDataStore} should stop
+	 * The maximum number of threads to be started by the {@link #savePagesExecutor}.
 	 */
-	private final AtomicBoolean destroy;
+	private static final int MAX_THREADS = 1;
 
 	/**
 	 * The wrapped {@link IDataStore} that actually stores that pages
 	 */
 	private final IDataStore dataStore;
 
-	/**
-	 * The queue where the entries which have to be saved are temporary stored
-	 */
-	private final BlockingQueue<Entry> entries;
+	private final ThreadPoolExecutor savePagesExecutor;
 
 	/**
-	 * A map 'sessionId:::pageId' -> {@link Entry}. Used for fast retrieval of {@link Entry}s which
-	 * are not yet stored by the wrapped {@link IDataStore}
+	 * The queue where the entries which have to be saved are temporary stored
 	 */
-	private final ConcurrentMap<String, Entry> entryMap;
+	private final BlockingQueue<Runnable> entries;
 
 	/**
 	 * Construct.
@@ -89,96 +72,72 @@ public class AsynchronousDataStore implements IDataStore
 	public AsynchronousDataStore(final IDataStore dataStore, final int capacity)
 	{
 		this.dataStore = dataStore;
-		destroy = new AtomicBoolean(false);
-		entries = new LinkedBlockingQueue<Entry>(capacity);
-		entryMap = new ConcurrentHashMap<String, Entry>();
-
-		PageSavingRunnable savingRunnable = new PageSavingRunnable(dataStore, entries, entryMap,
-			destroy);
-		Thread thread = new Thread(savingRunnable, "Wicket-PageSavingThread");
-		thread.setDaemon(true);
-		thread.start();
+		entries = new LinkedBlockingQueue<Runnable>(capacity);
+		savePagesExecutor = new ThreadPoolExecutor(MAX_THREADS, MAX_THREADS, 1l, TimeUnit.SECONDS,
+			entries, new RejectStoringTask());
+
 	}
 
 	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#destroy()
+	 * @see org.apache.wicket.pageStore.IDataStore#getData(java.lang.String, int)
 	 */
-	public void destroy()
+	public byte[] getData(final String sessionId, final int pageId)
 	{
-		destroy.set(true);
+		Entry entry = null;
 
-		try
+		for (Runnable runnable : savePagesExecutor.getQueue())
 		{
-			synchronized (destroy)
+			StoreEntryRunnable storeEntryRunnable = (StoreEntryRunnable)runnable;
+			Entry cursorEntry = storeEntryRunnable.getEntry();
+
+			if (cursorEntry.getPageId() == pageId && cursorEntry.getSessionId().equals(sessionId))
 			{
-				destroy.wait();
+				entry = cursorEntry;
+				break;
 			}
 		}
-		catch (InterruptedException e)
-		{
-			log.error(e.getMessage(), e);
-		}
-
-		dataStore.destroy();
-	}
-
-	/**
-	 * Little helper
-	 * 
-	 * @param sessionId
-	 * @param id
-	 * @return Entry
-	 */
-	private Entry getEntry(final String sessionId, final int id)
-	{
-		return entryMap.get(getKey(sessionId, id));
-	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#getData(java.lang.String, int)
-	 */
-	public byte[] getData(final String sessionId, final int id)
-	{
-		Entry entry = getEntry(sessionId, id);
+		final byte[] data;
 		if (entry != null)
 		{
-			log.debug(
-				"Returning the data of a non-stored entry with sessionId '{}' and pageId '{}'",
-				sessionId, id);
-			return entry.data;
+			data = entry.getData();
+			if (log.isDebugEnabled())
+			{
+				log.debug(
+					"Returning the data (with length '{}') of a non-stored entry with sessionId '{}' and pageId '{}'",
+					new Object[] { data.length, sessionId, pageId });
+			}
+		}
+		else
+		{
+			data = dataStore.getData(sessionId, pageId);
+			if (log.isDebugEnabled())
+			{
+				log.debug(
+					"Returning the data (with length '{}') of a stored entry with sessionId '{}' and pageId '{}'",
+					new Object[] { data.length, sessionId, pageId });
+			}
 		}
-		byte[] data = dataStore.getData(sessionId, id);
-
-		log.debug("Returning the data of a stored entry with sessionId '{}' and pageId '{}'",
-			sessionId, id);
-
 		return data;
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#isReplicated()
-	 */
-	public boolean isReplicated()
-	{
-		return dataStore.isReplicated();
-	}
-
 	/**
 	 * @see org.apache.wicket.pageStore.IDataStore#removeData(java.lang.String, int)
 	 */
-	public void removeData(final String sessionId, final int id)
+	public void removeData(final String sessionId, final int pageId)
 	{
-		String key = getKey(sessionId, id);
-		if (key != null)
+		for (Runnable runnable : savePagesExecutor.getQueue())
 		{
-			Entry entry = entryMap.remove(key);
-			if (entry != null)
+			StoreEntryRunnable storeEntryRunnable = (StoreEntryRunnable)runnable;
+			Entry cursorEntry = storeEntryRunnable.getEntry();
+
+			if (cursorEntry.getPageId() == pageId && cursorEntry.getSessionId().equals(sessionId))
 			{
-				entries.remove(entry);
+				savePagesExecutor.remove(runnable);
 			}
 		}
 
-		dataStore.removeData(sessionId, id);
+		dataStore.removeData(sessionId, pageId);
 	}
 
 	/**
@@ -186,73 +145,117 @@ public class AsynchronousDataStore implements IDataStore
 	 */
 	public void removeData(final String sessionId)
 	{
-		for (Iterator<Entry> itor = entries.iterator(); itor.hasNext();)
+		for (Runnable runnable : savePagesExecutor.getQueue())
 		{
-			Entry entry = itor.next();
-			if (entry != null) // this check is not needed in JDK6
-			{
-				String entrySessionId = entry.sessionId;
+			StoreEntryRunnable storeEntryRunnable = (StoreEntryRunnable)runnable;
+			Entry cursorEntry = storeEntryRunnable.getEntry();
 
-				if (sessionId.equals(entrySessionId))
-				{
-					entryMap.remove(getKey(entry));
-					itor.remove();
-				}
+			if (cursorEntry.getSessionId().equals(sessionId))
+			{
+				savePagesExecutor.remove(runnable);
 			}
 		}
 
 		dataStore.removeData(sessionId);
 	}
 
+
 	/**
 	 * Save the entry in the queue if there is a room or directly pass it to the wrapped
 	 * {@link IDataStore} if there is no such
 	 * 
 	 * @see org.apache.wicket.pageStore.IDataStore#storeData(java.lang.String, int, byte[])
 	 */
-	public void storeData(final String sessionId, final int id, final byte[] data)
+	public void storeData(final String sessionId, final int pageId, final byte[] data)
+	{
+		Entry entry = new Entry(sessionId, pageId, data);
+		StoreEntryRunnable storeEntryRunnable = new StoreEntryRunnable(entry, dataStore);
+
+		savePagesExecutor.execute(storeEntryRunnable);
+	}
+
+	/**
+	 * @see org.apache.wicket.pageStore.IDataStore#destroy()
+	 */
+	public void destroy()
 	{
-		Entry entry = new Entry(sessionId, id, data);
+		log.debug("Going to shutdown the shutdown the task executor.");
+		savePagesExecutor.shutdown();
 		try
 		{
-			boolean added = entries.offer(entry, OFFER_WAIT, TimeUnit.MILLISECONDS);
-
-			if (added == false)
-			{
-				log.debug("Storing synchronously page with id '{}' in session '{}'", id, sessionId);
-				dataStore.storeData(sessionId, id, data);
-			}
-			else
+			boolean stopped = savePagesExecutor.awaitTermination(30, TimeUnit.SECONDS);
+			if (stopped == false)
 			{
-				entryMap.put(getKey(entry), entry);
+				log.warn("Some tasks didn't stop successfully. They were forcefully stopped.");
+				savePagesExecutor.shutdownNow();
 			}
 		}
 		catch (InterruptedException e)
 		{
-			log.error(e.getMessage(), e);
-			dataStore.storeData(sessionId, id, data);
+			throw new RuntimeException(e);
 		}
+
+		log.debug("Going to shutdown the shutdown the underlying IDataStore.");
+		dataStore.destroy();
 	}
 
 	/**
-	 * 
-	 * @param pageId
-	 * @param sessionId
-	 * @return generated key
+	 * @see org.apache.wicket.pageStore.IDataStore#isReplicated()
 	 */
-	private static String getKey(final String sessionId, final int pageId)
+	public boolean isReplicated()
 	{
-		return pageId + ":::" + sessionId;
+		return dataStore.isReplicated();
 	}
 
 	/**
-	 * 
-	 * @param entry
-	 * @return generated key
+	 * Rejecting task handler.
+	 * <p>
+	 * If the queue is full a task is rejected and must be saved synchronously in this handler
 	 */
-	private static String getKey(final Entry entry)
+	private static class RejectStoringTask implements RejectedExecutionHandler
 	{
-		return getKey(entry.sessionId, entry.pageId);
+
+		public void rejectedExecution(final Runnable runnable, final ThreadPoolExecutor executor)
+		{
+			StoreEntryRunnable storeEntryRunnable = (StoreEntryRunnable)runnable;
+			IDataStore dataStore = storeEntryRunnable.getDataStore();
+			Entry entry = storeEntryRunnable.getEntry();
+
+			log.debug("Queue is full. Entry '{}' will be saved synchronously.", entry);
+			dataStore.storeData(entry.getSessionId(), entry.getPageId(), entry.getData());
+		}
+
+	}
+
+	/**
+	 * Task implementation to save a page entry in a separate thread
+	 */
+	private static class StoreEntryRunnable implements Runnable
+	{
+		private final Entry entry;
+		private final IDataStore dataStore;
+
+		public StoreEntryRunnable(final Entry entry, final IDataStore dataStore)
+		{
+			this.entry = entry;
+			this.dataStore = dataStore;
+		}
+
+		public void run()
+		{
+			log.debug("Saving asynchronously: '{}'...", entry);
+			dataStore.storeData(entry.getSessionId(), entry.getPageId(), entry.getData());
+		}
+
+		public Entry getEntry()
+		{
+			return entry;
+		}
+
+		public IDataStore getDataStore()
+		{
+			return dataStore;
+		}
 	}
 
 	/**
@@ -271,6 +274,21 @@ public class AsynchronousDataStore implements IDataStore
 			this.data = Args.notNull(data, "data");
 		}
 
+		public String getSessionId()
+		{
+			return sessionId;
+		}
+
+		public int getPageId()
+		{
+			return pageId;
+		}
+
+		public byte[] getData()
+		{
+			return data;
+		}
+
 		@Override
 		public int hashCode()
 		{
@@ -308,59 +326,5 @@ public class AsynchronousDataStore implements IDataStore
 		{
 			return "Entry [sessionId=" + sessionId + ", pageId=" + pageId + "]";
 		}
-
-	}
-
-	/**
-	 * The thread that acts as consumer of {@link Entry}ies
-	 */
-	private static class PageSavingRunnable implements Runnable
-	{
-		private static final Logger log = LoggerFactory.getLogger(PageSavingRunnable.class);
-
-		private final AtomicBoolean destroy;
-
-		private final BlockingQueue<Entry> entries;
-
-		private final ConcurrentMap<String, Entry> entryMap;
-
-		private final IDataStore dataStore;
-
-		private PageSavingRunnable(IDataStore dataStore, BlockingQueue<Entry> entries,
-			ConcurrentMap<String, Entry> entryMap, AtomicBoolean destroy)
-		{
-			this.dataStore = dataStore;
-			this.entries = entries;
-			this.entryMap = entryMap;
-			this.destroy = destroy;
-		}
-
-		public void run()
-		{
-			while (destroy.get() == false)
-			{
-				Entry entry = null;
-				try
-				{
-					entry = entries.poll(POLL_WAIT, TimeUnit.MILLISECONDS);
-				}
-				catch (InterruptedException e)
-				{
-					log.error(e.getMessage(), e);
-				}
-
-				if (entry != null)
-				{
-					log.debug("Saving asynchronously: {}...", entry);
-					dataStore.storeData(entry.sessionId, entry.pageId, entry.data);
-					entryMap.remove(getKey(entry));
-				}
-			}
-
-			synchronized (destroy)
-			{
-				destroy.notify();
-			}
-		}
 	}
 }
diff --git a/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousDataStoreTest.java b/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousDataStoreTest.java
index 26ae83a347..92e00a5bf0 100644
--- a/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousDataStoreTest.java
+++ b/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousDataStoreTest.java
@@ -71,6 +71,7 @@ public class AsynchronousDataStoreTest
 		}
 		LATCH.await();
 		executorService.shutdown();
+		DATA_STORE.destroy();
 	}
 
 	private static abstract class AbstractTask implements Runnable
