diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java
index eb73ee7986..be577f3338 100644
--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java
+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/WicketFilter.java
@@ -96,8 +96,8 @@ public class WicketFilter implements Filter
 	private boolean isServlet = false;
 
 	/**
-	 * default constructor, usually invoked through the servlet 
-	 * container by the web.xml configuration
+	 * default constructor, usually invoked through the servlet container by the web.xml
+	 * configuration
 	 */
 	public WicketFilter()
 	{
@@ -106,11 +106,11 @@ public class WicketFilter implements Filter
 	/**
 	 * constructor supporting programmatic setup of the filter
 	 * <p/>
-	 *  this can be useful for programmatically creating and appending the 
-	 *  wicket filter to the servlet context using servlet 3 features.
+	 * this can be useful for programmatically creating and appending the wicket filter to the
+	 * servlet context using servlet 3 features.
 	 * 
 	 * @param application
-	 *           web application
+	 *            web application
 	 */
 	public WicketFilter(WebApplication application)
 	{
@@ -174,7 +174,7 @@ public class WicketFilter implements Filter
 				return false;
 			}
 
-			if ("OPTIONS".equals(httpServletRequest.getMethod()))
+			if ("OPTIONS".equalsIgnoreCase(httpServletRequest.getMethod()))
 			{
 				// handle the OPTIONS request outside of normal request processing.
 				// wicket pages normally only support GET and POST methods, but resources and
@@ -198,7 +198,8 @@ public class WicketFilter implements Filter
 					httpServletResponse);
 
 				RequestCycle requestCycle = application.createRequestCycle(webRequest, webResponse);
-				res = processRequestCycle(requestCycle, webResponse, httpServletRequest, httpServletResponse, chain);
+				res = processRequestCycle(requestCycle, webResponse, httpServletRequest,
+					httpServletResponse, chain);
 			}
 			else
 			{
@@ -238,7 +239,7 @@ public class WicketFilter implements Filter
 
 	/**
 	 * Process the request cycle
-	 *
+	 * 
 	 * @param requestCycle
 	 * @param webResponse
 	 * @param httpServletRequest
@@ -249,8 +250,9 @@ public class WicketFilter implements Filter
 	 * @throws ServletException
 	 */
 	protected boolean processRequestCycle(RequestCycle requestCycle, WebResponse webResponse,
-	    HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,
-		final FilterChain chain) throws IOException, ServletException {
+		HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse,
+		final FilterChain chain) throws IOException, ServletException
+	{
 		// Assume we are able to handle the request
 		boolean res = true;
 
@@ -518,6 +520,7 @@ public class WicketFilter implements Filter
 
 	/**
 	 * Provide a standard getter for filterPath.
+	 * 
 	 * @return The configured filterPath.
 	 */
 	protected String getFilterPath()
@@ -651,7 +654,8 @@ public class WicketFilter implements Filter
 		if (this.filterPath != null)
 		{
 			throw new IllegalStateException(
-				"Filter path is write-once. You can not change it. Current value='" + filterPath + '\'');
+				"Filter path is write-once. You can not change it. Current value='" + filterPath +
+					'\'');
 		}
 		if (filterPath != null)
 		{
@@ -775,7 +779,7 @@ public class WicketFilter implements Filter
 	 * A filterPath should have all leading slashes removed and exactly one trailing slash. A
 	 * wildcard asterisk character has no special meaning. If your intention is to mean the top
 	 * level "/" then an empty string should be used instead.
-	 *
+	 * 
 	 * @param filterPath
 	 * @return
 	 */
diff --git a/wicket-core/src/test/java/org/apache/wicket/protocol/http/WicketFilterTest.java b/wicket-core/src/test/java/org/apache/wicket/protocol/http/WicketFilterTest.java
index 5c5234f018..82c7320b65 100644
--- a/wicket-core/src/test/java/org/apache/wicket/protocol/http/WicketFilterTest.java
+++ b/wicket-core/src/test/java/org/apache/wicket/protocol/http/WicketFilterTest.java
@@ -16,10 +16,7 @@
  */
 package org.apache.wicket.protocol.http;
 
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.spy;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+import static org.mockito.Mockito.*;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -54,8 +51,11 @@ import org.apache.wicket.protocol.http.mock.MockHttpServletRequest;
 import org.apache.wicket.protocol.http.mock.MockHttpServletResponse;
 import org.apache.wicket.protocol.http.mock.MockServletContext;
 import org.apache.wicket.request.http.WebRequest;
+import org.apache.wicket.request.resource.AbstractResource;
 import org.apache.wicket.request.resource.DynamicImageResource;
+import org.apache.wicket.request.resource.IResource;
 import org.apache.wicket.util.file.WebXmlFile;
+import org.apache.wicket.util.string.Strings;
 import org.apache.wicket.util.tester.DummyHomePage;
 import org.junit.After;
 import org.junit.Assert;
@@ -171,6 +171,80 @@ public class WicketFilterTest extends Assert
 		}
 	}
 
+	@Test
+	public void options() throws IOException, ServletException, ParseException
+	{
+		try
+		{
+			application = new MockApplication();
+			WicketFilter filter = new WicketFilter();
+			filter.init(new FilterTestingConfig());
+			ThreadContext.setApplication(application);
+			final String failure = "Should never get here when an OPTIONS request is issued";
+			IResource resource = new AbstractResource()
+			{
+				@Override
+				protected ResourceResponse newResourceResponse(Attributes attributes)
+				{
+
+					fail(failure);
+					return null;
+				}
+			};
+			application.getSharedResources().add("foo.txt", resource);
+
+			// check OPTIONS request is processed correctly
+
+			MockHttpServletRequest request = new MockHttpServletRequest(application, null, null);
+			request.setURL(request.getContextPath() + request.getServletPath() +
+				"/wicket/resource/" + Application.class.getName() + "/foo.txt");
+			request.setMethod("OPtioNS"); // test that we do not care about case
+			MockHttpServletResponse response = new MockHttpServletResponse(request);
+			filter.doFilter(request, response, new FilterChain()
+			{
+				@Override
+				public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse)
+					throws IOException, ServletException
+				{
+				}
+			});
+
+			assertEquals(HttpServletResponse.SC_OK, response.getStatus());
+			assertEquals("0", response.getHeader("Content-Length"));
+			assertFalse(Strings.isEmpty(response.getHeader("Allow")));
+			assertTrue(response.getHeader("Allow").toUpperCase().contains("GET"));
+			assertTrue(response.getHeader("Allow").toUpperCase().contains("POST"));
+
+			// try with a GET request to make sure we fail correctly
+
+			request = new MockHttpServletRequest(application, null, null);
+			request.setURL(request.getContextPath() + request.getServletPath() +
+				"/wicket/resource/" + Application.class.getName() + "/foo.txt");
+			response = new MockHttpServletResponse(request);
+			try
+			{
+				filter.doFilter(request, response, new FilterChain()
+				{
+					@Override
+					public void doFilter(ServletRequest servletRequest,
+						ServletResponse servletResponse) throws IOException, ServletException
+					{
+					}
+				});
+			}
+			catch (AssertionError e)
+			{
+				assertTrue(failure.equals(e.getMessage()));
+			}
+
+		}
+		finally
+		{
+			ThreadContext.detach();
+		}
+	}
+
+
 	private void setIfModifiedSinceToNextWeek(MockHttpServletRequest request)
 	{
 		Calendar nextWeek = Calendar.getInstance();
