diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java
index 735683ca94..fd55e405d5 100644
--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java
+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java
@@ -242,18 +242,18 @@ public class AsynchronousPageStore extends DelegatingPageStore
 	{
 		private static final Logger log = LoggerFactory.getLogger(PageAddingRunnable.class);
 
-		private final BlockingQueue<PendingAdd> entries;
+		private final BlockingQueue<PendingAdd> queue;
 
-		private final ConcurrentMap<String, PendingAdd> addQueue;
+		private final ConcurrentMap<String, PendingAdd> map;
 
 		private final IPageStore delegate;
 
-		private PageAddingRunnable(IPageStore delegate, BlockingQueue<PendingAdd> entries,
-		                           ConcurrentMap<String, PendingAdd> entryMap)
+		private PageAddingRunnable(IPageStore delegate, BlockingQueue<PendingAdd> queue,
+		                           ConcurrentMap<String, PendingAdd> map)
 		{
 			this.delegate = delegate;
-			this.entries = entries;
-			this.addQueue = entryMap;
+			this.queue = queue;
+			this.map = map;
 		}
 
 		@Override
@@ -264,7 +264,7 @@ public class AsynchronousPageStore extends DelegatingPageStore
 				PendingAdd add = null;
 				try
 				{
-					add = entries.poll(POLL_WAIT, TimeUnit.MILLISECONDS);
+					add = queue.poll(POLL_WAIT, TimeUnit.MILLISECONDS);
 				}
 				catch (InterruptedException e)
 				{
@@ -276,7 +276,7 @@ public class AsynchronousPageStore extends DelegatingPageStore
 					log.debug("Saving asynchronously: {}...", add);
 					add.asynchronous = true;					
 					delegate.addPage(add, add.page);
-					addQueue.remove(add.getKey());
+					map.remove(add.getKey());
 				}
 			}
 		}
@@ -383,7 +383,14 @@ public class AsynchronousPageStore extends DelegatingPageStore
 			return;
 		}
 
-		queue.removeIf(add -> add.sessionId.equals(sessionId));
+		queue.removeIf(add -> {
+			if (add.sessionId.equals(sessionId)) {
+				queueMap.remove(add.getKey());
+				return true;
+			}
+			
+			return false;
+		});
 		
 		getDelegate().removeAllPages(context);
 	}
diff --git a/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java b/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java
index 3f72f98c1f..ffd85e5020 100644
--- a/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java
+++ b/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java
@@ -176,8 +176,6 @@ public class AsynchronousPageStoreTest
 	{
 		final Semaphore semaphore = new Semaphore(0);
 		
-		final AtomicBoolean got = new AtomicBoolean(false);
-		
 		IPageStore store = new MockPageStore() {
 			
 			@Override
@@ -223,6 +221,63 @@ public class AsynchronousPageStoreTest
 		store.destroy();
 	}
 
+	/**
+	 * WICKET-6793
+	 *
+	 * @throws InterruptedException
+	 */
+	@Test
+	void dontKeepPendingPagesInMapIfSessionExpires() throws InterruptedException
+	{
+
+		final Semaphore semaphore = new Semaphore(0);
+		
+		IPageStore store = new NoopPageStore() {
+			
+			@Override
+			public synchronized void addPage(IPageContext context, IManageablePage page)
+			{
+				try
+				{
+					semaphore.acquire();
+				}
+				catch (InterruptedException e)
+				{
+				}
+			}
+			
+			@Override
+			public IManageablePage getPage(IPageContext context, int id)
+			{
+				return null;
+			}
+		};
+
+		IPageStore asyncPageStore = new AsynchronousPageStore(store, 100);
+
+		int pageId = 0;
+		
+		String sessionId = "sessionId";
+		
+		IPageContext context = new MockPageContext(sessionId);
+
+		SerializedPage page = new SerializedPage(pageId, "", new byte[0]);
+		// add twice so the first one clogs the queue and the second
+		// is still present in the queue
+		asyncPageStore.addPage(context, page);
+		asyncPageStore.addPage(context, page);
+
+		// clear the queue
+		asyncPageStore.removeAllPages(context);
+		
+		assertEquals(null, asyncPageStore.getPage(context, pageId));
+		
+		store.destroy();
+
+		semaphore.release();
+	}
+
+
 	/**
 	 * Store works fully asynchronous when number of pages handled never exceeds the
 	 * asynchronous-storage capacity.
