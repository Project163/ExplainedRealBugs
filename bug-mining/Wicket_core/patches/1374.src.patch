diff --git a/wicket-core/src/main/java/org/apache/wicket/DefaultPageManagerProvider.java b/wicket-core/src/main/java/org/apache/wicket/DefaultPageManagerProvider.java
index d7b0b45870..4b9b13079c 100644
--- a/wicket-core/src/main/java/org/apache/wicket/DefaultPageManagerProvider.java
+++ b/wicket-core/src/main/java/org/apache/wicket/DefaultPageManagerProvider.java
@@ -73,7 +73,9 @@ public class DefaultPageManagerProvider implements IPageManagerProvider
 			}
 		}
 		else
+		{
 			pageStore = newPageStore(dataStore);
+		}
 
 		return new PageStoreManager(application.getName(), pageStore, pageManagerContext);
 
@@ -84,7 +86,6 @@ public class DefaultPageManagerProvider implements IPageManagerProvider
 		int inmemoryCacheSize = getStoreSettings().getInmemoryCacheSize();
 		ISerializer pageSerializer = application.getFrameworkSettings().getSerializer();
 		return new DefaultPageStore(pageSerializer, dataStore, inmemoryCacheSize);
-//		return new PerSessionPageStore(pageSerializer, dataStore, inmemoryCacheSize);
 	}
 
 	protected IDataStore newDataStore()
diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java
index e98eb64167..7ccd689048 100644
--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java
+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousDataStore.java
@@ -88,18 +88,15 @@ public class AsynchronousDataStore implements IDataStore
 	public AsynchronousDataStore(final IDataStore dataStore, final int capacity)
 	{
 		this.dataStore = dataStore;
-		entries = new LinkedBlockingQueue<Entry>(capacity);
-		entryMap = new ConcurrentHashMap<String, Entry>();
+		entries = new LinkedBlockingQueue<>(capacity);
+		entryMap = new ConcurrentHashMap<>();
 
 		PageSavingRunnable savingRunnable = new PageSavingRunnable(dataStore, entries, entryMap);
-		pageSavingThread = new Thread(savingRunnable, "Wicket-PageSavingThread");
+		pageSavingThread = new Thread(savingRunnable, "Wicket-AsyncDataStore-PageSavingThread");
 		pageSavingThread.setDaemon(true);
 		pageSavingThread.start();
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#destroy()
-	 */
 	@Override
 	public void destroy()
 	{
@@ -130,9 +127,6 @@ public class AsynchronousDataStore implements IDataStore
 		return entryMap.get(getKey(sessionId, id));
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#getData(java.lang.String, int)
-	 */
 	@Override
 	public byte[] getData(final String sessionId, final int id)
 	{
@@ -152,18 +146,12 @@ public class AsynchronousDataStore implements IDataStore
 		return data;
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#isReplicated()
-	 */
 	@Override
 	public boolean isReplicated()
 	{
 		return dataStore.isReplicated();
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#removeData(java.lang.String, int)
-	 */
 	@Override
 	public void removeData(final String sessionId, final int id)
 	{
@@ -180,9 +168,6 @@ public class AsynchronousDataStore implements IDataStore
 		dataStore.removeData(sessionId, id);
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IDataStore#removeData(java.lang.String)
-	 */
 	@Override
 	public void removeData(final String sessionId)
 	{
@@ -362,7 +347,7 @@ public class AsynchronousDataStore implements IDataStore
 	@Override
 	public final boolean canBeAsynchronous()
 	{
-		// should not wrap in abother AsynchronousDataStore
+		// should not wrap in another AsynchronousDataStore
 		return false;
 	}
 }
diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java
index 3c77df600e..43993ba74f 100644
--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java
+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/AsynchronousPageStore.java
@@ -1,3 +1,19 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.wicket.pageStore;
 
 import java.io.Serializable;
@@ -8,7 +24,6 @@ import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 
 import org.apache.wicket.page.IManageablePage;
-import org.apache.wicket.pageStore.IPageStore;
 import org.apache.wicket.util.lang.Args;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -53,7 +68,7 @@ public class AsynchronousPageStore implements IPageStore
 	/**
 	 * The wrapped {@link IPageStore} that actually stores that pages
 	 */
-	private final IPageStore pageStore;
+	private final IPageStore delegate;
 
 	/**
 	 * The queue where the entries which have to be saved are temporary stored
@@ -69,19 +84,19 @@ public class AsynchronousPageStore implements IPageStore
 	/**
 	 * Construct.
 	 * 
-	 * @param pageStore
+	 * @param delegate
 	 *            the wrapped {@link IPageStore} that actually saved the page
 	 * @param capacity
 	 *            the capacity of the queue that delays the saving
 	 */
-	public AsynchronousPageStore(final IPageStore pageStore, final int capacity)
+	public AsynchronousPageStore(final IPageStore delegate, final int capacity)
 	{
-		this.pageStore = pageStore;
-		entries = new LinkedBlockingQueue<Entry>(capacity);
-		entryMap = new ConcurrentHashMap<String, Entry>();
+		this.delegate = Args.notNull(delegate, "delegate");
+		entries = new LinkedBlockingQueue<>(capacity);
+		entryMap = new ConcurrentHashMap<>();
 
-		PageSavingRunnable savingRunnable = new PageSavingRunnable(pageStore, entries, entryMap);
-		pageSavingThread = new Thread(savingRunnable, "AsyncPageStore-PageSavingThread");
+		PageSavingRunnable savingRunnable = new PageSavingRunnable(delegate, entries, entryMap);
+		pageSavingThread = new Thread(savingRunnable, "Wicket-AsyncPageStore-PageSavingThread");
 		pageSavingThread.setDaemon(true);
 		pageSavingThread.start();
 	}
@@ -139,7 +154,7 @@ public class AsynchronousPageStore implements IPageStore
 			final int prime = 31;
 			int result = 1;
 			result = prime * result + page.getPageId();
-			result = prime * result + ((sessionId == null) ? 0 : sessionId.hashCode());
+			result = prime * result + sessionId.hashCode();
 			return result;
 		}
 
@@ -155,12 +170,7 @@ public class AsynchronousPageStore implements IPageStore
 			Entry other = (Entry)obj;
 			if (page.getPageId() != other.page.getPageId())
 				return false;
-			if (sessionId == null)
-			{
-				if (other.sessionId != null)
-					return false;
-			}
-			else if (!sessionId.equals(other.sessionId))
+			if (!sessionId.equals(other.sessionId))
 				return false;
 			return true;
 		}
@@ -184,12 +194,12 @@ public class AsynchronousPageStore implements IPageStore
 
 		private final ConcurrentMap<String, Entry> entryMap;
 
-		private final IPageStore pageStore;
+		private final IPageStore delegate;
 
-		private PageSavingRunnable(IPageStore pageStore, BlockingQueue<Entry> entries,
-			ConcurrentMap<String, Entry> entryMap)
+		private PageSavingRunnable(IPageStore delegate, BlockingQueue<Entry> entries,
+		                           ConcurrentMap<String, Entry> entryMap)
 		{
-			this.pageStore = pageStore;
+			this.delegate = delegate;
 			this.entries = entries;
 			this.entryMap = entryMap;
 		}
@@ -212,16 +222,13 @@ public class AsynchronousPageStore implements IPageStore
 				if (entry != null)
 				{
 					log.debug("Saving asynchronously: {}...", entry);
-					pageStore.storePage(entry.sessionId, entry.page);
+					delegate.storePage(entry.sessionId, entry.page);
 					entryMap.remove(getKey(entry));
 				}
 			}
 		}
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#destroy()
-	 */
 	@Override
 	public void destroy()
 	{
@@ -238,12 +245,9 @@ public class AsynchronousPageStore implements IPageStore
 			}
 		}
 
-		pageStore.destroy();
+		delegate.destroy();
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#getPage(java.lang.String, int)
-	 */
 	@Override
 	public IManageablePage getPage(String sessionId, int pageId)
 	{
@@ -255,7 +259,7 @@ public class AsynchronousPageStore implements IPageStore
 				sessionId, pageId);
 			return entry.page;
 		}
-		IManageablePage page = pageStore.getPage(sessionId, pageId);
+		IManageablePage page = delegate.getPage(sessionId, pageId);
 
 		log.debug("Returning the page of a stored entry with session id '{}' and page id '{}'",
 			sessionId, pageId);
@@ -263,9 +267,6 @@ public class AsynchronousPageStore implements IPageStore
 		return page;
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#removePage(java.lang.String, int)
-	 */
 	@Override
 	public void removePage(String sessionId, int pageId)
 	{
@@ -279,14 +280,9 @@ public class AsynchronousPageStore implements IPageStore
 			}
 		}
 
-		pageStore.removePage(sessionId, pageId);
-
+		delegate.removePage(sessionId, pageId);
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#storePage(java.lang.String,
-	 *      org.apache.wicket.page.IManageablePage)
-	 */
 	@Override
 	public void storePage(String sessionId, IManageablePage page)
 	{
@@ -306,59 +302,45 @@ public class AsynchronousPageStore implements IPageStore
 				log.debug("Storing synchronously page with id '{}' in session '{}'",
 					page.getPageId(), sessionId);
 				entryMap.remove(key);
-				pageStore.storePage(sessionId, page);
+				delegate.storePage(sessionId, page);
 			}
 		}
 		catch (InterruptedException e)
 		{
 			log.error(e.getMessage(), e);
 			entryMap.remove(key);
-			pageStore.storePage(sessionId, page);
+			delegate.storePage(sessionId, page);
 		}
-
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#unbind(java.lang.String)
-	 */
 	@Override
 	public void unbind(String sessionId)
 	{
-		pageStore.unbind(sessionId);
+		delegate.unbind(sessionId);
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#prepareForSerialization(java.lang. String,
-	 *      java.io.Serializable)
-	 */
 	@Override
 	public Serializable prepareForSerialization(String sessionId, Serializable page)
 	{
-		return pageStore.prepareForSerialization(sessionId, page);
+		return delegate.prepareForSerialization(sessionId, page);
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#restoreAfterSerialization(java.io. Serializable)
-	 */
 	@Override
 	public Object restoreAfterSerialization(Serializable serializable)
 	{
-		return pageStore.restoreAfterSerialization(serializable);
+		return delegate.restoreAfterSerialization(serializable);
 	}
 
-	/**
-	 * @see org.apache.wicket.pageStore.IPageStore#convertToPage(java.lang.Object)
-	 */
 	@Override
 	public IManageablePage convertToPage(Object page)
 	{
-		return pageStore.convertToPage(page);
+		return delegate.convertToPage(page);
 	}
 
 	@Override
 	public boolean canBeAsynchronous()
 	{
+		// should not wrap in another AsynchronousPageStore
 		return false;
 	}
-
 }
diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/PerSessionPageStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/PerSessionPageStore.java
index abef0c9244..4a21f4c58e 100644
--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/PerSessionPageStore.java
+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/PerSessionPageStore.java
@@ -323,7 +323,6 @@ public class PerSessionPageStore extends AbstractCachingPageStore<IManageablePag
 			cache.clear();
 		}
 	}
-	
 
 	@Override
 	public boolean canBeAsynchronous()
diff --git a/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java b/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java
index 7ade857840..4b17f6930f 100644
--- a/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java
+++ b/wicket-core/src/test/java/org/apache/wicket/pageStore/AsynchronousPageStoreTest.java
@@ -1,3 +1,19 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package org.apache.wicket.pageStore;
 
 import static org.junit.Assert.assertEquals;
@@ -8,44 +24,34 @@ import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutput;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
+import com.google.common.base.Stopwatch;
 import org.apache.commons.lang3.RandomUtils;
 import org.apache.wicket.page.IManageablePage;
 import org.apache.wicket.serialize.ISerializer;
 import org.apache.wicket.serialize.java.DeflatedJavaSerializer;
+import org.apache.wicket.util.SlowTests;
 import org.apache.wicket.util.file.File;
 import org.apache.wicket.util.lang.Bytes;
 import org.junit.Test;
+import org.junit.experimental.categories.Category;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.base.Stopwatch;
-
 
 /**
  * AsynchronousPageStoreTest
- * 
- * @author manuelbarzi
  *
+ * @author manuelbarzi
  */
+@Category(SlowTests.class)
 public class AsynchronousPageStoreTest
 {
-
 	/** Log for reporting. */
 	private static final Logger log = LoggerFactory.getLogger(AsynchronousPageStoreTest.class);
 
@@ -96,7 +102,7 @@ public class AsynchronousPageStoreTest
 		private void writeObject(java.io.ObjectOutputStream s) throws IOException
 		{
 			log.debug("serializing page {} for {}ms (session {})", getPageId(), writeMillis,
-				sessionId);
+					sessionId);
 			try
 			{
 				Thread.sleep(writeMillis);
@@ -113,10 +119,10 @@ public class AsynchronousPageStoreTest
 		}
 
 		private void readObject(java.io.ObjectInputStream s)
-			throws IOException, ClassNotFoundException
+				throws IOException, ClassNotFoundException
 		{
 			log.debug("deserializing page {} for {}ms (session {})", getPageId(), writeMillis,
-				sessionId);
+					sessionId);
 			try
 			{
 				Thread.sleep(readMillis);
@@ -135,15 +141,15 @@ public class AsynchronousPageStoreTest
 		public String toString()
 		{
 			return "DummyPage[pageId = " + pageId + ", writeMillis = " + writeMillis +
-				", readMillis = " + readMillis + ", sessionId = " + sessionId + ", hashCode = " +
-				hashCode() + "]";
+					", readMillis = " + readMillis + ", sessionId = " + sessionId + ", hashCode = " +
+					hashCode() + "]";
 		}
 	}
 
 	/**
 	 * Store returns the same page instance from queue when there is a close request for it back
 	 * again.
-	 * 
+	 *
 	 * @throws InterruptedException
 	 */
 	@Test
@@ -154,7 +160,7 @@ public class AsynchronousPageStoreTest
 		// ISerializer serializer = new DummySerializer();
 
 		IDataStore dataStore = new DiskDataStore("applicationName", new File("./target"),
-			Bytes.bytes(10000l));
+				Bytes.bytes(10000l));
 
 		// IPageStore pageStore = new DummyPageStore(new File("target/store"));
 		IPageStore pageStore = spy(new DefaultPageStore(serializer, dataStore, 0));
@@ -179,7 +185,7 @@ public class AsynchronousPageStoreTest
 	/**
 	 * Store returns the restored page instance from wrapped store when there is a distant request
 	 * for it back again.
-	 * 
+	 *
 	 * @throws InterruptedException
 	 */
 	@Test
@@ -190,7 +196,7 @@ public class AsynchronousPageStoreTest
 		// ISerializer serializer = new DummySerializer();
 
 		IDataStore dataStore = new DiskDataStore("applicationName", new File("./target"),
-			Bytes.bytes(10000l));
+				Bytes.bytes(10000l));
 
 		// IPageStore pageStore = new DummyPageStore(new File("target/store"));
 		IPageStore pageStore = spy(new DefaultPageStore(serializer, dataStore, 0));
@@ -215,7 +221,7 @@ public class AsynchronousPageStoreTest
 	/**
 	 * Store works fully asynchronous when number of pages handled never exceeds the
 	 * asynchronous-storage capacity.
-	 * 
+	 *
 	 * @throws InterruptedException
 	 */
 	@Test
@@ -228,7 +234,7 @@ public class AsynchronousPageStoreTest
 		int asyncPageStoreCapacity = pages * sessions;
 
 		List<Metrics> results = runTest(sessions, pages, writeMillis, readMillis,
-			asyncPageStoreCapacity);
+				asyncPageStoreCapacity);
 
 		for (Metrics metrics : results)
 			System.out.println(metrics);
@@ -244,7 +250,7 @@ public class AsynchronousPageStoreTest
 	/**
 	 * Store behaves sync from when number of pages handled exceeds the given asynchronous-storage
 	 * capacity. It works asynchronous until the number of pages reaches the limit (capacity).
-	 * 
+	 *
 	 * @throws InterruptedException
 	 */
 	@Test
@@ -255,10 +261,10 @@ public class AsynchronousPageStoreTest
 		long writeMillis = 2000;
 		long readMillis = 1500;
 		int asyncPageStoreCapacity = pages; // only up to the first round of
-											// pages
+		// pages
 
 		List<Metrics> results = runTest(sessions, pages, writeMillis, readMillis,
-			asyncPageStoreCapacity);
+				asyncPageStoreCapacity);
 
 		for (Metrics metrics : results)
 			System.out.println(metrics);
@@ -294,12 +300,12 @@ public class AsynchronousPageStoreTest
 		public String toString()
 		{
 			return "Metrics[storedPage = " + storedPage + ", storingMillis = " + storingMillis +
-				", restoredPage = " + restoredPage + ", restoringMillis = " + restoringMillis + "]";
+					", restoredPage = " + restoredPage + ", restoringMillis = " + restoringMillis + "]";
 		}
 	}
 
 	private List<Metrics> runTest(int sessions, int pages, long writeMillis, long readMillis,
-		int asyncPageStoreCapacity) throws InterruptedException
+	                              int asyncPageStoreCapacity) throws InterruptedException
 	{
 
 		List<Metrics> results = new ArrayList<>();
@@ -310,7 +316,7 @@ public class AsynchronousPageStoreTest
 		ISerializer serializer = new DeflatedJavaSerializer("applicationKey");
 
 		IDataStore dataStore = new DiskDataStore("applicationName", new File("./target"),
-			Bytes.bytes(10000l));
+				Bytes.bytes(10000l));
 
 		// IPageStore pageStore = new DummyPageStore(new File("target/store")) {
 		IPageStore pageStore = new DefaultPageStore(serializer, dataStore, 0)
@@ -339,7 +345,7 @@ public class AsynchronousPageStoreTest
 
 				stopwatch.reset();
 				DummyPage page = new DummyPage(pageId, around(writeMillis), around(readMillis),
-					sessionId);
+						sessionId);
 				stopwatch.start();
 				asyncPageStore.storePage(sessionId, page);
 				metrics.storedPage = page;
@@ -348,7 +354,7 @@ public class AsynchronousPageStoreTest
 				stopwatch.reset();
 				stopwatch.start();
 				metrics.restoredPage = DummyPage.class
-					.cast(asyncPageStore.getPage(sessionId, pageId));
+						.cast(asyncPageStore.getPage(sessionId, pageId));
 				metrics.restoringMillis = stopwatch.elapsed(TimeUnit.MILLISECONDS);
 
 				results.add(metrics);
@@ -364,219 +370,4 @@ public class AsynchronousPageStoreTest
 	{
 		return RandomUtils.nextLong((long)(target * .9), (long)(target * 1.1));
 	}
-
-	// other aux dummy impls for testing
-
-	private class DummySerializer implements ISerializer
-	{
-
-		@Override
-		public byte[] serialize(Object obj)
-		{
-			ByteArrayOutputStream bos = null;
-			ObjectOutput out = null;
-			try
-			{
-				bos = new ByteArrayOutputStream();
-				out = new ObjectOutputStream(bos);
-				out.writeObject(obj);
-				return bos.toByteArray();
-			}
-			catch (FileNotFoundException e)
-			{
-				throw new RuntimeException(e);
-			}
-			catch (IOException e)
-			{
-				throw new RuntimeException(e);
-			}
-			finally
-			{
-				try
-				{
-					if (bos != null)
-						bos.close();
-					if (out != null)
-						out.close();
-				}
-				catch (IOException e)
-				{
-					throw new RuntimeException(e);
-				}
-			}
-		}
-
-		@Override
-		public Object deserialize(byte[] bytes)
-		{
-			ByteArrayInputStream bis = null;
-			ObjectInput in = null;
-			try
-			{
-				bis = new ByteArrayInputStream(bytes);
-				in = new ObjectInputStream(bis);
-				return in.readObject();
-			}
-			catch (IOException e)
-			{
-				throw new RuntimeException(e);
-			}
-			catch (ClassNotFoundException e)
-			{
-				throw new RuntimeException(e);
-			}
-			finally
-			{
-				try
-				{
-					if (bis != null)
-						bis.close();
-					if (in != null)
-						in.close();
-				}
-				catch (IOException e)
-				{
-					throw new RuntimeException(e);
-				}
-			}
-		}
-
-	}
-
-	private class DummyPageStore implements IPageStore
-	{
-
-		private File folder;
-
-		private DummyPageStore(File folder)
-		{
-			folder.mkdirs();
-			this.folder = folder;
-		}
-
-		private File getPageFile(String sessionId, int pageId)
-		{
-			return new File(folder.getAbsolutePath() + "/" + sessionId + "-" + pageId + ".page");
-		}
-
-		private void toFile(Object obj, File file)
-		{
-			FileOutputStream fos = null;
-			ObjectOutput oo = null;
-			try
-			{
-				fos = new FileOutputStream(file);
-				oo = new ObjectOutputStream(fos);
-				oo.writeObject(obj);
-			}
-			catch (FileNotFoundException e)
-			{
-				throw new RuntimeException(e);
-			}
-			catch (IOException e)
-			{
-				throw new RuntimeException(e);
-			}
-			finally
-			{
-				try
-				{
-					if (fos != null)
-						fos.close();
-					if (oo != null)
-						oo.close();
-				}
-				catch (IOException e)
-				{
-					throw new RuntimeException(e);
-				}
-			}
-		}
-
-		private Object fromFile(File file)
-		{
-			FileInputStream fis = null;
-			ObjectInput oi = null;
-			try
-			{
-				fis = new FileInputStream(file);
-				oi = new ObjectInputStream(fis);
-				return oi.readObject();
-			}
-			catch (IOException e)
-			{
-				throw new RuntimeException(e);
-			}
-			catch (ClassNotFoundException e)
-			{
-				throw new RuntimeException(e);
-			}
-			finally
-			{
-				try
-				{
-					if (fis != null)
-						fis.close();
-					if (oi != null)
-						oi.close();
-				}
-				catch (IOException e)
-				{
-					throw new RuntimeException(e);
-				}
-			}
-		}
-
-		@Override
-		public void destroy()
-		{
-		}
-
-		@Override
-		public IManageablePage getPage(String sessionId, int pageId)
-		{
-			return (IManageablePage)fromFile(getPageFile(sessionId, pageId));
-		}
-
-		@Override
-		public void removePage(String sessionId, int pageId)
-		{
-		}
-
-		@Override
-		public void storePage(String sessionId, IManageablePage page)
-		{
-			toFile(page, getPageFile(sessionId, page.getPageId()));
-		}
-
-		@Override
-		public void unbind(String sessionId)
-		{
-		}
-
-		@Override
-		public Serializable prepareForSerialization(String sessionId, Serializable page)
-		{
-			return null;
-		}
-
-		@Override
-		public Object restoreAfterSerialization(Serializable serializable)
-		{
-			return null;
-		}
-
-		@Override
-		public IManageablePage convertToPage(Object page)
-		{
-			return null;
-		}
-
-		@Override
-		public boolean canBeAsynchronous()
-		{
-			return false;
-		}
-	}
-
-}
\ No newline at end of file
+}
