diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java b/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java
index b51029d7e4..a505dda5da 100644
--- a/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java
+++ b/wicket-core/src/main/java/org/apache/wicket/markup/html/tree/AbstractTree.java
@@ -846,17 +846,28 @@ public abstract class AbstractTree extends Panel
 			{
 				wasLeaf = eventChildren.contains(getChildAt(parentNode, i));
 			}
-			// if parent was a leaf, testing if wasn't an not presented root
-			if (wasLeaf && !(parentItem.getParentItem() == null && isRootLess()))
+
+			boolean addingToHiddedRoot = parentItem.getParentItem() == null && isRootLess();
+			// if parent was a presented leaf
+			if (wasLeaf && !addingToHiddedRoot)
 			{
 				// parentNode now has children for the first time, so we may need to invalidate
 				// grandparent so that parentNode's junctionLink gets rebuilt with a plus/minus link
 				Object grandparentNode = getParentNode(parentNode);
-				// not invalidating if the grandparent is a not presented root
-				if (!(getParentNode(grandparentNode) == null && isRootLess()))
+				boolean addingToHiddedRootSon = grandparentNode != null &&
+					getParentNode(grandparentNode) == null && isRootLess();
+				// if visible, invalidate the grandparent
+				if (grandparentNode != null && !addingToHiddedRootSon)
 				{
 					invalidateNodeWithChildren(grandparentNode);
 				}
+				else
+				{
+					// if not, simply invalidating the parent node
+					// OBS.: forcing rebuild since unlike the grandparent, the old
+					// leaf parent needs to rebuild with plus/minus link
+					invalidateNode(parentNode, true);
+				}
 				getTreeState().expandNode(parentNode);
 			}
 			else
diff --git a/wicket-core/src/test/java/org/apache/wicket/markup/html/tree/TreeTest.java b/wicket-core/src/test/java/org/apache/wicket/markup/html/tree/TreeTest.java
index cd9369ce42..3d6f9214a8 100644
--- a/wicket-core/src/test/java/org/apache/wicket/markup/html/tree/TreeTest.java
+++ b/wicket-core/src/test/java/org/apache/wicket/markup/html/tree/TreeTest.java
@@ -29,9 +29,6 @@ import org.apache.wicket.util.resource.IResourceStream;
 import org.apache.wicket.util.resource.StringResourceStream;
 
 /**
- * Test cases preventing the two related bugs at:
- * 
- * @see <a href="https://issues.apache.org/jira/browse/WICKET-3309">WICKET-3309</a>
  * @author Pedro Santos
  */
 public class TreeTest extends WicketTestCase
@@ -41,6 +38,8 @@ public class TreeTest extends WicketTestCase
 	 * Asserting that {@link AbstractTree#treeNodesInserted(javax.swing.event.TreeModelEvent)} adds
 	 * the new item to the dirtyItemsCreateDOM, since there is no parent node at client to be
 	 * recreated.
+	 * 
+	 * @see <a href="https://issues.apache.org/jira/browse/WICKET-3309">WICKET-3309</a>
 	 */
 	public void testAddChildOnRootAtAnOnRootLessTree()
 	{
@@ -54,6 +53,8 @@ public class TreeTest extends WicketTestCase
 	/**
 	 * Asserting that {@link AbstractTree#treeNodesInserted(javax.swing.event.TreeModelEvent)} don't
 	 * add and not presented node to the AJAX response by invalidating it.
+	 * 
+	 * @see <a href="https://issues.apache.org/jira/browse/WICKET-3309">WICKET-3309</a>
 	 */
 	public void testAddGrandchildOnRootAtAnRootLessTree()
 	{
@@ -67,6 +68,19 @@ public class TreeTest extends WicketTestCase
 		assertTrue(tester.getLastResponseAsString().contains("newNode"));
 	}
 
+	/**
+	 * Asserting the old leaf root node gets a junction link when adding its first child
+	 * 
+	 * @see <a href="https://issues.apache.org/jira/browse/WICKET-3449">WICKET-3449</a>
+	 */
+	public void testJunctionLinkRendered()
+	{
+		TestPage testPage = new TestPage();
+		tester.startPage(testPage);
+		tester.clickLink("addToRoot", true);
+		assertTrue(tester.getLastResponseAsString().contains("junctionLink"));
+	}
+
 	/** */
 	public static class TestPage extends WebPage implements IMarkupResourceStreamProvider
 	{
