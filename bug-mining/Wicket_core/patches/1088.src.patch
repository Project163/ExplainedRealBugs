diff --git a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java
index 1ec4f02a73..4b40921e6d 100644
--- a/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java
+++ b/wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java
@@ -35,7 +35,6 @@ import org.apache.wicket.markup.MarkupStream;
 import org.apache.wicket.markup.MarkupType;
 import org.apache.wicket.markup.WicketTag;
 import org.apache.wicket.markup.html.border.Border;
-import org.apache.wicket.markup.html.internal.InlineEnclosure;
 import org.apache.wicket.markup.resolver.ComponentResolvers;
 import org.apache.wicket.model.IComponentInheritedModel;
 import org.apache.wicket.model.IModel;
@@ -262,9 +261,31 @@ public abstract class MarkupContainer extends Component implements Iterable<Comp
 			children_remove(index);
 		}
 		add(component);
-
+		
+		/**
+		 * https://issues.apache.org/jira/browse/WICKET-5724
+		 */
+		queueChildContainer(component);
+		
 		return true;
 	}
+	
+	/**
+	 * Try to queue a child markup container if the current 
+	 * component queue still contain items.
+	 * 
+	 * @param component
+	 * 	The children markup container
+	 */
+	private void queueChildContainer(final Component component)
+	{
+		if (queue != null && !queue.isEmpty() && 
+			component instanceof MarkupContainer)
+		{
+			MarkupContainer childContainer = (MarkupContainer)component;
+			childContainer.queue(queue);
+		}
+	}
 
 	/**
 	 * @param component
@@ -1661,24 +1682,8 @@ public abstract class MarkupContainer extends Component implements Iterable<Comp
 			{
 				Component component = (Component)child;
 				component.detach();
-
-				// We need to keep InlineEnclosures for Ajax request handling.
-				// TODO this is really ugly. Feature request for 1.5: change auto-component that
-				// they don't need to be removed anymore.
-				if (!(component instanceof InlineEnclosure) && component.isAuto())
-				{
-					children_remove(i);
-				}
 			}
 		}
-
-		if (children instanceof ChildList)
-		{
-			ChildList lst = (ChildList)children;
-			Object[] tmp = new Object[lst.size];
-			System.arraycopy(lst.childs, 0, tmp, 0, lst.size);
-			children = tmp;
-		}
 	}
 
 	/**
@@ -1986,7 +1991,35 @@ public abstract class MarkupContainer extends Component implements Iterable<Comp
 			queue = new ComponentQueue();
 		}
 		queue.add(components);
-
+		
+		return innerQueue();
+	}
+	
+	/**
+	 * Queues components over the current container and using the given component queue.
+	 * 
+	 * @param queue
+	 *			the component queue to use. 
+	 * @return
+	 */
+	protected MarkupContainer queue(ComponentQueue queue)
+	{
+		ComponentQueue currentQueue = this.queue;
+		this.queue = queue;
+		 
+		MarkupContainer markupContainer = innerQueue();
+		this.queue = currentQueue;
+		
+		return markupContainer;
+	}
+	
+	/**
+	 * Runs the actual queuing process. 
+	 * 
+	 * @return
+	 */
+	protected MarkupContainer innerQueue()
+	{
 		MarkupContainer region = null;
 		Page page = null;
 
diff --git a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java
index 79edb52a66..5e66d954ed 100644
--- a/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java
+++ b/wicket-core/src/main/java/org/apache/wicket/markup/parser/filter/RelativePathPrefixHandler.java
@@ -17,6 +17,7 @@
 package org.apache.wicket.markup.parser.filter;
 
 import java.text.ParseException;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.wicket.Component;
 import org.apache.wicket.MarkupContainer;
@@ -99,10 +100,9 @@ public final class RelativePathPrefixHandler extends AbstractMarkupFilter
 	/** 
 	 * https://issues.apache.org/jira/browse/WICKET-5724
 	 * 
-	 * Says if we are inside an head tag or wicket:head tag. 
-	 * 
+	 * Unique index to generate new tag ids.
 	 * */
-	private boolean insideHead;
+	private final AtomicInteger componentIndex = new AtomicInteger();
 
 	/**
 	 * Constructor for the IComponentResolver role.
@@ -128,21 +128,9 @@ public final class RelativePathPrefixHandler extends AbstractMarkupFilter
 	{
 		if (tag.isClose())
 		{
-			if (isHeadTag(tag))	
-			{
-				//outside head tag
-				insideHead = false;
-			}
-			
 			return tag;
 		}
 
-		if (isHeadTag(tag))	
-		{
-			//inside head tag
-			insideHead = true;
-		}
-
 		String wicketIdAttr = getWicketNamespace() + ":" + "id";
 
 		// Don't touch any wicket:id component and any auto-components
@@ -162,60 +150,31 @@ public final class RelativePathPrefixHandler extends AbstractMarkupFilter
 			{
 				if (tag.getId() == null)
 				{
-					tag.setId(getWicketRelativePathPrefix(null));
+					tag.setId(getWicketRelativePathPrefix(null) 
+						+ componentIndex.getAndIncrement());
 					tag.setAutoComponentTag(true);
-					
-					/**
-					 * https://issues.apache.org/jira/browse/WICKET-5724
-					 * Transparent component inside page body must allow 
-					 * queued children components.
-					 */
-					if(!insideHead)
-					{
-						tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory()
-						{
-							@Override
-							public Component newComponent(MarkupContainer container, ComponentTag tag)
-							{
-								String id = tag.getId() + container.getPage().getAutoIndex();
-								tag.setId(id);
-	
-								return new TransparentWebMarkupContainer(id);
-							}
-						});	
-					}
 				}
+
 				tag.addBehavior(RELATIVE_PATH_BEHAVIOR);
 				tag.setModified(true);
+				
 				break;
 			}
 		}
 
 		return tag;
 	}
-	
-	private boolean isHeadTag(ComponentTag tag)
-	{
-		if (HtmlHeaderSectionHandler.HEAD.equalsIgnoreCase(tag.getName()))
-		{
-			return true;
-		}	
 		
-		return false;
-	}
-	
 	@Override
 	public Component resolve(final MarkupContainer container, final MarkupStream markupStream,
 		final ComponentTag tag)
 	{
-		if ((tag != null) && (tag.getId().equals(getWicketRelativePathPrefix(markupStream))))
+		if ((tag != null) && (tag.getId().startsWith(getWicketRelativePathPrefix(markupStream))))
 		{
-			String id = tag.getId() + container.getPage().getAutoIndex();
-
 			// we do not want to mess with the hierarchy, so the container has to be
 			// transparent as it may have wicket components inside. for example a raw anchor tag
 			// that contains a label.
-			return new TransparentWebMarkupContainer(id);
+			return new TransparentWebMarkupContainer(tag.getId());
 		}
 		return null;
 	}
