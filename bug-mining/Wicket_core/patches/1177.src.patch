diff --git a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequestImpl.java b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequestImpl.java
index 3609b3b915..46aafb0d11 100644
--- a/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequestImpl.java
+++ b/wicket-core/src/main/java/org/apache/wicket/protocol/http/servlet/MultipartServletWebRequestImpl.java
@@ -16,28 +16,37 @@
  */
 package org.apache.wicket.protocol.http.servlet;
 
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.Part;
 
 import org.apache.commons.fileupload.FileItem;
 import org.apache.commons.fileupload.FileItemFactory;
+import org.apache.commons.fileupload.FileItemHeaders;
 import org.apache.commons.fileupload.FileUploadBase;
 import org.apache.commons.fileupload.FileUploadException;
 import org.apache.commons.fileupload.disk.DiskFileItemFactory;
 import org.apache.commons.fileupload.servlet.ServletFileUpload;
 import org.apache.commons.fileupload.servlet.ServletRequestContext;
+import org.apache.commons.fileupload.util.FileItemHeadersImpl;
 import org.apache.commons.io.FileCleaningTracker;
 import org.apache.wicket.Application;
 import org.apache.wicket.WicketRuntimeException;
 import org.apache.wicket.util.file.FileCleanerTrackerAdapter;
 import org.apache.wicket.util.file.IFileCleaner;
+import org.apache.wicket.util.io.ByteArrayOutputStream;
+import org.apache.wicket.util.io.Streams;
 import org.apache.wicket.util.lang.Args;
 import org.apache.wicket.util.lang.Bytes;
 import org.apache.wicket.util.string.StringValue;
@@ -162,7 +171,7 @@ public class MultipartServletWebRequestImpl extends MultipartServletWebRequest
 
 		FileUploadBase fileUpload = newFileUpload(encoding);
 
-		final List<FileItem> items;
+		List<FileItem> items;
 
 		if (wantUploadProgressUpdates())
 		{
@@ -189,6 +198,10 @@ public class MultipartServletWebRequestImpl extends MultipartServletWebRequest
 		else
 		{
 			items = fileUpload.parseRequest(new ServletRequestContext(request));
+			if (items.isEmpty())
+			{
+				items = readParts(request);
+			}
 		}
 
 		// Loop through items
@@ -232,6 +245,27 @@ public class MultipartServletWebRequestImpl extends MultipartServletWebRequest
 		}
 	}
 
+	private List<FileItem> readParts(HttpServletRequest request) throws FileUploadException
+	{
+		List<FileItem> itemsFromParts = new ArrayList<>();
+		try
+		{
+			Collection<Part> parts = request.getParts();
+			if (parts != null)
+			{
+				for (Part part : parts)
+				{
+					FileItem fileItem = new PartFileItem(part);
+					itemsFromParts.add(fileItem);
+				}
+			}
+		} catch (IOException | ServletException e)
+		{
+			throw new FileUploadException("", e);
+		}
+		return itemsFromParts;
+	}
+
 	/**
 	 * Factory method for creating new instances of FileUploadBase
 	 *
@@ -530,4 +564,155 @@ public class MultipartServletWebRequestImpl extends MultipartServletWebRequest
 		Args.notNull(upload, "upload");
 		req.getSession().removeAttribute(getSessionKey(upload));
 	}
+
+	private static class PartFileItem implements FileItem
+	{
+		private final Part part;
+
+		private PartFileItem(Part part) {
+			this.part = part;
+		}
+
+		@Override
+		public InputStream getInputStream() throws IOException
+		{
+			return part.getInputStream();
+		}
+
+		@Override
+		public String getContentType()
+		{
+			return part.getContentType();
+		}
+
+		@Override
+		public String getName()
+		{
+			return getFileName(part);
+		}
+
+		private String getFileName(Part part) {
+			for (String cd : part.getHeader("content-disposition").split(";")) {
+				if (cd.trim().startsWith("filename")) {
+					return cd.substring(cd.indexOf('=') + 1).trim()
+							.replace("\"", "");
+				}
+			}
+			return null;
+		}
+
+		@Override
+		public boolean isInMemory()
+		{
+			return true;
+		}
+
+		@Override
+		public long getSize()
+		{
+			return part.getSize();
+		}
+
+		@Override
+		public byte[] get()
+		{
+			try
+			{
+				ByteArrayOutputStream baos = new ByteArrayOutputStream();
+				Streams.copy(getInputStream() ,baos);
+				return baos.toByteArray();
+			} catch (IOException iox)
+			{
+				throw new WicketRuntimeException("Could not read upload's part input stream", iox);
+			}
+		}
+
+		@Override
+		public String getString(String encoding) throws UnsupportedEncodingException
+		{
+			byte[] bytes = get();
+			return new String(bytes, encoding);
+		}
+
+		@Override
+		public String getString()
+		{
+			try
+			{
+				return getString("UTF-8");
+			} catch (UnsupportedEncodingException uex)
+			{
+				throw new WicketRuntimeException("UTF-8 must be supported", uex);
+			}
+		}
+
+		@Override
+		public void write(File file) throws Exception
+		{
+			part.write(file.getName());
+		}
+
+		@Override
+		public void delete()
+		{
+			try
+			{
+				part.delete();
+			} catch (IOException iox)
+			{
+				throw new WicketRuntimeException("A problem occurred while deleting an upload part", iox);
+			}
+		}
+
+		@Override
+		public String getFieldName()
+		{
+			return part.getName();
+		}
+
+		@Override
+		public void setFieldName(String name)
+		{
+			throw new UnsupportedOperationException("setFieldName");
+		}
+
+		@Override
+		public boolean isFormField()
+		{
+			return false;
+		}
+
+		@Override
+		public void setFormField(boolean state)
+		{
+			throw new UnsupportedOperationException("setFormField");
+		}
+
+		@Override
+		public OutputStream getOutputStream() throws IOException
+		{
+			throw new UnsupportedOperationException("getOutputStream");
+		}
+
+		@Override
+		public FileItemHeaders getHeaders()
+		{
+			FileItemHeadersImpl fileItemHeaders = new FileItemHeadersImpl();
+			for (String headerName : part.getHeaderNames())
+			{
+				Collection<String> headerValues = part.getHeaders(headerName);
+				for (String headerValue : headerValues)
+				{
+					fileItemHeaders.addHeader(headerName, headerValue);
+				}
+			}
+			return fileItemHeaders;
+		}
+
+		@Override
+		public void setHeaders(FileItemHeaders headers)
+		{
+			throw new UnsupportedOperationException("setHeaders");
+		}
+	}
 }
