diff --git a/wicket-core/src/main/java/org/apache/wicket/pageStore/AbstractPersistentPageStore.java b/wicket-core/src/main/java/org/apache/wicket/pageStore/AbstractPersistentPageStore.java
index ad294be7a1..0a4cd5dfaf 100644
--- a/wicket-core/src/main/java/org/apache/wicket/pageStore/AbstractPersistentPageStore.java
+++ b/wicket-core/src/main/java/org/apache/wicket/pageStore/AbstractPersistentPageStore.java
@@ -48,6 +48,14 @@ public abstract class AbstractPersistentPageStore implements IPageStore
 	 */
 	private static final ConcurrentMap<String, AbstractPersistentPageStore> STORES = new ConcurrentHashMap<>();
 
+	private static final ThreadLocal<Boolean> gettingSessionAttribute = new ThreadLocal<>()
+	{
+		protected Boolean initialValue()
+		{
+			return Boolean.FALSE;
+		}
+	};
+
 	private final String storeKey;
 
 	protected AbstractPersistentPageStore(String applicationName)
@@ -144,17 +152,22 @@ public abstract class AbstractPersistentPageStore implements IPageStore
 	 */
 	private String getSessionIdentifier(IPageContext context, boolean create)
 	{
-		String key = KEY_PREFIX + Classes.simpleName(getClass());
-		
-		SessionAttribute attribute = context.getSessionAttribute(key, create ? () -> {
-			return new SessionAttribute(storeKey, createSessionIdentifier(context));
-		} : null);
-		
-		if (attribute == null)
-		{
-			return null;
+		gettingSessionAttribute.set(Boolean.TRUE);
+		try {
+			String key = KEY_PREFIX + Classes.simpleName(getClass());
+			
+			SessionAttribute attribute = context.getSessionAttribute(key, create ? () -> {
+				return new SessionAttribute(storeKey, createSessionIdentifier(context));
+			} : null);
+			
+			if (attribute == null)
+			{
+				return null;
+			}
+			return attribute.sessionIdentifier;
+		} finally {
+			gettingSessionAttribute.set(Boolean.FALSE);
 		}
-		return attribute.sessionIdentifier;
 	}
 
 	/**
@@ -207,7 +220,10 @@ public abstract class AbstractPersistentPageStore implements IPageStore
 			}
 			else
 			{
-				store.removeAllPersistedPages(sessionIdentifier);
+				if (Boolean.FALSE.equals(gettingSessionAttribute.get()))
+				{
+					store.removeAllPersistedPages(sessionIdentifier);
+				}		
 			}
 		}
 	}
diff --git a/wicket-core/src/test/java/org/apache/wicket/pageStore/AbstractPersistentPageStoreTest.java b/wicket-core/src/test/java/org/apache/wicket/pageStore/AbstractPersistentPageStoreTest.java
new file mode 100644
index 0000000000..e74c9ecb18
--- /dev/null
+++ b/wicket-core/src/test/java/org/apache/wicket/pageStore/AbstractPersistentPageStoreTest.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.pageStore;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.io.Serializable;
+import java.util.function.Supplier;
+
+import jakarta.servlet.http.HttpSessionBindingListener;
+
+import org.apache.wicket.mock.MockPageContext;
+import org.apache.wicket.page.IManageablePage;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Test vor {@link AbstractPersistentPageStore}.
+ */
+class AbstractPersistentPageStoreTest
+{
+
+	/**
+	 * WICKET-6990
+	 */
+	@Test
+	void rebindingAttributeDoesNotRemoveAllPages()
+	{
+		var store = new AbstractPersistentPageStore("test")
+		{
+			
+			@Override
+			public boolean supportsVersioning()
+			{
+				return false;
+			}
+			
+			@Override
+			protected void removePersistedPage(String sessionIdentifier, IManageablePage page)
+			{
+			}
+			
+			@Override
+			protected void removeAllPersistedPages(String sessionIdentifier)
+			{
+				fail("unexpected removal of all pages while rebinding attribute");
+			}
+			
+			@Override
+			protected IManageablePage getPersistedPage(String sessionIdentifier, int id)
+			{
+				return null;
+			}
+			
+			@Override
+			protected void addPersistedPage(String sessionIdentifier, IManageablePage page)
+			{
+				
+			}
+		};
+		
+		var context = new MockPageContext() {
+			@Override
+			public <T extends Serializable> T getSessionAttribute(String key,
+				Supplier<T> defaultValue)
+			{
+				T attribute = super.getSessionAttribute(key, defaultValue);
+				
+				// simulate container unbinding when attribute is set again
+				((HttpSessionBindingListener)attribute).valueUnbound(null);
+				
+				return attribute;
+			}
+		};
+		assertTrue(store.canBeAsynchronous(context));
+		
+	}
+
+}
