diff --git a/wicket-core/src/main/java/org/apache/wicket/Application.java b/wicket-core/src/main/java/org/apache/wicket/Application.java
index 7f42216400..54c709de91 100644
--- a/wicket-core/src/main/java/org/apache/wicket/Application.java
+++ b/wicket-core/src/main/java/org/apache/wicket/Application.java
@@ -55,7 +55,6 @@ import org.apache.wicket.markup.resolver.WicketMessageResolver;
 import org.apache.wicket.page.DefaultPageManagerContext;
 import org.apache.wicket.page.IPageManager;
 import org.apache.wicket.page.IPageManagerContext;
-import org.apache.wicket.page.PageAccessSynchronizer;
 import org.apache.wicket.pageStore.IDataStore;
 import org.apache.wicket.pageStore.IPageStore;
 import org.apache.wicket.protocol.http.DummyRequestLogger;
@@ -192,9 +191,6 @@ public abstract class Application implements UnboundListener, IEventSink
 	/** page renderer provider */
 	private IPageRendererProvider pageRendererProvider;
 
-	/** */
-	private PageAccessSynchronizer pageAccessSynchronizer;
-
 	/** request cycle provider */
 	private IRequestCycleProvider requestCycleProvider;
 
@@ -706,8 +702,6 @@ public abstract class Application implements UnboundListener, IEventSink
 
 		pageFactory = newPageFactory();
 
-		pageAccessSynchronizer = new PageAccessSynchronizer(getRequestCycleSettings().getTimeout());
-
 		requestCycleProvider = new DefaultRequestCycleProvider();
 		exceptionMapperProvider = new DefaultExceptionMapperProvider();
 	}
@@ -1331,7 +1325,7 @@ public abstract class Application implements UnboundListener, IEventSink
 	 * 
 	 * @return the page manager
 	 */
-	public final IPageManager getPageManager()
+	final IPageManager getPageManager()
 	{
 		if (pageManager == null)
 		{
@@ -1339,7 +1333,7 @@ public abstract class Application implements UnboundListener, IEventSink
 			{
 				if (pageManager == null)
 				{
-					pageManager = pageAccessSynchronizer.adapt(pageManagerProvider.get(getPageManagerContext()));
+					pageManager = pageManagerProvider.get(getPageManagerContext());
 				}
 			}
 		}
@@ -1559,7 +1553,7 @@ public abstract class Application implements UnboundListener, IEventSink
 			@Override
 			public void onDetach(final RequestCycle requestCycle)
 			{
-				getPageManager().commitRequest();
+				Session.get().getPageManager().commitRequest();
 			}
 		});
 		requestCycle.getListeners().add(requestCycleListeners);
diff --git a/wicket-core/src/main/java/org/apache/wicket/Session.java b/wicket-core/src/main/java/org/apache/wicket/Session.java
index 02403d68f4..089430546d 100644
--- a/wicket-core/src/main/java/org/apache/wicket/Session.java
+++ b/wicket-core/src/main/java/org/apache/wicket/Session.java
@@ -31,12 +31,16 @@ import org.apache.wicket.event.IEventSink;
 import org.apache.wicket.feedback.FeedbackMessage;
 import org.apache.wicket.feedback.FeedbackMessages;
 import org.apache.wicket.page.IPageManager;
+import org.apache.wicket.page.PageAccessSynchronizer;
 import org.apache.wicket.request.ClientInfo;
 import org.apache.wicket.request.Request;
 import org.apache.wicket.request.cycle.RequestCycle;
 import org.apache.wicket.session.ISessionStore;
+import org.apache.wicket.util.IProvider;
+import org.apache.wicket.util.LazyInitializer;
 import org.apache.wicket.util.lang.Objects;
 import org.apache.wicket.util.lang.WicketObjects;
+import org.apache.wicket.util.time.Duration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -124,6 +128,8 @@ public abstract class Session implements IClusterable, IEventSink
 	/** a sequence used for generating page IDs */
 	private int pageId = 0;
 
+	/** synchronize page's access by session */
+	private final IProvider<PageAccessSynchronizer> pageAccessSynchronizer;
 
 	/**
 	 * Checks if the <code>Session</code> threadlocal is set in this thread
@@ -212,6 +218,8 @@ public abstract class Session implements IClusterable, IEventSink
 			throw new IllegalStateException(
 				"Request#getLocale() cannot return null, request has to have a locale set on it");
 		}
+
+		pageAccessSynchronizer = new PageAccessSynchronizerProvider();
 	}
 
 	/**
@@ -831,13 +839,37 @@ public abstract class Session implements IClusterable, IEventSink
 	 * 
 	 * @return {@link IPageManager} instance.
 	 */
-	public IPageManager getPageManager()
+	public final IPageManager getPageManager()
 	{
-		return getApplication().getPageManager();
+		IPageManager pageManager = Application.get().getPageManager();
+		return pageAccessSynchronizer.get().adapt(pageManager);
 	}
 
 	/** {@inheritDoc} */
 	public void onEvent(IEvent<?> event)
 	{
 	}
+
+	private static final class PageAccessSynchronizerProvider extends
+		LazyInitializer<PageAccessSynchronizer>
+	{
+		@Override
+		protected PageAccessSynchronizer createInstance()
+		{
+			final Duration timeout;
+			if (Application.exists())
+			{
+				timeout = Application.get().getRequestCycleSettings().getTimeout();
+			}
+			else
+			{
+				timeout = Duration.minutes(1);
+				log.warn(
+					"PageAccessSynchronizer created outside of application thread, using default timeout: {}",
+					timeout);
+			}
+			return new PageAccessSynchronizer(timeout);
+		}
+	}
+
 }
diff --git a/wicket-core/src/main/java/org/apache/wicket/page/PageAccessSynchronizer.java b/wicket-core/src/main/java/org/apache/wicket/page/PageAccessSynchronizer.java
index 7345275232..af6db00d43 100644
--- a/wicket-core/src/main/java/org/apache/wicket/page/PageAccessSynchronizer.java
+++ b/wicket-core/src/main/java/org/apache/wicket/page/PageAccessSynchronizer.java
@@ -16,12 +16,13 @@
  */
 package org.apache.wicket.page;
 
+import java.io.Serializable;
 import java.util.Iterator;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 import org.apache.wicket.util.IProvider;
-import org.apache.wicket.util.ValueProvider;
-import org.apache.wicket.util.lang.Args;
+import org.apache.wicket.util.LazyInitializer;
 import org.apache.wicket.util.time.Duration;
 import org.apache.wicket.util.time.Time;
 import org.slf4j.Logger;
@@ -32,18 +33,22 @@ import org.slf4j.LoggerFactory;
  * 
  * @author Igor Vaynberg (ivaynberg)
  */
-public class PageAccessSynchronizer
+public class PageAccessSynchronizer implements Serializable
 {
 	private static final Logger logger = LoggerFactory.getLogger(PageAccessSynchronizer.class);
 
 	/** map of which pages are owned by which threads */
-	private final ConcurrentHashMap<Integer, PageLock> locks = new ConcurrentHashMap<Integer, PageLock>();
-
-	/** used to synchronize various code points */
-	private final Object semaphore = new Object();
+	private IProvider<ConcurrentMap<Integer, PageLock>> locks = new LazyInitializer<ConcurrentMap<Integer, PageLock>>()
+	{
+		@Override
+		protected ConcurrentMap<Integer, PageLock> createInstance()
+		{
+			return new ConcurrentHashMap<Integer, PageLock>();
+		}
+	};
 
 	/** timeout value for acquiring a page lock */
-	private final IProvider<Duration> timeout;
+	private final Duration timeout;
 
 	/**
 	 * Constructor
@@ -53,18 +58,6 @@ public class PageAccessSynchronizer
 	 */
 	public PageAccessSynchronizer(Duration timeout)
 	{
-		this(ValueProvider.of(timeout));
-	}
-
-	/**
-	 * Constructor
-	 * 
-	 * @param timeout
-	 *            timeout value for acquiring a page lock
-	 */
-	public PageAccessSynchronizer(IProvider<Duration> timeout)
-	{
-		Args.notNull(timeout, "timeout");
 		this.timeout = timeout;
 	}
 
@@ -83,19 +76,23 @@ public class PageAccessSynchronizer
 	 */
 	public void lockPage(int pageId) throws CouldNotLockPageException
 	{
-		final Duration timeout = this.timeout.get();
 		final Thread thread = Thread.currentThread();
 		final PageLock lock = new PageLock(pageId, thread);
 		final Time start = Time.now();
 
 		boolean locked = false;
 
+		final boolean isDebugEnabled = logger.isDebugEnabled();
+
 		while (!locked && start.elapsedSince().lessThan(timeout))
 		{
-			logger.debug("'{}' attempting to acquire lock to page with id '{}'", thread.getName(),
-				pageId);
+			if (isDebugEnabled)
+			{
+				logger.debug("'{}' attempting to acquire lock to page with id '{}'",
+					thread.getName(), pageId);
+			}
 
-			PageLock previous = locks.putIfAbsent(pageId, lock);
+			PageLock previous = locks.get().putIfAbsent(pageId, lock);
 			if (previous == null || previous.getThread() == thread)
 			{
 				// first thread to acquire lock or lock is already owned by this thread
@@ -107,16 +104,16 @@ public class PageAccessSynchronizer
 				long remaining = remaining(start, timeout);
 				if (remaining > 0)
 				{
-					synchronized (semaphore)
+					synchronized (previous)
 					{
-						if (logger.isDebugEnabled())
+						if (isDebugEnabled)
 						{
 							logger.debug("{} waiting for lock to page {} for {}", new Object[] {
 									thread.getName(), pageId, Duration.milliseconds(remaining) });
 						}
 						try
 						{
-							semaphore.wait(remaining);
+							previous.wait(remaining);
 						}
 						catch (InterruptedException e)
 						{
@@ -129,12 +126,19 @@ public class PageAccessSynchronizer
 		}
 		if (locked)
 		{
-			logger.debug("{} acquired lock to page {}", thread.getName(), pageId);
+			if (isDebugEnabled)
+			{
+				logger.debug("{} acquired lock to page {}", thread.getName(), pageId);
+			}
 		}
 		else
 		{
-			logger.warn("{} failed to acquire lock to page {}, attempted for {} out of allowed {}",
-				new Object[] { thread.getName(), pageId, start.elapsedSince(), timeout });
+			if (logger.isWarnEnabled())
+			{
+				logger.warn(
+					"{} failed to acquire lock to page {}, attempted for {} out of allowed {}",
+					new Object[] { thread.getName(), pageId, start.elapsedSince(), timeout });
+			}
 			throw new CouldNotLockPageException(pageId, thread.getName(), timeout);
 		}
 	}
@@ -145,9 +149,10 @@ public class PageAccessSynchronizer
 	public void unlockAllPages()
 	{
 		final Thread thread = Thread.currentThread();
-		final Iterator<PageLock> locks = this.locks.values().iterator();
+		final Iterator<PageLock> locks = this.locks.get().values().iterator();
+
+		final boolean isDebugEnabled = logger.isDebugEnabled();
 
-		boolean changed = false;
 		while (locks.hasNext())
 		{
 			// remove all locks held by this thread
@@ -155,18 +160,19 @@ public class PageAccessSynchronizer
 			if (lock.getThread() == thread)
 			{
 				locks.remove();
-				logger.debug("{} released lock to page {}", thread.getName(), lock.getPageId());
-				changed = true;
-			}
-		}
-
-		if (changed)
-		{
-			// if any locks were removed notify threads waiting for a lock
-			synchronized (semaphore)
-			{
-				logger.debug("{} notifying blocked threads", thread.getName());
-				semaphore.notifyAll();
+				if (isDebugEnabled)
+				{
+					logger.debug("{} released lock to page {}", thread.getName(), lock.getPageId());
+				}
+				// if any locks were removed notify threads waiting for a lock
+				synchronized (lock)
+				{
+					if (isDebugEnabled)
+					{
+						logger.debug("{} notifying blocked threads", thread.getName());
+					}
+					lock.notifyAll();
+				}
 			}
 		}
 	}
@@ -250,7 +256,5 @@ public class PageAccessSynchronizer
 		{
 			return thread;
 		}
-
-
 	}
 }
diff --git a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java
index d7b93488d9..fff53d81cb 100644
--- a/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java
+++ b/wicket-core/src/main/java/org/apache/wicket/request/handler/PageProvider.java
@@ -17,6 +17,7 @@
 package org.apache.wicket.request.handler;
 
 import org.apache.wicket.Application;
+import org.apache.wicket.Session;
 import org.apache.wicket.page.IPageManager;
 import org.apache.wicket.protocol.http.PageExpiredException;
 import org.apache.wicket.request.IRequestHandler;
@@ -168,12 +169,15 @@ public class PageProvider implements IPageProvider
 
 	/**
 	 * Mark the error page as candidate for storing
+	 * 
+	 * @param page
+	 *            the page to store
 	 */
 	private void touchPageInstance(IRequestablePage page)
 	{
-		if (Application.exists())
+		if (Session.exists())
 		{
-			Application.get().getPageManager().touchPage(page);
+			Session.get().getPageManager().touchPage(page);
 		}
 	}
 
diff --git a/wicket-core/src/test/java/org/apache/wicket/pageStore/PageAccessSynchronizerTest.java b/wicket-core/src/test/java/org/apache/wicket/pageStore/PageAccessSynchronizerTest.java
index b9f5dace0a..afee56459b 100644
--- a/wicket-core/src/test/java/org/apache/wicket/pageStore/PageAccessSynchronizerTest.java
+++ b/wicket-core/src/test/java/org/apache/wicket/pageStore/PageAccessSynchronizerTest.java
@@ -24,6 +24,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.wicket.page.CouldNotLockPageException;
 import org.apache.wicket.page.PageAccessSynchronizer;
+import org.apache.wicket.util.lang.WicketObjects;
 import org.apache.wicket.util.time.Duration;
 import org.apache.wicket.util.time.Time;
 import org.junit.Rule;
@@ -259,4 +260,44 @@ public class PageAccessSynchronizerTest
 	{
 		runContentionTest(10, 20, Duration.seconds(10));
 	}
+
+	@Test
+	public void testSerialization() throws Exception
+	{
+		// a simple worker that acquires a lock on page 5
+		class Locker extends Thread
+		{
+			private final PageAccessSynchronizer sync;
+
+			public Locker(PageAccessSynchronizer sync)
+			{
+				this.sync = sync;
+			}
+
+			@Override
+			public void run()
+			{
+				sync.lockPage(5);
+			}
+		}
+
+		// set up a synchronizer and lock page 5 with locker1
+		final Duration timeout = Duration.seconds(30);
+		final PageAccessSynchronizer sync = new PageAccessSynchronizer(timeout);
+		Locker locker1 = new Locker(sync);
+
+		final long start = System.currentTimeMillis();
+		locker1.run();
+
+		// make sure we can serialize the synchronizer
+
+		final PageAccessSynchronizer sync2 = (PageAccessSynchronizer)WicketObjects.cloneObject(sync);
+		assertTrue(sync != sync2);
+
+		// make sure the clone does not retain locks by attempting to lock page locked by locker1 in
+		// locker2
+		Locker locker2 = new Locker(sync2);
+		locker2.run();
+		assertTrue(Duration.milliseconds(System.currentTimeMillis() - start).lessThan(timeout));
+	}
 }
diff --git a/wicket-core/src/test/java/org/apache/wicket/versioning/PageVersioningTest.java b/wicket-core/src/test/java/org/apache/wicket/versioning/PageVersioningTest.java
index ec1f0d3795..bdd528a574 100644
--- a/wicket-core/src/test/java/org/apache/wicket/versioning/PageVersioningTest.java
+++ b/wicket-core/src/test/java/org/apache/wicket/versioning/PageVersioningTest.java
@@ -131,7 +131,7 @@ public class PageVersioningTest
 	 */
 	private void checkPageVersionsAreStored(Page versioningPage)
 	{
-		IPageManager pageManager = wicketTester.getApplication().getPageManager();
+		IPageManager pageManager = wicketTester.getSession().getPageManager();
 
 		int lastPageId = versioningPage.getPageId();
 		while (lastPageId >= 0)
