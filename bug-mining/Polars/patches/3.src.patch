diff --git a/crates/polars-expr/src/expressions/binary.rs b/crates/polars-expr/src/expressions/binary.rs
index 0b6eb77000..68bdd461eb 100644
--- a/crates/polars-expr/src/expressions/binary.rs
+++ b/crates/polars-expr/src/expressions/binary.rs
@@ -82,6 +82,9 @@ pub fn apply_operator(left: &Column, right: &Column, op: Operator) -> PolarsResu
             _ if right.dtype().is_array() => left / right,
             List(_) => left / right,
             _ if right.dtype().is_list() => left / right,
+            _ if left.dtype().is_string() || right.dtype().is_string() => {
+                polars_bail!(InvalidOperation: "cannot divide using strings")
+            },
             _ => {
                 if right.dtype().is_temporal() {
                     return left / right;
diff --git a/crates/polars-plan/src/plans/aexpr/schema.rs b/crates/polars-plan/src/plans/aexpr/schema.rs
index 771cb474f9..0e6fb81857 100644
--- a/crates/polars-plan/src/plans/aexpr/schema.rs
+++ b/crates/polars-plan/src/plans/aexpr/schema.rs
@@ -445,7 +445,7 @@ fn get_arithmetic_field(
                 (_, Datetime(_, _)) | (Datetime(_, _), _) => {
                     polars_bail!(InvalidOperation: "{} not allowed on {} and {}", op, left_field.dtype, right_type)
                 },
-                (Date, Date) => Duration(TimeUnit::Milliseconds),
+                (Date, Date) => Duration(TimeUnit::Microseconds),
                 (_, Date) | (Date, _) => {
                     polars_bail!(InvalidOperation: "{} not allowed on {} and {}", op, left_field.dtype, right_type)
                 },
@@ -697,6 +697,9 @@ fn get_truediv_dtype(left_dtype: &DataType, right_dtype: &DataType) -> PolarsRes
             let dtype = get_truediv_dtype(list_dtype.leaf_dtype(), other_dtype.leaf_dtype())?;
             list_dtype.cast_leaf(dtype)
         },
+        (Boolean, Float32) => Float32,
+        (Boolean, b) if b.is_numeric() => Float64,
+        (Boolean, Boolean) => Float64,
         #[cfg(feature = "dtype-u8")]
         (Float32, UInt8 | Int8) => Float32,
         #[cfg(feature = "dtype-u16")]
@@ -704,6 +707,9 @@ fn get_truediv_dtype(left_dtype: &DataType, right_dtype: &DataType) -> PolarsRes
         (Float32, other) if other.is_integer() => Float64,
         (Float32, Float64) => Float64,
         (Float32, _) => Float32,
+        (String, _) | (_, String) => polars_bail!(
+            InvalidOperation: "division with 'String' datatypes is not allowed"
+        ),
         #[cfg(feature = "dtype-decimal")]
         (Decimal(_, Some(scale_left)), Decimal(_, _)) => {
             let scale = _get_decimal_scale_div(*scale_left);
diff --git a/py-polars/tests/unit/test_schema.py b/py-polars/tests/unit/test_schema.py
index b70ba87295..5e75665688 100644
--- a/py-polars/tests/unit/test_schema.py
+++ b/py-polars/tests/unit/test_schema.py
@@ -5,8 +5,14 @@ from typing import Any
 import pytest
 
 import polars as pl
+from polars.datatypes.group import NUMERIC_DTYPES, TEMPORAL_DTYPES
 from polars.testing.asserts.frame import assert_frame_equal
 
+# Used by test_lazy_collect_schema_matches_computed_schema
+_TEST_COLLECT_SCHEMA_M_DTYPES = (
+    {pl.Boolean, pl.String} | NUMERIC_DTYPES | TEMPORAL_DTYPES
+) - {pl.Decimal}
+
 
 def test_schema() -> None:
     s = pl.Schema({"foo": pl.Int8(), "bar": pl.String()})
@@ -137,6 +143,62 @@ def test_schema_in_map_elements_returns_scalar() -> None:
     assert q.collect().schema == schema
 
 
+@pytest.mark.slow
+@pytest.mark.parametrize(
+    "expr",
+    [
+        # TODO: Add more (bitwise) operators once their types are resolved correctly
+        pl.col("col0") > pl.col("col1"),
+        pl.col("col0") >= pl.col("col1"),
+        pl.col("col0") < pl.col("col1"),
+        pl.col("col0") <= pl.col("col1"),
+        pl.col("col0") == pl.col("col1"),
+        pl.col("col0") != pl.col("col1"),
+        pl.col("col0") + pl.col("col1"),
+        pl.col("col0") - pl.col("col1"),
+        pl.col("col0") * pl.col("col1"),
+        pl.col("col0") / pl.col("col1"),
+        pl.col("col0").truediv(pl.col("col1")),
+        pl.col("col0") // pl.col("col1"),
+        pl.col("col0") % pl.col("col1"),
+    ],
+)
+@pytest.mark.parametrize("dtype1", _TEST_COLLECT_SCHEMA_M_DTYPES)
+@pytest.mark.parametrize("dtype2", _TEST_COLLECT_SCHEMA_M_DTYPES)
+def test_lazy_collect_schema_matches_computed_schema(
+    expr: pl.Expr, dtype1: pl.DataType, dtype2: pl.DataType
+) -> None:
+    df = pl.DataFrame(
+        {
+            "col0": [None],
+            "col1": [None],
+        },
+        schema={
+            "col0": dtype1,
+            "col1": dtype2,
+        },
+    )
+    lazy_df = df.lazy().select(expr)
+
+    expected_schema = None
+    try:
+        expected_schema = lazy_df.collect().schema
+    except (
+        # Applying the operator to these dtypes will result in an error,
+        # so they their output dtype is undefined
+        pl.exceptions.InvalidOperationError,
+        pl.exceptions.SchemaError,
+        pl.exceptions.ComputeError,
+    ):
+        return
+
+    actual_schema = lazy_df.collect_schema()
+    assert actual_schema == expected_schema, (
+        f"{expr} on {df.dtypes} results in {actual_schema} instead of {expected_schema}\n"
+        f"result of computation is:\n{lazy_df.collect()}\n"
+    )
+
+
 def test_ir_cache_unique_18198() -> None:
     lf = pl.LazyFrame({"a": [1]})
     lf.collect_schema()
@@ -370,6 +432,27 @@ def test_scalar_agg_schema_20044() -> None:
     ).schema == pl.Schema([("c", pl.String), ("d", pl.Float64)])
 
 
+@pytest.mark.parametrize(
+    "df",
+    [
+        pl.DataFrame({"a": [None, True, False], "b": 3 * [128]}),
+        pl.DataFrame(
+            {"a": [[None, True, False]], "b": [3 * [128]]},
+            schema={"a": pl.Array(pl.Boolean, 3), "b": pl.Array(pl.Int64, 3)},
+        ),
+        pl.DataFrame(
+            {"a": [[None, True, False]], "b": [3 * [128]]},
+            schema={"a": pl.List(pl.Boolean), "b": pl.List(pl.Int64)},
+        ),
+    ],
+)
+def test_div_collect_schema_matches_23993(df: pl.DataFrame) -> None:
+    q = df.lazy().select(pl.col("a") / pl.col("b"))
+    expected = q.collect().schema
+    actual = q.collect_schema()
+    assert actual == expected
+
+
 def test_mean_on_invalid_type_24008() -> None:
     df = pl.DataFrame({"s": ["bob", "foo"]})
     q = df.lazy().select(pl.col("s").mean())
