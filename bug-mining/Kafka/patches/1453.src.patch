diff --git a/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java b/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java
index a036faf8e8..f53ce7bd99 100644
--- a/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java
+++ b/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java
@@ -43,11 +43,14 @@ import org.apache.kafka.common.utils.Time;
  */
 public class BufferPool {
 
+    static final String WAIT_TIME_SENSOR_NAME = "bufferpool-wait-time";
+
     private final long totalMemory;
     private final int poolableSize;
     private final ReentrantLock lock;
     private final Deque<ByteBuffer> free;
     private final Deque<Condition> waiters;
+    /** This memory is accounted for separately from the poolable buffers in free. */
     private long availableMemory;
     private final Metrics metrics;
     private final Time time;
@@ -55,7 +58,7 @@ public class BufferPool {
 
     /**
      * Create a new buffer pool
-     * 
+     *
      * @param memory The maximum amount of memory that this buffer pool can allocate
      * @param poolableSize The buffer size to cache in the free list rather than deallocating
      * @param metrics instance of Metrics
@@ -71,7 +74,7 @@ public class BufferPool {
         this.availableMemory = memory;
         this.metrics = metrics;
         this.time = time;
-        this.waitTime = this.metrics.sensor("bufferpool-wait-time");
+        this.waitTime = this.metrics.sensor(WAIT_TIME_SENSOR_NAME);
         MetricName metricName = metrics.metricName("bufferpool-wait-ratio",
                                                    metricGrpName,
                                                    "The fraction of time an appender waits for space allocation.");
@@ -81,7 +84,7 @@ public class BufferPool {
     /**
      * Allocate a buffer of the given size. This method blocks if there is not enough memory and the buffer pool
      * is configured with blocking mode.
-     * 
+     *
      * @param size The buffer size to allocate in bytes
      * @param maxTimeToBlockMs The maximum time in milliseconds to block for buffer memory to be available
      * @return The buffer
@@ -109,78 +112,76 @@ public class BufferPool {
                 // we have enough unallocated or pooled memory to immediately
                 // satisfy the request
                 freeUp(size);
+                ByteBuffer allocatedBuffer = allocateByteBuffer(size);
                 this.availableMemory -= size;
-                lock.unlock();
-                return allocateByteBuffer(size);
+                return allocatedBuffer;
             } else {
                 // we are out of memory and will have to block
                 int accumulated = 0;
                 ByteBuffer buffer = null;
+                boolean hasError = true;
                 Condition moreMemory = this.lock.newCondition();
-                long remainingTimeToBlockNs = TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);
-                this.waiters.addLast(moreMemory);
-                // loop over and over until we have a buffer or have reserved
-                // enough memory to allocate one
-                while (accumulated < size) {
-                    long startWaitNs = time.nanoseconds();
-                    long timeNs;
-                    boolean waitingTimeElapsed;
-                    try {
-                        waitingTimeElapsed = !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);
-                    } catch (InterruptedException e) {
-                        this.waiters.remove(moreMemory);
-                        throw e;
-                    } finally {
-                        long endWaitNs = time.nanoseconds();
-                        timeNs = Math.max(0L, endWaitNs - startWaitNs);
-                        this.waitTime.record(timeNs, time.milliseconds());
-                    }
+                try {
+                    long remainingTimeToBlockNs = TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);
+                    this.waiters.addLast(moreMemory);
+                    // loop over and over until we have a buffer or have reserved
+                    // enough memory to allocate one
+                    while (accumulated < size) {
+                        long startWaitNs = time.nanoseconds();
+                        long timeNs;
+                        boolean waitingTimeElapsed;
+                        try {
+                            waitingTimeElapsed = !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);
+                        } finally {
+                            long endWaitNs = time.nanoseconds();
+                            timeNs = Math.max(0L, endWaitNs - startWaitNs);
+                            this.waitTime.record(timeNs, time.milliseconds());
+                        }
 
-                    if (waitingTimeElapsed) {
-                        this.waiters.remove(moreMemory);
-                        throw new TimeoutException("Failed to allocate memory within the configured max blocking time " + maxTimeToBlockMs + " ms.");
-                    }
-
-                    remainingTimeToBlockNs -= timeNs;
-                    // check if we can satisfy this request from the free list,
-                    // otherwise allocate memory
-                    if (accumulated == 0 && size == this.poolableSize && !this.free.isEmpty()) {
-                        // just grab a buffer from the free list
-                        buffer = this.free.pollFirst();
-                        accumulated = size;
-                    } else {
-                        // we'll need to allocate memory, but we may only get
-                        // part of what we need on this iteration
-                        freeUp(size - accumulated);
-                        int got = (int) Math.min(size - accumulated, this.availableMemory);
-                        this.availableMemory -= got;
-                        accumulated += got;
-                    }
-                }
+                        if (waitingTimeElapsed) {
+                            throw new TimeoutException("Failed to allocate memory within the configured max blocking time " + maxTimeToBlockMs + " ms.");
+                        }
 
-                // remove the condition for this thread to let the next thread
-                // in line start getting memory
-                Condition removed = this.waiters.removeFirst();
-                if (removed != moreMemory)
-                    throw new IllegalStateException("Wrong condition: this shouldn't happen.");
+                        remainingTimeToBlockNs -= timeNs;
 
-                // signal any additional waiters if there is more memory left
-                // over for them
-                if (this.availableMemory > 0 || !this.free.isEmpty()) {
-                    if (!this.waiters.isEmpty())
-                        this.waiters.peekFirst().signal();
-                }
+                        // check if we can satisfy this request from the free list,
+                        // otherwise allocate memory
+                        if (accumulated == 0 && size == this.poolableSize && !this.free.isEmpty()) {
+                            // just grab a buffer from the free list
+                            buffer = this.free.pollFirst();
+                            accumulated = size;
+                        } else {
+                            // we'll need to allocate memory, but we may only get
+                            // part of what we need on this iteration
+                            freeUp(size - accumulated);
+                            int got = (int) Math.min(size - accumulated, this.availableMemory);
+                            this.availableMemory -= got;
+                            accumulated += got;
+                        }
+                    }
 
-                // unlock and return the buffer
-                lock.unlock();
-                if (buffer == null)
-                    return allocateByteBuffer(size);
-                else
+                    if (buffer == null)
+                        buffer = allocateByteBuffer(size);
+                    hasError = false;
+                    //unlock happens in top-level, enclosing finally
                     return buffer;
+                } finally {
+                    // When this loop was not able to successfully terminate don't loose available memory
+                    if (hasError)
+                        this.availableMemory += accumulated;
+                    this.waiters.remove(moreMemory);
+                }
             }
         } finally {
-            if (lock.isHeldByCurrentThread())
+            // signal any additional waiters if there is more memory left
+            // over for them
+            try {
+                if (!(this.availableMemory == 0 && this.free.isEmpty()) && !this.waiters.isEmpty())
+                    this.waiters.peekFirst().signal();
+            } finally {
+                // Another finally... otherwise find bugs complains
                 lock.unlock();
+            }
         }
     }
 
@@ -201,7 +202,7 @@ public class BufferPool {
     /**
      * Return buffers to the pool. If they are of the poolable size add them to the free list, otherwise just mark the
      * memory as free.
-     * 
+     *
      * @param buffer The buffer to return
      * @param size The size of the buffer to mark as deallocated, note that this may be smaller than buffer.capacity
      *             since the buffer may re-allocate itself during in-place compression
diff --git a/clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java b/clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java
index b4a597c5c6..2ce33ee27c 100644
--- a/clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java
@@ -16,8 +16,11 @@
  */
 package org.apache.kafka.clients.producer.internals;
 
+import org.apache.kafka.common.MetricName;
 import org.apache.kafka.common.errors.TimeoutException;
 import org.apache.kafka.common.metrics.Metrics;
+import org.apache.kafka.common.metrics.Sensor;
+import org.apache.kafka.common.metrics.stats.Rate;
 import org.apache.kafka.common.utils.MockTime;
 import org.apache.kafka.common.utils.Time;
 import org.apache.kafka.test.TestUtils;
@@ -33,12 +36,26 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.Condition;
+import org.junit.runner.RunWith;
+import org.powermock.core.classloader.annotations.PrepareForTest;
+import org.powermock.modules.junit4.PowerMockRunner;
+
+import static org.easymock.EasyMock.eq;
+import static org.easymock.EasyMock.createNiceMock;
+import static org.easymock.EasyMock.replay;
+import static org.easymock.EasyMock.anyLong;
+import static org.easymock.EasyMock.anyDouble;
+import static org.easymock.EasyMock.expectLastCall;
+import static org.easymock.EasyMock.expect;
+import static org.easymock.EasyMock.anyString;
 
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 import static org.junit.Assert.assertEquals;
 
+
+@RunWith(PowerMockRunner.class)
 public class BufferPoolTest {
     private final MockTime time = new MockTime();
     private final Metrics metrics = new Metrics(time);
@@ -171,6 +188,7 @@ public class BufferPoolTest {
         } catch (TimeoutException e) {
             // this is good
         }
+        assertTrue("available memory" + pool.availableMemory(), pool.availableMemory() >= 9 && pool.availableMemory() <= 10);
         long endTimeMs = Time.SYSTEM.milliseconds();
         assertTrue("Allocation should finish not much later than maxBlockTimeMs", endTimeMs - beginTimeMs < maxBlockTimeMs + 1000);
     }
@@ -225,6 +243,35 @@ public class BufferPoolTest {
         assertEquals(pool.queued(), 0);
     }
 
+    @PrepareForTest({Sensor.class, MetricName.class})
+    @Test
+    public void testCleanupMemoryAvailabilityOnMetricsException() throws Exception {
+        Metrics mockedMetrics = createNiceMock(Metrics.class);
+        Sensor mockedSensor = createNiceMock(Sensor.class);
+        MetricName metricName = createNiceMock(MetricName.class);
+
+        expect(mockedMetrics.sensor(BufferPool.WAIT_TIME_SENSOR_NAME)).andReturn(mockedSensor);
+
+        mockedSensor.record(anyDouble(), anyLong());
+        expectLastCall().andThrow(new OutOfMemoryError());
+        expect(mockedMetrics.metricName(anyString(), eq(metricGroup), anyString())).andReturn(metricName);
+        mockedSensor.add(metricName, new Rate(TimeUnit.NANOSECONDS));
+
+        replay(mockedMetrics, mockedSensor, metricName);
+
+        BufferPool bufferPool = new BufferPool(2, 1, mockedMetrics, time,  metricGroup);
+        bufferPool.allocate(1, 0);
+        try {
+            bufferPool.allocate(2, 1000);
+            assertTrue("Expected oom.", false);
+        } catch (OutOfMemoryError expected) {
+        }
+        assertEquals(1, bufferPool.availableMemory());
+        assertEquals(0, bufferPool.queued());
+        //This shouldn't timeout
+        bufferPool.allocate(1, 0);
+    }
+
     private static class BufferPoolAllocator implements Runnable {
         BufferPool pool;
         long maxBlockTimeMs;
