diff --git a/core/src/main/scala/kafka/admin/ReassignPartitionsCommand.scala b/core/src/main/scala/kafka/admin/ReassignPartitionsCommand.scala
index 9cc1d27d97..65d6428d90 100755
--- a/core/src/main/scala/kafka/admin/ReassignPartitionsCommand.scala
+++ b/core/src/main/scala/kafka/admin/ReassignPartitionsCommand.scala
@@ -597,17 +597,17 @@ object ReassignPartitionsCommand extends Logging {
                                 : String = {
     val bld = new mutable.ArrayBuffer[String]
     states.keySet.toBuffer.sortWith(compareTopicPartitionReplicas).foreach {
-      case replica =>
+      replica =>
         val state = states(replica)
         state match {
-          case MissingLogDirMoveState(targetLogDir) =>
+          case MissingLogDirMoveState(_) =>
             bld.append(s"Partition ${replica.topic()}-${replica.partition()} is not found " +
               s"in any live log dir on broker ${replica.brokerId()}. There is likely an " +
               s"offline log directory on the broker.")
-          case MissingReplicaMoveState(targetLogDir) =>
+          case MissingReplicaMoveState(_) =>
             bld.append(s"Partition ${replica.topic()}-${replica.partition()} cannot be found " +
               s"in any live log directory on broker ${replica.brokerId()}.")
-          case ActiveMoveState(currentLogDir, targetLogDir, futureLogDir) =>
+          case ActiveMoveState(_, targetLogDir, futureLogDir) =>
             if (targetLogDir.equals(futureLogDir)) {
               bld.append(s"Reassignment of replica ${replica} is still in progress.")
             } else {
@@ -619,7 +619,7 @@ object ReassignPartitionsCommand extends Logging {
             bld.append(s"Partition ${replica.topic()}-${replica.partition()} on broker " +
               s"${replica.brokerId()} is not being moved from log dir ${currentLogDir} to " +
               s"${targetLogDir}.")
-          case CompletedMoveState(targetLogDir) =>
+          case CompletedMoveState(_) =>
             bld.append(s"Reassignment of replica ${replica} completed successfully.")
         }
     }
@@ -674,8 +674,8 @@ object ReassignPartitionsCommand extends Logging {
    */
   def clearBrokerLevelThrottles(adminClient: Admin, brokers: Set[Int]): Unit = {
     val configOps = new util.HashMap[ConfigResource, util.Collection[AlterConfigOp]]()
-    brokers.foreach {
-      case brokerId => configOps.put(
+    brokers.foreach { brokerId =>
+      configOps.put(
         new ConfigResource(ConfigResource.Type.BROKER, brokerId.toString),
         brokerLevelThrottles.map(throttle => new AlterConfigOp(
           new ConfigEntry(throttle, null), OpType.DELETE)).asJava)
@@ -1191,7 +1191,7 @@ object ReassignPartitionsCommand extends Logging {
                                   reassignments: Map[TopicPartition, Seq[Int]]): Map[TopicPartition, Throwable] = {
     val results: Map[TopicPartition, KafkaFuture[Void]] =
       adminClient.alterPartitionReassignments(reassignments.map { case (part, replicas) =>
-        (part, Optional.of(new NewPartitionReassignment(replicas.map(Integer.valueOf(_)).asJava)))
+        (part, Optional.of(new NewPartitionReassignment(replicas.map(Integer.valueOf).asJava)))
       }.asJava).values().asScala
     results.flatMap {
       case (part, future) => {
@@ -1229,19 +1229,23 @@ object ReassignPartitionsCommand extends Logging {
     }
   }
 
+  /**
+   * Compute the in progress partition move from the current reassignments.
+   * @param currentReassignments All replicas, adding replicas and removing replicas of target partitions
+   */
   private def calculateCurrentMoveMap(currentReassignments: Map[TopicPartition, PartitionReassignment]): MoveMap = {
     val moveMap = new mutable.HashMap[String, mutable.Map[Int, PartitionMove]]()
     // Add the current reassignments to the move map.
     currentReassignments.foreach { case (part, reassignment) =>
-      val move = PartitionMove(new mutable.HashSet[Int](), new mutable.HashSet[Int]())
-      reassignment.replicas.forEach { replica =>
-        move.sources += replica
-        move.destinations += replica
-      }
-      reassignment.addingReplicas.forEach(move.destinations += _)
-      reassignment.removingReplicas.forEach(move.destinations -= _)
+      val allReplicas = reassignment.replicas().asScala.map(Int.unbox)
+      val addingReplicas = reassignment.addingReplicas.asScala.map(Int.unbox)
+
+      // The addingReplicas is included in the replicas during reassignment
+      val sources = mutable.Set[Int]() ++ allReplicas.diff(addingReplicas)
+      val destinations = mutable.Set[Int]() ++ addingReplicas
+
       val partMoves = moveMap.getOrElseUpdate(part.topic, new mutable.HashMap[Int, PartitionMove])
-      partMoves.put(part.partition, move)
+      partMoves.put(part.partition, PartitionMove(sources, destinations))
     }
     moveMap
   }
@@ -1250,7 +1254,7 @@ object ReassignPartitionsCommand extends Logging {
    * Calculate the global map of all partitions that are moving.
    *
    * @param currentReassignments    The currently active reassignments.
-   * @param proposedReassignments   The proposed reassignments (destinations replicas only).
+   * @param proposedParts           The proposed location of the partitions (destinations replicas only).
    * @param currentParts            The current location of the partitions that we are
    *                                proposing to move.
    * @return                        A map from topic name to partition map.
@@ -1258,40 +1262,25 @@ object ReassignPartitionsCommand extends Logging {
    *                                the movements for that partition.
    */
   def calculateProposedMoveMap(currentReassignments: Map[TopicPartition, PartitionReassignment],
-                               proposedReassignments: Map[TopicPartition, Seq[Int]],
+                               proposedParts: Map[TopicPartition, Seq[Int]],
                                currentParts: Map[TopicPartition, Seq[Int]]): MoveMap = {
     val moveMap = calculateCurrentMoveMap(currentReassignments)
 
-    // Add the proposed reassignments to the move map.  The proposals will overwrite
-    // the current reassignments.
-    proposedReassignments.foreach {
-      case (part, replicas) => {
-        val move = PartitionMove(new mutable.HashSet[Int](), new mutable.HashSet[Int]())
-        move.destinations ++= replicas
+    proposedParts.foreach {
+      case (part, replicas) =>
         val partMoves = moveMap.getOrElseUpdate(part.topic(), new mutable.HashMap[Int, PartitionMove])
-        partMoves.put(part.partition(), move)
-      }
-    }
-    // For partitions we are moving, add the current replica locations as sources.
-    // Ignore partitions that are not being moved.
-    moveMap.foreach {
-      case (topicName, partMap) =>
-        partMap.foreach {
-          case (partitionIndex, moves) =>
-            currentParts.get(new TopicPartition(topicName, partitionIndex)) match {
-              case None =>
-              case Some(replicas) => moves.sources ++= replicas
-            }
-        }
-    }
-    // Remove sources from destinations.  If something is a source, the data is already there,
-    // so it doesn't need to be treated as a destination (by having follower throttle applied, etc.)
-    moveMap.foreach {
-      case (_, partMap) =>
-        partMap.foreach {
-          case (_, moves) =>
-            moves.destinations --= moves.sources
-        }
+
+        // If there is a reassignment in progress, use the sources from moveMap, otherwise
+        // use the sources from currentParts
+        val sources = mutable.Set[Int]() ++ (partMoves.get(part.partition()) match {
+          case Some(move) => move.sources.toSeq
+          case None => currentParts.getOrElse(part,
+            throw new RuntimeException(s"Trying to reassign a topic partition $part with 0 replicas"))
+        })
+        val destinations = mutable.Set[Int]() ++ replicas.diff(sources.toSeq)
+
+        partMoves.put(part.partition,
+          PartitionMove(sources, destinations))
     }
     moveMap
   }
diff --git a/core/src/test/scala/unit/kafka/admin/ReassignPartitionsUnitTest.scala b/core/src/test/scala/unit/kafka/admin/ReassignPartitionsUnitTest.scala
index ba4b709eb3..27bf4251b2 100644
--- a/core/src/test/scala/unit/kafka/admin/ReassignPartitionsUnitTest.scala
+++ b/core/src/test/scala/unit/kafka/admin/ReassignPartitionsUnitTest.scala
@@ -28,7 +28,6 @@ import org.apache.kafka.common.config.ConfigResource
 import org.apache.kafka.common.errors.{InvalidReplicationFactorException, UnknownTopicOrPartitionException}
 import org.apache.kafka.common.{Node, TopicPartition, TopicPartitionInfo, TopicPartitionReplica}
 import org.junit.Assert.{assertEquals, assertFalse, assertThrows, assertTrue}
-import org.junit.function.ThrowingRunnable
 import org.junit.rules.Timeout
 import org.junit.{After, Assert, Before, Rule, Test}
 
@@ -75,11 +74,11 @@ class ReassignPartitionsUnitTest {
         mkString(System.lineSeparator()),
       partitionReassignmentStatesToString(Map(
         new TopicPartition("foo", 0) ->
-          new PartitionReassignmentState(Seq(1, 2, 3), Seq(1, 2, 3), true),
+          PartitionReassignmentState(Seq(1, 2, 3), Seq(1, 2, 3), true),
         new TopicPartition("foo", 1) ->
-          new PartitionReassignmentState(Seq(1, 2, 3), Seq(1, 2, 4), false),
+          PartitionReassignmentState(Seq(1, 2, 3), Seq(1, 2, 4), false),
         new TopicPartition("bar", 0) ->
-          new PartitionReassignmentState(Seq(1, 2, 3), Seq(1, 2, 4), false),
+          PartitionReassignmentState(Seq(1, 2, 3), Seq(1, 2, 4), false),
       )))
   }
 
@@ -192,15 +191,15 @@ class ReassignPartitionsUnitTest {
       "Partition quux-2 is not found in any live log dir on broker 1. " +
           "There is likely an offline log directory on the broker.").mkString(System.lineSeparator()),
         replicaMoveStatesToString(Map(
-          new TopicPartitionReplica("bar", 0, 0) -> new CompletedMoveState("/tmp/kafka-logs0"),
-          new TopicPartitionReplica("foo", 0, 0) -> new ActiveMoveState("/tmp/kafka-logs0",
+          new TopicPartitionReplica("bar", 0, 0) -> CompletedMoveState("/tmp/kafka-logs0"),
+          new TopicPartitionReplica("foo", 0, 0) -> ActiveMoveState("/tmp/kafka-logs0",
             "/tmp/kafka-logs1", "/tmp/kafka-logs1"),
-          new TopicPartitionReplica("foo", 1, 0) -> new CancelledMoveState("/tmp/kafka-logs0",
+          new TopicPartitionReplica("foo", 1, 0) -> CancelledMoveState("/tmp/kafka-logs0",
             "/tmp/kafka-logs1"),
-          new TopicPartitionReplica("quux", 0, 0) -> new MissingReplicaMoveState("/tmp/kafka-logs1"),
-          new TopicPartitionReplica("quux", 1, 1) -> new ActiveMoveState("/tmp/kafka-logs0",
+          new TopicPartitionReplica("quux", 0, 0) -> MissingReplicaMoveState("/tmp/kafka-logs1"),
+          new TopicPartitionReplica("quux", 1, 1) -> ActiveMoveState("/tmp/kafka-logs0",
             "/tmp/kafka-logs1", "/tmp/kafka-logs2"),
-          new TopicPartitionReplica("quux", 2, 1) -> new MissingLogDirMoveState("/tmp/kafka-logs1")
+          new TopicPartitionReplica("quux", 2, 1) -> MissingLogDirMoveState("/tmp/kafka-logs1")
         )))
   }
 
@@ -234,20 +233,19 @@ class ReassignPartitionsUnitTest {
       build()
     try {
       assertEquals(Seq(
-        new BrokerMetadata(0, Some("rack0")),
-        new BrokerMetadata(1, Some("rack1"))
+        BrokerMetadata(0, Some("rack0")),
+        BrokerMetadata(1, Some("rack1"))
       ), getBrokerMetadata(adminClient, Seq(0, 1), true))
       assertEquals(Seq(
-        new BrokerMetadata(0, None),
-        new BrokerMetadata(1, None)
+        BrokerMetadata(0, None),
+        BrokerMetadata(1, None)
       ), getBrokerMetadata(adminClient, Seq(0, 1), false))
       assertStartsWith("Not all brokers have rack information",
-        assertThrows(classOf[AdminOperationException], new ThrowingRunnable {
-          override def run(): Unit = getBrokerMetadata(adminClient, Seq(1, 2), true)
-        }).getMessage)
+        assertThrows(classOf[AdminOperationException],
+          () => getBrokerMetadata(adminClient, Seq(1, 2), true)).getMessage)
       assertEquals(Seq(
-        new BrokerMetadata(1, None),
-        new BrokerMetadata(2, None)
+        BrokerMetadata(1, None),
+        BrokerMetadata(2, None)
       ), getBrokerMetadata(adminClient, Seq(1, 2), false))
     } finally {
       adminClient.close()
@@ -258,25 +256,19 @@ class ReassignPartitionsUnitTest {
   def testParseGenerateAssignmentArgs(): Unit = {
     assertStartsWith("Broker list contains duplicate entries",
       assertThrows("Expected to detect duplicate broker list entries",
-        classOf[AdminCommandFailedException], new ThrowingRunnable {
-          override def run():Unit = parseGenerateAssignmentArgs(
-            """{"topics": [{"topic": "foo"}], "version":1}""", "1,1,2")
-        }).getMessage)
+        classOf[AdminCommandFailedException], () => parseGenerateAssignmentArgs(
+          """{"topics": [{"topic": "foo"}], "version":1}""", "1,1,2")).getMessage)
     assertStartsWith("Broker list contains duplicate entries",
       assertThrows("Expected to detect duplicate broker list entries",
-        classOf[AdminCommandFailedException], new ThrowingRunnable {
-          override def run():Unit = parseGenerateAssignmentArgs(
-            """{"topics": [{"topic": "foo"}], "version":1}""", "5,2,3,4,5")
-        }).getMessage)
+        classOf[AdminCommandFailedException], () => parseGenerateAssignmentArgs(
+          """{"topics": [{"topic": "foo"}], "version":1}""", "5,2,3,4,5")).getMessage)
     assertEquals((Seq(5,2,3,4),Seq("foo")),
       parseGenerateAssignmentArgs("""{"topics": [{"topic": "foo"}], "version":1}""",
         "5,2,3,4"))
     assertStartsWith("List of topics to reassign contains duplicate entries",
       assertThrows("Expected to detect duplicate topic entries",
-        classOf[AdminCommandFailedException], new ThrowingRunnable {
-          override def run():Unit = parseGenerateAssignmentArgs(
-            """{"topics": [{"topic": "foo"},{"topic": "foo"}], "version":1}""", "5,2,3,4")
-        }).getMessage)
+        classOf[AdminCommandFailedException], () => parseGenerateAssignmentArgs(
+          """{"topics": [{"topic": "foo"},{"topic": "foo"}], "version":1}""", "5,2,3,4")).getMessage)
     assertEquals((Seq(5,3,4),Seq("foo","bar")),
       parseGenerateAssignmentArgs(
         """{"topics": [{"topic": "foo"},{"topic": "bar"}], "version":1}""",
@@ -290,11 +282,9 @@ class ReassignPartitionsUnitTest {
       addTopics(adminClient)
       assertStartsWith("Replication factor: 3 larger than available brokers: 2",
         assertThrows("Expected generateAssignment to fail",
-          classOf[InvalidReplicationFactorException], new ThrowingRunnable {
-            override def run():Unit = {
-              generateAssignment(adminClient,
-                """{"topics":[{"topic":"foo"},{"topic":"bar"}]}""", "0,1", false)
-            }
+          classOf[InvalidReplicationFactorException], () => {
+            generateAssignment(adminClient,
+              """{"topics":[{"topic":"foo"},{"topic":"bar"}]}""", "0,1", false)
           }).getMessage)
     } finally {
       adminClient.close()
@@ -316,11 +306,9 @@ class ReassignPartitionsUnitTest {
       addTopics(adminClient)
       assertStartsWith("Not all brokers have rack information.",
         assertThrows("Expected generateAssignment to fail",
-          classOf[AdminOperationException], new ThrowingRunnable {
-            override def run():Unit = {
-              generateAssignment(adminClient,
-                """{"topics":[{"topic":"foo"}]}""", "0,1,2,3", true)
-            }
+          classOf[AdminOperationException], () => {
+            generateAssignment(adminClient,
+              """{"topics":[{"topic":"foo"}]}""", "0,1,2,3", true)
           }).getMessage)
       // It should succeed when --disable-rack-aware is used.
       val (_, current) = generateAssignment(adminClient,
@@ -351,7 +339,7 @@ class ReassignPartitionsUnitTest {
 
       // The proposed assignment should only span the provided brokers
       proposed.values.foreach {
-        case replicas => {
+        replicas => {
           if (!replicas.forall(goalBrokers.contains(_))) {
             Assert.fail(s"Proposed assignment ${proposed} puts replicas on brokers " +
               s"other than ${goalBrokers}")
@@ -390,38 +378,68 @@ class ReassignPartitionsUnitTest {
 
   @Test
   def testMoveMap(): Unit = {
+    // overwrite foo-0 with different reassignments
+    // keep old reassignments of foo-1
+    // overwrite foo-2 with same reassignments
+    // overwrite foo-3 with new reassignments without overlap of old reassignments
+    // overwrite foo-4 with a subset of old reassignments
+    // overwrite foo-5 with a superset of old reassignments
+    // add new reassignments to bar-0
     val moveMap = calculateProposedMoveMap(Map(
       new TopicPartition("foo", 0) -> new PartitionReassignment(
-        Arrays.asList(1,2,3),Arrays.asList(4),Arrays.asList(3)),
+        Arrays.asList(1,2,3,4), Arrays.asList(4), Arrays.asList(3)),
       new TopicPartition("foo", 1) -> new PartitionReassignment(
-        Arrays.asList(4,5,6),Arrays.asList(7, 8),Arrays.asList(4, 5))
+        Arrays.asList(4,5,6,7,8), Arrays.asList(7, 8), Arrays.asList(4, 5)),
+      new TopicPartition("foo", 2) -> new PartitionReassignment(
+        Arrays.asList(1,2,3,4), Arrays.asList(3,4), Arrays.asList(1,2)),
+      new TopicPartition("foo", 3) -> new PartitionReassignment(
+        Arrays.asList(1,2,3,4), Arrays.asList(3,4), Arrays.asList(1,2)),
+      new TopicPartition("foo", 4) -> new PartitionReassignment(
+        Arrays.asList(1,2,3,4), Arrays.asList(3,4), Arrays.asList(1,2)),
+      new TopicPartition("foo", 5) -> new PartitionReassignment(
+        Arrays.asList(1,2,3,4), Arrays.asList(3,4), Arrays.asList(1,2))
     ), Map(
       new TopicPartition("foo", 0) -> Seq(1,2,5),
+      new TopicPartition("foo", 2) -> Seq(3,4),
+      new TopicPartition("foo", 3) -> Seq(5,6),
+      new TopicPartition("foo", 4) -> Seq(3),
+      new TopicPartition("foo", 5) -> Seq(3,4,5,6),
       new TopicPartition("bar", 0) -> Seq(1,2,3)
     ), Map(
-      new TopicPartition("foo", 0) -> Seq(1,2,3),
-      new TopicPartition("foo", 1) -> Seq(4,5,6),
+      new TopicPartition("foo", 0) -> Seq(1,2,3,4),
+      new TopicPartition("foo", 1) -> Seq(4,5,6,7,8),
+      new TopicPartition("foo", 2) -> Seq(1,2,3,4),
+      new TopicPartition("foo", 3) -> Seq(1,2,3,4),
+      new TopicPartition("foo", 4) -> Seq(1,2,3,4),
+      new TopicPartition("foo", 5) -> Seq(1,2,3,4),
       new TopicPartition("bar", 0) -> Seq(2,3,4),
       new TopicPartition("baz", 0) -> Seq(1,2,3)
     ))
+
     assertEquals(
       mutable.Map("foo" -> mutable.Map(
-          0 -> new PartitionMove(mutable.Set(1,2,3), mutable.Set(5)),
-          1 -> new PartitionMove(mutable.Set(4,5,6), mutable.Set(7, 8))
-        ),
-        "bar" -> mutable.Map(
-          0 -> new PartitionMove(mutable.Set(2,3,4), mutable.Set(1)),
-        )
-      ), moveMap)
+        0 -> PartitionMove(mutable.Set(1,2,3), mutable.Set(5)),
+        1 -> PartitionMove(mutable.Set(4,5,6), mutable.Set(7,8)),
+        2 -> PartitionMove(mutable.Set(1,2), mutable.Set(3,4)),
+        3 -> PartitionMove(mutable.Set(1,2), mutable.Set(5,6)),
+        4 -> PartitionMove(mutable.Set(1,2), mutable.Set(3)),
+        5 -> PartitionMove(mutable.Set(1,2), mutable.Set(3,4,5,6))
+      ), "bar" -> mutable.Map(
+        0 -> PartitionMove(mutable.Set(2,3,4), mutable.Set(1)),
+      )), moveMap)
+
     assertEquals(Map(
-        "foo" -> "0:1,0:2,0:3,1:4,1:5,1:6",
+        "foo" -> "0:1,0:2,0:3,1:4,1:5,1:6,2:1,2:2,3:1,3:2,4:1,4:2,5:1,5:2",
         "bar" -> "0:2,0:3,0:4"
       ), calculateLeaderThrottles(moveMap))
+
     assertEquals(Map(
-        "foo" -> "0:5,1:7,1:8",
+        "foo" -> "0:5,1:7,1:8,2:3,2:4,3:5,3:6,4:3,5:3,5:4,5:5,5:6",
         "bar" -> "0:1"
       ), calculateFollowerThrottles(moveMap))
+
     assertEquals(Set(1,2,3,4,5,6,7,8), calculateReassigningBrokers(moveMap))
+
     assertEquals(Set(0,2), calculateMovingBrokers(
       Set(new TopicPartitionReplica("quux", 0, 0),
           new TopicPartitionReplica("quux", 1, 2))))
@@ -431,40 +449,29 @@ class ReassignPartitionsUnitTest {
   def testParseExecuteAssignmentArgs(): Unit = {
     assertStartsWith("Partition reassignment list cannot be empty",
       assertThrows("Expected to detect empty partition reassignment list",
-        classOf[AdminCommandFailedException], new ThrowingRunnable {
-          override def run():Unit =
-            parseExecuteAssignmentArgs("""{"version":1,"partitions":[]}""")
-        }).getMessage)
+        classOf[AdminCommandFailedException],
+        () => parseExecuteAssignmentArgs("""{"version":1,"partitions":[]}""")).getMessage)
     assertStartsWith("Partition reassignment contains duplicate topic partitions",
       assertThrows("Expected to detect a partition list with duplicate entries",
-        classOf[AdminCommandFailedException], new ThrowingRunnable {
-          override def run():Unit =
-            parseExecuteAssignmentArgs(
-              """{"version":1,"partitions":""" +
-                """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["any","any"]},""" +
-                """{"topic":"foo","partition":0,"replicas":[2,3,4],"log_dirs":["any","any","any"]}""" +
-                """]}""")
-        }).getMessage)
+        classOf[AdminCommandFailedException], () => parseExecuteAssignmentArgs(
+          """{"version":1,"partitions":""" +
+            """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["any","any"]},""" +
+            """{"topic":"foo","partition":0,"replicas":[2,3,4],"log_dirs":["any","any","any"]}""" +
+            """]}""")).getMessage)
     assertStartsWith("Partition reassignment contains duplicate topic partitions",
       assertThrows("Expected to detect a partition replica list with duplicate entries",
-        classOf[AdminCommandFailedException], new ThrowingRunnable {
-          override def run():Unit =
-            parseExecuteAssignmentArgs(
-              """{"version":1,"partitions":""" +
-                """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["/abc","/def"]},""" +
-                """{"topic":"foo","partition":0,"replicas":[2,3],"log_dirs":["/abc","/def"]}""" +
-                """]}""")
-        }).getMessage)
+        classOf[AdminCommandFailedException], () => parseExecuteAssignmentArgs(
+          """{"version":1,"partitions":""" +
+            """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["/abc","/def"]},""" +
+            """{"topic":"foo","partition":0,"replicas":[2,3],"log_dirs":["/abc","/def"]}""" +
+            """]}""")).getMessage)
     assertStartsWith("Partition replica lists may not contain duplicate entries",
       assertThrows("Expected to detect a partition replica list with duplicate entries",
-        classOf[AdminCommandFailedException], new ThrowingRunnable {
-          override def run():Unit =
-            parseExecuteAssignmentArgs(
-              """{"version":1,"partitions":""" +
-                """[{"topic":"foo","partition":0,"replicas":[0,0],"log_dirs":["/abc","/def"]},""" +
-                """{"topic":"foo","partition":1,"replicas":[2,3],"log_dirs":["/abc","/def"]}""" +
-                """]}""")
-        }).getMessage)
+        classOf[AdminCommandFailedException], () => parseExecuteAssignmentArgs(
+          """{"version":1,"partitions":""" +
+            """[{"topic":"foo","partition":0,"replicas":[0,0],"log_dirs":["/abc","/def"]},""" +
+            """{"topic":"foo","partition":1,"replicas":[2,3],"log_dirs":["/abc","/def"]}""" +
+            """]}""")).getMessage)
     assertEquals((Map(
         new TopicPartition("foo", 0) -> Seq(1, 2, 3),
         new TopicPartition("foo", 1) -> Seq(3, 4, 5),
@@ -495,14 +502,11 @@ class ReassignPartitionsUnitTest {
       addTopics(adminClient)
       assertStartsWith("Topic quux not found",
         assertThrows("Expected reassignment with non-existent topic to fail",
-          classOf[ExecutionException], new ThrowingRunnable {
-            override def run():Unit =
-              executeAssignment(adminClient, false,
-                """{"version":1,"partitions":""" +
-                """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["any","any"]},""" +
-                """{"topic":"quux","partition":0,"replicas":[2,3,4],"log_dirs":["any","any","any"]}""" +
-                """]}""")
-          }).getCause.getMessage)
+          classOf[ExecutionException], () => executeAssignment(adminClient, false,
+            """{"version":1,"partitions":""" +
+              """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["any","any"]},""" +
+              """{"topic":"quux","partition":0,"replicas":[2,3,4],"log_dirs":["any","any","any"]}""" +
+              """]}""")).getCause.getMessage)
     } finally {
       adminClient.close()
     }
@@ -515,14 +519,11 @@ class ReassignPartitionsUnitTest {
       addTopics(adminClient)
       assertStartsWith("Unknown broker id 4",
         assertThrows("Expected reassignment with non-existent broker id to fail",
-          classOf[AdminCommandFailedException], new ThrowingRunnable {
-            override def run():Unit =
-              executeAssignment(adminClient, false,
-                """{"version":1,"partitions":""" +
-                  """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["any","any"]},""" +
-                  """{"topic":"foo","partition":1,"replicas":[2,3,4],"log_dirs":["any","any","any"]}""" +
-                  """]}""")
-          }).getMessage)
+          classOf[AdminCommandFailedException], () => executeAssignment(adminClient, false,
+            """{"version":1,"partitions":""" +
+              """[{"topic":"foo","partition":0,"replicas":[0,1],"log_dirs":["any","any"]},""" +
+              """{"topic":"foo","partition":1,"replicas":[2,3,4],"log_dirs":["any","any","any"]}""" +
+              """]}""")).getMessage)
     } finally {
       adminClient.close()
     }
@@ -614,7 +615,7 @@ class ReassignPartitionsUnitTest {
         Map("foo" -> "leaderFoo", "bar" -> "leaderBar"),
         Map("bar" -> "followerBar"))
       val topics = Seq("bar", "foo").map(
-        id => new ConfigResource(ConfigResource.Type.TOPIC, id.toString))
+        id => new ConfigResource(ConfigResource.Type.TOPIC, id))
       val results = adminClient.describeConfigs(topics.asJava).all().get()
       verifyTopicThrottleResults(results.get(topics(0)), "leaderBar", "followerBar")
       verifyTopicThrottleResults(results.get(topics(1)), "leaderFoo", "")
@@ -628,9 +629,9 @@ class ReassignPartitionsUnitTest {
                                          expectedFollowerThrottle: String): Unit = {
     val configs = new mutable.HashMap[String, String]
     config.entries.forEach(entry => configs.put(entry.name, entry.value))
-    assertEquals(expectedLeaderThrottle.toString,
+    assertEquals(expectedLeaderThrottle,
       configs.getOrElse(topicLevelLeaderThrottle, ""))
-    assertEquals(expectedFollowerThrottle.toString,
+    assertEquals(expectedFollowerThrottle,
       configs.getOrElse(topicLevelFollowerThrottle, ""))
   }
 
