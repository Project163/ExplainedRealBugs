diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
index 85a6ffeacc..1e4d0cf195 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
@@ -1225,7 +1225,7 @@ public class AsyncKafkaConsumer<K, V> implements ConsumerDelegate<K, V> {
         wakeupTrigger.disableWakeups();
 
         final Timer closeTimer = time.timer(timeout);
-        clientTelemetryReporter.ifPresent(reporter -> reporter.initiateClose(timeout.toMillis()));
+        clientTelemetryReporter.ifPresent(ClientTelemetryReporter::initiateClose);
         closeTimer.update();
         // Prepare shutting down the network thread
         swallow(log, Level.ERROR, "Failed to release assignment before closing consumer",
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ClassicKafkaConsumer.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ClassicKafkaConsumer.java
index 52eee98d08..bc9102b0ae 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ClassicKafkaConsumer.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ClassicKafkaConsumer.java
@@ -1118,7 +1118,7 @@ public class ClassicKafkaConsumer<K, V> implements ConsumerDelegate<K, V> {
         AtomicReference<Throwable> firstException = new AtomicReference<>();
 
         final Timer closeTimer = createTimerForRequest(timeout);
-        clientTelemetryReporter.ifPresent(reporter -> reporter.initiateClose(timeout.toMillis()));
+        clientTelemetryReporter.ifPresent(ClientTelemetryReporter::initiateClose);
         closeTimer.update();
         // Close objects with a timeout. The timeout is required because the coordinator & the fetcher send requests to
         // the server in the process of closing which may not respect the overall timeout defined for closing the
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ShareConsumerImpl.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ShareConsumerImpl.java
index fd8f0385b9..ad564e346d 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ShareConsumerImpl.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ShareConsumerImpl.java
@@ -840,7 +840,7 @@ public class ShareConsumerImpl<K, V> implements ShareConsumerDelegate<K, V> {
         wakeupTrigger.disableWakeups();
 
         final Timer closeTimer = time.timer(timeout);
-        clientTelemetryReporter.ifPresent(reporter -> reporter.initiateClose(timeout.toMillis()));
+        clientTelemetryReporter.ifPresent(ClientTelemetryReporter::initiateClose);
         closeTimer.update();
 
         // Prepare shutting down the network thread
diff --git a/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java b/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java
index 948c0f57a5..0b290318b0 100644
--- a/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java
+++ b/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java
@@ -1393,6 +1393,9 @@ public class KafkaProducer<K, V> implements Producer<K, V> {
             } else {
                 // Try to close gracefully.
                 final Timer closeTimer = time.timer(timeout);
+                clientTelemetryReporter.ifPresent(ClientTelemetryReporter::initiateClose);
+                closeTimer.update();
+
                 if (this.sender != null) {
                     this.sender.initiateClose();
                     closeTimer.update();
@@ -1407,7 +1410,6 @@ public class KafkaProducer<K, V> implements Producer<K, V> {
                         closeTimer.update();
                     }
                 }
-                clientTelemetryReporter.ifPresent(reporter -> reporter.initiateClose(closeTimer.remainingMs()));
             }
         }
 
diff --git a/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporter.java b/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporter.java
index 1fbf32011e..78a3900d63 100644
--- a/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporter.java
+++ b/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporter.java
@@ -218,10 +218,10 @@ public class ClientTelemetryReporter implements MetricsReporter {
         telemetryProvider.updateLabels(labels);
     }
 
-    public void initiateClose(long timeoutMs) {
+    public void initiateClose() {
         log.debug("Initiate close of ClientTelemetryReporter");
         try {
-            clientTelemetrySender.initiateClose(timeoutMs);
+            clientTelemetrySender.initiateClose();
         } catch (Exception exception) {
             log.error("Failed to initiate close of client telemetry reporter", exception);
         }
@@ -271,7 +271,6 @@ public class ClientTelemetryReporter implements MetricsReporter {
 
         private final ReadWriteLock lock = new ReentrantReadWriteLock();
         private final Condition subscriptionLoaded = lock.writeLock().newCondition();
-        private final Condition terminalPushInProgress = lock.writeLock().newCondition();
         /*
          Initial state should be subscription needed which should allow issuing first telemetry
          request of get telemetry subscription.
@@ -602,8 +601,8 @@ public class ClientTelemetryReporter implements MetricsReporter {
         }
 
         @Override
-        public void initiateClose(long timeoutMs) {
-            log.debug("initiate close for client telemetry, check if terminal push required. Timeout {} ms.", timeoutMs);
+        public void initiateClose() {
+            log.debug("initiate close for client telemetry, check if terminal push required.");
 
             lock.writeLock().lock();
             try {
@@ -623,14 +622,7 @@ public class ClientTelemetryReporter implements MetricsReporter {
                     return;
                 }
 
-                try {
-                    log.info("About to wait {} ms. for terminal telemetry push to be submitted", timeoutMs);
-                    if (!terminalPushInProgress.await(timeoutMs, TimeUnit.MILLISECONDS)) {
-                        log.info("Wait for terminal telemetry push to be submitted has elapsed; may not have actually sent request");
-                    }
-                } catch (InterruptedException e) {
-                    log.warn("Error during client telemetry close", e);
-                }
+                log.debug("Updated state to send terminal telemetry push request");
             } finally {
                 lock.writeLock().unlock();
             }
@@ -827,13 +819,9 @@ public class ClientTelemetryReporter implements MetricsReporter {
                 ClientTelemetryState oldState = state;
                 state = oldState.validateTransition(newState);
                 log.debug("Setting telemetry state from {} to {}", oldState, newState);
-
-                if (newState == ClientTelemetryState.TERMINATING_PUSH_IN_PROGRESS) {
-                    terminalPushInProgress.signalAll();
-                }
                 return true;
             } catch (IllegalStateException e) {
-                log.warn("Error updating client telemetry state, disabled telemetry", e);
+                log.warn("Error updating client telemetry state, disabled telemetry");
                 enabled = false;
                 return false;
             } finally {
diff --git a/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetrySender.java b/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetrySender.java
index 17a6da664f..d7fd81364f 100644
--- a/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetrySender.java
+++ b/clients/src/main/java/org/apache/kafka/common/telemetry/internals/ClientTelemetrySender.java
@@ -107,8 +107,6 @@ public interface ClientTelemetrySender extends AutoCloseable {
     /**
      * Initiates shutdown of this client. This method is called when the enclosing client instance
      * is being closed. This method should not throw an exception if the client is already closed.
-     *
-     * @param timeoutMs The maximum time to wait for the client to close.
      */
-    void initiateClose(long timeoutMs);
+    void initiateClose();
 }
diff --git a/clients/src/test/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporterTest.java b/clients/src/test/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporterTest.java
index 7dba97c238..066e9ff74d 100644
--- a/clients/src/test/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporterTest.java
+++ b/clients/src/test/java/org/apache/kafka/common/telemetry/internals/ClientTelemetryReporterTest.java
@@ -729,6 +729,48 @@ public class ClientTelemetryReporterTest {
         assertTrue(timeMs >= 500 && timeMs <= 1500);
     }
 
+    @Test
+    public void testTelemetryReporterInitiateClose() {
+        ClientTelemetryReporter.DefaultClientTelemetrySender telemetrySender = (ClientTelemetryReporter.DefaultClientTelemetrySender) clientTelemetryReporter.telemetrySender();
+        telemetrySender.updateSubscriptionResult(subscription, time.milliseconds());
+        assertTrue(telemetrySender.maybeSetState(ClientTelemetryState.SUBSCRIPTION_IN_PROGRESS));
+        assertTrue(telemetrySender.maybeSetState(ClientTelemetryState.PUSH_NEEDED));
+
+        clientTelemetryReporter.initiateClose();
+        assertEquals(ClientTelemetryState.TERMINATING_PUSH_NEEDED, ((ClientTelemetryReporter.DefaultClientTelemetrySender) clientTelemetryReporter
+            .telemetrySender()).state());
+    }
+
+    @Test
+    public void testTelemetryReporterInitiateCloseNoSubscription() {
+        clientTelemetryReporter.initiateClose();
+        assertEquals(ClientTelemetryState.SUBSCRIPTION_NEEDED, ((ClientTelemetryReporter.DefaultClientTelemetrySender) clientTelemetryReporter
+            .telemetrySender()).state());
+    }
+
+    @Test
+    public void testTelemetryReporterInitiateCloseAlreadyInTerminatedStates() {
+        ClientTelemetryReporter.DefaultClientTelemetrySender telemetrySender = (ClientTelemetryReporter.DefaultClientTelemetrySender) clientTelemetryReporter.telemetrySender();
+        telemetrySender.updateSubscriptionResult(subscription, time.milliseconds());
+        assertTrue(telemetrySender.maybeSetState(ClientTelemetryState.SUBSCRIPTION_IN_PROGRESS));
+        assertTrue(telemetrySender.maybeSetState(ClientTelemetryState.PUSH_NEEDED));
+        assertTrue(telemetrySender.maybeSetState(ClientTelemetryState.TERMINATING_PUSH_NEEDED));
+
+        clientTelemetryReporter.initiateClose();
+        assertEquals(ClientTelemetryState.TERMINATING_PUSH_NEEDED, ((ClientTelemetryReporter.DefaultClientTelemetrySender) clientTelemetryReporter
+            .telemetrySender()).state());
+
+        assertTrue(telemetrySender.maybeSetState(ClientTelemetryState.TERMINATING_PUSH_IN_PROGRESS));
+        clientTelemetryReporter.initiateClose();
+        assertEquals(ClientTelemetryState.TERMINATING_PUSH_IN_PROGRESS, ((ClientTelemetryReporter.DefaultClientTelemetrySender) clientTelemetryReporter
+            .telemetrySender()).state());
+
+        assertTrue(telemetrySender.maybeSetState(ClientTelemetryState.TERMINATED));
+        clientTelemetryReporter.initiateClose();
+        assertEquals(ClientTelemetryState.TERMINATED, ((ClientTelemetryReporter.DefaultClientTelemetrySender) clientTelemetryReporter
+            .telemetrySender()).state());
+    }
+
     @AfterEach
     public void tearDown() {
         clientTelemetryReporter.close();
