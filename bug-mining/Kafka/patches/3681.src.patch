diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java
index 0fdcd90c24..221eeb49fe 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java
@@ -208,22 +208,12 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
     private final Map<Uuid, String> assignedTopicNamesCache;
 
     /**
-     * Topic IDs received in a target assignment for which we haven't found topic names yet.
-     * Items are added to this set every time a target assignment is received. Items are removed
-     * when metadata is found for the topic. This is where the member collects all assignments
-     * received from the broker, even though they may not be ready to reconcile due to missing
+     * Topic IDs and partitions received in the last target assignment. Items are added to this set
+     * every time a target assignment is received. This is where the member collects the assignment
+     * received from the broker, even though it may not be ready to fully reconcile due to missing
      * metadata.
      */
-    private final Map<Uuid, SortedSet<Integer>> assignmentUnresolved;
-
-    /**
-     * Assignment received for which topic names have been resolved, so it's ready to be
-     * reconciled. Items are added to this set when received in a target assignment (if metadata
-     * available), or when a metadata update is received. This is where the member keeps all the
-     * assignment ready to reconcile, even though the reconciliation might need to wait if there
-     * is already another on in process.
-     */
-    private final SortedSet<TopicIdPartition> assignmentReadyToReconcile;
+    private final Map<Uuid, SortedSet<Integer>> currentTargetAssignment;
 
     /**
      * If there is a reconciliation running (triggering commit, callbacks) for the
@@ -297,8 +287,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
         this.commitRequestManager = commitRequestManager;
         this.metadata = metadata;
         this.assignedTopicNamesCache = new HashMap<>();
-        this.assignmentUnresolved = new HashMap<>();
-        this.assignmentReadyToReconcile = new TreeSet<>(TOPIC_ID_PARTITION_COMPARATOR);
+        this.currentTargetAssignment = new HashMap<>();
         this.currentAssignment = new HashMap<>();
         this.log = logContext.logger(MembershipManagerImpl.class);
         this.stateUpdatesListeners = new ArrayList<>();
@@ -397,7 +386,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
             }
             processAssignmentReceived(assignment);
 
-        } else if (allPendingAssignmentsReconciled()) {
+        } else if (targetAssignmentReconciled()) {
             transitionTo(MemberState.STABLE);
         }
     }
@@ -411,20 +400,18 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
      * @param assignment Assignment received from the broker.
      */
     private void processAssignmentReceived(ConsumerGroupHeartbeatResponseData.Assignment assignment) {
-        replaceUnresolvedAssignmentWithNewAssignment(assignment);
-        if (!assignmentUnresolved.equals(currentAssignment)) {
+        replaceTargetAssignmentWithNewAssignment(assignment);
+        if (!targetAssignmentReconciled()) {
             // Transition the member to RECONCILING when receiving a new target
             // assignment from the broker, different from the current assignment. Note that the
             // reconciliation might not be triggered just yet because of missing metadata.
             transitionTo(MemberState.RECONCILING);
-            assignmentReadyToReconcile.clear();
-            resolveMetadataForUnresolvedAssignment();
             reconcile();
         } else {
             // Same assignment received, nothing to reconcile.
             log.debug("Target assignment {} received from the broker is equals to the member " +
                     "current assignment {}. Nothing to reconcile.",
-                assignmentUnresolved, currentAssignment);
+                currentTargetAssignment, currentAssignment);
             // Make sure we transition the member back to STABLE if it was RECONCILING (ex.
             // member was RECONCILING unresolved assignments that were just removed by the
             // broker), or JOINING (member joining received empty assignment).
@@ -435,23 +422,15 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
     }
 
     /**
-     * Overwrite collection of unresolved topic Ids with the new target assignment. This will
-     * effectively achieve the following:
-     *
-     *    - all topics received in assignment will try to be resolved to find their topic names
-     *
-     *    - any topic received in a previous assignment that was still unresolved, and that is
-     *    not included in the assignment anymore, will be removed from the unresolved collection.
-     *    This should be the case when a topic is sent in an assignment, deleted right after, and
-     *    removed from the assignment the next time a broker sends one to the member.
+     * Overwrite the target assignment with the new target assignment.
      *
      * @param assignment Target assignment received from the broker.
      */
-    private void replaceUnresolvedAssignmentWithNewAssignment(
+    private void replaceTargetAssignmentWithNewAssignment(
             ConsumerGroupHeartbeatResponseData.Assignment assignment) {
-        assignmentUnresolved.clear();
+        currentTargetAssignment.clear();
         assignment.topicPartitions().forEach(topicPartitions ->
-            assignmentUnresolved.put(topicPartitions.topicId(), new TreeSet<>(topicPartitions.partitions())));
+            currentTargetAssignment.put(topicPartitions.topicId(), new TreeSet<>(topicPartitions.partitions())));
     }
 
     /**
@@ -731,7 +710,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
         }
 
         if (state == MemberState.ACKNOWLEDGING) {
-            if (allPendingAssignmentsReconciled()) {
+            if (targetAssignmentReconciled()) {
                 transitionTo(MemberState.STABLE);
             } else {
                 log.debug("Member {} with epoch {} transitioned to {} after a heartbeat was sent " +
@@ -765,8 +744,8 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
     /**
      * @return True if there are no assignments waiting to be resolved from metadata or reconciled.
      */
-    private boolean allPendingAssignmentsReconciled() {
-        return assignmentUnresolved.isEmpty() && assignmentReadyToReconcile.isEmpty();
+    private boolean targetAssignmentReconciled() {
+        return currentAssignment.equals(currentTargetAssignment);
     }
 
     @Override
@@ -788,23 +767,29 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
     }
 
     /**
-     * Reconcile the assignment that has been received from the server and for which topic names
-     * are resolved, kept in the {@link #assignmentReadyToReconcile}. This will commit if needed,
-     * trigger the callbacks and update the subscription state. Note that only one reconciliation
+     * Reconcile the assignment that has been received from the server. If for some topics, the
+     * topic ID cannot be matched to a topic name, a metadata update will be triggered and only
+     * the subset of topics that are resolvable will be reconciled. Reconciliation will trigger the
+     * callbacks and update the subscription state. Note that only one reconciliation
      * can be in progress at a time. If there is already another one in progress when this is
      * triggered, it will be no-op, and the assignment will be reconciled on the next
      * reconciliation loop.
      */
-    boolean reconcile() {
+    void reconcile() {
+        if (targetAssignmentReconciled()) {
+            log.debug("Ignoring reconciliation attempt. Target assignment is equal to the " +
+                    "current assignment.");
+            return;
+        }
         if (reconciliationInProgress) {
             log.debug("Ignoring reconciliation attempt. Another reconciliation is already in progress. Assignment " +
-                    assignmentReadyToReconcile + " will be handled in the next reconciliation loop.");
-            return false;
+                currentTargetAssignment + " will be handled in the next reconciliation loop.");
+            return;
         }
 
-        // Make copy of the assignment to reconcile as it could change as new assignments or metadata updates are received
-        SortedSet<TopicIdPartition> assignedTopicIdPartitions = new TreeSet<>(TOPIC_ID_PARTITION_COMPARATOR);
-        assignedTopicIdPartitions.addAll(assignmentReadyToReconcile);
+        // Find the subset of the target assignment that can be resolved to topic names, and trigger a metadata update
+        // if some topic IDs are not resolvable.
+        SortedSet<TopicIdPartition> assignedTopicIdPartitions = findResolvableAssignmentAndTriggerMetadataUpdate();
 
         SortedSet<TopicPartition> ownedPartitions = new TreeSet<>(TOPIC_PARTITION_COMPARATOR);
         ownedPartitions.addAll(subscriptions.assignedPartitions());
@@ -824,7 +809,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
         if (sameAssignmentReceived) {
             log.debug("Ignoring reconciliation attempt. Target assignment ready to reconcile {} " +
                     "is equal to the member current assignment {}.", assignedTopicPartitions, ownedPartitions);
-            return false;
+            return;
         }
 
         markReconciliationInProgress();
@@ -877,8 +862,6 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
 
             revokeAndAssign(assignedTopicIdPartitions, revokedPartitions, addedPartitions);
         });
-
-        return true;
     }
 
     long getExpirationTimeForTimeout(final long timeoutMs) {
@@ -942,11 +925,6 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
                 if (state == MemberState.RECONCILING && !memberHasRejoined) {
                     // Make assignment effective on the broker by transitioning to send acknowledge.
                     transitionTo(MemberState.ACKNOWLEDGING);
-
-                    // Indicate that we completed reconciling a subset of the assignment ready to
-                    // reconcile (new assignments might have been received or discovered in
-                    // metadata).
-                    assignmentReadyToReconcile.removeAll(assignedTopicIdPartitions);
                 } else {
                     String reason = interruptedReconciliationErrorMessage();
                     log.error("Interrupting reconciliation after partitions assigned callback " +
@@ -1003,7 +981,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
     }
 
     /**
-     * Build set of TopicPartition (topic name and partition id) from the target assignment
+     * Build set of TopicIdPartition (topic ID, topic name and partition id) from the target assignment
      * received from the broker (topic IDs and list of partitions).
      *
      * <p>
@@ -1019,11 +997,13 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
      *     </li>
      * </ol>
      */
-    private void resolveMetadataForUnresolvedAssignment() {
-        assignmentReadyToReconcile.clear();
+    private SortedSet<TopicIdPartition> findResolvableAssignmentAndTriggerMetadataUpdate() {
+        final SortedSet<TopicIdPartition> assignmentReadyToReconcile = new TreeSet<>(TOPIC_ID_PARTITION_COMPARATOR);
+        final HashMap<Uuid, SortedSet<Integer>> unresolved = new HashMap<>(currentTargetAssignment);
+
         // Try to resolve topic names from metadata cache or subscription cache, and move
-        // assignments from the "unresolved" collection, to the "readyToReconcile" one.
-        Iterator<Map.Entry<Uuid, SortedSet<Integer>>> it = assignmentUnresolved.entrySet().iterator();
+        // assignments from the "unresolved" collection, to the "assignmentReadyToReconcile" one.
+        Iterator<Map.Entry<Uuid, SortedSet<Integer>>> it = unresolved.entrySet().iterator();
         while (it.hasNext()) {
             Map.Entry<Uuid, SortedSet<Integer>> e = it.next();
             Uuid topicId = e.getKey();
@@ -1032,17 +1012,21 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
             Optional<String> nameFromMetadata = findTopicNameInGlobalOrLocalCache(topicId);
             nameFromMetadata.ifPresent(resolvedTopicName -> {
                 // Name resolved, so assignment is ready for reconciliation.
-                addToAssignmentReadyToReconcile(topicId, resolvedTopicName, topicPartitions);
+                topicPartitions.forEach(tp ->
+                    assignmentReadyToReconcile.add(new TopicIdPartition(topicId, tp, resolvedTopicName))
+                );
                 it.remove();
             });
         }
 
-        if (!assignmentUnresolved.isEmpty()) {
+        if (!unresolved.isEmpty()) {
             log.debug("Topic Ids {} received in target assignment were not found in metadata and " +
                     "are not currently assigned. Requesting a metadata update now to resolve " +
-                    "topic names.", assignmentUnresolved.keySet());
+                    "topic names.", unresolved.keySet());
             metadata.requestUpdate(true);
         }
+
+        return assignmentReadyToReconcile;
     }
 
     /**
@@ -1067,20 +1051,6 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
         }
     }
 
-    /**
-     * Build a TopicPartition for each of the partitions included in the heartbeat topicPartitions,
-     * and using the given topic name. Add the created TopicPartition to the
-     * {@link #assignmentReadyToReconcile}.
-     */
-    private void addToAssignmentReadyToReconcile(Uuid topicId, String topicName, SortedSet<Integer> topicPartitions) {
-        topicPartitions.forEach(tp -> {
-            TopicIdPartition topicIdPartition = new TopicIdPartition(
-                    topicId,
-                    new TopicPartition(topicName, tp));
-            assignmentReadyToReconcile.add(topicIdPartition);
-        });
-    }
-
     /**
      * Revoke partitions. This will:
      * <ul>
@@ -1303,8 +1273,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
      * or the next reconciliation loop). Remove all elements from the topic names cache.
      */
     private void clearPendingAssignmentsAndLocalNamesCache() {
-        assignmentUnresolved.clear();
-        assignmentReadyToReconcile.clear();
+        currentTargetAssignment.clear();
         assignedTopicNamesCache.clear();
     }
 
@@ -1350,21 +1319,39 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
         return this.currentAssignment;
     }
 
-
     /**
      * @return Set of topic IDs received in a target assignment that have not been reconciled yet
-     * because topic names are not in metadata. Visible for testing.
+     * because topic names are not in metadata or reconciliation hasn't finished. Reconciliation
+     * hasn't finished for a topic if the currently active assignment has a different set of partitions
+     * for the topic than the target assignment.
+     *
+     * Visible for testing.
      */
-    Set<Uuid> topicsWaitingForMetadata() {
-        return Collections.unmodifiableSet(assignmentUnresolved.keySet());
+    Set<Uuid> topicsAwaitingReconciliation() {
+        return topicPartitionsAwaitingReconciliation().keySet();
     }
 
     /**
-     * @return Topic partitions received in a target assignment that have been resolved in
-     * metadata and are ready to be reconciled. Visible for testing.
+     * @return Map of topics partitions received in a target assignment that have not been
+     * reconciled yet because topic names are not in metadata or reconciliation hasn't finished.
+     * The values in the map are the sets of partitions contained in the target assignment but
+     * missing from the currently reconciled assignment, for each topic.
+     *
+     * Visible for testing.
      */
-    Set<TopicIdPartition> assignmentReadyToReconcile() {
-        return Collections.unmodifiableSet(assignmentReadyToReconcile);
+    Map<Uuid, SortedSet<Integer>> topicPartitionsAwaitingReconciliation() {
+        final Map<Uuid, SortedSet<Integer>> topicPartitionMap = new HashMap<>();
+        currentTargetAssignment.forEach((topicId, targetPartitions) -> {
+            final SortedSet<Integer> reconciledPartitions = currentAssignment.get(topicId);
+            if (!targetPartitions.equals(reconciledPartitions)) {
+                final TreeSet<Integer> missingPartitions = new TreeSet<>(targetPartitions);
+                if (reconciledPartitions != null) {
+                    missingPartitions.removeAll(reconciledPartitions);
+                }
+                topicPartitionMap.put(topicId, missingPartitions);
+            }
+        });
+        return Collections.unmodifiableMap(topicPartitionMap);
     }
 
     /**
@@ -1379,7 +1366,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
      * When cluster metadata is updated, try to resolve topic names for topic IDs received in
      * assignment that hasn't been resolved yet.
      * <ul>
-     *     <li>Try to find topic names for all unresolved assignments</li>
+     *     <li>Try to find topic names for all assignments</li>
      *     <li>Add discovered topic names to the local topic names cache</li>
      *     <li>If any topics are resolved, trigger a reconciliation process</li>
      *     <li>If some topics still remain unresolved, request another metadata update</li>
@@ -1387,8 +1374,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
      */
     @Override
     public void onUpdate(ClusterResource clusterResource) {
-        resolveMetadataForUnresolvedAssignment();
-        if (!assignmentReadyToReconcile.isEmpty()) {
+        if (state == MemberState.RECONCILING) {
             reconcile();
         }
     }
diff --git a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImplTest.java b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImplTest.java
index 7683a521e0..9c6fa21a5e 100644
--- a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImplTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImplTest.java
@@ -39,6 +39,7 @@ import org.junit.jupiter.api.Test;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -54,6 +55,9 @@ import java.util.stream.Collectors;
 
 import static org.apache.kafka.clients.consumer.internals.AsyncKafkaConsumer.invokeRebalanceCallbacks;
 import static org.apache.kafka.common.requests.ConsumerGroupHeartbeatRequest.LEAVE_GROUP_MEMBER_EPOCH;
+import static org.apache.kafka.common.utils.Utils.mkEntry;
+import static org.apache.kafka.common.utils.Utils.mkMap;
+import static org.apache.kafka.common.utils.Utils.mkSortedSet;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertInstanceOf;
@@ -368,8 +372,7 @@ public class MembershipManagerImplTest {
             Collections.emptyList());
         receiveAssignment(topicId, Arrays.asList(0, 1), membershipManager);
         assertEquals(MemberState.PREPARE_LEAVING, membershipManager.state());
-        assertTrue(membershipManager.assignmentReadyToReconcile().isEmpty());
-        assertTrue(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertTrue(membershipManager.topicsAwaitingReconciliation().isEmpty());
         verify(membershipManager, never()).markReconciliationInProgress();
 
         // When callback completes member should transition to LEAVING.
@@ -474,8 +477,8 @@ public class MembershipManagerImplTest {
         CompletableFuture<Void> commitResult =
                 mockNewAssignmentAndRevocationStuckOnCommit(membershipManager, topicId1, topic1,
                         Arrays.asList(1, 2), true);
-        Set<TopicIdPartition> assignment1 = topicIdPartitionsSet(topicId1, topic1, 1, 2);
-        assertEquals(assignment1, membershipManager.assignmentReadyToReconcile());
+        Map<Uuid, SortedSet<Integer>> assignment1 = topicIdPartitionsMap(topicId1,  1, 2);
+        assertEquals(assignment1, membershipManager.topicPartitionsAwaitingReconciliation());
 
         // Get fenced and rejoin while still reconciling. Get new assignment to reconcile after
         // rejoining.
@@ -489,8 +492,8 @@ public class MembershipManagerImplTest {
         mockOwnedPartitionAndAssignmentReceived(membershipManager, topicId3, "topic3", owned);
         receiveAssignmentAfterRejoin(topicId3, Collections.singletonList(5), membershipManager);
         verifyReconciliationNotTriggered(membershipManager);
-        Set<TopicIdPartition> assignmentAfterRejoin = topicIdPartitionsSet(topicId3, "topic3", 5);
-        assertEquals(assignmentAfterRejoin, membershipManager.assignmentReadyToReconcile());
+        Map<Uuid, SortedSet<Integer>> assignmentAfterRejoin = topicIdPartitionsMap(topicId3, 5);
+        assertEquals(assignmentAfterRejoin, membershipManager.topicPartitionsAwaitingReconciliation());
 
         // Reconciliation completes when the member has already re-joined the group. Should not
         // update the subscription state or send ack.
@@ -500,7 +503,7 @@ public class MembershipManagerImplTest {
 
         // Assignment received after rejoining should be ready to reconcile on the next
         // reconciliation loop.
-        assertEquals(assignmentAfterRejoin, membershipManager.assignmentReadyToReconcile());
+        assertEquals(assignmentAfterRejoin, membershipManager.topicPartitionsAwaitingReconciliation());
     }
 
     /**
@@ -532,13 +535,13 @@ public class MembershipManagerImplTest {
                 mockNewAssignmentAndRevocationStuckOnCommit(membershipManager, topicId2, topic2,
                         Arrays.asList(1, 2), false);
         verify(metadata).requestUpdate(anyBoolean());
-        assertEquals(Collections.singleton(topicId2), membershipManager.topicsWaitingForMetadata());
+        assertEquals(Collections.singleton(topicId2), membershipManager.topicsAwaitingReconciliation());
 
         // Metadata discovered for topic2 while reconciliation in progress to revoke topic1.
         // Should not trigger a new reconciliation because there is one already in progress.
         mockTopicNameInMetadataCache(Collections.singletonMap(topicId2, topic2), true);
         membershipManager.onUpdate(null);
-        assertEquals(Collections.emptySet(), membershipManager.topicsWaitingForMetadata());
+        assertEquals(Collections.singleton(topicId2), membershipManager.topicsAwaitingReconciliation());
         verifyReconciliationNotTriggered(membershipManager);
 
         // Reconciliation in progress completes. Should be applied revoking topic 1 only. Newly
@@ -552,8 +555,62 @@ public class MembershipManagerImplTest {
 
         // Pending assignment that was discovered in metadata should be ready to reconcile in the
         // next reconciliation loop.
-        Set<TopicIdPartition> topic2Assignment = topicIdPartitionsSet(topicId2, topic2, 1, 2);
-        assertEquals(topic2Assignment, membershipManager.assignmentReadyToReconcile());
+        Map<Uuid, SortedSet<Integer>> topic2Assignment = topicIdPartitionsMap(topicId2,  1, 2);
+        assertEquals(topic2Assignment, membershipManager.topicPartitionsAwaitingReconciliation());
+    }
+
+    // Tests the case where topic metadata is not available at the time of the assignment,
+    // but is made available later.
+    @Test
+    public void testDelayedMetadataUsedToCompleteAssignment() {
+
+        Uuid topicId1 = Uuid.randomUuid();
+        String topic1 = "topic1";
+        final TopicIdPartition topicId1Partition0 = new TopicIdPartition(topicId1, new TopicPartition(topic1, 0));
+
+        Uuid topicId2 = Uuid.randomUuid();
+        String topic2 = "topic2";
+        final TopicIdPartition topicId2Partition0 = new TopicIdPartition(topicId2, new TopicPartition(topic2, 0));
+
+        // Receive assignment with only topic1-0, entering STABLE state.
+        MembershipManagerImpl membershipManager =
+            mockMemberSuccessfullyReceivesAndAcksAssignment(topicId1, topic1, Collections.singletonList(0));
+
+        membershipManager.onHeartbeatRequestSent();
+
+        assertEquals(MemberState.STABLE, membershipManager.state());
+        when(subscriptionState.assignedPartitions()).thenReturn(getTopicPartitions(Collections.singleton(topicId1Partition0)));
+        clearInvocations(membershipManager, subscriptionState);
+
+        // New assignment adding a new topic2-0 (not in metadata).
+        // No reconciliation triggered, because new topic in assignment is waiting for metadata.
+
+        Map<Uuid, SortedSet<Integer>> newAssignment =
+            mkMap(
+                mkEntry(topicId1, mkSortedSet(0)),
+                mkEntry(topicId2, mkSortedSet(0))
+            );
+
+        receiveAssignment(newAssignment, membershipManager);
+
+        verifyReconciliationNotTriggered(membershipManager);
+        assertEquals(MemberState.RECONCILING, membershipManager.state());
+        assertEquals(Collections.singleton(topicId2), membershipManager.topicsAwaitingReconciliation());
+        verify(metadata).requestUpdate(anyBoolean());
+        clearInvocations(membershipManager, commitRequestManager);
+
+        // Metadata discovered for topic2. Should trigger reconciliation to complete the assignment,
+        // with membership manager entering ACKNOWLEDGING state.
+
+        Map<Uuid, String> fullTopicMetadata = mkMap(
+            mkEntry(topicId1, topic1),
+            mkEntry(topicId2, topic2)
+        );
+        when(metadata.topicNames()).thenReturn(fullTopicMetadata);
+
+        membershipManager.onUpdate(null);
+
+        verifyReconciliationTriggeredAndCompleted(membershipManager, Arrays.asList(topicId1Partition0, topicId2Partition0));
     }
 
     @Test
@@ -745,13 +802,13 @@ public class MembershipManagerImplTest {
     public void testNewAssignmentReplacesPreviousOneWaitingOnMetadata() {
         MembershipManagerImpl membershipManager = mockJoinAndReceiveAssignment(false);
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertFalse(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertFalse(membershipManager.topicsAwaitingReconciliation().isEmpty());
 
         // When the ack is sent nothing should change. Member still has nothing to reconcile,
         // only topics waiting for metadata.
         membershipManager.onHeartbeatRequestSent();
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertFalse(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertFalse(membershipManager.topicsAwaitingReconciliation().isEmpty());
 
         // New target assignment received while there is another one waiting to be resolved
         // and reconciled. This assignment does not include the previous one that is waiting
@@ -769,7 +826,7 @@ public class MembershipManagerImplTest {
         // because the first assignment that was not resolved should have been discarded
         membershipManager.onHeartbeatRequestSent();
         assertEquals(MemberState.STABLE, membershipManager.state());
-        assertTrue(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertTrue(membershipManager.topicsAwaitingReconciliation().isEmpty());
     }
 
     /**
@@ -782,13 +839,13 @@ public class MembershipManagerImplTest {
     public void testNewEmptyAssignmentReplacesPreviousOneWaitingOnMetadata() {
         MembershipManagerImpl membershipManager = mockJoinAndReceiveAssignment(false);
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertFalse(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertFalse(membershipManager.topicsAwaitingReconciliation().isEmpty());
 
         // When the ack is sent nothing should change. Member still has nothing to reconcile,
         // only topics waiting for metadata.
         membershipManager.onHeartbeatRequestSent();
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertFalse(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertFalse(membershipManager.topicsAwaitingReconciliation().isEmpty());
 
         // New target assignment received while there is another one waiting to be resolved
         // and reconciled. This assignment does not include the previous one that is waiting
@@ -806,7 +863,7 @@ public class MembershipManagerImplTest {
     public void testNewAssignmentNotInMetadataReplacesPreviousOneWaitingOnMetadata() {
         MembershipManagerImpl membershipManager = mockJoinAndReceiveAssignment(false);
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertFalse(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertFalse(membershipManager.topicsAwaitingReconciliation().isEmpty());
 
         // New target assignment (not found in metadata) received while there is another one
         // waiting to be resolved and reconciled. This assignment does not include the previous
@@ -816,8 +873,8 @@ public class MembershipManagerImplTest {
         when(metadata.topicNames()).thenReturn(Collections.emptyMap());
         receiveAssignment(topicId, Collections.singletonList(0), membershipManager);
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertFalse(membershipManager.topicsWaitingForMetadata().isEmpty());
-        assertEquals(topicId, membershipManager.topicsWaitingForMetadata().iterator().next());
+        assertFalse(membershipManager.topicsAwaitingReconciliation().isEmpty());
+        assertEquals(topicId, membershipManager.topicsAwaitingReconciliation().iterator().next());
     }
 
     /**
@@ -832,7 +889,7 @@ public class MembershipManagerImplTest {
         Uuid topicId = Uuid.randomUuid();
         receiveAssignment(topicId, Collections.singletonList(1), membershipManager);
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertFalse(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertFalse(membershipManager.topicsAwaitingReconciliation().isEmpty());
 
         // Metadata update received, including the missing topic name.
         String topicName = "topic1";
@@ -845,7 +902,7 @@ public class MembershipManagerImplTest {
         Set<TopicPartition> expectedAssignment = Collections.singleton(new TopicPartition(topicName, 1));
         verify(subscriptionState).assignFromSubscribed(expectedAssignment);
         assertEquals(MemberState.ACKNOWLEDGING, membershipManager.state());
-        assertTrue(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertTrue(membershipManager.topicsAwaitingReconciliation().isEmpty());
     }
 
     /**
@@ -875,7 +932,7 @@ public class MembershipManagerImplTest {
         MembershipManagerImpl membershipManager = mockJoinAndReceiveAssignment(true, assignment);
         assertEquals(MemberState.ACKNOWLEDGING, membershipManager.state());
         verify(metadata).requestUpdate(anyBoolean());
-        assertEquals(Collections.singleton(topic2), membershipManager.topicsWaitingForMetadata());
+        assertEquals(Collections.singleton(topic2), membershipManager.topicsAwaitingReconciliation());
 
         // When the ack is sent the member should go back to RECONCILING because it still has
         // unresolved assignment to be reconciled.
@@ -887,7 +944,7 @@ public class MembershipManagerImplTest {
         clearInvocations(subscriptionState);
         membershipManager.onHeartbeatResponseReceived(createConsumerGroupHeartbeatResponse(assignment).data());
         assertEquals(MemberState.RECONCILING, membershipManager.state());
-        assertEquals(Collections.singleton(topic2), membershipManager.topicsWaitingForMetadata());
+        assertEquals(Collections.singleton(topic2), membershipManager.topicsAwaitingReconciliation());
         verify(subscriptionState, never()).assignFromSubscribed(anyCollection());
     }
 
@@ -1042,7 +1099,7 @@ public class MembershipManagerImplTest {
 
         // Should not trigger reconciliation, and request a metadata update.
         verifyReconciliationNotTriggered(membershipManager);
-        assertEquals(Collections.singleton(topicId), membershipManager.topicsWaitingForMetadata());
+        assertEquals(Collections.singleton(topicId), membershipManager.topicsAwaitingReconciliation());
         verify(metadata).requestUpdate(anyBoolean());
 
         String topicName = "topic1";
@@ -1053,7 +1110,7 @@ public class MembershipManagerImplTest {
         List<TopicIdPartition> expectedAssignmentReconciled = topicIdPartitions(topicId, topicName, 0, 1);
         verifyReconciliationTriggeredAndCompleted(membershipManager, expectedAssignmentReconciled);
         assertEquals(MemberState.ACKNOWLEDGING, membershipManager.state());
-        assertTrue(membershipManager.topicsWaitingForMetadata().isEmpty());
+        assertTrue(membershipManager.topicsAwaitingReconciliation().isEmpty());
     }
 
     @Test
@@ -1071,7 +1128,7 @@ public class MembershipManagerImplTest {
 
         // Should not trigger reconciliation, and request a metadata update.
         verifyReconciliationNotTriggered(membershipManager);
-        assertEquals(Collections.singleton(topicId), membershipManager.topicsWaitingForMetadata());
+        assertEquals(Collections.singleton(topicId), membershipManager.topicsAwaitingReconciliation());
         verify(metadata).requestUpdate(anyBoolean());
 
         // Metadata update received, but still without the unresolved topic in it. Should keep
@@ -1079,7 +1136,7 @@ public class MembershipManagerImplTest {
         when(metadata.topicNames()).thenReturn(Collections.emptyMap());
         membershipManager.onUpdate(null);
         verifyReconciliationNotTriggered(membershipManager);
-        assertEquals(Collections.singleton(topicId), membershipManager.topicsWaitingForMetadata());
+        assertEquals(Collections.singleton(topicId), membershipManager.topicsAwaitingReconciliation());
         verify(metadata, times(2)).requestUpdate(anyBoolean());
     }
 
@@ -1620,7 +1677,7 @@ public class MembershipManagerImplTest {
     private void mockOwnedPartitionAndAssignmentReceived(MembershipManagerImpl membershipManager,
                                                          Uuid topicId,
                                                          String topicName,
-                                                         List<TopicIdPartition> previouslyOwned) {
+                                                         Collection<TopicIdPartition> previouslyOwned) {
         when(subscriptionState.assignedPartitions()).thenReturn(getTopicPartitions(previouslyOwned));
         membershipManager.updateCurrentAssignment(new HashSet<>(previouslyOwned));
         when(metadata.topicNames()).thenReturn(Collections.singletonMap(topicId, topicName));
@@ -1628,7 +1685,7 @@ public class MembershipManagerImplTest {
         when(subscriptionState.rebalanceListener()).thenReturn(Optional.empty()).thenReturn(Optional.empty());
     }
 
-    private Set<TopicPartition> getTopicPartitions(List<TopicIdPartition> topicIdPartitions) {
+    private Set<TopicPartition> getTopicPartitions(Collection<TopicIdPartition> topicIdPartitions) {
         return topicIdPartitions.stream().map(topicIdPartition ->
                 new TopicPartition(topicIdPartition.topic(), topicIdPartition.partition()))
             .collect(Collectors.toSet());
@@ -1676,6 +1733,16 @@ public class MembershipManagerImplTest {
         return membershipManager;
     }
 
+    private void receiveAssignment(Map<Uuid, SortedSet<Integer>> topicIdPartitionList, MembershipManager membershipManager) {
+        ConsumerGroupHeartbeatResponseData.Assignment targetAssignment = new ConsumerGroupHeartbeatResponseData.Assignment()
+            .setTopicPartitions(topicIdPartitionList.entrySet().stream().map(tp ->
+                new ConsumerGroupHeartbeatResponseData.TopicPartitions()
+                    .setTopicId(tp.getKey())
+                    .setPartitions(new ArrayList<>(tp.getValue()))).collect(Collectors.toList()));
+        ConsumerGroupHeartbeatResponse heartbeatResponse = createConsumerGroupHeartbeatResponse(targetAssignment);
+        membershipManager.onHeartbeatResponseReceived(heartbeatResponse.data());
+    }
+
     private void receiveAssignment(Uuid topicId, List<Integer> partitions, MembershipManager membershipManager) {
         ConsumerGroupHeartbeatResponseData.Assignment targetAssignment = new ConsumerGroupHeartbeatResponseData.Assignment()
                 .setTopicPartitions(Collections.singletonList(
