diff --git a/clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java b/clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java
index 2e2f8646bf..5d1fc9a996 100644
--- a/clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java
+++ b/clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java
@@ -51,7 +51,6 @@ public class FetchRequest extends AbstractRequest {
     public static final int FUTURE_LOCAL_REPLICA_ID = -3;
 
     private final FetchRequestData data;
-    private volatile LinkedHashMap<TopicIdPartition, PartitionData> fetchData = null;
 
     // This is an immutable read-only structures derived from FetchRequestData
     private final FetchMetadata metadata;
@@ -395,38 +394,29 @@ public class FetchRequest extends AbstractRequest {
     // For versions < 13, builds the partitionData map using only the FetchRequestData.
     // For versions 13+, builds the partitionData map using both the FetchRequestData and a mapping of topic IDs to names.
     public Map<TopicIdPartition, PartitionData> fetchData(Map<Uuid, String> topicNames) {
-        if (fetchData == null) {
-            synchronized (this) {
-                if (fetchData == null) {
-                    // Assigning the lazy-initialized `fetchData` in the last step
-                    // to avoid other threads accessing a half-initialized object.
-                    final LinkedHashMap<TopicIdPartition, PartitionData> fetchDataTmp = new LinkedHashMap<>();
-                    final short version = version();
-                    data.topics().forEach(fetchTopic -> {
-                        String name;
-                        if (version < 13) {
-                            name = fetchTopic.topic(); // can't be null
-                        } else {
-                            name = topicNames.get(fetchTopic.topicId());
-                        }
-                        fetchTopic.partitions().forEach(fetchPartition ->
-                                // Topic name may be null here if the topic name was unable to be resolved using the topicNames map.
-                                fetchDataTmp.put(new TopicIdPartition(fetchTopic.topicId(), new TopicPartition(name, fetchPartition.partition())),
-                                        new PartitionData(
-                                                fetchTopic.topicId(),
-                                                fetchPartition.fetchOffset(),
-                                                fetchPartition.logStartOffset(),
-                                                fetchPartition.partitionMaxBytes(),
-                                                optionalEpoch(fetchPartition.currentLeaderEpoch()),
-                                                optionalEpoch(fetchPartition.lastFetchedEpoch())
-                                        )
-                                )
-                        );
-                    });
-                    fetchData = fetchDataTmp;
-                }
+        final LinkedHashMap<TopicIdPartition, PartitionData> fetchData = new LinkedHashMap<>();
+        final short version = version();
+        data.topics().forEach(fetchTopic -> {
+            String name;
+            if (version < 13) {
+                name = fetchTopic.topic(); // can't be null
+            } else {
+                name = topicNames.get(fetchTopic.topicId());
             }
-        }
+            fetchTopic.partitions().forEach(fetchPartition ->
+                // Topic name may be null here if the topic name was unable to be resolved using the topicNames map.
+                fetchData.put(new TopicIdPartition(fetchTopic.topicId(), new TopicPartition(name, fetchPartition.partition())),
+                    new PartitionData(
+                        fetchTopic.topicId(),
+                        fetchPartition.fetchOffset(),
+                        fetchPartition.logStartOffset(),
+                        fetchPartition.partitionMaxBytes(),
+                        optionalEpoch(fetchPartition.currentLeaderEpoch()),
+                        optionalEpoch(fetchPartition.lastFetchedEpoch())
+                    )
+                )
+            );
+        });
         return fetchData;
     }
 
diff --git a/clients/src/test/java/org/apache/kafka/common/requests/FetchRequestTest.java b/clients/src/test/java/org/apache/kafka/common/requests/FetchRequestTest.java
index ebda210d77..2d8652bae4 100644
--- a/clients/src/test/java/org/apache/kafka/common/requests/FetchRequestTest.java
+++ b/clients/src/test/java/org/apache/kafka/common/requests/FetchRequestTest.java
@@ -275,19 +275,64 @@ public class FetchRequestTest {
     }
 
     private FetchRequest createFetchRequestByVersion(short version, Uuid topicId, TopicIdPartition tp) {
-        Map<TopicPartition, FetchRequest.PartitionData> partitionData = Collections.singletonMap(tp.topicPartition(),
-                new FetchRequest.PartitionData(topicId, 0, 0, 0, Optional.empty()));
+        return createFetchRequestByVersion(version, tp, new FetchRequest.PartitionData(topicId, 0, 0, 0, Optional.empty()));
+    }
+
+    private FetchRequest createFetchRequestByVersion(short version, TopicIdPartition tp,
+                                                     FetchRequest.PartitionData partitionData) {
+        Map<TopicPartition, FetchRequest.PartitionData> partitionDataMap = Collections.singletonMap(tp.topicPartition(), partitionData);
         if (version >= 13) {
             return FetchRequest.Builder
-                    .forReplica(version, 0, 1, 1, 1, partitionData)
-                    .replaced(Collections.singletonList(tp))
-                    .metadata(FetchMetadata.newIncremental(123)).build(version);
+                .forReplica(version, 0, 1, 1, 1, partitionDataMap)
+                .replaced(Collections.singletonList(tp))
+                .metadata(FetchMetadata.newIncremental(123)).build(version);
         } else {
             return FetchRequest.Builder
-                    .forReplica(version, 0, 1, 1, 1, partitionData)
-                    .removed(Collections.singletonList(tp))
-                    .metadata(FetchMetadata.newIncremental(123)).build(version);
+                .forReplica(version, 0, 1, 1, 1, partitionDataMap)
+                .removed(Collections.singletonList(tp))
+                .metadata(FetchMetadata.newIncremental(123)).build(version);
         }
     }
 
+    @ParameterizedTest
+    @MethodSource("fetchVersions")
+    public void testFetchDataNoCacheData(short version) {
+        Uuid topicId = Uuid.randomUuid();
+        int partition = 0;
+        TopicIdPartition tp = new TopicIdPartition(topicId, partition, "topic1");
+        long fetchOffset = 118L;
+        long logStartOffset = 119L;
+        int maxBytes = 120;
+        Optional<Integer> currentLeaderEpoch = Optional.of(121);
+        FetchRequest.PartitionData partitionData = new FetchRequest.PartitionData(topicId, fetchOffset, logStartOffset, maxBytes, currentLeaderEpoch);
+        FetchRequest fetchRequest = createFetchRequestByVersion(version, tp, partitionData);
+        Map<Uuid, String> topicNames = Collections.singletonMap(topicId, tp.topic());
+        Map<TopicIdPartition, FetchRequest.PartitionData> topicIdPartitionMap = fetchRequest.fetchData(topicNames);
+
+        assertEquals(topicNames.size(), topicIdPartitionMap.size());
+        topicIdPartitionMap.forEach((topicIdPartition, partitionDataTmp) -> {
+            assertEquals(tp.topic(), topicIdPartition.topic());
+            assertEquals(topicId, topicIdPartition.topicId());
+            assertEquals(tp.partition(), topicIdPartition.partition());
+            assertEquals(tp.topicPartition(), topicIdPartition.topicPartition());
+            assertEquals(fetchOffset, partitionDataTmp.fetchOffset);
+            assertEquals(logStartOffset, partitionDataTmp.logStartOffset);
+            assertEquals(maxBytes, partitionDataTmp.maxBytes);
+            assertEquals(currentLeaderEpoch, partitionDataTmp.currentLeaderEpoch);
+        });
+
+        String expectedTopic = version >= 13 ? null : tp.topic();
+        topicIdPartitionMap = fetchRequest.fetchData(Collections.emptyMap());
+        assertEquals(1, topicIdPartitionMap.size());
+        topicIdPartitionMap.forEach((topicIdPartition, partitionDataTmp) -> {
+            assertEquals(expectedTopic, topicIdPartition.topic());
+            assertEquals(topicId, topicIdPartition.topicId());
+            assertEquals(tp.partition(), topicIdPartition.partition());
+            assertEquals(new TopicPartition(expectedTopic, partition), topicIdPartition.topicPartition());
+            assertEquals(fetchOffset, partitionDataTmp.fetchOffset);
+            assertEquals(logStartOffset, partitionDataTmp.logStartOffset);
+            assertEquals(maxBytes, partitionDataTmp.maxBytes);
+            assertEquals(currentLeaderEpoch, partitionDataTmp.currentLeaderEpoch);
+        });
+    }
 }
