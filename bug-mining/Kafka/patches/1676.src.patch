diff --git a/core/src/main/scala/kafka/Kafka.scala b/core/src/main/scala/kafka/Kafka.scala
index 7c5b420bc4..062ff30329 100755
--- a/core/src/main/scala/kafka/Kafka.scala
+++ b/core/src/main/scala/kafka/Kafka.scala
@@ -18,6 +18,7 @@
 package kafka
 
 import java.util.Properties
+import sun.misc.{Signal, SignalHandler}
 
 import joptsimple.OptionParser
 import kafka.utils.Implicits._
@@ -25,6 +26,7 @@ import kafka.server.{KafkaServer, KafkaServerStartable}
 import kafka.utils.{CommandLineUtils, Exit, Logging}
 import org.apache.kafka.common.utils.Utils
 
+import scala.collection.mutable
 import scala.collection.JavaConverters._
 
 object Kafka extends Logging {
@@ -41,10 +43,10 @@ object Kafka extends Logging {
 
     val props = Utils.loadProps(args(0))
 
-    if(args.length > 1) {
+    if (args.length > 1) {
       val options = optionParser.parse(args.slice(1, args.length): _*)
 
-      if(options.nonOptionArguments().size() > 0) {
+      if (options.nonOptionArguments().size() > 0) {
         CommandLineUtils.printUsageAndDie(optionParser, "Found non argument parameters: " + options.nonOptionArguments().toArray.mkString(","))
       }
 
@@ -53,12 +55,33 @@ object Kafka extends Logging {
     props
   }
 
+  private def registerLoggingSignalHandler(): Unit = {
+    val jvmSignalHandlers = mutable.Map[String, SignalHandler]()
+    val handler = new SignalHandler() {
+      override def handle(signal: Signal) {
+        info(s"Terminating process due to signal $signal")
+        jvmSignalHandlers.get(signal.getName).foreach(_.handle(signal))
+      }
+    }
+    def registerHandler(signalName: String) {
+      val oldHandler = Signal.handle(new Signal(signalName), handler)
+      if (oldHandler != null)
+        jvmSignalHandlers.put(signalName, oldHandler)
+    }
+    registerHandler("TERM")
+    registerHandler("INT")
+    registerHandler("HUP")
+  }
+
   def main(args: Array[String]): Unit = {
     try {
       val serverProps = getPropsFromArgs(args)
       val kafkaServerStartable = KafkaServerStartable.fromProps(serverProps)
 
-      // attach shutdown handler to catch control-c
+      // register signal handler to log termination due to SIGTERM, SIGHUP and SIGINT (control-c)
+      registerLoggingSignalHandler()
+
+      // attach shutdown handler to catch terminating signals as well as normal termination
       Runtime.getRuntime().addShutdownHook(new Thread("kafka-shutdown-hook") {
         override def run(): Unit = kafkaServerStartable.shutdown()
       })
diff --git a/core/src/main/scala/kafka/utils/Exit.scala b/core/src/main/scala/kafka/utils/Exit.scala
index a4120b76f1..3e29ddd857 100644
--- a/core/src/main/scala/kafka/utils/Exit.scala
+++ b/core/src/main/scala/kafka/utils/Exit.scala
@@ -19,7 +19,7 @@ package kafka.utils
 import org.apache.kafka.common.utils.{Exit => JExit}
 
 /**
-  * Internal class that should be used instead of `Exit.exit()` and `Runtime.getRuntime().halt()` so that tests can
+  * Internal class that should be used instead of `System.exit()` and `Runtime.getRuntime().halt()` so that tests can
   * easily change the behaviour.
   */
 object Exit {
