diff --git a/clients/src/main/java/org/apache/kafka/common/utils/Utils.java b/clients/src/main/java/org/apache/kafka/common/utils/Utils.java
index df223b69fb..9f84c4fdea 100755
--- a/clients/src/main/java/org/apache/kafka/common/utils/Utils.java
+++ b/clients/src/main/java/org/apache/kafka/common/utils/Utils.java
@@ -1281,30 +1281,41 @@ public final class Utils {
 
     /**
      * Convert timestamp to an epoch value
-     * @param timestamp to be converted
-     * @return epoch value of a given timestamp
-     * @throws ParseException for timestamp that doesn't follow ISO8601 format
+     * @param timestamp the timestamp to be converted, the accepted formats are:
+     *                 (1) yyyy-MM-dd'T'HH:mm:ss.SSS, ex: 2020-11-10T16:51:38.198
+     *                 (2) yyyy-MM-dd'T'HH:mm:ss.SSSZ, ex: 2020-11-10T16:51:38.198+0800
+     *                 (3) yyyy-MM-dd'T'HH:mm:ss.SSSX, ex: 2020-11-10T16:51:38.198+08
+     *                 (4) yyyy-MM-dd'T'HH:mm:ss.SSSXX, ex: 2020-11-10T16:51:38.198+0800
+     *                 (5) yyyy-MM-dd'T'HH:mm:ss.SSSXXX, ex: 2020-11-10T16:51:38.198+08:00
+     *
+     * @return epoch value of a given timestamp (i.e. the number of milliseconds since January 1, 1970, 00:00:00 GMT)
+     * @throws ParseException for timestamp that doesn't follow ISO8601 format or the format is not expected
      */
-    public static long getDateTime(String timestamp) throws ParseException {
+    public static long getDateTime(String timestamp) throws ParseException, IllegalArgumentException {
+        if (timestamp == null) {
+            throw new IllegalArgumentException("Error parsing timestamp with null value");
+        }
+
         final String[] timestampParts = timestamp.split("T");
         if (timestampParts.length < 2) {
             throw new ParseException("Error parsing timestamp. It does not contain a 'T' according to ISO8601 format", timestamp.length());
         }
 
         final String secondPart = timestampParts[1];
-        if (secondPart == null || secondPart.isEmpty()) {
-            throw new ParseException("Error parsing timestamp. Time part after 'T' is null or empty", timestamp.length());
-        }
-
         if (!(secondPart.contains("+") || secondPart.contains("-") || secondPart.contains("Z"))) {
             timestamp = timestamp + "Z";
         }
 
+        SimpleDateFormat simpleDateFormat = new SimpleDateFormat();
+        // strictly parsing the date/time format
+        simpleDateFormat.setLenient(false);
         try {
-            final Date date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(timestamp);
+            simpleDateFormat.applyPattern("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
+            final Date date = simpleDateFormat.parse(timestamp);
             return date.getTime();
         } catch (final ParseException e) {
-            final Date date = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSX").parse(timestamp);
+            simpleDateFormat.applyPattern("yyyy-MM-dd'T'HH:mm:ss.SSSX");
+            final Date date = simpleDateFormat.parse(timestamp);
             return date.getTime();
         }
     }
diff --git a/clients/src/test/java/org/apache/kafka/common/utils/UtilsTest.java b/clients/src/test/java/org/apache/kafka/common/utils/UtilsTest.java
index 82c24f0a51..320c10648e 100755
--- a/clients/src/test/java/org/apache/kafka/common/utils/UtilsTest.java
+++ b/clients/src/test/java/org/apache/kafka/common/utils/UtilsTest.java
@@ -19,6 +19,7 @@ package org.apache.kafka.common.utils;
 import org.apache.kafka.common.config.ConfigException;
 import org.apache.kafka.test.TestUtils;
 import org.junit.Test;
+import org.junit.function.ThrowingRunnable;
 import org.mockito.stubbing.OngoingStubbing;
 
 import java.io.Closeable;
@@ -32,6 +33,11 @@ import java.nio.channels.FileChannel;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.StandardOpenOption;
+import java.time.LocalDateTime;
+import java.time.format.DateTimeFormatter;
+import java.time.format.DateTimeFormatterBuilder;
+import java.time.temporal.ChronoField;
+import java.time.temporal.ChronoUnit;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashSet;
@@ -800,16 +806,51 @@ public class UtilsTest {
     }
 
     @Test
-    public void shouldThrowOnInvalidDateFormat() {
+    public void shouldThrowOnInvalidDateFormatOrNullTimestamp() {
         //check some invalid formats
-        assertThat(assertThrows(ParseException.class, () -> {
-            invokeGetDateTimeMethod(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss"));
-        }).getMessage(), containsString("Unparseable date"));
+        // test null timestamp
+        assertThat(assertThrows(IllegalArgumentException.class, () -> {
+            Utils.getDateTime(null);
+        }).getMessage(), containsString("Error parsing timestamp with null value"));
 
-        assertThat(assertThrows(ParseException.class, () -> {
+        // test pattern: yyyy-MM-dd'T'HH:mm:ss.X
+        checkExceptionForGetDateTimeMethod(() -> {
             invokeGetDateTimeMethod(new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.X"));
-        }).getMessage(), containsString("Unparseable date"));
+        });
+
+        // test pattern: yyyy-MM-dd HH:mm:ss
+        assertThat(assertThrows(ParseException.class, () -> {
+            invokeGetDateTimeMethod(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));
+        }).getMessage(), containsString("It does not contain a 'T' according to ISO8601 format"));
+
+        // KAFKA-10685: use DateTimeFormatter generate micro/nano second timestamp
+        final DateTimeFormatter formatter = new DateTimeFormatterBuilder()
+            .appendPattern("yyyy-MM-dd'T'HH:mm:ss")
+            .appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true)
+            .toFormatter();
+        final LocalDateTime timestampWithNanoSeconds = LocalDateTime.of(2020, 11, 9, 12, 34, 56, 123456789);
+        final LocalDateTime timestampWithMicroSeconds = timestampWithNanoSeconds.truncatedTo(ChronoUnit.MICROS);
+        final LocalDateTime timestampWithSeconds = timestampWithNanoSeconds.truncatedTo(ChronoUnit.SECONDS);
+
+        // test pattern: yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS
+        checkExceptionForGetDateTimeMethod(() -> {
+            Utils.getDateTime(formatter.format(timestampWithNanoSeconds));
+        });
+
+        // test pattern: yyyy-MM-dd'T'HH:mm:ss.SSSSSS
+        checkExceptionForGetDateTimeMethod(() -> {
+            Utils.getDateTime(formatter.format(timestampWithMicroSeconds));
+        });
+
+        // test pattern: yyyy-MM-dd'T'HH:mm:ss
+        checkExceptionForGetDateTimeMethod(() -> {
+            Utils.getDateTime(formatter.format(timestampWithSeconds));
+        });
+    }
 
+    private void checkExceptionForGetDateTimeMethod(ThrowingRunnable runnable) {
+        assertThat(assertThrows(ParseException.class, runnable)
+            .getMessage(), containsString("Unparseable date"));
     }
 
     private void invokeGetDateTimeMethod(final SimpleDateFormat format) throws ParseException {
