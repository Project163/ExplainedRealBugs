diff --git a/core/src/main/scala/kafka/log/OffsetIndex.scala b/core/src/main/scala/kafka/log/OffsetIndex.scala
index aa654e831f..80dd4305a0 100644
--- a/core/src/main/scala/kafka/log/OffsetIndex.scala
+++ b/core/src/main/scala/kafka/log/OffsetIndex.scala
@@ -301,7 +301,7 @@ class OffsetIndex(@volatile var file: File, val baseOffset: Long, val maxIndexSi
   /**
    * Forcefully free the buffer's mmap. We do this only on windows.
    */
-  def forceUnmap(m: MappedByteBuffer) {
+  private def forceUnmap(m: MappedByteBuffer) {
     try {
       if(m.isInstanceOf[sun.nio.ch.DirectBuffer])
         (m.asInstanceOf[sun.nio.ch.DirectBuffer]).cleaner().clean()
diff --git a/core/src/main/scala/kafka/server/OffsetCheckpoint.scala b/core/src/main/scala/kafka/server/OffsetCheckpoint.scala
index 815c90d703..b5719f89f7 100644
--- a/core/src/main/scala/kafka/server/OffsetCheckpoint.scala
+++ b/core/src/main/scala/kafka/server/OffsetCheckpoint.scala
@@ -53,17 +53,17 @@ class OffsetCheckpoint(val file: File) extends Logging {
       
         // flush and overwrite old file
         writer.flush()
-        // swap new offset checkpoint file with previous one
-        if(!temp.renameTo(file)) {
-          // renameTo() fails on Windows if the destination file exists.
-          file.delete()
-          if(!temp.renameTo(file)) {
-            throw new IOException("File rename from %s to %s failed.".format(temp.getAbsolutePath, file.getAbsolutePath))
-          }
-        }
       } finally {
         writer.close()
       }
+      
+      // swap new offset checkpoint file with previous one
+      if(!temp.renameTo(file)) {
+        // renameTo() fails on Windows if the destination file exists.
+        file.delete()
+        if(!temp.renameTo(file))
+          throw new IOException("File rename from %s to %s failed.".format(temp.getAbsolutePath, file.getAbsolutePath))
+      }
     }
   }
 
