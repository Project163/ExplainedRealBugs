diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/Windows.java b/streams/src/main/java/org/apache/kafka/streams/kstream/Windows.java
index 06cacb4fa1..c64a80f2a7 100644
--- a/streams/src/main/java/org/apache/kafka/streams/kstream/Windows.java
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/Windows.java
@@ -17,9 +17,7 @@
 
 package org.apache.kafka.streams.kstream;
 
-
 import java.util.Map;
-import java.util.concurrent.atomic.AtomicInteger;
 
 /**
  * The window specification interface that can be extended for windowing operation in joins and aggregations.
@@ -32,8 +30,6 @@ public abstract class Windows<W extends Window> {
 
     private static final long DEFAULT_MAINTAIN_DURATION = 24 * 60 * 60 * 1000L;   // one day
 
-    private static final AtomicInteger NAME_INDEX = new AtomicInteger(0);
-
     protected String name;
 
     private long maintainDurationMs;
@@ -86,7 +82,7 @@ public abstract class Windows<W extends Window> {
     }
 
     /**
-     * Creates all windows that contain the provided timestamp.
+     * Creates all windows that contain the provided timestamp, indexed by non-negative window start timestamps.
      *
      * @param timestamp  the timestamp window should get created for
      * @return  a map of {@code windowStartTimestamp -> Window} entries
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java
index 6911a4546e..7e5baf3067 100644
--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java
@@ -20,6 +20,7 @@ package org.apache.kafka.streams.processor.internals;
 import org.apache.kafka.clients.consumer.ConsumerRecord;
 import org.apache.kafka.common.TopicPartition;
 import org.apache.kafka.common.record.TimestampType;
+import org.apache.kafka.streams.errors.StreamsException;
 import org.apache.kafka.streams.processor.TimestampExtractor;
 
 import java.util.ArrayDeque;
@@ -84,6 +85,10 @@ public class RecordQueue {
                                                                          rawRecord.serializedValueSize(), key, value);
             long timestamp = timestampExtractor.extract(record);
 
+            // validate that timestamp must be non-negative
+            if (timestamp < 0)
+                throw new StreamsException("Extracted timestamp value is negative, which is not allowed.");
+
             StampedRecord stampedRecord = new StampedRecord(record, timestamp);
 
             fifoQueue.addLast(stampedRecord);
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java
index d9efb6debb..e7e24fb659 100644
--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java
@@ -209,7 +209,12 @@ public class StreamTask extends AbstractTask implements Punctuator {
     public boolean maybePunctuate() {
         long timestamp = partitionGroup.timestamp();
 
-        return punctuationQueue.mayPunctuate(timestamp, this);
+        // if the timestamp is not known yet, meaning there is not enough data accumulated
+        // to reason stream partition time, then skip.
+        if (timestamp == TimestampTracker.NOT_KNOWN)
+            return false;
+        else
+            return punctuationQueue.mayPunctuate(timestamp, this);
     }
 
     /**
