diff --git a/core/src/main/scala/kafka/admin/CreateTopicCommand.scala b/core/src/main/scala/kafka/admin/CreateTopicCommand.scala
index e2ed2d9a04..e304fee738 100644
--- a/core/src/main/scala/kafka/admin/CreateTopicCommand.scala
+++ b/core/src/main/scala/kafka/admin/CreateTopicCommand.scala
@@ -51,11 +51,6 @@ object CreateTopicCommand extends Logging {
                                         "broker_id_for_part2_replica1 : broker_id_for_part2_replica2 , ...")
                            .ofType(classOf[String])
                            .defaultsTo("")
-    val maxTopicNameLenOpt = parser.accepts("max-name-len", "maximum length of the topic name")
-                           .withRequiredArg
-                           .describedAs("max topic name length")
-                           .ofType(classOf[java.lang.Integer])
-                           .defaultsTo(Topic.maxNameLength)
 
     val options = parser.parse(args : _*)
 
@@ -68,7 +63,6 @@ object CreateTopicCommand extends Logging {
     }
 
     val topic = options.valueOf(topicOpt)
-    val maxTopicNameLength = options.valueOf(maxTopicNameLenOpt).intValue
     val zkConnect = options.valueOf(zkConnectOpt)
     val nPartitions = options.valueOf(nPartitionsOpt).intValue
     val replicationFactor = options.valueOf(replicationFactorOpt).intValue
@@ -76,8 +70,7 @@ object CreateTopicCommand extends Logging {
     var zkClient: ZkClient = null
     try {
       zkClient = new ZkClient(zkConnect, 30000, 30000, ZKStringSerializer)
-      val topicNameValidator = new TopicNameValidator(maxTopicNameLength)
-      createTopic(zkClient, topic, nPartitions, replicationFactor, replicaAssignmentStr, topicNameValidator)
+      createTopic(zkClient, topic, nPartitions, replicationFactor, replicaAssignmentStr)
       println("creation succeeded!")
     } catch {
       case e =>
@@ -89,9 +82,8 @@ object CreateTopicCommand extends Logging {
     }
   }
 
-  def createTopic(zkClient: ZkClient, topic: String, numPartitions: Int = 1, replicationFactor: Int = 1, replicaAssignmentStr: String = "",
-                  topicNameValidator: TopicNameValidator = new TopicNameValidator(Topic.maxNameLength)) {
-    topicNameValidator.validate(topic)
+  def createTopic(zkClient: ZkClient, topic: String, numPartitions: Int = 1, replicationFactor: Int = 1, replicaAssignmentStr: String = "") {
+    Topic.validate(topic)
 
     val brokerList = ZkUtils.getSortedBrokerList(zkClient)
 
diff --git a/core/src/main/scala/kafka/server/KafkaApis.scala b/core/src/main/scala/kafka/server/KafkaApis.scala
index 5667fbc5f9..12bc799acd 100644
--- a/core/src/main/scala/kafka/server/KafkaApis.scala
+++ b/core/src/main/scala/kafka/server/KafkaApis.scala
@@ -22,7 +22,7 @@ import kafka.admin.{CreateTopicCommand, AdminUtils}
 import kafka.api._
 import kafka.message._
 import kafka.network._
-import kafka.utils.{TopicNameValidator, Pool, SystemTime, Logging}
+import kafka.utils.{Pool, SystemTime, Logging}
 import org.apache.log4j.Logger
 import scala.collection._
 import mutable.HashMap
@@ -44,7 +44,6 @@ class KafkaApis(val requestChannel: RequestChannel,
   private val producerRequestPurgatory = new ProducerRequestPurgatory
   private val fetchRequestPurgatory = new FetchRequestPurgatory(requestChannel)
   private val delayedRequestMetrics = new DelayedRequestMetrics
-  private val topicNameValidator = new TopicNameValidator(replicaManager.config.maxTopicNameLength)
 
   private val requestLogger = Logger.getLogger("kafka.request.logger")
   this.logIdent = "[KafkaApi-%d] ".format(brokerId)
@@ -389,8 +388,7 @@ class KafkaApis(val requestChannel: RequestChannel,
             try {
               /* check if auto creation of topics is turned on */
               if (config.autoCreateTopics) {
-                CreateTopicCommand.createTopic(zkClient, topic, config.numPartitions, config.defaultReplicationFactor,
-                                               topicNameValidator = topicNameValidator)
+                CreateTopicCommand.createTopic(zkClient, topic, config.numPartitions, config.defaultReplicationFactor)
                 info("Auto creation of topic %s with %d partitions and replication factor %d is successful!"
                              .format(topic, config.numPartitions, config.defaultReplicationFactor))
                 val newTopicMetadata = AdminUtils.getTopicMetaDataFromZK(List(topic), zkClient).head
diff --git a/core/src/main/scala/kafka/server/KafkaConfig.scala b/core/src/main/scala/kafka/server/KafkaConfig.scala
index 5978d3beff..b6bab265af 100644
--- a/core/src/main/scala/kafka/server/KafkaConfig.scala
+++ b/core/src/main/scala/kafka/server/KafkaConfig.scala
@@ -112,9 +112,6 @@ class KafkaConfig private (val props: VerifiableProperties) extends ZKConfig(pro
   /* enable auto creation of topic on the server */
   val autoCreateTopics = props.getBoolean("auto.create.topics", true)
 
-  /* the maximum length of topic name*/
-  val maxTopicNameLength = props.getIntInRange("max.topic.name.length", Topic.maxNameLength, (1, Int.MaxValue))
-
   /**
    * Following properties are relevant to Kafka replication
    */
diff --git a/core/src/main/scala/kafka/tools/KafkaMigrationTool.java b/core/src/main/scala/kafka/tools/KafkaMigrationTool.java
index 46414a7ab0..b903c77d11 100644
--- a/core/src/main/scala/kafka/tools/KafkaMigrationTool.java
+++ b/core/src/main/scala/kafka/tools/KafkaMigrationTool.java
@@ -17,6 +17,15 @@
 
 package kafka.tools;
 
+import joptsimple.*;
+import kafka.javaapi.producer.Producer;
+import kafka.javaapi.producer.ProducerData;
+import kafka.message.Message;
+import kafka.producer.ProducerConfig;
+import kafka.utils.Utils;
+import scala.collection.Iterator;
+import scala.collection.JavaConversions;
+
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
@@ -28,18 +37,6 @@ import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Properties;
-import joptsimple.ArgumentAcceptingOptionSpec;
-import joptsimple.OptionParser;
-import joptsimple.OptionSet;
-import joptsimple.OptionSpec;
-import joptsimple.OptionSpecBuilder;
-import kafka.javaapi.producer.Producer;
-import kafka.javaapi.producer.ProducerData;
-import kafka.message.Message;
-import kafka.producer.ProducerConfig;
-import kafka.utils.Utils;
-import scala.collection.JavaConversions;
-import scala.collection.Iterator;
 
 
 /**
diff --git a/core/src/main/scala/kafka/utils/Topic.scala b/core/src/main/scala/kafka/utils/Topic.scala
index c5223a50ba..fe79adff53 100644
--- a/core/src/main/scala/kafka/utils/Topic.scala
+++ b/core/src/main/scala/kafka/utils/Topic.scala
@@ -21,24 +21,21 @@ import kafka.common.InvalidTopicException
 import util.matching.Regex
 
 object Topic {
+  val legalChars = "[a-zA-Z0-9_-]"
   val maxNameLength = 255
-  val illegalChars = "/" + '\u0000' + '\u0001' + "-" + '\u001F' + '\u007F' + "-" + '\u009F' +
-                     '\uD800' + "-" + '\uF8FF' + '\uFFF0' + "-" + '\uFFFF'
-}
-
-class TopicNameValidator(maxLen: Int) {
-  // Regex checks for illegal chars and "." and ".." filenames
-  private val rgx = new Regex("(^\\.{1,2}$)|[" + Topic.illegalChars + "]")
+  private val rgx = new Regex(legalChars + "+")
 
   def validate(topic: String) {
     if (topic.length <= 0)
       throw new InvalidTopicException("topic name is illegal, can't be empty")
-    else if (topic.length > maxLen)
-      throw new InvalidTopicException("topic name is illegal, can't be longer than " + maxLen + " characters")
+    else if (topic.length > maxNameLength)
+      throw new InvalidTopicException("topic name is illegal, can't be longer than " + maxNameLength + " characters")
 
     rgx.findFirstIn(topic) match {
-      case Some(t) => throw new InvalidTopicException("topic name " + topic + " is illegal, doesn't match expected regular expression")
-      case None =>
+      case Some(t) =>
+        if (!t.equals(topic))
+          throw new InvalidTopicException("topic name " + topic + " is illegal, contains a character other than ASCII alphanumerics, _ and -")
+      case None => throw new InvalidTopicException("topic name " + topic + " is illegal,  contains a character other than ASCII alphanumerics, _ and -")
     }
   }
 }
diff --git a/core/src/test/scala/unit/kafka/utils/TopicTest.scala b/core/src/test/scala/unit/kafka/utils/TopicTest.scala
index 6384010fe3..e567be5c3f 100644
--- a/core/src/test/scala/unit/kafka/utils/TopicTest.scala
+++ b/core/src/test/scala/unit/kafka/utils/TopicTest.scala
@@ -32,21 +32,30 @@ class TopicTest {
     for (i <- 1 to 6)
       longName += longName
     invalidTopicNames += longName
-    val badChars = Array('/', '\u0000', '\u0001', '\u0018', '\u001F', '\u008F', '\uD805', '\uFFFA')
+    val badChars = Array('/', '\\', ',', '\0', ':', "\"", '\'', ';', '*', '?', '.')
     for (weirdChar <- badChars) {
       invalidTopicNames += "Is" + weirdChar + "funny"
     }
 
-    val topicNameValidator = new TopicNameValidator(Topic.maxNameLength)
-
     for (i <- 0 until invalidTopicNames.size) {
       try {
-        topicNameValidator.validate(invalidTopicNames(i))
+        Topic.validate(invalidTopicNames(i))
         fail("Should throw InvalidTopicException.")
       }
       catch {
         case e: InvalidTopicException => "This is good."
       }
     }
+
+    val validTopicNames = new ArrayBuffer[String]()
+    validTopicNames += ("valid", "TOPIC", "nAmEs", "ar6", "VaL1d", "_0-9_")
+    for (i <- 0 until validTopicNames.size) {
+      try {
+        Topic.validate(validTopicNames(i))
+      }
+      catch {
+        case e: Exception => fail("Should not throw exception.")
+      }
+    }
   }
 }
