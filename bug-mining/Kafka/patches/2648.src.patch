diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java
index 4813f42436..17fc095ba1 100644
--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java
@@ -77,7 +77,13 @@ final class StateManagerUtil {
         // We should only load checkpoint AFTER the corresponding state directory lock has been acquired and
         // the state stores have been registered; we should not try to load at the state manager construction time.
         // See https://issues.apache.org/jira/browse/KAFKA-8574
+
         for (final StateStore store : topology.stateStores()) {
+            if (stateMgr.getStore(store.name()) != null) {
+                log.warn("Skip the registration of store {} since it is already registered. This could be due " +
+                    "to a half-way registration in the previous round of initialization.", store.name());
+                continue;
+            }
             processorContext.uninitialize();
             store.init(processorContext, store);
             log.trace("Registered state store {}", store.name());
diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java
index c5de838375..69022279c6 100644
--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java
@@ -153,15 +153,16 @@ public class StateManagerUtilTest {
 
         expect(topology.stateStores()).andReturn(Arrays.asList(store1, store2));
 
+        // Store1 will be registered as it hasn't been registered before.
+        expect(stateManager.getStore(store1.name())).andReturn(null);
+
         processorContext.uninitialize();
         expectLastCall();
         processorContext.register(store1, store1.stateRestoreCallback);
         expectLastCall();
 
-        processorContext.uninitialize();
-        expectLastCall();
-        processorContext.register(store2, store2.stateRestoreCallback);
-        expectLastCall();
+        // Store2 is already registered, so no more registration will happen.
+        expect(stateManager.getStore(store2.name())).andReturn(store2);
 
         stateManager.initializeStoreOffsetsFromCheckpoint(true);
         expectLastCall();
