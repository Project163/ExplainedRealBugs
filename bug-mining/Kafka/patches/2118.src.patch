diff --git a/clients/src/main/java/org/apache/kafka/common/security/token/delegation/internals/DelegationTokenCache.java b/clients/src/main/java/org/apache/kafka/common/security/token/delegation/internals/DelegationTokenCache.java
index a74781f0e1..9cc913f575 100644
--- a/clients/src/main/java/org/apache/kafka/common/security/token/delegation/internals/DelegationTokenCache.java
+++ b/clients/src/main/java/org/apache/kafka/common/security/token/delegation/internals/DelegationTokenCache.java
@@ -32,10 +32,15 @@ import java.util.concurrent.ConcurrentHashMap;
 public class DelegationTokenCache {
 
     private CredentialCache credentialCache = new CredentialCache();
+
     //Cache to hold all the tokens
     private Map<String, TokenInformation> tokenCache = new ConcurrentHashMap<>();
+
     //Cache to hold hmac->tokenId mapping. This is required for renew, expire requests
-    private Map<String, String> hmacIDCache = new ConcurrentHashMap<>();
+    private Map<String, String> hmacTokenIdCache = new ConcurrentHashMap<>();
+
+    //Cache to hold tokenId->hmac mapping. This is required for removing entry from hmacTokenIdCache using tokenId.
+    private Map<String, String> tokenIdHmacCache = new ConcurrentHashMap<>();
 
     public DelegationTokenCache(Collection<String> scramMechanisms) {
         //Create caches for scramMechanisms
@@ -60,17 +65,21 @@ public class DelegationTokenCache {
         //Update Scram Credentials
         updateCredentials(tokenId, scramCredentialMap);
         //Update hmac-id cache
-        hmacIDCache.put(hmac, tokenId);
+        hmacTokenIdCache.put(hmac, tokenId);
+        tokenIdHmacCache.put(tokenId, hmac);
     }
 
-
     public void removeCache(String tokenId) {
         removeToken(tokenId);
-        updateCredentials(tokenId, new HashMap<String, ScramCredential>());
+        updateCredentials(tokenId, new HashMap<>());
+    }
+
+    public String tokenIdForHmac(String base64hmac) {
+        return hmacTokenIdCache.get(base64hmac);
     }
 
     public TokenInformation tokenForHmac(String base64hmac) {
-        String tokenId = hmacIDCache.get(base64hmac);
+        String tokenId = hmacTokenIdCache.get(base64hmac);
         return tokenId == null ? null : tokenCache.get(tokenId);
     }
 
@@ -81,7 +90,10 @@ public class DelegationTokenCache {
     public void removeToken(String tokenId) {
         TokenInformation tokenInfo = tokenCache.remove(tokenId);
         if (tokenInfo != null) {
-            hmacIDCache.remove(tokenInfo.tokenId());
+            String hmac = tokenIdHmacCache.remove(tokenInfo.tokenId());
+            if (hmac != null) {
+                hmacTokenIdCache.remove(hmac);
+            }
         }
     }
 
diff --git a/core/src/test/scala/unit/kafka/security/token/delegation/DelegationTokenManagerTest.scala b/core/src/test/scala/unit/kafka/security/token/delegation/DelegationTokenManagerTest.scala
index b8d4376c54..ed82f5ed44 100644
--- a/core/src/test/scala/unit/kafka/security/token/delegation/DelegationTokenManagerTest.scala
+++ b/core/src/test/scala/unit/kafka/security/token/delegation/DelegationTokenManagerTest.scala
@@ -19,7 +19,7 @@ package kafka.security.token.delegation
 
 import java.net.InetAddress
 import java.nio.ByteBuffer
-import java.util.Properties
+import java.util.{Base64, Properties}
 
 import kafka.network.RequestChannel.Session
 import kafka.security.auth.Acl.WildCardHost
@@ -189,6 +189,30 @@ class DelegationTokenManagerTest extends ZooKeeperTestHarness  {
     assertEquals(time.milliseconds, expiryTimeStamp)
   }
 
+  @Test
+  def testRemoveTokenHmac():Unit = {
+    val config = KafkaConfig.fromProps(props)
+    val tokenManager = createDelegationTokenManager(config, tokenCache, time, zkClient)
+    tokenManager.startup
+
+    tokenManager.createToken(owner, renewer, -1 , createTokenResultCallBack)
+    val issueTime = time.milliseconds
+    val tokenId = createTokenResult.tokenId
+    val password = DelegationTokenManager.createHmac(tokenId, masterKey)
+    assertEquals(CreateTokenResult(issueTime, issueTime + renewTimeMsDefault,  issueTime + maxLifeTimeMsDefault, tokenId, password, Errors.NONE), createTokenResult)
+
+    // expire the token immediately
+    tokenManager.expireToken(owner, ByteBuffer.wrap(password), -1, renewResponseCallback)
+
+    val encodedHmac = Base64.getEncoder.encodeToString(password)
+    // check respective hmac map entry is removed for the expired tokenId.
+    val tokenInformation = tokenManager.tokenCache.tokenIdForHmac(encodedHmac)
+    assertNull(tokenInformation)
+
+    //check that the token is removed
+    assert(tokenManager.getToken(tokenId).isEmpty)
+  }
+
   @Test
   def testDescribeToken(): Unit = {
 
