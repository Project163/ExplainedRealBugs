diff --git a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java
index 62072e09c3..7dbd6112f7 100644
--- a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java
+++ b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java
@@ -519,7 +519,7 @@ public class DelegatingClassLoader extends URLClassLoader {
         if (serviceLoaderManifestForPlugin(name)) {
             // Default implementation of getResources searches the parent class loader and also its own URL paths. This will enable the
             // PluginClassLoader to limit its resource search to only its own URL paths.
-            return null;
+            return Collections.emptyEnumeration();
         } else {
             return super.getResources(name);
         }
diff --git a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/PluginClassLoader.java b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/PluginClassLoader.java
index bc0df79b07..da05966e13 100644
--- a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/PluginClassLoader.java
+++ b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/PluginClassLoader.java
@@ -19,8 +19,12 @@ package org.apache.kafka.connect.runtime.isolation;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import java.io.IOException;
 import java.net.URL;
 import java.net.URLClassLoader;
+import java.util.Enumeration;
+import java.util.Objects;
+import java.util.Vector;
 
 /**
  * A custom classloader dedicated to loading Connect plugin classes in classloading isolation.
@@ -81,6 +85,35 @@ public class PluginClassLoader extends URLClassLoader {
         return "PluginClassLoader{pluginLocation=" + pluginLocation + "}";
     }
 
+    @Override
+    public URL getResource(String name) {
+        Objects.requireNonNull(name);
+
+        URL url = findResource(name);
+        if (url == null) {
+            url = super.getResource(name);
+        }
+        return url;
+    }
+
+    @Override
+    public Enumeration<URL> getResources(String name) throws IOException {
+        Objects.requireNonNull(name);
+        Vector<URL> resources = new Vector<>();
+        for (Enumeration<URL> foundLocally = findResources(name); foundLocally.hasMoreElements();) {
+            URL url = foundLocally.nextElement();
+            if (url != null)
+                resources.add(url);
+        }
+        // Explicitly call the parent implementation instead of super to avoid double-listing the local resources
+        for (Enumeration<URL> foundByParent = getParent().getResources(name); foundByParent.hasMoreElements();) {
+            URL url = foundByParent.nextElement();
+            if (url != null)
+                resources.add(url);
+        }
+        return resources.elements();
+    }
+
     // This method needs to be thread-safe because it is supposed to be called by multiple
     // Connect tasks. While findClass is thread-safe, defineClass called within loadClass of the
     // base method is not. More on multithreaded classloaders in:
@@ -109,3 +142,4 @@ public class PluginClassLoader extends URLClassLoader {
         }
     }
 }
+
diff --git a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java
index 8008e26079..311c14be92 100644
--- a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java
+++ b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/Plugins.java
@@ -55,14 +55,20 @@ public class Plugins {
     private final DelegatingClassLoader delegatingLoader;
 
     public Plugins(Map<String, String> props) {
+        this(props, Plugins.class.getClassLoader());
+    }
+
+    // VisibleForTesting
+    Plugins(Map<String, String> props, ClassLoader parent) {
         List<String> pluginLocations = WorkerConfig.pluginLocations(props);
-        delegatingLoader = newDelegatingClassLoader(pluginLocations);
+        delegatingLoader = newDelegatingClassLoader(pluginLocations, parent);
         delegatingLoader.initLoaders();
     }
 
-    protected DelegatingClassLoader newDelegatingClassLoader(final List<String> paths) {
+    // VisibleForTesting
+    protected DelegatingClassLoader newDelegatingClassLoader(final List<String> paths, ClassLoader parent) {
         return AccessController.doPrivileged(
-                (PrivilegedAction<DelegatingClassLoader>) () -> new DelegatingClassLoader(paths)
+                (PrivilegedAction<DelegatingClassLoader>) () -> new DelegatingClassLoader(paths, parent)
         );
     }
 
diff --git a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoaderTest.java b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoaderTest.java
index f3f3680ba0..48f805002f 100644
--- a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoaderTest.java
+++ b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoaderTest.java
@@ -53,8 +53,10 @@ public class DelegatingClassLoaderTest {
 
     @Test
     public void testLoadingUnloadedPluginClass() {
-        TestPlugins.assertAvailable();
-        DelegatingClassLoader classLoader = new DelegatingClassLoader(Collections.emptyList());
+        DelegatingClassLoader classLoader = new DelegatingClassLoader(
+                Collections.emptyList(),
+                DelegatingClassLoader.class.getClassLoader()
+        );
         classLoader.initLoaders();
         for (String pluginClassName : TestPlugins.pluginClasses()) {
             assertThrows(ClassNotFoundException.class, () -> classLoader.loadClass(pluginClassName));
@@ -63,8 +65,10 @@ public class DelegatingClassLoaderTest {
 
     @Test
     public void testLoadingPluginClass() throws ClassNotFoundException {
-        TestPlugins.assertAvailable();
-        DelegatingClassLoader classLoader = new DelegatingClassLoader(TestPlugins.pluginPath());
+        DelegatingClassLoader classLoader = new DelegatingClassLoader(
+                TestPlugins.pluginPath(),
+                DelegatingClassLoader.class.getClassLoader()
+        );
         classLoader.initLoaders();
         for (String pluginClassName : TestPlugins.pluginClasses()) {
             assertNotNull(classLoader.loadClass(pluginClassName));
@@ -77,7 +81,9 @@ public class DelegatingClassLoaderTest {
         pluginDir.newFile("invalid.jar");
 
         DelegatingClassLoader classLoader = new DelegatingClassLoader(
-            Collections.singletonList(pluginDir.getRoot().getAbsolutePath()));
+                Collections.singletonList(pluginDir.getRoot().getAbsolutePath()),
+                DelegatingClassLoader.class.getClassLoader()
+        );
         classLoader.initLoaders();
     }
 
@@ -87,14 +93,18 @@ public class DelegatingClassLoaderTest {
         pluginDir.newFile("my-plugin/invalid.jar");
 
         DelegatingClassLoader classLoader = new DelegatingClassLoader(
-            Collections.singletonList(pluginDir.getRoot().getAbsolutePath()));
+                Collections.singletonList(pluginDir.getRoot().getAbsolutePath()),
+                DelegatingClassLoader.class.getClassLoader()
+        );
         classLoader.initLoaders();
     }
 
     @Test
     public void testLoadingNoPlugins() {
         DelegatingClassLoader classLoader = new DelegatingClassLoader(
-            Collections.singletonList(pluginDir.getRoot().getAbsolutePath()));
+                Collections.singletonList(pluginDir.getRoot().getAbsolutePath()),
+                DelegatingClassLoader.class.getClassLoader()
+        );
         classLoader.initLoaders();
     }
 
@@ -103,14 +113,14 @@ public class DelegatingClassLoaderTest {
         pluginDir.newFolder("my-plugin");
 
         DelegatingClassLoader classLoader = new DelegatingClassLoader(
-            Collections.singletonList(pluginDir.getRoot().getAbsolutePath()));
+                Collections.singletonList(pluginDir.getRoot().getAbsolutePath()),
+                DelegatingClassLoader.class.getClassLoader()
+        );
         classLoader.initLoaders();
     }
 
     @Test
     public void testLoadingMixOfValidAndInvalidPlugins() throws Exception {
-        TestPlugins.assertAvailable();
-
         pluginDir.newFile("invalid.jar");
         pluginDir.newFolder("my-plugin");
         pluginDir.newFile("my-plugin/invalid.jar");
@@ -122,7 +132,9 @@ public class DelegatingClassLoaderTest {
         }
 
         DelegatingClassLoader classLoader = new DelegatingClassLoader(
-            Collections.singletonList(pluginDir.getRoot().getAbsolutePath()));
+                Collections.singletonList(pluginDir.getRoot().getAbsolutePath()),
+                DelegatingClassLoader.class.getClassLoader()
+        );
         classLoader.initLoaders();
         for (String pluginClassName : TestPlugins.pluginClasses()) {
             assertNotNull(classLoader.loadClass(pluginClassName));
diff --git a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/PluginsTest.java b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/PluginsTest.java
index c6688ec98f..4b040de92c 100644
--- a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/PluginsTest.java
+++ b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/PluginsTest.java
@@ -17,8 +17,14 @@
 
 package org.apache.kafka.connect.runtime.isolation;
 
+import java.io.File;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Map.Entry;
+
 import org.apache.kafka.common.Configurable;
 import org.apache.kafka.common.config.AbstractConfig;
 import org.apache.kafka.common.config.ConfigDef;
@@ -33,6 +39,7 @@ import org.apache.kafka.connect.rest.ConnectRestExtension;
 import org.apache.kafka.connect.rest.ConnectRestExtensionContext;
 import org.apache.kafka.connect.runtime.WorkerConfig;
 import org.apache.kafka.connect.runtime.isolation.Plugins.ClassLoaderUsage;
+import org.apache.kafka.connect.runtime.isolation.TestPlugins.TestPlugin;
 import org.apache.kafka.connect.storage.Converter;
 import org.apache.kafka.connect.storage.ConverterConfig;
 import org.apache.kafka.connect.storage.ConverterType;
@@ -172,10 +179,8 @@ public class PluginsTest {
 
     @Test
     public void shouldThrowIfPluginThrows() {
-        TestPlugins.assertAvailable();
-
         assertThrows(ConnectException.class, () -> plugins.newPlugin(
-            TestPlugins.ALWAYS_THROW_EXCEPTION,
+            TestPlugin.ALWAYS_THROW_EXCEPTION.className(),
             new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
             Converter.class
         ));
@@ -184,9 +189,8 @@ public class PluginsTest {
     @Test
     public void shouldShareStaticValuesBetweenSamePlugin() {
         // Plugins are not isolated from other instances of their own class.
-        TestPlugins.assertAvailable();
         Converter firstPlugin = plugins.newPlugin(
-            TestPlugins.ALIASED_STATIC_FIELD,
+            TestPlugin.ALIASED_STATIC_FIELD.className(),
             new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
             Converter.class
         );
@@ -194,7 +198,7 @@ public class PluginsTest {
         assertInstanceOf(SamplingTestPlugin.class, firstPlugin, "Cannot collect samples");
 
         Converter secondPlugin = plugins.newPlugin(
-            TestPlugins.ALIASED_STATIC_FIELD,
+            TestPlugin.ALIASED_STATIC_FIELD.className(),
             new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
             Converter.class
         );
@@ -208,9 +212,8 @@ public class PluginsTest {
 
     @Test
     public void newPluginShouldServiceLoadWithPluginClassLoader() {
-        TestPlugins.assertAvailable();
         Converter plugin = plugins.newPlugin(
-            TestPlugins.SERVICE_LOADER,
+            TestPlugin.SERVICE_LOADER.className(),
             new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
             Converter.class
         );
@@ -225,9 +228,8 @@ public class PluginsTest {
 
     @Test
     public void newPluginShouldInstantiateWithPluginClassLoader() {
-        TestPlugins.assertAvailable();
         Converter plugin = plugins.newPlugin(
-            TestPlugins.ALIASED_STATIC_FIELD,
+            TestPlugin.ALIASED_STATIC_FIELD.className(),
             new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
             Converter.class
         );
@@ -239,16 +241,14 @@ public class PluginsTest {
 
     @Test
     public void shouldFailToFindConverterInCurrentClassloader() {
-        TestPlugins.assertAvailable();
-        props.put(WorkerConfig.KEY_CONVERTER_CLASS_CONFIG, TestPlugins.SAMPLING_CONVERTER);
+        props.put(WorkerConfig.KEY_CONVERTER_CLASS_CONFIG, TestPlugin.SAMPLING_CONVERTER.className());
         assertThrows(ConfigException.class, this::createConfig);
     }
 
     @Test
     public void newConverterShouldConfigureWithPluginClassLoader() {
-        TestPlugins.assertAvailable();
-        props.put(WorkerConfig.KEY_CONVERTER_CLASS_CONFIG, TestPlugins.SAMPLING_CONVERTER);
-        ClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugins.SAMPLING_CONVERTER);
+        props.put(WorkerConfig.KEY_CONVERTER_CLASS_CONFIG, TestPlugin.SAMPLING_CONVERTER.className());
+        ClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugin.SAMPLING_CONVERTER.className());
         try (LoaderSwap loaderSwap = plugins.withClassLoader(classLoader)) {
             createConfig();
         }
@@ -267,11 +267,10 @@ public class PluginsTest {
 
     @Test
     public void newConfigProviderShouldConfigureWithPluginClassLoader() {
-        TestPlugins.assertAvailable();
         String providerPrefix = "some.provider";
-        props.put(providerPrefix + ".class", TestPlugins.SAMPLING_CONFIG_PROVIDER);
+        props.put(providerPrefix + ".class", TestPlugin.SAMPLING_CONFIG_PROVIDER.className());
 
-        PluginClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugins.SAMPLING_CONFIG_PROVIDER);
+        PluginClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugin.SAMPLING_CONFIG_PROVIDER.className());
         assertNotNull(classLoader);
         try (LoaderSwap loaderSwap = plugins.withClassLoader(classLoader)) {
             createConfig();
@@ -291,9 +290,8 @@ public class PluginsTest {
 
     @Test
     public void newHeaderConverterShouldConfigureWithPluginClassLoader() {
-        TestPlugins.assertAvailable();
-        props.put(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, TestPlugins.SAMPLING_HEADER_CONVERTER);
-        ClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugins.SAMPLING_HEADER_CONVERTER);
+        props.put(WorkerConfig.HEADER_CONVERTER_CLASS_CONFIG, TestPlugin.SAMPLING_HEADER_CONVERTER.className());
+        ClassLoader classLoader = plugins.delegatingLoader().pluginClassLoader(TestPlugin.SAMPLING_HEADER_CONVERTER.className());
         try (LoaderSwap loaderSwap = plugins.withClassLoader(classLoader)) {
             createConfig();
         }
@@ -312,9 +310,8 @@ public class PluginsTest {
 
     @Test
     public void newPluginsShouldConfigureWithPluginClassLoader() {
-        TestPlugins.assertAvailable();
         List<Configurable> configurables = plugins.newPlugins(
-            Collections.singletonList(TestPlugins.SAMPLING_CONFIGURABLE),
+            Collections.singletonList(TestPlugin.SAMPLING_CONFIGURABLE.className()),
             config,
             Configurable.class
         );
@@ -327,6 +324,70 @@ public class PluginsTest {
         assertPluginClassLoaderAlwaysActive(samples);
     }
 
+    @Test
+    public void pluginClassLoaderReadVersionFromResourceExistingOnlyInChild() throws Exception {
+        assertClassLoaderReadsVersionFromResource(
+                TestPlugin.ALIASED_STATIC_FIELD,
+                TestPlugin.READ_VERSION_FROM_RESOURCE_V1,
+                TestPlugin.READ_VERSION_FROM_RESOURCE_V1.className(),
+                "1.0.0");
+    }
+
+    @Test
+    public void pluginClassLoaderReadVersionFromResourceExistingOnlyInParent() throws Exception {
+        assertClassLoaderReadsVersionFromResource(
+                TestPlugin.READ_VERSION_FROM_RESOURCE_V1,
+                TestPlugin.ALIASED_STATIC_FIELD,
+                TestPlugin.READ_VERSION_FROM_RESOURCE_V1.className(),
+                "1.0.0");
+    }
+
+    @Test
+    public void pluginClassLoaderReadVersionFromResourceExistingInParentAndChild() throws Exception {
+        assertClassLoaderReadsVersionFromResource(
+                TestPlugin.READ_VERSION_FROM_RESOURCE_V1,
+                TestPlugin.READ_VERSION_FROM_RESOURCE_V2,
+                TestPlugin.READ_VERSION_FROM_RESOURCE_V2.className(),
+                "2.0.0", "1.0.0");
+    }
+
+    private void assertClassLoaderReadsVersionFromResource(
+            TestPlugin parentResource, TestPlugin childResource, String className, String... expectedVersions) throws MalformedURLException {
+        URL[] systemPath = TestPlugins.pluginPath(parentResource)
+                .stream()
+                .map(File::new)
+                .map(File::toURI)
+                .map(uri -> {
+                    try {
+                        return uri.toURL();
+                    } catch (MalformedURLException e) {
+                        throw new RuntimeException(e);
+                    }
+                })
+                .toArray(URL[]::new);
+        URLClassLoader parent = new URLClassLoader(systemPath);
+
+        // Initialize Plugins object with parent class loader in the class loader tree. This is
+        // to simulate the situation where jars exist on both system classpath and plugin path.
+        Map<String, String> pluginProps = Collections.singletonMap(
+                WorkerConfig.PLUGIN_PATH_CONFIG,
+                String.join(",", TestPlugins.pluginPath(childResource))
+        );
+        plugins = new Plugins(pluginProps, parent);
+
+        Converter converter = plugins.newPlugin(
+                className,
+                new AbstractConfig(new ConfigDef(), Collections.emptyMap()),
+                Converter.class
+        );
+        // Verify the version was read from the correct resource
+        assertEquals(expectedVersions[0],
+                new String(converter.fromConnectData(null, null, null)));
+        // When requesting multiple resources, they should be listed in the correct order
+        assertEquals(Arrays.asList(expectedVersions),
+                converter.toConnectData(null, null).value());
+    }
+
     public static void assertPluginClassLoaderAlwaysActive(Map<String, SamplingTestPlugin> samples) {
         for (Entry<String, SamplingTestPlugin> e : samples.entrySet()) {
             String sampleName = "\"" + e.getKey() + "\" (" + e.getValue() + ")";
diff --git a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java
index e3e7ddc463..f48b9c6492 100644
--- a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java
+++ b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java
@@ -70,7 +70,6 @@ public class SynchronizationTest {
 
     @Before
     public void setup() {
-        TestPlugins.assertAvailable();
         Map<String, String> pluginProps = Collections.singletonMap(
             WorkerConfig.PLUGIN_PATH_CONFIG,
             String.join(",", TestPlugins.pluginPath())
@@ -81,10 +80,10 @@ public class SynchronizationTest {
         pclBreakpoint = new Breakpoint<>();
         plugins = new Plugins(pluginProps) {
             @Override
-            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {
+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths, ClassLoader parent) {
                 return AccessController.doPrivileged(
                     (PrivilegedAction<DelegatingClassLoader>) () ->
-                        new SynchronizedDelegatingClassLoader(paths)
+                        new SynchronizedDelegatingClassLoader(paths, parent)
                 );
             }
         };
@@ -172,8 +171,8 @@ public class SynchronizationTest {
             ClassLoader.registerAsParallelCapable();
         }
 
-        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {
-            super(pluginPaths);
+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths, ClassLoader parent) {
+            super(pluginPaths, parent);
         }
 
         @Override
@@ -216,7 +215,7 @@ public class SynchronizationTest {
     // If the test times out, then there's a deadlock in the test but not necessarily the code
     @Test(timeout = 15000L)
     public void testSimultaneousUpwardAndDownwardDelegating() throws Exception {
-        String t1Class = TestPlugins.SAMPLING_CONVERTER;
+        String t1Class = TestPlugins.TestPlugin.SAMPLING_CONVERTER.className();
         // Grab a reference to the target PluginClassLoader before activating breakpoints
         ClassLoader connectorLoader = plugins.connectorLoader(t1Class);
 
@@ -295,7 +294,7 @@ public class SynchronizationTest {
     // Ensure the PluginClassLoader is parallel capable and not synchronized on its monitor lock
     public void testPluginClassLoaderDoesntHoldMonitorLock()
         throws InterruptedException, TimeoutException, BrokenBarrierException {
-        String t1Class = TestPlugins.SAMPLING_CONVERTER;
+        String t1Class = TestPlugins.TestPlugin.SAMPLING_CONVERTER.className();
         ClassLoader connectorLoader = plugins.connectorLoader(t1Class);
 
         Object externalTestLock = new Object();
@@ -319,7 +318,7 @@ public class SynchronizationTest {
             synchronized (externalTestLock) {
                 try {
                     progress.await(null);
-                    Class.forName(TestPlugins.SAMPLING_CONVERTER, true, connectorLoader);
+                    Class.forName(TestPlugins.TestPlugin.SAMPLING_CONVERTER.className(), true, connectorLoader);
                 } catch (ClassNotFoundException e) {
                     throw new RuntimeException("Failed to load test plugin", e);
                 }
diff --git a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/TestPlugins.java b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/TestPlugins.java
index 9561ffb0f5..f828b31674 100644
--- a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/TestPlugins.java
+++ b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/TestPlugins.java
@@ -27,13 +27,13 @@ import java.io.StringWriter;
 import java.net.URL;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.jar.Attributes;
 import java.util.jar.JarEntry;
 import java.util.jar.JarOutputStream;
@@ -53,51 +53,92 @@ import org.slf4j.LoggerFactory;
  *
  * <p>To add a plugin, create the source files in the resource tree, and edit this class to build
  * that plugin during initialization. For example, the plugin class {@literal package.Class} should
- * be placed in {@literal resources/test-plugins/something/package/Class.java} and loaded using
- * {@code createPluginJar("something")}. The class name, contents, and plugin directory can take
- * any value you need for testing.
+ * be placed in {@literal resources/test-plugins/something/package/Class.java} and added as a
+ * TestPlugin enum {@code PLUGIN_ID("something", "package.Class");}. The class name, contents,
+ * and plugin directory can take any value you need for testing.
  *
- * <p>To use this class in your tests, make sure to first call
- * {@link TestPlugins#assertAvailable()} to verify that the plugins initialized correctly.
- * Otherwise, exceptions during the plugin build are not propagated, and may invalidate your test.
- * You can access the list of plugin jars for assembling a {@literal plugin.path}, and reference
- * the names of the different plugins directly via the exposed constants.
+ * <p>You can then assemble a {@literal plugin.path} of a list of plugin jars via {@link TestPlugins#pluginPath},
+ * and reference the names of the different plugins directly via the {@link TestPlugin} enum.
  */
 public class TestPlugins {
+    public enum TestPlugin {
+        /**
+         * A plugin which will always throw an exception during loading
+         */
+        ALWAYS_THROW_EXCEPTION("always-throw-exception", "test.plugins.AlwaysThrowException"),
+        /**
+         * A plugin which samples information about its initialization.
+         */
+        ALIASED_STATIC_FIELD("aliased-static-field", "test.plugins.AliasedStaticField"),
+        /**
+         * A {@link org.apache.kafka.connect.storage.Converter}
+         * which samples information about its method calls.
+         */
+        SAMPLING_CONVERTER("sampling-converter", "test.plugins.SamplingConverter"),
+        /**
+         * A {@link org.apache.kafka.common.Configurable}
+         * which samples information about its method calls.
+         */
+        SAMPLING_CONFIGURABLE("sampling-configurable", "test.plugins.SamplingConfigurable"),
+        /**
+         * A {@link org.apache.kafka.connect.storage.HeaderConverter}
+         * which samples information about its method calls.
+         */
+        SAMPLING_HEADER_CONVERTER("sampling-header-converter", "test.plugins.SamplingHeaderConverter"),
+        /**
+         * A {@link org.apache.kafka.common.config.provider.ConfigProvider}
+         * which samples information about its method calls.
+         */
+        SAMPLING_CONFIG_PROVIDER("sampling-config-provider", "test.plugins.SamplingConfigProvider"),
+        /**
+         * A plugin which uses a {@link java.util.ServiceLoader}
+         * to load internal classes, and samples information about their initialization.
+         */
+        SERVICE_LOADER("service-loader", "test.plugins.ServiceLoaderPlugin"),
+        /**
+         * A plugin which reads a version string from a resource and packages the version string 1.0.0.
+         */
+        READ_VERSION_FROM_RESOURCE_V1("read-version-from-resource-v1", "test.plugins.ReadVersionFromResource"),
+        /**
+         * A plugin which reads a version string from a resource and packages the version string 2.0.0.
+         * This plugin is not included in {@link TestPlugins#pluginPath()} and must be included explicitly
+         */
+        READ_VERSION_FROM_RESOURCE_V2("read-version-from-resource-v2", "test.plugins.ReadVersionFromResource", false),
+        /**
+         * A plugin which shares a jar file with {@link TestPlugin#MULTIPLE_PLUGINS_IN_JAR_THING_TWO}
+         */
+        MULTIPLE_PLUGINS_IN_JAR_THING_ONE("multiple-plugins-in-jar", "test.plugins.ThingOne"),
+        /**
+         * A plugin which shares a jar file with {@link TestPlugin#MULTIPLE_PLUGINS_IN_JAR_THING_ONE}
+         */
+        MULTIPLE_PLUGINS_IN_JAR_THING_TWO("multiple-plugins-in-jar", "test.plugins.ThingTwo");
 
-    /**
-     * Class name of a plugin which will always throw an exception during loading
-     */
-    public static final String ALWAYS_THROW_EXCEPTION = "test.plugins.AlwaysThrowException";
-    /**
-     * Class name of a plugin which samples information about its initialization.
-     */
-    public static final String ALIASED_STATIC_FIELD = "test.plugins.AliasedStaticField";
-    /**
-     * Class name of a {@link org.apache.kafka.connect.storage.Converter}
-     * which samples information about its method calls.
-     */
-    public static final String SAMPLING_CONVERTER = "test.plugins.SamplingConverter";
-    /**
-     * Class name of a {@link org.apache.kafka.common.Configurable}
-     * which samples information about its method calls.
-     */
-    public static final String SAMPLING_CONFIGURABLE = "test.plugins.SamplingConfigurable";
-    /**
-     * Class name of a {@link org.apache.kafka.connect.storage.HeaderConverter}
-     * which samples information about its method calls.
-     */
-    public static final String SAMPLING_HEADER_CONVERTER = "test.plugins.SamplingHeaderConverter";
-    /**
-     * Class name of a {@link org.apache.kafka.common.config.provider.ConfigProvider}
-     * which samples information about its method calls.
-     */
-    public static final String SAMPLING_CONFIG_PROVIDER = "test.plugins.SamplingConfigProvider";
-    /**
-     * Class name of a plugin which uses a {@link java.util.ServiceLoader}
-     * to load internal classes, and samples information about their initialization.
-     */
-    public static final String SERVICE_LOADER = "test.plugins.ServiceLoaderPlugin";
+        private final String resourceDir;
+        private final String className;
+        private final boolean includeByDefault;
+
+        TestPlugin(String resourceDir, String className) {
+            this(resourceDir, className, true);
+        }
+
+        TestPlugin(String resourceDir, String className, boolean includeByDefault) {
+            this.resourceDir = resourceDir;
+            this.className = className;
+            this.includeByDefault = includeByDefault;
+        }
+
+        public String resourceDir() {
+            return resourceDir;
+        }
+
+        public String className() {
+            return className;
+        }
+
+        public boolean includeByDefault() {
+            return includeByDefault;
+        }
+    }
 
     private static final Logger log = LoggerFactory.getLogger(TestPlugins.class);
     private static final Map<String, File> PLUGIN_JARS;
@@ -105,15 +146,14 @@ public class TestPlugins {
 
     static {
         Throwable err = null;
-        HashMap<String, File> pluginJars = new HashMap<>();
+        Map<String, File> pluginJars = new HashMap<>();
         try {
-            pluginJars.put(ALWAYS_THROW_EXCEPTION, createPluginJar("always-throw-exception"));
-            pluginJars.put(ALIASED_STATIC_FIELD, createPluginJar("aliased-static-field"));
-            pluginJars.put(SAMPLING_CONVERTER, createPluginJar("sampling-converter"));
-            pluginJars.put(SAMPLING_CONFIGURABLE, createPluginJar("sampling-configurable"));
-            pluginJars.put(SAMPLING_HEADER_CONVERTER, createPluginJar("sampling-header-converter"));
-            pluginJars.put(SAMPLING_CONFIG_PROVIDER, createPluginJar("sampling-config-provider"));
-            pluginJars.put(SERVICE_LOADER, createPluginJar("service-loader"));
+            for (TestPlugin testPlugin : TestPlugin.values()) {
+                if (pluginJars.containsKey(testPlugin.resourceDir())) {
+                    log.debug("Skipping recompilation of " + testPlugin.resourceDir());
+                }
+                pluginJars.put(testPlugin.resourceDir(), createPluginJar(testPlugin.resourceDir()));
+            }
         } catch (Throwable e) {
             log.error("Could not set up plugin test jars", e);
             err = e;
@@ -122,11 +162,7 @@ public class TestPlugins {
         INITIALIZATION_EXCEPTION = err;
     }
 
-    /**
-     * Ensure that the test plugin JARs were assembled without error before continuing.
-     * @throws AssertionError if any plugin failed to load, or no plugins were loaded.
-     */
-    public static void assertAvailable() throws AssertionError {
+    private static void assertAvailable() throws AssertionError {
         if (INITIALIZATION_EXCEPTION != null) {
             throw new AssertionError("TestPlugins did not initialize completely",
                 INITIALIZATION_EXCEPTION);
@@ -137,22 +173,59 @@ public class TestPlugins {
     }
 
     /**
-     * A list of jar files containing test plugins
+     * Assemble a default plugin path containing all TestPlugin instances which are not hidden by default.
      * @return A list of plugin jar filenames
+     * @throws AssertionError if any plugin failed to load, or no plugins were loaded.
      */
     public static List<String> pluginPath() {
-        return PLUGIN_JARS.values()
-            .stream()
-            .map(File::getPath)
-            .collect(Collectors.toList());
+        return pluginPath(defaultPlugins());
     }
 
     /**
-     * Get all of the classes that were successfully built by this class
+     * Assemble a plugin path containing some TestPlugin instances
+     * @param plugins One or more plugins which should be included on the plugin path.
+     * @return A list of plugin jar filenames containing the specified test plugins
+     * @throws AssertionError if any plugin failed to load, or no plugins were loaded.
+     */
+    public static List<String> pluginPath(TestPlugin... plugins) {
+        assertAvailable();
+        return Arrays.stream(plugins)
+                .filter(Objects::nonNull)
+                .map(TestPlugin::resourceDir)
+                .distinct()
+                .map(PLUGIN_JARS::get)
+                .map(File::getPath)
+                .collect(Collectors.toList());
+    }
+
+    /**
+     * Get all plugin classes which are included on the default classpath
      * @return A list of plugin class names
+     * @throws AssertionError if any plugin failed to load, or no plugins were loaded.
      */
     public static List<String> pluginClasses() {
-        return new ArrayList<>(PLUGIN_JARS.keySet());
+        return pluginClasses(defaultPlugins());
+    }
+
+    /**
+     * Get all plugin classes which are included in the specified plugins
+     * @param plugins One or more plugins which are included in the plugin path.
+     * @return A list of plugin class names
+     * @throws AssertionError if any plugin failed to load, or no plugins were loaded.
+     */
+    public static List<String> pluginClasses(TestPlugin... plugins) {
+        assertAvailable();
+        return Arrays.stream(plugins)
+                .filter(Objects::nonNull)
+                .map(TestPlugin::className)
+                .distinct()
+                .collect(Collectors.toList());
+    }
+
+    private static TestPlugin[] defaultPlugins() {
+        return Arrays.stream(TestPlugin.values())
+                .filter(TestPlugin::includeByDefault)
+                .toArray(TestPlugin[]::new);
     }
 
     private static File createPluginJar(String resourceDir) throws IOException {
diff --git a/connect/runtime/src/test/resources/test-plugins/aliased-static-field/test/plugins/AliasedStaticField.java b/connect/runtime/src/test/resources/test-plugins/aliased-static-field/test/plugins/AliasedStaticField.java
index d865f4e91b..df77f300a7 100644
--- a/connect/runtime/src/test/resources/test-plugins/aliased-static-field/test/plugins/AliasedStaticField.java
+++ b/connect/runtime/src/test/resources/test-plugins/aliased-static-field/test/plugins/AliasedStaticField.java
@@ -25,8 +25,10 @@ import org.apache.kafka.connect.storage.Converter;
 import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
 
 /**
- * Samples data about its initialization environment for later analysis
- * Samples are shared between instances of the same class in a static variable
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Samples data about its initialization environment for later analysis.
+ * Samples are shared between instances of the same class in a static variable.
  */
 public class AliasedStaticField extends SamplingTestPlugin implements Converter {
 
diff --git a/connect/runtime/src/test/resources/test-plugins/always-throw-exception/test/plugins/AlwaysThrowException.java b/connect/runtime/src/test/resources/test-plugins/always-throw-exception/test/plugins/AlwaysThrowException.java
index 858f3ed5ea..cbbce91579 100644
--- a/connect/runtime/src/test/resources/test-plugins/always-throw-exception/test/plugins/AlwaysThrowException.java
+++ b/connect/runtime/src/test/resources/test-plugins/always-throw-exception/test/plugins/AlwaysThrowException.java
@@ -24,7 +24,9 @@ import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
 import org.apache.kafka.connect.storage.Converter;
 
 /**
- * Unconditionally throw an exception during static initialization.
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Unconditionally throw an exception during static initialization.
  */
 public class AlwaysThrowException implements Converter {
 
diff --git a/connect/runtime/src/test/resources/test-plugins/multiple-plugins-in-jar/test/plugins/ThingOne.java b/connect/runtime/src/test/resources/test-plugins/multiple-plugins-in-jar/test/plugins/ThingOne.java
new file mode 100644
index 0000000000..955b370e4f
--- /dev/null
+++ b/connect/runtime/src/test/resources/test-plugins/multiple-plugins-in-jar/test/plugins/ThingOne.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.plugins;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Map;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.SchemaAndValue;
+import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
+import org.apache.kafka.connect.storage.Converter;
+
+/**
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Exfiltrates data via {@link ThingOne#fromConnectData(String, Schema, Object)}.
+ */
+public class ThingOne implements Converter {
+    @Override
+    public void configure(final Map<String, ?> configs, final boolean isKey) {
+
+    }
+
+    @Override
+    public byte[] fromConnectData(final String topic, final Schema schema, final Object value) {
+        return "Thing one".getBytes(StandardCharsets.UTF_8);
+    }
+
+    @Override
+    public SchemaAndValue toConnectData(final String topic, final byte[] value) {
+        return null;
+    }
+}
diff --git a/connect/runtime/src/test/resources/test-plugins/multiple-plugins-in-jar/test/plugins/ThingTwo.java b/connect/runtime/src/test/resources/test-plugins/multiple-plugins-in-jar/test/plugins/ThingTwo.java
new file mode 100644
index 0000000000..9a0a0e6dee
--- /dev/null
+++ b/connect/runtime/src/test/resources/test-plugins/multiple-plugins-in-jar/test/plugins/ThingTwo.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.plugins;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Map;
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.SchemaAndValue;
+import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
+import org.apache.kafka.connect.runtime.isolation.TestPlugins;
+import org.apache.kafka.connect.storage.Converter;
+
+/**
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Exfiltrates data via {@link ThingTwo#fromConnectData(String, Schema, Object)}.
+ */
+public class ThingTwo implements Converter {
+    @Override
+    public void configure(final Map<String, ?> configs, final boolean isKey) {
+
+    }
+
+    @Override
+    public byte[] fromConnectData(final String topic, final Schema schema, final Object value) {
+        return "Thing two".getBytes(StandardCharsets.UTF_8);
+    }
+
+    @Override
+    public SchemaAndValue toConnectData(final String topic, final byte[] value) {
+        return null;
+    }
+}
diff --git a/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v1/test/plugins/ReadVersionFromResource.java b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v1/test/plugins/ReadVersionFromResource.java
new file mode 100644
index 0000000000..2f5f911f2e
--- /dev/null
+++ b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v1/test/plugins/ReadVersionFromResource.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.plugins;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Map;
+import java.util.stream.Collectors;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.net.URL;
+
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.SchemaAndValue;
+import org.apache.kafka.connect.storage.Converter;
+
+/**
+ * Fake plugin class for testing classloading isolation
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}
+ * <p>Load resource(s) from the isolated classloader instance.
+ * Exfiltrates data via {@link ReadVersionFromResource#fromConnectData(String, Schema, Object)}
+ * and {@link ReadVersionFromResource#toConnectData(String, byte[])}.
+ */
+public class ReadVersionFromResource implements Converter {
+    @Override
+    public void configure(final Map<String, ?> configs, final boolean isKey) {
+
+    }
+
+    private String version(InputStream stream) throws IOException {
+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {
+            return reader.lines()
+                    .filter(s -> !s.isEmpty() && !s.startsWith("#"))
+                    .collect(Collectors.toList())
+                    .get(0);
+        }
+    }
+
+    @Override
+    public byte[] fromConnectData(final String topic, final Schema schema, final Object value) {
+        try (InputStream stream = this.getClass().getResourceAsStream("/version")) {
+            return version(stream).getBytes(StandardCharsets.UTF_8);
+        } catch (IOException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    @Override
+    public SchemaAndValue toConnectData(final String topic, final byte[] value) {
+        try {
+            Enumeration<URL> e = this.getClass().getClassLoader().getResources("version");
+            ArrayList<String> versions = new ArrayList<>();
+            while (e.hasMoreElements()) {
+                try (InputStream stream = e.nextElement().openStream()) {
+                    versions.add(version(stream));
+                }
+            }
+            return new SchemaAndValue(null, versions);
+        } catch (IOException e) {
+            throw new AssertionError(e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v1/version b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v1/version
new file mode 100644
index 0000000000..49584c02d0
--- /dev/null
+++ b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v1/version
@@ -0,0 +1,16 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements. See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+1.0.0
\ No newline at end of file
diff --git a/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v2/test/plugins/ReadVersionFromResource.java b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v2/test/plugins/ReadVersionFromResource.java
new file mode 100644
index 0000000000..9f450a342a
--- /dev/null
+++ b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v2/test/plugins/ReadVersionFromResource.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package test.plugins;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Map;
+import java.util.stream.Collectors;
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.net.URL;
+
+import org.apache.kafka.connect.data.Schema;
+import org.apache.kafka.connect.data.SchemaAndValue;
+import org.apache.kafka.connect.storage.Converter;
+
+/**
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Load resource(s) from the isolated classloader instance.
+ * Exfiltrates data via {@link ReadVersionFromResource#fromConnectData(String, Schema, Object)}
+ * and {@link ReadVersionFromResource#toConnectData(String, byte[])}.
+ */
+public class ReadVersionFromResource implements Converter {
+    @Override
+    public void configure(final Map<String, ?> configs, final boolean isKey) {
+
+    }
+
+    private String version(InputStream stream) throws IOException {
+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {
+            return reader.lines()
+                    .filter(s -> !s.isEmpty() && !s.startsWith("#"))
+                    .collect(Collectors.toList())
+                    .get(0);
+        }
+    }
+
+    @Override
+    public byte[] fromConnectData(final String topic, final Schema schema, final Object value) {
+        try (InputStream stream = this.getClass().getResourceAsStream("/version")) {
+            return version(stream).getBytes(StandardCharsets.UTF_8);
+        } catch (IOException e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    @Override
+    public SchemaAndValue toConnectData(final String topic, final byte[] value) {
+        try {
+            Enumeration<URL> e = this.getClass().getClassLoader().getResources("version");
+            ArrayList<String> versions = new ArrayList<>();
+            while (e.hasMoreElements()) {
+                try (InputStream stream = e.nextElement().openStream()) {
+                    versions.add(version(stream));
+                }
+            }
+            return new SchemaAndValue(null, versions);
+        } catch (IOException e) {
+            throw new AssertionError(e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v2/version b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v2/version
new file mode 100644
index 0000000000..56d688a444
--- /dev/null
+++ b/connect/runtime/src/test/resources/test-plugins/read-version-from-resource-v2/version
@@ -0,0 +1,16 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements. See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License. You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+2.0.0
\ No newline at end of file
diff --git a/connect/runtime/src/test/resources/test-plugins/sampling-config-provider/test/plugins/SamplingConfigProvider.java b/connect/runtime/src/test/resources/test-plugins/sampling-config-provider/test/plugins/SamplingConfigProvider.java
index df8285eba9..f2417d3de5 100644
--- a/connect/runtime/src/test/resources/test-plugins/sampling-config-provider/test/plugins/SamplingConfigProvider.java
+++ b/connect/runtime/src/test/resources/test-plugins/sampling-config-provider/test/plugins/SamplingConfigProvider.java
@@ -30,7 +30,9 @@ import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
 import org.apache.kafka.connect.storage.HeaderConverter;
 
 /**
- * Samples data about its initialization environment for later analysis
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Samples data about its initialization environment for later analysis.
  */
 public class SamplingConfigProvider extends SamplingTestPlugin implements ConfigProvider {
 
diff --git a/connect/runtime/src/test/resources/test-plugins/sampling-configurable/test/plugins/SamplingConfigurable.java b/connect/runtime/src/test/resources/test-plugins/sampling-configurable/test/plugins/SamplingConfigurable.java
index a917f2f2ca..610ae6b724 100644
--- a/connect/runtime/src/test/resources/test-plugins/sampling-configurable/test/plugins/SamplingConfigurable.java
+++ b/connect/runtime/src/test/resources/test-plugins/sampling-configurable/test/plugins/SamplingConfigurable.java
@@ -26,7 +26,9 @@ import org.apache.kafka.connect.storage.Converter;
 import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
 
 /**
- * Samples data about its initialization environment for later analysis
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Samples data about its initialization environment for later analysis.
  */
 public class SamplingConfigurable extends SamplingTestPlugin implements Converter, Configurable {
 
diff --git a/connect/runtime/src/test/resources/test-plugins/sampling-converter/test/plugins/SamplingConverter.java b/connect/runtime/src/test/resources/test-plugins/sampling-converter/test/plugins/SamplingConverter.java
index 39109a1d4e..217e6efc77 100644
--- a/connect/runtime/src/test/resources/test-plugins/sampling-converter/test/plugins/SamplingConverter.java
+++ b/connect/runtime/src/test/resources/test-plugins/sampling-converter/test/plugins/SamplingConverter.java
@@ -25,7 +25,9 @@ import org.apache.kafka.connect.storage.Converter;
 import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
 
 /**
- * Samples data about its initialization environment for later analysis
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Samples data about its initialization environment for later analysis.
  */
 public class SamplingConverter extends SamplingTestPlugin implements Converter {
 
diff --git a/connect/runtime/src/test/resources/test-plugins/sampling-header-converter/test/plugins/SamplingHeaderConverter.java b/connect/runtime/src/test/resources/test-plugins/sampling-header-converter/test/plugins/SamplingHeaderConverter.java
index 11a1e28e72..914c6faac6 100644
--- a/connect/runtime/src/test/resources/test-plugins/sampling-header-converter/test/plugins/SamplingHeaderConverter.java
+++ b/connect/runtime/src/test/resources/test-plugins/sampling-header-converter/test/plugins/SamplingHeaderConverter.java
@@ -27,7 +27,9 @@ import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
 import org.apache.kafka.connect.storage.HeaderConverter;
 
 /**
- * Samples data about its initialization environment for later analysis
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Samples data about its initialization environment for later analysis.
  */
 public class SamplingHeaderConverter extends SamplingTestPlugin implements HeaderConverter {
 
diff --git a/connect/runtime/src/test/resources/test-plugins/service-loader/test/plugins/ServiceLoaderPlugin.java b/connect/runtime/src/test/resources/test-plugins/service-loader/test/plugins/ServiceLoaderPlugin.java
index e6371baf56..6c50dcc888 100644
--- a/connect/runtime/src/test/resources/test-plugins/service-loader/test/plugins/ServiceLoaderPlugin.java
+++ b/connect/runtime/src/test/resources/test-plugins/service-loader/test/plugins/ServiceLoaderPlugin.java
@@ -27,7 +27,9 @@ import org.apache.kafka.connect.storage.Converter;
 import org.apache.kafka.connect.runtime.isolation.SamplingTestPlugin;
 
 /**
- * Samples data about its initialization environment for later analysis
+ * Fake plugin class for testing classloading isolation.
+ * See {@link org.apache.kafka.connect.runtime.isolation.TestPlugins}.
+ * <p>Samples data about its initialization environment for later analysis.
  */
 public class ServiceLoaderPlugin extends SamplingTestPlugin implements Converter {
 
