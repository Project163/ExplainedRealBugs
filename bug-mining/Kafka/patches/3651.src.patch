diff --git a/clients/src/main/java/org/apache/kafka/clients/InFlightRequests.java b/clients/src/main/java/org/apache/kafka/clients/InFlightRequests.java
index 6f5477e37e..4235be5c8d 100644
--- a/clients/src/main/java/org/apache/kafka/clients/InFlightRequests.java
+++ b/clients/src/main/java/org/apache/kafka/clients/InFlightRequests.java
@@ -158,7 +158,9 @@ final class InFlightRequests {
 
     private Boolean hasExpiredRequest(long now, Deque<NetworkClient.InFlightRequest> deque) {
         for (NetworkClient.InFlightRequest request : deque) {
-            if (request.timeElapsedSinceSendMs(now) > request.requestTimeoutMs)
+            // We exclude throttle time here because we want to ensure that we don't expire requests while
+            // they are throttled. The request timeout should take effect only after the throttle time has elapsed.
+            if (request.timeElapsedSinceSendMs(now) - request.throttleTimeMs() > request.requestTimeoutMs)
                 return true;
         }
         return false;
@@ -181,4 +183,8 @@ final class InFlightRequests {
         return nodeIds;
     }
 
+    void incrementThrottleTime(String nodeId, long throttleTimeMs) {
+        requests.getOrDefault(nodeId, new ArrayDeque<>()).
+                forEach(request -> request.incrementThrottleTime(throttleTimeMs));
+    }
 }
diff --git a/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java b/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java
index a596f660d0..3a7af6617e 100644
--- a/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java
+++ b/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java
@@ -345,16 +345,16 @@ public class NetworkClient implements KafkaClient {
         for (InFlightRequest request : inFlightRequests) {
             if (log.isDebugEnabled()) {
                 log.debug("Cancelled in-flight {} request with correlation id {} due to node {} being disconnected " +
-                        "(elapsed time since creation: {}ms, elapsed time since send: {}ms, request timeout: {}ms): {}",
+                        "(elapsed time since creation: {}ms, elapsed time since send: {}ms, throttle time: {}ms, request timeout: {}ms): {}",
                     request.header.apiKey(), request.header.correlationId(), nodeId,
                     request.timeElapsedSinceCreateMs(now), request.timeElapsedSinceSendMs(now),
-                    request.requestTimeoutMs, request.request);
+                    request.throttleTimeMs(), request.requestTimeoutMs, request.request);
             } else {
                 log.info("Cancelled in-flight {} request with correlation id {} due to node {} being disconnected " +
-                        "(elapsed time since creation: {}ms, elapsed time since send: {}ms, request timeout: {}ms)",
+                        "(elapsed time since creation: {}ms, elapsed time since send: {}ms, throttle time: {}ms, request timeout: {}ms)",
                     request.header.apiKey(), request.header.correlationId(), nodeId,
                     request.timeElapsedSinceCreateMs(now), request.timeElapsedSinceSendMs(now),
-                    request.requestTimeoutMs);
+                    request.throttleTimeMs(), request.requestTimeoutMs);
             }
 
             if (!request.isInternalRequest) {
@@ -909,6 +909,7 @@ public class NetworkClient implements KafkaClient {
     private void maybeThrottle(AbstractResponse response, short apiVersion, String nodeId, long now) {
         int throttleTimeMs = response.throttleTimeMs();
         if (throttleTimeMs > 0 && response.shouldClientThrottle(apiVersion)) {
+            inFlightRequests.incrementThrottleTime(nodeId, throttleTimeMs);
             connectionStates.throttle(nodeId, now + throttleTimeMs);
             log.trace("Connection to node {} is throttled for {} ms until timestamp {}", nodeId, throttleTimeMs,
                       now + throttleTimeMs);
@@ -1386,6 +1387,7 @@ public class NetworkClient implements KafkaClient {
         final long sendTimeMs;
         final long createdTimeMs;
         final long requestTimeoutMs;
+        long throttleTimeMs;
 
         public InFlightRequest(ClientRequest clientRequest,
                                RequestHeader header,
@@ -1431,6 +1433,10 @@ public class NetworkClient implements KafkaClient {
             return Math.max(0, currentTimeMs - sendTimeMs);
         }
 
+        public long throttleTimeMs() {
+            return throttleTimeMs;
+        }
+
         public long timeElapsedSinceCreateMs(long currentTimeMs) {
             return Math.max(0, currentTimeMs - createdTimeMs);
         }
@@ -1463,6 +1469,10 @@ public class NetworkClient implements KafkaClient {
                     ", callback=" + callback +
                     ", send=" + send + ")";
         }
+
+        public void incrementThrottleTime(long throttleTimeMs) {
+            this.throttleTimeMs = throttleTimeMs + this.throttleTimeMs;
+        }
     }
 
 }
diff --git a/clients/src/test/java/org/apache/kafka/clients/NetworkClientTest.java b/clients/src/test/java/org/apache/kafka/clients/NetworkClientTest.java
index 747049fd19..cd3ec36f38 100644
--- a/clients/src/test/java/org/apache/kafka/clients/NetworkClientTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/NetworkClientTest.java
@@ -560,6 +560,38 @@ public class NetworkClientTest {
             "Expected the connections to fail due to the socket connection setup timeout");
     }
 
+    @Test
+    public void testConnectionTimeoutAfterThrottling() {
+        awaitReady(client, node);
+        short requestVersion = PRODUCE.latestVersion();
+        int timeoutMs = 1000;
+        ProduceRequest.Builder builder = new ProduceRequest.Builder(
+            requestVersion,
+            requestVersion,
+            new ProduceRequestData()
+                .setAcks((short) 1)
+                .setTimeoutMs(timeoutMs));
+        TestCallbackHandler handler = new TestCallbackHandler();
+        ClientRequest r1 = client.newClientRequest(node.idString(), builder, time.milliseconds(), true,
+                defaultRequestTimeoutMs, handler);
+
+        client.send(r1, time.milliseconds());
+        client.poll(0, time.milliseconds());
+
+        // Throttle long enough to ensure other inFlight requests timeout.
+        ProduceResponse pr = new ProduceResponse(new ProduceResponseData().setThrottleTimeMs(timeoutMs));
+        ByteBuffer buffer = RequestTestUtils.serializeResponseWithHeader(pr, requestVersion, r1.correlationId());
+        selector.delayedReceive(new DelayedReceive(node.idString(), new NetworkReceive(node.idString(), buffer)));
+        ClientRequest r2 = client.newClientRequest(node.idString(), builder, time.milliseconds(), true,
+                defaultRequestTimeoutMs, handler);
+        client.send(r2, time.milliseconds());
+        time.sleep(timeoutMs);
+        client.poll(0, time.milliseconds());
+
+        assertEquals(1, client.inFlightRequestCount(node.idString()));
+        assertFalse(client.connectionFailed(node), "Connection should not have failed due to the extra time spent throttling.");
+    }
+
     @Test
     public void testConnectionThrottling() {
         // Instrument the test to return a response with a 100ms throttle delay.
