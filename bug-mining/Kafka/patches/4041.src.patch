diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManager.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManager.java
index 153279162b..98644180e8 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManager.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManager.java
@@ -24,10 +24,12 @@ import org.apache.kafka.common.metrics.Sensor;
 import org.apache.kafka.common.metrics.stats.WindowedCount;
 
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 
+import static org.apache.kafka.common.utils.Utils.mkEntry;
+import static org.apache.kafka.common.utils.Utils.mkMap;
+
 /**
  * The {@link FetchMetricsManager} class provides wrapper methods to record lag, lead, latency, and fetch metrics.
  * It keeps an internal ID of the assigned set of partitions which is updated to ensure the set of metrics it
@@ -101,20 +103,24 @@ public class FetchMetricsManager {
 
     void recordBytesFetched(String topic, int bytes) {
         String name = topicBytesFetchedMetricName(topic);
-        Sensor bytesFetched = new SensorBuilder(metrics, name, () -> topicTags(topic))
-                .withAvg(metricsRegistry.topicFetchSizeAvg)
-                .withMax(metricsRegistry.topicFetchSizeMax)
-                .withMeter(metricsRegistry.topicBytesConsumedRate, metricsRegistry.topicBytesConsumedTotal)
-                .build();
+        maybeRecordDeprecatedBytesFetched(name, topic, bytes);
+
+        Sensor bytesFetched = new SensorBuilder(metrics, name, () -> Map.of("topic", topic))
+            .withAvg(metricsRegistry.topicFetchSizeAvg)
+            .withMax(metricsRegistry.topicFetchSizeMax)
+            .withMeter(metricsRegistry.topicBytesConsumedRate, metricsRegistry.topicBytesConsumedTotal)
+            .build();
         bytesFetched.record(bytes);
     }
 
     void recordRecordsFetched(String topic, int records) {
         String name = topicRecordsFetchedMetricName(topic);
-        Sensor recordsFetched = new SensorBuilder(metrics, name, () -> topicTags(topic))
-                .withAvg(metricsRegistry.topicRecordsPerRequestAvg)
-                .withMeter(metricsRegistry.topicRecordsConsumedRate, metricsRegistry.topicRecordsConsumedTotal)
-                .build();
+        maybeRecordDeprecatedRecordsFetched(name, topic, records);
+
+        Sensor recordsFetched = new SensorBuilder(metrics, name, () -> Map.of("topic", topic))
+            .withAvg(metricsRegistry.topicRecordsPerRequestAvg)
+            .withMeter(metricsRegistry.topicRecordsConsumedRate, metricsRegistry.topicRecordsConsumedTotal)
+            .build();
         recordsFetched.record(records);
     }
 
@@ -122,11 +128,13 @@ public class FetchMetricsManager {
         this.recordsLag.record(lag);
 
         String name = partitionRecordsLagMetricName(tp);
-        Sensor recordsLag = new SensorBuilder(metrics, name, () -> topicPartitionTags(tp))
-                .withValue(metricsRegistry.partitionRecordsLag)
-                .withMax(metricsRegistry.partitionRecordsLagMax)
-                .withAvg(metricsRegistry.partitionRecordsLagAvg)
-                .build();
+        maybeRecordDeprecatedPartitionLag(name, tp, lag);
+
+        Sensor recordsLag = new SensorBuilder(metrics, name, () -> mkMap(mkEntry("topic", tp.topic()), mkEntry("partition", String.valueOf(tp.partition()))))
+            .withValue(metricsRegistry.partitionRecordsLag)
+            .withMax(metricsRegistry.partitionRecordsLagMax)
+            .withAvg(metricsRegistry.partitionRecordsLagAvg)
+            .build();
 
         recordsLag.record(lag);
     }
@@ -135,11 +143,13 @@ public class FetchMetricsManager {
         this.recordsLead.record(lead);
 
         String name = partitionRecordsLeadMetricName(tp);
-        Sensor recordsLead = new SensorBuilder(metrics, name, () -> topicPartitionTags(tp))
-                .withValue(metricsRegistry.partitionRecordsLead)
-                .withMin(metricsRegistry.partitionRecordsLeadMin)
-                .withAvg(metricsRegistry.partitionRecordsLeadAvg)
-                .build();
+        maybeRecordDeprecatedPartitionLead(name, tp, lead);
+
+        Sensor recordsLead = new SensorBuilder(metrics, name, () -> mkMap(mkEntry("topic", tp.topic()), mkEntry("partition", String.valueOf(tp.partition()))))
+            .withValue(metricsRegistry.partitionRecordsLead)
+            .withMin(metricsRegistry.partitionRecordsLeadMin)
+            .withAvg(metricsRegistry.partitionRecordsLeadAvg)
+            .build();
 
         recordsLead.record(lead);
     }
@@ -162,16 +172,22 @@ public class FetchMetricsManager {
                     metrics.removeSensor(partitionRecordsLagMetricName(tp));
                     metrics.removeSensor(partitionRecordsLeadMetricName(tp));
                     metrics.removeMetric(partitionPreferredReadReplicaMetricName(tp));
+                    // Remove deprecated metrics.
+                    metrics.removeSensor(deprecatedMetricName(partitionRecordsLagMetricName(tp)));
+                    metrics.removeSensor(deprecatedMetricName(partitionRecordsLeadMetricName(tp)));
+                    metrics.removeMetric(deprecatedPartitionPreferredReadReplicaMetricName(tp));
                 }
             }
 
             for (TopicPartition tp : newAssignedPartitions) {
                 if (!this.assignedPartitions.contains(tp)) {
+                    maybeRecordDeprecatedPreferredReadReplica(tp, subscription);
+
                     MetricName metricName = partitionPreferredReadReplicaMetricName(tp);
                     metrics.addMetricIfAbsent(
-                            metricName,
-                            null,
-                            (Gauge<Integer>) (config, now) -> subscription.preferredReadReplica(tp, 0L).orElse(-1)
+                        metricName,
+                        null,
+                        (Gauge<Integer>) (config, now) -> subscription.preferredReadReplica(tp, 0L).orElse(-1)
                     );
                 }
             }
@@ -181,6 +197,67 @@ public class FetchMetricsManager {
         }
     }
 
+    @Deprecated // To be removed in Kafka 5.0 release.
+    private void maybeRecordDeprecatedBytesFetched(String name, String topic, int bytes) {
+        if (shouldReportDeprecatedMetric(topic)) {
+            Sensor deprecatedBytesFetched = new SensorBuilder(metrics, deprecatedMetricName(name), () -> topicTags(topic))
+                .withAvg(metricsRegistry.topicFetchSizeAvg)
+                .withMax(metricsRegistry.topicFetchSizeMax)
+                .withMeter(metricsRegistry.topicBytesConsumedRate, metricsRegistry.topicBytesConsumedTotal)
+                .build();
+            deprecatedBytesFetched.record(bytes);
+        }
+    }
+
+    @Deprecated // To be removed in Kafka 5.0 release.
+    private void maybeRecordDeprecatedRecordsFetched(String name, String topic, int records) {
+        if (shouldReportDeprecatedMetric(topic)) {
+            Sensor deprecatedRecordsFetched = new SensorBuilder(metrics, deprecatedMetricName(name), () -> topicTags(topic))
+                .withAvg(metricsRegistry.topicRecordsPerRequestAvg)
+                .withMeter(metricsRegistry.topicRecordsConsumedRate, metricsRegistry.topicRecordsConsumedTotal)
+                .build();
+            deprecatedRecordsFetched.record(records);
+        }
+    }
+
+    @Deprecated // To be removed in Kafka 5.0 release.
+    private void maybeRecordDeprecatedPartitionLag(String name, TopicPartition tp, long lag) {
+        if (shouldReportDeprecatedMetric(tp.topic())) {
+            Sensor deprecatedRecordsLag = new SensorBuilder(metrics, deprecatedMetricName(name), () -> topicPartitionTags(tp))
+                .withValue(metricsRegistry.partitionRecordsLag)
+                .withMax(metricsRegistry.partitionRecordsLagMax)
+                .withAvg(metricsRegistry.partitionRecordsLagAvg)
+                .build();
+
+            deprecatedRecordsLag.record(lag);
+        }
+    }
+
+    @Deprecated // To be removed in Kafka 5.0 release.
+    private void maybeRecordDeprecatedPartitionLead(String name, TopicPartition tp, double lead) {
+        if (shouldReportDeprecatedMetric(tp.topic())) {
+            Sensor deprecatedRecordsLead = new SensorBuilder(metrics, deprecatedMetricName(name), () -> topicPartitionTags(tp))
+                .withValue(metricsRegistry.partitionRecordsLead)
+                .withMin(metricsRegistry.partitionRecordsLeadMin)
+                .withAvg(metricsRegistry.partitionRecordsLeadAvg)
+                .build();
+
+            deprecatedRecordsLead.record(lead);
+        }
+    }
+
+    @Deprecated // To be removed in Kafka 5.0 release.
+    private void maybeRecordDeprecatedPreferredReadReplica(TopicPartition tp, SubscriptionState subscription) {
+        if (shouldReportDeprecatedMetric(tp.topic())) {
+            MetricName metricName = deprecatedPartitionPreferredReadReplicaMetricName(tp);
+            metrics.addMetricIfAbsent(
+                metricName,
+                null,
+                (Gauge<Integer>) (config, now) -> subscription.preferredReadReplica(tp, 0L).orElse(-1)
+            );
+        }
+    }
+
     private static String topicBytesFetchedMetricName(String topic) {
         return "topic." + topic + ".bytes-fetched";
     }
@@ -197,22 +274,34 @@ public class FetchMetricsManager {
         return tp + ".records-lag";
     }
 
+    private static String deprecatedMetricName(String name) {
+        return name + ".deprecated";
+    }
+
+    private static boolean shouldReportDeprecatedMetric(String topic) {
+        return topic.contains(".");
+    }
+
     private MetricName partitionPreferredReadReplicaMetricName(TopicPartition tp) {
+        Map<String, String> metricTags = mkMap(mkEntry("topic", tp.topic()), mkEntry("partition", String.valueOf(tp.partition())));
+        return this.metrics.metricInstance(metricsRegistry.partitionPreferredReadReplica, metricTags);
+    }
+
+    @Deprecated
+    private MetricName deprecatedPartitionPreferredReadReplicaMetricName(TopicPartition tp) {
         Map<String, String> metricTags = topicPartitionTags(tp);
         return this.metrics.metricInstance(metricsRegistry.partitionPreferredReadReplica, metricTags);
     }
 
+    @Deprecated
     static Map<String, String> topicTags(String topic) {
-        Map<String, String> metricTags = new HashMap<>(1);
-        metricTags.put("topic", topic.replace('.', '_'));
-        return metricTags;
+        return Map.of("topic", topic.replace('.', '_'));
     }
 
+    @Deprecated
     static Map<String, String> topicPartitionTags(TopicPartition tp) {
-        Map<String, String> metricTags = new HashMap<>(2);
-        metricTags.put("topic", tp.topic().replace('.', '_'));
-        metricTags.put("partition", String.valueOf(tp.partition()));
-        return metricTags;
+        return mkMap(mkEntry("topic", tp.topic().replace('.', '_')),
+            mkEntry("partition", String.valueOf(tp.partition())));
     }
 
 }
\ No newline at end of file
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsRegistry.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsRegistry.java
index b0e69bb22a..589cb6736b 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsRegistry.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/FetchMetricsRegistry.java
@@ -26,6 +26,9 @@ import java.util.Set;
 
 public class FetchMetricsRegistry {
 
+    private static final String DEPRECATED_TOPIC_METRICS_MESSAGE = "Note: For topic names with periods (.), an additional "
+        + "metric with underscores is emitted. However, the periods replaced metric is deprecated. Please use the metric with actual topic name instead.";
+
     public MetricNameTemplate fetchSizeAvg;
     public MetricNameTemplate fetchSizeMax;
     public MetricNameTemplate bytesConsumedRate;
@@ -110,39 +113,39 @@ public class FetchMetricsRegistry {
         topicTags.add("topic");
 
         this.topicFetchSizeAvg = new MetricNameTemplate("fetch-size-avg", groupName,
-                "The average number of bytes fetched per request for a topic", topicTags);
+                "The average number of bytes fetched per request for a topic. " + DEPRECATED_TOPIC_METRICS_MESSAGE, topicTags);
         this.topicFetchSizeMax = new MetricNameTemplate("fetch-size-max", groupName,
-                "The maximum number of bytes fetched per request for a topic", topicTags);
+                "The maximum number of bytes fetched per request for a topic. " + DEPRECATED_TOPIC_METRICS_MESSAGE, topicTags);
         this.topicBytesConsumedRate = new MetricNameTemplate("bytes-consumed-rate", groupName,
-                "The average number of bytes consumed per second for a topic", topicTags);
+                "The average number of bytes consumed per second for a topic. " + DEPRECATED_TOPIC_METRICS_MESSAGE, topicTags);
         this.topicBytesConsumedTotal = new MetricNameTemplate("bytes-consumed-total", groupName,
-                "The total number of bytes consumed for a topic", topicTags);
+                "The total number of bytes consumed for a topic. " + DEPRECATED_TOPIC_METRICS_MESSAGE, topicTags);
 
         this.topicRecordsPerRequestAvg = new MetricNameTemplate("records-per-request-avg", groupName,
-                "The average number of records in each request for a topic", topicTags);
+                "The average number of records in each request for a topic. " + DEPRECATED_TOPIC_METRICS_MESSAGE, topicTags);
         this.topicRecordsConsumedRate = new MetricNameTemplate("records-consumed-rate", groupName,
-                "The average number of records consumed per second for a topic", topicTags);
+                "The average number of records consumed per second for a topic. " + DEPRECATED_TOPIC_METRICS_MESSAGE, topicTags);
         this.topicRecordsConsumedTotal = new MetricNameTemplate("records-consumed-total", groupName,
-                "The total number of records consumed for a topic", topicTags);
+                "The total number of records consumed for a topic. " + DEPRECATED_TOPIC_METRICS_MESSAGE, topicTags);
 
         /* Partition level */
         Set<String> partitionTags = new HashSet<>(topicTags);
         partitionTags.add("partition");
         this.partitionRecordsLag = new MetricNameTemplate("records-lag", groupName,
-                "The latest lag of the partition", partitionTags);
+                "The latest lag of the partition. " + DEPRECATED_TOPIC_METRICS_MESSAGE, partitionTags);
         this.partitionRecordsLagMax = new MetricNameTemplate("records-lag-max", groupName,
-                "The max lag of the partition", partitionTags);
+                "The max lag of the partition. " + DEPRECATED_TOPIC_METRICS_MESSAGE, partitionTags);
         this.partitionRecordsLagAvg = new MetricNameTemplate("records-lag-avg", groupName,
-                "The average lag of the partition", partitionTags);
+                "The average lag of the partition. " + DEPRECATED_TOPIC_METRICS_MESSAGE, partitionTags);
         this.partitionRecordsLead = new MetricNameTemplate("records-lead", groupName,
-                "The latest lead of the partition", partitionTags);
+                "The latest lead of the partition. " + DEPRECATED_TOPIC_METRICS_MESSAGE, partitionTags);
         this.partitionRecordsLeadMin = new MetricNameTemplate("records-lead-min", groupName,
-                "The min lead of the partition", partitionTags);
+                "The min lead of the partition. " + DEPRECATED_TOPIC_METRICS_MESSAGE, partitionTags);
         this.partitionRecordsLeadAvg = new MetricNameTemplate("records-lead-avg", groupName,
-                "The average lead of the partition", partitionTags);
+                "The average lead of the partition. " + DEPRECATED_TOPIC_METRICS_MESSAGE, partitionTags);
         this.partitionPreferredReadReplica = new MetricNameTemplate(
                 "preferred-read-replica", groupName,
-                "The current read replica for the partition, or -1 if reading from leader", partitionTags);
+                "The current read replica for the partition, or -1 if reading from leader. " + DEPRECATED_TOPIC_METRICS_MESSAGE, partitionTags);
     }
 
     public List<MetricNameTemplate> getAllTemplates() {
diff --git a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManagerTest.java b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManagerTest.java
index c7daeb5334..8dc50b1e66 100644
--- a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManagerTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetchMetricsManagerTest.java
@@ -24,6 +24,7 @@ import org.apache.kafka.common.metrics.Metrics;
 import org.apache.kafka.common.metrics.Sensor;
 import org.apache.kafka.common.metrics.stats.Avg;
 import org.apache.kafka.common.metrics.stats.Max;
+import org.apache.kafka.common.utils.LogContext;
 import org.apache.kafka.common.utils.MockTime;
 import org.apache.kafka.common.utils.Time;
 
@@ -32,10 +33,12 @@ import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 import java.util.Map;
+import java.util.Set;
 
 import static org.apache.kafka.clients.consumer.internals.FetchMetricsManager.topicPartitionTags;
 import static org.apache.kafka.clients.consumer.internals.FetchMetricsManager.topicTags;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class FetchMetricsManagerTest {
 
@@ -43,7 +46,6 @@ public class FetchMetricsManagerTest {
 
     private final Time time = new MockTime(1, 0, 0);
     private static final String TOPIC_NAME = "test";
-    private static final TopicPartition TP = new TopicPartition(TOPIC_NAME, 0);
 
     private Metrics metrics;
     private FetchMetricsRegistry metricsRegistry;
@@ -115,22 +117,43 @@ public class FetchMetricsManagerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testBytesFetchedTopic() {
         String topicName1 = TOPIC_NAME;
-        String topicName2 = "another-topic";
-        Map<String, String> tags1 = topicTags(topicName1);
-        Map<String, String> tags2 = topicTags(topicName2);
+        String topicName2 = "another.topic";
+        Map<String, String> tags1 = Map.of("topic", topicName1);
+        Map<String, String> tags2 = Map.of("topic", topicName2);
+        Map<String, String> deprecatedTags = topicTags(topicName2);
+        int initialMetricsSize = metrics.metrics().size();
 
         metricsManager.recordBytesFetched(topicName1, 2);
+        // 4 new metrics shall be registered.
+        assertEquals(4, metrics.metrics().size() - initialMetricsSize);
         metricsManager.recordBytesFetched(topicName2, 1);
+        // Another 8 metrics get registered as deprecated metrics should be reported for topicName2.
+        assertEquals(12, metrics.metrics().size() - initialMetricsSize);
+
         time.sleep(metrics.config().timeWindowMs() + 1);
         metricsManager.recordBytesFetched(topicName1, 10);
         metricsManager.recordBytesFetched(topicName2, 5);
 
+        // Subsequent calls should not register new metrics.
+        assertEquals(12, metrics.metrics().size() - initialMetricsSize);
+        // Validate metrics for topicName1.
         assertEquals(6, metricValue(metricsRegistry.topicFetchSizeAvg, tags1), EPSILON);
         assertEquals(10, metricValue(metricsRegistry.topicFetchSizeMax, tags1), EPSILON);
+        assertTrue(metricValue(metricsRegistry.topicBytesConsumedRate, tags1) > 0);
+        assertEquals(12, metricValue(metricsRegistry.topicBytesConsumedTotal, tags1), EPSILON);
+        // Validate metrics for topicName2.
         assertEquals(3, metricValue(metricsRegistry.topicFetchSizeAvg, tags2), EPSILON);
         assertEquals(5, metricValue(metricsRegistry.topicFetchSizeMax, tags2), EPSILON);
+        assertTrue(metricValue(metricsRegistry.topicBytesConsumedRate, tags2) > 0);
+        assertEquals(6, metricValue(metricsRegistry.topicBytesConsumedTotal, tags2), EPSILON);
+        // Validate metrics for deprecated topic.
+        assertEquals(3, metricValue(metricsRegistry.topicFetchSizeAvg, deprecatedTags), EPSILON);
+        assertEquals(5, metricValue(metricsRegistry.topicFetchSizeMax, deprecatedTags), EPSILON);
+        assertTrue(metricValue(metricsRegistry.topicBytesConsumedRate, deprecatedTags) > 0);
+        assertEquals(6, metricValue(metricsRegistry.topicBytesConsumedTotal, deprecatedTags), EPSILON);
     }
 
     @Test
@@ -143,48 +166,216 @@ public class FetchMetricsManagerTest {
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testRecordsFetchedTopic() {
         String topicName1 = TOPIC_NAME;
-        String topicName2 = "another-topic";
-        Map<String, String> tags1 = topicTags(topicName1);
-        Map<String, String> tags2 = topicTags(topicName2);
+        String topicName2 = "another.topic";
+        Map<String, String> tags1 = Map.of("topic", topicName1);
+        Map<String, String> tags2 = Map.of("topic", topicName2);
+        Map<String, String> deprecatedTags = topicTags(topicName2);
+        int initialMetricsSize = metrics.metrics().size();
 
         metricsManager.recordRecordsFetched(topicName1, 2);
+        // 3 new metrics shall be registered.
+        assertEquals(3, metrics.metrics().size() - initialMetricsSize);
         metricsManager.recordRecordsFetched(topicName2, 1);
+        // Another 6 metrics get registered as deprecated metrics should be reported for topicName2.
+        assertEquals(9, metrics.metrics().size() - initialMetricsSize);
+
         time.sleep(metrics.config().timeWindowMs() + 1);
         metricsManager.recordRecordsFetched(topicName1, 10);
         metricsManager.recordRecordsFetched(topicName2, 5);
 
+        // Subsequent calls should not register new metrics.
+        assertEquals(9, metrics.metrics().size() - initialMetricsSize);
+        // Validate metrics for topicName1.
         assertEquals(6, metricValue(metricsRegistry.topicRecordsPerRequestAvg, tags1), EPSILON);
+        assertTrue(metricValue(metricsRegistry.topicRecordsConsumedRate, tags1) > 0);
+        assertEquals(12, metricValue(metricsRegistry.topicRecordsConsumedTotal, tags1), EPSILON);
+        // Validate metrics for topicName2.
         assertEquals(3, metricValue(metricsRegistry.topicRecordsPerRequestAvg, tags2), EPSILON);
+        assertTrue(metricValue(metricsRegistry.topicRecordsConsumedRate, tags2) > 0);
+        assertEquals(6, metricValue(metricsRegistry.topicRecordsConsumedTotal, tags2), EPSILON);
+        // Validate metrics for deprecated topic.
+        assertEquals(3, metricValue(metricsRegistry.topicRecordsPerRequestAvg, deprecatedTags), EPSILON);
+        assertTrue(metricValue(metricsRegistry.topicRecordsConsumedRate, deprecatedTags) > 0);
+        assertEquals(6, metricValue(metricsRegistry.topicRecordsConsumedTotal, deprecatedTags), EPSILON);
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testPartitionLag() {
-        Map<String, String> tags = topicPartitionTags(TP);
-        metricsManager.recordPartitionLag(TP, 14);
-        metricsManager.recordPartitionLag(TP, 8);
+        TopicPartition tp1 = new TopicPartition(TOPIC_NAME, 0);
+        TopicPartition tp2 = new TopicPartition("another.topic", 0);
+
+        Map<String, String> tags1 = Map.of("topic", tp1.topic(), "partition", String.valueOf(tp1.partition()));
+        Map<String, String> tags2 = Map.of("topic", tp2.topic(), "partition", String.valueOf(tp2.partition()));
+        Map<String, String> deprecatedTags = topicPartitionTags(tp2);
+        int initialMetricsSize = metrics.metrics().size();
+
+        metricsManager.recordPartitionLag(tp1, 14);
+        // 3 new metrics shall be registered.
+        assertEquals(3, metrics.metrics().size() - initialMetricsSize);
+
+        metricsManager.recordPartitionLag(tp1, 8);
         time.sleep(metrics.config().timeWindowMs() + 1);
-        metricsManager.recordPartitionLag(TP, 5);
+        metricsManager.recordPartitionLag(tp1, 5);
 
+        // Subsequent calls should not register new metrics.
+        assertEquals(3, metrics.metrics().size() - initialMetricsSize);
+        // Validate metrics for tp1.
         assertEquals(14, metricValue(metricsRegistry.recordsLagMax), EPSILON);
-        assertEquals(5, metricValue(metricsRegistry.partitionRecordsLag, tags), EPSILON);
-        assertEquals(14, metricValue(metricsRegistry.partitionRecordsLagMax, tags), EPSILON);
-        assertEquals(9, metricValue(metricsRegistry.partitionRecordsLagAvg, tags), EPSILON);
+        assertEquals(5, metricValue(metricsRegistry.partitionRecordsLag, tags1), EPSILON);
+        assertEquals(14, metricValue(metricsRegistry.partitionRecordsLagMax, tags1), EPSILON);
+        assertEquals(9, metricValue(metricsRegistry.partitionRecordsLagAvg, tags1), EPSILON);
+
+        metricsManager.recordPartitionLag(tp2, 7);
+        // Another 6 metrics get registered as deprecated metrics should be reported for tp2.
+        assertEquals(9, metrics.metrics().size() - initialMetricsSize);
+        metricsManager.recordPartitionLag(tp2, 3);
+        time.sleep(metrics.config().timeWindowMs() + 1);
+        metricsManager.recordPartitionLag(tp2, 2);
+
+        // Subsequent calls should not register new metrics.
+        assertEquals(9, metrics.metrics().size() - initialMetricsSize);
+        // Validate metrics for tp2.
+        assertEquals(7, metricValue(metricsRegistry.recordsLagMax), EPSILON);
+        assertEquals(2, metricValue(metricsRegistry.partitionRecordsLag, tags2), EPSILON);
+        assertEquals(7, metricValue(metricsRegistry.partitionRecordsLagMax, tags2), EPSILON);
+        assertEquals(4, metricValue(metricsRegistry.partitionRecordsLagAvg, tags2), EPSILON);
+        // Validate metrics for deprecated topic.
+        assertEquals(2, metricValue(metricsRegistry.partitionRecordsLag, deprecatedTags), EPSILON);
+        assertEquals(7, metricValue(metricsRegistry.partitionRecordsLagMax, deprecatedTags), EPSILON);
+        assertEquals(4, metricValue(metricsRegistry.partitionRecordsLagAvg, deprecatedTags), EPSILON);
     }
 
     @Test
+    @SuppressWarnings("deprecation")
     public void testPartitionLead() {
-        Map<String, String> tags = topicPartitionTags(TP);
-        metricsManager.recordPartitionLead(TP, 15);
-        metricsManager.recordPartitionLead(TP, 11);
+        TopicPartition tp1 = new TopicPartition(TOPIC_NAME, 0);
+        TopicPartition tp2 = new TopicPartition("another.topic", 0);
+
+        Map<String, String> tags1 = Map.of("topic", tp1.topic(), "partition", String.valueOf(tp1.partition()));
+        Map<String, String> tags2 = Map.of("topic", tp2.topic(), "partition", String.valueOf(tp2.partition()));
+        Map<String, String> deprecatedTags = topicPartitionTags(tp2);
+        int initialMetricsSize = metrics.metrics().size();
+
+        metricsManager.recordPartitionLead(tp1, 15);
+        // 3 new metrics shall be registered.
+        assertEquals(3, metrics.metrics().size() - initialMetricsSize);
+
+        metricsManager.recordPartitionLead(tp1, 11);
         time.sleep(metrics.config().timeWindowMs() + 1);
-        metricsManager.recordPartitionLead(TP, 13);
+        metricsManager.recordPartitionLead(tp1, 13);
 
+        // Subsequent calls should not register new metrics.
+        assertEquals(3, metrics.metrics().size() - initialMetricsSize);
+        // Validate metrics for tp1.
         assertEquals(11, metricValue(metricsRegistry.recordsLeadMin), EPSILON);
-        assertEquals(13, metricValue(metricsRegistry.partitionRecordsLead, tags), EPSILON);
-        assertEquals(11, metricValue(metricsRegistry.partitionRecordsLeadMin, tags), EPSILON);
-        assertEquals(13, metricValue(metricsRegistry.partitionRecordsLeadAvg, tags), EPSILON);
+        assertEquals(13, metricValue(metricsRegistry.partitionRecordsLead, tags1), EPSILON);
+        assertEquals(11, metricValue(metricsRegistry.partitionRecordsLeadMin, tags1), EPSILON);
+        assertEquals(13, metricValue(metricsRegistry.partitionRecordsLeadAvg, tags1), EPSILON);
+
+        metricsManager.recordPartitionLead(tp2, 18);
+        // Another 6 metrics get registered as deprecated metrics should be reported for tp2.
+        assertEquals(9, metrics.metrics().size() - initialMetricsSize);
+
+        metricsManager.recordPartitionLead(tp2, 12);
+        time.sleep(metrics.config().timeWindowMs() + 1);
+        metricsManager.recordPartitionLead(tp2, 15);
+
+        // Subsequent calls should not register new metrics.
+        assertEquals(9, metrics.metrics().size() - initialMetricsSize);
+        // Validate metrics for tp2.
+        assertEquals(12, metricValue(metricsRegistry.recordsLeadMin), EPSILON);
+        assertEquals(15, metricValue(metricsRegistry.partitionRecordsLead, tags2), EPSILON);
+        assertEquals(12, metricValue(metricsRegistry.partitionRecordsLeadMin, tags2), EPSILON);
+        assertEquals(15, metricValue(metricsRegistry.partitionRecordsLeadAvg, tags2), EPSILON);
+        // Validate metrics for deprecated topic.
+        assertEquals(15, metricValue(metricsRegistry.partitionRecordsLead, deprecatedTags), EPSILON);
+        assertEquals(12, metricValue(metricsRegistry.partitionRecordsLeadMin, deprecatedTags), EPSILON);
+        assertEquals(15, metricValue(metricsRegistry.partitionRecordsLeadAvg, deprecatedTags), EPSILON);
+    }
+
+    @Test
+    @SuppressWarnings("deprecation")
+    public void testMaybeUpdateAssignment() {
+        TopicPartition tp1 = new TopicPartition(TOPIC_NAME, 0);
+        TopicPartition tp2 = new TopicPartition("another.topic", 0);
+        TopicPartition tp3 = new TopicPartition("another.topic", 1);
+        int initialMetricsSize = metrics.metrics().size();
+
+        SubscriptionState subscriptionState = new SubscriptionState(new LogContext(), AutoOffsetResetStrategy.NONE);
+        subscriptionState.assignFromUser(Set.of(tp1));
+
+        metricsManager.maybeUpdateAssignment(subscriptionState);
+        // 1 new metrics shall be registered.
+        assertEquals(1, metrics.metrics().size() - initialMetricsSize);
+
+        subscriptionState.assignFromUser(Set.of(tp1, tp2));
+        subscriptionState.updatePreferredReadReplica(tp2, 1, () -> 0L);
+        metricsManager.maybeUpdateAssignment(subscriptionState);
+        // Another 2 metrics get registered as deprecated metrics should be reported for tp2.
+        assertEquals(3, metrics.metrics().size() - initialMetricsSize);
+
+        Map<String, String> tags1 = Map.of("topic", tp1.topic(), "partition", String.valueOf(tp1.partition()));
+        Map<String, String> tags2 = Map.of("topic", tp2.topic(), "partition", String.valueOf(tp2.partition()));
+        Map<String, String> deprecatedTags = topicPartitionTags(tp2);
+        // Validate preferred read replica metrics.
+        assertEquals(-1, readReplicaMetricValue(metricsRegistry.partitionPreferredReadReplica, tags1), EPSILON);
+        assertEquals(1, readReplicaMetricValue(metricsRegistry.partitionPreferredReadReplica, tags2), EPSILON);
+        assertEquals(1, readReplicaMetricValue(metricsRegistry.partitionPreferredReadReplica, deprecatedTags), EPSILON);
+
+        // Remove tp2 from subscription set.
+        subscriptionState.assignFromUser(Set.of(tp1, tp3));
+        metricsManager.maybeUpdateAssignment(subscriptionState);
+        // Metrics count shall remain same as tp2 should be removed and tp3 gets added.
+        assertEquals(3, metrics.metrics().size() - initialMetricsSize);
+
+        // Remove all partitions.
+        subscriptionState.assignFromUser(Set.of());
+        metricsManager.maybeUpdateAssignment(subscriptionState);
+        // Metrics count shall be same as initial count as all new metrics shall be removed.
+        assertEquals(initialMetricsSize, metrics.metrics().size());
+    }
+
+    @Test
+    public void testMaybeUpdateAssignmentWithAdditionalRegisteredMetrics() {
+        TopicPartition tp1 = new TopicPartition(TOPIC_NAME, 0);
+        TopicPartition tp2 = new TopicPartition("another.topic", 0);
+        TopicPartition tp3 = new TopicPartition("another.topic", 1);
+
+        int initialMetricsSize = metrics.metrics().size();
+
+        metricsManager.recordPartitionLag(tp1, 14);
+        metricsManager.recordPartitionLead(tp1, 11);
+        metricsManager.recordPartitionLag(tp2, 5);
+        metricsManager.recordPartitionLead(tp2, 1);
+        metricsManager.recordPartitionLag(tp3, 4);
+        metricsManager.recordPartitionLead(tp3, 2);
+
+        int additionalRegisteredMetricsSize = metrics.metrics().size();
+
+        SubscriptionState subscriptionState = new SubscriptionState(new LogContext(), AutoOffsetResetStrategy.NONE);
+        subscriptionState.assignFromUser(Set.of(tp1, tp2, tp3));
+        metricsManager.maybeUpdateAssignment(subscriptionState);
+
+        // 5 new metrics shall be registered.
+        assertEquals(5, metrics.metrics().size() - additionalRegisteredMetricsSize);
+
+        // Remove 1 partition which has deprecated metrics as well.
+        subscriptionState.assignFromUser(Set.of(tp1, tp2));
+        metricsManager.maybeUpdateAssignment(subscriptionState);
+        // For tp2, 14 metrics will be unregistered. 3 for partition lag, 3 for partition lead, 1 for
+        // preferred read replica and similarly 7 deprecated metrics. Hence, we should have 9 metrics
+        // removed from additionalRegisteredMetricsSize.
+        assertEquals(9, additionalRegisteredMetricsSize - metrics.metrics().size());
+
+        // Remove all partitions.
+        subscriptionState.assignFromUser(Set.of());
+        metricsManager.maybeUpdateAssignment(subscriptionState);
+        // Metrics count shall be same as initial count as all new metrics shall be removed.
+        assertEquals(initialMetricsSize, metrics.metrics().size());
     }
 
     private void registerNodeLatencyMetric(String connectionId, MetricName nodeLatencyAvg, MetricName nodeLatencyMax) {
@@ -209,4 +400,9 @@ public class FetchMetricsManagerTest {
         return (Double) metric.metricValue();
     }
 
+    private Integer readReplicaMetricValue(MetricNameTemplate name, Map<String, String> tags) {
+        MetricName metricName = metrics.metricInstance(name, tags);
+        KafkaMetric metric = metrics.metric(metricName);
+        return (Integer) metric.metricValue();
+    }
 }
