diff --git a/core/src/main/scala/kafka/server/KafkaApis.scala b/core/src/main/scala/kafka/server/KafkaApis.scala
index 3e01fb5f55..12280155bb 100644
--- a/core/src/main/scala/kafka/server/KafkaApis.scala
+++ b/core/src/main/scala/kafka/server/KafkaApis.scala
@@ -186,77 +186,77 @@ class KafkaApis(val requestChannel: RequestChannel,
       trace(s"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};" +
         s"securityProtocol:${request.context.securityProtocol},principal:${request.context.principal}")
 
-      request.envelope.foreach { envelope =>
-        if (maybeHandleInvalidEnvelope(envelope, request.header.apiKey)) {
-          return
+      val handled = request.envelope.exists { envelope =>
+        maybeHandleInvalidEnvelope(envelope, request.header.apiKey)
+      }
+
+      if (!handled) {
+        request.header.apiKey match {
+          case ApiKeys.PRODUCE => handleProduceRequest(request)
+          case ApiKeys.FETCH => handleFetchRequest(request)
+          case ApiKeys.LIST_OFFSETS => handleListOffsetRequest(request)
+          case ApiKeys.METADATA => handleTopicMetadataRequest(request)
+          case ApiKeys.LEADER_AND_ISR => handleLeaderAndIsrRequest(request)
+          case ApiKeys.STOP_REPLICA => handleStopReplicaRequest(request)
+          case ApiKeys.UPDATE_METADATA => handleUpdateMetadataRequest(request)
+          case ApiKeys.CONTROLLED_SHUTDOWN => handleControlledShutdownRequest(request)
+          case ApiKeys.OFFSET_COMMIT => handleOffsetCommitRequest(request)
+          case ApiKeys.OFFSET_FETCH => handleOffsetFetchRequest(request)
+          case ApiKeys.FIND_COORDINATOR => handleFindCoordinatorRequest(request)
+          case ApiKeys.JOIN_GROUP => handleJoinGroupRequest(request)
+          case ApiKeys.HEARTBEAT => handleHeartbeatRequest(request)
+          case ApiKeys.LEAVE_GROUP => handleLeaveGroupRequest(request)
+          case ApiKeys.SYNC_GROUP => handleSyncGroupRequest(request)
+          case ApiKeys.DESCRIBE_GROUPS => handleDescribeGroupRequest(request)
+          case ApiKeys.LIST_GROUPS => handleListGroupsRequest(request)
+          case ApiKeys.SASL_HANDSHAKE => handleSaslHandshakeRequest(request)
+          case ApiKeys.API_VERSIONS => handleApiVersionsRequest(request)
+          case ApiKeys.CREATE_TOPICS => maybeForward(request, handleCreateTopicsRequest)
+          case ApiKeys.DELETE_TOPICS => maybeForward(request, handleDeleteTopicsRequest)
+          case ApiKeys.DELETE_RECORDS => handleDeleteRecordsRequest(request)
+          case ApiKeys.INIT_PRODUCER_ID => handleInitProducerIdRequest(request)
+          case ApiKeys.OFFSET_FOR_LEADER_EPOCH => handleOffsetForLeaderEpochRequest(request)
+          case ApiKeys.ADD_PARTITIONS_TO_TXN => handleAddPartitionToTxnRequest(request)
+          case ApiKeys.ADD_OFFSETS_TO_TXN => handleAddOffsetsToTxnRequest(request)
+          case ApiKeys.END_TXN => handleEndTxnRequest(request)
+          case ApiKeys.WRITE_TXN_MARKERS => handleWriteTxnMarkersRequest(request)
+          case ApiKeys.TXN_OFFSET_COMMIT => handleTxnOffsetCommitRequest(request)
+          case ApiKeys.DESCRIBE_ACLS => handleDescribeAcls(request)
+          case ApiKeys.CREATE_ACLS => maybeForward(request, handleCreateAcls)
+          case ApiKeys.DELETE_ACLS => maybeForward(request, handleDeleteAcls)
+          case ApiKeys.ALTER_CONFIGS => maybeForward(request, handleAlterConfigsRequest)
+          case ApiKeys.DESCRIBE_CONFIGS => handleDescribeConfigsRequest(request)
+          case ApiKeys.ALTER_REPLICA_LOG_DIRS => handleAlterReplicaLogDirsRequest(request)
+          case ApiKeys.DESCRIBE_LOG_DIRS => handleDescribeLogDirsRequest(request)
+          case ApiKeys.SASL_AUTHENTICATE => handleSaslAuthenticateRequest(request)
+          case ApiKeys.CREATE_PARTITIONS => maybeForward(request, handleCreatePartitionsRequest)
+          case ApiKeys.CREATE_DELEGATION_TOKEN => maybeForward(request, handleCreateTokenRequest)
+          case ApiKeys.RENEW_DELEGATION_TOKEN => maybeForward(request, handleRenewTokenRequest)
+          case ApiKeys.EXPIRE_DELEGATION_TOKEN => maybeForward(request, handleExpireTokenRequest)
+          case ApiKeys.DESCRIBE_DELEGATION_TOKEN => handleDescribeTokensRequest(request)
+          case ApiKeys.DELETE_GROUPS => handleDeleteGroupsRequest(request)
+          case ApiKeys.ELECT_LEADERS => handleElectReplicaLeader(request)
+          case ApiKeys.INCREMENTAL_ALTER_CONFIGS => maybeForward(request, handleIncrementalAlterConfigsRequest)
+          case ApiKeys.ALTER_PARTITION_REASSIGNMENTS => maybeForward(request, handleAlterPartitionReassignmentsRequest)
+          case ApiKeys.LIST_PARTITION_REASSIGNMENTS => handleListPartitionReassignmentsRequest(request)
+          case ApiKeys.OFFSET_DELETE => handleOffsetDeleteRequest(request)
+          case ApiKeys.DESCRIBE_CLIENT_QUOTAS => handleDescribeClientQuotasRequest(request)
+          case ApiKeys.ALTER_CLIENT_QUOTAS => maybeForward(request, handleAlterClientQuotasRequest)
+          case ApiKeys.DESCRIBE_USER_SCRAM_CREDENTIALS => handleDescribeUserScramCredentialsRequest(request)
+          case ApiKeys.ALTER_USER_SCRAM_CREDENTIALS => maybeForward(request, handleAlterUserScramCredentialsRequest)
+          case ApiKeys.ALTER_ISR => handleAlterIsrRequest(request)
+          case ApiKeys.UPDATE_FEATURES => maybeForward(request, handleUpdateFeatures)
+          case ApiKeys.ENVELOPE => throw new IllegalStateException(
+            "Envelope request should not be handled directly in top level API")
+
+          // Until we are ready to integrate the Raft layer, these APIs are treated as
+          // unexpected and we just close the connection.
+          case ApiKeys.VOTE => closeConnection(request, util.Collections.emptyMap())
+          case ApiKeys.BEGIN_QUORUM_EPOCH => closeConnection(request, util.Collections.emptyMap())
+          case ApiKeys.END_QUORUM_EPOCH => closeConnection(request, util.Collections.emptyMap())
+          case ApiKeys.DESCRIBE_QUORUM => closeConnection(request, util.Collections.emptyMap())
         }
       }
-
-      request.header.apiKey match {
-        case ApiKeys.PRODUCE => handleProduceRequest(request)
-        case ApiKeys.FETCH => handleFetchRequest(request)
-        case ApiKeys.LIST_OFFSETS => handleListOffsetRequest(request)
-        case ApiKeys.METADATA => handleTopicMetadataRequest(request)
-        case ApiKeys.LEADER_AND_ISR => handleLeaderAndIsrRequest(request)
-        case ApiKeys.STOP_REPLICA => handleStopReplicaRequest(request)
-        case ApiKeys.UPDATE_METADATA => handleUpdateMetadataRequest(request)
-        case ApiKeys.CONTROLLED_SHUTDOWN => handleControlledShutdownRequest(request)
-        case ApiKeys.OFFSET_COMMIT => handleOffsetCommitRequest(request)
-        case ApiKeys.OFFSET_FETCH => handleOffsetFetchRequest(request)
-        case ApiKeys.FIND_COORDINATOR => handleFindCoordinatorRequest(request)
-        case ApiKeys.JOIN_GROUP => handleJoinGroupRequest(request)
-        case ApiKeys.HEARTBEAT => handleHeartbeatRequest(request)
-        case ApiKeys.LEAVE_GROUP => handleLeaveGroupRequest(request)
-        case ApiKeys.SYNC_GROUP => handleSyncGroupRequest(request)
-        case ApiKeys.DESCRIBE_GROUPS => handleDescribeGroupRequest(request)
-        case ApiKeys.LIST_GROUPS => handleListGroupsRequest(request)
-        case ApiKeys.SASL_HANDSHAKE => handleSaslHandshakeRequest(request)
-        case ApiKeys.API_VERSIONS => handleApiVersionsRequest(request)
-        case ApiKeys.CREATE_TOPICS => maybeForward(request, handleCreateTopicsRequest)
-        case ApiKeys.DELETE_TOPICS => maybeForward(request, handleDeleteTopicsRequest)
-        case ApiKeys.DELETE_RECORDS => handleDeleteRecordsRequest(request)
-        case ApiKeys.INIT_PRODUCER_ID => handleInitProducerIdRequest(request)
-        case ApiKeys.OFFSET_FOR_LEADER_EPOCH => handleOffsetForLeaderEpochRequest(request)
-        case ApiKeys.ADD_PARTITIONS_TO_TXN => handleAddPartitionToTxnRequest(request)
-        case ApiKeys.ADD_OFFSETS_TO_TXN => handleAddOffsetsToTxnRequest(request)
-        case ApiKeys.END_TXN => handleEndTxnRequest(request)
-        case ApiKeys.WRITE_TXN_MARKERS => handleWriteTxnMarkersRequest(request)
-        case ApiKeys.TXN_OFFSET_COMMIT => handleTxnOffsetCommitRequest(request)
-        case ApiKeys.DESCRIBE_ACLS => handleDescribeAcls(request)
-        case ApiKeys.CREATE_ACLS => maybeForward(request, handleCreateAcls)
-        case ApiKeys.DELETE_ACLS => maybeForward(request, handleDeleteAcls)
-        case ApiKeys.ALTER_CONFIGS => maybeForward(request, handleAlterConfigsRequest)
-        case ApiKeys.DESCRIBE_CONFIGS => handleDescribeConfigsRequest(request)
-        case ApiKeys.ALTER_REPLICA_LOG_DIRS => handleAlterReplicaLogDirsRequest(request)
-        case ApiKeys.DESCRIBE_LOG_DIRS => handleDescribeLogDirsRequest(request)
-        case ApiKeys.SASL_AUTHENTICATE => handleSaslAuthenticateRequest(request)
-        case ApiKeys.CREATE_PARTITIONS => maybeForward(request, handleCreatePartitionsRequest)
-        case ApiKeys.CREATE_DELEGATION_TOKEN => maybeForward(request, handleCreateTokenRequest)
-        case ApiKeys.RENEW_DELEGATION_TOKEN => maybeForward(request, handleRenewTokenRequest)
-        case ApiKeys.EXPIRE_DELEGATION_TOKEN => maybeForward(request, handleExpireTokenRequest)
-        case ApiKeys.DESCRIBE_DELEGATION_TOKEN => handleDescribeTokensRequest(request)
-        case ApiKeys.DELETE_GROUPS => handleDeleteGroupsRequest(request)
-        case ApiKeys.ELECT_LEADERS => handleElectReplicaLeader(request)
-        case ApiKeys.INCREMENTAL_ALTER_CONFIGS => maybeForward(request, handleIncrementalAlterConfigsRequest)
-        case ApiKeys.ALTER_PARTITION_REASSIGNMENTS => maybeForward(request, handleAlterPartitionReassignmentsRequest)
-        case ApiKeys.LIST_PARTITION_REASSIGNMENTS => handleListPartitionReassignmentsRequest(request)
-        case ApiKeys.OFFSET_DELETE => handleOffsetDeleteRequest(request)
-        case ApiKeys.DESCRIBE_CLIENT_QUOTAS => handleDescribeClientQuotasRequest(request)
-        case ApiKeys.ALTER_CLIENT_QUOTAS => maybeForward(request, handleAlterClientQuotasRequest)
-        case ApiKeys.DESCRIBE_USER_SCRAM_CREDENTIALS => handleDescribeUserScramCredentialsRequest(request)
-        case ApiKeys.ALTER_USER_SCRAM_CREDENTIALS => maybeForward(request, handleAlterUserScramCredentialsRequest)
-        case ApiKeys.ALTER_ISR => handleAlterIsrRequest(request)
-        case ApiKeys.UPDATE_FEATURES => maybeForward(request, handleUpdateFeatures)
-        case ApiKeys.ENVELOPE => throw new IllegalStateException(
-          "Envelope request should not be handled directly in top level API")
-
-        // Until we are ready to integrate the Raft layer, these APIs are treated as
-        // unexpected and we just close the connection.
-        case ApiKeys.VOTE => closeConnection(request, util.Collections.emptyMap())
-        case ApiKeys.BEGIN_QUORUM_EPOCH => closeConnection(request, util.Collections.emptyMap())
-        case ApiKeys.END_QUORUM_EPOCH => closeConnection(request, util.Collections.emptyMap())
-        case ApiKeys.DESCRIBE_QUORUM => closeConnection(request, util.Collections.emptyMap())
-      }
     } catch {
       case e: FatalExitError => throw e
       case e: Throwable => handleError(request, e)
diff --git a/core/src/test/scala/unit/kafka/server/KafkaApisTest.scala b/core/src/test/scala/unit/kafka/server/KafkaApisTest.scala
index 04e42aa616..ef566f931b 100644
--- a/core/src/test/scala/unit/kafka/server/KafkaApisTest.scala
+++ b/core/src/test/scala/unit/kafka/server/KafkaApisTest.scala
@@ -292,6 +292,24 @@ class KafkaApisTest {
 
   @Test
   def testEnvelopeRequestHandlingAsController(): Unit = {
+    testEnvelopeRequestWithAlterConfig(
+      alterConfigHandler = () => ApiError.NONE,
+      expectedError = Errors.NONE
+    )
+  }
+
+  @Test
+  def testEnvelopeRequestWithAlterConfigUnhandledError(): Unit = {
+    testEnvelopeRequestWithAlterConfig(
+      alterConfigHandler = () => throw new IllegalStateException(),
+      expectedError = Errors.UNKNOWN_SERVER_ERROR
+    )
+  }
+
+  private def testEnvelopeRequestWithAlterConfig(
+    alterConfigHandler: () => ApiError,
+    expectedError: Errors
+  ): Unit = {
     val authorizer: Authorizer = EasyMock.niceMock(classOf[Authorizer])
 
     authorizeResource(authorizer, AclOperation.CLUSTER_ACTION, ResourceType.CLUSTER, Resource.CLUSTER_NAME, AuthorizationResult.ALLOWED)
@@ -309,7 +327,9 @@ class KafkaApisTest {
 
     val configResource = new ConfigResource(ConfigResource.Type.TOPIC, resourceName)
     EasyMock.expect(adminManager.alterConfigs(anyObject(), EasyMock.eq(false)))
-      .andReturn(Map(configResource -> ApiError.NONE))
+      .andAnswer(() => {
+        Map(configResource -> alterConfigHandler.apply())
+      })
 
     EasyMock.replay(replicaManager, clientRequestQuotaManager, requestChannel, authorizer,
       adminManager, controller)
@@ -338,7 +358,7 @@ class KafkaApisTest {
       resourceResponse.resourceName() -> Errors.forCode(resourceResponse.errorCode)
     }.toMap
 
-    assertEquals(Map(resourceName -> Errors.NONE), responseMap)
+    assertEquals(Map(resourceName -> expectedError), responseMap)
 
     verify(authorizer, controller, adminManager)
   }
@@ -378,6 +398,9 @@ class KafkaApisTest {
       Collections.singletonList(new MemberIdentity())).build(requestHeader.apiVersion)
     val serializedRequestData = RequestTestUtils.serializeRequestWithHeader(requestHeader, leaveGroupRequest)
 
+    resetToStrict(requestChannel)
+
+    EasyMock.expect(requestChannel.updateErrorMetrics(ApiKeys.ENVELOPE, Map(Errors.INVALID_REQUEST -> 1)))
     val capturedResponse = expectNoThrottling()
 
     EasyMock.replay(replicaManager, clientRequestQuotaManager, requestChannel, controller)
@@ -415,7 +438,6 @@ class KafkaApisTest {
   private def testInvalidEnvelopeRequest(expectedError: Errors,
                                          fromPrivilegedListener: Boolean = true,
                                          shouldCloseConnection: Boolean = false,
-                                         principalSerde: Option[KafkaPrincipalSerde] = kafkaPrincipalSerde,
                                          performAuthorize: Boolean = false,
                                          authorizeResult: AuthorizationResult = AuthorizationResult.ALLOWED,
                                          isActiveController: Boolean = true): Unit = {
