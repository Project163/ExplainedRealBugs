diff --git a/checkstyle/suppressions.xml b/checkstyle/suppressions.xml
index f49c3e8edb..862a2927ec 100644
--- a/checkstyle/suppressions.xml
+++ b/checkstyle/suppressions.xml
@@ -306,7 +306,7 @@
     <suppress checks="(ParameterNumber|ClassDataAbstractionCoupling)"
               files="(QuorumController).java"/>
     <suppress checks="CyclomaticComplexity"
-              files="(ClientQuotasImage|MetadataDelta|QuorumController|ReplicationControlManager).java"/>
+              files="(ClientQuotasImage|KafkaEventQueue|MetadataDelta|QuorumController|ReplicationControlManager).java"/>
     <suppress checks="NPathComplexity"
               files="(ClientQuotasImage|KafkaEventQueue|ReplicationControlManager|FeatureControlManager).java"/>
     <suppress checks="(NPathComplexity|ClassFanOutComplexity|CyclomaticComplexity|ClassDataAbstractionCoupling|LocalVariableName|MemberName|ParameterName|MethodLength|JavaNCSS|AvoidStarImport)"
diff --git a/core/src/main/scala/kafka/server/BrokerLifecycleManager.scala b/core/src/main/scala/kafka/server/BrokerLifecycleManager.scala
index dd3f39b156..9e42dfb4d9 100644
--- a/core/src/main/scala/kafka/server/BrokerLifecycleManager.scala
+++ b/core/src/main/scala/kafka/server/BrokerLifecycleManager.scala
@@ -180,7 +180,10 @@ class BrokerLifecycleManager(
   /**
    * The event queue.
    */
-  private[server] val eventQueue = new KafkaEventQueue(time, logContext, threadNamePrefix.getOrElse(""))
+  private[server] val eventQueue = new KafkaEventQueue(time,
+    logContext,
+    threadNamePrefix.getOrElse(""),
+    new ShutdownEvent())
 
   /**
    * Start the BrokerLifecycleManager.
@@ -239,7 +242,7 @@ class BrokerLifecycleManager(
    * Start shutting down the BrokerLifecycleManager, but do not block.
    */
   def beginShutdown(): Unit = {
-    eventQueue.beginShutdown("beginShutdown", new ShutdownEvent())
+    eventQueue.beginShutdown("beginShutdown");
   }
 
   /**
@@ -470,7 +473,7 @@ class BrokerLifecycleManager(
     override def run(): Unit = {
       if (!initialRegistrationSucceeded) {
         error("Shutting down because we were unable to register with the controller quorum.")
-        eventQueue.beginShutdown("registrationTimeout", new ShutdownEvent())
+        eventQueue.beginShutdown("registrationTimeout");
       }
     }
   }
diff --git a/core/src/main/scala/kafka/server/metadata/BrokerMetadataSnapshotter.scala b/core/src/main/scala/kafka/server/metadata/BrokerMetadataSnapshotter.scala
index cbcc515586..b882872255 100644
--- a/core/src/main/scala/kafka/server/metadata/BrokerMetadataSnapshotter.scala
+++ b/core/src/main/scala/kafka/server/metadata/BrokerMetadataSnapshotter.scala
@@ -61,7 +61,7 @@ class BrokerMetadataSnapshotter(
   /**
    * The event queue which runs this listener.
    */
-  val eventQueue = new KafkaEventQueue(time, logContext, threadNamePrefix.getOrElse(""))
+  val eventQueue = new KafkaEventQueue(time, logContext, threadNamePrefix.getOrElse(""), new ShutdownEvent())
 
   override def maybeStartSnapshot(
     lastContainedLogTime: Long,
@@ -126,7 +126,7 @@ class BrokerMetadataSnapshotter(
   }
 
   def beginShutdown(): Unit = {
-    eventQueue.beginShutdown("beginShutdown", new ShutdownEvent())
+    eventQueue.beginShutdown("beginShutdown");
   }
 
   class ShutdownEvent() extends EventQueue.Event {
diff --git a/metadata/src/main/java/org/apache/kafka/image/loader/MetadataLoader.java b/metadata/src/main/java/org/apache/kafka/image/loader/MetadataLoader.java
index 7fe1930c87..c1fd0aa438 100644
--- a/metadata/src/main/java/org/apache/kafka/image/loader/MetadataLoader.java
+++ b/metadata/src/main/java/org/apache/kafka/image/loader/MetadataLoader.java
@@ -25,6 +25,7 @@ import org.apache.kafka.image.MetadataProvenance;
 import org.apache.kafka.image.publisher.MetadataPublisher;
 import org.apache.kafka.image.writer.ImageReWriter;
 import org.apache.kafka.image.writer.ImageWriterOptions;
+import org.apache.kafka.queue.EventQueue;
 import org.apache.kafka.queue.KafkaEventQueue;
 import org.apache.kafka.raft.Batch;
 import org.apache.kafka.raft.BatchReader;
@@ -209,7 +210,7 @@ public class MetadataLoader implements RaftClient.Listener<ApiMessageAndVersion>
         this.uninitializedPublishers = new LinkedHashMap<>();
         this.publishers = new LinkedHashMap<>();
         this.image = MetadataImage.EMPTY;
-        this.eventQueue = new KafkaEventQueue(time, logContext, threadNamePrefix);
+        this.eventQueue = new KafkaEventQueue(time, logContext, threadNamePrefix, new ShutdownEvent());
     }
 
     private boolean stillNeedToCatchUp(long offset) {
@@ -538,9 +539,14 @@ public class MetadataLoader implements RaftClient.Listener<ApiMessageAndVersion>
 
     @Override
     public void beginShutdown() {
-        eventQueue.beginShutdown("beginShutdown", () -> {
+        eventQueue.beginShutdown("beginShutdown");
+    }
+
+    class ShutdownEvent implements EventQueue.Event {
+        @Override
+        public void run() throws Exception {
             for (Iterator<MetadataPublisher> iter = uninitializedPublishers.values().iterator();
-                    iter.hasNext(); ) {
+                 iter.hasNext(); ) {
                 closePublisher(iter.next());
                 iter.remove();
             }
@@ -549,7 +555,7 @@ public class MetadataLoader implements RaftClient.Listener<ApiMessageAndVersion>
                 closePublisher(iter.next());
                 iter.remove();
             }
-        });
+        }
     }
 
     Time time() {
diff --git a/metadata/src/main/java/org/apache/kafka/metadata/util/SnapshotFileReader.java b/metadata/src/main/java/org/apache/kafka/metadata/util/SnapshotFileReader.java
index 1e5e6371d0..81945d1233 100644
--- a/metadata/src/main/java/org/apache/kafka/metadata/util/SnapshotFileReader.java
+++ b/metadata/src/main/java/org/apache/kafka/metadata/util/SnapshotFileReader.java
@@ -63,7 +63,7 @@ public final class SnapshotFileReader implements AutoCloseable {
         this.snapshotPath = snapshotPath;
         this.listener = listener;
         this.queue = new KafkaEventQueue(Time.SYSTEM,
-            new LogContext("[snapshotReaderQueue] "), "snapshotReaderQueue_");
+            new LogContext("[snapshotReaderQueue] "), "snapshotReaderQueue_", new ShutdownEvent());
         this.caughtUpFuture = new CompletableFuture<>();
     }
 
@@ -174,22 +174,24 @@ public final class SnapshotFileReader implements AutoCloseable {
         } else {
             caughtUpFuture.completeExceptionally(new RuntimeException(reason));
         }
-        queue.beginShutdown(reason, new EventQueue.Event() {
-            @Override
-            public void run() throws Exception {
-                listener.beginShutdown();
-                if (fileRecords != null) {
-                    fileRecords.close();
-                    fileRecords = null;
-                }
-                batchIterator = null;
-            }
+        queue.beginShutdown(reason);
+    }
 
-            @Override
-            public void handleException(Throwable e) {
-                log.error("shutdown error", e);
+    class ShutdownEvent implements EventQueue.Event {
+        @Override
+        public void run() throws Exception {
+            listener.beginShutdown();
+            if (fileRecords != null) {
+                fileRecords.close();
+                fileRecords = null;
             }
-        });
+            batchIterator = null;
+        }
+
+        @Override
+        public void handleException(Throwable e) {
+            log.error("shutdown error", e);
+        }
     }
 
     @Override
diff --git a/metadata/src/test/java/org/apache/kafka/metalog/LocalLogManager.java b/metadata/src/test/java/org/apache/kafka/metalog/LocalLogManager.java
index a90e268720..492251bb02 100644
--- a/metadata/src/test/java/org/apache/kafka/metalog/LocalLogManager.java
+++ b/metadata/src/test/java/org/apache/kafka/metalog/LocalLogManager.java
@@ -501,7 +501,8 @@ public final class LocalLogManager implements RaftClient<ApiMessageAndVersion>,
         this.nodeId = nodeId;
         this.shared = shared;
         this.maxReadOffset = shared.initialMaxReadOffset();
-        this.eventQueue = new KafkaEventQueue(Time.SYSTEM, logContext, threadNamePrefix);
+        this.eventQueue = new KafkaEventQueue(Time.SYSTEM, logContext,
+                threadNamePrefix, new ShutdownEvent());
         shared.registerLogManager(this);
     }
 
@@ -601,7 +602,12 @@ public final class LocalLogManager implements RaftClient<ApiMessageAndVersion>,
     }
 
     public void beginShutdown() {
-        eventQueue.beginShutdown("beginShutdown", () -> {
+        eventQueue.beginShutdown("beginShutdown");
+    }
+
+    class ShutdownEvent implements EventQueue.Event {
+        @Override
+        public void run() throws Exception {
             try {
                 if (initialized && !shutdown) {
                     log.debug("Node {}: beginning shutdown.", nodeId);
@@ -609,13 +615,13 @@ public final class LocalLogManager implements RaftClient<ApiMessageAndVersion>,
                     for (MetaLogListenerData listenerData : listeners.values()) {
                         listenerData.beginShutdown();
                     }
-                    shared.unregisterLogManager(this);
+                    shared.unregisterLogManager(LocalLogManager.this);
                 }
             } catch (Exception e) {
                 log.error("Unexpected exception while sending beginShutdown callbacks", e);
             }
             shutdown = true;
-        });
+        }
     }
 
     @Override
diff --git a/server-common/src/main/java/org/apache/kafka/queue/EventQueue.java b/server-common/src/main/java/org/apache/kafka/queue/EventQueue.java
index d0c752e641..8c4022cee2 100644
--- a/server-common/src/main/java/org/apache/kafka/queue/EventQueue.java
+++ b/server-common/src/main/java/org/apache/kafka/queue/EventQueue.java
@@ -21,7 +21,6 @@ import org.slf4j.Logger;
 
 import java.util.OptionalLong;
 import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.function.Function;
 
 
@@ -209,44 +208,15 @@ public interface EventQueue extends AutoCloseable {
                  Function<OptionalLong, OptionalLong> deadlineNsCalculator,
                  Event event);
 
-    /**
-     * Asynchronously shut down the event queue with no unnecessary delay.
-     * @see #beginShutdown(String, Event, long, TimeUnit)
-     *
-     * @param source                The source of the shutdown.
-     */
-    default void beginShutdown(String source) {
-        beginShutdown(source, new VoidEvent());
-    }
-
-    /**
-     * Asynchronously shut down the event queue with no unnecessary delay.
-     *
-     * @param source        The source of the shutdown.
-     * @param cleanupEvent  The mandatory event to invoke after all other events have
-     *                      been processed.
-     * @see #beginShutdown(String, Event, long, TimeUnit)
-     */
-    default void beginShutdown(String source, Event cleanupEvent) {
-        beginShutdown(source, cleanupEvent, 0, TimeUnit.SECONDS);
-    }
-
     /**
      * Asynchronously shut down the event queue.
      *
-     * No new events will be accepted, and the timeout will be initiated
-     * for all existing events.
+     * No new events will be accepted, and the queue thread will exit after running the existing events.
+     * Deferred events will receive TimeoutExceptions.
      *
      * @param source        The source of the shutdown.
-     * @param cleanupEvent  The mandatory event to invoke after all other events have
-     *                      been processed.
-     * @param timeSpan      The amount of time to use for the timeout.
-     *                      Once the timeout elapses, any remaining queued
-     *                      events will get a
-     *                      {@link org.apache.kafka.common.errors.TimeoutException}.
-     * @param timeUnit      The time unit to use for the timeout.
      */
-    void beginShutdown(String source, Event cleanupEvent, long timeSpan, TimeUnit timeUnit);
+    void beginShutdown(String source);
 
     /**
      * @return The number of pending and running events. If this is 0, there is no running event and
diff --git a/server-common/src/main/java/org/apache/kafka/queue/KafkaEventQueue.java b/server-common/src/main/java/org/apache/kafka/queue/KafkaEventQueue.java
index b53339edfe..7d4f46aa77 100644
--- a/server-common/src/main/java/org/apache/kafka/queue/KafkaEventQueue.java
+++ b/server-common/src/main/java/org/apache/kafka/queue/KafkaEventQueue.java
@@ -23,10 +23,10 @@ import java.util.Objects;
 import java.util.OptionalLong;
 import java.util.TreeMap;
 import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Function;
+
 import org.apache.kafka.common.errors.TimeoutException;
 import org.apache.kafka.common.utils.KafkaThread;
 import org.apache.kafka.common.utils.LogContext;
@@ -115,34 +115,40 @@ public final class KafkaEventQueue implements EventQueue {
 
         /**
          * Run the event associated with this EventContext.
+         *
+         * @param log                  The logger to use.
+         * @param exceptionToDeliver   If non-null, the exception to deliver to the event.
+         *
+         * @return                     True if the thread was interrupted; false otherwise.
          */
-        void run(Logger log) throws InterruptedException {
-            try {
-                event.run();
-            } catch (InterruptedException e) {
-                throw e;
-            } catch (Exception e) {
+        boolean run(Logger log, Throwable exceptionToDeliver) {
+            if (exceptionToDeliver == null) {
                 try {
-                    event.handleException(e);
-                } catch (Throwable t) {
-                    log.error("Unexpected exception in handleException", t);
+                    event.run();
+                } catch (InterruptedException e) {
+                    log.warn("Interrupted while running event. Shutting down event queue");
+                    return true;
+                } catch (Throwable e) {
+                    log.debug("Got exception while running {}. Invoking handleException.", event, e);
+                    exceptionToDeliver = e;
                 }
             }
-        }
-
-        /**
-         * Complete the event associated with this EventContext with a timeout exception.
-         */
-        void completeWithTimeout() {
-            completeWithException(new TimeoutException());
+            if (exceptionToDeliver != null) {
+                completeWithException(log, exceptionToDeliver);
+            }
+            return Thread.currentThread().isInterrupted();
         }
 
         /**
          * Complete the event associated with this EventContext with the specified
          * exception.
          */
-        void completeWithException(Throwable t) {
-            event.handleException(t);
+        void completeWithException(Logger log, Throwable t) {
+            try {
+                event.handleException(t);
+            } catch (Exception e) {
+                log.error("Unexpected exception in handleException", e);
+            }
         }
     }
 
@@ -173,10 +179,14 @@ public final class KafkaEventQueue implements EventQueue {
         public void run() {
             try {
                 handleEvents();
-                cleanupEvent.run();
             } catch (Throwable e) {
                 log.warn("event handler thread exiting with exception", e);
             }
+            try {
+                cleanupEvent.run();
+            } catch (Throwable e) {
+                log.warn("cleanup event threw exception", e);
+            }
         }
 
         private void remove(EventContext eventContext) {
@@ -192,23 +202,23 @@ public final class KafkaEventQueue implements EventQueue {
         }
 
         private void handleEvents() throws InterruptedException {
-            EventContext toTimeout = null;
+            Throwable toDeliver = null;
             EventContext toRun = null;
+            boolean wasInterrupted = false;
             while (true) {
-                if (toTimeout != null) {
-                    toTimeout.completeWithTimeout();
-                } else if (toRun != null) {
-                    toRun.run(log);
+                if (toRun != null) {
+                    wasInterrupted = toRun.run(log, toDeliver);
                 }
                 lock.lock();
                 try {
-                    if (toTimeout != null) {
-                        size--;
-                        toTimeout = null;
-                    }
                     if (toRun != null) {
                         size--;
+                        if (wasInterrupted) {
+                            interrupted = wasInterrupted;
+                        }
+                        toDeliver = null;
                         toRun = null;
+                        wasInterrupted = false;
                     }
                     long awaitNs = Long.MAX_VALUE;
                     Map.Entry<Long, EventContext> entry = deadlineMap.firstEntry();
@@ -224,41 +234,60 @@ public final class KafkaEventQueue implements EventQueue {
                                 // queue.  (The value for deferred events is a schedule time
                                 // rather than a timeout.)
                                 remove(eventContext);
+                                toDeliver = null;
                                 toRun = eventContext;
                             } else {
                                 // not a deferred event, so it is a deadline, and it is timed out.
                                 remove(eventContext);
-                                toTimeout = eventContext;
+                                toDeliver = new TimeoutException();
+                                toRun = eventContext;
                             }
                             continue;
-                        } else if (closingTimeNs <= now) {
+                        } else if (interrupted) {
+                            remove(eventContext);
+                            toDeliver = new InterruptedException();
+                            toRun = eventContext;
+                            continue;
+                        } else if (shuttingDown) {
                             remove(eventContext);
-                            toTimeout = eventContext;
+                            toDeliver = new TimeoutException();
+                            toRun = eventContext;
                             continue;
                         }
                         awaitNs = timeoutNs - now;
                     }
                     if (head.next == head) {
-                        if ((closingTimeNs != Long.MAX_VALUE) && deadlineMap.isEmpty()) {
+                        if (deadlineMap.isEmpty() && (shuttingDown || interrupted)) {
                             // If there are no more entries to process, and the queue is
                             // closing, exit the thread.
                             return;
                         }
                     } else {
+                        if (interrupted) {
+                            toDeliver = new InterruptedException();
+                        } else {
+                            toDeliver = null;
+                        }
                         toRun = head.next;
                         remove(toRun);
                         continue;
                     }
-                    if (closingTimeNs != Long.MAX_VALUE) {
-                        long now = time.nanoseconds();
-                        if (awaitNs > closingTimeNs - now) {
-                            awaitNs = closingTimeNs - now;
-                        }
-                    }
                     if (awaitNs == Long.MAX_VALUE) {
-                        cond.await();
+                        try {
+                            cond.await();
+                        } catch (InterruptedException e) {
+                            log.warn("Interrupted while waiting for a new event. " +
+                                "Shutting down event queue");
+                            interrupted = true;
+                        }
                     } else {
-                        cond.awaitNanos(awaitNs);
+                        try {
+                            cond.awaitNanos(awaitNs);
+                        } catch (InterruptedException e) {
+                            log.warn("Interrupted while waiting for a deferred event. " +
+                                "Shutting down event queue");
+                            interrupted = true;
+                        }
                     }
                 } finally {
                     lock.unlock();
@@ -270,9 +299,12 @@ public final class KafkaEventQueue implements EventQueue {
                           Function<OptionalLong, OptionalLong> deadlineNsCalculator) {
             lock.lock();
             try {
-                if (closingTimeNs != Long.MAX_VALUE) {
+                if (shuttingDown) {
                     return new RejectedExecutionException();
                 }
+                if (interrupted) {
+                    return new InterruptedException();
+                }
                 OptionalLong existingDeadlineNs = OptionalLong.empty();
                 if (eventContext.tag != null) {
                     EventContext toRemove =
@@ -362,31 +394,69 @@ public final class KafkaEventQueue implements EventQueue {
         }
     }
 
+    /**
+     * The clock to use.
+     */
     private final Time time;
+
+    /**
+     * The event to run when the queue is closing.
+     */
+    private final Event cleanupEvent;
+
+    /**
+     * The lock which protects private data.
+     */
     private final ReentrantLock lock;
+
+    /**
+     * The log4j logger to use.
+     */
     private final Logger log;
+
+    /**
+     * The runnable that our thread executes.
+     */
     private final EventHandler eventHandler;
+
+    /**
+     * The queue thread.
+     */
     private final Thread eventHandlerThread;
 
     /**
-     * The time in monotonic nanoseconds when the queue is closing, or Long.MAX_VALUE if
-     * the queue is not currently closing.
+     * True if the event queue is shutting down. Protected by the lock.
      */
-    private long closingTimeNs;
+    private boolean shuttingDown;
 
-    private Event cleanupEvent;
+    /**
+     * True if the event handler thread was interrupted. Protected by the lock.
+     */
+    private boolean interrupted;
+
+    public KafkaEventQueue(
+        Time time,
+        LogContext logContext,
+        String threadNamePrefix
+    ) {
+        this(time, logContext, threadNamePrefix, VoidEvent::new);
+    }
 
-    public KafkaEventQueue(Time time,
-                           LogContext logContext,
-                           String threadNamePrefix) {
+    public KafkaEventQueue(
+        Time time,
+        LogContext logContext,
+        String threadNamePrefix,
+        Event cleanupEvent
+    ) {
         this.time = time;
+        this.cleanupEvent = Objects.requireNonNull(cleanupEvent);
         this.lock = new ReentrantLock();
         this.log = logContext.logger(KafkaEventQueue.class);
         this.eventHandler = new EventHandler();
         this.eventHandlerThread = new KafkaThread(threadNamePrefix + "EventHandler",
             this.eventHandler, false);
-        this.closingTimeNs = Long.MAX_VALUE;
-        this.cleanupEvent = null;
+        this.shuttingDown = false;
+        this.interrupted = false;
         this.eventHandlerThread.start();
     }
 
@@ -398,7 +468,7 @@ public final class KafkaEventQueue implements EventQueue {
         EventContext eventContext = new EventContext(event, insertionType, tag);
         Exception e = eventHandler.enqueue(eventContext, deadlineNsCalculator);
         if (e != null) {
-            eventContext.completeWithException(e);
+            eventContext.completeWithException(log, e);
         }
     }
 
@@ -408,24 +478,15 @@ public final class KafkaEventQueue implements EventQueue {
     }
 
     @Override
-    public void beginShutdown(String source, Event newCleanupEvent,
-                              long timeSpan, TimeUnit timeUnit) {
-        if (timeSpan < 0) {
-            throw new IllegalArgumentException("beginShutdown must be called with a " +
-                "non-negative timeout.");
-        }
-        Objects.requireNonNull(newCleanupEvent);
+    public void beginShutdown(String source) {
         lock.lock();
         try {
-            if (cleanupEvent != null) {
+            if (shuttingDown) {
                 log.debug("{}: Event queue is already shutting down.", source);
                 return;
             }
             log.info("{}: shutting down event queue.", source);
-            cleanupEvent = newCleanupEvent;
-            long newClosingTimeNs = time.nanoseconds() + timeUnit.toNanos(timeSpan);
-            if (closingTimeNs >= newClosingTimeNs)
-                closingTimeNs = newClosingTimeNs;
+            shuttingDown = true;
             eventHandler.cond.signal();
         } finally {
             lock.unlock();
diff --git a/server-common/src/test/java/org/apache/kafka/queue/KafkaEventQueueTest.java b/server-common/src/test/java/org/apache/kafka/queue/KafkaEventQueueTest.java
index 09910200a1..d210df3b7a 100644
--- a/server-common/src/test/java/org/apache/kafka/queue/KafkaEventQueueTest.java
+++ b/server-common/src/test/java/org/apache/kafka/queue/KafkaEventQueueTest.java
@@ -35,6 +35,7 @@ import org.apache.kafka.test.TestUtils;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 
+import static java.util.concurrent.TimeUnit.HOURS;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertThrows;
@@ -165,7 +166,7 @@ public class KafkaEventQueueTest {
         queue.close();
     }
 
-    private final static long ONE_HOUR_NS = TimeUnit.NANOSECONDS.convert(1, TimeUnit.HOURS);
+    private final static long ONE_HOUR_NS = TimeUnit.NANOSECONDS.convert(1, HOURS);
 
     @Test
     public void testScheduleDeferredWithTagReplacement() throws Exception {
@@ -214,7 +215,7 @@ public class KafkaEventQueueTest {
         final AtomicInteger count = new AtomicInteger(0);
         CompletableFuture<Integer> future = new CompletableFuture<>();
         queue.scheduleDeferred("myDeferred",
-            __ -> OptionalLong.of(Time.SYSTEM.nanoseconds() + TimeUnit.HOURS.toNanos(1)),
+            __ -> OptionalLong.of(Time.SYSTEM.nanoseconds() + HOURS.toNanos(1)),
             new FutureEvent<>(future, () -> count.getAndAdd(1)));
         queue.beginShutdown("testShutdownBeforeDeferred");
         assertThrows(ExecutionException.class, () -> future.get());
@@ -257,7 +258,7 @@ public class KafkaEventQueueTest {
         future.complete(null);
         TestUtils.waitForCondition(() -> queue.isEmpty(), "Failed to see the queue become empty.");
         queue.scheduleDeferred("later",
-                __ -> OptionalLong.of(Time.SYSTEM.nanoseconds() + TimeUnit.HOURS.toNanos(1)),
+                __ -> OptionalLong.of(Time.SYSTEM.nanoseconds() + HOURS.toNanos(1)),
                 () -> { });
         assertFalse(queue.isEmpty());
         queue.scheduleDeferred("soon",
@@ -270,4 +271,145 @@ public class KafkaEventQueueTest {
         queue.close();
         assertTrue(queue.isEmpty());
     }
+
+    /**
+     * Test that we continue handling events after Event#handleException itself throws an exception.
+     */
+    @Test
+    public void testHandleExceptionThrowingAnException() throws Exception {
+        KafkaEventQueue queue = new KafkaEventQueue(Time.SYSTEM, new LogContext(),
+                "testHandleExceptionThrowingAnException");
+        CompletableFuture<Void> initialFuture = new CompletableFuture<>();
+        queue.append(() -> initialFuture.get());
+        AtomicInteger counter = new AtomicInteger(0);
+        queue.append(new EventQueue.Event() {
+            @Override
+            public void run() throws Exception {
+                counter.incrementAndGet();
+                throw new IllegalStateException("First exception");
+            }
+
+            @Override
+            public void handleException(Throwable e) {
+                if (e instanceof IllegalStateException) {
+                    counter.incrementAndGet();
+                    throw new RuntimeException("Second exception");
+                }
+            }
+        });
+        queue.append(() -> counter.incrementAndGet());
+        assertEquals(3, queue.size());
+        initialFuture.complete(null);
+        TestUtils.waitForCondition(() -> counter.get() == 3,
+                "Failed to see all events execute as planned.");
+        queue.close();
+    }
+
+    private static class InterruptableEvent implements EventQueue.Event {
+        private final CompletableFuture<Void> runFuture;
+        private final CompletableFuture<Thread> queueThread;
+        private final AtomicInteger numCallsToRun;
+        private final AtomicInteger numInterruptedExceptionsSeen;
+
+        InterruptableEvent(
+            CompletableFuture<Thread> queueThread,
+            AtomicInteger numCallsToRun,
+            AtomicInteger numInterruptedExceptionsSeen
+        ) {
+            this.runFuture = new CompletableFuture<>();
+            this.queueThread = queueThread;
+            this.numCallsToRun = numCallsToRun;
+            this.numInterruptedExceptionsSeen = numInterruptedExceptionsSeen;
+        }
+
+        @Override
+        public void run() throws Exception {
+            numCallsToRun.incrementAndGet();
+            queueThread.complete(Thread.currentThread());
+            runFuture.get();
+        }
+
+        @Override
+        public void handleException(Throwable e) {
+            if (e instanceof InterruptedException) {
+                numInterruptedExceptionsSeen.incrementAndGet();
+                Thread.currentThread().interrupt();
+            }
+        }
+    }
+
+    @Test
+    public void testInterruptedExceptionHandling() throws Exception {
+        KafkaEventQueue queue = new KafkaEventQueue(Time.SYSTEM, new LogContext(),
+                "testInterruptedExceptionHandling");
+        CompletableFuture<Thread> queueThread = new CompletableFuture<>();
+        AtomicInteger numCallsToRun = new AtomicInteger(0);
+        AtomicInteger numInterruptedExceptionsSeen = new AtomicInteger(0);
+        queue.append(new InterruptableEvent(queueThread, numCallsToRun, numInterruptedExceptionsSeen));
+        queue.append(new InterruptableEvent(queueThread, numCallsToRun, numInterruptedExceptionsSeen));
+        queue.append(new InterruptableEvent(queueThread, numCallsToRun, numInterruptedExceptionsSeen));
+        queue.append(new InterruptableEvent(queueThread, numCallsToRun, numInterruptedExceptionsSeen));
+        queueThread.get().interrupt();
+        TestUtils.retryOnExceptionWithTimeout(30000,
+                () -> assertEquals(1, numCallsToRun.get()));
+        TestUtils.retryOnExceptionWithTimeout(30000,
+                () -> assertEquals(3, numInterruptedExceptionsSeen.get()));
+        queue.close();
+    }
+
+    static class ExceptionTrapperEvent implements EventQueue.Event {
+        final CompletableFuture<Throwable> exception = new CompletableFuture<>();
+
+        @Override
+        public void run() throws Exception {
+            exception.complete(null);
+        }
+
+        @Override
+        public void handleException(Throwable e) {
+            exception.complete(e);
+        }
+    }
+
+    @Test
+    public void testInterruptedWithEmptyQueue() throws Exception {
+        CompletableFuture<Void> cleanupFuture = new CompletableFuture<>();
+        KafkaEventQueue queue = new KafkaEventQueue(Time.SYSTEM, new LogContext(),
+                "testInterruptedWithEmptyQueue", () -> cleanupFuture.complete(null));
+        CompletableFuture<Thread> queueThread = new CompletableFuture<>();
+        queue.append(() -> queueThread.complete(Thread.currentThread()));
+        TestUtils.retryOnExceptionWithTimeout(30000, () -> assertEquals(0, queue.size()));
+        queueThread.get().interrupt();
+        cleanupFuture.get();
+        ExceptionTrapperEvent ieTrapper = new ExceptionTrapperEvent();
+        queue.append(ieTrapper);
+        assertEquals(InterruptedException.class, ieTrapper.exception.get().getClass());
+        queue.close();
+        ExceptionTrapperEvent reTrapper = new ExceptionTrapperEvent();
+        queue.append(reTrapper);
+        assertEquals(RejectedExecutionException.class, reTrapper.exception.get().getClass());
+    }
+
+    @Test
+    public void testInterruptedWithDeferredEvents() throws Exception {
+        CompletableFuture<Void> cleanupFuture = new CompletableFuture<>();
+        KafkaEventQueue queue = new KafkaEventQueue(Time.SYSTEM, new LogContext(),
+                "testInterruptedWithDeferredEvents", () -> cleanupFuture.complete(null));
+        CompletableFuture<Thread> queueThread = new CompletableFuture<>();
+        queue.append(() -> queueThread.complete(Thread.currentThread()));
+        ExceptionTrapperEvent ieTrapper1 = new ExceptionTrapperEvent();
+        ExceptionTrapperEvent ieTrapper2 = new ExceptionTrapperEvent();
+        queue.scheduleDeferred("ie2",
+                __ -> OptionalLong.of(Time.SYSTEM.nanoseconds() + HOURS.toNanos(2)),
+                ieTrapper2);
+        queue.scheduleDeferred("ie1",
+                __ -> OptionalLong.of(Time.SYSTEM.nanoseconds() + HOURS.toNanos(1)),
+                ieTrapper1);
+        TestUtils.retryOnExceptionWithTimeout(30000, () -> assertEquals(2, queue.size()));
+        queueThread.get().interrupt();
+        cleanupFuture.get();
+        assertEquals(InterruptedException.class, ieTrapper1.exception.get().getClass());
+        assertEquals(InterruptedException.class, ieTrapper2.exception.get().getClass());
+        queue.close();
+    }
 }
\ No newline at end of file
diff --git a/server-common/src/test/resources/test/log4j.properties b/server-common/src/test/resources/test/log4j.properties
new file mode 100644
index 0000000000..be36f90299
--- /dev/null
+++ b/server-common/src/test/resources/test/log4j.properties
@@ -0,0 +1,21 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+log4j.rootLogger=INFO, stdout
+
+log4j.appender.stdout=org.apache.log4j.ConsoleAppender
+log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
+log4j.appender.stdout.layout.ConversionPattern=[%d] %p %m (%c:%L)%n
+
+log4j.logger.org.apache.kafka=INFO
