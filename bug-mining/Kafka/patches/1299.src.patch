diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignor.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignor.java
index 4ae2d331ca..53607e867f 100644
--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignor.java
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignor.java
@@ -577,26 +577,20 @@ public class StreamPartitionAssignor implements PartitionAssignor, Configurable
             assignedPartitions.add(partition);
         }
 
-        // only need to update the host partitions map if it is not leader
-        if (this.partitionsByHostState == null) {
-            this.partitionsByHostState = info.partitionsByHost;
-        }
-
-        // only need to build if it is not leader
-        if (metadataWithInternalTopics == null) {
-            final Collection<Set<TopicPartition>> values = partitionsByHostState.values();
-            final Map<TopicPartition, PartitionInfo> topicToPartitionInfo = new HashMap<>();
-            for (Set<TopicPartition> value : values) {
-                for (TopicPartition topicPartition : value) {
-                    topicToPartitionInfo.put(topicPartition, new PartitionInfo(topicPartition.topic(),
-                                                                               topicPartition.partition(),
-                                                                               null,
-                                                                               new Node[0],
-                                                                               new Node[0]));
-                }
+        this.partitionsByHostState = info.partitionsByHost;
+
+        final Collection<Set<TopicPartition>> values = partitionsByHostState.values();
+        final Map<TopicPartition, PartitionInfo> topicToPartitionInfo = new HashMap<>();
+        for (Set<TopicPartition> value : values) {
+            for (TopicPartition topicPartition : value) {
+                topicToPartitionInfo.put(topicPartition, new PartitionInfo(topicPartition.topic(),
+                                                                           topicPartition.partition(),
+                                                                           null,
+                                                                           new Node[0],
+                                                                           new Node[0]));
             }
-            metadataWithInternalTopics = Cluster.empty().withPartitions(topicToPartitionInfo);
         }
+        metadataWithInternalTopics = Cluster.empty().withPartitions(topicToPartitionInfo);
     }
 
     /**
diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignorTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignorTest.java
index 0e0620dfde..82e9d49767 100644
--- a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignorTest.java
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamPartitionAssignorTest.java
@@ -889,6 +889,50 @@ public class StreamPartitionAssignorTest {
         assertThat(expectedAssignment, equalTo(assignment.get(client).partitions()));
     }
 
+    @Test
+    public void shouldUpdatePartitionHostInfoMapOnAssignment() throws Exception {
+        final StreamPartitionAssignor partitionAssignor = new StreamPartitionAssignor();
+        final TopicPartition partitionOne = new TopicPartition("topic", 1);
+        final TopicPartition partitionTwo = new TopicPartition("topic", 2);
+        final Map<HostInfo, Set<TopicPartition>> firstHostState = Collections.singletonMap(
+                new HostInfo("localhost", 9090), Utils.mkSet(partitionOne, partitionTwo));
+
+        final Map<HostInfo, Set<TopicPartition>> secondHostState = new HashMap<>();
+        secondHostState.put(new HostInfo("localhost", 9090), Utils.mkSet(partitionOne));
+        secondHostState.put(new HostInfo("other", 9090), Utils.mkSet(partitionTwo));
+
+        partitionAssignor.onAssignment(createAssignment(firstHostState));
+        assertEquals(firstHostState, partitionAssignor.getPartitionsByHostState());
+        partitionAssignor.onAssignment(createAssignment(secondHostState));
+        assertEquals(secondHostState, partitionAssignor.getPartitionsByHostState());
+    }
+
+    @Test
+    public void shouldUpdateClusterMetadataOnAssignment() throws Exception {
+        final StreamPartitionAssignor partitionAssignor = new StreamPartitionAssignor();
+        final TopicPartition topicOne = new TopicPartition("topic", 1);
+        final TopicPartition topicTwo = new TopicPartition("topic2", 2);
+        final Map<HostInfo, Set<TopicPartition>> firstHostState = Collections.singletonMap(
+                new HostInfo("localhost", 9090), Utils.mkSet(topicOne));
+
+        final Map<HostInfo, Set<TopicPartition>> secondHostState = Collections.singletonMap(
+                new HostInfo("localhost", 9090), Utils.mkSet(topicOne, topicTwo));
+
+        partitionAssignor.onAssignment(createAssignment(firstHostState));
+        assertEquals(Utils.mkSet("topic"), partitionAssignor.clusterMetadata().topics());
+        partitionAssignor.onAssignment(createAssignment(secondHostState));
+        assertEquals(Utils.mkSet("topic", "topic2"), partitionAssignor.clusterMetadata().topics());
+    }
+
+    private PartitionAssignor.Assignment createAssignment(final Map<HostInfo, Set<TopicPartition>> firstHostState) {
+        final AssignmentInfo info = new AssignmentInfo(Collections.<TaskId>emptyList(),
+                                                       Collections.<TaskId, Set<TopicPartition>>emptyMap(),
+                                                       firstHostState);
+
+        return new PartitionAssignor.Assignment(
+                Collections.<TopicPartition>emptyList(), info.encode());
+    }
+
     @Test
     public void shouldNotAddStandbyTaskPartitionsToPartitionsForHost() throws Exception {
         final Properties props = configProps();
