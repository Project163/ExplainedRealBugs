diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/AbstractMergedSortedCacheStoreIterator.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/AbstractMergedSortedCacheStoreIterator.java
index 819c58ca20..834b18f649 100644
--- a/streams/src/main/java/org/apache/kafka/streams/state/internals/AbstractMergedSortedCacheStoreIterator.java
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/AbstractMergedSortedCacheStoreIterator.java
@@ -59,14 +59,28 @@ abstract class AbstractMergedSortedCacheStoreIterator<K, KS, V, VS> implements K
     public boolean hasNext() {
         // skip over items deleted from cache, and corresponding store items if they have the same key
         while (cacheIterator.hasNext() && isDeletedCacheEntry(cacheIterator.peekNext())) {
-            if (storeIterator.hasNext()) {
-                final KS nextStoreKey = storeIterator.peekNextKey();
-                // advance the store iterator if the key is the same as the deleted cache key
-                if (compare(cacheIterator.peekNextKey(), nextStoreKey) == 0) {
-                    storeIterator.next();
-                }
+            if (!storeIterator.hasNext()) {
+                // if storeIterator is exhausted, we can just skip over every tombstone
+                // in the cache since they don't shadow any valid key
+                cacheIterator.next();
+                continue;
+            }
+
+            final KS nextStoreKey = storeIterator.peekNextKey();
+            final int compare = compare(cacheIterator.peekNextKey(), nextStoreKey);
+
+            if (compare == 0) {
+                // next cache entry is a valid tombstone for the next store key
+                storeIterator.next();
+                cacheIterator.next();
+            } else if (compare < 0) {
+                // cache has a tombstone for an entry that doesn't exist in the store
+                cacheIterator.next();
+            } else {
+                // store iterator has a valid entry, but we should not advance the cache
+                // iterator because it may still shadow a future store key
+                return true;
             }
-            cacheIterator.next();
         }
 
         return cacheIterator.hasNext() || storeIterator.hasNext();
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java
index a678908b04..1a63f83563 100644
--- a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java
@@ -148,19 +148,51 @@ public class MergedSortedCacheKeyValueBytesStoreIteratorTest {
         assertFalse(createIterator().hasNext());
     }
 
+    @Test
+    public void shouldIterateCacheOnly() {
+        final byte[][] bytes = {{0}, {1}, {2}};
+        for (final byte[] aByte : bytes) {
+            cache.put(namespace, Bytes.wrap(aByte), new LRUCacheEntry(aByte));
+        }
+
+        try (final MergedSortedCacheKeyValueBytesStoreIterator iterator = createIterator()) {
+            assertArrayEquals(bytes[0], iterator.next().key.get());
+            assertArrayEquals(bytes[1], iterator.next().key.get());
+            assertArrayEquals(bytes[2], iterator.next().key.get());
+            assertFalse(iterator.hasNext());
+        }
+    }
+
+    @Test
+    public void shouldIterateStoreOnly() {
+        final byte[][] bytes = {{0}, {1}, {2}};
+        for (final byte[] aByte : bytes) {
+            store.put(Bytes.wrap(aByte), aByte);
+        }
+
+        try (final MergedSortedCacheKeyValueBytesStoreIterator iterator = createIterator()) {
+            assertArrayEquals(bytes[0], iterator.next().key.get());
+            assertArrayEquals(bytes[1], iterator.next().key.get());
+            assertArrayEquals(bytes[2], iterator.next().key.get());
+            assertFalse(iterator.hasNext());
+        }
+    }
+
     @Test
     public void shouldSkipAllDeletedFromCache() {
         final byte[][] bytes = {{0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}, {10}, {11}};
         for (final byte[] aByte : bytes) {
             final Bytes aBytes = Bytes.wrap(aByte);
             store.put(aBytes, aByte);
-            cache.put(namespace, aBytes, new LRUCacheEntry(aByte));
         }
+
+        cache.put(namespace, Bytes.wrap(new byte[]{-1}), new LRUCacheEntry(null));
         cache.put(namespace, Bytes.wrap(bytes[1]), new LRUCacheEntry(null));
         cache.put(namespace, Bytes.wrap(bytes[2]), new LRUCacheEntry(null));
         cache.put(namespace, Bytes.wrap(bytes[3]), new LRUCacheEntry(null));
         cache.put(namespace, Bytes.wrap(bytes[8]), new LRUCacheEntry(null));
         cache.put(namespace, Bytes.wrap(bytes[11]), new LRUCacheEntry(null));
+        cache.put(namespace, Bytes.wrap(new byte[]{14}), new LRUCacheEntry(null));
 
         try (final MergedSortedCacheKeyValueBytesStoreIterator iterator = createIterator()) {
             assertArrayEquals(bytes[0], iterator.next().key.get());
@@ -174,6 +206,13 @@ public class MergedSortedCacheKeyValueBytesStoreIteratorTest {
         }
     }
 
+    @Test
+    public void shouldNotHaveNextIfBothIteratorsInitializedEmpty() {
+        try (final MergedSortedCacheKeyValueBytesStoreIterator iterator = createIterator()) {
+            assertFalse(iterator.hasNext());
+        }
+    }
+
     @Test
     public void shouldPeekNextKey() {
         final KeyValueStore<Bytes, byte[]> kv = new InMemoryKeyValueStore("one");
