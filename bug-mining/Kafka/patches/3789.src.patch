diff --git a/clients/src/main/java/org/apache/kafka/common/Cluster.java b/clients/src/main/java/org/apache/kafka/common/Cluster.java
index 84b77ef5f4..820adbdb5f 100644
--- a/clients/src/main/java/org/apache/kafka/common/Cluster.java
+++ b/clients/src/main/java/org/apache/kafka/common/Cluster.java
@@ -385,12 +385,13 @@ public final class Cluster {
                 Objects.equals(internalTopics, cluster.internalTopics) &&
                 Objects.equals(controller, cluster.controller) &&
                 Objects.equals(partitionsByTopicPartition, cluster.partitionsByTopicPartition) &&
-                Objects.equals(clusterResource, cluster.clusterResource);
+                Objects.equals(clusterResource, cluster.clusterResource) &&
+                Objects.equals(topicIds, cluster.topicIds);
     }
 
     @Override
     public int hashCode() {
         return Objects.hash(isBootstrapConfigured, nodes, unauthorizedTopics, invalidTopics, internalTopics, controller,
-                partitionsByTopicPartition, clusterResource);
+                partitionsByTopicPartition, clusterResource, topicIds);
     }
 }
diff --git a/clients/src/main/java/org/apache/kafka/common/PartitionInfo.java b/clients/src/main/java/org/apache/kafka/common/PartitionInfo.java
index 29bedff0cf..0577b4200a 100644
--- a/clients/src/main/java/org/apache/kafka/common/PartitionInfo.java
+++ b/clients/src/main/java/org/apache/kafka/common/PartitionInfo.java
@@ -16,6 +16,9 @@
  */
 package org.apache.kafka.common;
 
+import java.util.Arrays;
+import java.util.Objects;
+
 /**
  * This is used to describe per-partition state in the MetadataResponse.
  */
@@ -88,6 +91,29 @@ public class PartitionInfo {
         return offlineReplicas;
     }
 
+    @Override
+    public int hashCode() {
+        return Objects.hash(topic, partition, leader, Arrays.hashCode(replicas),
+            Arrays.hashCode(inSyncReplicas), Arrays.hashCode(offlineReplicas));
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        PartitionInfo other = (PartitionInfo) obj;
+        return Objects.equals(topic, other.topic) &&
+            partition == other.partition &&
+            Objects.equals(leader, other.leader) &&
+            Objects.deepEquals(replicas, other.replicas) &&
+            Objects.deepEquals(inSyncReplicas, other.inSyncReplicas) &&
+            Objects.deepEquals(offlineReplicas, other.offlineReplicas);
+    }
+
     @Override
     public String toString() {
         return String.format("Partition(topic = %s, partition = %d, leader = %s, replicas = %s, isr = %s, offlineReplicas = %s)",
diff --git a/clients/src/test/java/org/apache/kafka/common/ClusterTest.java b/clients/src/test/java/org/apache/kafka/common/ClusterTest.java
index 4c6db86d6a..f209b48f71 100644
--- a/clients/src/test/java/org/apache/kafka/common/ClusterTest.java
+++ b/clients/src/test/java/org/apache/kafka/common/ClusterTest.java
@@ -21,12 +21,15 @@ import org.junit.jupiter.api.Test;
 
 import java.net.InetSocketAddress;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 import static java.util.Arrays.asList;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 
 public class ClusterTest {
@@ -89,4 +92,74 @@ public class ClusterTest {
             new PartitionInfo(TOPIC_B, 2, NODES[1], NODES, NODES)));
     }
 
+    @Test
+    public void testNotEquals() {
+        String clusterId1 = "clusterId1";
+        String clusterId2 = "clusterId2";
+        Node node0 = new Node(0, "host0", 100);
+        Node node1 = new Node(1, "host1", 100);
+        Set<PartitionInfo> partitions1 = Collections.singleton(new PartitionInfo("topic1", 0, node0, new Node[]{node0, node1}, new Node[]{node0}));
+        Set<PartitionInfo> partitions2 = Collections.singleton(new PartitionInfo("topic2", 0, node0, new Node[]{node1, node0}, new Node[]{node1}));
+        Set<String> unauthorizedTopics1 = Collections.singleton("topic1");
+        Set<String> unauthorizedTopics2 = Collections.singleton("topic2");
+        Set<String> invalidTopics1 = Collections.singleton("topic1");
+        Set<String> invalidTopics2 = Collections.singleton("topic2");
+        Set<String> internalTopics1 = Collections.singleton("topic3");
+        Set<String> internalTopics2 = Collections.singleton("topic4");
+        Node controller1 = new Node(2, "host2", 100);
+        Node controller2 = new Node(3, "host3", 100); 
+        Map<String, Uuid> topicIds1 = Collections.singletonMap("topic1", Uuid.randomUuid());
+        Map<String, Uuid> topicIds2 = Collections.singletonMap("topic2", Uuid.randomUuid());
+
+        Cluster cluster1 = new Cluster(clusterId1, Collections.singletonList(node0), partitions1,
+            unauthorizedTopics1, invalidTopics1, internalTopics1, controller1, topicIds1);
+        Cluster differentTopicIds = new Cluster(clusterId1, Collections.singletonList(node0), partitions1,
+            unauthorizedTopics1, invalidTopics1, internalTopics1, controller1, topicIds2);
+        Cluster differentController = new Cluster(clusterId1, Collections.singletonList(node0), partitions1,
+            unauthorizedTopics1, invalidTopics1, internalTopics1, controller2, topicIds1);
+        Cluster differentInternalTopics = new Cluster(clusterId1, Collections.singletonList(node0), partitions1,
+            unauthorizedTopics1, invalidTopics1, internalTopics2, controller1, topicIds1);
+        Cluster differentInvalidTopics = new Cluster(clusterId1, Collections.singletonList(node0), partitions1,
+            unauthorizedTopics1, invalidTopics2, internalTopics1, controller1, topicIds1);
+        Cluster differentUnauthorizedTopics = new Cluster(clusterId1, Collections.singletonList(node0), partitions1,
+            unauthorizedTopics2, invalidTopics1, internalTopics1, controller1, topicIds1);
+        Cluster differentPartitions = new Cluster(clusterId1, Collections.singletonList(node0), partitions2,
+            unauthorizedTopics1, invalidTopics1, internalTopics1, controller1, topicIds1);
+        Cluster differentNodes = new Cluster(clusterId1, Arrays.asList(node0, node1), partitions1,
+            unauthorizedTopics1, invalidTopics1, internalTopics1, controller1, topicIds1);
+        Cluster differentClusterId = new Cluster(clusterId2, Collections.singletonList(node0), partitions1,
+            unauthorizedTopics1, invalidTopics1, internalTopics1, controller1, topicIds1);
+
+        assertNotEquals(cluster1, differentTopicIds);
+        assertNotEquals(cluster1, differentController);
+        assertNotEquals(cluster1, differentInternalTopics);
+        assertNotEquals(cluster1, differentInvalidTopics);
+        assertNotEquals(cluster1, differentUnauthorizedTopics);
+        assertNotEquals(cluster1, differentPartitions);
+        assertNotEquals(cluster1, differentNodes);
+        assertNotEquals(cluster1, differentClusterId);
+    }
+
+    @Test
+    public void testEquals() {
+        String clusterId1 = "clusterId1";
+        Node node1 = new Node(1, "host0", 100);
+        Node node1duplicate = new Node(1, "host0", 100);
+        Set<PartitionInfo> partitions1 = Collections.singleton(new PartitionInfo("topic1", 0, node1, new Node[]{node1}, new Node[]{node1}));
+        Set<PartitionInfo> partitions1duplicate = Collections.singleton(new PartitionInfo("topic1", 0, node1duplicate, new Node[]{node1duplicate}, new Node[]{node1duplicate}));
+        Set<String> unauthorizedTopics1 = Collections.singleton("topic1");
+        Set<String> invalidTopics1 = Collections.singleton("topic1");
+        Set<String> internalTopics1 = Collections.singleton("topic3");
+        Node controller1 = new Node(2, "host0", 100);
+        Node controller1duplicate = new Node(2, "host0", 100);
+        Uuid topicId1 = Uuid.randomUuid();
+        Map<String, Uuid> topicIds1 = Collections.singletonMap("topic1", topicId1);
+        Map<String, Uuid> topicIds1duplicate = Collections.singletonMap("topic1", topicId1);
+
+        Cluster cluster1 = new Cluster(clusterId1, Collections.singletonList(node1), partitions1, unauthorizedTopics1,
+            invalidTopics1, internalTopics1, controller1, topicIds1);
+        Cluster cluster1duplicate = new Cluster(clusterId1, Collections.singletonList(node1duplicate), partitions1duplicate,
+            unauthorizedTopics1, invalidTopics1, internalTopics1, controller1duplicate, topicIds1duplicate);
+        assertEquals(cluster1, cluster1duplicate);
+    }
 }
