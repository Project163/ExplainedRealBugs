diff --git a/core/src/main/scala/kafka/log/LogCleaner.scala b/core/src/main/scala/kafka/log/LogCleaner.scala
index baf937d641..0d4cab9a0f 100644
--- a/core/src/main/scala/kafka/log/LogCleaner.scala
+++ b/core/src/main/scala/kafka/log/LogCleaner.scala
@@ -323,6 +323,8 @@ class LogCleaner(initialConfig: CleanerConfig,
       val cleaned = tryCleanFilthiestLog()
       if (!cleaned)
         pause(config.backOffMs, TimeUnit.MILLISECONDS)
+
+      cleanerManager.maintainUncleanablePartitions()
     }
 
     /**
diff --git a/core/src/main/scala/kafka/log/LogCleanerManager.scala b/core/src/main/scala/kafka/log/LogCleanerManager.scala
index 02d6a30ad2..3915d3e8a8 100755
--- a/core/src/main/scala/kafka/log/LogCleanerManager.scala
+++ b/core/src/main/scala/kafka/log/LogCleanerManager.scala
@@ -103,11 +103,13 @@ private[log] class LogCleanerManager(val logDirs: Seq[File],
             val lastClean = allCleanerCheckpoints
             val now = Time.SYSTEM.milliseconds
             partitions.iterator.map { tp =>
-              val log = logs.get(tp)
-              val lastCleanOffset = lastClean.get(tp)
-              val offsetsToClean = cleanableOffsets(log, lastCleanOffset, now)
-              val (_, uncleanableBytes) = calculateCleanableBytes(log, offsetsToClean.firstDirtyOffset, offsetsToClean.firstUncleanableDirtyOffset)
-              uncleanableBytes
+              Option(logs.get(tp)).map {
+                log =>
+                  val lastCleanOffset = lastClean.get(tp)
+                  val offsetsToClean = cleanableOffsets(log, lastCleanOffset, now)
+                  val (_, uncleanableBytes) = calculateCleanableBytes(log, offsetsToClean.firstDirtyOffset, offsetsToClean.firstUncleanableDirtyOffset)
+                  uncleanableBytes
+              }.getOrElse(0L)
             }.sum
           case None => 0
         }
@@ -512,6 +514,27 @@ private[log] class LogCleanerManager(val logDirs: Seq[File],
       uncleanablePartitions.get(log.parentDir).exists(partitions => partitions.contains(topicPartition))
     }
   }
+
+  def maintainUncleanablePartitions(): Unit = {
+    // Remove deleted partitions from uncleanablePartitions
+    inLock(lock) {
+      // Note: we don't use retain or filterInPlace method in this function because retain is deprecated in
+      // scala 2.13 while filterInPlace is not available in scala 2.12.
+
+      // Remove deleted partitions
+      uncleanablePartitions.values.foreach {
+        partitions =>
+          val partitionsToRemove = partitions.filterNot(logs.contains(_)).toList
+          partitionsToRemove.foreach { partitions.remove(_) }
+      }
+
+      // Remove entries with empty partition set.
+      val logDirsToRemove = uncleanablePartitions.filter {
+        case (_, partitions) => partitions.isEmpty
+      }.map { _._1}.toList
+      logDirsToRemove.foreach { uncleanablePartitions.remove(_) }
+    }
+  }
 }
 
 /**
diff --git a/core/src/test/scala/unit/kafka/log/LogCleanerIntegrationTest.scala b/core/src/test/scala/unit/kafka/log/LogCleanerIntegrationTest.scala
index 5f6a56d21f..c9797439a4 100644
--- a/core/src/test/scala/unit/kafka/log/LogCleanerIntegrationTest.scala
+++ b/core/src/test/scala/unit/kafka/log/LogCleanerIntegrationTest.scala
@@ -24,11 +24,9 @@ import kafka.metrics.{KafkaMetricsGroup, KafkaYammerMetrics}
 import kafka.utils.{MockTime, TestUtils}
 import org.apache.kafka.common.TopicPartition
 import org.apache.kafka.common.record.{CompressionType, RecordBatch}
-import org.apache.kafka.test.TestUtils.DEFAULT_MAX_WAIT_MS
 import org.junit.jupiter.api.Assertions._
-import org.junit.jupiter.api.{AfterEach, Test, Timeout}
+import org.junit.jupiter.api.{AfterEach, Test}
 
-import java.util.concurrent.TimeUnit
 import scala.collection.{Iterable, Seq}
 import scala.jdk.CollectionConverters._
 
@@ -47,7 +45,6 @@ class LogCleanerIntegrationTest extends AbstractLogCleanerIntegrationTest with K
     TestUtils.clearYammerMetrics()
   }
 
-  @Timeout(value = DEFAULT_MAX_WAIT_MS, unit = TimeUnit.MILLISECONDS)
   @Test
   def testMarksPartitionsAsOfflineAndPopulatesUncleanableMetrics(): Unit = {
     val largeMessageKey = 20
@@ -88,6 +85,21 @@ class LogCleanerIntegrationTest extends AbstractLogCleanerIntegrationTest with K
     assertTrue(uncleanablePartitions.contains(topicPartitions(0)))
     assertTrue(uncleanablePartitions.contains(topicPartitions(1)))
     assertFalse(uncleanablePartitions.contains(topicPartitions(2)))
+
+    // Delete one partition
+    cleaner.logs.remove(topicPartitions(0))
+    TestUtils.waitUntilTrue(
+      () => {
+        time.sleep(1000)
+        uncleanablePartitionsCountGauge.value() == 1
+      },
+      "There should be 1 uncleanable partitions",
+      2000L)
+
+    val uncleanablePartitions2 = cleaner.cleanerManager.uncleanablePartitions(uncleanableDirectory)
+    assertFalse(uncleanablePartitions2.contains(topicPartitions(0)))
+    assertTrue(uncleanablePartitions2.contains(topicPartitions(1)))
+    assertFalse(uncleanablePartitions2.contains(topicPartitions(2)))
   }
 
   private def getGauge[T](filter: MetricName => Boolean): Gauge[T] = {
