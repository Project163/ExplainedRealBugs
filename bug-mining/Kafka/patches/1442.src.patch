diff --git a/core/src/main/scala/kafka/admin/AclCommand.scala b/core/src/main/scala/kafka/admin/AclCommand.scala
index 8cb06e8f69..0bedee345d 100644
--- a/core/src/main/scala/kafka/admin/AclCommand.scala
+++ b/core/src/main/scala/kafka/admin/AclCommand.scala
@@ -19,7 +19,9 @@ package kafka.admin
 
 import joptsimple._
 import kafka.security.auth._
+import kafka.server.KafkaConfig
 import kafka.utils._
+import org.apache.kafka.common.security.JaasUtils
 import org.apache.kafka.common.security.auth.KafkaPrincipal
 import org.apache.kafka.common.utils.Utils
 
@@ -59,12 +61,13 @@ object AclCommand {
   }
 
   def withAuthorizer(opts: AclCommandOptions)(f: Authorizer => Unit) {
+    val defaultProps = Map(KafkaConfig.ZkEnableSecureAclsProp -> JaasUtils.isZkSecurityEnabled)
     val authorizerProperties =
       if (opts.options.has(opts.authorizerPropertiesOpt)) {
         val authorizerProperties = opts.options.valuesOf(opts.authorizerPropertiesOpt).asScala
-        CommandLineUtils.parseKeyValueArgs(authorizerProperties, acceptMissingValue = false).asScala
+        defaultProps ++ CommandLineUtils.parseKeyValueArgs(authorizerProperties, acceptMissingValue = false).asScala
       } else {
-        Map.empty[String, Any]
+        defaultProps
       }
 
     val authorizerClass = opts.options.valueOf(opts.authorizerOpt)
diff --git a/core/src/main/scala/kafka/controller/KafkaController.scala b/core/src/main/scala/kafka/controller/KafkaController.scala
index 97ad198749..9f8def10f7 100644
--- a/core/src/main/scala/kafka/controller/KafkaController.scala
+++ b/core/src/main/scala/kafka/controller/KafkaController.scala
@@ -717,7 +717,7 @@ class KafkaController(val config: KafkaConfig, zkUtils: ZkUtils, val brokerState
         // the following call can still fail if another controller gets elected between checking if the path exists and
         // trying to create the controller epoch path
         try {
-          zkClient.createPersistent(ZkUtils.ControllerEpochPath, KafkaController.InitialControllerEpoch.toString)
+          zkUtils.createPersistentPath(ZkUtils.ControllerEpochPath, KafkaController.InitialControllerEpoch.toString)
           controllerContext.epoch = KafkaController.InitialControllerEpoch
           controllerContext.epochZkVersion = KafkaController.InitialControllerEpochZkVersion
         } catch {
diff --git a/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala b/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala
index 51de3bc5e2..eaacd6a1eb 100644
--- a/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala
+++ b/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala
@@ -109,7 +109,7 @@ class SimpleAclAuthorizer extends Authorizer with Logging {
     zkUtils = ZkUtils(zkUrl,
                       sessionTimeout = zkSessionTimeOutMs,
                       connectionTimeout = zkConnectionTimeoutMs,
-                      JaasUtils.isZkSecurityEnabled())
+                      kafkaConfig.zkEnableSecureAcls)
     zkUtils.makeSurePersistentPathExists(SimpleAclAuthorizer.AclZkPath)
 
     loadCache()
diff --git a/core/src/main/scala/kafka/server/ZookeeperLeaderElector.scala b/core/src/main/scala/kafka/server/ZookeeperLeaderElector.scala
index 64a401ae7c..11cf2ef9bf 100644
--- a/core/src/main/scala/kafka/server/ZookeeperLeaderElector.scala
+++ b/core/src/main/scala/kafka/server/ZookeeperLeaderElector.scala
@@ -78,7 +78,7 @@ class ZookeeperLeaderElector(controllerContext: ControllerContext,
       val zkCheckedEphemeral = new ZKCheckedEphemeral(electionPath,
                                                       electString,
                                                       controllerContext.zkUtils.zkConnection.getZookeeper,
-                                                      JaasUtils.isZkSecurityEnabled())
+                                                      controllerContext.zkUtils.isSecure)
       zkCheckedEphemeral.create()
       info(brokerId + " successfully elected as leader")
       leaderId = brokerId
diff --git a/core/src/test/scala/integration/kafka/api/SaslPlainPlaintextConsumerTest.scala b/core/src/test/scala/integration/kafka/api/SaslPlainPlaintextConsumerTest.scala
index ddf9578478..b1f378bada 100644
--- a/core/src/test/scala/integration/kafka/api/SaslPlainPlaintextConsumerTest.scala
+++ b/core/src/test/scala/integration/kafka/api/SaslPlainPlaintextConsumerTest.scala
@@ -17,19 +17,30 @@ import java.util.Locale
 
 import org.apache.kafka.common.protocol.SecurityProtocol
 import kafka.server.KafkaConfig
-import kafka.utils.JaasTestUtils
+import kafka.utils.{JaasTestUtils, TestUtils}
 import org.apache.kafka.common.network.ListenerName
+import org.junit.Test
 
 class SaslPlainPlaintextConsumerTest extends BaseConsumerTest with SaslTestHarness {
   override protected val zkSaslEnabled = true
+  override protected val zkAclsEnabled = Some(false)
   override protected def listenerName = new ListenerName("CLIENT")
   override protected val kafkaClientSaslMechanism = "PLAIN"
   override protected val kafkaServerSaslMechanisms = List(kafkaClientSaslMechanism)
   override protected val kafkaServerJaasEntryName =
     s"${listenerName.value.toLowerCase(Locale.ROOT)}.${JaasTestUtils.KafkaServerContextName}"
-  this.serverConfig.setProperty(KafkaConfig.ZkEnableSecureAclsProp, "true")
+  this.serverConfig.setProperty(KafkaConfig.ZkEnableSecureAclsProp, "false")
   override protected def securityProtocol = SecurityProtocol.SASL_PLAINTEXT
   override protected lazy val trustStoreFile = Some(File.createTempFile("truststore", ".jks"))
   override protected val serverSaslProperties = Some(kafkaServerSaslProperties(kafkaServerSaslMechanisms, kafkaClientSaslMechanism))
   override protected val clientSaslProperties = Some(kafkaClientSaslProperties(kafkaClientSaslMechanism))
+
+  /**
+   * Checks that everyone can access ZkUtils.SecureZkRootPaths and ZkUtils.SensitiveZkRootPaths
+   * when zookeeper.set.acl=false, even if Zookeeper is SASL-enabled.
+   */
+  @Test
+  def testZkAclsDisabled() {
+    TestUtils.verifyUnsecureZkAcls(zkUtils)
+  }
 }
diff --git a/core/src/test/scala/integration/kafka/api/SaslPlainSslEndToEndAuthorizationTest.scala b/core/src/test/scala/integration/kafka/api/SaslPlainSslEndToEndAuthorizationTest.scala
index bfccd28020..975ca4ccdd 100644
--- a/core/src/test/scala/integration/kafka/api/SaslPlainSslEndToEndAuthorizationTest.scala
+++ b/core/src/test/scala/integration/kafka/api/SaslPlainSslEndToEndAuthorizationTest.scala
@@ -16,11 +16,21 @@
   */
 package kafka.api
 
-import kafka.utils.JaasTestUtils
+import kafka.utils.{JaasTestUtils, TestUtils}
+import org.junit.Test
 
 class SaslPlainSslEndToEndAuthorizationTest extends SaslEndToEndAuthorizationTest {
   override protected def kafkaClientSaslMechanism = "PLAIN"
   override protected def kafkaServerSaslMechanisms = List("PLAIN")
   override val clientPrincipal = JaasTestUtils.KafkaPlainUser
   override val kafkaPrincipal = JaasTestUtils.KafkaPlainAdmin
+
+  /**
+   * Checks that secure paths created by broker and acl paths created by AclCommand
+   * have expected ACLs.
+   */
+  @Test
+  def testAcls() {
+    TestUtils.verifySecureZkAcls(zkUtils, 1)
+  }
 }
diff --git a/core/src/test/scala/unit/kafka/security/auth/ZkAuthorizationTest.scala b/core/src/test/scala/unit/kafka/security/auth/ZkAuthorizationTest.scala
index ba1becc63f..3e7fce4be0 100644
--- a/core/src/test/scala/unit/kafka/security/auth/ZkAuthorizationTest.scala
+++ b/core/src/test/scala/unit/kafka/security/auth/ZkAuthorizationTest.scala
@@ -18,7 +18,7 @@
 package kafka.security.auth
 
 import kafka.admin.ZkSecurityMigrator
-import kafka.utils.{Logging, ZkUtils}
+import kafka.utils.{Logging, TestUtils, ZkUtils}
 import kafka.zk.ZooKeeperTestHarness
 import org.apache.kafka.common.KafkaException
 import org.apache.kafka.common.security.JaasUtils
@@ -83,7 +83,7 @@ class ZkAuthorizationTest extends ZooKeeperTestHarness with Logging {
         val aclList = zkUtils.zkConnection.getAcl(path).getKey
         assertTrue(aclList.size == 2)
         for (acl: ACL <- aclList.asScala) {
-          assertTrue(isAclSecure(acl, false))
+          assertTrue(TestUtils.isAclSecure(acl, false))
         }
       }
     }
@@ -226,7 +226,7 @@ class ZkAuthorizationTest extends ZooKeeperTestHarness with Logging {
   private def verify(path: String): Boolean = {
     val sensitive = ZkUtils.sensitivePath(path)
     val list = zkUtils.zkConnection.getAcl(path).getKey
-    list.asScala.forall(isAclSecure(_, sensitive))
+    list.asScala.forall(TestUtils.isAclSecure(_, sensitive))
   }
 
   /**
@@ -240,37 +240,12 @@ class ZkAuthorizationTest extends ZooKeeperTestHarness with Logging {
         list.size == 1
     isListSizeCorrect && list.asScala.forall(
       if (secure)
-        isAclSecure(_, sensitive)
+        TestUtils.isAclSecure(_, sensitive)
       else
-        isAclUnsecure
+        TestUtils.isAclUnsecure
     )
   }
   
-  /**
-   * Verifies that this ACL is the secure one. The
-   * values are based on the constants used in the 
-   * ZooKeeper code base.
-   */
-  private def isAclSecure(acl: ACL, sensitive: Boolean): Boolean = {
-    info(s"ACL $acl")
-    acl.getPerms match {
-      case 1 => !sensitive && acl.getId.getScheme.equals("world")
-      case 31 => acl.getId.getScheme.equals("sasl")
-      case _ => false
-    }
-  }
-  
-  /**
-   * Verifies that the ACL corresponds to the unsecure one.
-   */
-  private def isAclUnsecure(acl: ACL): Boolean = {
-    info(s"ACL $acl")
-    acl.getPerms match {
-      case 31 => acl.getId.getScheme.equals("world")
-      case _ => false
-    }
-  }
-  
   /**
    * Sets up and starts the recursive execution of deletes.
    * This is used in the testDelete and testDeleteRecursive
diff --git a/core/src/test/scala/unit/kafka/utils/TestUtils.scala b/core/src/test/scala/unit/kafka/utils/TestUtils.scala
index 214fc39210..eb681ec623 100755
--- a/core/src/test/scala/unit/kafka/utils/TestUtils.scala
+++ b/core/src/test/scala/unit/kafka/utils/TestUtils.scala
@@ -50,6 +50,8 @@ import org.apache.kafka.common.serialization.{ByteArraySerializer, Serializer}
 import org.apache.kafka.common.utils.Time
 import org.apache.kafka.common.utils.Utils._
 import org.apache.kafka.test.{TestSslUtils, TestUtils => JTestUtils}
+import org.apache.zookeeper.ZooDefs._
+import org.apache.zookeeper.data.ACL
 import org.junit.Assert._
 
 import scala.collection.JavaConverters._
@@ -1144,6 +1146,72 @@ object TestUtils extends Logging {
       s"expected acls $expected but got ${authorizer.getAcls(resource)}", waitTime = JTestUtils.DEFAULT_MAX_WAIT_MS)
   }
 
+  /**
+   * Verifies that this ACL is the secure one.
+   */
+  def isAclSecure(acl: ACL, sensitive: Boolean): Boolean = {
+    debug(s"ACL $acl")
+    acl.getPerms match {
+      case Perms.READ => !sensitive && acl.getId.getScheme == "world"
+      case Perms.ALL => acl.getId.getScheme == "sasl"
+      case _ => false
+    }
+  }
+
+  /**
+   * Verifies that the ACL corresponds to the unsecure one that
+   * provides ALL access to everyone (world).
+   */
+  def isAclUnsecure(acl: ACL): Boolean = {
+    debug(s"ACL $acl")
+    acl.getPerms match {
+      case Perms.ALL => acl.getId.getScheme == "world"
+      case _ => false
+    }
+  }
+
+  private def secureZkPaths(zkUtils: ZkUtils): Seq[String] = {
+    def subPaths(path: String): Seq[String] = {
+      if (zkUtils.pathExists(path))
+        path +: zkUtils.getChildren(path).map(c => path + "/" + c).flatMap(subPaths)
+      else
+        Seq.empty
+    }
+    val topLevelPaths = ZkUtils.SecureZkRootPaths ++ ZkUtils.SensitiveZkRootPaths
+    topLevelPaths.flatMap(subPaths)
+  }
+
+  /**
+   * Verifies that all secure paths in ZK are created with the expected ACL.
+   */
+  def verifySecureZkAcls(zkUtils: ZkUtils, usersWithAccess: Int) {
+    secureZkPaths(zkUtils).foreach(path => {
+      if (zkUtils.pathExists(path)) {
+        val sensitive = ZkUtils.sensitivePath(path)
+        // usersWithAccess have ALL access to path. For paths that are
+        // not sensitive, world has READ access.
+        val aclCount = if (sensitive) usersWithAccess else usersWithAccess + 1
+        val acls = zkUtils.zkConnection.getAcl(path).getKey
+        assertEquals(s"Invalid ACLs for $path $acls", aclCount, acls.size)
+        acls.asScala.foreach(acl => isAclSecure(acl, sensitive))
+      }
+    })
+  }
+
+  /**
+   * Verifies that secure paths in ZK have no access control. This is
+   * the case when zookeeper.set.acl=false and no ACLs have been configured.
+   */
+  def verifyUnsecureZkAcls(zkUtils: ZkUtils) {
+    secureZkPaths(zkUtils).foreach(path => {
+      if (zkUtils.pathExists(path)) {
+        val acls = zkUtils.zkConnection.getAcl(path).getKey
+        assertEquals(s"Invalid ACLs for $path $acls", 1, acls.size)
+        acls.asScala.foreach(isAclUnsecure)
+      }
+    })
+  }
+
   /**
     * To use this you pass in a sequence of functions that are your arrange/act/assert test on the SUT.
     * They all run at the same time in the assertConcurrent method; the chances of triggering a multithreading code error,
diff --git a/core/src/test/scala/unit/kafka/zk/ZooKeeperTestHarness.scala b/core/src/test/scala/unit/kafka/zk/ZooKeeperTestHarness.scala
index 5d580368db..2805b3b54e 100755
--- a/core/src/test/scala/unit/kafka/zk/ZooKeeperTestHarness.scala
+++ b/core/src/test/scala/unit/kafka/zk/ZooKeeperTestHarness.scala
@@ -31,6 +31,7 @@ abstract class ZooKeeperTestHarness extends JUnitSuite with Logging {
 
   val zkConnectionTimeout = 10000
   val zkSessionTimeout = 6000
+  protected val zkAclsEnabled: Option[Boolean] = None
 
   var zkUtils: ZkUtils = null
   var zookeeper: EmbeddedZookeeper = null
@@ -41,7 +42,7 @@ abstract class ZooKeeperTestHarness extends JUnitSuite with Logging {
   @Before
   def setUp() {
     zookeeper = new EmbeddedZookeeper()
-    zkUtils = ZkUtils(zkConnect, zkSessionTimeout, zkConnectionTimeout, JaasUtils.isZkSecurityEnabled())
+    zkUtils = ZkUtils(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkAclsEnabled.getOrElse(JaasUtils.isZkSecurityEnabled()))
   }
 
   @After
