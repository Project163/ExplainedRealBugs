diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/DefaultStateUpdater.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/DefaultStateUpdater.java
index 3ab94f689f..8133d8c19f 100644
--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/DefaultStateUpdater.java
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/DefaultStateUpdater.java
@@ -55,7 +55,6 @@ import java.util.Set;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -153,7 +152,6 @@ public class DefaultStateUpdater implements StateUpdater {
                 clearInputQueue();
                 clearUpdatingAndPausedTasks();
                 updaterMetrics.clear();
-                shutdownGate.countDown();
                 log.info("State updater thread stopped");
             }
         }
@@ -766,7 +764,6 @@ public class DefaultStateUpdater implements StateUpdater {
     private long lastCommitMs;
 
     private StateUpdaterThread stateUpdaterThread = null;
-    private CountDownLatch shutdownGate;
 
     public DefaultStateUpdater(final String name,
                                final Metrics metrics,
@@ -796,7 +793,6 @@ public class DefaultStateUpdater implements StateUpdater {
             }
             stateUpdaterThread = new StateUpdaterThread(name, metrics, changelogReader);
             stateUpdaterThread.start();
-            shutdownGate = new CountDownLatch(1);
 
             // initialize the last commit as of now to prevent first commit happens immediately
             this.lastCommitMs = time.milliseconds();
@@ -821,7 +817,8 @@ public class DefaultStateUpdater implements StateUpdater {
             }
 
             try {
-                if (!shutdownGate.await(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
+                stateUpdaterThread.join(timeout.toMillis());
+                if (stateUpdaterThread.isAlive()) {
                     throw new StreamsException("State updater thread did not shutdown within the timeout");
                 }
                 stateUpdaterThread = null;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/tasks/DefaultTaskExecutor.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/tasks/DefaultTaskExecutor.java
index 84b49d1cd1..99ac6a3dc0 100644
--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/tasks/DefaultTaskExecutor.java
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/tasks/DefaultTaskExecutor.java
@@ -32,8 +32,6 @@ import org.apache.kafka.streams.processor.internals.TaskExecutionMetadata;
 import org.slf4j.Logger;
 
 import java.time.Duration;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -74,8 +72,6 @@ public class DefaultTaskExecutor implements TaskExecutor {
                     unassignCurrentTask();
                 }
 
-                shutdownGate.countDown();
-
                 final KafkaFutureImpl<StreamTask> taskReleaseFuture;
                 if ((taskReleaseFuture = taskReleaseRequested.getAndSet(null)) != null) {
                     log.debug("Asked to return current task, but shutting down.");
@@ -223,7 +219,6 @@ public class DefaultTaskExecutor implements TaskExecutor {
 
     private StreamTask currentTask = null;
     private TaskExecutorThread taskExecutorThread = null;
-    private CountDownLatch shutdownGate;
 
     public DefaultTaskExecutor(final TaskManager taskManager,
                                final String name,
@@ -247,13 +242,12 @@ public class DefaultTaskExecutor implements TaskExecutor {
         if (taskExecutorThread == null) {
             taskExecutorThread = new TaskExecutorThread(name);
             taskExecutorThread.start();
-            shutdownGate = new CountDownLatch(1);
         }
     }
 
     @Override
     public boolean isRunning() {
-        return taskExecutorThread != null && taskExecutorThread.isAlive() && shutdownGate.getCount() != 0;
+        return taskExecutorThread != null && taskExecutorThread.isAlive();
     }
 
     @Override
@@ -267,7 +261,8 @@ public class DefaultTaskExecutor implements TaskExecutor {
     public void awaitShutdown(final Duration timeout) {
         if (taskExecutorThread != null) {
             try {
-                if (!shutdownGate.await(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
+                taskExecutorThread.join(timeout.toMillis());
+                if (taskExecutorThread.isAlive()) {
                     throw new StreamsException("State updater thread did not shutdown within the timeout");
                 }
                 taskExecutorThread = null;
@@ -290,7 +285,7 @@ public class DefaultTaskExecutor implements TaskExecutor {
             if (!taskExecutorThread.taskReleaseRequested.compareAndSet(null, future)) {
                 throw new IllegalStateException("There was already a task release request registered");
             }
-            if (shutdownGate.getCount() == 0) {
+            if (!taskExecutorThread.isAlive()) {
                 log.debug("Completing future, because task executor was just shut down");
                 future.complete(null);
             } else {
