diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
index 074d864b79..5b11beada9 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
@@ -1084,7 +1084,9 @@ public class AsyncKafkaConsumer<K, V> implements ConsumerDelegate<K, V> {
     }
 
     private Fetch<K, V> pollForFetches(Timer timer) {
-        long pollTimeout = timer.remainingMs();
+        long pollTimeout = isCommittedOffsetsManagementEnabled()
+                ? Math.min(applicationEventHandler.maximumTimeToWait(), timer.remainingMs())
+                : timer.remainingMs();
 
         // if data is available already, return it immediately
         final Fetch<K, V> fetch = collectFetch();
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/CommitRequestManager.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/CommitRequestManager.java
index 976fc12151..5caee5e503 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/CommitRequestManager.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/CommitRequestManager.java
@@ -165,6 +165,17 @@ public class CommitRequestManager implements RequestManager {
         return new NetworkClientDelegate.PollResult(timeUntilNextPoll, requests);
     }
 
+    /**
+     * Returns the delay for which the application thread can safely wait before it should be responsive
+     * to results from the request managers. For example, the subscription state can change when heartbeats
+     * are sent, so blocking for longer than the heartbeat interval might mean the application thread is not
+     * responsive to changes.
+     */
+    @Override
+    public long maximumTimeToWait(long currentTimeMs) {
+        return autoCommitState.map(ac -> ac.remainingMs(currentTimeMs)).orElse(Long.MAX_VALUE);
+    }
+
     private static long findMinTime(final Collection<? extends RequestState> requests, final long currentTimeMs) {
         return requests.stream()
             .mapToLong(request -> request.remainingBackoffMs(currentTimeMs))
@@ -799,6 +810,11 @@ public class CommitRequestManager implements RequestManager {
             this.timer.reset(autoCommitInterval);
         }
 
+        public long remainingMs(final long currentTimeMs) {
+            this.timer.update(currentTimeMs);
+            return this.timer.remainingMs();
+        }
+
         public void ack(final long currentTimeMs) {
             this.timer.update(currentTimeMs);
         }
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerNetworkThread.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerNetworkThread.java
index 7274897f34..e2d600fbc8 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerNetworkThread.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerNetworkThread.java
@@ -205,6 +205,26 @@ public class ConsumerNetworkThread extends KafkaThread implements Closeable {
             networkClientDelegate.wakeup();
     }
 
+    /**
+     * Returns the delay for which the application thread can safely wait before it should be responsive
+     * to results from the request managers. For example, the subscription state can change when heartbeats
+     * are sent, so blocking for longer than the heartbeat interval might mean the application thread is not
+     * responsive to changes.
+     *
+     * @return The maximum delay in milliseconds
+     */
+    public long maximumTimeToWait() {
+        final long currentTimeMs = time.milliseconds();
+        if (requestManagers == null) {
+            return MAX_POLL_TIMEOUT_MS;
+        }
+        return requestManagers.entries().stream()
+                .filter(Optional::isPresent)
+                .map(Optional::get)
+                .map(rm -> rm.maximumTimeToWait(currentTimeMs))
+                .reduce(Long.MAX_VALUE, Math::min);
+    }
+
     @Override
     public void close() {
         close(closeTimeout);
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManager.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManager.java
index 0390b48122..e724735f53 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManager.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManager.java
@@ -40,6 +40,8 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
+import java.util.stream.Collectors;
 
 /**
  * <p>Manages the request creation and response handling for the heartbeat. The module creates a
@@ -81,16 +83,16 @@ public class HeartbeatRequestManager implements RequestManager {
      */
     private final CoordinatorRequestManager coordinatorRequestManager;
 
-    /**
-     * SubscriptionState tracks the topic, partition and offset of the member
-     */
-    private final SubscriptionState subscriptions;
-
     /**
      * HeartbeatRequestState manages heartbeat request timing and retries
      */
     private final HeartbeatRequestState heartbeatRequestState;
 
+    /*
+     * HeartbeatState manages building the heartbeat requests correctly
+     */
+    private final HeartbeatState heartbeatState;
+
     /**
      * MembershipManager manages member's essential attributes like epoch and id, and its rebalance state
      */
@@ -111,12 +113,12 @@ public class HeartbeatRequestManager implements RequestManager {
         final BackgroundEventHandler backgroundEventHandler) {
         this.coordinatorRequestManager = coordinatorRequestManager;
         this.logger = logContext.logger(getClass());
-        this.subscriptions = subscriptions;
         this.membershipManager = membershipManager;
         this.backgroundEventHandler = backgroundEventHandler;
         this.rebalanceTimeoutMs = config.getInt(CommonClientConfigs.MAX_POLL_INTERVAL_MS_CONFIG);
         long retryBackoffMs = config.getLong(ConsumerConfig.RETRY_BACKOFF_MS_CONFIG);
         long retryBackoffMaxMs = config.getLong(ConsumerConfig.RETRY_BACKOFF_MAX_MS_CONFIG);
+        this.heartbeatState = new HeartbeatState(subscriptions, membershipManager, rebalanceTimeoutMs);
         this.heartbeatRequestState = new HeartbeatRequestState(logContext, time, 0, retryBackoffMs,
             retryBackoffMaxMs, rebalanceTimeoutMs);
     }
@@ -126,15 +128,15 @@ public class HeartbeatRequestManager implements RequestManager {
         final LogContext logContext,
         final ConsumerConfig config,
         final CoordinatorRequestManager coordinatorRequestManager,
-        final SubscriptionState subscriptions,
         final MembershipManager membershipManager,
+        final HeartbeatState heartbeatState,
         final HeartbeatRequestState heartbeatRequestState,
         final BackgroundEventHandler backgroundEventHandler) {
         this.logger = logContext.logger(this.getClass());
-        this.subscriptions = subscriptions;
         this.rebalanceTimeoutMs = config.getInt(CommonClientConfigs.MAX_POLL_INTERVAL_MS_CONFIG);
         this.coordinatorRequestManager = coordinatorRequestManager;
         this.heartbeatRequestState = heartbeatRequestState;
+        this.heartbeatState = heartbeatState;
         this.membershipManager = membershipManager;
         this.backgroundEventHandler = backgroundEventHandler;
     }
@@ -181,36 +183,24 @@ public class HeartbeatRequestManager implements RequestManager {
         return new NetworkClientDelegate.PollResult(heartbeatRequestState.heartbeatIntervalMs, Collections.singletonList(request));
     }
 
-    private NetworkClientDelegate.UnsentRequest makeHeartbeatRequest() {
-        // TODO: extract this logic for building the ConsumerGroupHeartbeatRequestData to a
-        //  stateful builder (HeartbeatState), that will keep the last data sent, and determine
-        //  the fields that changed and need to be included in the next HB (ex. check
-        //  subscriptionState changed from last sent to include assignment). It should also
-        //  ensure that all fields are sent on failure.
-        ConsumerGroupHeartbeatRequestData data = new ConsumerGroupHeartbeatRequestData()
-            .setGroupId(membershipManager.groupId())
-            .setMemberEpoch(membershipManager.memberEpoch())
-            .setRebalanceTimeoutMs(rebalanceTimeoutMs);
-
-        if (membershipManager.memberId() != null) {
-            data.setMemberId(membershipManager.memberId());
-        }
-
-        membershipManager.groupInstanceId().ifPresent(data::setInstanceId);
-
-        if (this.subscriptions.hasPatternSubscription()) {
-            // TODO: Pass the string to the GC if server side regex is used.
-        } else {
-            data.setSubscribedTopicNames(new ArrayList<>(this.subscriptions.subscription()));
-            List<ConsumerGroupHeartbeatRequestData.TopicPartitions> topicPartitions =
-                    buildTopicPartitionsList(membershipManager.currentAssignment());
-            data.setTopicPartitions(topicPartitions);
-        }
-
-        this.membershipManager.serverAssignor().ifPresent(data::setServerAssignor);
+    /**
+     * Returns the delay for which the application thread can safely wait before it should be responsive
+     * to results from the request managers. For example, the subscription state can change when heartbeats
+     * are sent, so blocking for longer than the heartbeat interval might mean the application thread is not
+     * responsive to changes.
+     *
+     * <p>In the event that heartbeats are currently being skipped, this still returns the next heartbeat
+     * delay rather than {@code Long.MAX_VALUE} so that the application thread remains responsive.
+     */
+    @Override
+    public long maximumTimeToWait(long currentTimeMs) {
+        boolean heartbeatNow = membershipManager.shouldHeartbeatNow() && !heartbeatRequestState.requestInFlight();
+        return heartbeatNow ? 0L : heartbeatRequestState.nextHeartbeatMs(currentTimeMs);
+    }
 
+    private NetworkClientDelegate.UnsentRequest makeHeartbeatRequest() {
         NetworkClientDelegate.UnsentRequest request = new NetworkClientDelegate.UnsentRequest(
-            new ConsumerGroupHeartbeatRequest.Builder(data),
+            new ConsumerGroupHeartbeatRequest.Builder(this.heartbeatState.buildRequestData()),
             coordinatorRequestManager.coordinator());
         return request.whenComplete((response, exception) -> {
             if (response != null) {
@@ -221,28 +211,9 @@ public class HeartbeatRequestManager implements RequestManager {
         });
     }
 
-    private List<ConsumerGroupHeartbeatRequestData.TopicPartitions> buildTopicPartitionsList(Set<TopicIdPartition> topicIdPartitions) {
-        List<ConsumerGroupHeartbeatRequestData.TopicPartitions> result = new ArrayList<>();
-        Map<Uuid, List<Integer>> partitionsPerTopicId = new HashMap<>();
-        for (TopicIdPartition topicIdPartition : topicIdPartitions) {
-            Uuid topicId = topicIdPartition.topicId();
-            if (!partitionsPerTopicId.containsKey(topicId)) {
-                partitionsPerTopicId.put(topicId, new ArrayList<>());
-            }
-            partitionsPerTopicId.get(topicId).add(topicIdPartition.partition());
-        }
-        for (Map.Entry<Uuid, List<Integer>> entry : partitionsPerTopicId.entrySet()) {
-            Uuid topicId = entry.getKey();
-            List<Integer> partitions = entry.getValue();
-            result.add(new ConsumerGroupHeartbeatRequestData.TopicPartitions()
-                    .setTopicId(topicId)
-                    .setPartitions(partitions));
-        }
-        return result;
-    }
-
     private void onFailure(final Throwable exception, final long responseTimeMs) {
         this.heartbeatRequestState.onFailedAttempt(responseTimeMs);
+        this.heartbeatState.reset();
         if (exception instanceof RetriableException) {
             String message = String.format("GroupHeartbeatRequest failed because of the retriable exception. " +
                     "Will retry in %s ms: %s",
@@ -271,6 +242,9 @@ public class HeartbeatRequestManager implements RequestManager {
         Errors error = Errors.forCode(response.data().errorCode());
         String errorMessage = response.data().errorMessage();
         String message;
+
+        this.heartbeatState.reset();
+
         // TODO: upon encountering a fatal/fenced error, trigger onPartitionLost logic to give up the current
         //  assignments.
         switch (error) {
@@ -417,4 +391,133 @@ public class HeartbeatRequestManager implements RequestManager {
             this.heartbeatTimer.updateAndReset(heartbeatIntervalMs);
         }
     }
+
+    /**
+     * Builds the heartbeat requests correctly, ensuring that all information is sent according to
+     * the protocol, but subsequent requests do not send information which has not changed. This
+     * is important to ensure that reconciliation completes successfully.
+     */
+    static class HeartbeatState {
+        private final SubscriptionState subscriptions;
+        private final MembershipManager membershipManager;
+        private final int rebalanceTimeoutMs;
+        private final SentFields sentFields;
+
+        public HeartbeatState(
+            final SubscriptionState subscriptions,
+            final MembershipManager membershipManager,
+            final int rebalanceTimeoutMs) {
+            this.subscriptions = subscriptions;
+            this.membershipManager = membershipManager;
+            this.rebalanceTimeoutMs = rebalanceTimeoutMs;
+            this.sentFields = new SentFields();
+        }
+
+
+        public void reset() {
+            sentFields.reset();
+        }
+
+        public ConsumerGroupHeartbeatRequestData buildRequestData() {
+            ConsumerGroupHeartbeatRequestData data = new ConsumerGroupHeartbeatRequestData();
+
+            // GroupId - always sent
+            data.setGroupId(membershipManager.groupId());
+
+            // MemberId - always sent, empty until it has been received from the coordinator
+            data.setMemberId(membershipManager.memberId());
+
+            // MemberEpoch - always sent
+            data.setMemberEpoch(membershipManager.memberEpoch());
+
+            // InstanceId - only sent if has changed since the last heartbeat
+            membershipManager.groupInstanceId().ifPresent(groupInstanceId -> {
+                if (!groupInstanceId.equals(sentFields.instanceId)) {
+                    data.setInstanceId(groupInstanceId);
+                    sentFields.instanceId = groupInstanceId;
+                }
+            });
+
+            // RebalanceTimeoutMs - only sent if has changed since the last heartbeat
+            if (sentFields.rebalanceTimeoutMs != rebalanceTimeoutMs) {
+                data.setRebalanceTimeoutMs(rebalanceTimeoutMs);
+                sentFields.rebalanceTimeoutMs = rebalanceTimeoutMs;
+            }
+
+            if (!this.subscriptions.hasPatternSubscription()) {
+                // SubscribedTopicNames - only sent if has changed since the last heartbeat
+                TreeSet<String> subscribedTopicNames = new TreeSet<>(this.subscriptions.subscription());
+                if (!subscribedTopicNames.equals(sentFields.subscribedTopicNames)) {
+                    data.setSubscribedTopicNames(new ArrayList<>(this.subscriptions.subscription()));
+                    sentFields.subscribedTopicNames = subscribedTopicNames;
+                }
+            } else {
+                // SubscribedTopicRegex - only sent if has changed since the last heartbeat
+                //                      - not supported yet
+            }
+
+            // ServerAssignor - only sent if has changed since the last heartbeat
+            this.membershipManager.serverAssignor().ifPresent(serverAssignor -> {
+                if (!serverAssignor.equals(sentFields.serverAssignor)) {
+                    data.setServerAssignor(serverAssignor);
+                    sentFields.serverAssignor = serverAssignor;
+                }
+            });
+
+            // ClientAssignors - not supported yet
+
+            // TopicPartitions - only sent if has changed since the last heartbeat
+            //   Note that TopicIdPartition.toString is being avoided here so that
+            //   the string consists of just the topic ID and the partition. 
+            //   When an assignment is received, we might not yet know the topic name
+            //   and then it is learnt subsequently by a metadata update.
+            TreeSet<String> assignedPartitions = membershipManager.currentAssignment().stream()
+                    .map(tp -> tp.topicId() + "-" + tp.partition())
+                    .collect(Collectors.toCollection(TreeSet::new));
+            if (!assignedPartitions.equals(sentFields.topicPartitions)) {
+                List<ConsumerGroupHeartbeatRequestData.TopicPartitions> topicPartitions =
+                        buildTopicPartitionsList(membershipManager.currentAssignment());
+                data.setTopicPartitions(topicPartitions);
+                sentFields.topicPartitions = assignedPartitions;
+            }
+
+            return data;
+        }
+
+        private List<ConsumerGroupHeartbeatRequestData.TopicPartitions> buildTopicPartitionsList(Set<TopicIdPartition> topicIdPartitions) {
+            List<ConsumerGroupHeartbeatRequestData.TopicPartitions> result = new ArrayList<>();
+            Map<Uuid, List<Integer>> partitionsPerTopicId = new HashMap<>();
+            for (TopicIdPartition topicIdPartition : topicIdPartitions) {
+                Uuid topicId = topicIdPartition.topicId();
+                partitionsPerTopicId.computeIfAbsent(topicId, __ -> new ArrayList<>()).add(topicIdPartition.partition());
+            }
+            for (Map.Entry<Uuid, List<Integer>> entry : partitionsPerTopicId.entrySet()) {
+                Uuid topicId = entry.getKey();
+                List<Integer> partitions = entry.getValue();
+                result.add(new ConsumerGroupHeartbeatRequestData.TopicPartitions()
+                        .setTopicId(topicId)
+                        .setPartitions(partitions));
+            }
+            return result;
+        }
+
+        // Fields of ConsumerHeartbeatRequest sent in the most recent request
+        static class SentFields {
+            private String instanceId = null;
+            private int rebalanceTimeoutMs = -1;
+            private TreeSet<String> subscribedTopicNames = null;
+            private String serverAssignor = null;
+            private TreeSet<String> topicPartitions = null;
+
+            SentFields() {}
+
+            void reset() {
+                instanceId = null;
+                rebalanceTimeoutMs = -1;
+                subscribedTopicNames = null;
+                serverAssignor = null;
+                topicPartitions = null;
+            }
+        }
+    }
 }
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java
index cdfa9881e8..8e19f10f24 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/MembershipManagerImpl.java
@@ -414,7 +414,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
      * Update a new assignment by setting the assigned partitions in the member subscription.
      *
      * @param assignedPartitions Topic partitions to take as the new subscription assignment
-     * @param clearAssignments True if the
+     * @param clearAssignments True if the pending assignments and metadata cache should be cleared
      */
     private void updateSubscription(Collection<TopicPartition> assignedPartitions,
                                     boolean clearAssignments) {
@@ -605,6 +605,12 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
      * reconciliation loop.
      */
     boolean reconcile() {
+        if (reconciliationInProgress) {
+            log.debug("Ignoring reconciliation attempt. Another reconciliation is already in progress. Assignment " +
+                    assignmentReadyToReconcile + " will be handled in the next reconciliation loop.");
+            return false;
+        }
+
         // Make copy of the assignment to reconcile as it could change as new assignments or metadata updates are received
         SortedSet<TopicIdPartition> assignedTopicIdPartitions = new TreeSet<>(TOPIC_ID_PARTITION_COMPARATOR);
         assignedTopicIdPartitions.addAll(assignmentReadyToReconcile);
@@ -615,21 +621,15 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
         // Keep copy of assigned TopicPartitions created from the TopicIdPartitions that are
         // being reconciled. Needed for interactions with the centralized subscription state that
         // does not support topic IDs yet, and for the callbacks.
-        SortedSet<TopicPartition> assignedTopicPartition = toTopicPartitionSet(assignedTopicIdPartitions);
+        SortedSet<TopicPartition> assignedTopicPartitions = toTopicPartitionSet(assignedTopicIdPartitions);
 
         // Check same assignment. Based on topic names for now, until topic IDs are properly
         // supported in the centralized subscription state object.
-        boolean sameAssignmentReceived = assignedTopicPartition.equals(ownedPartitions);
+        boolean sameAssignmentReceived = assignedTopicPartitions.equals(ownedPartitions);
 
-        if (reconciliationInProgress || sameAssignmentReceived) {
-            String reason;
-            if (reconciliationInProgress) {
-                reason = "Another reconciliation is already in progress. Assignment " +
-                        assignmentReadyToReconcile + " will be handled in the next reconciliation loop.";
-            } else {
-                reason = "Target assignment ready to reconcile is equals to the member current assignment.";
-            }
-            log.debug("Ignoring reconciliation attempt. " + reason);
+        if (sameAssignmentReceived) {
+            log.debug("Ignoring reconciliation attempt. Target assignment ready to reconcile {} " +
+                    "is equal to the member current assignment {}.", assignedTopicPartitions, ownedPartitions);
             return false;
         }
 
@@ -637,13 +637,13 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
 
         // Partitions to assign (not previously owned)
         SortedSet<TopicPartition> addedPartitions = new TreeSet<>(TOPIC_PARTITION_COMPARATOR);
-        addedPartitions.addAll(assignedTopicPartition);
+        addedPartitions.addAll(assignedTopicPartitions);
         addedPartitions.removeAll(ownedPartitions);
 
         // Partitions to revoke
         SortedSet<TopicPartition> revokedPartitions = new TreeSet<>(TOPIC_PARTITION_COMPARATOR);
         revokedPartitions.addAll(ownedPartitions);
-        revokedPartitions.removeAll(assignedTopicPartition);
+        revokedPartitions.removeAll(assignedTopicPartitions);
 
         log.info("Updating assignment with\n" +
                         "\tAssigned partitions:                       {}\n" +
@@ -673,7 +673,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
                     boolean memberHasRejoined = memberEpochOnReconciliationStart != memberEpoch;
                     if (state == MemberState.RECONCILING && !memberHasRejoined) {
                         // Apply assignment
-                        CompletableFuture<Void> assignResult = assignPartitions(assignedTopicPartition,
+                        CompletableFuture<Void> assignResult = assignPartitions(assignedTopicPartitions,
                                 addedPartitions);
 
                         // Clear topic names cache only for topics that are not in the subscription anymore
@@ -1074,6 +1074,7 @@ public class MembershipManagerImpl implements MembershipManager, ClusterResource
     public void onUpdate(ClusterResource clusterResource) {
         resolveMetadataForUnresolvedAssignment();
         if (!assignmentReadyToReconcile.isEmpty()) {
+            transitionTo(MemberState.RECONCILING);
             reconcile();
         }
     }
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/NetworkClientDelegate.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/NetworkClientDelegate.java
index 698bbaabcd..732de9055c 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/NetworkClientDelegate.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/NetworkClientDelegate.java
@@ -328,7 +328,11 @@ public class NetworkClientDelegate implements AutoCloseable {
 
         public void onFailure(final long currentTimeMs, final RuntimeException e) {
             this.responseCompletionTimeMs = currentTimeMs;
-            this.future.completeExceptionally(e);
+            if (e != null) {
+                this.future.completeExceptionally(e);
+            } else {
+                this.future.completeExceptionally(DisconnectException.INSTANCE);
+            }
         }
 
         public long completionTimeMs() {
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/RequestManager.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/RequestManager.java
index 8592035dda..0cda89aedf 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/RequestManager.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/RequestManager.java
@@ -62,4 +62,19 @@ public interface RequestManager {
     default PollResult pollOnClose() {
         return EMPTY;
     }
+
+    /**
+     * Returns the delay for which the application thread can safely wait before it should be responsive
+     * to results from the request managers. For example, the subscription state can change when heartbeats
+     * are sent, so blocking for longer than the heartbeat interval might mean the application thread is not
+     * responsive to changes.
+     *
+     * @param currentTimeMs The current system time at which the method was called; useful for determining if
+     *                      time-sensitive operations should be performed
+     *
+     * @return The maximum delay in milliseconds
+     */
+    default long maximumTimeToWait(long currentTimeMs) {
+        return Long.MAX_VALUE;
+    }
 }
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/events/ApplicationEventHandler.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/events/ApplicationEventHandler.java
index 2917d507d7..f564a80d47 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/events/ApplicationEventHandler.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/events/ApplicationEventHandler.java
@@ -81,6 +81,18 @@ public class ApplicationEventHandler implements Closeable {
         networkThread.wakeup();
     }
 
+    /**
+     * Returns the delay for which the application thread can safely wait before it should be responsive
+     * to results from the request managers. For example, the subscription state can change when heartbeats
+     * are sent, so blocking for longer than the heartbeat interval might mean the application thread is not
+     * responsive to changes.
+     *
+     * @return The maximum delay in milliseconds
+     */
+    public long maximumTimeToWait() {
+        return networkThread.maximumTimeToWait();
+    }
+
     /**
      * Add a {@link CompletableApplicationEvent} to the handler. The method blocks waiting for the result, and will
      * return the result value upon successful completion; otherwise throws an error.
diff --git a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumerTest.java b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumerTest.java
index 2a2ee9ba2b..4624a391a8 100644
--- a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumerTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumerTest.java
@@ -18,6 +18,7 @@ package org.apache.kafka.clients.consumer.internals;
 
 import org.apache.kafka.clients.ClientResponse;
 import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
 import org.apache.kafka.clients.consumer.OffsetAndMetadata;
 import org.apache.kafka.clients.consumer.OffsetAndTimestamp;
 import org.apache.kafka.clients.consumer.OffsetCommitCallback;
@@ -110,6 +111,7 @@ public class AsyncKafkaConsumerTest {
     private FetchCollector<?, ?> fetchCollector;
     private ConsumerTestBuilder.AsyncKafkaConsumerTestBuilder testBuilder;
     private ApplicationEventHandler applicationEventHandler;
+    private SubscriptionState subscriptions;
 
     @BeforeEach
     public void setup() {
@@ -122,6 +124,7 @@ public class AsyncKafkaConsumerTest {
         applicationEventHandler = testBuilder.applicationEventHandler;
         consumer = testBuilder.consumer;
         fetchCollector = testBuilder.fetchCollector;
+        subscriptions = testBuilder.subscriptions;
     }
 
     @AfterEach
@@ -793,6 +796,38 @@ public class AsyncKafkaConsumerTest {
         }
     }
 
+    @Test
+    public void testLongPollWaitIsLimited() {
+        String topicName = "topic1";
+        consumer.subscribe(singletonList(topicName));
+
+        assertEquals(singleton(topicName), consumer.subscription());
+        assertTrue(consumer.assignment().isEmpty());
+
+        final int partition = 3;
+        final TopicPartition tp = new TopicPartition(topicName, partition);
+        final List<ConsumerRecord<String, String>> records = asList(
+            new ConsumerRecord<>(topicName, partition, 2, "key1", "value1"),
+            new ConsumerRecord<>(topicName, partition, 3, "key2", "value2")
+        );
+
+        // On the first iteration, return no data; on the second, return two records
+        doAnswer(invocation -> {
+            // Mock the subscription being assigned as the first fetch is collected
+            subscriptions.assignFromSubscribed(Collections.singleton(tp));
+            return Fetch.empty();
+        }).doAnswer(invocation -> {
+            return Fetch.forPartition(tp, records, true);
+        }).when(fetchCollector).collectFetch(any(FetchBuffer.class));
+
+        // And then poll for up to 10000ms, which should return 2 records without timing out
+        ConsumerRecords<?, ?> returnedRecords = consumer.poll(Duration.ofMillis(10000));
+        assertEquals(2, returnedRecords.count());
+
+        assertEquals(singleton(topicName), consumer.subscription());
+        assertEquals(singleton(tp), consumer.assignment());
+    }
+
     private void assertNoPendingWakeup(final WakeupTrigger wakeupTrigger) {
         assertNull(wakeupTrigger.getPendingTask());
     }
diff --git a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerTestBuilder.java b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerTestBuilder.java
index 7e4336d388..801fe76bc9 100644
--- a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerTestBuilder.java
+++ b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerTestBuilder.java
@@ -87,6 +87,7 @@ public class ConsumerTestBuilder implements Closeable {
     final Optional<CommitRequestManager> commitRequestManager;
     final Optional<HeartbeatRequestManager> heartbeatRequestManager;
     final Optional<MembershipManager> membershipManager;
+    final Optional<HeartbeatRequestManager.HeartbeatState> heartbeatState;
     final Optional<HeartbeatRequestManager.HeartbeatRequestState> heartbeatRequestState;
     final TopicMetadataRequestManager topicMetadataRequestManager;
     final FetchRequestManager fetchRequestManager;
@@ -204,7 +205,12 @@ public class ConsumerTestBuilder implements Closeable {
                         logContext
                 )
             );
-            HeartbeatRequestManager.HeartbeatRequestState state = spy(new HeartbeatRequestManager.HeartbeatRequestState(logContext,
+            HeartbeatRequestManager.HeartbeatState heartbeatState = spy(new HeartbeatRequestManager.HeartbeatState(
+                    subscriptions,
+                    mm,
+                    DEFAULT_MAX_POLL_INTERVAL_MS));
+            HeartbeatRequestManager.HeartbeatRequestState heartbeatRequestState = spy(new HeartbeatRequestManager.HeartbeatRequestState(
+                    logContext,
                     time,
                     gi.heartbeatIntervalMs,
                     retryBackoffMs,
@@ -214,20 +220,22 @@ public class ConsumerTestBuilder implements Closeable {
                     logContext,
                     config,
                     coordinator,
-                    subscriptions,
                     mm,
-                    state,
+                    heartbeatState,
+                    heartbeatRequestState,
                     backgroundEventHandler));
 
             this.coordinatorRequestManager = Optional.of(coordinator);
             this.commitRequestManager = Optional.of(commit);
             this.heartbeatRequestManager = Optional.of(heartbeat);
-            this.heartbeatRequestState = Optional.of(state);
+            this.heartbeatState = Optional.of(heartbeatState);
+            this.heartbeatRequestState = Optional.of(heartbeatRequestState);
             this.membershipManager = Optional.of(mm);
         } else {
             this.coordinatorRequestManager = Optional.empty();
             this.commitRequestManager = Optional.empty();
             this.heartbeatRequestManager = Optional.empty();
+            this.heartbeatState = Optional.empty();
             this.heartbeatRequestState = Optional.empty();
             this.membershipManager = Optional.empty();
         }
diff --git a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManagerTest.java b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManagerTest.java
index bc336c2786..ae15f2b485 100644
--- a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManagerTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/HeartbeatRequestManagerTest.java
@@ -20,7 +20,9 @@ import org.apache.kafka.clients.ClientResponse;
 import org.apache.kafka.clients.consumer.internals.events.BackgroundEventHandler;
 import org.apache.kafka.common.KafkaException;
 import org.apache.kafka.common.Node;
+import org.apache.kafka.common.Uuid;
 import org.apache.kafka.common.errors.TimeoutException;
+import org.apache.kafka.common.message.ConsumerGroupHeartbeatRequestData;
 import org.apache.kafka.common.message.ConsumerGroupHeartbeatResponseData;
 import org.apache.kafka.common.protocol.ApiKeys;
 import org.apache.kafka.common.protocol.Errors;
@@ -68,6 +70,7 @@ public class HeartbeatRequestManagerTest {
     private HeartbeatRequestManager heartbeatRequestManager;
     private MembershipManager membershipManager;
     private HeartbeatRequestManager.HeartbeatRequestState heartbeatRequestState;
+    private HeartbeatRequestManager.HeartbeatState heartbeatState;
     private final String memberId = "member-id";
     private final int memberEpoch = 1;
     private BackgroundEventHandler backgroundEventHandler;
@@ -83,6 +86,7 @@ public class HeartbeatRequestManagerTest {
         coordinatorRequestManager = testBuilder.coordinatorRequestManager.orElseThrow(IllegalStateException::new);
         heartbeatRequestManager = testBuilder.heartbeatRequestManager.orElseThrow(IllegalStateException::new);
         heartbeatRequestState = testBuilder.heartbeatRequestState.orElseThrow(IllegalStateException::new);
+        heartbeatState = testBuilder.heartbeatState.orElseThrow(IllegalStateException::new);
         backgroundEventHandler = testBuilder.backgroundEventHandler;
         subscriptions = testBuilder.subscriptions;
         membershipManager = testBuilder.membershipManager.orElseThrow(IllegalStateException::new);
@@ -116,6 +120,7 @@ public class HeartbeatRequestManagerTest {
 
         resetWithZeroHeartbeatInterval(Optional.empty());
         mockStableMember();
+        assertEquals(0, heartbeatRequestManager.maximumTimeToWait(time.milliseconds()));
         result = heartbeatRequestManager.poll(time.milliseconds());
         assertEquals(1, result.unsentRequests.size());
 
@@ -133,6 +138,7 @@ public class HeartbeatRequestManagerTest {
         membershipManager.onSubscriptionUpdated();
 
         // Create a ConsumerHeartbeatRequest and verify the payload
+        assertEquals(0, heartbeatRequestManager.maximumTimeToWait(time.milliseconds()));
         NetworkClientDelegate.PollResult pollResult = heartbeatRequestManager.poll(time.milliseconds());
         assertEquals(1, pollResult.unsentRequests.size());
         NetworkClientDelegate.UnsentRequest request = pollResult.unsentRequests.get(0);
@@ -181,6 +187,7 @@ public class HeartbeatRequestManagerTest {
         NetworkClientDelegate.PollResult result = heartbeatRequestManager.poll(time.milliseconds());
         assertEquals(0, result.unsentRequests.size());
         assertEquals(DEFAULT_HEARTBEAT_INTERVAL_MS - 100, result.timeUntilNextPollMs);
+        assertEquals(DEFAULT_HEARTBEAT_INTERVAL_MS - 100, heartbeatRequestManager.maximumTimeToWait(time.milliseconds()));
 
         // Member in state where it should not send Heartbeat anymore
         when(subscriptions.hasAutoAssignedPartitions()).thenReturn(true);
@@ -199,6 +206,7 @@ public class HeartbeatRequestManagerTest {
         assertEquals(1, result.unsentRequests.size());
         // Interval timer reset
         assertEquals(DEFAULT_HEARTBEAT_INTERVAL_MS, result.timeUntilNextPollMs);
+        assertEquals(DEFAULT_HEARTBEAT_INTERVAL_MS, heartbeatRequestManager.maximumTimeToWait(time.milliseconds()));
         // Membership manager updated (to transition out of the heartbeating state)
         verify(membershipManager).onHeartbeatRequestSent();
     }
@@ -244,6 +252,7 @@ public class HeartbeatRequestManagerTest {
         NetworkClientDelegate.PollResult result = heartbeatRequestManager.poll(time.milliseconds());
 
         assertEquals(Long.MAX_VALUE, result.timeUntilNextPollMs);
+        assertEquals(DEFAULT_HEARTBEAT_INTERVAL_MS, heartbeatRequestManager.maximumTimeToWait(time.milliseconds()));
         assertEquals(0, result.unsentRequests.size());
     }
 
@@ -332,6 +341,72 @@ public class HeartbeatRequestManagerTest {
         }
     }
 
+    @Test
+    public void testHeartbeatState() {
+        // The initial ConsumerGroupHeartbeatRequest sets most fields to their initial empty values
+        ConsumerGroupHeartbeatRequestData data = heartbeatState.buildRequestData();
+        assertEquals(ConsumerTestBuilder.DEFAULT_GROUP_ID, data.groupId());
+        assertEquals("", data.memberId());
+        assertEquals(0, data.memberEpoch());
+        assertNull(data.instanceId());
+        assertEquals(ConsumerTestBuilder.DEFAULT_MAX_POLL_INTERVAL_MS, data.rebalanceTimeoutMs());
+        assertEquals(Collections.emptyList(), data.subscribedTopicNames());
+        assertNull(data.subscribedTopicRegex());
+        assertNull(data.serverAssignor());
+        assertEquals(Collections.emptyList(), data.topicPartitions());
+        membershipManager.onHeartbeatRequestSent();
+        assertEquals(MemberState.UNSUBSCRIBED, membershipManager.state());
+
+        // Mock a response from the group coordinator, that supplies the member ID and a new epoch
+        mockStableMember();
+        data = heartbeatState.buildRequestData();
+        assertEquals(ConsumerTestBuilder.DEFAULT_GROUP_ID, data.groupId());
+        assertEquals(memberId, data.memberId());
+        assertEquals(1, data.memberEpoch());
+        assertNull(data.instanceId());
+        assertEquals(-1, data.rebalanceTimeoutMs());
+        assertNull(data.subscribedTopicNames());
+        assertNull(data.subscribedTopicRegex());
+        assertNull(data.serverAssignor());
+        assertNull(data.topicPartitions());
+        membershipManager.onHeartbeatRequestSent();
+        assertEquals(MemberState.STABLE, membershipManager.state());
+
+        // Join the group and subscribe to a topic, but the response has not yet been received
+        String topic = "topic1";
+        subscriptions.subscribe(Collections.singleton(topic), Optional.empty());
+        membershipManager.onSubscriptionUpdated();
+        membershipManager.transitionToFenced(); // And indirect way of moving to JOINING state
+        data = heartbeatState.buildRequestData();
+        assertEquals(ConsumerTestBuilder.DEFAULT_GROUP_ID, data.groupId());
+        assertEquals(memberId, data.memberId());
+        assertEquals(0, data.memberEpoch());
+        assertNull(data.instanceId());
+        assertEquals(-1, data.rebalanceTimeoutMs());
+        assertEquals(Collections.singletonList(topic), data.subscribedTopicNames());
+        assertNull(data.subscribedTopicRegex());
+        assertNull(data.serverAssignor());
+        assertNull(data.topicPartitions());
+        membershipManager.onHeartbeatRequestSent();
+        assertEquals(MemberState.JOINING, membershipManager.state());
+
+        // Mock the response from the group coordinator which returns an assignment
+        ConsumerGroupHeartbeatResponseData.TopicPartitions tpTopic1 =
+            new ConsumerGroupHeartbeatResponseData.TopicPartitions();
+        tpTopic1.setTopicId(Uuid.randomUuid());
+        tpTopic1.setPartitions(Collections.singletonList(0));
+        ConsumerGroupHeartbeatResponseData.Assignment assignmentTopic1 =
+            new ConsumerGroupHeartbeatResponseData.Assignment();
+        assignmentTopic1.setTopicPartitions(Collections.singletonList(tpTopic1));
+        ConsumerGroupHeartbeatResponse rs1 = new ConsumerGroupHeartbeatResponse(new ConsumerGroupHeartbeatResponseData()
+                .setHeartbeatIntervalMs(DEFAULT_HEARTBEAT_INTERVAL_MS)
+                .setMemberId(memberId)
+                .setMemberEpoch(1)
+                .setAssignment(assignmentTopic1));
+        membershipManager.onHeartbeatResponseReceived(rs1.data());
+        assertEquals(MemberState.RECONCILING, membershipManager.state());
+    }
+
     private void mockStableMember() {
         membershipManager.onSubscriptionUpdated();
         // Heartbeat response without assignment to set the state to STABLE.
