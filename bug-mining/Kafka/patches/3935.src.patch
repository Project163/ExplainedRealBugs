diff --git a/core/src/main/scala/kafka/tools/StorageTool.scala b/core/src/main/scala/kafka/tools/StorageTool.scala
index db1531ead4..13c7eaac17 100644
--- a/core/src/main/scala/kafka/tools/StorageTool.scala
+++ b/core/src/main/scala/kafka/tools/StorageTool.scala
@@ -36,6 +36,7 @@ import org.apache.kafka.server.config.ReplicationConfigs
 
 import java.util
 import scala.collection.mutable
+import scala.jdk.CollectionConverters.{ListHasAsScala, MapHasAsScala}
 
 object StorageTool extends Logging {
 
@@ -90,6 +91,10 @@ object StorageTool extends Logging {
         runVersionMappingCommand(namespace, printStream)
         0
 
+      case "feature-dependencies" =>
+        runFeatureDependenciesCommand(namespace, printStream)
+        0
+
       case "random-uuid" =>
         printStream.println(Uuid.randomUuid)
         0
@@ -162,11 +167,70 @@ object StorageTool extends Logging {
       }
     } catch {
       case e: IllegalArgumentException =>
-        throw new TerseFailure(s"Unsupported release version '$releaseVersion'. Supported versions are: " +
+        throw new TerseFailure(s"Unknown release version '$releaseVersion'. Supported versions are: " +
           s"${MetadataVersion.MINIMUM_BOOTSTRAP_VERSION.version} to ${MetadataVersion.LATEST_PRODUCTION.version}")
     }
   }
 
+  def runFeatureDependenciesCommand(
+    namespace: Namespace,
+    printStream: PrintStream
+  ): Unit = {
+    val featureArgs = Option(namespace.getList[String]("feature")).map(_.asScala.toList).getOrElse(List.empty)
+
+    // Iterate over each feature specified with --feature
+    if (featureArgs != null) {
+      for (featureArg <- featureArgs) {
+        val Array(featureName, versionStr) = featureArg.split("=")
+
+        val featureLevel = try {
+          versionStr.toShort
+        } catch {
+          case _: NumberFormatException =>
+            throw new TerseFailure(s"Invalid version format: $versionStr for feature $featureName")
+        }
+
+        if (featureName == MetadataVersion.FEATURE_NAME) {
+          val metadataVersion = try {
+            MetadataVersion.fromFeatureLevel(featureLevel)
+          } catch {
+            case _: IllegalArgumentException =>
+              throw new TerseFailure(s"Unknown metadata.version $featureLevel")
+          }
+          printStream.printf("%s=%d (%s) has no dependencies.%n", featureName, featureLevel, metadataVersion.version())
+        } else {
+          Features.values().find(_.featureName == featureName) match {
+            case Some(feature) =>
+              val featureVersion = try {
+                feature.fromFeatureLevel(featureLevel, true)
+              } catch {
+                case _: IllegalArgumentException =>
+                  throw new TerseFailure(s"Feature level $featureLevel is not supported for feature $featureName")
+              }
+              val dependencies = featureVersion.dependencies().asScala
+
+              if (dependencies.isEmpty) {
+                printStream.printf("%s=%d has no dependencies.%n", featureName, featureLevel)
+              } else {
+                printStream.printf("%s=%d requires:%n", featureName, featureLevel)
+                for ((depFeature, depLevel) <- dependencies) {
+                  if (depFeature == MetadataVersion.FEATURE_NAME) {
+                    val metadataVersion = MetadataVersion.fromFeatureLevel(depLevel)
+                    printStream.println(s"    $depFeature=$depLevel (${metadataVersion.version()})")
+                  } else {
+                    printStream.println(s"    $depFeature=$depLevel")
+                  }
+                }
+              }
+
+            case None =>
+              throw new TerseFailure(s"Unknown feature: $featureName")
+          }
+        }
+      }
+    }
+  }
+
   def createStandaloneDynamicVoters(
     config: KafkaConfig
   ): DynamicVoters = {
@@ -195,6 +259,7 @@ object StorageTool extends Logging {
     addInfoParser(subparsers)
     addFormatParser(subparsers)
     addVersionMappingParser(subparsers)
+    addFeatureDependenciesParser(subparsers)
     addRandomUuidParser(subparsers)
 
     parser.parseArgs(args)
@@ -260,6 +325,21 @@ object StorageTool extends Logging {
         s"${MetadataVersion.IBP_3_0_IV0}; the default is ${MetadataVersion.LATEST_PRODUCTION}")
   }
 
+  private def addFeatureDependenciesParser(subparsers: Subparsers): Unit = {
+    val featureDependenciesParser = subparsers.addParser("feature-dependencies")
+      .help("Look up dependencies for a given feature version. " +
+        "If the feature is not known or the version not yet defined, an error is thrown. " +
+        "Multiple features can be specified."
+      )
+
+    featureDependenciesParser.addArgument("--feature", "-f")
+      .required(true)
+      .help("The features and their versions to look up dependencies for, in feature=version format." +
+        " For example: `metadata.version=5`."
+      )
+      .action(append())
+  }
+
   private def addRandomUuidParser(subparsers: Subparsers): Unit = {
     subparsers.addParser("random-uuid")
       .help("Print a random UUID.")
diff --git a/core/src/test/scala/unit/kafka/tools/StorageToolTest.scala b/core/src/test/scala/unit/kafka/tools/StorageToolTest.scala
index b868c6a708..a4711a1969 100644
--- a/core/src/test/scala/unit/kafka/tools/StorageToolTest.scala
+++ b/core/src/test/scala/unit/kafka/tools/StorageToolTest.scala
@@ -512,7 +512,7 @@ Found problem:
       runVersionMappingCommand(stream, "2.9-IV2")
     })
 
-    assertEquals("Unsupported release version '2.9-IV2'." +
+    assertEquals("Unknown release version '2.9-IV2'." +
       " Supported versions are: " + MetadataVersion.MINIMUM_BOOTSTRAP_VERSION.version +
       " to " + MetadataVersion.LATEST_PRODUCTION.version, exception.getMessage
     )
@@ -521,9 +521,102 @@ Found problem:
       runVersionMappingCommand(stream, "invalid")
     })
 
-    assertEquals("Unsupported release version 'invalid'." +
+    assertEquals("Unknown release version 'invalid'." +
       " Supported versions are: " + MetadataVersion.MINIMUM_BOOTSTRAP_VERSION.version +
       " to " + MetadataVersion.LATEST_PRODUCTION.version, exception2.getMessage
     )
   }
+
+  private def runFeatureDependenciesCommand(
+    stream: ByteArrayOutputStream,
+    features: Seq[String]
+  ): Int = {
+    val tempDir = TestUtils.tempDir()
+    try {
+      val arguments = ListBuffer[String]("feature-dependencies")
+      features.foreach(feature => {
+        arguments += "--feature"
+        arguments += feature
+      })
+      StorageTool.execute(arguments.toArray, new PrintStream(stream))
+    } finally {
+      Utils.delete(tempDir)
+    }
+  }
+
+  @Test
+  def testHandleFeatureDependenciesForFeatureWithDependencies(): Unit = {
+    val stream = new ByteArrayOutputStream()
+    assertEquals(0, runFeatureDependenciesCommand(stream, Seq("test.feature.version=2")))
+
+    val output = stream.toString
+    val metadataVersion = MetadataVersion.latestTesting()
+
+    val expectedOutput = s"test.feature.version=2 requires:\n    metadata.version=${metadataVersion.featureLevel()} (${metadataVersion.version()})\n"
+    assertEquals(expectedOutput.trim, output.trim)
+  }
+
+  @Test
+  def testMultipleFeatureDependencies(): Unit = {
+    val stream = new ByteArrayOutputStream()
+    val features = Seq("transaction.version=2", "group.version=1", "test.feature.version=2")
+
+    assertEquals(0, runFeatureDependenciesCommand(stream, features))
+
+    val output = stream.toString.trim
+    System.out.println(output)
+
+    val latestTestingVersion = MetadataVersion.latestTesting()
+    val latestTestingVersionString = s"metadata.version=${latestTestingVersion.featureLevel()} (${latestTestingVersion.version()})"
+
+    val expectedOutput =
+      s"""transaction.version=2 has no dependencies.
+         |group.version=1 has no dependencies.
+         |test.feature.version=2 requires:
+         |    $latestTestingVersionString
+         |""".stripMargin.trim
+
+    assertEquals(expectedOutput, output)
+  }
+
+  @Test
+  def testHandleFeatureDependenciesForFeatureWithNoDependencies(): Unit = {
+    val stream = new ByteArrayOutputStream()
+    assertEquals(0, runFeatureDependenciesCommand(stream, Seq("metadata.version=17")))
+
+    val output = stream.toString.trim
+
+    assertEquals("metadata.version=17 (3.7-IV2) has no dependencies.", output)
+  }
+
+  @Test
+  def testHandleFeatureDependenciesForUnknownFeature(): Unit = {
+    val stream = new ByteArrayOutputStream()
+    val exception = assertThrows(classOf[TerseFailure], () => {
+      runFeatureDependenciesCommand(stream, Seq("unknown.feature.version=1"))
+    })
+
+    assertEquals("Unknown feature: unknown.feature.version", exception.getMessage)
+  }
+
+  @Test
+  def testHandleFeatureDependenciesForFeatureWithUnknownFeatureVersion(): Unit = {
+    val stream = new ByteArrayOutputStream()
+    val exception = assertThrows(classOf[TerseFailure], () => {
+      runFeatureDependenciesCommand(stream, Seq("transaction.version=1000"))
+    })
+
+    assertEquals("Feature level 1000 is not supported for feature transaction.version", exception.getMessage)
+  }
+
+  @Test
+  def testHandleFeatureDependenciesForInvalidVersionFormat(): Unit = {
+    val stream = new ByteArrayOutputStream()
+
+    val exception = assertThrows(classOf[TerseFailure], () => {
+      runFeatureDependenciesCommand(stream, Seq("metadata.version=invalid"))
+    })
+
+    assertEquals("Invalid version format: invalid for feature metadata.version", exception.getMessage)
+  }
 }
diff --git a/tools/src/main/java/org/apache/kafka/tools/FeatureCommand.java b/tools/src/main/java/org/apache/kafka/tools/FeatureCommand.java
index d815851c6e..a78d04ca17 100644
--- a/tools/src/main/java/org/apache/kafka/tools/FeatureCommand.java
+++ b/tools/src/main/java/org/apache/kafka/tools/FeatureCommand.java
@@ -24,6 +24,7 @@ import org.apache.kafka.clients.admin.UpdateFeaturesOptions;
 import org.apache.kafka.clients.admin.UpdateFeaturesResult;
 import org.apache.kafka.common.utils.Exit;
 import org.apache.kafka.common.utils.Utils;
+import org.apache.kafka.server.common.FeatureVersion;
 import org.apache.kafka.server.common.Features;
 import org.apache.kafka.server.common.MetadataVersion;
 import org.apache.kafka.server.util.CommandLineUtils;
@@ -91,6 +92,7 @@ public class FeatureCommand {
         addDowngradeParser(subparsers);
         addDisableParser(subparsers);
         addVersionMappingParser(subparsers);
+        addFeatureDependenciesParser(subparsers);
 
         Namespace namespace = parser.parseArgsOrFail(args);
         String command = namespace.getString("command");
@@ -118,6 +120,9 @@ public class FeatureCommand {
                 case "version-mapping":
                     handleVersionMapping(namespace);
                     break;
+                case "feature-dependencies":
+                    handleFeatureDependencies(namespace);
+                    break;
                 default:
                     throw new TerseException("Unknown command " + command);
             }
@@ -187,6 +192,20 @@ public class FeatureCommand {
                 .action(store());
     }
 
+    private static void addFeatureDependenciesParser(Subparsers subparsers) {
+        Subparser featureDependenciesParser = subparsers.addParser("feature-dependencies")
+                .help("Look up dependencies for a given feature version. " +
+                        "If the feature is not known or the version not yet defined, an error is thrown. " +
+                        "Multiple features can be specified."
+                );
+        featureDependenciesParser.addArgument("--feature")
+                .help("The feature and version to look up dependencies for, in feature=version format. " +
+                        "For example: `metadata.version=5`."
+                )
+                .required(true)
+                .action(append());
+    }
+
     static String levelToString(String feature, short level) {
         if (feature.equals(MetadataVersion.FEATURE_NAME)) {
             try {
@@ -260,7 +279,7 @@ public class FeatureCommand {
             try {
                 version = MetadataVersion.fromVersionString(metadata);
             } catch (Throwable e) {
-                throw new TerseException("Unsupported metadata.version " + metadata +
+                throw new TerseException("Unknown metadata.version " + metadata +
                         ". Supported metadata.version are " + metadataVersionsToString(
                         MetadataVersion.MINIMUM_BOOTSTRAP_VERSION, MetadataVersion.latestProduction()));
             }
@@ -314,12 +333,60 @@ public class FeatureCommand {
                 System.out.printf("%s=%d%n", feature.featureName(), featureLevel);
             }
         } catch (IllegalArgumentException e) {
-            throw new TerseException("Unsupported release version '" + releaseVersion + "'." +
+            throw new TerseException("Unknown release version '" + releaseVersion + "'." +
                 " Supported versions are: " + MetadataVersion.MINIMUM_BOOTSTRAP_VERSION +
                 " to " + MetadataVersion.LATEST_PRODUCTION);
         }
     }
 
+    static void handleFeatureDependencies(Namespace namespace) throws TerseException {
+        List<String> featureArgs = namespace.getList("feature");
+
+        // Iterate over each feature specified with --feature
+        if (featureArgs != null) {
+            for (String feature : featureArgs) {
+                String[] nameAndLevel = parseNameAndLevel(feature);
+
+                String featureName = nameAndLevel[0];
+                short featureLevel = Short.parseShort(nameAndLevel[1]);
+
+                if (featureName.equals(MetadataVersion.FEATURE_NAME)) {
+                    MetadataVersion metadataVersion;
+                    try {
+                        metadataVersion = MetadataVersion.fromFeatureLevel(featureLevel);
+                    } catch (IllegalArgumentException e) {
+                        throw new TerseException("Unknown metadata.version " + featureLevel);
+                    }
+
+                    // Assuming metadata versions do not have dependencies.
+                    System.out.printf("%s=%d (%s) has no dependencies.%n", featureName, featureLevel, metadataVersion.version());
+                } else {
+                    Features featureEnum = Arrays.stream(Features.FEATURES)
+                            .filter(f -> f.featureName().equals(featureName))
+                            .findFirst()
+                            .orElseThrow(() -> new TerseException("Unknown feature: " + featureName));
+
+                    FeatureVersion featureVersion = featureEnum.fromFeatureLevel(featureLevel, true);
+                    Map<String, Short> dependencies = featureVersion.dependencies();
+
+                    if (dependencies.isEmpty()) {
+                        System.out.printf("%s=%d has no dependencies.%n", featureName, featureLevel);
+                    } else {
+                        System.out.printf("%s=%d requires:%n", featureName, featureLevel);
+                        dependencies.forEach((depFeature, depLevel) -> {
+                            if (depFeature.equals(MetadataVersion.FEATURE_NAME)) {
+                                MetadataVersion depMetadataVersion = MetadataVersion.fromFeatureLevel(depLevel);
+                                System.out.printf("    %s=%d (%s)%n", depFeature, depLevel, depMetadataVersion.version());
+                            } else {
+                                System.out.printf("    %s=%d%n", depFeature, depLevel);
+                            }
+                        });
+                    }
+                }
+            }
+        }
+    }
+
     private static void update(String op, Admin admin, Map<String, FeatureUpdate> updates, Boolean dryRun) throws TerseException {
         if (updates.isEmpty()) {
             throw new TerseException("You must specify at least one feature to " + op);
diff --git a/tools/src/test/java/org/apache/kafka/tools/FeatureCommandTest.java b/tools/src/test/java/org/apache/kafka/tools/FeatureCommandTest.java
index 7e4e36cbf9..bdff4de775 100644
--- a/tools/src/test/java/org/apache/kafka/tools/FeatureCommandTest.java
+++ b/tools/src/test/java/org/apache/kafka/tools/FeatureCommandTest.java
@@ -363,7 +363,7 @@ public class FeatureCommandTest {
                 throw new RuntimeException(e);
             }
         });
-        
+
         MetadataVersion metadataVersion = MetadataVersion.latestProduction();
 
         // Check that the metadata version is correctly included in the output
@@ -386,7 +386,7 @@ public class FeatureCommandTest {
             FeatureCommand.handleVersionMapping(new Namespace(namespace))
         );
 
-        assertEquals("Unsupported release version '2.9-IV2'." +
+        assertEquals("Unknown release version '2.9-IV2'." +
             " Supported versions are: " + MetadataVersion.MINIMUM_BOOTSTRAP_VERSION +
             " to " + MetadataVersion.LATEST_PRODUCTION, exception1.getMessage());
 
@@ -396,8 +396,121 @@ public class FeatureCommandTest {
             FeatureCommand.handleVersionMapping(new Namespace(namespace))
         );
 
-        assertEquals("Unsupported release version 'invalid'." +
+        assertEquals("Unknown release version 'invalid'." +
             " Supported versions are: " + MetadataVersion.MINIMUM_BOOTSTRAP_VERSION +
             " to " + MetadataVersion.LATEST_PRODUCTION, exception2.getMessage());
     }
+
+    @Test
+    public void testHandleFeatureDependenciesForFeatureWithDependencies() {
+        Map<String, Object> namespace = new HashMap<>();
+        namespace.put("feature", Collections.singletonList("test.feature.version=2"));
+
+        String output = ToolsTestUtils.captureStandardOut(() -> {
+            try {
+                FeatureCommand.handleFeatureDependencies(new Namespace(namespace));
+            } catch (TerseException e) {
+                throw new RuntimeException(e);
+            }
+        });
+
+        String expectedOutput = String.format(
+            "test.feature.version=2 requires:\n    metadata.version=%d (%s)\n",
+            MetadataVersion.latestTesting().featureLevel(),
+            MetadataVersion.latestTesting().version()
+        );
+
+        assertEquals(expectedOutput.trim(), output.trim());
+    }
+
+    @Test
+    public void testHandleFeatureDependenciesForFeatureWithNoDependencies() {
+        Map<String, Object> namespace = new HashMap<>();
+        namespace.put("feature", Collections.singletonList("metadata.version=17"));
+
+        String output = ToolsTestUtils.captureStandardOut(() -> {
+            try {
+                FeatureCommand.handleFeatureDependencies(new Namespace(namespace));
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        });
+
+        assertEquals("metadata.version=17 (3.7-IV2) has no dependencies.", output);
+    }
+
+    @Test
+    public void testHandleFeatureDependenciesForUnknownFeature() {
+        Map<String, Object> namespace = new HashMap<>();
+        namespace.put("feature", Collections.singletonList("unknown.feature=1"));
+
+        Exception exception = assertThrows(
+            TerseException.class,
+            () -> FeatureCommand.handleFeatureDependencies(new Namespace(namespace)
+            ));
+
+        assertEquals("Unknown feature: unknown.feature", exception.getMessage());
+    }
+
+    @Test
+    public void testHandleFeatureDependenciesForFeatureWithUnknownFeatureVersion() {
+        Map<String, Object> namespace = new HashMap<>();
+        namespace.put("feature", Collections.singletonList("transaction.version=1000"));
+
+        Exception exception = assertThrows(
+            IllegalArgumentException.class,
+            () -> FeatureCommand.handleFeatureDependencies(new Namespace(namespace)
+            ));
+
+        assertEquals("No feature:transaction.version with feature level 1000", exception.getMessage());
+    }
+
+    @Test
+    public void testHandleFeatureDependenciesForInvalidVersionFormat() {
+        Map<String, Object> namespace = new HashMap<>();
+        namespace.put("feature", Collections.singletonList("metadata.version=invalid"));
+
+        RuntimeException exception = assertThrows(
+            RuntimeException.class,
+            () -> FeatureCommand.handleFeatureDependencies(new Namespace(namespace))
+        );
+
+        assertEquals(
+            "Can't parse feature=level string metadata.version=invalid: unable to parse invalid as a short.",
+            exception.getMessage()
+        );
+    }
+
+    @Test
+    public void testHandleFeatureDependenciesForMultipleFeatures() {
+        Map<String, Object> namespace = new HashMap<>();
+        namespace.put("feature", Arrays.asList(
+                "transaction.version=2",
+                "group.version=1",
+                "test.feature.version=2"
+        ));
+
+        String output = ToolsTestUtils.captureStandardOut(() -> {
+            try {
+                FeatureCommand.handleFeatureDependencies(new Namespace(namespace));
+            } catch (TerseException e) {
+                throw new RuntimeException(e);
+            }
+        });
+
+        // Expected output for test.feature.version=2 dependencies
+        String latestTestingVersionOutput = String.format(
+                "test.feature.version=2 requires:\n    metadata.version=%d (%s)\n",
+                MetadataVersion.latestTesting().featureLevel(),
+                MetadataVersion.latestTesting().version()
+        );
+
+        String expectedOutput = String.join("\n",
+                "transaction.version=2 has no dependencies.",
+                "group.version=1 has no dependencies.",
+                latestTestingVersionOutput.trim()
+        );
+
+        assertEquals(expectedOutput.trim(), output.trim());
+    }
 }
