diff --git a/clients/src/main/java/org/apache/kafka/common/network/Selector.java b/clients/src/main/java/org/apache/kafka/common/network/Selector.java
index dc7534a4de..c3b4888339 100644
--- a/clients/src/main/java/org/apache/kafka/common/network/Selector.java
+++ b/clients/src/main/java/org/apache/kafka/common/network/Selector.java
@@ -601,7 +601,7 @@ public class Selector implements Selectable, AutoCloseable {
                     close(channel, CloseMode.GRACEFUL);
 
             } catch (Exception e) {
-                String desc = channel.socketDescription();
+                String desc = String.format("%s (channelId=%s)", channel.socketDescription(), channel.id());
                 if (e instanceof IOException) {
                     log.debug("Connection with {} disconnected", desc, e);
                 } else if (e instanceof AuthenticationException) {
diff --git a/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java b/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java
index b9879ad6da..893fd6a4ec 100644
--- a/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java
+++ b/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java
@@ -300,6 +300,9 @@ public class SslTransportLayer implements TransportLayer {
             // in the socket channel to read and unwrap, process the data so that any SSL handshake exceptions are reported.
             try {
                 do {
+                    log.trace("Process any available bytes from peer, netReadBuffer {} netWriterBuffer {} handshakeStatus {} readable? {}",
+                        netReadBuffer, netWriteBuffer, handshakeStatus, readable);
+                    handshakeWrapAfterFailure(false);
                     handshakeUnwrap(false, true);
                 } while (readable && readFromSocketChannel() > 0);
             } catch (SSLException e1) {
@@ -475,9 +478,13 @@ public class SslTransportLayer implements TransportLayer {
         //this should never be called with a network buffer that contains data
         //so we can clear it here.
         netWriteBuffer.clear();
-        SSLEngineResult result = sslEngine.wrap(ByteUtils.EMPTY_BUF, netWriteBuffer);
-        //prepare the results to be written
-        netWriteBuffer.flip();
+        SSLEngineResult result;
+        try {
+            result = sslEngine.wrap(ByteUtils.EMPTY_BUF, netWriteBuffer);
+        } finally {
+            //prepare the results to be written
+            netWriteBuffer.flip();
+        }
         handshakeStatus = result.getHandshakeStatus();
         if (result.getStatus() == SSLEngineResult.Status.OK &&
             result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {
@@ -866,6 +873,7 @@ public class SslTransportLayer implements TransportLayer {
      */
     private void handshakeFailure(SSLException sslException, boolean flush) throws IOException {
         //Release all resources such as internal buffers that SSLEngine is managing
+        log.debug("SSL Handshake failed", sslException);
         sslEngine.closeOutbound();
         try {
             sslEngine.closeInbound();
@@ -879,13 +887,10 @@ public class SslTransportLayer implements TransportLayer {
         // Attempt to flush any outgoing bytes. If flush doesn't complete, delay exception handling until outgoing bytes
         // are flushed. If write fails because remote end has closed the channel, log the I/O exception and  continue to
         // handle the handshake failure as an authentication exception.
-        try {
-            if (!flush || flush(netWriteBuffer))
-                throw handshakeException;
-        } catch (IOException e) {
-            log.debug("Failed to flush all bytes before closing channel", e);
+        if (!flush || handshakeWrapAfterFailure(flush))
             throw handshakeException;
-        }
+        else
+            log.debug("Delay propagation of handshake exception till {} bytes remaining are flushed", netWriteBuffer.remaining());
     }
 
     // SSL handshake failures are typically thrown as SSLHandshakeException, SSLProtocolException,
@@ -921,6 +926,42 @@ public class SslTransportLayer implements TransportLayer {
             throw handshakeException;
     }
 
+    /**
+     * Perform handshake wrap after an SSLException or any IOException.
+     *
+     * If `doWrite=false`, we are processing IOException after peer has disconnected, so we
+     * cannot send any more data. We perform any pending wraps so that we can unwrap any
+     * peer data that is already available.
+     *
+     * If `doWrite=true`, we are processing SSLException, we perform wrap and flush
+     * any data to notify the peer of the handshake failure.
+     *
+     * Returns true if no more wrap is required and any data is flushed or discarded.
+     */
+    private boolean handshakeWrapAfterFailure(boolean doWrite) {
+        try {
+            log.trace("handshakeWrapAfterFailure status {} doWrite {}", handshakeStatus, doWrite);
+            while (handshakeStatus == HandshakeStatus.NEED_WRAP && (!doWrite || flush(netWriteBuffer))) {
+                if (!doWrite)
+                    clearWriteBuffer();
+                handshakeWrap(doWrite);
+            }
+        } catch (Exception e) {
+            log.debug("Failed to wrap and flush all bytes before closing channel", e);
+            clearWriteBuffer();
+        }
+        if (!doWrite)
+            clearWriteBuffer();
+        return !netWriteBuffer.hasRemaining();
+    }
+
+    private void clearWriteBuffer() {
+        if (netWriteBuffer.hasRemaining())
+            log.debug("Discarding write buffer {} since peer has disconnected", netWriteBuffer);
+        netWriteBuffer.position(0);
+        netWriteBuffer.limit(0);
+    }
+
     @Override
     public boolean isMute() {
         return key.isValid() && (key.interestOps() & SelectionKey.OP_READ) == 0;
diff --git a/clients/src/test/java/org/apache/kafka/common/network/NetworkTestUtils.java b/clients/src/test/java/org/apache/kafka/common/network/NetworkTestUtils.java
index 4f53845146..002d76ffe0 100644
--- a/clients/src/test/java/org/apache/kafka/common/network/NetworkTestUtils.java
+++ b/clients/src/test/java/org/apache/kafka/common/network/NetworkTestUtils.java
@@ -96,10 +96,16 @@ public class NetworkTestUtils {
         assertTrue(selector.isChannelReady(node));
     }
 
-    public static ChannelState waitForChannelClose(Selector selector, String node, ChannelState.State channelState)
+    public static ChannelState waitForChannelClose(Selector selector, String node, ChannelState.State channelState) throws IOException {
+        return waitForChannelClose(selector, node, channelState, 0);
+    }
+
+    public static ChannelState waitForChannelClose(Selector selector, String node, ChannelState.State channelState, int delayBetweenPollMs)
             throws IOException {
         boolean closed = false;
         for (int i = 0; i < 300; i++) {
+            if (delayBetweenPollMs > 0)
+                Utils.sleep(delayBetweenPollMs);
             selector.poll(100L);
             if (selector.channel(node) == null && selector.closingChannel(node) == null) {
                 closed = true;
diff --git a/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java b/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java
index 17a8d796a7..5b0d4172d8 100644
--- a/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java
+++ b/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java
@@ -917,7 +917,7 @@ public class SslTransportLayerTest {
 
         // Test without delay and a couple of delay counts to ensure delay applies to handshake failure
         for (int i = 0; i < 3; i++) {
-            String node = "0";
+            String node = String.valueOf(i);
             TestSslChannelBuilder serverChannelBuilder = new TestSslChannelBuilder(Mode.SERVER);
             serverChannelBuilder.configure(args.sslServerConfigs);
             serverChannelBuilder.flushDelayCount = i;
@@ -936,6 +936,14 @@ public class SslTransportLayerTest {
         }
     }
 
+    @ParameterizedTest
+    @ArgumentsSource(SslTransportLayerArgumentsProvider.class)
+    public void testPeerNotifiedOfHandshakeFailureWithClientSideDelay(Args args) throws Exception {
+        args.sslServerConfigs.put(BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG, "required");
+        CertStores.KEYSTORE_PROPS.forEach(args.sslClientConfigs::remove);
+        verifySslConfigsWithHandshakeFailure(args, 1);
+    }
+
     @ParameterizedTest
     @ArgumentsSource(SslTransportLayerArgumentsProvider.class)
     public void testCloseSsl(Args args) throws Exception {
@@ -1299,12 +1307,16 @@ public class SslTransportLayerTest {
     }
 
     private void verifySslConfigsWithHandshakeFailure(Args args) throws Exception {
+        verifySslConfigsWithHandshakeFailure(args, 0);
+    }
+
+    private void verifySslConfigsWithHandshakeFailure(Args args, int pollDelayMs) throws Exception {
         server = createEchoServer(args, SecurityProtocol.SSL);
         createSelector(args.sslClientConfigs);
         InetSocketAddress addr = new InetSocketAddress("localhost", server.port());
         String node = "0";
         selector.connect(node, addr, BUFFER_SIZE, BUFFER_SIZE);
-        NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);
+        NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED, pollDelayMs);
         server.verifyAuthenticationMetrics(0, 1);
     }
 
@@ -1418,6 +1430,8 @@ public class SslTransportLayerTest {
 
             @Override
             protected boolean flush(ByteBuffer buf) throws IOException {
+                if (!buf.hasRemaining())
+                    return super.flush(buf);
                 if (numFlushesRemaining.decrementAndGet() == 0 && !ready())
                     flushFailureAction.run();
                 else if (numDelayedFlushesRemaining.getAndDecrement() != 0)
