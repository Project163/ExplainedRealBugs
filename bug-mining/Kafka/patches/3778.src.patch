diff --git a/core/src/main/scala/kafka/network/SocketServer.scala b/core/src/main/scala/kafka/network/SocketServer.scala
index 8ef05f8027..dd8213dc85 100644
--- a/core/src/main/scala/kafka/network/SocketServer.scala
+++ b/core/src/main/scala/kafka/network/SocketServer.scala
@@ -617,7 +617,7 @@ private[kafka] abstract class Acceptor(val socketServer: SocketServer,
   private val blockedPercentMeter = metricsGroup.newMeter(blockedPercentMeterMetricName,"blocked time", TimeUnit.NANOSECONDS)
   private var currentProcessorIndex = 0
   private[network] val throttledSockets = new mutable.PriorityQueue[DelayedCloseSocket]()
-  private var started = false
+  private val started = new AtomicBoolean()
   private[network] val startedFuture = new CompletableFuture[Void]()
 
   val thread: KafkaThread = KafkaThread.nonDaemon(
@@ -638,7 +638,7 @@ private[kafka] abstract class Acceptor(val socketServer: SocketServer,
       debug(s"Starting acceptor thread for listener ${endPoint.listenerName}")
       thread.start()
       startedFuture.complete(null)
-      started = true
+      started.set(true)
     } catch {
       case e: ClosedChannelException =>
         debug(s"Refusing to start acceptor for ${endPoint.listenerName} since the acceptor has already been shut down.")
@@ -675,6 +675,9 @@ private[kafka] abstract class Acceptor(val socketServer: SocketServer,
   def close(): Unit = {
     beginShutdown()
     thread.join()
+    if (!started.get) {
+      closeAll()
+    }
     synchronized {
       processors.foreach(_.close())
     }
@@ -700,14 +703,18 @@ private[kafka] abstract class Acceptor(val socketServer: SocketServer,
         }
       }
     } finally {
-      debug("Closing server socket, selector, and any throttled sockets.")
-      CoreUtils.swallow(serverChannel.close(), this, Level.ERROR)
-      CoreUtils.swallow(nioSelector.close(), this, Level.ERROR)
-      throttledSockets.foreach(throttledSocket => closeSocket(throttledSocket.socket, this))
-      throttledSockets.clear()
+      closeAll()
     }
   }
 
+  private def closeAll(): Unit = {
+    debug("Closing server socket, selector, and any throttled sockets.")
+    CoreUtils.swallow(serverChannel.close(), this, Level.ERROR)
+    CoreUtils.swallow(nioSelector.close(), this, Level.ERROR)
+    throttledSockets.foreach(throttledSocket => closeSocket(throttledSocket.socket, this))
+    throttledSockets.clear()
+  }
+
   /**
    * Create a server socket to listen for connections on.
    */
@@ -846,7 +853,7 @@ private[kafka] abstract class Acceptor(val socketServer: SocketServer,
       listenerProcessors += processor
       requestChannel.addProcessor(processor)
 
-      if (started) {
+      if (started.get) {
         processor.start()
       }
     }
@@ -916,6 +923,7 @@ private[kafka] class Processor(
   private val metricsGroup = new KafkaMetricsGroup(this.getClass)
 
   val shouldRun: AtomicBoolean = new AtomicBoolean(true)
+  private val started: AtomicBoolean = new AtomicBoolean()
 
   val thread: KafkaThread = KafkaThread.nonDaemon(threadName, this)
 
@@ -1352,7 +1360,11 @@ private[kafka] class Processor(
   private[network] def channel(connectionId: String): Option[KafkaChannel] =
     Option(selector.channel(connectionId))
 
-  def start(): Unit = thread.start()
+  def start(): Unit = {
+    if (!started.getAndSet(true)) {
+      thread.start()
+    }
+  }
 
   /**
    * Wakeup the thread for selection.
@@ -1369,6 +1381,9 @@ private[kafka] class Processor(
     try {
       beginShutdown()
       thread.join()
+      if (!started.get) {
+        CoreUtils.swallow(closeAll(), this, Level.ERROR)
+      }
     } finally {
       metricsGroup.removeMetric("IdlePercent", Map("networkProcessor" -> id.toString).asJava)
       metrics.removeMetric(expiredConnectionsKilledCountMetricName)
diff --git a/core/src/test/scala/unit/kafka/network/SocketServerTest.scala b/core/src/test/scala/unit/kafka/network/SocketServerTest.scala
index 445e9ba612..ac8307bdf7 100644
--- a/core/src/test/scala/unit/kafka/network/SocketServerTest.scala
+++ b/core/src/test/scala/unit/kafka/network/SocketServerTest.scala
@@ -1207,6 +1207,17 @@ class SocketServerTest {
     }
   }
 
+  @Test
+  def testServerShutdownWithoutEnable(): Unit = {
+    // The harness server has already been enabled, so it's invalid for this test.
+    shutdownServerAndMetrics(server)
+    val props = TestUtils.createBrokerConfig(0, TestUtils.MockZkConnect, port = 0)
+    val overrideServer = new TestableSocketServer(KafkaConfig.fromProps(props))
+    overrideServer.shutdown()
+    assertFalse(overrideServer.testableAcceptor.isOpen)
+    overrideServer.testableSelector.waitForOperations(SelectorOperation.CloseSelector, 1)
+  }
+
   @Test
   def testClientDisconnectionWithOutstandingReceivesProcessedUntilFailedSend(): Unit = {
     shutdownServerAndMetrics(server)
@@ -2137,6 +2148,8 @@ class SocketServerTest {
     override def newProcessor(id: Int, listenerName: ListenerName, securityProtocol: SecurityProtocol): Processor = {
       new TestableProcessor(id, time, requestChannel, listenerName, securityProtocol, cfg, connectionQuotas, connectionQueueSize, isPrivilegedListener)
     }
+
+    def isOpen: Boolean = serverChannel.isOpen
   }
 
   class TestableProcessor(id: Int, time: Time, requestChannel: RequestChannel, listenerName: ListenerName, securityProtocol: SecurityProtocol, config: KafkaConfig, connectionQuotas: ConnectionQuotas, connectionQueueSize: Int, isPrivilegedListener: Boolean)
@@ -2204,9 +2217,12 @@ class SocketServerTest {
     def testableSelector: TestableSelector =
       testableProcessor.selector.asInstanceOf[TestableSelector]
 
-    def testableProcessor: TestableProcessor = {
+    def testableProcessor: TestableProcessor =
+      testableAcceptor.processors(0).asInstanceOf[TestableProcessor]
+
+    def testableAcceptor: TestableAcceptor = {
       val endpoint = this.config.dataPlaneListeners.head
-      dataPlaneAcceptors.get(endpoint).processors(0).asInstanceOf[TestableProcessor]
+      dataPlaneAcceptors.get(endpoint).asInstanceOf[TestableAcceptor]
     }
 
     def waitForChannelClose(connectionId: String, locallyClosed: Boolean): Unit = {
