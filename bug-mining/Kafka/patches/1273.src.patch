diff --git a/core/src/main/scala/kafka/controller/KafkaController.scala b/core/src/main/scala/kafka/controller/KafkaController.scala
index 7ec38eec34..1f6e19a2c9 100755
--- a/core/src/main/scala/kafka/controller/KafkaController.scala
+++ b/core/src/main/scala/kafka/controller/KafkaController.scala
@@ -316,29 +316,32 @@ class KafkaController(val config : KafkaConfig, zkUtils: ZkUtils, val brokerStat
   def onControllerFailover() {
     if(isRunning) {
       info("Broker %d starting become controller state transition".format(config.brokerId))
-      //read controller epoch from zk
       readControllerEpochFromZookeeper()
-      // increment the controller epoch
       incrementControllerEpoch(zkUtils.zkClient)
+
       // before reading source of truth from zookeeper, register the listeners to get broker/topic callbacks
       registerReassignedPartitionsListener()
       registerIsrChangeNotificationListener()
       registerPreferredReplicaElectionListener()
       partitionStateMachine.registerListeners()
       replicaStateMachine.registerListeners()
+
       initializeControllerContext()
-      // We need to send MetadataUpdateRequest after controller context is initialized and before state machines are started.
-      // This is because broker needs to receive the list of live brokers from MetadataUpdateRequest first in order to process
-      // any LeaderAndIsrRequest that is generated by replicaStateMachine.startup() and partitionStateMachine.startup().
+
+      // We need to send UpdateMetadataRequest after the controller context is initialized and before the state machines
+      // are started. The is because brokers need to receive the list of live brokers from UpdateMetadataRequest before
+      // they can process the LeaderAndIsrRequests that are generated by replicaStateMachine.startup() and
+      // partitionStateMachine.startup().
       sendUpdateMetadataRequest(controllerContext.liveOrShuttingDownBrokerIds.toSeq)
+
       replicaStateMachine.startup()
       partitionStateMachine.startup()
+
       // register the partition change listeners for all existing topics on failover
       controllerContext.allTopics.foreach(topic => partitionStateMachine.registerPartitionChangeListener(topic))
       info("Broker %d is ready to serve as the new controller with epoch %d".format(config.brokerId, epoch))
       maybeTriggerPartitionReassignment()
       maybeTriggerPreferredReplicaElection()
-      /* send partition leadership info to all live brokers */
       if (config.autoLeaderRebalanceEnable) {
         info("starting the partition rebalance scheduler")
         autoRebalanceScheduler.startup()
