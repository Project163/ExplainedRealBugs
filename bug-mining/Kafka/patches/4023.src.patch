diff --git a/connect/mirror/src/main/java/org/apache/kafka/connect/mirror/MirrorCheckpointConnector.java b/connect/mirror/src/main/java/org/apache/kafka/connect/mirror/MirrorCheckpointConnector.java
index 0af3b14e3b..218c64e85a 100644
--- a/connect/mirror/src/main/java/org/apache/kafka/connect/mirror/MirrorCheckpointConnector.java
+++ b/connect/mirror/src/main/java/org/apache/kafka/connect/mirror/MirrorCheckpointConnector.java
@@ -132,6 +132,12 @@ public class MirrorCheckpointConnector extends SourceConnector {
     // divide consumer groups among tasks
     @Override
     public List<Map<String, String>> taskConfigs(int maxTasks) {
+        // If the replication is disabled or checkpoint emission is disabled by setting 'emit.checkpoints.enabled' to false,
+        // the interval of checkpoint emission will be negative and no 'MirrorCheckpointTask' will be created.
+        if (!config.enabled() || config.emitCheckpointsInterval().isNegative()) {
+            return Collections.emptyList();
+        }
+
         if (knownConsumerGroups == null) {
             // If knownConsumerGroup is null, it means the initial loading has not finished.
             // An exception should be thrown to trigger the retry behavior in the framework.
@@ -139,13 +145,11 @@ public class MirrorCheckpointConnector extends SourceConnector {
             throw new RetriableException("Timeout while loading consumer groups.");
         }
 
-        // if the replication is disabled, known consumer group is empty, or checkpoint emission is
-        // disabled by setting 'emit.checkpoints.enabled' to false, the interval of checkpoint emission
-        // will be negative and no 'MirrorCheckpointTask' will be created
-        if (!config.enabled() || knownConsumerGroups.isEmpty()
-                || config.emitCheckpointsInterval().isNegative()) {
+        // If the consumer group is empty, no 'MirrorCheckpointTask' will be created.
+        if (knownConsumerGroups.isEmpty()) {
             return Collections.emptyList();
         }
+
         int numTasks = Math.min(maxTasks, knownConsumerGroups.size());
         List<List<String>> groupsPartitioned = ConnectorUtils.groupPartitions(new ArrayList<>(knownConsumerGroups), numTasks);
         return IntStream.range(0, numTasks)
