diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
index 429c0c1bb5..974e7c52eb 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AsyncKafkaConsumer.java
@@ -1623,6 +1623,12 @@ public class AsyncKafkaConsumer<K, V> implements ConsumerDelegate<K, V> {
             // If there are partitions still needing a position and a reset policy is defined,
             // request reset using the default policy. If no reset strategy is defined and there
             // are partitions with a missing position, then we will raise a NoOffsetForPartitionException exception.
+            //
+            // Note: this will *not* initialize the position for any partitions that are in the process
+            // of being assigned and awaiting ConsumerRebalanceListener callbacks. We don't want to reset
+            // positions until the partition has been fully assigned *and* we want to wait until
+            // initWithCommittedOffsetsIfNeeded has had a chance to look up the partition's committed
+            // offset, if applicable.
             subscriptions.resetInitializingPositions();
 
             // Reset positions using partition offsets retrieved from the leader, for any partitions
diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java
index 255b7585b5..6fe0616dbc 100644
--- a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java
@@ -20,6 +20,7 @@ import org.apache.kafka.clients.ApiVersions;
 import org.apache.kafka.clients.Metadata;
 import org.apache.kafka.clients.NodeApiVersions;
 import org.apache.kafka.clients.consumer.ConsumerRebalanceListener;
+import org.apache.kafka.clients.consumer.KafkaConsumer;
 import org.apache.kafka.clients.consumer.NoOffsetForPartitionException;
 import org.apache.kafka.clients.consumer.OffsetAndMetadata;
 import org.apache.kafka.clients.consumer.OffsetResetStrategy;
@@ -30,6 +31,7 @@ import org.apache.kafka.common.message.OffsetForLeaderEpochResponseData.EpochEnd
 import org.apache.kafka.common.utils.LogContext;
 import org.slf4j.Logger;
 
+import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -746,7 +748,7 @@ public class SubscriptionState {
     }
 
     public synchronized Set<TopicPartition> initializingPartitions() {
-        return collectPartitions(state -> state.fetchState.equals(FetchStates.INITIALIZING) && !state.pendingOnAssignedCallback);
+        return collectPartitions(TopicPartitionState::shouldInitialize);
     }
 
     private Set<TopicPartition> collectPartitions(Predicate<TopicPartitionState> filter) {
@@ -759,11 +761,22 @@ public class SubscriptionState {
         return result;
     }
 
-
+    /**
+     * Note: this will not attempt to reset partitions that are in the process of being assigned
+     * and are pending the completion of any {@link ConsumerRebalanceListener#onPartitionsAssigned(Collection)}
+     * callbacks.
+     *
+     * <p/>
+     *
+     * This method only appears to be invoked the by the {@link KafkaConsumer} during its
+     * {@link KafkaConsumer#poll(Duration)} logic. <em>Direct</em> calls to methods like
+     * {@link #requestOffsetReset(TopicPartition)}, {@link #requestOffsetResetIfPartitionAssigned(TopicPartition)},
+     * etc. do <em>not</em> skip partitions pending assignment.
+     */
     public synchronized void resetInitializingPositions() {
         final Set<TopicPartition> partitionsWithNoOffsets = new HashSet<>();
         assignment.forEach((tp, partitionState) -> {
-            if (partitionState.fetchState.equals(FetchStates.INITIALIZING)) {
+            if (partitionState.shouldInitialize()) {
                 if (defaultResetStrategy == OffsetResetStrategy.NONE)
                     partitionsWithNoOffsets.add(tp);
                 else
@@ -1086,6 +1099,16 @@ public class SubscriptionState {
             this.paused = false;
         }
 
+        /**
+         * Only partitions that are {@link FetchStates#INITIALIZING initializing} <em>and not</em>
+         * {@link #pendingOnAssignedCallback pending} the completion of the
+         * {@link ConsumerRebalanceListener#onPartitionsAssigned(Collection) onPartitionsAssigned} callback
+         * should be considered as initialize-able.
+         */
+        private boolean shouldInitialize() {
+            return fetchState.equals(FetchStates.INITIALIZING) && !pendingOnAssignedCallback;
+        }
+
         private boolean isFetchable() {
             return !paused && !pendingRevocation && !pendingOnAssignedCallback && hasValidPosition();
         }
diff --git a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java
index e54bb36e17..f1bb163f3c 100644
--- a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/SubscriptionStateTest.java
@@ -967,4 +967,39 @@ public class SubscriptionStateTest {
 
         assertThrows(IllegalStateException.class, () -> state.isOffsetResetNeeded(unassignedPartition));
     }
+
+    /**
+     * This test checks that we will not attempt to prematurely reset position of partitions that are pending.
+     *
+     * See KAFKA-16556.
+     */
+    @Test
+    public void testPendingPartitionsDoNotResetPositions() {
+        Optional<ConsumerRebalanceListener> listener = Optional.of(new CounterConsumerRebalanceListener());
+        Set<String> topics = Collections.singleton(topic);
+        Collection<TopicPartition> assignedPartitions = Collections.singleton(tp0);
+
+        // User subscribes to a topic and the group coordinator assigns a partitions to our consumer.
+        state.subscribe(topics, listener);
+        state.assignFromSubscribedAwaitingCallback(assignedPartitions, assignedPartitions);
+
+        // The logic in initializingPartitions will filter out the pending partition and it will
+        // not be considered fetchable.
+        assertFalse(state.initializingPartitions().contains(tp0));
+        assertFalse(state.isFetchable(tp0));
+        assertFalse(state.hasAllFetchPositions());
+
+        // Let's pretend this code is being executed by the Consumer.poll() code on the application thread.
+        assertFalse(state.isOffsetResetNeeded(tp0));
+        state.resetInitializingPositions();
+        assertFalse(state.isOffsetResetNeeded(tp0));
+
+        // Shortly after, on the next loop of the poll() method, we complete the callback.
+        state.enablePartitionsAwaitingCallback(Collections.singleton(tp0));
+
+        // THEN, we can reset the partition (if needed).
+        assertFalse(state.isOffsetResetNeeded(tp0));
+        state.resetInitializingPositions();
+        assertTrue(state.isOffsetResetNeeded(tp0));
+    }
 }
