diff --git a/clients/src/main/java/org/apache/kafka/clients/KafkaClient.java b/clients/src/main/java/org/apache/kafka/clients/KafkaClient.java
index d563fa0d9f..5bca261436 100644
--- a/clients/src/main/java/org/apache/kafka/clients/KafkaClient.java
+++ b/clients/src/main/java/org/apache/kafka/clients/KafkaClient.java
@@ -85,8 +85,18 @@ public interface KafkaClient extends Closeable {
      */
     List<ClientResponse> poll(long timeout, long now);
 
+    /**
+     * Diconnects the connection to a particular node, if there is one.
+     * Any pending ClientRequests for this connection will receive disconnections.
+     *
+     * @param nodeId The id of the node
+     */
+    void disconnect(String nodeId);
+
     /**
      * Closes the connection to a particular node (if there is one).
+     * All requests on the connection will be cleared.  ClientRequest callbacks will not be invoked
+     * for the cleared requests, nor will they be returned from poll().
      *
      * @param nodeId The id of the node
      */
diff --git a/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java b/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java
index 1d4fe58949..6e2968aa2c 100644
--- a/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java
+++ b/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java
@@ -226,8 +226,40 @@ public class NetworkClient implements KafkaClient {
         return false;
     }
 
+    /**
+     * Disconnects the connection to a particular node, if there is one.
+     * Any pending ClientRequests for this connection will receive disconnections.
+     *
+     * @param nodeId The id of the node
+     */
+    @Override
+    public void disconnect(String nodeId) {
+        selector.close(nodeId);
+        List<ApiKeys> requestTypes = new ArrayList<>();
+        long now = time.milliseconds();
+        for (InFlightRequest request : inFlightRequests.clearAll(nodeId)) {
+            if (request.isInternalRequest) {
+                if (request.header.apiKey() == ApiKeys.METADATA.id) {
+                    metadataUpdater.handleDisconnection(request.destination);
+                }
+            } else {
+                requestTypes.add(ApiKeys.forId(request.header.apiKey()));
+                abortedSends.add(new ClientResponse(request.header,
+                        request.callback, request.destination, request.createdTimeMs, now,
+                        true, null, null));
+            }
+        }
+        connectionStates.remove(nodeId);
+        if (log.isDebugEnabled()) {
+            log.debug("Manually disconnected from {}.  Removed requests: {}.", nodeId,
+                Utils.join(requestTypes, ", "));
+        }
+    }
+
     /**
      * Closes the connection to a particular node (if there is one).
+     * All requests on the connection will be cleared.  ClientRequest callbacks will not be invoked
+     * for the cleared requests, nor will they be returned from poll().
      *
      * @param nodeId The id of the node
      */
@@ -386,6 +418,15 @@ public class NetworkClient implements KafkaClient {
      */
     @Override
     public List<ClientResponse> poll(long timeout, long now) {
+        if (!abortedSends.isEmpty()) {
+            // If there are aborted sends because of unsupported version exceptions or disconnects,
+            // handle them immediately without waiting for Selector#poll.
+            List<ClientResponse> responses = new ArrayList<>();
+            handleAbortedSends(responses);
+            completeResponses(responses);
+            return responses;
+        }
+
         long metadataTimeout = metadataUpdater.maybeUpdate(now);
         try {
             this.selector.poll(Utils.min(timeout, metadataTimeout, requestTimeoutMs));
@@ -396,15 +437,18 @@ public class NetworkClient implements KafkaClient {
         // process completed actions
         long updatedNow = this.time.milliseconds();
         List<ClientResponse> responses = new ArrayList<>();
-        handleAbortedSends(responses);
         handleCompletedSends(responses, updatedNow);
         handleCompletedReceives(responses, updatedNow);
         handleDisconnections(responses, updatedNow);
         handleConnections();
         handleInitiateApiVersionRequests(updatedNow);
         handleTimedOutRequests(responses, updatedNow);
+        completeResponses(responses);
 
-        // invoke callbacks
+        return responses;
+    }
+
+    private void completeResponses(List<ClientResponse> responses) {
         for (ClientResponse response : responses) {
             try {
                 response.onComplete();
@@ -412,8 +456,6 @@ public class NetworkClient implements KafkaClient {
                 log.error("Uncaught error in request completion:", e);
             }
         }
-
-        return responses;
     }
 
     /**
diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/AdminClient.java b/clients/src/main/java/org/apache/kafka/clients/admin/AdminClient.java
index 73ea75452a..7e5944f916 100644
--- a/clients/src/main/java/org/apache/kafka/clients/admin/AdminClient.java
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/AdminClient.java
@@ -44,7 +44,7 @@ public abstract class AdminClient implements AutoCloseable {
      * @return The new KafkaAdminClient.
      */
     public static AdminClient create(Properties props) {
-        return KafkaAdminClient.createInternal(new AdminClientConfig(props));
+        return KafkaAdminClient.createInternal(new AdminClientConfig(props), null);
     }
 
     /**
@@ -54,7 +54,7 @@ public abstract class AdminClient implements AutoCloseable {
      * @return The new KafkaAdminClient.
      */
     public static AdminClient create(Map<String, Object> conf) {
-        return KafkaAdminClient.createInternal(new AdminClientConfig(conf));
+        return KafkaAdminClient.createInternal(new AdminClientConfig(conf), null);
     }
 
     /**
@@ -106,7 +106,7 @@ public abstract class AdminClient implements AutoCloseable {
                                                     CreateTopicsOptions options);
 
     /**
-     * Similar to #{@link AdminClient#deleteTopics(Collection<String>, DeleteTopicsOptions),
+     * Similar to #{@link AdminClient#deleteTopics(Collection<String>, DeleteTopicsOptions)},
      * but uses the default options.
      *
      * @param topics            The topic names to delete.
@@ -213,7 +213,7 @@ public abstract class AdminClient implements AutoCloseable {
     public abstract ApiVersionsResult apiVersions(Collection<Node> nodes, ApiVersionsOptions options);
 
     /**
-     * Similar to #{@link AdminClient#describeAcls(AclBindingFilter, DescribeAclsOptions),
+     * Similar to #{@link AdminClient#describeAcls(AclBindingFilter, DescribeAclsOptions)},
      * but uses the default options.
      *
      * @param filter            The filter to use.
@@ -236,7 +236,7 @@ public abstract class AdminClient implements AutoCloseable {
     public abstract DescribeAclsResult describeAcls(AclBindingFilter filter, DescribeAclsOptions options);
 
     /**
-     * Similar to #{@link AdminClient#createAcls(Collection<AclBinding>, CreateAclsOptions),
+     * Similar to #{@link AdminClient#createAcls(Collection<AclBinding>, CreateAclsOptions)},
      * but uses the default options.
      *
      * @param acls              The ACLs to create
@@ -259,7 +259,7 @@ public abstract class AdminClient implements AutoCloseable {
     public abstract CreateAclsResult createAcls(Collection<AclBinding> acls, CreateAclsOptions options);
 
     /**
-     * Similar to #{@link AdminClient#deleteAcls(Collection<AclBinding>, DeleteAclsOptions),
+     * Similar to #{@link AdminClient#deleteAcls(Collection<AclBinding>, DeleteAclsOptions)},
      * but uses the default options.
      *
      * @param filters           The filters to use.
@@ -334,5 +334,4 @@ public abstract class AdminClient implements AutoCloseable {
      * @return                The AlterConfigsResult
      */
     public abstract AlterConfigsResult alterConfigs(Map<ConfigResource, Config> configs, AlterConfigsOptions options);
-
 }
diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/AdminClientConfig.java b/clients/src/main/java/org/apache/kafka/clients/admin/AdminClientConfig.java
index 49f57531a4..876c9b0a27 100644
--- a/clients/src/main/java/org/apache/kafka/clients/admin/AdminClientConfig.java
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/AdminClientConfig.java
@@ -165,7 +165,7 @@ public class AdminClientConfig extends AbstractConfig {
         return CommonClientConfigs.postProcessReconnectBackoffConfigs(this, parsedValues);
     }
 
-    AdminClientConfig(Map<?, ?> props) {
+    public AdminClientConfig(Map<?, ?> props) {
         super(CONFIG, props);
     }
 
diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java b/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java
index da76032ef9..62899a3ac0 100644
--- a/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java
@@ -179,6 +179,11 @@ public class KafkaAdminClient extends AdminClient {
      */
     private final AtomicLong hardShutdownTimeMs = new AtomicLong(INVALID_SHUTDOWN_TIME);
 
+    /**
+     * A factory which creates TimeoutProcessors for the RPC thread.
+     */
+    private final TimeoutProcessorFactory timeoutProcessorFactory;
+
     /**
      * Get or create a list value from a map.
      *
@@ -270,7 +275,7 @@ public class KafkaAdminClient extends AdminClient {
         return throwable.getClass().getSimpleName();
     }
 
-    static KafkaAdminClient createInternal(AdminClientConfig config) {
+    static KafkaAdminClient createInternal(AdminClientConfig config, TimeoutProcessorFactory timeoutProcessorFactory) {
         Metadata metadata = null;
         Metrics metrics = null;
         NetworkClient networkClient = null;
@@ -312,7 +317,8 @@ public class KafkaAdminClient extends AdminClient {
                 true,
                 apiVersions);
             channelBuilder = null;
-            return new KafkaAdminClient(config, clientId, time, metadata, metrics, networkClient);
+            return new KafkaAdminClient(config, clientId, time, metadata, metrics, networkClient,
+                timeoutProcessorFactory);
         } catch (Throwable exc) {
             closeQuietly(metrics, "Metrics");
             closeQuietly(networkClient, "NetworkClient");
@@ -329,7 +335,7 @@ public class KafkaAdminClient extends AdminClient {
 
         try {
             metrics = new Metrics(new MetricConfig(), new LinkedList<MetricsReporter>(), time);
-            return new KafkaAdminClient(config, clientId, time, metadata, metrics, client);
+            return new KafkaAdminClient(config, clientId, time, metadata, metrics, client, null);
         } catch (Throwable exc) {
             closeQuietly(metrics, "Metrics");
             throw new KafkaException("Failed create new KafkaAdminClient", exc);
@@ -337,7 +343,7 @@ public class KafkaAdminClient extends AdminClient {
     }
 
     private KafkaAdminClient(AdminClientConfig config, String clientId, Time time, Metadata metadata,
-                     Metrics metrics, KafkaClient client) {
+                     Metrics metrics, KafkaClient client, TimeoutProcessorFactory timeoutProcessorFactory) {
         this.defaultTimeoutMs = config.getInt(AdminClientConfig.REQUEST_TIMEOUT_MS_CONFIG);
         this.clientId = clientId;
         this.time = time;
@@ -350,6 +356,8 @@ public class KafkaAdminClient extends AdminClient {
         this.runnable = new AdminClientRunnable();
         String threadName = "kafka-admin-client-thread" + (clientId.length() > 0 ? " | " + clientId : "");
         this.thread = new KafkaThread(threadName, runnable, false);
+        this.timeoutProcessorFactory = (timeoutProcessorFactory == null) ?
+            new TimeoutProcessorFactory() : timeoutProcessorFactory;
         config.logUnused();
         log.debug("Created Kafka admin client {}", this.clientId);
         thread.start();
@@ -449,7 +457,7 @@ public class KafkaAdminClient extends AdminClient {
         }
     }
 
-    private abstract class Call {
+    abstract class Call {
         private final String callName;
         private final long deadlineMs;
         private final NodeProvider nodeProvider;
@@ -557,6 +565,79 @@ public class KafkaAdminClient extends AdminClient {
         }
     }
 
+    static class TimeoutProcessorFactory {
+        TimeoutProcessor create(long now) {
+            return new TimeoutProcessor(now);
+        }
+    }
+
+    static class TimeoutProcessor {
+        /**
+         * The current time in milliseconds.
+         */
+        private final long now;
+
+        /**
+         * The number of milliseconds until the next timeout.
+         */
+        private int nextTimeoutMs;
+
+        /**
+         * Create a new timeout processor.
+         *
+         * @param now           The current time in milliseconds since the epoch.
+         */
+        TimeoutProcessor(long now) {
+            this.now = now;
+            this.nextTimeoutMs = Integer.MAX_VALUE;
+        }
+
+        /**
+         * Check for calls which have timed out.
+         * Timed out calls will be removed and failed.
+         * The remaining milliseconds until the next timeout will be updated.
+         *
+         * @param calls         The collection of calls.
+         *
+         * @return              The number of calls which were timed out.
+         */
+        int handleTimeouts(Collection<Call> calls, String msg) {
+            int numTimedOut = 0;
+            for (Iterator<Call> iter = calls.iterator(); iter.hasNext(); ) {
+                Call call = iter.next();
+                int remainingMs = calcTimeoutMsRemainingAsInt(now, call.deadlineMs);
+                if (remainingMs < 0) {
+                    call.fail(now, new TimeoutException(msg));
+                    iter.remove();
+                    numTimedOut++;
+                } else {
+                    nextTimeoutMs = Math.min(nextTimeoutMs, remainingMs);
+                }
+            }
+            return numTimedOut;
+        }
+
+        /**
+         * Check whether a call should be timed out.
+         * The remaining milliseconds until the next timeout will be updated.
+         *
+         * @param call      The call.
+         *
+         * @return          True if the call should be timed out.
+         */
+        boolean callHasExpired(Call call) {
+            int remainingMs = calcTimeoutMsRemainingAsInt(now, call.deadlineMs);
+            if (remainingMs < 0)
+                return true;
+            nextTimeoutMs = Math.min(nextTimeoutMs, remainingMs);
+            return false;
+        }
+
+        int nextTimeoutMs() {
+            return nextTimeoutMs;
+        }
+    }
+
     private final class AdminClientRunnable implements Runnable {
         /**
          * Pending calls.  Protected by the object monitor.
@@ -592,73 +673,6 @@ public class KafkaAdminClient extends AdminClient {
             return null;
         }
 
-        private class TimeoutProcessor {
-            /**
-             * The current time in milliseconds.
-             */
-            private final long now;
-
-            /**
-             * The number of milliseconds until the next timeout.
-             */
-            private int nextTimeoutMs;
-
-            /**
-             * Create a new timeout processor.
-             *
-             * @param now           The current time in milliseconds since the epoch.
-             */
-            TimeoutProcessor(long now) {
-                this.now = now;
-                this.nextTimeoutMs = Integer.MAX_VALUE;
-            }
-
-            /**
-             * Check for calls which have timed out.
-             * Timed out calls will be removed and failed.
-             * The remaining milliseconds until the next timeout will be updated.
-             *
-             * @param calls         The collection of calls.
-             *
-             * @return              The number of calls which were timed out.
-             */
-            int handleTimeouts(Collection<Call> calls, String msg) {
-                int numTimedOut = 0;
-                for (Iterator<Call> iter = calls.iterator(); iter.hasNext(); ) {
-                    Call call = iter.next();
-                    int remainingMs = calcTimeoutMsRemainingAsInt(now, call.deadlineMs);
-                    if (remainingMs < 0) {
-                        call.fail(now, new TimeoutException(msg));
-                        iter.remove();
-                        numTimedOut++;
-                    } else {
-                        nextTimeoutMs = Math.min(nextTimeoutMs, remainingMs);
-                    }
-                }
-                return numTimedOut;
-            }
-
-            /**
-             * Check whether a call should be timed out.
-             * The remaining milliseconds until the next timeout will be updated.
-             *
-             * @param call      The call.
-             *
-             * @return          True if the call should be timed out.
-             */
-            boolean callHasExpired(Call call) {
-                int remainingMs = calcTimeoutMsRemainingAsInt(now, call.deadlineMs);
-                if (remainingMs < 0)
-                    return true;
-                nextTimeoutMs = Math.min(nextTimeoutMs, remainingMs);
-                return false;
-            }
-
-            int nextTimeoutMs() {
-                return nextTimeoutMs;
-            }
-        }
-
         /**
          * Time out the elements in the newCalls list which are expired.
          *
@@ -800,7 +814,7 @@ public class KafkaAdminClient extends AdminClient {
                 Call call = contexts.get(0);
                 if (processor.callHasExpired(call)) {
                     log.debug("{}: Closing connection to {} to time out {}", clientId, nodeId, call);
-                    client.close(nodeId);
+                    client.disconnect(nodeId);
                     numTimedOut++;
                     // We don't remove anything from the callsInFlight data structure.  Because the connection
                     // has been closed, the calls should be returned by the next client#poll(),
@@ -829,8 +843,9 @@ public class KafkaAdminClient extends AdminClient {
                     // If the server returns information about a correlation ID we didn't use yet,
                     // an internal server error has occurred.  Close the connection and log an error message.
                     log.error("Internal server error on {}: server returned information about unknown " +
-                        "correlation ID {}", response.destination(), correlationId);
-                    client.close(response.destination());
+                        "correlation ID {}.  requestHeader = {}", response.destination(), correlationId,
+                        response.requestHeader());
+                    client.disconnect(response.destination());
                     continue;
                 }
 
@@ -908,7 +923,7 @@ public class KafkaAdminClient extends AdminClient {
                     break;
 
                 // Handle timeouts.
-                TimeoutProcessor timeoutProcessor = new TimeoutProcessor(now);
+                TimeoutProcessor timeoutProcessor = timeoutProcessorFactory.create(now);
                 timeoutNewCalls(timeoutProcessor);
                 timeoutCallsToSend(timeoutProcessor, callsToSend);
                 timeoutCallsInFlight(timeoutProcessor, callsInFlight);
diff --git a/clients/src/test/java/org/apache/kafka/clients/MockClient.java b/clients/src/test/java/org/apache/kafka/clients/MockClient.java
index 3a5adeeb30..29fae94f73 100644
--- a/clients/src/test/java/org/apache/kafka/clients/MockClient.java
+++ b/clients/src/test/java/org/apache/kafka/clients/MockClient.java
@@ -127,6 +127,7 @@ public class MockClient implements KafkaClient {
         return isBlackedOut(node);
     }
 
+    @Override
     public void disconnect(String node) {
         long now = time.milliseconds();
         Iterator<ClientRequest> iter = requests.iterator();
diff --git a/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java b/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java
index c0e86e9ef9..dfab018376 100644
--- a/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java
+++ b/clients/src/test/java/org/apache/kafka/clients/admin/KafkaAdminClientTest.java
@@ -45,6 +45,8 @@ import org.apache.kafka.common.resource.ResourceType;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -70,6 +72,8 @@ import static org.junit.Assert.fail;
  * See AdminClientIntegrationTest for an integration test.
  */
 public class KafkaAdminClientTest {
+    private static final Logger log = LoggerFactory.getLogger(KafkaAdminClientTest.class);
+
     @Rule
     final public Timeout globalTimeout = Timeout.millis(120000);
 
@@ -345,4 +349,42 @@ public class KafkaAdminClientTest {
         assertEquals("There are unexpected extra elements in the collection.",
             elements.length, collection.size());
     }
+
+    public static KafkaAdminClient createInternal(AdminClientConfig config, KafkaAdminClient.TimeoutProcessorFactory timeoutProcessorFactory) {
+        return KafkaAdminClient.createInternal(config, timeoutProcessorFactory);
+    }
+
+    public static class FailureInjectingTimeoutProcessorFactory extends KafkaAdminClient.TimeoutProcessorFactory {
+
+        private int numTries = 0;
+        
+        @Override
+        public KafkaAdminClient.TimeoutProcessor create(long now) {
+            return new FailureInjectingTimeoutProcessor(now);
+        }
+
+        synchronized boolean shouldInjectFailure() {
+            numTries++;
+            return numTries == 3;
+        }
+
+        public final class FailureInjectingTimeoutProcessor extends KafkaAdminClient.TimeoutProcessor {
+            public FailureInjectingTimeoutProcessor(long now) {
+                super(now);
+            }
+
+            boolean callHasExpired(KafkaAdminClient.Call call) {
+                if (shouldInjectFailure()) {
+                    log.debug("Injecting timeout for {}.", call);
+                    return true;
+                } else {
+                    boolean ret = super.callHasExpired(call);
+                    log.debug("callHasExpired({}) = {}", call, ret);
+                    return ret;
+                }
+            }
+        }
+
+    }
+
 }
diff --git a/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala b/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala
index 0a1d229563..cd4ecc9805 100644
--- a/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala
+++ b/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala
@@ -20,6 +20,7 @@ import java.util
 import java.util.{Collections, Properties}
 import java.util.concurrent.{ExecutionException, TimeUnit}
 
+import org.apache.kafka.clients.admin.KafkaAdminClientTest
 import org.apache.kafka.common.utils.{Time, Utils}
 import kafka.integration.KafkaServerTestHarness
 import kafka.log.LogConfig
@@ -344,6 +345,24 @@ class AdminClientIntegrationTest extends KafkaServerTestHarness with Logging {
     cfgs.foreach(_.putAll(serverConfig))
     cfgs.map(KafkaConfig.fromProps)
   }
+
+  /**
+    * Test injecting timeouts for calls that are in flight.
+    */
+  @Test
+  def testCallInFlightTimeouts(): Unit = {
+    val config = createConfig()
+    config.put(AdminClientConfig.REQUEST_TIMEOUT_MS_CONFIG, "100000000")
+    val factory = new KafkaAdminClientTest.FailureInjectingTimeoutProcessorFactory()
+    val client = KafkaAdminClientTest.createInternal(new AdminClientConfig(config), factory)
+    val future = client.createTopics(Seq("mytopic", "mytopic2").map(new NewTopic(_, 1, 1)).asJava,
+        new CreateTopicsOptions().validateOnly(true))
+    val future2 = client.createTopics(Seq("mytopic3", "mytopic4").map(new NewTopic(_, 1, 1)).asJava,
+        new CreateTopicsOptions().validateOnly(true))
+    future.all().get
+    future2.all().get
+    client.close()
+  }
 }
 
 object AdminClientIntegrationTest {
