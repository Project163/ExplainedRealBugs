diff --git a/build.gradle b/build.gradle
index d7820b4724..5189fd5752 100644
--- a/build.gradle
+++ b/build.gradle
@@ -974,6 +974,7 @@ project(':examples') {
 
 project(':generator') {
   dependencies {
+    compile libs.argparse4j
     compile libs.jacksonDatabind
     compile libs.jacksonJDK8Datatypes
     compile libs.jacksonJaxrsJsonProvider
@@ -1050,10 +1051,12 @@ project(':clients') {
   task processMessages(type:JavaExec) {
     main = "org.apache.kafka.message.MessageGenerator"
     classpath = project(':generator').sourceSets.main.runtimeClasspath
-    args = [ "org.apache.kafka.common.message",
-             "src/generated/java/org/apache/kafka/common/message",
-             "src/main/resources/common/message",
-             "ApiMessageTypeGenerator" ]
+    args = [ "-p", "org.apache.kafka.common.message",
+             "-o", "src/generated/java/org/apache/kafka/common/message",
+             "-i", "src/main/resources/common/message",
+             "-t", "ApiMessageTypeGenerator",
+             "-m", "MessageDataGenerator", "JsonConverterGenerator"
+           ]
     inputs.dir("src/main/resources/common/message")
     outputs.dir("src/generated/java/org/apache/kafka/common/message")
   }
@@ -1061,10 +1064,11 @@ project(':clients') {
   task processTestMessages(type:JavaExec) {
     main = "org.apache.kafka.message.MessageGenerator"
     classpath = project(':generator').sourceSets.main.runtimeClasspath
-    args = [ "org.apache.kafka.common.message",
-             "src/generated-test/java/org/apache/kafka/common/message",
-             "src/test/resources/common/message",
-             "none" ]
+    args = [ "-p", "org.apache.kafka.common.message",
+             "-o", "src/generated-test/java/org/apache/kafka/common/message",
+             "-i", "src/test/resources/common/message",
+             "-m", "MessageDataGenerator", "JsonConverterGenerator"
+           ]
     inputs.dir("src/test/resources/common/message")
     outputs.dir("src/generated-test/java/org/apache/kafka/common/message")
   }
@@ -1199,10 +1203,11 @@ project(':streams') {
   task processMessages(type:JavaExec) {
     main = "org.apache.kafka.message.MessageGenerator"
     classpath = project(':generator').sourceSets.main.runtimeClasspath
-    args = [ "org.apache.kafka.streams.internals.generated",
-             "src/generated/java/org/apache/kafka/streams/internals/generated",
-             "src/main/resources/common/message",
-             "none" ]
+    args = [ "-p", "org.apache.kafka.streams.internals.generated",
+             "-o", "src/generated/java/org/apache/kafka/streams/internals/generated",
+             "-i", "src/main/resources/common/message",
+             "-m", "MessageDataGenerator"
+           ]
     inputs.dir("src/main/resources/common/message")
     outputs.dir("src/generated/java/org/apache/kafka/streams/internals/generated")
   }
diff --git a/checkstyle/import-control.xml b/checkstyle/import-control.xml
index 377ea4290a..d5b1573e79 100644
--- a/checkstyle/import-control.xml
+++ b/checkstyle/import-control.xml
@@ -232,6 +232,8 @@
   <subpackage name="message">
     <allow pkg="com.fasterxml.jackson" />
     <allow pkg="com.fasterxml.jackson.annotation" />
+    <allow pkg="net.sourceforge.argparse4j" />
+    <allow pkg="org.apache.message" />
   </subpackage>
 
   <subpackage name="streams">
diff --git a/checkstyle/suppressions.xml b/checkstyle/suppressions.xml
index 01dd37bd11..532471cb49 100644
--- a/checkstyle/suppressions.xml
+++ b/checkstyle/suppressions.xml
@@ -14,7 +14,7 @@
     <suppress checks="NPathComplexity"
               files="(MessageDataGenerator|FieldSpec|WorkerSinkTask).java"/>
     <suppress checks="JavaNCSS"
-              files="(ApiMessageType).java|MessageDataGenerator.java"/>
+              files="(ApiMessageType|FieldSpec|MessageDataGenerator).java"/>
     <suppress checks="MethodLength"
               files="MessageDataGenerator.java"/>
     <suppress id="dontUseSystemExit"
@@ -76,7 +76,7 @@
     <suppress checks="(UnnecessaryParentheses|BooleanExpressionComplexity|CyclomaticComplexity|WhitespaceAfter|LocalVariableName)"
               files="Murmur3.java"/>
 
-    <suppress checks="(NPathComplexity|ClassFanOutComplexity|CyclomaticComplexity|ClassDataAbstractionCoupling|LocalVariableName|MemberName|ParameterName|MethodLength|JavaNCSS)"
+    <suppress checks="(NPathComplexity|ClassFanOutComplexity|CyclomaticComplexity|ClassDataAbstractionCoupling|LocalVariableName|MemberName|ParameterName|MethodLength|JavaNCSS|AvoidStarImport)"
             files="clients[\\/]src[\\/](generated|generated-test)[\\/].+.java$"/>
 
     <suppress checks="NPathComplexity"
@@ -172,7 +172,7 @@
               files="^(?!.*[\\/]org[\\/]apache[\\/]kafka[\\/]streams[\\/].*$)"/>
 
     <!-- Generated code -->
-    <suppress checks="(NPathComplexity|ClassFanOutComplexity|CyclomaticComplexity|ClassDataAbstractionCoupling|FinalLocalVariable|LocalVariableName|MemberName|ParameterName|MethodLength|JavaNCSS)"
+    <suppress checks="(NPathComplexity|ClassFanOutComplexity|CyclomaticComplexity|ClassDataAbstractionCoupling|FinalLocalVariable|LocalVariableName|MemberName|ParameterName|MethodLength|JavaNCSS|AvoidStarImport)"
               files="streams[\\/]src[\\/](generated|generated-test)[\\/].+.java$"/>
 
     <suppress checks="ImportControl" files="FetchResponseData.java"/>
diff --git a/clients/src/main/java/org/apache/kafka/common/protocol/Message.java b/clients/src/main/java/org/apache/kafka/common/protocol/Message.java
index 3ff33044fe..2a313ff9fd 100644
--- a/clients/src/main/java/org/apache/kafka/common/protocol/Message.java
+++ b/clients/src/main/java/org/apache/kafka/common/protocol/Message.java
@@ -17,8 +17,6 @@
 
 package org.apache.kafka.common.protocol;
 
-import com.fasterxml.jackson.annotation.JsonInclude;
-import com.fasterxml.jackson.databind.JsonNode;
 import org.apache.kafka.common.protocol.types.RawTaggedField;
 import org.apache.kafka.common.protocol.types.Struct;
 
@@ -102,46 +100,6 @@ public interface Message {
      */
     Struct toStruct(short version);
 
-    /**
-     * Reads this message from a Jackson JsonNode object.  This will overwrite
-     * all relevant fields with information from the Struct.
-     *
-     * For the most part, we expect every JSON object in the input to be the
-     * correct type.  There is one exception: we will deserialize numbers
-     * represented as strings.  If the numeric string begins with 0x, we will
-     * treat the number as hexadecimal.
-     *
-     * Note that we expect to see NullNode objects created for null entries.
-     * Therefore, please configure your Jackson ObjectMapper with
-     * setSerializationInclusion({@link JsonInclude.Include#ALWAYS}).
-     * Other settings may silently omit the nulls, which is not the
-     * semantic that Kafka RPC uses.  (Including a field and setting it to
-     * null is different than not including the field.)
-     *
-     * @param node          The source node.
-     * @param version       The version to use.
-     *
-     * @throws {@see org.apache.kafka.common.errors.UnsupportedVersionException}
-     *                      If the specified JSON can't be processed with the
-     *                      specified message version.
-     */
-    void fromJson(JsonNode node, short version);
-
-    /**
-     * Convert this message to a JsonNode.
-     *
-     * Note that 64-bit numbers will be serialized as strings rather than as integers.
-     * The reason is because JavaScript can't represent numbers above 2**52 accurately.
-     * Therefore, for maximum interoperability, we represent these numbers as strings.
-     *
-     * @param version       The version to use.
-     *
-     * @throws {@see org.apache.kafka.common.errors.UnsupportedVersionException}
-     *                      If the specified version is too new to be supported
-     *                      by this software.
-     */
-    JsonNode toJson(short version);
-
     /**
      * Returns a list of tagged fields which this software can't understand.
      *
diff --git a/clients/src/test/java/org/apache/kafka/common/message/MessageTest.java b/clients/src/test/java/org/apache/kafka/common/message/MessageTest.java
index a3946bd3ca..f473c93098 100644
--- a/clients/src/test/java/org/apache/kafka/common/message/MessageTest.java
+++ b/clients/src/test/java/org/apache/kafka/common/message/MessageTest.java
@@ -53,6 +53,7 @@ import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.Timeout;
 
+import java.lang.reflect.Method;
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -780,15 +781,29 @@ public final class MessageTest {
         assertEquals(expected.toString(), message2.toString());
     }
 
+    @SuppressWarnings("unchecked")
     private void testJsonRoundTrip(short version, Message message, Message expected) throws Exception {
-        JsonNode jsonNode = message.toJson(version);
-        Message message2 = message.getClass().newInstance();
-        message2.fromJson(jsonNode, version);
+        String jsonConverter = jsonConverterTypeName(message.getClass().getTypeName());
+        Class<?> converter = Class.forName(jsonConverter);
+        Method writeMethod = converter.getMethod("write", message.getClass(), short.class);
+        JsonNode jsonNode = (JsonNode) writeMethod.invoke(null, message, version);
+        Method readMethod = converter.getMethod("read", JsonNode.class, short.class);
+        Message message2 = (Message) readMethod.invoke(null, jsonNode, version);
         assertEquals(expected, message2);
         assertEquals(expected.hashCode(), message2.hashCode());
         assertEquals(expected.toString(), message2.toString());
     }
 
+    private static String jsonConverterTypeName(String source) {
+        int outerClassIndex = source.lastIndexOf('$');
+        if (outerClassIndex == -1) {
+            return  source + "JsonConverter";
+        } else {
+            return source.substring(0, outerClassIndex) + "JsonConverter$" +
+                source.substring(outerClassIndex + 1) + "JsonConverter";
+        }
+    }
+
     /**
      * Verify that the JSON files support the same message versions as the
      * schemas accessible through the ApiKey class.
diff --git a/generator/src/main/java/org/apache/kafka/message/FieldSpec.java b/generator/src/main/java/org/apache/kafka/message/FieldSpec.java
index c0b280bc6a..3bdbe570b3 100644
--- a/generator/src/main/java/org/apache/kafka/message/FieldSpec.java
+++ b/generator/src/main/java/org/apache/kafka/message/FieldSpec.java
@@ -25,6 +25,7 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.UUID;
 import java.util.regex.Pattern;
 
 public final class FieldSpec {
@@ -272,4 +273,343 @@ public final class FieldSpec {
     public boolean zeroCopy() {
         return zeroCopy;
     }
+
+    /**
+     * Get a string representation of the field default.
+     *
+     * @param headerGenerator   The header generator in case we need to add imports.
+     * @param structRegistry    The struct registry in case we need to look up structs.
+     *
+     * @return                  A string that can be used for the field default in the
+     *                          generated code.
+     */
+    String fieldDefault(HeaderGenerator headerGenerator,
+                        StructRegistry structRegistry) {
+        if (type instanceof FieldType.BoolFieldType) {
+            if (fieldDefault.isEmpty()) {
+                return "false";
+            } else if (fieldDefault.equalsIgnoreCase("true")) {
+                return "true";
+            } else if (fieldDefault.equalsIgnoreCase("false")) {
+                return "false";
+            } else {
+                throw new RuntimeException("Invalid default for boolean field " +
+                    name + ": " + fieldDefault);
+            }
+        } else if ((type instanceof FieldType.Int8FieldType) ||
+            (type instanceof FieldType.Int16FieldType) ||
+            (type instanceof FieldType.Int32FieldType) ||
+            (type instanceof FieldType.Int64FieldType)) {
+            int base = 10;
+            String defaultString = fieldDefault;
+            if (defaultString.startsWith("0x")) {
+                base = 16;
+                defaultString = defaultString.substring(2);
+            }
+            if (type instanceof FieldType.Int8FieldType) {
+                if (defaultString.isEmpty()) {
+                    return "(byte) 0";
+                } else {
+                    try {
+                        Byte.valueOf(defaultString, base);
+                    } catch (NumberFormatException e) {
+                        throw new RuntimeException("Invalid default for int8 field " +
+                            name + ": " + defaultString, e);
+                    }
+                    return "(byte) " + fieldDefault;
+                }
+            } else if (type instanceof FieldType.Int16FieldType) {
+                if (defaultString.isEmpty()) {
+                    return "(short) 0";
+                } else {
+                    try {
+                        Short.valueOf(defaultString, base);
+                    } catch (NumberFormatException e) {
+                        throw new RuntimeException("Invalid default for int16 field " +
+                            name + ": " + defaultString, e);
+                    }
+                    return "(short) " + fieldDefault;
+                }
+            } else if (type instanceof FieldType.Int32FieldType) {
+                if (defaultString.isEmpty()) {
+                    return "0";
+                } else {
+                    try {
+                        Integer.valueOf(defaultString, base);
+                    } catch (NumberFormatException e) {
+                        throw new RuntimeException("Invalid default for int32 field " +
+                            name + ": " + defaultString, e);
+                    }
+                    return fieldDefault;
+                }
+            } else if (type instanceof FieldType.Int64FieldType) {
+                if (defaultString.isEmpty()) {
+                    return "0L";
+                } else {
+                    try {
+                        Long.valueOf(defaultString, base);
+                    } catch (NumberFormatException e) {
+                        throw new RuntimeException("Invalid default for int64 field " +
+                            name + ": " + defaultString, e);
+                    }
+                    return fieldDefault + "L";
+                }
+            } else {
+                throw new RuntimeException("Unsupported field type " + type);
+            }
+        } else if (type instanceof FieldType.UUIDFieldType) {
+            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
+            if (fieldDefault.isEmpty()) {
+                headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+                return "MessageUtil.ZERO_UUID";
+            } else {
+                try {
+                    UUID.fromString(fieldDefault);
+                } catch (IllegalArgumentException e) {
+                    throw new RuntimeException("Invalid default for uuid field " +
+                        name + ": " + fieldDefault, e);
+                }
+                headerGenerator.addImport(MessageGenerator.UUID_CLASS);
+                return "UUID.fromString(\"" + fieldDefault + "\")";
+            }
+        } else if (type instanceof FieldType.Float64FieldType) {
+            if (fieldDefault.isEmpty()) {
+                return "0.0";
+            } else {
+                try {
+                    Double.parseDouble(fieldDefault);
+                } catch (NumberFormatException e) {
+                    throw new RuntimeException("Invalid default for float64 field " +
+                        name + ": " + fieldDefault, e);
+                }
+                return "Double.parseDouble(\"" + fieldDefault + "\")";
+            }
+        } else if (type instanceof FieldType.StringFieldType) {
+            if (fieldDefault.equals("null")) {
+                validateNullDefault();
+                return "null";
+            } else {
+                return "\"" + fieldDefault + "\"";
+            }
+        } else if (type.isBytes()) {
+            if (fieldDefault.equals("null")) {
+                validateNullDefault();
+                return "null";
+            } else if (!fieldDefault.isEmpty()) {
+                throw new RuntimeException("Invalid default for bytes field " +
+                    name + ".  The only valid default for a bytes field " +
+                    "is empty or null.");
+            }
+            if (zeroCopy) {
+                headerGenerator.addImport(MessageGenerator.BYTE_UTILS_CLASS);
+                return "ByteUtils.EMPTY_BUF";
+            } else {
+                headerGenerator.addImport(MessageGenerator.BYTES_CLASS);
+                return "Bytes.EMPTY";
+            }
+        } else if (type.isRecords()) {
+            return "null";
+        } else if (type.isStruct()) {
+            if (!fieldDefault.isEmpty()) {
+                throw new RuntimeException("Invalid default for struct field " +
+                    name + ": custom defaults are not supported for struct fields.");
+            }
+            return "new " + type.toString() + "()";
+        } else if (type.isArray()) {
+            if (fieldDefault.equals("null")) {
+                validateNullDefault();
+                return "null";
+            } else if (!fieldDefault.isEmpty()) {
+                throw new RuntimeException("Invalid default for array field " +
+                    name + ".  The only valid default for an array field " +
+                    "is the empty array or null.");
+            }
+            return String.format("new %s(0)",
+                concreteJavaType(headerGenerator, structRegistry));
+        } else {
+            throw new RuntimeException("Unsupported field type " + type);
+        }
+    }
+
+    private void validateNullDefault() {
+        if (!(nullableVersions().contains(versions))) {
+            throw new RuntimeException("null cannot be the default for field " +
+                name + ", because not all versions of this field are " +
+                "nullable.");
+        }
+    }
+
+    /**
+     * Get the abstract Java type of the field-- for example, List.
+     *
+     * @param headerGenerator   The header generator in case we need to add imports.
+     * @param structRegistry    The struct registry in case we need to look up structs.
+     *
+     * @return                  The abstract java type name.
+     */
+    String fieldAbstractJavaType(HeaderGenerator headerGenerator,
+                                 StructRegistry structRegistry) {
+        if (type instanceof FieldType.BoolFieldType) {
+            return "boolean";
+        } else if (type instanceof FieldType.Int8FieldType) {
+            return "byte";
+        } else if (type instanceof FieldType.Int16FieldType) {
+            return "short";
+        } else if (type instanceof FieldType.Int32FieldType) {
+            return "int";
+        } else if (type instanceof FieldType.Int64FieldType) {
+            return "long";
+        } else if (type instanceof FieldType.UUIDFieldType) {
+            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
+            return "UUID";
+        } else if (type instanceof FieldType.Float64FieldType) {
+            return "double";
+        } else if (type.isString()) {
+            return "String";
+        } else if (type.isBytes()) {
+            if (zeroCopy) {
+                headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);
+                return "ByteBuffer";
+            } else {
+                return "byte[]";
+            }
+        } else if (type instanceof FieldType.RecordsFieldType) {
+            headerGenerator.addImport(MessageGenerator.BASE_RECORDS_CLASS);
+            return "BaseRecords";
+        } else if (type.isStruct()) {
+            return MessageGenerator.capitalizeFirst(typeString());
+        } else if (type.isArray()) {
+            FieldType.ArrayType arrayType = (FieldType.ArrayType) type;
+            if (structRegistry.isStructArrayWithKeys(this)) {
+                headerGenerator.addImport(MessageGenerator.IMPLICIT_LINKED_HASH_MULTI_COLLECTION_CLASS);
+                return collectionType(arrayType.elementType().toString());
+            } else {
+                headerGenerator.addImport(MessageGenerator.LIST_CLASS);
+                return String.format("List<%s>",
+                    arrayType.elementType().getBoxedJavaType(headerGenerator));
+            }
+        } else {
+            throw new RuntimeException("Unknown field type " + type);
+        }
+    }
+
+    /**
+     * Get the concrete Java type of the field-- for example, ArrayList.
+     *
+     * @param headerGenerator   The header generator in case we need to add imports.
+     * @param structRegistry    The struct registry in case we need to look up structs.
+     *
+     * @return                  The abstract java type name.
+     */
+    String concreteJavaType(HeaderGenerator headerGenerator,
+                            StructRegistry structRegistry) {
+        if (type.isArray()) {
+            FieldType.ArrayType arrayType = (FieldType.ArrayType) type;
+            if (structRegistry.isStructArrayWithKeys(this)) {
+                return collectionType(arrayType.elementType().toString());
+            } else {
+                headerGenerator.addImport(MessageGenerator.ARRAYLIST_CLASS);
+                return String.format("ArrayList<%s>",
+                    arrayType.elementType().getBoxedJavaType(headerGenerator));
+            }
+        } else {
+            return fieldAbstractJavaType(headerGenerator, structRegistry);
+        }
+    }
+
+    static String collectionType(String baseType) {
+        return baseType + "Collection";
+    }
+
+    /**
+     * Generate an if statement that checks if this field has a non-default value.
+     *
+     * @param headerGenerator   The header generator in case we need to add imports.
+     * @param structRegistry    The struct registry in case we need to look up structs.
+     * @param buffer            The code buffer to write to.
+     * @param fieldPrefix       The prefix to prepend before references to this field.
+     * @param nullableVersions  The nullable versions to use for this field.  This is
+     *                          mainly to let us choose to ignore the possibility of
+     *                          nulls sometimes (like when dealing with array entries
+     *                          that cannot be null).
+     */
+    void generateNonDefaultValueCheck(HeaderGenerator headerGenerator,
+                                      StructRegistry structRegistry,
+                                      CodeBuffer buffer,
+                                      String fieldPrefix,
+                                      Versions nullableVersions) {
+        String fieldDefault = fieldDefault(headerGenerator, structRegistry);
+        if (type().isArray()) {
+            if (fieldDefault.equals("null")) {
+                buffer.printf("if (%s%s != null) {%n", fieldPrefix, camelCaseName());
+            } else if (nullableVersions.empty()) {
+                buffer.printf("if (!%s%s.isEmpty()) {%n", fieldPrefix, camelCaseName());
+            } else {
+                buffer.printf("if (%s%s == null || !%s%s.isEmpty()) {%n",
+                    fieldPrefix, camelCaseName(), fieldPrefix, camelCaseName());
+            }
+        } else if (type().isBytes()) {
+            if (fieldDefault.equals("null")) {
+                buffer.printf("if (%s%s != null) {%n", fieldPrefix, camelCaseName());
+            } else if (nullableVersions.empty()) {
+                if (zeroCopy()) {
+                    buffer.printf("if (%s%s.hasRemaining()) {%n",
+                        fieldPrefix, camelCaseName());
+                } else {
+                    buffer.printf("if (%s%s.length != 0) {%n",
+                        fieldPrefix, camelCaseName());
+                }
+            } else {
+                if (zeroCopy()) {
+                    buffer.printf("if (%s%s == null || %s%s.remaining() > 0) {%n",
+                        fieldPrefix, camelCaseName(), fieldPrefix, camelCaseName());
+                } else {
+                    buffer.printf("if (%s%s == null || %s%s.length != 0) {%n",
+                        fieldPrefix, camelCaseName(), fieldPrefix, camelCaseName());
+                }
+            }
+        } else if (type().isString() || type().isStruct()) {
+            if (fieldDefault.equals("null")) {
+                buffer.printf("if (%s%s != null) {%n", fieldPrefix, camelCaseName());
+            } else if (nullableVersions.empty()) {
+                buffer.printf("if (!%s%s.equals(%s)) {%n",
+                    fieldPrefix, camelCaseName(), fieldDefault);
+            } else {
+                buffer.printf("if (%s%s == null || !%s%s.equals(%s)) {%n",
+                    fieldPrefix, camelCaseName(), fieldPrefix, camelCaseName(),
+                    fieldDefault);
+            }
+        } else if (type() instanceof FieldType.BoolFieldType) {
+            buffer.printf("if (%s%s%s) {%n",
+                fieldDefault.equals("true") ? "!" : "",
+                fieldPrefix, camelCaseName());
+        } else {
+            buffer.printf("if (%s%s != %s) {%n",
+                fieldPrefix, camelCaseName(), fieldDefault);
+        }
+    }
+
+    /**
+     * Generate an if statement that checks if this field is non-default and also
+     * non-ignorable.
+     *
+     * @param headerGenerator   The header generator in case we need to add imports.
+     * @param structRegistry    The struct registry in case we need to look up structs.
+     * @param fieldPrefix       The prefix to prepend before references to this field.
+     * @param buffer            The code buffer to write to.
+     */
+    void generateNonIgnorableFieldCheck(HeaderGenerator headerGenerator,
+                                        StructRegistry structRegistry,
+                                        String fieldPrefix,
+                                        CodeBuffer buffer) {
+        generateNonDefaultValueCheck(headerGenerator, structRegistry,
+            buffer, fieldPrefix, nullableVersions());
+        buffer.incrementIndent();
+        headerGenerator.addImport(MessageGenerator.UNSUPPORTED_VERSION_EXCEPTION_CLASS);
+        buffer.printf("throw new UnsupportedVersionException(" +
+                "\"Attempted to write a non-default %s at version \" + _version);%n",
+            camelCaseName());
+        buffer.decrementIndent();
+        buffer.printf("}%n");
+    }
 }
diff --git a/generator/src/main/java/org/apache/kafka/message/FieldType.java b/generator/src/main/java/org/apache/kafka/message/FieldType.java
index aa4523ee46..ac6bb574c9 100644
--- a/generator/src/main/java/org/apache/kafka/message/FieldType.java
+++ b/generator/src/main/java/org/apache/kafka/message/FieldType.java
@@ -26,6 +26,11 @@ public interface FieldType {
         static final BoolFieldType INSTANCE = new BoolFieldType();
         private static final String NAME = "bool";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return "Boolean";
+        }
+
         @Override
         public Optional<Integer> fixedLength() {
             return Optional.of(1);
@@ -41,6 +46,11 @@ public interface FieldType {
         static final Int8FieldType INSTANCE = new Int8FieldType();
         private static final String NAME = "int8";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return "Byte";
+        }
+
         @Override
         public Optional<Integer> fixedLength() {
             return Optional.of(1);
@@ -56,6 +66,11 @@ public interface FieldType {
         static final Int16FieldType INSTANCE = new Int16FieldType();
         private static final String NAME = "int16";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return "Short";
+        }
+
         @Override
         public Optional<Integer> fixedLength() {
             return Optional.of(2);
@@ -71,6 +86,11 @@ public interface FieldType {
         static final Int32FieldType INSTANCE = new Int32FieldType();
         private static final String NAME = "int32";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return "Integer";
+        }
+
         @Override
         public Optional<Integer> fixedLength() {
             return Optional.of(4);
@@ -86,6 +106,11 @@ public interface FieldType {
         static final Int64FieldType INSTANCE = new Int64FieldType();
         private static final String NAME = "int64";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return "Long";
+        }
+
         @Override
         public Optional<Integer> fixedLength() {
             return Optional.of(8);
@@ -101,6 +126,12 @@ public interface FieldType {
         static final UUIDFieldType INSTANCE = new UUIDFieldType();
         private static final String NAME = "uuid";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
+            return "UUID";
+        }
+
         @Override
         public Optional<Integer> fixedLength() {
             return Optional.of(16);
@@ -121,6 +152,11 @@ public interface FieldType {
             return Optional.of(8);
         }
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return "Double";
+        }
+
         @Override
         public boolean isFloat() {
             return true;
@@ -136,6 +172,11 @@ public interface FieldType {
         static final StringFieldType INSTANCE = new StringFieldType();
         private static final String NAME = "string";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return "String";
+        }
+
         @Override
         public boolean serializationIsDifferentInFlexibleVersions() {
             return true;
@@ -161,6 +202,12 @@ public interface FieldType {
         static final BytesFieldType INSTANCE = new BytesFieldType();
         private static final String NAME = "bytes";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);
+            return "ByteBuffer";
+        }
+
         @Override
         public boolean serializationIsDifferentInFlexibleVersions() {
             return true;
@@ -186,6 +233,12 @@ public interface FieldType {
         static final RecordsFieldType INSTANCE = new RecordsFieldType();
         private static final String NAME = "records";
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            headerGenerator.addImport(MessageGenerator.BASE_RECORDS_CLASS);
+            return "BaseRecords";
+        }
+
         @Override
         public boolean serializationIsDifferentInFlexibleVersions() {
             return true;
@@ -214,6 +267,11 @@ public interface FieldType {
             this.type = type;
         }
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            return type;
+        }
+
         @Override
         public boolean serializationIsDifferentInFlexibleVersions() {
             return true;
@@ -242,6 +300,11 @@ public interface FieldType {
             return true;
         }
 
+        @Override
+        public String getBoxedJavaType(HeaderGenerator headerGenerator) {
+            throw new UnsupportedOperationException();
+        }
+
         @Override
         public boolean isArray() {
             return true;
@@ -315,6 +378,8 @@ public interface FieldType {
         }
     }
 
+    String getBoxedJavaType(HeaderGenerator headerGenerator);
+
     /**
      * Returns true if this is an array type.
      */
diff --git a/generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java b/generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java
new file mode 100644
index 0000000000..db26505641
--- /dev/null
+++ b/generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java
@@ -0,0 +1,412 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.kafka.message;
+
+import java.io.BufferedWriter;
+import java.util.Iterator;
+
+/**
+ * Generates Kafka MessageData classes.
+ */
+public final class JsonConverterGenerator implements MessageClassGenerator {
+    private final static String SUFFIX = "JsonConverter";
+    private final String packageName;
+    private final StructRegistry structRegistry;
+    private final HeaderGenerator headerGenerator;
+    private final CodeBuffer buffer;
+
+    JsonConverterGenerator(String packageName) {
+        this.packageName = packageName;
+        this.structRegistry = new StructRegistry();
+        this.headerGenerator = new HeaderGenerator(packageName);
+        this.buffer = new CodeBuffer();
+    }
+
+    @Override
+    public String outputName(MessageSpec spec) {
+        return spec.dataClassName() + SUFFIX;
+    }
+
+    @Override
+    public void generateAndWrite(MessageSpec message, BufferedWriter writer)
+            throws Exception {
+        structRegistry.register(message);
+        headerGenerator.addStaticImport(String.format("%s.%s.*",
+            packageName, message.dataClassName()));
+        buffer.printf("public class %s {%n",
+            MessageGenerator.capitalizeFirst(outputName(message)));
+        buffer.incrementIndent();
+        generateConverters(message.dataClassName(), message.struct(),
+            message.validVersions());
+        for (Iterator<StructRegistry.StructInfo> iter = structRegistry.structs();
+                iter.hasNext(); ) {
+            StructRegistry.StructInfo info = iter.next();
+            buffer.printf("%n");
+            buffer.printf("public static class %s {%n",
+                MessageGenerator.capitalizeFirst(info.spec().name() + SUFFIX));
+            buffer.incrementIndent();
+            generateConverters(MessageGenerator.capitalizeFirst(info.spec().name()),
+                info.spec(), info.parentVersions());
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+        }
+        buffer.decrementIndent();
+        buffer.printf("}%n");
+        headerGenerator.generate();
+        headerGenerator.buffer().write(writer);
+        buffer.write(writer);
+    }
+
+    private void generateConverters(String name,
+                                    StructSpec spec,
+                                    Versions parentVersions) {
+        generateRead(name, spec, parentVersions);
+        generateWrite(name, spec, parentVersions);
+    }
+
+    private void generateRead(String className,
+                              StructSpec struct,
+                              Versions parentVersions) {
+        headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);
+        buffer.printf("public static %s read(JsonNode _node, short _version) {%n",
+            className);
+        buffer.incrementIndent();
+        buffer.printf("%s _object = new %s();%n", className, className);
+        VersionConditional.forVersions(struct.versions(), parentVersions).
+            allowMembershipCheckAlwaysFalse(false).
+            ifNotMember(__ -> {
+                headerGenerator.addImport(MessageGenerator.UNSUPPORTED_VERSION_EXCEPTION_CLASS);
+                buffer.printf("throw new UnsupportedVersionException(\"Can't read " +
+                    "version \" + _version + \" of %s\");%n", className);
+            }).
+            generate(buffer);
+        Versions curVersions = parentVersions.intersect(struct.versions());
+        for (FieldSpec field : struct.fields()) {
+            String sourceVariable = String.format("_%sNode", field.camelCaseName());
+            buffer.printf("JsonNode %s = _node.get(\"%s\");%n",
+                sourceVariable,
+                field.camelCaseName());
+            buffer.printf("if (%s == null) {%n", sourceVariable);
+            buffer.incrementIndent();
+            Versions mandatoryVersions = field.versions().subtract(field.taggedVersions());
+            VersionConditional.forVersions(mandatoryVersions, curVersions).
+                ifMember(__ -> {
+                    buffer.printf("throw new RuntimeException(\"%s: unable to locate " +
+                            "field \'%s\', which is mandatory in version \" + _version);%n",
+                        className, field.camelCaseName());
+                }).
+                ifNotMember(__ -> {
+                    buffer.printf("_object.%s = %s;%n", field.camelCaseName(),
+                        field.fieldDefault(headerGenerator, structRegistry));
+                }).
+                generate(buffer);
+            buffer.decrementIndent();
+            buffer.printf("} else {%n");
+            buffer.incrementIndent();
+            VersionConditional.forVersions(struct.versions(), curVersions).
+                ifMember(presentVersions -> {
+                    generateTargetFromJson(new Target(field,
+                            sourceVariable,
+                            className,
+                        input -> String.format("_object.%s = %s", field.camelCaseName(), input)),
+                        curVersions);
+                }).ifNotMember(__ -> {
+                    buffer.printf("throw new RuntimeException(\"%s: field \'%s\' is not " +
+                        "supported in version \" + _version);%n",
+                        className, field.camelCaseName());
+                }).generate(buffer);
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+        }
+        buffer.printf("return _object;%n");
+        buffer.decrementIndent();
+        buffer.printf("}%n");
+    }
+
+    private void generateTargetFromJson(Target target, Versions curVersions) {
+        if (target.field().type() instanceof FieldType.BoolFieldType) {
+            buffer.printf("if (!%s.isBoolean()) {%n", target.sourceVariable());
+            buffer.incrementIndent();
+            buffer.printf("throw new RuntimeException(\"%s expected Boolean type, " +
+                "but got \" + _node.getNodeType());%n", target.humanReadableName());
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+            buffer.printf("%s;%n", target.assignmentStatement(
+                target.sourceVariable() + ".asBoolean()"));
+        } else if (target.field().type() instanceof FieldType.Int8FieldType) {
+            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("MessageUtil.jsonNodeToByte(%s, \"%s\")",
+                    target.sourceVariable(), target.humanReadableName())));
+        } else if (target.field().type() instanceof FieldType.Int16FieldType) {
+            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("MessageUtil.jsonNodeToShort(%s, \"%s\")",
+                    target.sourceVariable(), target.humanReadableName())));
+        } else if (target.field().type() instanceof FieldType.Int32FieldType) {
+            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("MessageUtil.jsonNodeToInt(%s, \"%s\")",
+                    target.sourceVariable(), target.humanReadableName())));
+        } else if (target.field().type() instanceof FieldType.Int64FieldType) {
+            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("MessageUtil.jsonNodeToLong(%s, \"%s\")",
+                    target.sourceVariable(), target.humanReadableName())));
+        } else if (target.field().type() instanceof FieldType.UUIDFieldType) {
+            buffer.printf("if (!%s.isTextual()) {%n", target.sourceVariable());
+            buffer.incrementIndent();
+            buffer.printf("throw new RuntimeException(\"%s expected a JSON string " +
+                "type, but got \" + _node.getNodeType());%n", target.humanReadableName());
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(String.format(
+                "UUID.fromString(%s.asText())", target.sourceVariable())));
+        } else if (target.field().type() instanceof FieldType.Float64FieldType) {
+            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("MessageUtil.jsonNodeToDouble(%s, \"%s\")",
+                    target.sourceVariable(), target.humanReadableName())));
+        } else {
+            // Handle the variable length types.  All of them are potentially
+            // nullable, so handle that here.
+            IsNullConditional.forName(target.sourceVariable()).
+                nullableVersions(target.field().nullableVersions()).
+                possibleVersions(curVersions).
+                conditionalGenerator((name, negated) ->
+                    String.format("%s%s.isNull()", negated ? "!" : "", name)).
+                ifNull(() -> {
+                    buffer.printf("%s;%n", target.assignmentStatement("null"));
+                }).
+                ifShouldNotBeNull(() -> {
+                    generateVariableLengthTargetFromJson(target, curVersions);
+                }).
+                generate(buffer);
+        }
+    }
+
+    private void generateVariableLengthTargetFromJson(Target target, Versions curVersions) {
+        if (target.field().type().isString()) {
+            buffer.printf("if (!%s.isTextual()) {%n", target.sourceVariable());
+            buffer.incrementIndent();
+            buffer.printf("throw new RuntimeException(\"%s expected a string " +
+                "type, but got \" + _node.getNodeType());%n", target.humanReadableName());
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("%s.asText()", target.sourceVariable())));
+        } else if (target.field().type().isBytes()) {
+            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+            if (target.field().zeroCopy()) {
+                headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);
+                buffer.printf("%s;%n", target.assignmentStatement(
+                    String.format("ByteBuffer.wrap(MessageUtil.jsonNodeToBinary(%s, \"%s\"))",
+                        target.sourceVariable(), target.humanReadableName())));
+            } else {
+                buffer.printf("%s;%n", target.assignmentStatement(
+                    String.format("MessageUtil.jsonNodeToBinary(%s, \"%s\")",
+                        target.sourceVariable(), target.humanReadableName())));
+            }
+        } else if (target.field().type().isRecords()) {
+            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+            headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);
+            headerGenerator.addImport(MessageGenerator.MEMORY_RECORDS_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("MemoryRecords.readableRecords(ByteBuffer.wrap(MessageUtil.jsonNodeToBinary(%s, \"%s\")))",
+                    target.sourceVariable(), target.humanReadableName())));
+        } else if (target.field().type().isArray()) {
+            buffer.printf("if (!%s.isArray()) {%n", target.sourceVariable());
+            buffer.incrementIndent();
+            buffer.printf("throw new RuntimeException(\"%s expected a JSON " +
+                "array, but got \" + _node.getNodeType());%n", target.humanReadableName());
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+            String type = target.field().concreteJavaType(headerGenerator, structRegistry);
+            buffer.printf("%s _collection = new %s();%n", type, type);
+            buffer.printf("%s;%n", target.assignmentStatement("_collection"));
+            headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);
+            buffer.printf("for (JsonNode _element : %s) {%n", target.sourceVariable());
+            buffer.incrementIndent();
+            generateTargetFromJson(target.arrayElementTarget(
+                input -> String.format("_collection.add(%s)", input)),
+                curVersions);
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+        } else if (target.field().type().isStruct()) {
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("%s%s.read(%s, _version)",
+                target.field().type().toString(), SUFFIX, target.sourceVariable())));
+        } else {
+            throw new RuntimeException("Unexpected type " + target.field().type());
+        }
+    }
+
+    private void generateWrite(String className,
+                               StructSpec struct,
+                               Versions parentVersions) {
+        headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);
+        buffer.printf("public static JsonNode write(%s _object, short _version) {%n",
+            className);
+        buffer.incrementIndent();
+        VersionConditional.forVersions(struct.versions(), parentVersions).
+            allowMembershipCheckAlwaysFalse(false).
+            ifNotMember(__ -> {
+                headerGenerator.addImport(MessageGenerator.UNSUPPORTED_VERSION_EXCEPTION_CLASS);
+                buffer.printf("throw new UnsupportedVersionException(\"Can't write " +
+                    "version \" + _version + \" of %s\");%n", className);
+            }).
+            generate(buffer);
+        Versions curVersions = parentVersions.intersect(struct.versions());
+        headerGenerator.addImport(MessageGenerator.OBJECT_NODE_CLASS);
+        headerGenerator.addImport(MessageGenerator.JSON_NODE_FACTORY_CLASS);
+        buffer.printf("ObjectNode _node = new ObjectNode(JsonNodeFactory.instance);%n");
+        for (FieldSpec field : struct.fields()) {
+            Target target = new Target(field,
+                String.format("_object.%s", field.camelCaseName()),
+                field.camelCaseName(),
+                input -> String.format("_node.set(\"%s\", %s)", field.camelCaseName(), input));
+            VersionConditional cond = VersionConditional.forVersions(field.versions(), curVersions).
+                ifMember(presentVersions -> {
+                    VersionConditional.forVersions(field.taggedVersions(), presentVersions).
+                        ifMember(presentAndTaggedVersions -> {
+                            field.generateNonDefaultValueCheck(headerGenerator,
+                                structRegistry, buffer, "_object.", field.nullableVersions());
+                            buffer.incrementIndent();
+                            if (field.defaultString().equals("null")) {
+                                // If the default was null, and we already checked that this field was not
+                                // the default, we can omit further null checks.
+                                generateTargetToJson(target.nonNullableCopy(), presentAndTaggedVersions);
+                            } else {
+                                generateTargetToJson(target, presentAndTaggedVersions);
+                            }
+                            buffer.decrementIndent();
+                            buffer.printf("}%n");
+                        }).
+                        ifNotMember(presentAndNotTaggedVersions -> {
+                            generateTargetToJson(target, presentAndNotTaggedVersions);
+                        }).
+                        generate(buffer);
+                });
+            if (!field.ignorable()) {
+                cond.ifNotMember(__ -> {
+                    field.generateNonIgnorableFieldCheck(headerGenerator,
+                        structRegistry, "_object.", buffer);
+                });
+            }
+            cond.generate(buffer);
+        }
+        buffer.printf("return _node;%n");
+        buffer.decrementIndent();
+        buffer.printf("}%n");
+    }
+
+    private void generateTargetToJson(Target target, Versions versions) {
+        if (target.field().type() instanceof FieldType.BoolFieldType) {
+            headerGenerator.addImport(MessageGenerator.BOOLEAN_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("BooleanNode.valueOf(%s)", target.sourceVariable())));
+        } else if ((target.field().type() instanceof FieldType.Int8FieldType) ||
+            (target.field().type() instanceof FieldType.Int16FieldType)) {
+            headerGenerator.addImport(MessageGenerator.SHORT_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("new ShortNode(%s)", target.sourceVariable())));
+        } else if (target.field().type() instanceof FieldType.Int32FieldType) {
+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("new IntNode(%s)", target.sourceVariable())));
+        } else if (target.field().type() instanceof FieldType.Int64FieldType) {
+            headerGenerator.addImport(MessageGenerator.LONG_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("new LongNode(%s)", target.sourceVariable())));
+        } else if (target.field().type() instanceof FieldType.UUIDFieldType) {
+            headerGenerator.addImport(MessageGenerator.TEXT_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("new TextNode(%s.toString())", target.sourceVariable())));
+        } else if (target.field().type() instanceof FieldType.Float64FieldType) {
+            headerGenerator.addImport(MessageGenerator.DOUBLE_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("new DoubleNode(%s)", target.sourceVariable())));
+        } else {
+            // Handle the variable length types.  All of them are potentially
+            // nullable, so handle that here.
+            IsNullConditional.forName(target.sourceVariable()).
+                nullableVersions(target.field().nullableVersions()).
+                possibleVersions(versions).
+                conditionalGenerator((name, negated) ->
+                    String.format("%s %s= null", name, negated ? "!" : "=")).
+                ifNull(() -> {
+                    headerGenerator.addImport(MessageGenerator.NULL_NODE_CLASS);
+                    buffer.printf("%s;%n", target.assignmentStatement("NullNode.instance"));
+                }).
+                ifShouldNotBeNull(() -> {
+                    generateVariableLengthTargetToJson(target, versions);
+                }).
+                generate(buffer);
+        }
+    }
+
+    private void generateVariableLengthTargetToJson(Target target, Versions versions) {
+        if (target.field().type().isString()) {
+            headerGenerator.addImport(MessageGenerator.TEXT_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("new TextNode(%s)", target.sourceVariable())));
+        } else if (target.field().type().isBytes()) {
+            headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);
+            if (target.field().zeroCopy()) {
+                headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
+                buffer.printf("%s;%n", target.assignmentStatement(
+                    String.format("new BinaryNode(MessageUtil.byteBufferToArray(%s))",
+                        target.sourceVariable())));
+            } else {
+                headerGenerator.addImport(MessageGenerator.ARRAYS_CLASS);
+                buffer.printf("%s;%n", target.assignmentStatement(
+                    String.format("new BinaryNode(Arrays.copyOf(%s, %s.length))",
+                        target.sourceVariable(), target.sourceVariable())));
+            }
+        } else if (target.field().type().isRecords()) {
+            headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);
+            buffer.printf("%s;%n", target.assignmentStatement("new BinaryNode(new byte[]{})"));
+        } else if (target.field().type().isArray()) {
+            headerGenerator.addImport(MessageGenerator.ARRAY_NODE_CLASS);
+            headerGenerator.addImport(MessageGenerator.JSON_NODE_FACTORY_CLASS);
+            FieldType.ArrayType arrayType = (FieldType.ArrayType) target.field().type();
+            FieldType elementType = arrayType.elementType();
+            String arrayInstanceName = String.format("_%sArray",
+                target.field().camelCaseName());
+            buffer.printf("ArrayNode %s = new ArrayNode(JsonNodeFactory.instance);%n",
+                arrayInstanceName);
+            buffer.printf("for (%s _element : %s) {%n",
+                elementType.getBoxedJavaType(headerGenerator), target.sourceVariable());
+            buffer.incrementIndent();
+            generateTargetToJson(target.arrayElementTarget(
+                input -> String.format("%s.add(%s)", arrayInstanceName, input)),
+                versions);
+            buffer.decrementIndent();
+            buffer.printf("}%n");
+            buffer.printf("%s;%n", target.assignmentStatement(arrayInstanceName));
+        } else if (target.field().type().isStruct()) {
+            buffer.printf("%s;%n", target.assignmentStatement(
+                String.format("%sJsonConverter.write(%s, _version)",
+                    target.field().type().toString(), target.sourceVariable())));
+        } else {
+            throw new RuntimeException("unknown type " + target.field().type());
+        }
+    }
+
+}
diff --git a/generator/src/main/java/org/apache/kafka/message/MessageClassGenerator.java b/generator/src/main/java/org/apache/kafka/message/MessageClassGenerator.java
new file mode 100644
index 0000000000..83117560a8
--- /dev/null
+++ b/generator/src/main/java/org/apache/kafka/message/MessageClassGenerator.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.kafka.message;
+
+import java.io.BufferedWriter;
+
+public interface MessageClassGenerator {
+    /**
+     * The short name of the converter class we are generating.  For example,
+     * FetchRequestDataJsonConverter.java.
+     */
+    String outputName(MessageSpec spec);
+
+    /**
+     * Generate the convertere, and then write it out.
+     *
+     * @param spec      The message to generate a converter for.
+     * @param writer    The writer to write out the state to.
+     */
+    void generateAndWrite(MessageSpec spec, BufferedWriter writer) throws Exception;
+}
diff --git a/generator/src/main/java/org/apache/kafka/message/MessageDataGenerator.java b/generator/src/main/java/org/apache/kafka/message/MessageDataGenerator.java
index d32a36f07b..46804992f1 100644
--- a/generator/src/main/java/org/apache/kafka/message/MessageDataGenerator.java
+++ b/generator/src/main/java/org/apache/kafka/message/MessageDataGenerator.java
@@ -17,19 +17,19 @@
 
 package org.apache.kafka.message;
 
-import java.io.Writer;
+import java.io.BufferedWriter;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.Optional;
 import java.util.Set;
 import java.util.TreeMap;
-import java.util.UUID;
 import java.util.stream.Collectors;
 
 /**
  * Generates Kafka MessageData classes.
  */
-public final class MessageDataGenerator {
+public final class MessageDataGenerator implements MessageClassGenerator {
     private final static String TAGGED_FIELDS_SECTION_NAME = "_tagged_fields";
 
     private final StructRegistry structRegistry;
@@ -45,6 +45,17 @@ public final class MessageDataGenerator {
         this.buffer = new CodeBuffer();
     }
 
+    @Override
+    public String outputName(MessageSpec spec) {
+        return spec.dataClassName();
+    }
+
+    @Override
+    public void generateAndWrite(MessageSpec message, BufferedWriter writer) throws Exception {
+        generate(message);
+        write(writer);
+    }
+
     void generate(MessageSpec message) throws Exception {
         if (message.struct().versions().contains(Short.MAX_VALUE)) {
             throw new RuntimeException("Message " + message.name() + " does " +
@@ -54,13 +65,13 @@ public final class MessageDataGenerator {
         schemaGenerator.generateSchemas(message);
         messageFlexibleVersions = message.flexibleVersions();
         generateClass(Optional.of(message),
-            message.generatedClassName(),
+            message.dataClassName(),
             message.struct(),
             message.struct().versions());
         headerGenerator.generate();
     }
 
-    void write(Writer writer) throws Exception {
+    void write(BufferedWriter writer) throws Exception {
         headerGenerator.buffer().write(writer);
         buffer.write(writer);
     }
@@ -98,10 +109,6 @@ public final class MessageDataGenerator {
         buffer.printf("%n");
         generateClassToStruct(className, struct, parentVersions);
         buffer.printf("%n");
-        generateClassFromJson(className, struct, parentVersions);
-        buffer.printf("%n");
-        generateClassToJson(className, struct, parentVersions);
-        buffer.printf("%n");
         generateClassSize(className, struct, parentVersions);
         if (isSetElement) {
             buffer.printf("%n");
@@ -152,7 +159,7 @@ public final class MessageDataGenerator {
             headerGenerator.addImport(MessageGenerator.IMPLICIT_LINKED_HASH_MULTI_COLLECTION_CLASS);
             implementedInterfaces.add("ImplicitLinkedHashMultiCollection.Element");
         }
-        Set<String> classModifiers = new HashSet<>();
+        Set<String> classModifiers = new LinkedHashSet<>();
         classModifiers.add("public");
         if (!isTopLevel) {
             classModifiers.add("static");
@@ -192,7 +199,7 @@ public final class MessageDataGenerator {
         buffer.printf("%n");
         headerGenerator.addImport(MessageGenerator.IMPLICIT_LINKED_HASH_MULTI_COLLECTION_CLASS);
         buffer.printf("public static class %s extends ImplicitLinkedHashMultiCollection<%s> {%n",
-            collectionType(className), className);
+            FieldSpec.collectionType(className), className);
         buffer.incrementIndent();
         generateHashSetZeroArgConstructor(className);
         buffer.printf("%n");
@@ -204,13 +211,13 @@ public final class MessageDataGenerator {
         buffer.printf("%n");
         generateHashSetFindAllMethod(className, struct);
         buffer.printf("%n");
-        generateCollectionDuplicateMethod(className, struct);
+        generateCollectionDuplicateMethod(className);
         buffer.decrementIndent();
         buffer.printf("}%n");
     }
 
     private void generateHashSetZeroArgConstructor(String className) {
-        buffer.printf("public %s() {%n", collectionType(className));
+        buffer.printf("public %s() {%n", FieldSpec.collectionType(className));
         buffer.incrementIndent();
         buffer.printf("super();%n");
         buffer.decrementIndent();
@@ -218,7 +225,8 @@ public final class MessageDataGenerator {
     }
 
     private void generateHashSetSizeArgConstructor(String className) {
-        buffer.printf("public %s(int expectedNumElements) {%n", collectionType(className));
+        buffer.printf("public %s(int expectedNumElements) {%n",
+            FieldSpec.collectionType(className));
         buffer.incrementIndent();
         buffer.printf("super(expectedNumElements);%n");
         buffer.decrementIndent();
@@ -227,7 +235,8 @@ public final class MessageDataGenerator {
 
     private void generateHashSetIteratorConstructor(String className) {
         headerGenerator.addImport(MessageGenerator.ITERATOR_CLASS);
-        buffer.printf("public %s(Iterator<%s> iterator) {%n", collectionType(className), className);
+        buffer.printf("public %s(Iterator<%s> iterator) {%n",
+            FieldSpec.collectionType(className), className);
         buffer.incrementIndent();
         buffer.printf("super(iterator);%n");
         buffer.decrementIndent();
@@ -272,16 +281,17 @@ public final class MessageDataGenerator {
     private String commaSeparatedHashSetFieldAndTypes(StructSpec struct) {
         return struct.fields().stream().
             filter(f -> f.mapKey()).
-            map(f -> String.format("%s %s", fieldConcreteJavaType(f), f.camelCaseName())).
+            map(f -> String.format("%s %s",
+                f.concreteJavaType(headerGenerator, structRegistry), f.camelCaseName())).
             collect(Collectors.joining(", "));
     }
 
-    private void generateCollectionDuplicateMethod(String className, StructSpec struct) {
+    private void generateCollectionDuplicateMethod(String className) {
         headerGenerator.addImport(MessageGenerator.LIST_CLASS);
-        buffer.printf("public %s duplicate() {%n", collectionType(className));
+        buffer.printf("public %s duplicate() {%n", FieldSpec.collectionType(className));
         buffer.incrementIndent();
         buffer.printf("%s _duplicate = new %s(size());%n",
-            collectionType(className), collectionType(className));
+            FieldSpec.collectionType(className), FieldSpec.collectionType(className));
         buffer.printf("for (%s _element : this) {%n", className);
         buffer.incrementIndent();
         buffer.printf("_duplicate.add(_element.duplicate());%n");
@@ -306,8 +316,9 @@ public final class MessageDataGenerator {
     }
 
     private void generateFieldDeclaration(FieldSpec field) {
-        buffer.printf("private %s %s;%n",
-            fieldAbstractJavaType(field), field.camelCaseName());
+        buffer.printf("%s %s;%n",
+            field.fieldAbstractJavaType(headerGenerator, structRegistry),
+            field.camelCaseName());
     }
 
     private void generateFieldAccessors(StructSpec struct, boolean isSetElement) {
@@ -361,69 +372,6 @@ public final class MessageDataGenerator {
         }
     }
 
-    private static String collectionType(String baseType) {
-        return baseType + "Collection";
-    }
-
-    private String fieldAbstractJavaType(FieldSpec field) {
-        if (field.type() instanceof FieldType.BoolFieldType) {
-            return "boolean";
-        } else if (field.type() instanceof FieldType.Int8FieldType) {
-            return "byte";
-        } else if (field.type() instanceof FieldType.Int16FieldType) {
-            return "short";
-        } else if (field.type() instanceof FieldType.Int32FieldType) {
-            return "int";
-        } else if (field.type() instanceof FieldType.Int64FieldType) {
-            return "long";
-        } else if (field.type() instanceof FieldType.UUIDFieldType) {
-            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
-            return "UUID";
-        } else if (field.type() instanceof FieldType.Float64FieldType) {
-            return "double";
-        } else if (field.type().isString()) {
-            return "String";
-        } else if (field.type().isBytes()) {
-            if (field.zeroCopy()) {
-                headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);
-                return "ByteBuffer";
-            } else {
-                return "byte[]";
-            }
-        } else if (field.type() instanceof FieldType.RecordsFieldType) {
-            headerGenerator.addImport(MessageGenerator.BASE_RECORDS_CLASS);
-            return "BaseRecords";
-        } else if (field.type().isStruct()) {
-            return MessageGenerator.capitalizeFirst(field.typeString());
-        } else if (field.type().isArray()) {
-            FieldType.ArrayType arrayType = (FieldType.ArrayType) field.type();
-            if (structRegistry.isStructArrayWithKeys(field)) {
-                headerGenerator.addImport(MessageGenerator.IMPLICIT_LINKED_HASH_MULTI_COLLECTION_CLASS);
-                return collectionType(arrayType.elementType().toString());
-            } else {
-                headerGenerator.addImport(MessageGenerator.LIST_CLASS);
-                return "List<" + getBoxedJavaType(arrayType.elementType()) + ">";
-            }
-        } else {
-            throw new RuntimeException("Unknown field type " + field.type());
-        }
-    }
-
-    private String fieldConcreteJavaType(FieldSpec field) {
-        if (field.type().isArray()) {
-            FieldType.ArrayType arrayType = (FieldType.ArrayType) field.type();
-            if (structRegistry.isStructArrayWithKeys(field)) {
-                headerGenerator.addImport(MessageGenerator.IMPLICIT_LINKED_HASH_MULTI_COLLECTION_CLASS);
-                return collectionType(arrayType.elementType().toString());
-            } else {
-                headerGenerator.addImport(MessageGenerator.ARRAYLIST_CLASS);
-                return "ArrayList<" + getBoxedJavaType(arrayType.elementType()) + ">";
-            }
-        } else {
-            return fieldAbstractJavaType(field);
-        }
-    }
-
     private void generateClassConstructors(String className, StructSpec struct, boolean isSetElement) {
         headerGenerator.addImport(MessageGenerator.READABLE_CLASS);
         buffer.printf("public %s(Readable _readable, short _version) {%n", className);
@@ -443,20 +391,12 @@ public final class MessageDataGenerator {
         buffer.printf("}%n");
         buffer.printf("%n");
 
-        headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);
-        buffer.printf("public %s(JsonNode _node, short _version) {%n", className);
-        buffer.incrementIndent();
-        buffer.printf("fromJson(_node, _version);%n");
-        generateConstructorEpilogue(isSetElement);
-        buffer.decrementIndent();
-        buffer.printf("}%n");
-        buffer.printf("%n");
-
         buffer.printf("public %s() {%n", className);
         buffer.incrementIndent();
         for (FieldSpec field : struct.fields()) {
             buffer.printf("this.%s = %s;%n",
-                field.camelCaseName(), fieldDefault(field));
+                field.camelCaseName(),
+                field.fieldDefault(headerGenerator, structRegistry));
         }
         generateConstructorEpilogue(isSetElement);
         buffer.decrementIndent();
@@ -507,7 +447,8 @@ public final class MessageDataGenerator {
                 alwaysEmitBlockScope(field.type().isVariableLength()).
                 ifNotMember(__ -> {
                     // If the field is not present, or is tagged, set it to its default here.
-                    buffer.printf("this.%s = %s;%n", field.camelCaseName(), fieldDefault(field));
+                    buffer.printf("this.%s = %s;%n", field.camelCaseName(),
+                        field.fieldDefault(headerGenerator, structRegistry));
                 }).
                 ifMember(presentAndUntaggedVersions -> {
                     if (field.type().isVariableLength() && !field.type().isStruct()) {
@@ -679,7 +620,8 @@ public final class MessageDataGenerator {
                 assignmentPrefix, lengthVar, assignmentSuffix);
         } else if (type.isBytes()) {
             if (zeroCopy) {
-                buffer.printf("%s_readable.readByteBuffer(%s)%s", assignmentPrefix, lengthVar, assignmentSuffix);
+                buffer.printf("%s_readable.readByteBuffer(%s)%s",
+                    assignmentPrefix, lengthVar, assignmentSuffix);
             } else {
                 buffer.printf("byte[] newBytes = new byte[%s];%n", lengthVar);
                 buffer.printf("_readable.readArray(newBytes);%n");
@@ -689,11 +631,13 @@ public final class MessageDataGenerator {
             headerGenerator.addImport(MessageGenerator.RECORDS_READABLE_CLASS);
             buffer.printf("if (_readable instanceof RecordsReadable) {%n");
             buffer.incrementIndent();
-            buffer.printf("%s((RecordsReadable) _readable).readRecords(%s)%s", assignmentPrefix, lengthVar, assignmentSuffix);
+            buffer.printf("%s((RecordsReadable) _readable).readRecords(%s)%s",
+                assignmentPrefix, lengthVar, assignmentSuffix);
             buffer.decrementIndent();
             buffer.printf("} else {%n");
             buffer.incrementIndent();
-            buffer.printf("throw new RuntimeException(\"Cannot read records from reader of class: \" + _readable.getClass().getSimpleName());%n");
+            buffer.printf("throw new RuntimeException(\"Cannot read records from " +
+                "reader of class: \" + _readable.getClass().getSimpleName());%n");
             buffer.decrementIndent();
             buffer.printf("}%n");
         } else if (type.isArray()) {
@@ -701,13 +645,14 @@ public final class MessageDataGenerator {
             if (isStructArrayWithKeys) {
                 headerGenerator.addImport(MessageGenerator.IMPLICIT_LINKED_HASH_MULTI_COLLECTION_CLASS);
                 buffer.printf("%s newCollection = new %s(%s);%n",
-                    collectionType(arrayType.elementType().toString()),
-                        collectionType(arrayType.elementType().toString()), lengthVar);
+                    FieldSpec.collectionType(arrayType.elementType().toString()),
+                        FieldSpec.collectionType(arrayType.elementType().toString()), lengthVar);
             } else {
                 headerGenerator.addImport(MessageGenerator.ARRAYLIST_CLASS);
+                String boxedArrayType =
+                    arrayType.elementType().getBoxedJavaType(headerGenerator);
                 buffer.printf("ArrayList<%s> newCollection = new ArrayList<%s>(%s);%n",
-                    getBoxedJavaType(arrayType.elementType()),
-                        getBoxedJavaType(arrayType.elementType()), lengthVar);
+                    boxedArrayType, boxedArrayType, lengthVar);
             }
             buffer.printf("for (int i = 0; i < %s; i++) {%n", lengthVar);
             buffer.incrementIndent();
@@ -769,7 +714,8 @@ public final class MessageDataGenerator {
             VersionConditional.forVersions(field.versions(), curVersions).
                 alwaysEmitBlockScope(field.type().isArray()).
                 ifNotMember(__ -> {
-                    buffer.printf("this.%s = %s;%n", field.camelCaseName(), fieldDefault(field));
+                    buffer.printf("this.%s = %s;%n", field.camelCaseName(),
+                        field.fieldDefault(headerGenerator, structRegistry));
                 }).
                 ifMember(presentVersions -> {
                     VersionConditional.forVersions(field.taggedVersions(), presentVersions).
@@ -811,18 +757,19 @@ public final class MessageDataGenerator {
                             } else if (field.type().isStruct()) {
                                 buffer.printf("this.%s = new %s((Struct) _taggedFields.remove(%d), _version);%n",
                                     field.camelCaseName(),
-                                    getBoxedJavaType(field.type()),
+                                    field.type().getBoxedJavaType(headerGenerator),
                                     field.tag().get());
                             } else {
                                 buffer.printf("this.%s = (%s) _taggedFields.remove(%d);%n",
                                     field.camelCaseName(),
-                                    getBoxedJavaType(field.type()),
+                                    field.type().getBoxedJavaType(headerGenerator),
                                     field.tag().get());
                             }
                             buffer.decrementIndent();
                             buffer.printf("} else {%n");
                             buffer.incrementIndent();
-                            buffer.printf("this.%s = %s;%n", field.camelCaseName(), fieldDefault(field));
+                            buffer.printf("this.%s = %s;%n", field.camelCaseName(),
+                                field.fieldDefault(headerGenerator, structRegistry));
                             buffer.decrementIndent();
                             buffer.printf("}%n");
                         }).
@@ -852,325 +799,6 @@ public final class MessageDataGenerator {
         buffer.printf("}%n");
     }
 
-    private void generateClassFromJson(String className, StructSpec struct,
-                                       Versions parentVersions) {
-        headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);
-        buffer.printf("@Override%n");
-        buffer.printf("public void fromJson(JsonNode _node, short _version) {%n");
-        buffer.incrementIndent();
-        VersionConditional.forVersions(struct.versions(), parentVersions).
-            allowMembershipCheckAlwaysFalse(false).
-            ifNotMember(__ -> {
-                headerGenerator.addImport(MessageGenerator.UNSUPPORTED_VERSION_EXCEPTION_CLASS);
-                buffer.printf("throw new UnsupportedVersionException(\"Can't read " +
-                    "version \" + _version + \" of %s\");%n", className);
-            }).
-            generate(buffer);
-        Versions curVersions = parentVersions.intersect(struct.versions());
-        for (FieldSpec field : struct.fields()) {
-            String sourceVariable = String.format("_%sNode", field.camelCaseName());
-            buffer.printf("JsonNode %s = _node.get(\"%s\");%n",
-                sourceVariable,
-                field.camelCaseName());
-            buffer.printf("if (%s == null) {%n", sourceVariable);
-            buffer.incrementIndent();
-            Versions mandatoryVersions = field.versions().subtract(field.taggedVersions());
-            VersionConditional.forVersions(mandatoryVersions, curVersions).
-                ifMember(__ -> {
-                    buffer.printf("throw new RuntimeException(\"%s: unable to locate " +
-                        "field \'%s\', which is mandatory in version \" + _version);%n",
-                        className, field.camelCaseName());
-                }).
-                ifNotMember(__ -> {
-                    buffer.printf("this.%s = %s;%n", field.camelCaseName(), fieldDefault(field));
-                }).
-                generate(buffer);
-            buffer.decrementIndent();
-            buffer.printf("} else {%n");
-            buffer.incrementIndent();
-            VersionConditional.forVersions(struct.versions(), curVersions).
-                ifMember(presentVersions -> {
-                    generateTargetFromJson(new Target(field,
-                        sourceVariable,
-                        className,
-                        input -> String.format("this.%s = %s", field.camelCaseName(), input)),
-                        curVersions);
-                }).ifNotMember(__ -> {
-                    buffer.printf("throw new RuntimeException(\"%s: field \'%s\' is not " +
-                        "supported in version \" + _version);%n",
-                        className, field.camelCaseName());
-                }).
-                generate(buffer);
-            buffer.decrementIndent();
-            buffer.printf("}%n");
-        }
-        buffer.decrementIndent();
-        buffer.printf("}%n");
-    }
-
-    private void generateTargetFromJson(Target target, Versions curVersions) {
-        if (target.field().type() instanceof FieldType.BoolFieldType) {
-            buffer.printf("if (!%s.isBoolean()) {%n", target.sourceVariable());
-            buffer.incrementIndent();
-            buffer.printf("throw new RuntimeException(\"%s expected Boolean type, " +
-                "but got \" + _node.getNodeType());%n", target.humanReadableName());
-            buffer.decrementIndent();
-            buffer.printf("}%n");
-            buffer.printf("%s;%n", target.assignmentStatement(
-                target.sourceVariable() + ".asBoolean()"));
-        } else if (target.field().type() instanceof FieldType.Int8FieldType) {
-            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("MessageUtil.jsonNodeToByte(%s, \"%s\")",
-                    target.sourceVariable(), target.humanReadableName())));
-        } else if (target.field().type() instanceof FieldType.Int16FieldType) {
-            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("MessageUtil.jsonNodeToShort(%s, \"%s\")",
-                    target.sourceVariable(), target.humanReadableName())));
-        } else if (target.field().type() instanceof FieldType.Int32FieldType) {
-            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("MessageUtil.jsonNodeToInt(%s, \"%s\")",
-                    target.sourceVariable(), target.humanReadableName())));
-        } else if (target.field().type() instanceof FieldType.Int64FieldType) {
-            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("MessageUtil.jsonNodeToLong(%s, \"%s\")",
-                    target.sourceVariable(), target.humanReadableName())));
-        } else if (target.field().type() instanceof FieldType.UUIDFieldType) {
-            buffer.printf("if (!%s.isTextual()) {%n", target.sourceVariable());
-            buffer.incrementIndent();
-            buffer.printf("throw new RuntimeException(\"%s expected a JSON string " +
-                "type, but got \" + _node.getNodeType());%n", target.humanReadableName());
-            buffer.decrementIndent();
-            buffer.printf("}%n");
-            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(String.format(
-                "UUID.fromString(%s.asText())", target.sourceVariable())));
-        } else if (target.field().type() instanceof FieldType.Float64FieldType) {
-            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("MessageUtil.jsonNodeToDouble(%s, \"%s\")",
-                    target.sourceVariable(), target.humanReadableName())));
-        } else {
-            // Handle the variable length types.  All of them are potentially
-            // nullable, so handle that here.
-            IsNullConditional.forName(target.sourceVariable()).
-                nullableVersions(target.field().nullableVersions()).
-                possibleVersions(curVersions).
-                conditionalGenerator((name, negated) ->
-                    String.format("%s%s.isNull()", negated ? "!" : "", name)).
-                ifNull(() -> {
-                    buffer.printf("%s;%n", target.assignmentStatement("null"));
-                }).
-                ifShouldNotBeNull(() -> {
-                    generateVariableLengthTargetFromJson(target, curVersions);
-                }).
-                generate(buffer);
-        }
-    }
-
-    private void generateVariableLengthTargetFromJson(Target target, Versions curVersions) {
-        if (target.field().type().isString()) {
-            buffer.printf("if (!%s.isTextual()) {%n", target.sourceVariable());
-            buffer.incrementIndent();
-            buffer.printf("throw new RuntimeException(\"%s expected a string " +
-                "type, but got \" + _node.getNodeType());%n", target.humanReadableName());
-            buffer.decrementIndent();
-            buffer.printf("}%n");
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("%s.asText()", target.sourceVariable())));
-        } else if (target.field().type().isBytes()) {
-            headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-            if (target.field().zeroCopy()) {
-                headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);
-                buffer.printf("%s;%n", target.assignmentStatement(
-                    String.format("ByteBuffer.wrap(MessageUtil.jsonNodeToBinary(%s, \"%s\"))",
-                        target.sourceVariable(), target.humanReadableName())));
-            } else {
-                buffer.printf("%s;%n", target.assignmentStatement(
-                    String.format("MessageUtil.jsonNodeToBinary(%s, \"%s\")",
-                        target.sourceVariable(), target.humanReadableName())));
-            }
-        } else if (target.field().type().isRecords()) {
-            headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);
-            headerGenerator.addImport(MessageGenerator.MEMORY_RECORDS_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                    String.format("MemoryRecords.readableRecords(ByteBuffer.wrap(MessageUtil.jsonNodeToBinary(%s, \"%s\")))",
-                            target.sourceVariable(), target.humanReadableName())));
-        } else if (target.field().type().isArray()) {
-            buffer.printf("if (!%s.isArray()) {%n", target.sourceVariable());
-            buffer.incrementIndent();
-            buffer.printf("throw new RuntimeException(\"%s expected a JSON " +
-                "array, but got \" + _node.getNodeType());%n", target.humanReadableName());
-            buffer.decrementIndent();
-            buffer.printf("}%n");
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("new %s()", fieldConcreteJavaType(target.field()))));
-            headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);
-            buffer.printf("for (JsonNode _element : %s) {%n", target.sourceVariable());
-            buffer.incrementIndent();
-            generateTargetFromJson(target.arrayElementTarget(
-                input -> String.format("%s.add(%s)", target.field().camelCaseName(), input)),
-                curVersions);
-            buffer.decrementIndent();
-            buffer.printf("}%n");
-        } else if (target.field().type().isStruct()) {
-            buffer.printf("%s;%n", target.assignmentStatement(String.format("new %s(%s, _version)",
-                target.field().type().toString(),
-                target.sourceVariable())));
-        } else {
-            throw new RuntimeException("Unexpected type " + target.field().type());
-        }
-    }
-
-    private void generateClassToJson(String className, StructSpec struct,
-                                     Versions parentVersions) {
-        headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);
-        buffer.printf("@Override%n");
-        buffer.printf("public JsonNode toJson(short _version) {%n");
-        buffer.incrementIndent();
-        VersionConditional.forVersions(struct.versions(), parentVersions).
-            allowMembershipCheckAlwaysFalse(false).
-            ifNotMember(__ -> {
-                headerGenerator.addImport(MessageGenerator.UNSUPPORTED_VERSION_EXCEPTION_CLASS);
-                buffer.printf("throw new UnsupportedVersionException(\"Can't write " +
-                    "version \" + _version + \" of %s\");%n", className);
-            }).
-            generate(buffer);
-        Versions curVersions = parentVersions.intersect(struct.versions());
-        headerGenerator.addImport(MessageGenerator.OBJECT_NODE_CLASS);
-        headerGenerator.addImport(MessageGenerator.JSON_NODE_FACTORY_CLASS);
-        buffer.printf("ObjectNode _node = new ObjectNode(JsonNodeFactory.instance);%n");
-        for (FieldSpec field : struct.fields()) {
-            Target target = new Target(field,
-                String.format("this.%s", field.camelCaseName()),
-                field.camelCaseName(),
-                input -> String.format("_node.set(\"%s\", %s)", field.camelCaseName(), input));
-            VersionConditional cond = VersionConditional.forVersions(field.versions(), curVersions).
-                ifMember(presentVersions -> {
-                    VersionConditional.forVersions(field.taggedVersions(), presentVersions).
-                        ifMember(presentAndTaggedVersions -> {
-                            generateNonDefaultValueCheck(field, field.nullableVersions());
-                            buffer.incrementIndent();
-                            if (field.defaultString().equals("null")) {
-                                // If the default was null, and we already checked that this field was not
-                                // the default, we can omit further null checks.
-                                generateTargetToJson(target.nonNullableCopy(), presentAndTaggedVersions);
-                            } else {
-                                generateTargetToJson(target, presentAndTaggedVersions);
-                            }
-                            buffer.decrementIndent();
-                            buffer.printf("}%n");
-                        }).
-                        ifNotMember(presentAndNotTaggedVersions -> {
-                            generateTargetToJson(target, presentAndNotTaggedVersions);
-                        }).
-                        generate(buffer);
-                });
-            if (!field.ignorable()) {
-                cond.ifNotMember(__ -> {
-                    generateNonIgnorableFieldCheck(field);
-                });
-            }
-            cond.generate(buffer);
-        }
-        buffer.printf("return _node;%n");
-        buffer.decrementIndent();
-        buffer.printf("}%n");
-    }
-
-    private void generateTargetToJson(Target target, Versions versions) {
-        if (target.field().type() instanceof FieldType.BoolFieldType) {
-            headerGenerator.addImport(MessageGenerator.BOOLEAN_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("BooleanNode.valueOf(%s)", target.sourceVariable())));
-        } else if ((target.field().type() instanceof FieldType.Int8FieldType) ||
-                   (target.field().type() instanceof FieldType.Int16FieldType)) {
-            headerGenerator.addImport(MessageGenerator.SHORT_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("new ShortNode(%s)", target.sourceVariable())));
-        } else if (target.field().type() instanceof FieldType.Int32FieldType) {
-            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("new IntNode(%s)", target.sourceVariable())));
-        } else if (target.field().type() instanceof FieldType.Int64FieldType) {
-            headerGenerator.addImport(MessageGenerator.LONG_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("new LongNode(%s)", target.sourceVariable())));
-        } else if (target.field().type() instanceof FieldType.UUIDFieldType) {
-            headerGenerator.addImport(MessageGenerator.TEXT_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("new TextNode(%s.toString())", target.sourceVariable())));
-        } else if (target.field().type() instanceof FieldType.Float64FieldType) {
-            headerGenerator.addImport(MessageGenerator.DOUBLE_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("new DoubleNode(%s)", target.sourceVariable())));
-        } else {
-            // Handle the variable length types.  All of them are potentially
-            // nullable, so handle that here.
-            IsNullConditional.forName(target.sourceVariable()).
-                nullableVersions(target.field().nullableVersions()).
-                possibleVersions(versions).
-                conditionalGenerator((name, negated) ->
-                    String.format("%s %s= null", name, negated ? "!" : "=")).
-                ifNull(() -> {
-                    headerGenerator.addImport(MessageGenerator.NULL_NODE_CLASS);
-                    buffer.printf("%s;%n", target.assignmentStatement("NullNode.instance"));
-                }).
-                ifShouldNotBeNull(() -> {
-                    generateVariableLengthTargetToJson(target, versions);
-                }).
-                generate(buffer);
-        }
-    }
-
-    private void generateVariableLengthTargetToJson(Target target, Versions versions) {
-        if (target.field().type().isString()) {
-            headerGenerator.addImport(MessageGenerator.TEXT_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("new TextNode(%s)", target.sourceVariable())));
-        } else if (target.field().type().isBytes()) {
-            headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);
-            if (target.field().zeroCopy()) {
-                headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-                buffer.printf("%s;%n", target.assignmentStatement(
-                    String.format("new BinaryNode(MessageUtil.byteBufferToArray(%s))",
-                        target.sourceVariable())));
-            } else {
-                headerGenerator.addImport(MessageGenerator.ARRAYS_CLASS);
-                buffer.printf("%s;%n", target.assignmentStatement(
-                    String.format("new BinaryNode(Arrays.copyOf(%s, %s.length))",
-                        target.sourceVariable(), target.sourceVariable())));
-            }
-        } else if (target.field().type().isRecords()) {
-            headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);
-            buffer.printf("%s;%n", target.assignmentStatement("new BinaryNode(new byte[]{})"));
-        } else if (target.field().type().isArray()) {
-            headerGenerator.addImport(MessageGenerator.ARRAY_NODE_CLASS);
-            headerGenerator.addImport(MessageGenerator.JSON_NODE_FACTORY_CLASS);
-            FieldType.ArrayType arrayType = (FieldType.ArrayType) target.field().type();
-            FieldType elementType = arrayType.elementType();
-            String arrayInstanceName = String.format("_%sArray", target.field().camelCaseName());
-            buffer.printf("ArrayNode %s = new ArrayNode(JsonNodeFactory.instance);%n", arrayInstanceName);
-            buffer.printf("for (%s _element : %s) {%n",
-                getBoxedJavaType(elementType), target.sourceVariable());
-            buffer.incrementIndent();
-            generateTargetToJson(target.arrayElementTarget(
-                input -> String.format("%s.add(%s)", arrayInstanceName, input)),
-                versions);
-            buffer.decrementIndent();
-            buffer.printf("}%n");
-            buffer.printf("%s;%n", target.assignmentStatement(arrayInstanceName));
-        } else if (target.field().type().isStruct()) {
-            buffer.printf("%s;%n", target.assignmentStatement(
-                String.format("%s.toJson(_version)", target.sourceVariable())));
-        } else {
-            throw new RuntimeException("unknown type " + target.field().type());
-        }
-    }
-
     private void generateArrayFromStruct(FieldSpec field, Versions versions) {
         IsNullConditional.forName("_nestedObjects").
             possibleVersions(versions).
@@ -1182,7 +810,8 @@ public final class MessageDataGenerator {
                 FieldType.ArrayType arrayType = (FieldType.ArrayType) field.type();
                 FieldType elementType = arrayType.elementType();
                 buffer.printf("this.%s = new %s(_nestedObjects.length);%n",
-                    field.camelCaseName(), fieldConcreteJavaType(field));
+                    field.camelCaseName(),
+                    field.concreteJavaType(headerGenerator, structRegistry));
                 buffer.printf("for (Object nestedObject : _nestedObjects) {%n");
                 buffer.incrementIndent();
                 if (elementType.isStruct()) {
@@ -1191,7 +820,8 @@ public final class MessageDataGenerator {
                         field.camelCaseName(), elementType.toString());
                 } else {
                     buffer.printf("this.%s.add((%s) nestedObject);%n",
-                        field.camelCaseName(), getBoxedJavaType(elementType));
+                        field.camelCaseName(),
+                        elementType.getBoxedJavaType(headerGenerator));
                 }
                 buffer.decrementIndent();
                 buffer.printf("}%n");
@@ -1199,31 +829,6 @@ public final class MessageDataGenerator {
             generate(buffer);
     }
 
-    private String getBoxedJavaType(FieldType type) {
-        if (type instanceof FieldType.BoolFieldType) {
-            return "Boolean";
-        } else if (type instanceof FieldType.Int8FieldType) {
-            return "Byte";
-        } else if (type instanceof FieldType.Int16FieldType) {
-            return "Short";
-        } else if (type instanceof FieldType.Int32FieldType) {
-            return "Integer";
-        } else if (type instanceof FieldType.Int64FieldType) {
-            return "Long";
-        } else if (type instanceof FieldType.UUIDFieldType) {
-            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
-            return "UUID";
-        } else if (type instanceof FieldType.Float64FieldType) {
-            return "Double";
-        } else if (type.isString()) {
-            return "String";
-        } else if (type.isStruct()) {
-            return type.toString();
-        } else {
-            throw new RuntimeException("Unsupported field type " + type);
-        }
-    }
-
     private String readFieldFromStruct(FieldType type, String name, boolean zeroCopy) {
         if (type instanceof FieldType.BoolFieldType) {
             return String.format("struct.getBoolean(\"%s\")", name);
@@ -1257,17 +862,6 @@ public final class MessageDataGenerator {
         }
     }
 
-    private void generateNonIgnorableFieldCheck(FieldSpec field) {
-        generateNonDefaultValueCheck(field, field.nullableVersions());
-        buffer.incrementIndent();
-        headerGenerator.addImport(MessageGenerator.UNSUPPORTED_VERSION_EXCEPTION_CLASS);
-        buffer.printf("throw new UnsupportedVersionException(" +
-                        "\"Attempted to write a non-default %s at version \" + _version);%n",
-                field.camelCaseName());
-        buffer.decrementIndent();
-        buffer.printf("}%n");
-    }
-
     private void generateClassWriter(String className, StructSpec struct,
             Versions parentVersions) {
         headerGenerator.addImport(MessageGenerator.WRITABLE_CLASS);
@@ -1321,7 +915,8 @@ public final class MessageDataGenerator {
                             }
                         }).
                         ifMember(__ -> {
-                            generateNonDefaultValueCheck(field, field.nullableVersions());
+                            field.generateNonDefaultValueCheck(headerGenerator,
+                                structRegistry, buffer, "this.", field.nullableVersions());
                             buffer.incrementIndent();
                             buffer.printf("_numTaggedFields++;%n");
                             buffer.decrementIndent();
@@ -1335,7 +930,8 @@ public final class MessageDataGenerator {
                 });
             if (!field.ignorable()) {
                 cond.ifNotMember(__ -> {
-                    generateNonIgnorableFieldCheck(field);
+                    field.generateNonIgnorableFieldCheck(headerGenerator,
+                        structRegistry, "this.", buffer);
                 });
             }
             cond.generate(buffer);
@@ -1364,7 +960,8 @@ public final class MessageDataGenerator {
                                 alwaysEmitBlockScope(true).
                                 ifShouldNotBeNull(() -> {
                                     if (!field.defaultString().equals("null")) {
-                                        generateNonDefaultValueCheck(field, Versions.NONE);
+                                        field.generateNonDefaultValueCheck(headerGenerator,
+                                            structRegistry, buffer, "this.", Versions.NONE);
                                         buffer.incrementIndent();
                                     }
                                     buffer.printf("_writable.writeUnsignedVarint(%d);%n", field.tag().get());
@@ -1560,7 +1157,7 @@ public final class MessageDataGenerator {
                     FieldType elementType = arrayType.elementType();
                     String elementName = String.format("%sElement", name);
                     buffer.printf("for (%s %s : %s) {%n",
-                        getBoxedJavaType(elementType),
+                        elementType.getBoxedJavaType(headerGenerator),
                         elementName,
                         name);
                     buffer.incrementIndent();
@@ -1584,55 +1181,6 @@ public final class MessageDataGenerator {
             generate(buffer);
     }
 
-    private void generateNonDefaultValueCheck(FieldSpec field, Versions nullableVersions) {
-        if (field.type().isArray()) {
-            if (fieldDefault(field).equals("null")) {
-                buffer.printf("if (%s != null) {%n",
-                    field.camelCaseName());
-            } else if (nullableVersions.empty()) {
-                buffer.printf("if (!%s.isEmpty()) {%n",
-                    field.camelCaseName());
-            } else {
-                buffer.printf("if (%s == null || !%s.isEmpty()) {%n",
-                    field.camelCaseName(), field.camelCaseName());
-            }
-        } else if (field.type().isBytes()) {
-            if (fieldDefault(field).equals("null")) {
-                buffer.printf("if (%s != null) {%n", field.camelCaseName());
-            } else if (nullableVersions.empty()) {
-                if (field.zeroCopy()) {
-                    buffer.printf("if (%s.hasRemaining()) {%n", field.camelCaseName());
-                } else {
-                    buffer.printf("if (%s.length != 0) {%n", field.camelCaseName());
-                }
-            } else {
-                if (field.zeroCopy()) {
-                    buffer.printf("if (%s == null || %s.remaining() > 0) {%n",
-                        field.camelCaseName(), field.camelCaseName());
-                } else {
-                    buffer.printf("if (%s == null || %s.length != 0) {%n",
-                        field.camelCaseName(), field.camelCaseName());
-                }
-            }
-        } else if (field.type().isString() || field.type().isStruct()) {
-            if (fieldDefault(field).equals("null")) {
-                buffer.printf("if (%s != null) {%n", field.camelCaseName());
-            } else if (nullableVersions.empty()) {
-                buffer.printf("if (!%s.equals(%s)) {%n",
-                    field.camelCaseName(), fieldDefault(field));
-            } else {
-                buffer.printf("if (%s == null || !%s.equals(%s)) {%n",
-                    field.camelCaseName(), field.camelCaseName(), fieldDefault(field));
-            }
-        } else if (field.type() instanceof FieldType.BoolFieldType) {
-            buffer.printf("if (%s%s) {%n",
-                fieldDefault(field).equals("true") ? "!" : "",
-                field.camelCaseName());
-        } else {
-            buffer.printf("if (%s != %s) {%n", field.camelCaseName(), fieldDefault(field));
-        }
-    }
-
     private void generateClassToStruct(String className, StructSpec struct,
                                        Versions parentVersions) {
         headerGenerator.addImport(MessageGenerator.STRUCT_CLASS);
@@ -1665,7 +1213,8 @@ public final class MessageDataGenerator {
                             generateFieldToStruct(field, presentAndUntaggedVersions);
                         }).
                         ifMember(presentAndTaggedVersions -> {
-                            generateNonDefaultValueCheck(field, field.nullableVersions());
+                            field.generateNonDefaultValueCheck(headerGenerator,
+                                structRegistry, buffer, "this.", field.nullableVersions());
                             buffer.incrementIndent();
                             generateTaggedFieldToMap(field, presentAndTaggedVersions);
                             buffer.decrementIndent();
@@ -1675,7 +1224,8 @@ public final class MessageDataGenerator {
                 });
             if (!field.ignorable()) {
                 cond.ifNotMember(__ -> {
-                    generateNonIgnorableFieldCheck(field);
+                    field.generateNonIgnorableFieldCheck(headerGenerator,
+                        structRegistry, "this.", buffer);
                 });
             }
             cond.generate(buffer);
@@ -1782,12 +1332,13 @@ public final class MessageDataGenerator {
     private void generateFieldToObjectArray(FieldSpec field) {
         FieldType.ArrayType arrayType = (FieldType.ArrayType) field.type();
         FieldType elementType = arrayType.elementType();
-        String boxdElementType = elementType.isStruct() ? "Struct" : getBoxedJavaType(elementType);
+        String boxdElementType = elementType.isStruct() ? "Struct" :
+            elementType.getBoxedJavaType(headerGenerator);
         buffer.printf("%s[] _nestedObjects = new %s[%s.size()];%n",
             boxdElementType, boxdElementType, field.camelCaseName());
         buffer.printf("int i = 0;%n");
         buffer.printf("for (%s element : this.%s) {%n",
-            getBoxedJavaType(arrayType.elementType()), field.camelCaseName());
+            arrayType.elementType().getBoxedJavaType(headerGenerator), field.camelCaseName());
         buffer.incrementIndent();
         if (elementType.isStruct()) {
             buffer.printf("_nestedObjects[i++] = element.toStruct(_version);%n");
@@ -1908,7 +1459,8 @@ public final class MessageDataGenerator {
         if (tagged) {
             // Check to see that the field is not set to the default value.
             // If it is, then we don't need to serialize it.
-            generateNonDefaultValueCheck(field, field.nullableVersions());
+            field.generateNonDefaultValueCheck(headerGenerator, structRegistry, buffer,
+                "this.", field.nullableVersions());
             buffer.incrementIndent();
             buffer.printf("_numTaggedFields++;%n");
             buffer.printf("_size += %d;%n",
@@ -1961,7 +1513,8 @@ public final class MessageDataGenerator {
             ifShouldNotBeNull(() -> {
                 if (tagged) {
                     if (!field.defaultString().equals("null")) {
-                        generateNonDefaultValueCheck(field, Versions.NONE);
+                        field.generateNonDefaultValueCheck(headerGenerator,
+                            structRegistry, buffer, "this.", Versions.NONE);
                         buffer.incrementIndent();
                     }
                     buffer.printf("_numTaggedFields++;%n");
@@ -2014,7 +1567,8 @@ public final class MessageDataGenerator {
                             "(use a struct).");
                     } else {
                         buffer.printf("for (%s %sElement : %s) {%n",
-                            getBoxedJavaType(elementType), field.camelCaseName(), field.camelCaseName());
+                            elementType.getBoxedJavaType(headerGenerator),
+                            field.camelCaseName(), field.camelCaseName());
                         buffer.incrementIndent();
                         generateVariableLengthArrayElementSize(fieldFlexibleVersions(field),
                             String.format("%sElement", field.camelCaseName()),
@@ -2282,12 +1836,13 @@ public final class MessageDataGenerator {
                 cond.ifShouldNotBeNull(() -> {
                     String newArrayName =
                         String.format("new%s", field.capitalizedCamelCaseName());
+                    String type = field.concreteJavaType(headerGenerator, structRegistry);
                     buffer.printf("%s %s = new %s(%s.size());%n",
-                        fieldConcreteJavaType(field), newArrayName,
-                        fieldConcreteJavaType(field), target.sourceVariable());
+                        type, newArrayName, type, target.sourceVariable());
                     FieldType.ArrayType arrayType = (FieldType.ArrayType) field.type();
                     buffer.printf("for (%s _element : %s) {%n",
-                        getBoxedJavaType(arrayType.elementType()), target.sourceVariable());
+                        arrayType.elementType().getBoxedJavaType(headerGenerator),
+                        target.sourceVariable());
                     buffer.incrementIndent();
                     generateFieldDuplicate(target.arrayElementTarget(input ->
                         String.format("%s.add(%s)", newArrayName, input)));
@@ -2322,8 +1877,7 @@ public final class MessageDataGenerator {
 
     private void generateFieldToString(String prefix, FieldSpec field) {
         if (field.type() instanceof FieldType.BoolFieldType) {
-            buffer.printf("+ \"%s%s=\" + (%s ? \"true\" : \"false\")%n",
-                prefix, field.camelCaseName(), field.camelCaseName());
+            buffer.printf("+ \"%s%s=\" + (%s ? \"true\" : \"false\")%n", prefix, field.camelCaseName(), field.camelCaseName());
         } else if ((field.type() instanceof FieldType.Int8FieldType) ||
                 (field.type() instanceof FieldType.Int16FieldType) ||
                 (field.type() instanceof FieldType.Int32FieldType) ||
@@ -2366,163 +1920,10 @@ public final class MessageDataGenerator {
         }
     }
 
-    private String fieldDefault(FieldSpec field) {
-        if (field.type() instanceof FieldType.BoolFieldType) {
-            if (field.defaultString().isEmpty()) {
-                return "false";
-            } else if (field.defaultString().equalsIgnoreCase("true")) {
-                return "true";
-            } else if (field.defaultString().equalsIgnoreCase("false")) {
-                return "false";
-            } else {
-                throw new RuntimeException("Invalid default for boolean field " +
-                    field.name() + ": " + field.defaultString());
-            }
-        } else if ((field.type() instanceof FieldType.Int8FieldType) ||
-                   (field.type() instanceof FieldType.Int16FieldType) ||
-                   (field.type() instanceof FieldType.Int32FieldType) ||
-                   (field.type() instanceof FieldType.Int64FieldType)) {
-            int base = 10;
-            String defaultString = field.defaultString();
-            if (defaultString.startsWith("0x")) {
-                base = 16;
-                defaultString = defaultString.substring(2);
-            }
-            if (field.type() instanceof FieldType.Int8FieldType) {
-                if (defaultString.isEmpty()) {
-                    return "(byte) 0";
-                } else {
-                    try {
-                        Byte.valueOf(defaultString, base);
-                    } catch (NumberFormatException e) {
-                        throw new RuntimeException("Invalid default for int8 field " +
-                            field.name() + ": " + defaultString, e);
-                    }
-                    return "(byte) " + field.defaultString();
-                }
-            } else if (field.type() instanceof FieldType.Int16FieldType) {
-                if (defaultString.isEmpty()) {
-                    return "(short) 0";
-                } else {
-                    try {
-                        Short.valueOf(defaultString, base);
-                    } catch (NumberFormatException e) {
-                        throw new RuntimeException("Invalid default for int16 field " +
-                            field.name() + ": " + field.defaultString(), e);
-                    }
-                    return "(short) " + field.defaultString();
-                }
-            } else if (field.type() instanceof FieldType.Int32FieldType) {
-                if (defaultString.isEmpty()) {
-                    return "0";
-                } else {
-                    try {
-                        Integer.valueOf(defaultString, base);
-                    } catch (NumberFormatException e) {
-                        throw new RuntimeException("Invalid default for int32 field " +
-                            field.name() + ": " + field.defaultString(), e);
-                    }
-                    return field.defaultString();
-                }
-            } else if (field.type() instanceof FieldType.Int64FieldType) {
-                if (defaultString.isEmpty()) {
-                    return "0L";
-                } else {
-                    try {
-                        Long.valueOf(defaultString, base);
-                    } catch (NumberFormatException e) {
-                        throw new RuntimeException("Invalid default for int64 field " +
-                            field.name() + ": " + field.defaultString(), e);
-                    }
-                    return field.defaultString() + "L";
-                }
-            } else {
-                throw new RuntimeException("Unsupported field type " + field.type());
-            }
-        } else if (field.type() instanceof FieldType.UUIDFieldType) {
-            headerGenerator.addImport(MessageGenerator.UUID_CLASS);
-            if (field.defaultString().isEmpty()) {
-                headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);
-                return "MessageUtil.ZERO_UUID";
-            } else {
-                try {
-                    UUID.fromString(field.defaultString());
-                } catch (IllegalArgumentException e) {
-                    throw new RuntimeException("Invalid default for uuid field " +
-                        field.name() + ": " + field.defaultString(), e);
-                }
-                headerGenerator.addImport(MessageGenerator.UUID_CLASS);
-                return "UUID.fromString(\"" + field.defaultString() + "\")";
-            }
-        } else if (field.type() instanceof FieldType.Float64FieldType) {
-            if (field.defaultString().isEmpty()) {
-                return "0.0";
-            } else {
-                try {
-                    Double.parseDouble(field.defaultString());
-                } catch (NumberFormatException e) {
-                    throw new RuntimeException("Invalid default for float64 field " +
-                        field.name() + ": " + field.defaultString(), e);
-                }
-                return "Double.parseDouble(\"" + field.defaultString() + "\")";
-            }
-        } else if (field.type() instanceof FieldType.StringFieldType) {
-            if (field.defaultString().equals("null")) {
-                validateNullDefault(field);
-                return "null";
-            } else {
-                return "\"" + field.defaultString() + "\"";
-            }
-        } else if (field.type().isBytes()) {
-            if (field.defaultString().equals("null")) {
-                validateNullDefault(field);
-                return "null";
-            } else if (!field.defaultString().isEmpty()) {
-                throw new RuntimeException("Invalid default for bytes field " +
-                        field.name() + ".  The only valid default for a bytes field " +
-                        "is empty or null.");
-            }
-            if (field.zeroCopy()) {
-                headerGenerator.addImport(MessageGenerator.BYTE_UTILS_CLASS);
-                return "ByteUtils.EMPTY_BUF";
-            } else {
-                headerGenerator.addImport(MessageGenerator.BYTES_CLASS);
-                return "Bytes.EMPTY";
-            }
-        } else if (field.type().isRecords()) {
-            return "null";
-        } else if (field.type().isStruct()) {
-            if (!field.defaultString().isEmpty()) {
-                throw new RuntimeException("Invalid default for struct field " +
-                    field.name() + ": custom defaults are not supported for struct fields.");
-            }
-            return "new " + field.type().toString() + "()";
-        } else if (field.type().isArray()) {
-            if (field.defaultString().equals("null")) {
-                validateNullDefault(field);
-                return "null";
-            } else if (!field.defaultString().isEmpty()) {
-                throw new RuntimeException("Invalid default for array field " +
-                    field.name() + ".  The only valid default for an array field " +
-                        "is the empty array or null.");
-            }
-            return String.format("new %s(0)", fieldConcreteJavaType(field));
-        } else {
-            throw new RuntimeException("Unsupported field type " + field.type());
-        }
-    }
-
-    private void validateNullDefault(FieldSpec field) {
-        if (!(field.nullableVersions().contains(field.versions()))) {
-            throw new RuntimeException("null cannot be the default for field " +
-                    field.name() + ", because not all versions of this field are " +
-                    "nullable.");
-        }
-    }
-
     private void generateFieldAccessor(FieldSpec field) {
         buffer.printf("%n");
-        generateAccessor(fieldAbstractJavaType(field), field.camelCaseName(),
+        generateAccessor(field.fieldAbstractJavaType(headerGenerator, structRegistry),
+            field.camelCaseName(),
             field.camelCaseName());
     }
 
@@ -2539,7 +1940,7 @@ public final class MessageDataGenerator {
         buffer.printf("public %s set%s(%s v) {%n",
             className,
             field.capitalizedCamelCaseName(),
-            fieldAbstractJavaType(field));
+            field.fieldAbstractJavaType(headerGenerator, structRegistry));
         buffer.incrementIndent();
         buffer.printf("this.%s = v;%n", field.camelCaseName());
         buffer.printf("return this;%n");
@@ -2569,4 +1970,5 @@ public final class MessageDataGenerator {
             return messageFlexibleVersions;
         }
     }
+
 }
diff --git a/generator/src/main/java/org/apache/kafka/message/MessageGenerator.java b/generator/src/main/java/org/apache/kafka/message/MessageGenerator.java
index 74d85b0552..030be39c71 100644
--- a/generator/src/main/java/org/apache/kafka/message/MessageGenerator.java
+++ b/generator/src/main/java/org/apache/kafka/message/MessageGenerator.java
@@ -22,15 +22,23 @@ import com.fasterxml.jackson.core.JsonParser;
 import com.fasterxml.jackson.databind.DeserializationFeature;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.SerializationFeature;
+import net.sourceforge.argparse4j.ArgumentParsers;
+import net.sourceforge.argparse4j.inf.ArgumentParser;
+import net.sourceforge.argparse4j.inf.Namespace;
 
 import java.io.BufferedWriter;
 import java.nio.file.DirectoryStream;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Locale;
 
+import static net.sourceforge.argparse4j.impl.Arguments.store;
+
 /**
  * The Kafka message generator.
  */
@@ -159,9 +167,8 @@ public final class MessageGenerator {
 
     private static TypeClassGenerator createTypeClassGenerator(String packageName,
                                                                String type) {
+        if (type == null) return null;
         switch (type) {
-            case "none":
-                return null;
             case "ApiMessageTypeGenerator":
                 return new ApiMessageTypeGenerator(packageName);
             default:
@@ -169,10 +176,30 @@ public final class MessageGenerator {
         }
     }
 
+    private static List<MessageClassGenerator> createMessageClassGenerators(String packageName,
+                                                                            List<String> types) {
+        if (types == null) return Collections.emptyList();
+        List<MessageClassGenerator> generators = new ArrayList<>();
+        for (String type : types) {
+            switch (type) {
+                case "MessageDataGenerator":
+                    generators.add(new MessageDataGenerator(packageName));
+                    break;
+                case "JsonConverterGenerator":
+                    generators.add(new JsonConverterGenerator(packageName));
+                    break;
+                default:
+                    throw new RuntimeException("Unknown message class generator type '" + type + "'");
+            }
+        }
+        return generators;
+    }
+
     public static void processDirectories(String packageName,
                                           String outputDir,
                                           String inputDir,
-                                          String typeClassGeneratorType) throws Exception {
+                                          String typeClassGeneratorType,
+                                          List<String> messageClassGeneratorTypes) throws Exception {
         Files.createDirectories(Paths.get(outputDir));
         int numProcessed = 0;
         TypeClassGenerator typeClassGenerator =
@@ -184,13 +211,15 @@ public final class MessageGenerator {
                 try {
                     MessageSpec spec = JSON_SERDE.
                         readValue(inputPath.toFile(), MessageSpec.class);
-                    String javaName = spec.generatedClassName() + JAVA_SUFFIX;
-                    outputFileNames.add(javaName);
-                    Path outputPath = Paths.get(outputDir, javaName);
-                    try (BufferedWriter writer = Files.newBufferedWriter(outputPath)) {
-                        MessageDataGenerator generator = new MessageDataGenerator(packageName);
-                        generator.generate(spec);
-                        generator.write(writer);
+                    List<MessageClassGenerator> generators =
+                        createMessageClassGenerators(packageName, messageClassGeneratorTypes);
+                    for (MessageClassGenerator generator : generators) {
+                        String name = generator.outputName(spec) + JAVA_SUFFIX;
+                        outputFileNames.add(name);
+                        Path outputPath = Paths.get(outputDir, name);
+                        try (BufferedWriter writer = Files.newBufferedWriter(outputPath)) {
+                            generator.generateAndWrite(spec, writer);
+                        }
                     }
                     numProcessed++;
                     if (typeClassGenerator != null) {
@@ -285,16 +314,38 @@ public final class MessageGenerator {
         return bytes;
     }
 
-    private final static String USAGE = "MessageGenerator: [output Java package] [output Java file] [input JSON file]";
-
     public static void main(String[] args) throws Exception {
-        if (args.length == 0) {
-            System.out.println(USAGE);
-            System.exit(0);
-        } else if (args.length != 4) {
-            System.out.println(USAGE);
-            System.exit(1);
-        }
-        processDirectories(args[0], args[1], args[2], args[3]);
+        ArgumentParser parser = ArgumentParsers
+            .newArgumentParser("message-generator")
+            .defaultHelp(true)
+            .description("The Kafka message generator");
+        parser.addArgument("--package", "-p")
+            .action(store())
+            .required(true)
+            .metavar("PACKAGE")
+            .help("The java package to use in generated files.");
+        parser.addArgument("--output", "-o")
+            .action(store())
+            .required(true)
+            .metavar("OUTPUT")
+            .help("The output directory to create.");
+        parser.addArgument("--input", "-i")
+            .action(store())
+            .required(true)
+            .metavar("INPUT")
+            .help("The input directory to use.");
+        parser.addArgument("--typeclass-generator", "-t")
+            .action(store())
+            .metavar("TYPECLASS_GENERATOR")
+            .help("The type class generator to use, if any.");
+        parser.addArgument("--message-class-generators", "-m")
+            .nargs("+")
+            .action(store())
+            .metavar("MESSAGE_CLASS_GENERATORS")
+            .help("The message class generators to use.");
+        Namespace res = parser.parseArgsOrFail(args);
+        processDirectories(res.getString("package"), res.getString("output"),
+            res.getString("input"), res.getString("typeclass_generator"),
+            res.getList("message_class_generators"));
     }
 }
diff --git a/generator/src/main/java/org/apache/kafka/message/MessageSpec.java b/generator/src/main/java/org/apache/kafka/message/MessageSpec.java
index 7666a66311..0b53cb1db0 100644
--- a/generator/src/main/java/org/apache/kafka/message/MessageSpec.java
+++ b/generator/src/main/java/org/apache/kafka/message/MessageSpec.java
@@ -106,7 +106,7 @@ public final class MessageSpec {
         return flexibleVersions.toString();
     }
 
-    public String generatedClassName() {
+    public String dataClassName() {
         switch (type) {
             case HEADER:
             case REQUEST:
diff --git a/generator/src/main/java/org/apache/kafka/message/SchemaGenerator.java b/generator/src/main/java/org/apache/kafka/message/SchemaGenerator.java
index e26dd29a46..b7ee175af2 100644
--- a/generator/src/main/java/org/apache/kafka/message/SchemaGenerator.java
+++ b/generator/src/main/java/org/apache/kafka/message/SchemaGenerator.java
@@ -82,7 +82,7 @@ final class SchemaGenerator {
     void generateSchemas(MessageSpec message) throws Exception {
         this.messageFlexibleVersions = message.flexibleVersions();
         // Generate schemas for inline structures
-        generateSchemas(message.generatedClassName(), message.struct(),
+        generateSchemas(message.dataClassName(), message.struct(),
             message.struct().versions());
 
         // Generate schemas for common structures
diff --git a/generator/src/main/java/org/apache/kafka/message/StructRegistry.java b/generator/src/main/java/org/apache/kafka/message/StructRegistry.java
index 1b54ec6153..4ed58a05a4 100644
--- a/generator/src/main/java/org/apache/kafka/message/StructRegistry.java
+++ b/generator/src/main/java/org/apache/kafka/message/StructRegistry.java
@@ -28,11 +28,38 @@ import java.util.TreeSet;
  * Contains structure data for Kafka MessageData classes.
  */
 final class StructRegistry {
-    private final Map<String, StructSpec> structSpecs;
+    private final Map<String, StructInfo> structs;
     private final Set<String> commonStructNames;
 
+    static class StructInfo {
+        /**
+         * The specification for this structure.
+         */
+        private final StructSpec spec;
+
+        /**
+         * The versions which the parent(s) of this structure can have.  If this is a
+         * top-level structure, this will be equal to the versions which the
+         * overall message can have.
+         */
+        private final Versions parentVersions;
+
+        StructInfo(StructSpec spec, Versions parentVersions) {
+            this.spec = spec;
+            this.parentVersions = parentVersions;
+        }
+
+        public StructSpec spec() {
+            return spec;
+        }
+
+        public Versions parentVersions() {
+            return parentVersions;
+        }
+    }
+
     StructRegistry() {
-        this.structSpecs = new TreeMap<>();
+        this.structs = new TreeMap<>();
         this.commonStructNames = new TreeSet<>();
     }
 
@@ -46,18 +73,18 @@ final class StructRegistry {
                 throw new RuntimeException("Can't process structure " + struct.name() +
                         ": the first letter of structure names must be capitalized.");
             }
-            if (structSpecs.put(struct.name(), struct) != null) {
+            if (structs.containsKey(struct.name())) {
                 throw new RuntimeException("Common struct " + struct.name() + " was specified twice.");
             }
+            structs.put(struct.name(), new StructInfo(struct, struct.versions()));
             commonStructNames.add(struct.name());
         }
-
         // Register inline structures.
-        addStructSpecs(message.fields());
+        addStructSpecs(message.validVersions(), message.fields());
     }
 
     @SuppressWarnings("unchecked")
-    private void addStructSpecs(List<FieldSpec> fields) {
+    private void addStructSpecs(Versions parentVersions, List<FieldSpec> fields) {
         for (FieldSpec field : fields) {
             String elementName = null;
             if (field.type().isStructArray()) {
@@ -66,7 +93,6 @@ final class StructRegistry {
             } else if (field.type().isStruct()) {
                 elementName = field.name();
             }
-
             if (elementName != null) {
                 if (commonStructNames.contains(elementName)) {
                     // If we're using a common structure, we can't specify its fields.
@@ -75,15 +101,18 @@ final class StructRegistry {
                         throw new RuntimeException("Can't re-specify the common struct " +
                                 elementName + " as an inline struct.");
                     }
-                } else if (structSpecs.put(elementName,
-                        new StructSpec(elementName,
-                                field.versions().toString(),
-                                field.fields())) != null) {
+                } else if (structs.containsKey(elementName)) {
                     // Inline structures should only appear once.
                     throw new RuntimeException("Struct " + elementName +
-                            " was specified twice.");
+                        " was specified twice.");
+                } else {
+                    // Synthesize a StructSpec object out of the fields.
+                    StructSpec spec = new StructSpec(elementName,
+                            field.versions().toString(),
+                            field.fields());
+                    structs.put(elementName, new StructInfo(spec, parentVersions));
                 }
-                addStructSpecs(field.fields());
+                addStructSpecs(parentVersions.intersect(field.versions()), field.fields());
             }
         }
     }
@@ -103,13 +132,12 @@ final class StructRegistry {
             throw new RuntimeException("Field " + field.name() +
                     " cannot be treated as a structure.");
         }
-        StructSpec struct = structSpecs.get(structFieldName);
-
-        if (struct == null) {
+        StructInfo structInfo = structs.get(structFieldName);
+        if (structInfo == null) {
             throw new RuntimeException("Unable to locate a specification for the structure " +
                     structFieldName);
         }
-        return struct;
+        return structInfo.spec;
     }
 
     /**
@@ -124,12 +152,12 @@ final class StructRegistry {
         if (!arrayType.isStructArray()) {
             return false;
         }
-        StructSpec struct = structSpecs.get(arrayType.elementName());
-        if (struct == null) {
+        StructInfo structInfo = structs.get(arrayType.elementName());
+        if (structInfo == null) {
             throw new RuntimeException("Unable to locate a specification for the structure " +
                     arrayType.elementName());
         }
-        return struct.hasKeys();
+        return structInfo.spec.hasKeys();
     }
 
     Set<String> commonStructNames() {
@@ -150,8 +178,12 @@ final class StructRegistry {
 
             @Override
             public StructSpec next() {
-                return structSpecs.get(iter.next());
+                return structs.get(iter.next()).spec;
             }
         };
     }
+
+    Iterator<StructInfo> structs() {
+        return structs.values().iterator();
+    }
 }
