<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:13:56 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-7119] Intermittent test failure with GSSAPI authentication failure</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-7119</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;I have seen this failure a couple of times in builds (e.g. &lt;a href=&quot;https://builds.apache.org/job/kafka-pr-jdk10-scala2.12/2412/testReport/junit/kafka.api/SaslSslAdminClientIntegrationTest/testLogStartOffsetCheckpoint/)&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/kafka-pr-jdk10-scala2.12/2412/testReport/junit/kafka.api/SaslSslAdminClientIntegrationTest/testLogStartOffsetCheckpoint/)&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;org.apache.kafka.common.errors.SaslAuthenticationException: An error: (java.security.PrivilegedActionException: javax.security.sasl.SaslException: GSS initiate failed &lt;span class=&quot;error&quot;&gt;&amp;#91;Caused by GSSException: No valid credentials provided (Mechanism level: Request is a replay (34) - Request is a replay)&amp;#93;&lt;/span&gt;) occurred when evaluating SASL token received from the Kafka Broker. Kafka Client will go to AUTHENTICATION_FAILED state. Caused by: javax.security.sasl.SaslException: GSS initiate failed &lt;span class=&quot;error&quot;&gt;&amp;#91;Caused by GSSException: No valid credentials provided (Mechanism level: Request is a replay (34) - Request is a replay)&amp;#93;&lt;/span&gt; at jdk.security.jgss/com.sun.security.sasl.gsskerb.GssKrb5Client.evaluateChallenge(GssKrb5Client.java:211) at org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$2.run(SaslClientAuthenticator.java:358) at org.apache.kafka.common.security.authenticator.SaslClientAuthenticator$2.run(SaslClientAuthenticator.java:356) at java.base/java.security.AccessController.doPrivileged(Native Method) at java.base/javax.security.auth.Subject.doAs(Subject.java:423) at org.apache.kafka.common.security.authenticator.SaslClientAuthenticator.createSaslToken(SaslClientAuthenticator.java:356) at org.apache.kafka.common.security.authenticator.SaslClientAuthenticator.sendSaslClientToken(SaslClientAuthenticator.java:268) at org.apache.kafka.common.security.authenticator.SaslClientAuthenticator.authenticate(SaslClientAuthenticator.java:205) at org.apache.kafka.common.network.KafkaChannel.prepare(KafkaChannel.java:127) at org.apache.kafka.common.network.Selector.pollSelectionKeys(Selector.java:487) at org.apache.kafka.common.network.Selector.poll(Selector.java:425) at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:510) at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:271) at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:242) at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:218) at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureCoordinatorReady(AbstractCoordinator.java:231) at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(ConsumerCoordinator.java:314) at org.apache.kafka.clients.consumer.KafkaConsumer.updateAssignmentMetadataIfNeeded(KafkaConsumer.java:1218) at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:1181) at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:1115) at kafka.api.AdminClientIntegrationTest.$anonfun$subscribeAndWaitForAssignment$2(AdminClientIntegrationTest.scala:980) at kafka.utils.TestUtils$.waitUntilTrue(TestUtils.scala:781) at kafka.api.AdminClientIntegrationTest.subscribeAndWaitForAssignment(AdminClientIntegrationTest.scala:979) at kafka.api.AdminClientIntegrationTest.testLogStartOffsetCheckpoint(AdminClientIntegrationTest.scala:755) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:564) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27) at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:298) at org.junit.internal.runners.statements.FailOnTimeout$CallableStatement.call(FailOnTimeout.java:292) at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264) at java.base/java.lang.Thread.run(Thread.java:844) Caused by: GSSException: No valid credentials provided (Mechanism level: Request is a replay (34) - Request is a replay) at java.security.jgss/sun.security.jgss.krb5.Krb5Context.initSecContext(Krb5Context.java:771) at java.security.jgss/sun.security.jgss.GSSContextImpl.initSecContext(GSSContextImpl.java:265) at java.security.jgss/sun.security.jgss.GSSContextImpl.initSecContext(GSSContextImpl.java:196) at jdk.security.jgss/com.sun.security.sasl.gsskerb.GssKrb5Client.evaluateChallenge(GssKrb5Client.java:192) ... 37 more Caused by: KrbException: Request is a replay (34) - Request is a replay at java.security.jgss/sun.security.krb5.KrbTgsRep.&amp;lt;init&amp;gt;(KrbTgsRep.java:73) at java.security.jgss/sun.security.krb5.KrbTgsReq.getReply(KrbTgsReq.java:251) at java.security.jgss/sun.security.krb5.KrbTgsReq.sendAndGetCreds(KrbTgsReq.java:262) at java.security.jgss/sun.security.krb5.internal.CredentialsUtil.serviceCreds(CredentialsUtil.java:308) at java.security.jgss/sun.security.krb5.internal.CredentialsUtil.acquireServiceCreds(CredentialsUtil.java:126) at java.security.jgss/sun.security.krb5.Credentials.acquireServiceCreds(Credentials.java:458) at java.security.jgss/sun.security.jgss.krb5.Krb5Context.initSecContext(Krb5Context.java:695) ... 40 more Caused by: KrbException: Identifier doesn&apos;t match expected value (906) at java.security.jgss/sun.security.krb5.internal.KDCRep.init(KDCRep.java:140) at java.security.jgss/sun.security.krb5.internal.TGSRep.init(TGSRep.java:65) at java.security.jgss/sun.security.krb5.internal.TGSRep.&amp;lt;init&amp;gt;(TGSRep.java:60) at java.security.jgss/sun.security.krb5.KrbTgsRep.&amp;lt;init&amp;gt;(KrbTgsRep.java:55)&lt;br/&gt;
... 46 more&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13169161">KAFKA-7119</key>
            <summary>Intermittent test failure with GSSAPI authentication failure</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rsivaram">Rajini Sivaram</assignee>
                                    <reporter username="rsivaram">Rajini Sivaram</reporter>
                        <labels>
                    </labels>
                <created>Fri, 29 Jun 2018 13:39:08 +0000</created>
                <updated>Thu, 16 Aug 2018 08:35:37 +0000</updated>
                            <resolved>Thu, 16 Aug 2018 08:35:37 +0000</resolved>
                                    <version>2.0.0</version>
                                    <fixVersion>1.0.3</fixVersion>
                    <fixVersion>1.1.2</fixVersion>
                    <fixVersion>2.0.1</fixVersion>
                    <fixVersion>2.1.0</fixVersion>
                                    <component>security</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16576023" author="githubbot" created="Fri, 10 Aug 2018 09:41:25 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #5487: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7119&quot; title=&quot;Intermittent test failure with GSSAPI authentication failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7119&quot;&gt;&lt;del&gt;KAFKA-7119&lt;/del&gt;&lt;/a&gt;: Handle transient Kerberos errors as non-fatal exceptions&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5487&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5487&lt;/a&gt;&lt;/p&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16580070" author="githubbot" created="Tue, 14 Aug 2018 17:00:57 +0000"  >&lt;p&gt;rajinisivaram closed pull request #5487: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7119&quot; title=&quot;Intermittent test failure with GSSAPI authentication failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7119&quot;&gt;&lt;del&gt;KAFKA-7119&lt;/del&gt;&lt;/a&gt;: Handle transient Kerberos errors as non-fatal exceptions&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5487&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5487&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java&lt;br/&gt;
index 2ef6d77f13f..8d6549d867c 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java&lt;br/&gt;
@@ -42,6 +42,7 @@&lt;br/&gt;
 import org.apache.kafka.common.requests.SaslHandshakeResponse;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.AuthenticateCallbackHandler;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipal;&lt;br/&gt;
+import org.apache.kafka.common.utils.Java;&lt;br/&gt;
 import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
@@ -51,6 +52,7 @@&lt;br/&gt;
 import javax.security.sasl.SaslClient;&lt;br/&gt;
 import javax.security.sasl.SaslException;&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
+import java.lang.reflect.Method;&lt;br/&gt;
 import java.nio.ByteBuffer;&lt;br/&gt;
 import java.nio.channels.SelectionKey;&lt;br/&gt;
 import java.security.Principal;&lt;br/&gt;
@@ -360,11 +362,9 @@ public void close() throws IOException {&lt;br/&gt;
                 });&lt;br/&gt;
         } catch (PrivilegedActionException e) {&lt;br/&gt;
             String error = &quot;An error: (&quot; + e + &quot;) occurred when evaluating SASL token received from the Kafka Broker.&quot;;&lt;br/&gt;
+            KerberosError kerberosError = KerberosError.fromException(e);&lt;br/&gt;
             // Try to provide hints to use about what went wrong so they can fix their configuration.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// TODO: introspect about e: look for GSS information.&lt;/li&gt;
	&lt;li&gt;final String unknownServerErrorText =&lt;/li&gt;
	&lt;li&gt;&quot;(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)&quot;;&lt;/li&gt;
	&lt;li&gt;if (e.toString().contains(unknownServerErrorText)) {&lt;br/&gt;
+            if (kerberosError == KerberosError.SERVER_NOT_FOUND) {&lt;br/&gt;
                 error += &quot; This may be caused by Java&apos;s being unable to resolve the Kafka Broker&apos;s&quot; +&lt;br/&gt;
                     &quot; hostname correctly. You may want to try to adding&quot; +&lt;br/&gt;
                     &quot; &apos;-Dsun.net.spi.nameservice.provider.1=dns,sun&apos; to your client&apos;s JVMFLAGS environment.&quot; +&lt;br/&gt;
@@ -373,7 +373,13 @@ public void close() throws IOException {&lt;br/&gt;
             }&lt;br/&gt;
             error += &quot; Kafka Client will go to AUTHENTICATION_FAILED state.&quot;;&lt;br/&gt;
             //Unwrap the SaslException inside `PrivilegedActionException`&lt;/li&gt;
	&lt;li&gt;throw new SaslAuthenticationException(error, e.getCause());&lt;br/&gt;
+            Throwable cause = e.getCause();&lt;br/&gt;
+            // Treat transient Kerberos errors as non-fatal SaslExceptions that are processed as I/O exceptions&lt;br/&gt;
+            // and all other failures as fatal SaslAuthenticationException.&lt;br/&gt;
+            if (kerberosError != null &amp;amp;&amp;amp; kerberosError.retriable)&lt;br/&gt;
+                throw new SaslException(error, cause);&lt;br/&gt;
+            else&lt;br/&gt;
+                throw new SaslAuthenticationException(error, cause);&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -436,4 +442,74 @@ static final String firstPrincipal(Subject subject) &lt;/p&gt;
{
                 throw new KafkaException(&quot;Principal could not be determined from Subject, this may be a transient failure due to Kerberos re-login&quot;);
         }
&lt;p&gt;     }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Kerberos exceptions that may require special handling. The standard Kerberos error codes&lt;br/&gt;
+     * for these errors are retrieved using KrbException#errorCode() from the underlying Kerberos&lt;br/&gt;
+     * exception thrown during &lt;/p&gt;
{@link SaslClient#evaluateChallenge(byte[])}
&lt;p&gt;.&lt;br/&gt;
+     */&lt;br/&gt;
+    private enum KerberosError {&lt;br/&gt;
+        // (Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)&lt;br/&gt;
+        // This is retriable, but included here to add extra logging for this case.&lt;br/&gt;
+        SERVER_NOT_FOUND(7, false),&lt;br/&gt;
+        // (Mechanism level: Client not yet valid - try again later (21))&lt;br/&gt;
+        CLIENT_NOT_YET_VALID(21, true),&lt;br/&gt;
+        // (Mechanism level: Ticket not yet valid (33) - Ticket not yet valid)])&lt;br/&gt;
+        // This could be a small timing window.&lt;br/&gt;
+        TICKET_NOT_YET_VALID(33, true),&lt;br/&gt;
+        // (Mechanism level: Request is a replay (34) - Request is a replay)&lt;br/&gt;
+        // Replay detection used to prevent DoS attacks can result in false positives, so retry on error.&lt;br/&gt;
+        REPLAY(34, true);&lt;br/&gt;
+&lt;br/&gt;
+&lt;br/&gt;
+        private static final Class&amp;lt;?&amp;gt; KRB_EXCEPTION_CLASS;&lt;br/&gt;
+        private static final Method KRB_EXCEPTION_RETURN_CODE_METHOD;&lt;br/&gt;
+&lt;br/&gt;
+        static {&lt;br/&gt;
+            try {&lt;br/&gt;
+                if (Java.isIbmJdk()) &lt;/p&gt;
{
+                    KRB_EXCEPTION_CLASS = Class.forName(&quot;com.ibm.security.krb5.internal.KrbException&quot;);
+                }
&lt;p&gt; else &lt;/p&gt;
{
+                    KRB_EXCEPTION_CLASS = Class.forName(&quot;sun.security.krb5.KrbException&quot;);
+                }
&lt;p&gt;+                KRB_EXCEPTION_RETURN_CODE_METHOD = KRB_EXCEPTION_CLASS.getMethod(&quot;returnCode&quot;);&lt;br/&gt;
+            } catch (Exception e) &lt;/p&gt;
{
+                throw new KafkaException(&quot;Kerberos exceptions could not be initialized&quot;, e);
+            }
&lt;p&gt;+        }&lt;br/&gt;
+&lt;br/&gt;
+        private final int errorCode;&lt;br/&gt;
+        private final boolean retriable;&lt;br/&gt;
+&lt;br/&gt;
+        KerberosError(int errorCode, boolean retriable) &lt;/p&gt;
{
+            this.errorCode = errorCode;
+            this.retriable = retriable;
+        }
&lt;p&gt;+&lt;br/&gt;
+        private static KerberosError fromException(Exception exception) {&lt;br/&gt;
+            Throwable cause = exception.getCause();&lt;br/&gt;
+            while (cause != null &amp;amp;&amp;amp; !KRB_EXCEPTION_CLASS.isInstance(cause)) &lt;/p&gt;
{
+                cause = cause.getCause();
+            }
&lt;p&gt;+            if (cause == null)&lt;br/&gt;
+                return null;&lt;br/&gt;
+            else {&lt;br/&gt;
+                try &lt;/p&gt;
{
+                    Integer errorCode = (Integer) KRB_EXCEPTION_RETURN_CODE_METHOD.invoke(cause);
+                    return fromErrorCode(errorCode);
+                }
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
+                    LOG.trace(&quot;Kerberos return code could not be determined from {} due to {}&quot;, exception, e);&lt;br/&gt;
+                    return null;&lt;br/&gt;
+                }&lt;br/&gt;
+            }&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        private static KerberosError fromErrorCode(int errorCode) {&lt;br/&gt;
+            for (KerberosError error : values()) &lt;/p&gt;
{
+                if (error.errorCode == errorCode)
+                    return error;
+            }
&lt;p&gt;+            return null;&lt;br/&gt;
+        }&lt;br/&gt;
+    }&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/core/src/test/scala/integration/kafka/server/GssapiAuthenticationTest.scala b/core/src/test/scala/integration/kafka/server/GssapiAuthenticationTest.scala&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..037f61408a5&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/core/src/test/scala/integration/kafka/server/GssapiAuthenticationTest.scala&lt;br/&gt;
@@ -0,0 +1,155 @@&lt;br/&gt;
+/**&lt;br/&gt;
+  * Licensed to the Apache Software Foundation (ASF) under one&lt;br/&gt;
+  * or more contributor license agreements.  See the NOTICE file&lt;br/&gt;
+  * distributed with this work for additional information&lt;br/&gt;
+  * regarding copyright ownership.  The ASF licenses this file&lt;br/&gt;
+  * to you under the Apache License, Version 2.0 (the&lt;br/&gt;
+  * &quot;License&quot;); you may not use this file except in compliance&lt;br/&gt;
+  * with the License.  You may obtain a copy of the License at&lt;br/&gt;
+  *&lt;br/&gt;
+  * &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+  *&lt;br/&gt;
+  * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+  * See the License for the specific language governing permissions and&lt;br/&gt;
+  * limitations under the License.&lt;br/&gt;
+  */&lt;br/&gt;
+&lt;br/&gt;
+package kafka.server&lt;br/&gt;
+&lt;br/&gt;
+import java.net.InetSocketAddress&lt;br/&gt;
+import java.util.Properties&lt;br/&gt;
+import java.util.concurrent.&lt;/p&gt;
{Executors, TimeUnit}
&lt;p&gt;+&lt;br/&gt;
+import kafka.api.&lt;/p&gt;
{Both, IntegrationTestHarness, SaslSetup}
&lt;p&gt;+import kafka.utils.TestUtils&lt;br/&gt;
+import org.apache.kafka.clients.CommonClientConfigs&lt;br/&gt;
+import org.apache.kafka.common.config.SaslConfigs&lt;br/&gt;
+import org.apache.kafka.common.network._&lt;br/&gt;
+import org.apache.kafka.common.security.&lt;/p&gt;
{JaasContext, TestSecurityConfig}
&lt;p&gt;+import org.apache.kafka.common.security.auth.SecurityProtocol&lt;br/&gt;
+import org.junit.Assert._&lt;br/&gt;
+import org.junit.&lt;/p&gt;
{After, Before, Test}
&lt;p&gt;+&lt;br/&gt;
+class GssapiAuthenticationTest extends IntegrationTestHarness with SaslSetup {&lt;br/&gt;
+&lt;br/&gt;
+  override val producerCount = 0&lt;br/&gt;
+  override val consumerCount = 0&lt;br/&gt;
+  override val serverCount = 1&lt;br/&gt;
+  override protected def securityProtocol = SecurityProtocol.SASL_PLAINTEXT&lt;br/&gt;
+&lt;br/&gt;
+  private val kafkaClientSaslMechanism = &quot;GSSAPI&quot;&lt;br/&gt;
+  private val kafkaServerSaslMechanisms = List(&quot;GSSAPI&quot;)&lt;br/&gt;
+&lt;br/&gt;
+  private val numThreads = 10&lt;br/&gt;
+  private val executor = Executors.newFixedThreadPool(numThreads)&lt;br/&gt;
+  private val clientConfig: Properties = new Properties&lt;br/&gt;
+  private var serverAddr: InetSocketAddress = _&lt;br/&gt;
+&lt;br/&gt;
+  @Before&lt;br/&gt;
+  override def setUp() &lt;/p&gt;
{
+    startSasl(jaasSections(kafkaServerSaslMechanisms, Option(kafkaClientSaslMechanism), Both))
+    super.setUp()
+    serverAddr = new InetSocketAddress(&quot;localhost&quot;,
+      servers.head.boundPort(ListenerName.forSecurityProtocol(SecurityProtocol.SASL_PLAINTEXT)))
+
+    clientConfig.put(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, SecurityProtocol.SASL_PLAINTEXT.name)
+    clientConfig.put(SaslConfigs.SASL_MECHANISM, kafkaClientSaslMechanism)
+    clientConfig.put(SaslConfigs.SASL_JAAS_CONFIG, jaasClientLoginModule(kafkaClientSaslMechanism))
+    clientConfig.put(CommonClientConfigs.CONNECTIONS_MAX_IDLE_MS_CONFIG, &quot;5000&quot;)
+  }
&lt;p&gt;+&lt;br/&gt;
+  @After&lt;br/&gt;
+  override def tearDown(): Unit = &lt;/p&gt;
{
+    executor.shutdownNow()
+    super.tearDown()
+    closeSasl()
+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Tests that Kerberos replay error `Request is a replay (34)` is not handled as an authentication exception&lt;br/&gt;
+   * since replay detection used to detect DoS attacks may occasionally reject valid concurrent requests.&lt;br/&gt;
+   */&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testRequestIsAReplay(): Unit = {&lt;br/&gt;
+    val successfulAuthsPerThread = 10&lt;br/&gt;
+    val futures = (0 until numThreads).map(_ =&amp;gt; executor.submit(new Runnable &lt;/p&gt;
{
+      override def run(): Unit = verifyRetriableFailuresDuringAuthentication(successfulAuthsPerThread)
+    }
&lt;p&gt;))&lt;br/&gt;
+    futures.foreach(_.get(60, TimeUnit.SECONDS))&lt;br/&gt;
+    assertEquals(0, TestUtils.totalMetricValue(servers.head, &quot;failed-authentication-total&quot;))&lt;br/&gt;
+    val successfulAuths = TestUtils.totalMetricValue(servers.head, &quot;successful-authentication-total&quot;)&lt;br/&gt;
+    assertTrue(&quot;Too few authentications: &quot; + successfulAuths, successfulAuths &amp;gt; successfulAuthsPerThread * numThreads)&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Tests that Kerberos error `Server not found in Kerberos database (7)` is handled&lt;br/&gt;
+   * as a fatal authentication failure.&lt;br/&gt;
+   */&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testServerNotFoundInKerberosDatabase(): Unit = &lt;/p&gt;
{
+    val jaasConfig = clientConfig.getProperty(SaslConfigs.SASL_JAAS_CONFIG)
+    val invalidServiceConfig = jaasConfig.replace(&quot;serviceName=\&quot;kafka\&quot;&quot;, &quot;serviceName=\&quot;invalid-service\&quot;&quot;)
+    clientConfig.put(SaslConfigs.SASL_JAAS_CONFIG, invalidServiceConfig)
+    clientConfig.put(SaslConfigs.SASL_KERBEROS_SERVICE_NAME, &quot;invalid-service&quot;)
+    verifyNonRetriableAuthenticationFailure()
+  }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Verifies that any exceptions during authentication with the current `clientConfig` are&lt;br/&gt;
+   * notified with disconnect state `AUTHENTICATE` (and not `AUTHENTICATION_FAILED`). This&lt;br/&gt;
+   * is to ensure that NetworkClient doesn&apos;t handle this as a fatal authentication failure,&lt;br/&gt;
+   * but as a transient I/O exception. So Producer/Consumer/AdminClient will retry&lt;br/&gt;
+   * any operation based on their configuration until timeout and will not propagate&lt;br/&gt;
+   * the exception to the application.&lt;br/&gt;
+   */&lt;br/&gt;
+  private def verifyRetriableFailuresDuringAuthentication(numSuccessfulAuths: Int): Unit = {&lt;br/&gt;
+    val selector = createSelector()&lt;br/&gt;
+    try {&lt;br/&gt;
+      var actualSuccessfulAuths = 0&lt;br/&gt;
+      while (actualSuccessfulAuths &amp;lt; numSuccessfulAuths) {&lt;br/&gt;
+        val nodeId = actualSuccessfulAuths.toString&lt;br/&gt;
+        selector.connect(nodeId, serverAddr, 1024, 1024)&lt;br/&gt;
+        TestUtils.waitUntilTrue(() =&amp;gt; &lt;/p&gt;
{
+          selector.poll(100)
+          val disconnectState = selector.disconnected().get(nodeId)
+          // Verify that disconnect state is not AUTHENTICATION_FAILED
+          if (disconnectState != null)
+            assertEquals(ChannelState.State.AUTHENTICATE, disconnectState.state())
+          selector.isChannelReady(nodeId) || disconnectState != null
+        }
&lt;p&gt;, &quot;Client not ready or disconnected within timeout&quot;)&lt;br/&gt;
+        if (selector.isChannelReady(nodeId))&lt;br/&gt;
+          actualSuccessfulAuths += 1&lt;br/&gt;
+        selector.close(nodeId)&lt;br/&gt;
+      }&lt;br/&gt;
+    } finally &lt;/p&gt;
{
+      selector.close()
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Verifies that authentication with the current `clientConfig` results in disconnection and that&lt;br/&gt;
+   * the disconnection is notified with disconnect state `AUTHENTICATION_FAILED`. This is to ensure&lt;br/&gt;
+   * that NetworkClient handles this as a fatal authentication failure that is propagated to&lt;br/&gt;
+   * applications by Producer/Consumer/AdminClient without retrying and waiting for timeout.&lt;br/&gt;
+   */&lt;br/&gt;
+  private def verifyNonRetriableAuthenticationFailure(): Unit = {&lt;br/&gt;
+    val selector = createSelector()&lt;br/&gt;
+    val nodeId = &quot;1&quot;&lt;br/&gt;
+    selector.connect(nodeId, serverAddr, 1024, 1024)&lt;br/&gt;
+    TestUtils.waitUntilTrue(() =&amp;gt; &lt;/p&gt;
{
+      selector.poll(100)
+      val disconnectState = selector.disconnected().get(nodeId)
+      if (disconnectState != null)
+        assertEquals(ChannelState.State.AUTHENTICATION_FAILED, disconnectState.state())
+      disconnectState != null
+    }
&lt;p&gt;, &quot;Client not disconnected within timeout&quot;)&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private def createSelector(): Selector = &lt;/p&gt;
{
+    val channelBuilder = ChannelBuilders.clientChannelBuilder(securityProtocol,
+      JaasContext.Type.CLIENT, new TestSecurityConfig(clientConfig), null, kafkaClientSaslMechanism, true)
+    NetworkTestUtils.createSelector(channelBuilder)
+  }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/core/src/test/scala/integration/kafka/server/ScramServerStartupTest.scala b/core/src/test/scala/integration/kafka/server/ScramServerStartupTest.scala&lt;br/&gt;
index 18b4f8e23b8..85028744ca3 100644&lt;br/&gt;
&amp;#8212; a/core/src/test/scala/integration/kafka/server/ScramServerStartupTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/integration/kafka/server/ScramServerStartupTest.scala&lt;br/&gt;
@@ -58,16 +58,9 @@ class ScramServerStartupTest extends IntegrationTestHarness with SaslSetup {&lt;/p&gt;

&lt;p&gt;   @Test&lt;br/&gt;
   def testAuthentications(): Unit = &lt;/p&gt;
{
-    val successfulAuths = totalAuthentications(&quot;successful-authentication-total&quot;)
+    val successfulAuths = TestUtils.totalMetricValue(servers.head, &quot;successful-authentication-total&quot;)
     assertTrue(&quot;No successful authentications&quot;, successfulAuths &amp;gt; 0)
-    val failedAuths = totalAuthentications(&quot;failed-authentication-total&quot;)
+    val failedAuths = TestUtils.totalMetricValue(servers.head, &quot;failed-authentication-total&quot;)
     assertEquals(0, failedAuths)
   }
&lt;p&gt;-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private def totalAuthentications(metricName: String): Int = 
{
-    val allMetrics = servers.head.metrics.metrics
-    val totalAuthCount = allMetrics.values().asScala.filter(_.metricName().name() == metricName)
-      .foldLeft(0.0)((total, metric) =&amp;gt; total + metric.metricValue.asInstanceOf[Double])
-    totalAuthCount.toInt
-  }
&lt;p&gt; }&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/utils/TestUtils.scala b/core/src/test/scala/unit/kafka/utils/TestUtils.scala&lt;br/&gt;
index 978362782ac..bdd68820b32 100755&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/test/scala/unit/kafka/utils/TestUtils.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/utils/TestUtils.scala&lt;br/&gt;
@@ -1415,4 +1415,11 @@ object TestUtils extends Logging 
{
             cause.getClass().getName, clazz.isInstance(cause))
     }
&lt;p&gt;   }&lt;br/&gt;
+&lt;br/&gt;
+  def totalMetricValue(server: KafkaServer, metricName: String): Long = &lt;/p&gt;
{
+    val allMetrics = server.metrics.metrics
+    val total = allMetrics.values().asScala.filter(_.metricName().name() == metricName)
+      .foldLeft(0.0)((total, metric) =&amp;gt; total + metric.metricValue.asInstanceOf[Double])
+    total.toLong
+  }
&lt;p&gt; }&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16580826" author="rsivaram" created="Wed, 15 Aug 2018 08:21:46 +0000"  >&lt;p&gt;There was a test failure with the 1.0 build. It looks like we need to handle retriable Kerberos exceptions on the server-side as well. I could recreate this failure only with Java 7, but to be safe, will fix trunk as well.&lt;/p&gt;

&lt;p&gt;Exception from &lt;a href=&quot;https://builds.apache.org/job/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/kafka&lt;/a&gt;&#8211;jdk7/232/:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java.util.concurrent.ExecutionException: java.lang.AssertionError: expected:&amp;lt;AUTHENTICATE&amp;gt; but was:&amp;lt;AUTHENTICATION_FAILED&amp;gt; at java.util.concurrent.FutureTask.report(FutureTask.java:122) at java.util.concurrent.FutureTask.get(FutureTask.java:202) at kafka.server.GssapiAuthenticationTest$$anonfun$testRequestIsAReplay$1.apply(GssapiAuthenticationTest.scala:80) at kafka.server.GssapiAuthenticationTest$$anonfun$testRequestIsAReplay$1.apply(GssapiAuthenticationTest.scala:80)&lt;/p&gt;&lt;/blockquote&gt;</comment>
                            <comment id="16580865" author="githubbot" created="Wed, 15 Aug 2018 09:08:34 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #5509: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7119&quot; title=&quot;Intermittent test failure with GSSAPI authentication failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7119&quot;&gt;&lt;del&gt;KAFKA-7119&lt;/del&gt;&lt;/a&gt;: Handle transient Kerberos errors on server side&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5509&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5509&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Don&apos;t report retriable Kerberos errors on the server-side as authentication failures to clients.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16582135" author="githubbot" created="Thu, 16 Aug 2018 08:02:27 +0000"  >&lt;p&gt;rajinisivaram closed pull request #5509: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7119&quot; title=&quot;Intermittent test failure with GSSAPI authentication failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7119&quot;&gt;&lt;del&gt;KAFKA-7119&lt;/del&gt;&lt;/a&gt;: Handle transient Kerberos errors on server side&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5509&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5509&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java&lt;br/&gt;
index 8d6549d867c..8934e8e5487 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslClientAuthenticator.java&lt;br/&gt;
@@ -42,7 +42,7 @@&lt;br/&gt;
 import org.apache.kafka.common.requests.SaslHandshakeResponse;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.AuthenticateCallbackHandler;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipal;&lt;br/&gt;
-import org.apache.kafka.common.utils.Java;&lt;br/&gt;
+import org.apache.kafka.common.security.kerberos.KerberosError;&lt;br/&gt;
 import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
@@ -52,7 +52,6 @@&lt;br/&gt;
 import javax.security.sasl.SaslClient;&lt;br/&gt;
 import javax.security.sasl.SaslException;&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
-import java.lang.reflect.Method;&lt;br/&gt;
 import java.nio.ByteBuffer;&lt;br/&gt;
 import java.nio.channels.SelectionKey;&lt;br/&gt;
 import java.security.Principal;&lt;br/&gt;
@@ -376,7 +375,7 @@ public void close() throws IOException {&lt;br/&gt;
             Throwable cause = e.getCause();&lt;br/&gt;
             // Treat transient Kerberos errors as non-fatal SaslExceptions that are processed as I/O exceptions&lt;br/&gt;
             // and all other failures as fatal SaslAuthenticationException.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (kerberosError != null &amp;amp;&amp;amp; kerberosError.retriable)&lt;br/&gt;
+            if (kerberosError != null &amp;amp;&amp;amp; kerberosError.retriable())&lt;br/&gt;
                 throw new SaslException(error, cause);&lt;br/&gt;
             else&lt;br/&gt;
                 throw new SaslAuthenticationException(error, cause);&lt;br/&gt;
@@ -443,73 +442,4 @@ static final String firstPrincipal(Subject subject) {&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Kerberos exceptions that may require special handling. The standard Kerberos error codes&lt;/li&gt;
	&lt;li&gt;* for these errors are retrieved using KrbException#errorCode() from the underlying Kerberos&lt;/li&gt;
	&lt;li&gt;* exception thrown during 
{@link SaslClient#evaluateChallenge(byte[])}.&lt;br/&gt;
-     */&lt;br/&gt;
-    private enum KerberosError {&lt;br/&gt;
-        // (Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)&lt;br/&gt;
-        // This is retriable, but included here to add extra logging for this case.&lt;br/&gt;
-        SERVER_NOT_FOUND(7, false),&lt;br/&gt;
-        // (Mechanism level: Client not yet valid - try again later (21))&lt;br/&gt;
-        CLIENT_NOT_YET_VALID(21, true),&lt;br/&gt;
-        // (Mechanism level: Ticket not yet valid (33) - Ticket not yet valid)])&lt;br/&gt;
-        // This could be a small timing window.&lt;br/&gt;
-        TICKET_NOT_YET_VALID(33, true),&lt;br/&gt;
-        // (Mechanism level: Request is a replay (34) - Request is a replay)&lt;br/&gt;
-        // Replay detection used to prevent DoS attacks can result in false positives, so retry on error.&lt;br/&gt;
-        REPLAY(34, true);&lt;br/&gt;
-&lt;br/&gt;
-&lt;br/&gt;
-        private static final Class&amp;lt;?&amp;gt; KRB_EXCEPTION_CLASS;&lt;br/&gt;
-        private static final Method KRB_EXCEPTION_RETURN_CODE_METHOD;&lt;br/&gt;
-&lt;br/&gt;
-        static {&lt;br/&gt;
-            try {&lt;br/&gt;
-                if (Java.isIbmJdk()) {
-                    KRB_EXCEPTION_CLASS = Class.forName(&quot;com.ibm.security.krb5.internal.KrbException&quot;);
-                } else {
-                    KRB_EXCEPTION_CLASS = Class.forName(&quot;sun.security.krb5.KrbException&quot;);
-                }&lt;br/&gt;
-                KRB_EXCEPTION_RETURN_CODE_METHOD = KRB_EXCEPTION_CLASS.getMethod(&quot;returnCode&quot;);&lt;br/&gt;
-            } catch (Exception e) {
-                throw new KafkaException(&quot;Kerberos exceptions could not be initialized&quot;, e);
-            }&lt;br/&gt;
-        }&lt;br/&gt;
-&lt;br/&gt;
-        private final int errorCode;&lt;br/&gt;
-        private final boolean retriable;&lt;br/&gt;
-&lt;br/&gt;
-        KerberosError(int errorCode, boolean retriable) {
-            this.errorCode = errorCode;
-            this.retriable = retriable;
-        }&lt;br/&gt;
-&lt;br/&gt;
-        private static KerberosError fromException(Exception exception) {&lt;br/&gt;
-            Throwable cause = exception.getCause();&lt;br/&gt;
-            while (cause != null &amp;amp;&amp;amp; !KRB_EXCEPTION_CLASS.isInstance(cause)) {
-                cause = cause.getCause();
-            }&lt;br/&gt;
-            if (cause == null)&lt;br/&gt;
-                return null;&lt;br/&gt;
-            else {&lt;br/&gt;
-                try {
-                    Integer errorCode = (Integer) KRB_EXCEPTION_RETURN_CODE_METHOD.invoke(cause);
-                    return fromErrorCode(errorCode);
-                } catch (Exception e) {&lt;br/&gt;
-                    LOG.trace(&quot;Kerberos return code could not be determined from {} due to {}&quot;, exception, e);&lt;br/&gt;
-                    return null;&lt;br/&gt;
-                }&lt;br/&gt;
-            }&lt;br/&gt;
-        }&lt;br/&gt;
-&lt;br/&gt;
-        private static KerberosError fromErrorCode(int errorCode) {&lt;br/&gt;
-            for (KerberosError error : values()) {
-                if (error.errorCode == errorCode)
-                    return error;
-            }&lt;br/&gt;
-            return null;&lt;br/&gt;
-        }&lt;br/&gt;
-    }&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java&lt;br/&gt;
index a3f81629bc7..e8f77a53e22 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java&lt;br/&gt;
@@ -49,6 +49,7 @@&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipal;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.SaslAuthenticationContext;&lt;br/&gt;
+import org.apache.kafka.common.security.kerberos.KerberosError;&lt;br/&gt;
 import org.apache.kafka.common.security.kerberos.KerberosName;&lt;br/&gt;
 import org.apache.kafka.common.security.kerberos.KerberosShortNamer;&lt;br/&gt;
 import org.apache.kafka.common.security.scram.ScramLoginModule;&lt;br/&gt;
@@ -267,11 +268,9 @@ public void authenticate() throws IOException {
                     default:
                         break;
                 }&lt;br/&gt;
-            } catch (SaslException | AuthenticationException e) {
+            } catch (AuthenticationException e) {
                 // Exception will be propagated after response is sent to client
-                AuthenticationException authException = (e instanceof AuthenticationException) ?
-                        (AuthenticationException) e : new AuthenticationException(&quot;SASL authentication failed&quot;, e);
-                setSaslState(SaslState.FAILED, authException);
+                setSaslState(SaslState.FAILED, e);
             } catch (Exception e) {&lt;br/&gt;
                 // In the case of IOExceptions and other unexpected exceptions, fail immediately&lt;br/&gt;
                 saslState = SaslState.FAILED;&lt;br/&gt;
@@ -378,12 +377,20 @@ private void handleSaslToken(byte[] clientToken) throws IOException {
                 // For versions with SASL_AUTHENTICATE header, send a response to SASL_AUTHENTICATE request even if token is empty.
                 ByteBuffer responseBuf = responseToken == null ? EMPTY_BUFFER : ByteBuffer.wrap(responseToken);
                 sendKafkaResponse(requestContext, new SaslAuthenticateResponse(Errors.NONE, null, responseBuf));
-            } catch (SaslAuthenticationException | SaslException e) {
-                String errorMessage = e instanceof SaslAuthenticationException ? e.getMessage() :
-                    &quot;Authentication failed due to invalid credentials with SASL mechanism &quot; + saslMechanism;
-                sendKafkaResponse(requestContext, new SaslAuthenticateResponse(Errors.SASL_AUTHENTICATION_FAILED,
-                        errorMessage));
+            } catch (SaslAuthenticationException e) {
+                sendKafkaResponse(requestContext, new SaslAuthenticateResponse(Errors.SASL_AUTHENTICATION_FAILED, e.getMessage()));
                 throw e;
+            } catch (SaslException e) {&lt;br/&gt;
+                KerberosError kerberosError = KerberosError.fromException(e);&lt;br/&gt;
+                if (kerberosError != null &amp;amp;&amp;amp; kerberosError.retriable()) {
+                    // Handle retriable Kerberos exceptions as I/O exceptions rather than authentication exceptions
+                    throw e;
+                } else {
+                    String errorMessage = &quot;Authentication failed due to invalid credentials with SASL mechanism &quot; + saslMechanism;
+                    sendKafkaResponse(requestContext, new SaslAuthenticateResponse(Errors.SASL_AUTHENTICATION_FAILED,
+                            errorMessage));
+                    throw new SaslAuthenticationException(errorMessage, e);
+                }&lt;br/&gt;
             }&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/security/kerberos/KerberosError.java b/clients/src/main/java/org/apache/kafka/common/security/kerberos/KerberosError.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..c6be441c7ed&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/security/kerberos/KerberosError.java&lt;br/&gt;
@@ -0,0 +1,100 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.common.security.kerberos;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.KafkaException;&lt;br/&gt;
+import org.apache.kafka.common.security.authenticator.SaslClientAuthenticator;&lt;br/&gt;
+import org.apache.kafka.common.utils.Java;&lt;br/&gt;
+import org.slf4j.Logger;&lt;br/&gt;
+import org.slf4j.LoggerFactory;&lt;br/&gt;
+&lt;br/&gt;
+import javax.security.sasl.SaslClient;&lt;br/&gt;
+import java.lang.reflect.Method;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * Kerberos exceptions that may require special handling. The standard Kerberos error codes&lt;br/&gt;
+ * for these errors are retrieved using KrbException#errorCode() from the underlying Kerberos&lt;br/&gt;
+ * exception thrown during {@link SaslClient#evaluateChallenge(byte[])}
&lt;p&gt;.&lt;br/&gt;
+ */&lt;br/&gt;
+public enum KerberosError {&lt;br/&gt;
+    // (Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)&lt;br/&gt;
+    // This is retriable, but included here to add extra logging for this case.&lt;br/&gt;
+    SERVER_NOT_FOUND(7, false),&lt;br/&gt;
+    // (Mechanism level: Client not yet valid - try again later (21))&lt;br/&gt;
+    CLIENT_NOT_YET_VALID(21, true),&lt;br/&gt;
+    // (Mechanism level: Ticket not yet valid (33) - Ticket not yet valid)])&lt;br/&gt;
+    // This could be a small timing window.&lt;br/&gt;
+    TICKET_NOT_YET_VALID(33, true),&lt;br/&gt;
+    // (Mechanism level: Request is a replay (34) - Request is a replay)&lt;br/&gt;
+    // Replay detection used to prevent DoS attacks can result in false positives, so retry on error.&lt;br/&gt;
+    REPLAY(34, true);&lt;br/&gt;
+&lt;br/&gt;
+    private static final Logger log = LoggerFactory.getLogger(SaslClientAuthenticator.class);&lt;br/&gt;
+    private static final Class&amp;lt;?&amp;gt; KRB_EXCEPTION_CLASS;&lt;br/&gt;
+    private static final Method KRB_EXCEPTION_RETURN_CODE_METHOD;&lt;br/&gt;
+&lt;br/&gt;
+    static {&lt;br/&gt;
+        try &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            if (Java.isIbmJdk()) {
+                KRB_EXCEPTION_CLASS = Class.forName(&quot;com.ibm.security.krb5.internal.KrbException&quot;);
+            } else {
+                KRB_EXCEPTION_CLASS = Class.forName(&quot;sun.security.krb5.KrbException&quot;);
+            }+            KRB_EXCEPTION_RETURN_CODE_METHOD = KRB_EXCEPTION_CLASS.getMethod(&amp;quot;returnCode&amp;quot;);+        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
+            throw new KafkaException(&quot;Kerberos exceptions could not be initialized&quot;, e);
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    private final int errorCode;&lt;br/&gt;
+    private final boolean retriable;&lt;br/&gt;
+&lt;br/&gt;
+    KerberosError(int errorCode, boolean retriable) &lt;/p&gt;
{
+        this.errorCode = errorCode;
+        this.retriable = retriable;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public boolean retriable() &lt;/p&gt;
{
+        return retriable;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static KerberosError fromException(Exception exception) {&lt;br/&gt;
+        Throwable cause = exception.getCause();&lt;br/&gt;
+        while (cause != null &amp;amp;&amp;amp; !KRB_EXCEPTION_CLASS.isInstance(cause)) &lt;/p&gt;
{
+            cause = cause.getCause();
+        }
&lt;p&gt;+        if (cause == null)&lt;br/&gt;
+            return null;&lt;br/&gt;
+        else {&lt;br/&gt;
+            try &lt;/p&gt;
{
+                Integer errorCode = (Integer) KRB_EXCEPTION_RETURN_CODE_METHOD.invoke(cause);
+                return fromErrorCode(errorCode);
+            }
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
+                log.trace(&quot;Kerberos return code could not be determined from {} due to {}&quot;, exception, e);&lt;br/&gt;
+                return null;&lt;br/&gt;
+            }&lt;br/&gt;
+        }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private static KerberosError fromErrorCode(int errorCode) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        for (KerberosError error }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+}&lt;br/&gt;
diff --git a/core/src/test/scala/integration/kafka/server/GssapiAuthenticationTest.scala b/core/src/test/scala/integration/kafka/server/GssapiAuthenticationTest.scala&lt;br/&gt;
index 04166c63b18..74b2a152e23 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/test/scala/integration/kafka/server/GssapiAuthenticationTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/integration/kafka/server/GssapiAuthenticationTest.scala&lt;br/&gt;
@@ -113,7 +113,8 @@ class GssapiAuthenticationTest extends IntegrationTestHarness with SaslSetup {&lt;br/&gt;
           val disconnectState = selector.disconnected().get(nodeId)&lt;br/&gt;
           // Verify that disconnect state is not AUTHENTICATION_FAILED&lt;br/&gt;
           if (disconnectState != null)&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;assertEquals(ChannelState.State.AUTHENTICATE, disconnectState.state())&lt;br/&gt;
+            assertEquals(s&quot;Authentication failed with exception ${disconnectState.exception()}&quot;,&lt;br/&gt;
+              ChannelState.State.AUTHENTICATE, disconnectState.state())&lt;br/&gt;
           selector.isChannelReady(nodeId) || disconnectState != null&lt;br/&gt;
         }, &quot;Client not ready or disconnected within timeout&quot;)&lt;br/&gt;
         if (selector.isChannelReady(nodeId))&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 13 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3vdxb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>junrao</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>