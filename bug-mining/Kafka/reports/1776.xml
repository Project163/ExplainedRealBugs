<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:05:49 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6252] A metric named &apos;XX&apos; already exists, can&apos;t register another one.</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6252</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;When a connector crashes (or is not implemented correctly by not stopping/interrupting &lt;tt&gt;poll()&lt;/tt&gt;), It cannot be restarted and an exception like this is thrown &lt;/p&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java.lang.IllegalArgumentException: A metric named &lt;span class=&quot;code-quote&quot;&gt;&apos;MetricName [name=offset-commit-max-time-ms, group=connector-task-metrics, description=The maximum time in milliseconds taken by &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; task to commit offsets., tags={connector=hdfs-sink-connector-recover, task=0}]&apos;&lt;/span&gt; already exists, can&apos;t register another one.
	at org.apache.kafka.common.metrics.Metrics.registerMetric(Metrics.java:532)
	at org.apache.kafka.common.metrics.Sensor.add(Sensor.java:256)
	at org.apache.kafka.common.metrics.Sensor.add(Sensor.java:241)
	at org.apache.kafka.connect.runtime.WorkerTask$TaskMetricsGroup.&amp;lt;init&amp;gt;(WorkerTask.java:328)
	at org.apache.kafka.connect.runtime.WorkerTask.&amp;lt;init&amp;gt;(WorkerTask.java:69)
	at org.apache.kafka.connect.runtime.WorkerSinkTask.&amp;lt;init&amp;gt;(WorkerSinkTask.java:98)
	at org.apache.kafka.connect.runtime.Worker.buildWorkerTask(Worker.java:449)
	at org.apache.kafka.connect.runtime.Worker.startTask(Worker.java:404)
	at org.apache.kafka.connect.runtime.distributed.DistributedHerder.startTask(DistributedHerder.java:852)
	at org.apache.kafka.connect.runtime.distributed.DistributedHerder.access$1600(DistributedHerder.java:108)
	at org.apache.kafka.connect.runtime.distributed.DistributedHerder$13.call(DistributedHerder.java:866)
	at org.apache.kafka.connect.runtime.distributed.DistributedHerder$13.call(DistributedHerder.java:862)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:745)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;I guess it&apos;s because the function taskMetricsGroup.close is not call in all the cases&lt;/p&gt;</description>
                <environment>Linux</environment>
        <key id="13120006">KAFKA-6252</key>
            <summary>A metric named &apos;XX&apos; already exists, can&apos;t register another one.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="wicknicks">Arjun Satish</assignee>
                                    <reporter username="alexis.sellier">Alexis Sellier</reporter>
                        <labels>
                    </labels>
                <created>Tue, 21 Nov 2017 17:03:36 +0000</created>
                <updated>Thu, 1 Feb 2018 10:27:31 +0000</updated>
                            <resolved>Sat, 6 Jan 2018 05:25:48 +0000</resolved>
                                    <version>1.0.0</version>
                                    <fixVersion>1.0.1</fixVersion>
                    <fixVersion>1.1.0</fixVersion>
                                    <component>connect</component>
                        <due></due>
                            <votes>7</votes>
                                    <watches>11</watches>
                                                                                                                <comments>
                            <comment id="16269781" author="rhauch" created="Wed, 29 Nov 2017 00:07:38 +0000"  >&lt;p&gt;This also happens when a connector does not properly implement &lt;tt&gt;stop()&lt;/tt&gt;. &lt;/p&gt;

&lt;p&gt;Connect will call &lt;tt&gt;stop()&lt;/tt&gt; on a source task to signal that it should &quot;_stop trying to poll for new data &lt;br/&gt;
and interrupt any outstanding poll() requests_&quot; (see the &lt;a href=&quot;http://kafka.apache.org/10/javadoc/org/apache/kafka/connect/source/SourceTask.html#stop--&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;JavaDoc&lt;/a&gt; for this method).&lt;/p&gt;

&lt;p&gt;Unfortunately, not all connectors properly adhere to this expectation. Since the metrics for the source task are cleaned up only when the worker source task&apos;s thread completes, a task whose &lt;tt&gt;poll()&lt;/tt&gt; method blocks forever will current prevent its thread from completing. So, we need to change how the metrics are cleaned up to ensure this always happens.&lt;/p&gt;</comment>
                            <comment id="16290110" author="willaustinjolt1" created="Wed, 13 Dec 2017 23:56:16 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rhauch&quot; class=&quot;user-hover&quot; rel=&quot;rhauch&quot;&gt;rhauch&lt;/a&gt; are there any workarounds for this issue until it is changed?&lt;/p&gt;</comment>
                            <comment id="16291119" author="rhauch" created="Thu, 14 Dec 2017 16:24:04 +0000"  >&lt;p&gt;No, I don&apos;t think there are any workarounds, other than restarting the worker. Of course the best workaround would be for the connectors to correct their behavior, but I understand that the framework should be more tolerant of such implementations where it can.&lt;/p&gt;</comment>
                            <comment id="16309815" author="rhauch" created="Wed, 3 Jan 2018 15:44:52 +0000"  >&lt;p&gt;As mentioned above, connectors run into this is because the Task doesn&apos;t properly implement `stop()`. For example, a source task has a &lt;tt&gt;poll()&lt;/tt&gt; method that is expected to block while there are no new records to return. However, that blocking must be interrupted when &lt;tt&gt;stop()&lt;/tt&gt; is called. If the source connector uses a thread, then &lt;tt&gt;stop()&lt;/tt&gt; should interrupt that thread and set the state such that &lt;tt&gt;poll()&lt;/tt&gt; will return an empty list. &lt;/p&gt;

&lt;p&gt;Other source connector implementation may use a &lt;tt&gt;BlockingQueue&lt;/tt&gt; and call the queue&apos;s &lt;tt&gt;take()&lt;/tt&gt; method to grab items out of a queue. In this case, &lt;tt&gt;take()&lt;/tt&gt; blocks indefinitely until there is an item in the queue, but if the task&apos;s &lt;tt&gt;stop()&lt;/tt&gt; method is called while &lt;tt&gt;poll()&lt;/tt&gt; is blocked on the queue&apos;s &lt;tt&gt;take()&lt;/tt&gt; method, the task will likely never add another item to the queue and &lt;tt&gt;take()&lt;/tt&gt; &amp;#8211; and thus &lt;tt&gt;poll()&lt;/tt&gt; &amp;#8211; will never return.&lt;/p&gt;

&lt;p&gt;The proper way to use a blocking queue is to use &lt;tt&gt;BlockingQueue.poll(timeout, unit)&lt;/tt&gt; method to block for a max amount of time, and to then handle the case when no item is retrieved from the queue. The task&apos;s &lt;tt&gt;poll()&lt;/tt&gt; can return an empty list.&lt;/p&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MySourceTask &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; SourceTask {
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; BlockingQueue&amp;lt;SourceRecord&amp;gt; queue;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; AtomicBoolean running = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; AtomicBoolean(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
    ...
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;SourceRecord&amp;gt; poll() {
        List&amp;lt;SourceRecord&amp;gt; batch = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();
        &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (running.get()) {
            &lt;span class=&quot;code-comment&quot;&gt;// Poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; records but only &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; a max amount of time!
&lt;/span&gt;            SourceRecord record = queue.poll(1L, TimeUnit.SECONDS);
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (record == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                &lt;span class=&quot;code-comment&quot;&gt;// the queue was empty, so &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt; looping ...
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;
            }
            &lt;span class=&quot;code-comment&quot;&gt;// We found at least one record, so add that and drain any others ...
&lt;/span&gt;            batch.add(record);
            queue.drainTo(batch);
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; batch;
        }
        &lt;span class=&quot;code-comment&quot;&gt;// Task has been stopped
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; batch;
    }
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void stop() {
        running.set(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course, there are lots of variations of this basic idea. For example, if needed the task could limit the size of the batch by using &lt;tt&gt;queue.drainTo(batch, batch.size() - maxBatchSize - 1)&lt;/tt&gt;, obviously ensuring that the second argument is non-negative. &lt;/p&gt;</comment>
                            <comment id="16309852" author="rhauch" created="Wed, 3 Jan 2018 16:15:17 +0000"  >&lt;p&gt;As for how we might more gracefully deal with such connectors, I can think of two possible changes:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;always ensure that &lt;tt&gt;poll()&lt;/tt&gt; always returns by interrupting the task; or&lt;/li&gt;
	&lt;li&gt;change how the task-specific metrics are created to deregister any existing metric group that already exists.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Ideally, we&apos;d do the first to make sure every task is always cleaned up. But there are quite a few issues with this. First, even tho &lt;tt&gt;poll()&lt;/tt&gt; already throws &lt;tt&gt;InterruptedException&lt;/tt&gt;, interrupting an unresponsive &lt;tt&gt;poll()&lt;/tt&gt; method would change existing behavior. Second, not all connector implementations may be expecting an interrupt and may fail to implement it properly. Third, we&apos;d have to decide how long to wait before interrupting. None of these are straightforward.&lt;/p&gt;

&lt;p&gt;So, my current thinking is that the second approach may be a better solution. Since each task-specific metrics group will only be duplicated if the connector is restarted and the previous tasks don&apos;t stop, the task-specific metrics group could clean up any previous task-specific metrics group instance. (Note that any metrics groups that are not specific to a connector and task should always be reused.)&lt;/p&gt;</comment>
                            <comment id="16314079" author="githubbot" created="Fri, 5 Jan 2018 22:56:35 +0000"  >&lt;p&gt;wicknicks opened a new pull request #4397: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6252&quot; title=&quot;A metric named &amp;#39;XX&amp;#39; already exists, can&amp;#39;t register another one.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6252&quot;&gt;&lt;del&gt;KAFKA-6252&lt;/del&gt;&lt;/a&gt;: Close the metric group to clean up any existing metrics&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4397&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4397&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Signed-off-by: Arjun Satish &amp;lt;arjun@confluent.io&amp;gt;&lt;/p&gt;

&lt;p&gt;   *More detailed description of your change,&lt;br/&gt;
   if necessary. The PR title and PR message become&lt;br/&gt;
   the squashed commit message, so use a separate&lt;br/&gt;
   comment to ping reviewers.*&lt;/p&gt;

&lt;p&gt;   *Summary of testing strategy (including rationale)&lt;br/&gt;
   for the feature or bug fix. Unit and/or integration&lt;br/&gt;
   tests are expected for any behaviour change and&lt;br/&gt;
   system tests should be considered for larger changes.*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16314383" author="githubbot" created="Sat, 6 Jan 2018 05:26:15 +0000"  >&lt;p&gt;ewencp closed pull request #4397: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6252&quot; title=&quot;A metric named &amp;#39;XX&amp;#39; already exists, can&amp;#39;t register another one.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6252&quot;&gt;&lt;del&gt;KAFKA-6252&lt;/del&gt;&lt;/a&gt;: Close the metric group to clean up any existing metrics&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4397&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4397&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerConnector.java b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerConnector.java&lt;br/&gt;
index 9e65cd2d80f..9b934f3428a 100644&lt;br/&gt;
&amp;#8212; a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerConnector.java&lt;br/&gt;
+++ b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerConnector.java&lt;br/&gt;
@@ -247,6 +247,8 @@ public ConnectorMetricsGroup(ConnectMetrics connectMetrics, AbstractStatus.State&lt;br/&gt;
             ConnectMetricsRegistry registry = connectMetrics.registry();&lt;br/&gt;
             this.metricGroup = connectMetrics.group(registry.connectorGroupName(),&lt;br/&gt;
                     registry.connectorTagName(), connName);&lt;br/&gt;
+            // prevent collisions by removing any previously created metrics in this group.&lt;br/&gt;
+            metricGroup.close();&lt;/p&gt;

&lt;p&gt;             metricGroup.addImmutableValueMetric(registry.connectorType, connectorType());&lt;br/&gt;
             metricGroup.addImmutableValueMetric(registry.connectorClass, connector.getClass().getName());&lt;br/&gt;
diff --git a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSinkTask.java b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSinkTask.java&lt;br/&gt;
index 234ce8adf14..587e4c68cf5 100644&lt;br/&gt;
&amp;#8212; a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSinkTask.java&lt;br/&gt;
+++ b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSinkTask.java&lt;br/&gt;
@@ -652,6 +652,8 @@ public SinkTaskMetricsGroup(ConnectorTaskId id, ConnectMetrics connectMetrics) {&lt;br/&gt;
             metricGroup = connectMetrics&lt;br/&gt;
                                   .group(registry.sinkTaskGroupName(), registry.connectorTagName(), id.connector(), registry.taskTagName(),&lt;br/&gt;
                                          Integer.toString(id.task()));&lt;br/&gt;
+            // prevent collisions by removing any previously created metrics in this group.&lt;br/&gt;
+            metricGroup.close();&lt;/p&gt;

&lt;p&gt;             sinkRecordRead = metricGroup.metrics().sensor(&quot;sink-record-read&quot;);&lt;br/&gt;
             sinkRecordRead.add(metricGroup.metricName(registry.sinkRecordReadRate), new Rate());&lt;br/&gt;
diff --git a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java&lt;br/&gt;
index 9072cd47c81..a172cdb45f0 100644&lt;br/&gt;
&amp;#8212; a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java&lt;br/&gt;
+++ b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerSourceTask.java&lt;br/&gt;
@@ -494,6 +494,8 @@ public SourceTaskMetricsGroup(ConnectorTaskId id, ConnectMetrics connectMetrics)&lt;br/&gt;
             metricGroup = connectMetrics.group(registry.sourceTaskGroupName(),&lt;br/&gt;
                     registry.connectorTagName(), id.connector(),&lt;br/&gt;
                     registry.taskTagName(), Integer.toString(id.task()));&lt;br/&gt;
+            // remove any previously created metrics in this group to prevent collisions.&lt;br/&gt;
+            metricGroup.close();&lt;/p&gt;

&lt;p&gt;             sourceRecordPoll = metricGroup.sensor(&quot;source-record-poll&quot;);&lt;br/&gt;
             sourceRecordPoll.add(metricGroup.metricName(registry.sourceRecordPollRate), new Rate());&lt;br/&gt;
diff --git a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerTask.java b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerTask.java&lt;br/&gt;
index ec069245b3d..d563f9bdede 100644&lt;br/&gt;
&amp;#8212; a/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerTask.java&lt;br/&gt;
+++ b/connect/runtime/src/main/java/org/apache/kafka/connect/runtime/WorkerTask.java&lt;br/&gt;
@@ -313,6 +313,8 @@ public TaskMetricsGroup(ConnectorTaskId id, ConnectMetrics connectMetrics, TaskS&lt;br/&gt;
             metricGroup = connectMetrics.group(registry.taskGroupName(),&lt;br/&gt;
                     registry.connectorTagName(), id.connector(),&lt;br/&gt;
                     registry.taskTagName(), Integer.toString(id.task()));&lt;br/&gt;
+            // prevent collisions by removing any previously created metrics in this group.&lt;br/&gt;
+            metricGroup.close();&lt;/p&gt;

&lt;p&gt;             metricGroup.addValueMetric(registry.taskStatus, new LiteralSupplier&amp;lt;String&amp;gt;() {&lt;br/&gt;
                 @Override&lt;br/&gt;
diff --git a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectMetricsTest.java b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectMetricsTest.java&lt;br/&gt;
index 2de7cb6e107..d247df83945 100644&lt;br/&gt;
&amp;#8212; a/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectMetricsTest.java&lt;br/&gt;
+++ b/connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectMetricsTest.java&lt;br/&gt;
@@ -16,13 +16,19 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.connect.runtime;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.MetricName;&lt;br/&gt;
+import org.apache.kafka.common.metrics.Sensor;&lt;br/&gt;
+import org.apache.kafka.common.metrics.stats.Avg;&lt;br/&gt;
+import org.apache.kafka.common.metrics.stats.Max;&lt;br/&gt;
 import org.apache.kafka.connect.runtime.ConnectMetrics.MetricGroup;&lt;br/&gt;
 import org.apache.kafka.connect.runtime.ConnectMetrics.MetricGroupId;&lt;br/&gt;
 import org.apache.kafka.connect.util.MockTime;&lt;br/&gt;
 import org.junit.After;&lt;br/&gt;
+import org.junit.Assert;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;+import java.util.Collections;&lt;br/&gt;
 import java.util.HashMap;&lt;br/&gt;
 import java.util.Map;&lt;/p&gt;

&lt;p&gt;@@ -136,4 +142,40 @@ public void testMetricGroupIdWithoutTags() &lt;/p&gt;
{
         assertNotNull(id1.tags());
         assertNotNull(id2.tags());
     }
&lt;p&gt;-}&lt;br/&gt;
\ No newline at end of file&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testRecreateWithClose() &lt;/p&gt;
{
+        int numMetrics = addToGroup(metrics, false);
+        int numMetricsInRecreatedGroup = addToGroup(metrics, true);
+        Assert.assertEquals(numMetrics, numMetricsInRecreatedGroup);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test(expected = IllegalArgumentException.class)&lt;br/&gt;
+    public void testRecreateWithoutClose() &lt;/p&gt;
{
+        int numMetrics = addToGroup(metrics, false);
+        int numMetricsInRecreatedGroup = addToGroup(metrics, false);
+        // we should never get here
+        throw new RuntimeException(&quot;Created &quot; + numMetricsInRecreatedGroup
+                + &quot; metrics in recreated group. Original=&quot; + numMetrics);
+    }
&lt;p&gt;+&lt;br/&gt;
+    private int addToGroup(ConnectMetrics connectMetrics, boolean shouldClose) {&lt;br/&gt;
+        ConnectMetricsRegistry registry = connectMetrics.registry();&lt;br/&gt;
+        ConnectMetrics.MetricGroup metricGroup = connectMetrics.group(registry.taskGroupName(),&lt;br/&gt;
+                registry.connectorTagName(), &quot;conn_name&quot;);&lt;br/&gt;
+&lt;br/&gt;
+        if (shouldClose) &lt;/p&gt;
{
+            metricGroup.close();
+        }
&lt;p&gt;+&lt;br/&gt;
+        Sensor sensor = metricGroup.sensor(&quot;my_sensor&quot;);&lt;br/&gt;
+        sensor.add(metricName(&quot;x1&quot;), new Max());&lt;br/&gt;
+        sensor.add(metricName(&quot;y2&quot;), new Avg());&lt;br/&gt;
+&lt;br/&gt;
+        return metricGroup.metrics().metrics().size();&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    static MetricName metricName(String name) &lt;/p&gt;
{
+        return new MetricName(name, &quot;test_group&quot;, &quot;metrics for testing&quot;, Collections.&amp;lt;String, String&amp;gt;emptyMap());
+    }
&lt;p&gt;+}&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16348345" author="gunnar.morling" created="Thu, 1 Feb 2018 10:25:25 +0000"  >&lt;p&gt;I also see this issue and can confirm it&apos;s not a connector still stuck in its polling loop.&lt;/p&gt;

&lt;p&gt;That being said I think interrupting &lt;tt&gt;poll()&lt;/tt&gt; after a while after a task fails to stop seems a reasonable thing to do to me (i.e. option #1 from &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rhauch&quot; class=&quot;user-hover&quot; rel=&quot;rhauch&quot;&gt;rhauch&lt;/a&gt;&apos;s comment above). In fact, I was surprised that it is not happening yet, given that &lt;tt&gt;poll()&lt;/tt&gt; is declared to throw &lt;tt&gt;InterruptedException&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Apart from the matter of metrics it may help to prevent threads of incorrectly implemented connectors hang around after stopping the connector. It won&apos;t work in all cases but it should help in many (&lt;tt&gt;poll()&lt;/tt&gt; will usually invoke and block on a method dealing correctly with interruption).&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                                                <inwardlinks description="is duplicated by">
                                        <issuelink>
            <issuekey id="13121391">KAFKA-6279</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13132675">KAFKA-6466</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 41 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3n273:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>ewencp</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>