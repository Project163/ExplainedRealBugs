<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:16:29 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6970] Kafka streams lets the user call init() and close() on a state store, when inside Processors</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6970</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;When using a state store within Transform (and Processor and TransformValues), the user is able to call init() and close() on the state stores. Those APIs should only be called by kafka streams itself.&lt;/p&gt;

&lt;p&gt;If possible, it would be good to guard those APIs so that the user cannot call them.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13163007">KAFKA-6970</key>
            <summary>Kafka streams lets the user call init() and close() on a state store, when inside Processors</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="nizhikov">Nikolay Izhikov</assignee>
                                    <reporter username="wushujames">James Cheng</reporter>
                        <labels>
                    </labels>
                <created>Wed, 30 May 2018 21:09:00 +0000</created>
                <updated>Wed, 27 Feb 2019 03:08:13 +0000</updated>
                            <resolved>Tue, 11 Dec 2018 09:45:03 +0000</resolved>
                                                    <fixVersion>2.2.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16703885" author="mjsax" created="Thu, 29 Nov 2018 22:03:47 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=NIzhikov&quot; class=&quot;user-hover&quot; rel=&quot;nizhikov&quot;&gt;NIzhikov&lt;/a&gt;: this might be something for you to tackle &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="16703896" author="nizhikov" created="Thu, 29 Nov 2018 22:17:21 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt; Thank you.&lt;br/&gt;
I will take care of this issue.&lt;/p&gt;</comment>
                            <comment id="16710463" author="nizhikov" created="Wed, 5 Dec 2018 18:33:01 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt; Seems, all cases from this ticket will be covered in &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7420&quot; title=&quot;Global stores should be guarded as read-only for regular tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7420&quot;&gt;&lt;del&gt;KAFKA-7420&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, when &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7420&quot; title=&quot;Global stores should be guarded as read-only for regular tasks&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7420&quot;&gt;&lt;del&gt;KAFKA-7420&lt;/del&gt;&lt;/a&gt; will be resolved we can close this ticket as duplicate.&lt;br/&gt;
Am I miss something?&lt;/p&gt;</comment>
                            <comment id="16710492" author="mjsax" created="Wed, 5 Dec 2018 18:55:23 +0000"  >&lt;p&gt;It&apos;s different. For this ticket, it&apos;s about &lt;em&gt;all&lt;/em&gt; stores &#8211; not just global stores.&lt;/p&gt;</comment>
                            <comment id="16710580" author="nizhikov" created="Wed, 5 Dec 2018 20:08:18 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt; Got it. Thanks for an answer.&lt;/p&gt;</comment>
                            <comment id="16713742" author="githubbot" created="Sat, 8 Dec 2018 17:34:11 +0000"  >&lt;p&gt;nizhikov opened a new pull request #6016: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6970&quot; title=&quot;Kafka streams lets the user call init() and close() on a state store, when inside Processors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6970&quot;&gt;&lt;del&gt;KAFKA-6970&lt;/del&gt;&lt;/a&gt;: All standard state stores guarded with read only wrapper&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/6016&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/6016&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16716687" author="githubbot" created="Tue, 11 Dec 2018 09:44:22 +0000"  >&lt;p&gt;mjsax closed pull request #6016: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6970&quot; title=&quot;Kafka streams lets the user call init() and close() on a state store, when inside Processors&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6970&quot;&gt;&lt;del&gt;KAFKA-6970&lt;/del&gt;&lt;/a&gt;: All standard state stores guarded with read only wrapper&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/6016&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/6016&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/TupleForwarder.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/TupleForwarder.java&lt;br/&gt;
index ff3ef44894b..99ba0f6ce06 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/TupleForwarder.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/TupleForwarder.java&lt;br/&gt;
@@ -50,9 +50,18 @@&lt;br/&gt;
     private CachedStateStore cachedStateStore(final StateStore store) {&lt;br/&gt;
         if (store instanceof CachedStateStore) &lt;/p&gt;
{
             return (CachedStateStore) store;
-        }
&lt;p&gt; else if (store instanceof WrappedStateStore&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;amp;&amp;amp; ((WrappedStateStore) store).wrappedStore() instanceof CachedStateStore) 
{
-            return (CachedStateStore) ((WrappedStateStore) store).wrappedStore();
+        }
&lt;p&gt; else if (store instanceof WrappedStateStore) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            StateStore wrapped = ((WrappedStateStore) store).wrappedStore();++            while (wrapped instanceof WrappedStateStore &amp;amp;&amp;amp; !(wrapped instanceof CachedStateStore)) {
+                wrapped = ((WrappedStateStore) wrapped).wrappedStore();
+            }++            if (!(wrapped instanceof CachedStateStore)) {
+                return null;
+            }++            return (CachedStateStore) wrapped;         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;         return null;&lt;br/&gt;
     }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java&lt;br/&gt;
index c79ec35328a..e7dd4dbc42a 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java&lt;br/&gt;
@@ -16,6 +16,7 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.processor.internals;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
 import org.apache.kafka.streams.errors.StreamsException;&lt;br/&gt;
 import org.apache.kafka.streams.internals.ApiUtils;&lt;br/&gt;
@@ -37,6 +38,7 @@&lt;/p&gt;

&lt;p&gt; import java.time.Duration;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
+import org.apache.kafka.streams.state.internals.WrappedStateStore.AbstractStateStore;&lt;/p&gt;

&lt;p&gt; import static org.apache.kafka.streams.internals.ApiUtils.prepareMillisCheckFailMsgPrefix;&lt;/p&gt;

&lt;p&gt;@@ -102,7 +104,16 @@ public StateStore getStateStore(final String name) &lt;/p&gt;
{
                     &quot;please file a bug report at https://issues.apache.org/jira/projects/KAFKA.&quot;);
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return stateManager.getStore(name);&lt;br/&gt;
+        final StateStore store = stateManager.getStore(name);&lt;br/&gt;
+        if (store instanceof KeyValueStore) 
{
+            return new KeyValueStoreReadWriteDecorator((KeyValueStore) store);
+        }
&lt;p&gt; else if (store instanceof WindowStore) &lt;/p&gt;
{
+            return new WindowStoreReadWriteDecorator((WindowStore) store);
+        }
&lt;p&gt; else if (store instanceof SessionStore) &lt;/p&gt;
{
+            return new SessionStoreReadWriteDecorator((SessionStore) store);
+        }
&lt;p&gt;+&lt;br/&gt;
+        return store;&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
@@ -196,23 +207,16 @@ public long streamTime() &lt;/p&gt;
{
         return streamTimeSupplier.get();
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private abstract static class StateStoreReadOnlyDecorator&amp;lt;T extends StateStore&amp;gt; implements StateStore {&lt;br/&gt;
+    private abstract static class StateStoreReadOnlyDecorator&amp;lt;T extends StateStore&amp;gt; extends AbstractStateStore {&lt;br/&gt;
         static final String ERROR_MESSAGE = &quot;Global store is read only&quot;;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final T underlying;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;StateStoreReadOnlyDecorator(final T underlying) 
{
-            this.underlying = underlying;
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public String name() {&lt;/li&gt;
	&lt;li&gt;return underlying.name();&lt;br/&gt;
+        StateStoreReadOnlyDecorator(final T inner) 
{
+            super(inner);
         }&lt;br/&gt;
 &lt;br/&gt;
-        @Override&lt;br/&gt;
-        public void init(final ProcessorContext context, final StateStore root) {&lt;br/&gt;
-            underlying.init(context, root);&lt;br/&gt;
+        @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
+        T getInner() {
+            return (T) wrappedStore();
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
@@ -221,44 +225,39 @@ public void flush() {&lt;br/&gt;
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
-        public void close() {
-            underlying.close();
-        }&lt;br/&gt;
-&lt;br/&gt;
-        @Override&lt;br/&gt;
-        public boolean persistent() {&lt;br/&gt;
-            return underlying.persistent();&lt;br/&gt;
+        public void init(final ProcessorContext context, final StateStore root) {
+            throw new UnsupportedOperationException(ERROR_MESSAGE);
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
-        public boolean isOpen() {&lt;br/&gt;
-            return underlying.isOpen();&lt;br/&gt;
+        public void close() {+            throw new UnsupportedOperationException(ERROR_MESSAGE);         }&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     private static class KeyValueStoreReadOnlyDecorator&amp;lt;K, V&amp;gt; extends StateStoreReadOnlyDecorator&amp;lt;KeyValueStore&amp;lt;K, V&amp;gt;&amp;gt; implements KeyValueStore&amp;lt;K, V&amp;gt; {&lt;br/&gt;
-        KeyValueStoreReadOnlyDecorator(final KeyValueStore&amp;lt;K, V&amp;gt; underlying) {&lt;br/&gt;
-            super(underlying);&lt;br/&gt;
+        KeyValueStoreReadOnlyDecorator(final KeyValueStore&amp;lt;K, V&amp;gt; inner) {+            super(inner);         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         @Override&lt;br/&gt;
         public V get(final K key) &lt;/p&gt;
{
-            return underlying.get(key);
+            return getInner().get(key);
         }

&lt;p&gt;         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;K, V&amp;gt; range(final K from, final K to) &lt;/p&gt;
{
-            return underlying.range(from, to);
+            return getInner().range(from, to);
         }

&lt;p&gt;         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;K, V&amp;gt; all() &lt;/p&gt;
{
-            return underlying.all();
+            return getInner().all();
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
         public long approximateNumEntries() {
-            return underlying.approximateNumEntries();
+            return getInner().approximateNumEntries();
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
@@ -283,8 +282,8 @@ public V delete(final K key) {&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     private static class WindowStoreReadOnlyDecorator&amp;lt;K, V&amp;gt; extends StateStoreReadOnlyDecorator&amp;lt;WindowStore&amp;lt;K, V&amp;gt;&amp;gt; implements WindowStore&amp;lt;K, V&amp;gt; {&lt;br/&gt;
-        WindowStoreReadOnlyDecorator(final WindowStore&amp;lt;K, V&amp;gt; underlying) {&lt;br/&gt;
-            super(underlying);&lt;br/&gt;
+        WindowStoreReadOnlyDecorator(final WindowStore&amp;lt;K, V&amp;gt; inner) {
+            super(inner);
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
@@ -299,46 +298,46 @@ public void put(final K key, final V value, final long windowStartTimestamp) {&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
         public V fetch(final K key, final long time) {
-            return underlying.fetch(key, time);
+            return getInner().fetch(key, time);
         }&lt;br/&gt;
 &lt;br/&gt;
         @Deprecated&lt;br/&gt;
         @Override&lt;br/&gt;
         public WindowStoreIterator&amp;lt;V&amp;gt; fetch(final K key, final long timeFrom, final long timeTo) {
-            return underlying.fetch(key, timeFrom, timeTo);
+            return getInner().fetch(key, timeFrom, timeTo);
         }&lt;br/&gt;
 &lt;br/&gt;
         @Deprecated&lt;br/&gt;
         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; fetch(final K from, final K to, final long timeFrom, final long timeTo) {
-            return underlying.fetch(from, to, timeFrom, timeTo);
+            return getInner().fetch(from, to, timeFrom, timeTo);
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; all() {-            return underlying.all();+            return getInner().all();         }

&lt;p&gt;         @Deprecated&lt;br/&gt;
         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; fetchAll(final long timeFrom, final long timeTo) &lt;/p&gt;
{
-            return underlying.fetchAll(timeFrom, timeTo);
+            return getInner().fetchAll(timeFrom, timeTo);
         }
&lt;p&gt;     }&lt;/p&gt;

&lt;p&gt;     private static class SessionStoreReadOnlyDecorator&amp;lt;K, AGG&amp;gt; extends StateStoreReadOnlyDecorator&amp;lt;SessionStore&amp;lt;K, AGG&amp;gt;&amp;gt; implements SessionStore&amp;lt;K, AGG&amp;gt; {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SessionStoreReadOnlyDecorator(final SessionStore&amp;lt;K, AGG&amp;gt; underlying) {&lt;/li&gt;
	&lt;li&gt;super(underlying);&lt;br/&gt;
+        SessionStoreReadOnlyDecorator(final SessionStore&amp;lt;K, AGG&amp;gt; inner) 
{
+            super(inner);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; findSessions(final K key, final long earliestSessionEndTime, final long latestSessionStartTime) &lt;/p&gt;
{
-            return underlying.findSessions(key, earliestSessionEndTime, latestSessionStartTime);
+            return getInner().findSessions(key, earliestSessionEndTime, latestSessionStartTime);
         }

&lt;p&gt;         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; findSessions(final K keyFrom, final K keyTo, final long earliestSessionEndTime, final long latestSessionStartTime) &lt;/p&gt;
{
-            return underlying.findSessions(keyFrom, keyTo, earliestSessionEndTime, latestSessionStartTime);
+            return getInner().findSessions(keyFrom, keyTo, earliestSessionEndTime, latestSessionStartTime);
         }

&lt;p&gt;         @Override&lt;br/&gt;
@@ -353,12 +352,161 @@ public void put(final Windowed&amp;lt;K&amp;gt; sessionKey, final AGG aggregate) {&lt;/p&gt;

&lt;p&gt;         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; fetch(final K key) &lt;/p&gt;
{
-            return underlying.fetch(key);
+            return getInner().fetch(key);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; fetch(final K from, final K to) &lt;/p&gt;
{
+            return getInner().fetch(from, to);
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    private abstract static class StateStoreReadWriteDecorator&amp;lt;T extends StateStore&amp;gt; extends AbstractStateStore {&lt;br/&gt;
+        static final String ERROR_MESSAGE = &quot;This method may only be called by Kafka Streams&quot;;&lt;br/&gt;
+&lt;br/&gt;
+        StateStoreReadWriteDecorator(final T inner) &lt;/p&gt;
{
+            super(inner);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
+        T wrapped() {
+            return (T) super.wrappedStore();
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void init(final ProcessorContext context, final StateStore root) {
+            throw new UnsupportedOperationException(ERROR_MESSAGE);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void close() {+            throw new UnsupportedOperationException(ERROR_MESSAGE);+        }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private static class KeyValueStoreReadWriteDecorator&amp;lt;K, V&amp;gt; extends StateStoreReadWriteDecorator&amp;lt;KeyValueStore&amp;lt;K, V&amp;gt;&amp;gt; implements KeyValueStore&amp;lt;K, V&amp;gt; {&lt;br/&gt;
+        KeyValueStoreReadWriteDecorator(final KeyValueStore&amp;lt;K, V&amp;gt; inner) {+            super(inner);+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public V get(final K key) &lt;/p&gt;
{
+            return wrapped().get(key);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;K, V&amp;gt; range(final K from, final K to) &lt;/p&gt;
{
+            return wrapped().range(from, to);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;K, V&amp;gt; all() &lt;/p&gt;
{
+            return wrapped().all();
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public long approximateNumEntries() {
+            return wrapped().approximateNumEntries();
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void put(final K key, final V value) {
+            wrapped().put(key, value);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public V putIfAbsent(final K key, final V value) {
+            return wrapped().putIfAbsent(key, value);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void putAll(final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; entries) {
+            wrapped().putAll(entries);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public V delete(final K key) {
+            return wrapped().delete(key);
+        }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private static class WindowStoreReadWriteDecorator&amp;lt;K, V&amp;gt; extends StateStoreReadWriteDecorator&amp;lt;WindowStore&amp;lt;K, V&amp;gt;&amp;gt; implements WindowStore&amp;lt;K, V&amp;gt; {&lt;br/&gt;
+        WindowStoreReadWriteDecorator(final WindowStore&amp;lt;K, V&amp;gt; inner) {
+            super(inner);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void put(final K key, final V value) {+            wrapped().put(key, value);+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void put(final K key, final V value, final long windowStartTimestamp) {
+            wrapped().put(key, value, windowStartTimestamp);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public V fetch(final K key, final long time) {
+            return wrapped().fetch(key, time);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Deprecated&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public WindowStoreIterator&amp;lt;V&amp;gt; fetch(final K key, final long timeFrom, final long timeTo) {
+            return wrapped().fetch(key, timeFrom, timeTo);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Deprecated&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; fetch(final K from, final K to, final long timeFrom, final long timeTo) {
+            return wrapped().fetch(from, to, timeFrom, timeTo);
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; all() {+            return wrapped().all();+        }
&lt;p&gt;+&lt;br/&gt;
+        @Deprecated&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; fetchAll(final long timeFrom, final long timeTo) &lt;/p&gt;
{
+            return wrapped().fetchAll(timeFrom, timeTo);
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    private static class SessionStoreReadWriteDecorator&amp;lt;K, AGG&amp;gt; extends StateStoreReadWriteDecorator&amp;lt;SessionStore&amp;lt;K, AGG&amp;gt;&amp;gt; implements SessionStore&amp;lt;K, AGG&amp;gt; {&lt;br/&gt;
+        SessionStoreReadWriteDecorator(final SessionStore&amp;lt;K, AGG&amp;gt; inner) &lt;/p&gt;
{
+            super(inner);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; findSessions(final K key, final long earliestSessionEndTime, final long latestSessionStartTime) &lt;/p&gt;
{
+            return wrapped().findSessions(key, earliestSessionEndTime, latestSessionStartTime);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; findSessions(final K keyFrom, final K keyTo, final long earliestSessionEndTime, final long latestSessionStartTime) &lt;/p&gt;
{
+            return wrapped().findSessions(keyFrom, keyTo, earliestSessionEndTime, latestSessionStartTime);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void remove(final Windowed&amp;lt;K&amp;gt; sessionKey) &lt;/p&gt;
{
+            wrapped().remove(sessionKey);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public void put(final Windowed&amp;lt;K&amp;gt; sessionKey, final AGG aggregate) &lt;/p&gt;
{
+            wrapped().put(sessionKey, aggregate);
+        }
&lt;p&gt;+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; fetch(final K key) &lt;/p&gt;
{
+            return wrapped().fetch(key);
         }

&lt;p&gt;         @Override&lt;br/&gt;
         public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, AGG&amp;gt; fetch(final K from, final K to) &lt;/p&gt;
{
-            return underlying.fetch(from, to);
+            return wrapped().fetch(from, to);
         }
&lt;p&gt;     }&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedStateStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedStateStore.java&lt;br/&gt;
index 38f966edabd..570c465f77f 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedStateStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedStateStore.java&lt;br/&gt;
@@ -41,7 +41,7 @@&lt;br/&gt;
     abstract class AbstractStateStore implements WrappedStateStore {&lt;br/&gt;
         final StateStore innerState;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;AbstractStateStore(final StateStore inner) {&lt;br/&gt;
+        protected AbstractStateStore(final StateStore inner) 
{
             this.innerState = inner;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorContextImplTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorContextImplTest.java&lt;br/&gt;
index fa5f597aa89..f956e0ed5a4 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorContextImplTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorContextImplTest.java&lt;br/&gt;
@@ -18,6 +18,7 @@&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.function.Consumer;&lt;/p&gt;

&lt;p&gt;@@ -38,8 +39,9 @@&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;-import static java.util.Collections.emptySet;&lt;br/&gt;
+import static java.util.Arrays.asList;&lt;br/&gt;
 import static org.easymock.EasyMock.anyLong;&lt;br/&gt;
+import static org.easymock.EasyMock.anyObject;&lt;br/&gt;
 import static org.easymock.EasyMock.anyString;&lt;br/&gt;
 import static org.easymock.EasyMock.expect;&lt;br/&gt;
 import static org.easymock.EasyMock.expectLastCall;&lt;br/&gt;
@@ -56,8 +58,14 @@&lt;br/&gt;
     private static final long VAL = 42L;&lt;br/&gt;
     private static final String STORE_NAME = &quot;underlying-store&quot;;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private boolean initExecuted;&lt;/li&gt;
	&lt;li&gt;private boolean closeExecuted;&lt;br/&gt;
+    private boolean flushExecuted;&lt;br/&gt;
+    private boolean putExecuted;&lt;br/&gt;
+    private boolean putIfAbsentExecuted;&lt;br/&gt;
+    private boolean putAllExecuted;&lt;br/&gt;
+    private boolean deleteExecuted;&lt;br/&gt;
+    private boolean removeExecuted;&lt;br/&gt;
+    private boolean put3argExecuted;&lt;br/&gt;
+&lt;br/&gt;
     private KeyValueIterator&amp;lt;String, Long&amp;gt; rangeIter;&lt;br/&gt;
     private KeyValueIterator&amp;lt;String, Long&amp;gt; allIter;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -66,6 +74,14 @@&lt;/p&gt;

&lt;p&gt;     @Before&lt;br/&gt;
     public void setup() {&lt;br/&gt;
+        flushExecuted = false;&lt;br/&gt;
+        putExecuted = false;&lt;br/&gt;
+        putIfAbsentExecuted = false;&lt;br/&gt;
+        putAllExecuted = false;&lt;br/&gt;
+        deleteExecuted = false;&lt;br/&gt;
+        removeExecuted = false;&lt;br/&gt;
+        put3argExecuted = false;&lt;br/&gt;
+&lt;br/&gt;
         rangeIter = mock(KeyValueIterator.class);&lt;br/&gt;
         allIter = mock(KeyValueIterator.class);&lt;br/&gt;
         windowStoreIter = mock(WindowStoreIterator.class);&lt;br/&gt;
@@ -82,9 +98,14 @@ public void setup() {&lt;/p&gt;

&lt;p&gt;         final ProcessorStateManager stateManager = mock(ProcessorStateManager.class);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;expect(stateManager.getGlobalStore(&quot;KeyValueStore&quot;)).andReturn(keyValueStoreMock());&lt;/li&gt;
	&lt;li&gt;expect(stateManager.getGlobalStore(&quot;WindowStore&quot;)).andReturn(windowStoreMock());&lt;/li&gt;
	&lt;li&gt;expect(stateManager.getGlobalStore(&quot;SessionStore&quot;)).andReturn(sessionStoreMock());&lt;br/&gt;
+        expect(stateManager.getGlobalStore(&quot;GlobalKeyValueStore&quot;)).andReturn(keyValueStoreMock());&lt;br/&gt;
+        expect(stateManager.getGlobalStore(&quot;GlobalWindowStore&quot;)).andReturn(windowStoreMock());&lt;br/&gt;
+        expect(stateManager.getGlobalStore(&quot;GlobalSessionStore&quot;)).andReturn(sessionStoreMock());&lt;br/&gt;
+        expect(stateManager.getGlobalStore(anyString())).andReturn(null);&lt;br/&gt;
+&lt;br/&gt;
+        expect(stateManager.getStore(&quot;LocalKeyValueStore&quot;)).andReturn(keyValueStoreMock());&lt;br/&gt;
+        expect(stateManager.getStore(&quot;LocalWindowStore&quot;)).andReturn(windowStoreMock());&lt;br/&gt;
+        expect(stateManager.getStore(&quot;LocalSessionStore&quot;)).andReturn(sessionStoreMock());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         replay(stateManager);&lt;/p&gt;

&lt;p&gt;@@ -98,16 +119,20 @@ public void setup() &lt;/p&gt;
{
             mock(ThreadCache.class)
         );
 
-        context.setCurrentNode(new ProcessorNode&amp;lt;String, Long&amp;gt;(&quot;fake&quot;, null, emptySet()));
+        context.setCurrentNode(new ProcessorNode&amp;lt;String, Long&amp;gt;(&quot;fake&quot;, null,
+            new HashSet&amp;lt;&amp;gt;(asList(&quot;LocalKeyValueStore&quot;, &quot;LocalWindowStore&quot;, &quot;LocalSessionStore&quot;))));
     }

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testKeyValueStore() {&lt;/li&gt;
	&lt;li&gt;doTest(&quot;KeyValueStore&quot;, (Consumer&amp;lt;KeyValueStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.put(&quot;1&quot;, 1L), &quot;put&quot;);&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.putIfAbsent(&quot;1&quot;, 1L), &quot;putIfAbsent&quot;);&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.putAll(Collections.emptyList()), &quot;putAll&quot;);&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.delete(&quot;1&quot;), &quot;delete&quot;);&lt;br/&gt;
+    public void globalKeyValueStoreShouldBeReadOnly() {&lt;br/&gt;
+        doTest(&quot;GlobalKeyValueStore&quot;, (Consumer&amp;lt;KeyValueStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; {&lt;br/&gt;
+            verifyStoreCannotBeInitializedOrClosed(store);&lt;br/&gt;
+&lt;br/&gt;
+            checkThrowsUnsupportedOperation(store::flush, &quot;flush()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.put(&quot;1&quot;, 1L), &quot;put()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.putIfAbsent(&quot;1&quot;, 1L), &quot;putIfAbsent()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.putAll(Collections.emptyList()), &quot;putAll()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.delete(&quot;1&quot;), &quot;delete()&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             assertEquals((Long) VAL, store.get(KEY));&lt;br/&gt;
             assertEquals(rangeIter, store.range(&quot;one&quot;, &quot;two&quot;));&lt;br/&gt;
@@ -117,10 +142,13 @@ public void testKeyValueStore() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testWindowStore() {&lt;/li&gt;
	&lt;li&gt;doTest(&quot;WindowStore&quot;, (Consumer&amp;lt;WindowStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.put(&quot;1&quot;, 1L, 1L), &quot;put&quot;);&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.put(&quot;1&quot;, 1L), &quot;put&quot;);&lt;br/&gt;
+    public void globalWindowStoreShouldBeReadOnly() {&lt;br/&gt;
+        doTest(&quot;GlobalWindowStore&quot;, (Consumer&amp;lt;WindowStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; {&lt;br/&gt;
+            verifyStoreCannotBeInitializedOrClosed(store);&lt;br/&gt;
+&lt;br/&gt;
+            checkThrowsUnsupportedOperation(store::flush, &quot;flush()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.put(&quot;1&quot;, 1L, 1L), &quot;put()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.put(&quot;1&quot;, 1L), &quot;put()&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             assertEquals(iters.get(0), store.fetchAll(0L, 0L));&lt;br/&gt;
             assertEquals(windowStoreIter, store.fetch(KEY, 0L, 1L));&lt;br/&gt;
@@ -131,10 +159,13 @@ public void testWindowStore() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testSessionStore() {&lt;/li&gt;
	&lt;li&gt;doTest(&quot;SessionStore&quot;, (Consumer&amp;lt;SessionStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; {&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.remove(null), &quot;remove&quot;);&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(() -&amp;gt; store.put(null, null), &quot;put&quot;);&lt;br/&gt;
+    public void globalSessionStoreShouldBeReadOnly() {&lt;br/&gt;
+        doTest(&quot;GlobalSessionStore&quot;, (Consumer&amp;lt;SessionStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; {&lt;br/&gt;
+            verifyStoreCannotBeInitializedOrClosed(store);&lt;br/&gt;
+&lt;br/&gt;
+            checkThrowsUnsupportedOperation(store::flush, &quot;flush()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.remove(null), &quot;remove()&quot;);&lt;br/&gt;
+            checkThrowsUnsupportedOperation(() -&amp;gt; store.put(null, null), &quot;put()&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             assertEquals(iters.get(3), store.findSessions(KEY, 1L, 2L));&lt;br/&gt;
             assertEquals(iters.get(4), store.findSessions(KEY, KEY, 1L, 2L));&lt;br/&gt;
@@ -143,6 +174,77 @@ public void testSessionStore() {&lt;br/&gt;
         });&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    @Test&lt;br/&gt;
+    public void localKeyValueStoreShouldNotAllowInitOrClose() {&lt;br/&gt;
+        doTest(&quot;LocalKeyValueStore&quot;, (Consumer&amp;lt;KeyValueStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; &lt;/p&gt;
{
+            verifyStoreCannotBeInitializedOrClosed(store);
+
+            store.flush();
+            assertTrue(flushExecuted);
+
+            store.put(&quot;1&quot;, 1L);
+            assertTrue(putExecuted);
+
+            store.putIfAbsent(&quot;1&quot;, 1L);
+            assertTrue(putIfAbsentExecuted);
+
+            store.putAll(Collections.emptyList());
+            assertTrue(putAllExecuted);
+
+            store.delete(&quot;1&quot;);
+            assertTrue(deleteExecuted);
+
+            assertEquals((Long) VAL, store.get(KEY));
+            assertEquals(rangeIter, store.range(&quot;one&quot;, &quot;two&quot;));
+            assertEquals(allIter, store.all());
+            assertEquals(VAL, store.approximateNumEntries());
+        }
&lt;p&gt;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void localWindowStoreShouldNotAllowInitOrClose() {&lt;br/&gt;
+        doTest(&quot;LocalWindowStore&quot;, (Consumer&amp;lt;WindowStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; &lt;/p&gt;
{
+            verifyStoreCannotBeInitializedOrClosed(store);
+
+            store.flush();
+            assertTrue(flushExecuted);
+
+            store.put(&quot;1&quot;, 1L);
+            assertTrue(putExecuted);
+
+            store.put(&quot;1&quot;, 1L, 1L);
+            assertTrue(put3argExecuted);
+
+            assertEquals(iters.get(0), store.fetchAll(0L, 0L));
+            assertEquals(windowStoreIter, store.fetch(KEY, 0L, 1L));
+            assertEquals(iters.get(1), store.fetch(KEY, KEY, 0L, 1L));
+            assertEquals((Long) VAL, store.fetch(KEY, 1L));
+            assertEquals(iters.get(2), store.all());
+        }
&lt;p&gt;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void localSessionStoreShouldNotAllowInitOrClose() {&lt;br/&gt;
+        doTest(&quot;LocalSessionStore&quot;, (Consumer&amp;lt;SessionStore&amp;lt;String, Long&amp;gt;&amp;gt;) store -&amp;gt; &lt;/p&gt;
{
+            verifyStoreCannotBeInitializedOrClosed(store);
+
+            store.flush();
+            assertTrue(flushExecuted);
+
+            store.remove(null);
+            assertTrue(removeExecuted);
+
+            store.put(null, null);
+            assertTrue(putExecuted);
+
+            assertEquals(iters.get(3), store.findSessions(KEY, 1L, 2L));
+            assertEquals(iters.get(4), store.findSessions(KEY, KEY, 1L, 2L));
+            assertEquals(iters.get(5), store.fetch(KEY));
+            assertEquals(iters.get(6), store.fetch(KEY, KEY));
+        }
&lt;p&gt;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
     private KeyValueStore&amp;lt;String, Long&amp;gt; keyValueStoreMock() {&lt;br/&gt;
         final KeyValueStore&amp;lt;String, Long&amp;gt; keyValueStoreMock = mock(KeyValueStore.class);&lt;/p&gt;

&lt;p&gt;@@ -154,6 +256,31 @@ public void testSessionStore() {&lt;br/&gt;
         expect(keyValueStoreMock.range(&quot;one&quot;, &quot;two&quot;)).andReturn(rangeIter);&lt;br/&gt;
         expect(keyValueStoreMock.all()).andReturn(allIter);&lt;/p&gt;

&lt;p&gt;+&lt;br/&gt;
+        keyValueStoreMock.put(anyString(), anyLong());&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; &lt;/p&gt;
{
+            putExecuted = true;
+            return null;
+        });&lt;br/&gt;
+&lt;br/&gt;
+        keyValueStoreMock.putIfAbsent(anyString(), anyLong());&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; {
+            putIfAbsentExecuted = true;
+            return null;
+        });&lt;br/&gt;
+&lt;br/&gt;
+        keyValueStoreMock.putAll(anyObject(List.class));&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; {
+            putAllExecuted = true;
+            return null;
+        });&lt;br/&gt;
+&lt;br/&gt;
+        keyValueStoreMock.delete(anyString());&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; {
+            deleteExecuted = true;
+            return null;
+        });&lt;br/&gt;
+&lt;br/&gt;
         replay(keyValueStoreMock);&lt;br/&gt;
 &lt;br/&gt;
         return keyValueStoreMock;&lt;br/&gt;
@@ -170,11 +297,24 @@ public void testSessionStore() {&lt;br/&gt;
         expect(windowStore.fetch(anyString(), anyLong())).andReturn(VAL);&lt;br/&gt;
         expect(windowStore.all()).andReturn(iters.get(2));&lt;br/&gt;
 &lt;br/&gt;
+        windowStore.put(anyString(), anyLong());&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; {+            putExecuted = true;+            return null;+        }
&lt;p&gt;);&lt;br/&gt;
+&lt;br/&gt;
+        windowStore.put(anyString(), anyLong(), anyLong());&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; &lt;/p&gt;
{
+            put3argExecuted = true;
+            return null;
+        }
&lt;p&gt;);&lt;br/&gt;
+&lt;br/&gt;
         replay(windowStore);&lt;/p&gt;

&lt;p&gt;         return windowStore;&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
     private SessionStore&amp;lt;String, Long&amp;gt; sessionStoreMock() {&lt;br/&gt;
         final SessionStore&amp;lt;String, Long&amp;gt; sessionStore = mock(SessionStore.class);&lt;/p&gt;

&lt;p&gt;@@ -185,25 +325,31 @@ public void testSessionStore() {&lt;br/&gt;
         expect(sessionStore.fetch(anyString())).andReturn(iters.get(5));&lt;br/&gt;
         expect(sessionStore.fetch(anyString(), anyString())).andReturn(iters.get(6));&lt;/p&gt;

&lt;p&gt;+        sessionStore.put(anyObject(Windowed.class), anyLong());&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; &lt;/p&gt;
{
+            putExecuted = true;
+            return null;
+        }
&lt;p&gt;);&lt;br/&gt;
+&lt;br/&gt;
+        sessionStore.remove(anyObject(Windowed.class));&lt;br/&gt;
+        expectLastCall().andAnswer(() -&amp;gt; &lt;/p&gt;
{
+            removeExecuted = true;
+            return null;
+        }
&lt;p&gt;);&lt;br/&gt;
+&lt;br/&gt;
         replay(sessionStore);&lt;/p&gt;

&lt;p&gt;         return sessionStore;&lt;br/&gt;
     }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void initStateStoreMock(final StateStore windowStore) {&lt;/li&gt;
	&lt;li&gt;expect(windowStore.name()).andReturn(STORE_NAME);&lt;/li&gt;
	&lt;li&gt;expect(windowStore.persistent()).andReturn(true);&lt;/li&gt;
	&lt;li&gt;expect(windowStore.isOpen()).andReturn(true);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;windowStore.init(null, null);&lt;/li&gt;
	&lt;li&gt;expectLastCall().andAnswer(() -&amp;gt; 
{
-            initExecuted = true;
-            return null;
-        }
&lt;p&gt;);&lt;br/&gt;
+    private void initStateStoreMock(final StateStore stateStore) {&lt;br/&gt;
+        expect(stateStore.name()).andReturn(STORE_NAME);&lt;br/&gt;
+        expect(stateStore.persistent()).andReturn(true);&lt;br/&gt;
+        expect(stateStore.isOpen()).andReturn(true);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;windowStore.close();&lt;br/&gt;
+        stateStore.flush();&lt;br/&gt;
         expectLastCall().andAnswer(() -&amp;gt; 
{
-            closeExecuted = true;
+            flushExecuted = true;
             return null;
         }
&lt;p&gt;);&lt;br/&gt;
     }&lt;br/&gt;
@@ -215,8 +361,6 @@ private void initStateStoreMock(final StateStore windowStore) {&lt;br/&gt;
             public void init(final ProcessorContext context) &lt;/p&gt;
{
                 final T store = (T) context.getStateStore(name);
 
-                checkStateStoreMethods(store);
-
                 checker.accept(store);
 
             }
&lt;p&gt;@@ -235,18 +379,13 @@ public void close() &lt;/p&gt;
{
         processor.init(context);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void checkStateStoreMethods(final StateStore store) {&lt;/li&gt;
	&lt;li&gt;checkThrowsUnsupportedOperation(store::flush, &quot;flush&quot;);&lt;br/&gt;
-&lt;br/&gt;
+    private void verifyStoreCannotBeInitializedOrClosed(final StateStore store) 
{
         assertEquals(STORE_NAME, store.name());
         assertTrue(store.persistent());
         assertTrue(store.isOpen());
 
-        store.init(null, null);
-        assertTrue(initExecuted);
-
-        store.close();
-        assertTrue(closeExecuted);
+        checkThrowsUnsupportedOperation(() -&amp;gt; store.init(null, null), &quot;init()&quot;);
+        checkThrowsUnsupportedOperation(store::close, &quot;close()&quot;);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private void checkThrowsUnsupportedOperation(final Runnable check, final String name) {&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorTopologyTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorTopologyTest.java&lt;br/&gt;
index 11050fe6f55..14b94dadab4 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorTopologyTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorTopologyTest.java&lt;br/&gt;
@@ -662,11 +662,6 @@ public void init(final ProcessorContext context) {&lt;br/&gt;
         public void process(final String key, final String value) &lt;/p&gt;
{
             store.put(key, value);
         }
&lt;p&gt;-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void close() 
{
-            store.close();
-        }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private &amp;lt;K, V&amp;gt; ProcessorSupplier&amp;lt;K, V&amp;gt; define(final Processor&amp;lt;K, V&amp;gt; processor) {&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16746883" author="mjsax" created="Sat, 19 Jan 2019 01:25:17 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=NIzhikov&quot; class=&quot;user-hover&quot; rel=&quot;nizhikov&quot;&gt;NIzhikov&lt;/a&gt; I just realized, that we should do the same thing for global stores, within &lt;tt&gt;GlobalProcessorContextImpl&lt;/tt&gt;. Do you want to do a follow up PR?&lt;/p&gt;</comment>
                            <comment id="16778821" author="mjsax" created="Wed, 27 Feb 2019 03:08:13 +0000"  >&lt;p&gt;Created &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-8006&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-8006&lt;/a&gt;&#160;as follow up because it will get a new &quot;fix version&quot; number.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13218226">KAFKA-8006</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13185913">KAFKA-7420</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 years, 37 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ubyn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>