<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:15:48 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-7519] Transactional Ids Left in Pending State by TransactionStateManager During Transactional Id Expiration Are Unusable</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-7519</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;After digging into a case where an exactly-once streams process was bizarrely unable to process incoming data, we observed the following:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;StreamThreads stalling while creating a producer, eventually resulting in no consumption by that streams process. Looking into those threads, we found they were stuck in a loop, sending InitProducerIdRequests and always receiving back the retriable error CONCURRENT_TRANSACTIONS and trying again. These requests always had the same transactional id.&lt;/li&gt;
	&lt;li&gt;After changing the streams process to not use exactly-once, it was able to process messages with no problems.&lt;/li&gt;
	&lt;li&gt;Alternatively, changing the applicationId for that streams process, it was able to process with no problems.&lt;/li&gt;
	&lt;li&gt;Every hour,&#160; every broker would fail the task `transactionalId-expiration` with the following error:
	&lt;ul&gt;
		&lt;li&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
{&lt;span class=&quot;code-quote&quot;&gt;&quot;exception&quot;&lt;/span&gt;:{&lt;span class=&quot;code-quote&quot;&gt;&quot;stacktrace&quot;&lt;/span&gt;:&quot;java.lang.IllegalStateException: Preparing transaction state transition to Dead &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; it already a pending sta
te Dead
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionMetadata.prepareTransitionTo(TransactionMetadata.scala:262)
&#160;&#160; &#160;at kafka.coordinator
.transaction.TransactionMetadata.prepareDead(TransactionMetadata.scala:237)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$a
nonfun$enableTransactionalIdExpiration$1$$anonfun$apply$mcV$sp$1$$anonfun$2$$anonfun$apply$9$$anonfun$3.apply(TransactionStateManager.scal
a:151)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$anonfun$enableTransactionalIdExpiration$1$$anonfun$apply$mcV$sp$1$$ano
nfun$2$$anonfun$apply$9$$anonfun$3.apply(TransactionStateManager.scala:151)
&#160;&#160; &#160;at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:251)
&#160;&#160; &#160;at
&#160;kafka.coordinator.transaction.TransactionMetadata.inLock(TransactionMetadata.scala:172)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionSt
ateManager$$anonfun$enableTransactionalIdExpiration$1$$anonfun$apply$mcV$sp$1$$anonfun$2$$anonfun$apply$9.apply(TransactionStateManager.sc
ala:150)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$anonfun$enableTransactionalIdExpiration$1$$anonfun$apply$mcV$sp$1$$a
nonfun$2$$anonfun$apply$9.apply(TransactionStateManager.scala:149)
&#160;&#160; &#160;at scala.collection.TraversableLike$$anonfun$map$1.apply(Traversable
Like.scala:234)
&#160;&#160; &#160;at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234)
&#160;&#160; &#160;at scala.collection.immutable.Li
st.foreach(List.scala:392)
&#160;&#160; &#160;at scala.collection.TraversableLike$&lt;span class=&quot;code-keyword&quot;&gt;class.&lt;/span&gt;map(TraversableLike.scala:234)
&#160;&#160; &#160;at scala.collection.immutable.Li
st.map(List.scala:296)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$anonfun$enableTransactionalIdExpiration$1$$anonfun$app
ly$mcV$sp$1$$anonfun$2.apply(TransactionStateManager.scala:149)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$anonfun$enabl
eTransactionalIdExpiration$1$$anonfun$apply$mcV$sp$1$$anonfun$2.apply(TransactionStateManager.scala:142)
&#160;&#160; &#160;at scala.collection.Traversabl
eLike$$anonfun$flatMap$1.apply(TraversableLike.scala:241)
&#160;&#160; &#160;at scala.collection.TraversableLike$$anonfun$flatMap$1.apply(TraversableLike.
scala:241)
&#160;&#160; &#160;at scala.collection.mutable.HashMap$$anonfun$foreach$1.apply(HashMap.scala:130)
&#160;&#160; &#160;at scala.collection.mutable.HashMap$$anon
fun$foreach$1.apply(HashMap.scala:130)
&#160;&#160; &#160;at scala.collection.mutable.HashTable$&lt;span class=&quot;code-keyword&quot;&gt;class.&lt;/span&gt;foreachEntry(HashTable.scala:236)
&#160;&#160; &#160;at scala.collec
tion.mutable.HashMap.foreachEntry(HashMap.scala:40)
&#160;&#160; &#160;at scala.collection.mutable.HashMap.foreach(HashMap.scala:130)
&#160;&#160; &#160;at scala.collecti
on.TraversableLike$&lt;span class=&quot;code-keyword&quot;&gt;class.&lt;/span&gt;flatMap(TraversableLike.scala:241)
&#160;&#160; &#160;at scala.collection.AbstractTraversable.flatMap(Traversable.scala:104)
&#160;&#160; &#160;a
t kafka.coordinator.transaction.TransactionStateManager$$anonfun$enableTransactionalIdExpiration$1$$anonfun$apply$mcV$sp$1.apply$mcV$sp(Tr
ansactionStateManager.scala:142)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$anonfun$enableTransactionalIdExpiration$1$$a
nonfun$apply$mcV$sp$1.apply(TransactionStateManager.scala:140)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$anonfun$enable
TransactionalIdExpiration$1$$anonfun$apply$mcV$sp$1.apply(TransactionStateManager.scala:140)
&#160;&#160; &#160;at kafka.utils.CoreUtils$.inLock(CoreUtils
.scala:251)
&#160;&#160; &#160;at kafka.utils.CoreUtils$.inReadLock(CoreUtils.scala:257)
&#160;&#160; &#160;at kafka.coordinator.transaction.TransactionStateManager$$anon
fun$enableTransactionalIdExpiration$1.apply$mcV$sp(TransactionStateManager.scala:140)
&#160;&#160; &#160;at kafka.utils.KafkaScheduler$$anonfun$1.apply$mc
V$sp(KafkaScheduler.scala:114)
&#160;&#160; &#160;at kafka.utils.CoreUtils$$anon$1.run(CoreUtils.scala:63)
&#160;&#160; &#160;at java.util.concurrent.Executors$RunnableAd
apter.call(Executors.java:511)
&#160;&#160; &#160;at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308)
&#160;&#160; &#160;at java.util.concurrent.Scheduled
ThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180)
&#160;&#160; &#160;at java.util.concurrent.ScheduledThreadPoolExec
utor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294)
&#160;&#160; &#160;at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecu
tor.java:1149)
&#160;&#160; &#160;at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
&#160;&#160; &#160;at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.jav
a:748)&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;exception_class&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;java.lang.IllegalStateException&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;exception_message&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;Preparing transaction state transition to Dead &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; it a
lready a pending state Dead&lt;span class=&quot;code-quote&quot;&gt;&quot;},&quot;&lt;/span&gt;source_host&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;kafka-broker-4.kafka-broker.&lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt;.svc.cluster.local&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;method&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;error&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;level&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;ERROR&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;message&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;Uncaught exception in scheduled task transactionalId-expiration&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;mdc&lt;span class=&quot;code-quote&quot;&gt;&quot;:{},&quot;&lt;/span&gt;file&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;Logging.scala&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;line_number&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;76&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;thread_name&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;transaction-log-manager-0&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;logger_name&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;kafka.utils.KafkaScheduler&lt;span class=&quot;code-quote&quot;&gt;&quot;,&quot;&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;class&amp;&lt;/span&gt;amp;amp;lt;span class=&lt;span class=&quot;code-quote&quot;&gt;&quot;code-quote&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;code-quote&quot;&gt;&quot;:&quot;&lt;/span&gt;kafka.utils.Logging$class&quot;}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Based on these problems and having read a bit of the server source, I guessed that this would all be explained by there being TransactionMetadata instances that are stuck in a pendingState.&lt;/p&gt;

&lt;p&gt;After doing a heap dump of the broker that was returning the error for our particular group, we found this:&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://issues.apache.org/jira/secure/attachment/12944608/12944608_image-2018-10-18-13-02-22-371.png&quot; height=&quot;224&quot; width=&quot;723&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;There were indeed a bunch of live TransactionMetadata instances that had a pending state of&#160; &quot;Dead&quot; but should have already been cleaned up, confirming my guess.&lt;/p&gt;

&lt;p&gt;Finally, after reading carefully through the TransactionStateManager callback for producing tombstones for expired transactional ids I noticed that if there is any error returned by the ReplicaManager, those transactions will&#160;&lt;em&gt;not&lt;/em&gt; have their pending state cleared.&lt;/p&gt;

&lt;p&gt;&#8212;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;Shortsummary%3A&quot;&gt;&lt;/a&gt;Short summary:&lt;/h3&gt;

&lt;p&gt;If the ReplicaManager fails to append the tombstone records for expiring a transactional id (in my case, this likely happened during a rebalance that wasn&apos;t properly rate limited), the broker fails to clear it&apos;s pending state for that transactional id, blocking any future actions on that transactional id (including cleanup), until the broker is restarted or another broker without that problem becomes the coordinator for that transactional id.&lt;/p&gt;

&lt;p&gt;&#8212;&lt;br/&gt;
 Related:&lt;br/&gt;
 There was a very similar case in &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-5351&quot; title=&quot;Broker clean bounce test puts the broker into a &amp;#39;CONCURRENT_TRANSACTIONS&amp;#39; state permanently&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-5351&quot;&gt;&lt;del&gt;KAFKA-5351&lt;/del&gt;&lt;/a&gt; where not clearing a TransactionMetadata&apos;s pendingState caused similar issues.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13192670">KAFKA-7519</key>
            <summary>Transactional Ids Left in Pending State by TransactionStateManager During Transactional Id Expiration Are Unusable</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="howellbridger">Bridger Howell</assignee>
                                    <reporter username="howellbridger">Bridger Howell</reporter>
                        <labels>
                    </labels>
                <created>Thu, 18 Oct 2018 19:04:28 +0000</created>
                <updated>Fri, 10 Jan 2020 09:37:30 +0000</updated>
                            <resolved>Mon, 22 Oct 2018 12:17:14 +0000</resolved>
                                    <version>2.0.0</version>
                                    <fixVersion>2.0.1</fixVersion>
                    <fixVersion>2.1.0</fixVersion>
                                    <component>core</component>
                    <component>producer </component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>8</watches>
                                                                                                                <comments>
                            <comment id="16655934" author="hachikuji" created="Thu, 18 Oct 2018 21:51:59 +0000"  >&lt;p&gt;Good find and thanks for the investigation.&lt;/p&gt;</comment>
                            <comment id="16655973" author="howellbridger" created="Thu, 18 Oct 2018 22:19:33 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dhruvilshah&quot; class=&quot;user-hover&quot; rel=&quot;dhruvilshah&quot;&gt;dhruvilshah&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hachikuji&quot; class=&quot;user-hover&quot; rel=&quot;hachikuji&quot;&gt;hachikuji&lt;/a&gt; thanks for looking at this!&lt;/p&gt;

&lt;p&gt;I&apos;d prepared a patch, since it seemed pretty straight forward to fix, but I wasn&apos;t able to get it to pass all of the tests running locally. I&apos;ve uploaded it here in case it&apos;s useful or there&apos;s a problem with the tests.&lt;/p&gt;</comment>
                            <comment id="16657056" author="dhruvilshah" created="Fri, 19 Oct 2018 16:41:31 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=howellbridger&quot; class=&quot;user-hover&quot; rel=&quot;howellbridger&quot;&gt;howellbridger&lt;/a&gt; thanks for the patch! Do you want to open a PR? I could help reviewing the code and look into any failures if needed.&lt;/p&gt;</comment>
                            <comment id="16657556" author="githubbot" created="Fri, 19 Oct 2018 23:31:35 +0000"  >&lt;p&gt;BirdHowl opened a new pull request #5820: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7519&quot; title=&quot;Transactional Ids Left in Pending State by TransactionStateManager During Transactional Id Expiration Are Unusable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7519&quot;&gt;&lt;del&gt;KAFKA-7519&lt;/del&gt;&lt;/a&gt; Clear pending transaction state when expiration fails&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5820&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5820&lt;/a&gt;&lt;/p&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;
			&lt;ol&gt;
				&lt;li&gt;Description:&lt;br/&gt;
   &lt;b&gt;Make sure that the transaction state is properly cleared when the `transactionalId-expiration` task fails. Operations on that transactional id would otherwise return a`CONCURRENT_TRANSACTIONS` error and appear &quot;untouchable&quot; to transaction state changes, preventing transactional producers from operating until a broker restart or transaction coordinator change.&lt;/b&gt;&lt;/li&gt;
			&lt;/ol&gt;
			&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;
			&lt;ol&gt;
				&lt;li&gt;Testing:&lt;br/&gt;
   &lt;b&gt;Unit tested by verifying that having the `transactionalId-expration` task won&apos;t leave the transaction metadata in a pending state if the replica manager returns an error.&lt;/b&gt;&lt;/li&gt;
			&lt;/ol&gt;
			&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16657899" author="ijuma" created="Sat, 20 Oct 2018 16:28:55 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=lindong&quot; class=&quot;user-hover&quot; rel=&quot;lindong&quot;&gt;lindong&lt;/a&gt;, I marked this as a blocker since the fix seems simple and the impact is severe.&lt;/p&gt;</comment>
                            <comment id="16657983" author="lindong" created="Sat, 20 Oct 2018 20:31:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ijuma&quot; class=&quot;user-hover&quot; rel=&quot;ijuma&quot;&gt;ijuma&lt;/a&gt;&#160;Thanks for updating the state. I would like to help review it. But it seems more related to the stream processing and transaction semantics. So it may be safer if someone with more expertise in these two areas can take a look &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16659332" author="githubbot" created="Mon, 22 Oct 2018 18:36:20 +0000"  >&lt;p&gt;ijuma closed pull request #5820: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7519&quot; title=&quot;Transactional Ids Left in Pending State by TransactionStateManager During Transactional Id Expiration Are Unusable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7519&quot;&gt;&lt;del&gt;KAFKA-7519&lt;/del&gt;&lt;/a&gt; Clear pending transaction state when expiration fails&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5820&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5820&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/core/src/main/scala/kafka/coordinator/transaction/TransactionStateManager.scala b/core/src/main/scala/kafka/coordinator/transaction/TransactionStateManager.scala&lt;br/&gt;
index 574c64e2c65..589407c2a2c 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/coordinator/transaction/TransactionStateManager.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/coordinator/transaction/TransactionStateManager.scala&lt;br/&gt;
@@ -166,37 +166,32 @@ class TransactionStateManager(brokerId: Int,&lt;br/&gt;
             (topicPartition, records)&lt;br/&gt;
           }&lt;/p&gt;

&lt;p&gt;-&lt;br/&gt;
         def removeFromCacheCallback(responses: collection.Map&lt;span class=&quot;error&quot;&gt;&amp;#91;TopicPartition, PartitionResponse&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
           responses.foreach { case (topicPartition, response) =&amp;gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;response.error match {&lt;/li&gt;
	&lt;li&gt;case Errors.NONE =&amp;gt;&lt;/li&gt;
	&lt;li&gt;inReadLock(stateLock) {&lt;/li&gt;
	&lt;li&gt;val toRemove = transactionalIdByPartition(topicPartition.partition())&lt;/li&gt;
	&lt;li&gt;transactionMetadataCache.get(topicPartition.partition)&lt;/li&gt;
	&lt;li&gt;.foreach { txnMetadataCacheEntry =&amp;gt;&lt;/li&gt;
	&lt;li&gt;toRemove.foreach { idCoordinatorEpochAndMetadata =&amp;gt;&lt;/li&gt;
	&lt;li&gt;val txnMetadata = txnMetadataCacheEntry.metadataPerTransactionalId.get(idCoordinatorEpochAndMetadata.transactionalId)&lt;/li&gt;
	&lt;li&gt;txnMetadata.inLock {&lt;/li&gt;
	&lt;li&gt;if (txnMetadataCacheEntry.coordinatorEpoch == idCoordinatorEpochAndMetadata.coordinatorEpoch&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; txnMetadata.pendingState.contains(Dead)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; txnMetadata.producerEpoch == idCoordinatorEpochAndMetadata.transitMetadata.producerEpoch&lt;/li&gt;
	&lt;li&gt;)&lt;/li&gt;
	&lt;li&gt;txnMetadataCacheEntry.metadataPerTransactionalId.remove(idCoordinatorEpochAndMetadata.transactionalId)&lt;/li&gt;
	&lt;li&gt;else {&lt;/li&gt;
	&lt;li&gt;debug(s&quot;failed to remove expired transactionalId: ${idCoordinatorEpochAndMetadata.transactionalId}&quot; +&lt;/li&gt;
	&lt;li&gt;s&quot; from cache. pendingState: ${txnMetadata.pendingState} producerEpoch: ${txnMetadata.producerEpoch}&quot; +&lt;/li&gt;
	&lt;li&gt;s&quot; expected producerEpoch: ${idCoordinatorEpochAndMetadata.transitMetadata.producerEpoch}&quot; +&lt;/li&gt;
	&lt;li&gt;s&quot; coordinatorEpoch: ${txnMetadataCacheEntry.coordinatorEpoch} expected coordinatorEpoch: &quot; +&lt;/li&gt;
	&lt;li&gt;s&quot;${idCoordinatorEpochAndMetadata.coordinatorEpoch}&quot;)&lt;/li&gt;
	&lt;li&gt;txnMetadata.pendingState = None&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+            inReadLock(stateLock) {&lt;br/&gt;
+              val toRemove = transactionalIdByPartition(topicPartition.partition)&lt;br/&gt;
+              transactionMetadataCache.get(topicPartition.partition).foreach { txnMetadataCacheEntry =&amp;gt;&lt;br/&gt;
+                toRemove.foreach { idCoordinatorEpochAndMetadata =&amp;gt;&lt;br/&gt;
+                  val transactionalId = idCoordinatorEpochAndMetadata.transactionalId&lt;br/&gt;
+                  val txnMetadata = txnMetadataCacheEntry.metadataPerTransactionalId.get(transactionalId)&lt;br/&gt;
+                  txnMetadata.inLock {&lt;br/&gt;
+                    if (txnMetadataCacheEntry.coordinatorEpoch == idCoordinatorEpochAndMetadata.coordinatorEpoch&lt;br/&gt;
+                      &amp;amp;&amp;amp; txnMetadata.pendingState.contains(Dead)&lt;br/&gt;
+                      &amp;amp;&amp;amp; txnMetadata.producerEpoch == idCoordinatorEpochAndMetadata.transitMetadata.producerEpoch&lt;br/&gt;
+                      &amp;amp;&amp;amp; response.error == Errors.NONE) 
{
+                      txnMetadataCacheEntry.metadataPerTransactionalId.remove(transactionalId)
+                    }
&lt;p&gt; else {&lt;br/&gt;
+                      warn(s&quot;Failed to remove expired transactionalId: $transactionalId&quot; +&lt;br/&gt;
+                        s&quot; from cache. Tombstone append error code: ${response.error},&quot; +&lt;br/&gt;
+                        s&quot; pendingState: ${txnMetadata.pendingState}, producerEpoch: ${txnMetadata.producerEpoch},&quot; +&lt;br/&gt;
+                        s&quot; expected producerEpoch: ${idCoordinatorEpochAndMetadata.transitMetadata.producerEpoch},&quot; +&lt;br/&gt;
+                        s&quot; coordinatorEpoch: ${txnMetadataCacheEntry.coordinatorEpoch}, expected coordinatorEpoch: &quot; +&lt;br/&gt;
+                        s&quot;${idCoordinatorEpochAndMetadata.coordinatorEpoch}&quot;)&lt;br/&gt;
+                      txnMetadata.pendingState = None&lt;br/&gt;
                     }&lt;br/&gt;
+                  }&lt;br/&gt;
                 }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;case _ =&amp;gt;&lt;/li&gt;
	&lt;li&gt;debug(s&quot;writing transactionalId tombstones for partition: ${topicPartition.partition} failed with error: ${response.error.message()}&quot;)&lt;br/&gt;
+              }&lt;br/&gt;
             }&lt;br/&gt;
           }&lt;br/&gt;
         }&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/coordinator/transaction/TransactionStateManagerTest.scala b/core/src/test/scala/unit/kafka/coordinator/transaction/TransactionStateManagerTest.scala&lt;br/&gt;
index b395d00a98e..d2fe7eacb23 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/test/scala/unit/kafka/coordinator/transaction/TransactionStateManagerTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/coordinator/transaction/TransactionStateManagerTest.scala&lt;br/&gt;
@@ -419,56 +419,57 @@ class TransactionStateManagerTest {&lt;br/&gt;
   def shouldRemoveCompleteCommmitExpiredTransactionalIds(): Unit = 
{
     setupAndRunTransactionalIdExpiration(Errors.NONE, CompleteCommit)
     verifyMetadataDoesntExist(transactionalId1)
-    verifyMetadataDoesExist(transactionalId2)
+    verifyMetadataDoesExistAndIsUsable(transactionalId2)
   }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   @Test&lt;br/&gt;
   def shouldRemoveCompleteAbortExpiredTransactionalIds(): Unit = &lt;/p&gt;
{
     setupAndRunTransactionalIdExpiration(Errors.NONE, CompleteAbort)
     verifyMetadataDoesntExist(transactionalId1)
-    verifyMetadataDoesExist(transactionalId2)
+    verifyMetadataDoesExistAndIsUsable(transactionalId2)
   }

&lt;p&gt;   @Test&lt;br/&gt;
   def shouldRemoveEmptyExpiredTransactionalIds(): Unit = &lt;/p&gt;
{
     setupAndRunTransactionalIdExpiration(Errors.NONE, Empty)
     verifyMetadataDoesntExist(transactionalId1)
-    verifyMetadataDoesExist(transactionalId2)
+    verifyMetadataDoesExistAndIsUsable(transactionalId2)
   }

&lt;p&gt;   @Test&lt;br/&gt;
   def shouldNotRemoveExpiredTransactionalIdsIfLogAppendFails(): Unit = &lt;/p&gt;
{
     setupAndRunTransactionalIdExpiration(Errors.NOT_ENOUGH_REPLICAS, CompleteAbort)
-    verifyMetadataDoesExist(transactionalId1)
-    verifyMetadataDoesExist(transactionalId2)
+    verifyMetadataDoesExistAndIsUsable(transactionalId1)
+    verifyMetadataDoesExistAndIsUsable(transactionalId2)
   }

&lt;p&gt;   @Test&lt;br/&gt;
   def shouldNotRemoveOngoingTransactionalIds(): Unit = &lt;/p&gt;
{
     setupAndRunTransactionalIdExpiration(Errors.NONE, Ongoing)
-    verifyMetadataDoesExist(transactionalId1)
-    verifyMetadataDoesExist(transactionalId2)
+    verifyMetadataDoesExistAndIsUsable(transactionalId1)
+    verifyMetadataDoesExistAndIsUsable(transactionalId2)
   }

&lt;p&gt;   @Test&lt;br/&gt;
   def shouldNotRemovePrepareAbortTransactionalIds(): Unit = &lt;/p&gt;
{
     setupAndRunTransactionalIdExpiration(Errors.NONE, PrepareAbort)
-    verifyMetadataDoesExist(transactionalId1)
-    verifyMetadataDoesExist(transactionalId2)
+    verifyMetadataDoesExistAndIsUsable(transactionalId1)
+    verifyMetadataDoesExistAndIsUsable(transactionalId2)
   }

&lt;p&gt;   @Test&lt;br/&gt;
   def shouldNotRemovePrepareCommitTransactionalIds(): Unit = &lt;/p&gt;
{
     setupAndRunTransactionalIdExpiration(Errors.NONE, PrepareCommit)
-    verifyMetadataDoesExist(transactionalId1)
-    verifyMetadataDoesExist(transactionalId2)
+    verifyMetadataDoesExistAndIsUsable(transactionalId1)
+    verifyMetadataDoesExistAndIsUsable(transactionalId2)
   }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private def verifyMetadataDoesExist(transactionalId: String) = {&lt;br/&gt;
+  private def verifyMetadataDoesExistAndIsUsable(transactionalId: String) = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {     transactionManager.getTransactionState(transactionalId) match {
       case Left(errors) =&amp;gt; fail(&quot;shouldn&apos;t have been any errors&quot;)
       case Right(None) =&amp;gt; fail(&quot;metadata should have been removed&quot;)
-      case Right(Some(metadata)) =&amp;gt; // ok
+      case Right(Some(metadata)) =&amp;gt;
+        assertTrue(&quot;metadata shouldn&apos;t be in a pending state&quot;, metadata.transactionMetadata.pendingState.isEmpty)
     }   }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;






&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="17012625" author="tunix" created="Fri, 10 Jan 2020 09:37:30 +0000"  >&lt;p&gt;I just had the exact error in Kafka 2.2.0 &#8211; any ideas? is this PR really merged into 2.0.1, 2.1.0 releases?&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://issues.apache.org/jira/secure/attachment/12990501/12990501_image-2020-01-10-12-37-28-804.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12944631" name="KAFKA-7519.patch" size="6002" author="howellbridger" created="Thu, 18 Oct 2018 22:09:19 +0000"/>
                            <attachment id="12944608" name="image-2018-10-18-13-02-22-371.png" size="211881" author="howellbridger" created="Thu, 18 Oct 2018 19:02:24 +0000"/>
                            <attachment id="12990501" name="image-2020-01-10-12-37-28-804.png" size="108119" author="tunix" created="Fri, 10 Jan 2020 09:37:29 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 44 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3zdsn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>