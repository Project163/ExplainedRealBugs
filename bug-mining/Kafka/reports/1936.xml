<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:11:36 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6967] TopologyTestDriver does not allow pre-populating state stores that have change logging</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6967</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;TopologyTestDriver does not allow pre-populating a state store that has logging enabled. If you try to do it, you will get the following error message:&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java.lang.IllegalStateException: This should not happen as timestamp() should only be called &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; a record is processed
	at org.apache.kafka.streams.processor.internals.AbstractProcessorContext.timestamp(AbstractProcessorContext.java:153)
	at org.apache.kafka.streams.state.internals.StoreChangeLogger.logChange(StoreChangeLogger.java:59)
	at org.apache.kafka.streams.state.internals.ChangeLoggingKeyValueBytesStore.put(ChangeLoggingKeyValueBytesStore.java:69)
	at org.apache.kafka.streams.state.internals.ChangeLoggingKeyValueBytesStore.put(ChangeLoggingKeyValueBytesStore.java:29)
	at org.apache.kafka.streams.state.internals.InnerMeteredKeyValueStore.put(InnerMeteredKeyValueStore.java:198)
	at org.apache.kafka.streams.state.internals.MeteredKeyValueBytesStore.put(MeteredKeyValueBytesStore.java:117)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also see:&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java#L723-L740&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java#L723-L740&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13162718">KAFKA-6967</key>
            <summary>TopologyTestDriver does not allow pre-populating state stores that have change logging</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mjsax">Matthias J. Sax</assignee>
                                    <reporter username="wushujames">James Cheng</reporter>
                        <labels>
                    </labels>
                <created>Tue, 29 May 2018 20:23:19 +0000</created>
                <updated>Wed, 6 Jun 2018 22:18:22 +0000</updated>
                            <resolved>Wed, 6 Jun 2018 22:18:22 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>2.0.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16494299" author="wushujames" created="Tue, 29 May 2018 21:27:51 +0000"  >&lt;p&gt;If the very first call to the state store is a `store.put()`, it has no timestamp (or context), so the `put()` fails with the above stack trace.&lt;/p&gt;

&lt;p&gt;If you instead run some data through topology first, and then afterwards manipulate the state store via `store.put()`, it has a context, and so the call works fine.&lt;/p&gt;</comment>
                            <comment id="16494644" author="githubbot" created="Wed, 30 May 2018 03:52:49 +0000"  >&lt;p&gt;mjsax opened a new pull request #5096: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6967&quot; title=&quot;TopologyTestDriver does not allow pre-populating state stores that have change logging&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6967&quot;&gt;&lt;del&gt;KAFKA-6967&lt;/del&gt;&lt;/a&gt;: TopologyTestDriver does not allow pre-populating state stores that have change logging&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5096&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5096&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   *More detailed description of your change,&lt;br/&gt;
   if necessary. The PR title and PR message become&lt;br/&gt;
   the squashed commit message, so use a separate&lt;br/&gt;
   comment to ping reviewers.*&lt;/p&gt;

&lt;p&gt;   *Summary of testing strategy (including rationale)&lt;br/&gt;
   for the feature or bug fix. Unit and/or integration&lt;br/&gt;
   tests are expected for any behaviour change and&lt;br/&gt;
   system tests should be considered for larger changes.*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16503984" author="githubbot" created="Wed, 6 Jun 2018 22:16:24 +0000"  >&lt;p&gt;mjsax closed pull request #5096: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6967&quot; title=&quot;TopologyTestDriver does not allow pre-populating state stores that have change logging&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6967&quot;&gt;&lt;del&gt;KAFKA-6967&lt;/del&gt;&lt;/a&gt;: TopologyTestDriver does not allow pre-populating state stores that have change logging&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5096&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5096&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/build.gradle b/build.gradle&lt;br/&gt;
index ab16b428a21..fc4bf4fb29e 100644&lt;br/&gt;
&amp;#8212; a/build.gradle&lt;br/&gt;
+++ b/build.gradle&lt;br/&gt;
@@ -1017,6 +1017,7 @@ project(&apos;:streams:test-utils&apos;) &lt;/p&gt;
{
 
     testCompile project(&apos;:clients&apos;).sourceSets.test.output
     testCompile libs.junit
+    testCompile libs.easymock
 
     testRuntime libs.slf4jlog4j
   }
&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedTableImplTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedTableImplTest.java&lt;br/&gt;
index 4b8298fb2fa..79e0b42226d 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedTableImplTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedTableImplTest.java&lt;br/&gt;
@@ -199,7 +199,7 @@ public void shouldReduceAndMaterializeResults() {&lt;br/&gt;
         final Map&amp;lt;String, Integer&amp;gt; results = getReducedResults(reduced);&lt;br/&gt;
         try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) &lt;/p&gt;
{
             assertReduced(results, topic, driver);
-            final KeyValueStore&amp;lt;String, Integer&amp;gt; reduce = (KeyValueStore&amp;lt;String, Integer&amp;gt;) driver.getStateStore(&quot;reduce&quot;);
+            final KeyValueStore&amp;lt;String, Integer&amp;gt; reduce = driver.getKeyValueStore(&quot;reduce&quot;);
             assertThat(reduce.get(&quot;A&quot;), equalTo(5));
             assertThat(reduce.get(&quot;B&quot;), equalTo(6));
         }
&lt;p&gt;@@ -240,7 +240,7 @@ public void shouldAggregateAndMaterializeResults() {&lt;/p&gt;

&lt;p&gt;         try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) &lt;/p&gt;
{
             processData(topic, driver);
-            final KeyValueStore&amp;lt;String, String&amp;gt; aggregate = (KeyValueStore&amp;lt;String, String&amp;gt;) driver.getStateStore(&quot;aggregate&quot;);
+            final KeyValueStore&amp;lt;String, String&amp;gt; aggregate = driver.getKeyValueStore(&quot;aggregate&quot;);
             assertThat(aggregate.get(&quot;1&quot;), equalTo(&quot;0+1+1+1&quot;));
             assertThat(aggregate.get(&quot;2&quot;), equalTo(&quot;0+2+2&quot;));
         }
&lt;p&gt;diff --git a/streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java b/streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java&lt;br/&gt;
index e46ec6a35d0..773cbb4c323 100644&lt;br/&gt;
&amp;#8212; a/streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java&lt;br/&gt;
+++ b/streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java&lt;br/&gt;
@@ -28,6 +28,7 @@&lt;br/&gt;
 import org.apache.kafka.common.PartitionInfo;&lt;br/&gt;
 import org.apache.kafka.common.TopicPartition;&lt;br/&gt;
 import org.apache.kafka.common.annotation.InterfaceStability;&lt;br/&gt;
+import org.apache.kafka.common.header.internals.RecordHeaders;&lt;br/&gt;
 import org.apache.kafka.common.metrics.Metrics;&lt;br/&gt;
 import org.apache.kafka.common.record.TimestampType;&lt;br/&gt;
 import org.apache.kafka.common.serialization.ByteArraySerializer;&lt;br/&gt;
@@ -170,7 +171,7 @@&lt;br/&gt;
 @InterfaceStability.Evolving&lt;br/&gt;
 public class TopologyTestDriver implements Closeable {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final Time mockTime;&lt;br/&gt;
+    private final Time mockWallClockTime;&lt;br/&gt;
     private final InternalTopologyBuilder internalTopologyBuilder;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private final static int PARTITION_ID = 0;&lt;br/&gt;
@@ -179,6 +180,8 @@&lt;br/&gt;
     private final GlobalStateUpdateTask globalStateTask;&lt;br/&gt;
     private final GlobalStateManager globalStateManager;&lt;/p&gt;

&lt;p&gt;+    private final InternalProcessorContext context;&lt;br/&gt;
+&lt;br/&gt;
     private final StateDirectory stateDirectory;&lt;br/&gt;
     private final Metrics metrics;&lt;br/&gt;
     private final ProcessorTopology processorTopology;&lt;br/&gt;
@@ -216,22 +219,9 @@ public TopologyTestDriver(final Topology topology,&lt;br/&gt;
     public TopologyTestDriver(final Topology topology,&lt;br/&gt;
                               final Properties config,&lt;br/&gt;
                               final long initialWallClockTimeMs) &lt;/p&gt;
{
-
         this(topology.internalTopologyBuilder, config, initialWallClockTimeMs);
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Create a new test diver instance.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param builder builder for the topology to be tested&lt;/li&gt;
	&lt;li&gt;* @param config the configuration for the topology&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;TopologyTestDriver(final InternalTopologyBuilder builder,&lt;/li&gt;
	&lt;li&gt;final Properties config) 
{
-        this(builder, config,  System.currentTimeMillis());
-
-    }
&lt;p&gt;-&lt;br/&gt;
     /**&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Create a new test diver instance.&lt;br/&gt;
      *&lt;br/&gt;
@@ -240,10 +230,10 @@ public TopologyTestDriver(final Topology topology,&lt;/li&gt;
	&lt;li&gt;@param initialWallClockTimeMs the initial value of internally mocked wall-clock time&lt;br/&gt;
      */&lt;br/&gt;
     private TopologyTestDriver(final InternalTopologyBuilder builder,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Properties config,&lt;/li&gt;
	&lt;li&gt;final long initialWallClockTimeMs) {&lt;br/&gt;
+                               final Properties config,&lt;br/&gt;
+                               final long initialWallClockTimeMs) 
{
         final StreamsConfig streamsConfig = new StreamsConfig(config);
-        mockTime = new MockTime(initialWallClockTimeMs);
+        mockWallClockTime = new MockTime(initialWallClockTimeMs);
 
         internalTopologyBuilder = builder;
         internalTopologyBuilder.setApplicationId(streamsConfig.getString(StreamsConfig.APPLICATION_ID_CONFIG));
@@ -260,7 +250,7 @@ private TopologyTestDriver(final InternalTopologyBuilder builder,
         }
&lt;p&gt;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final MockConsumer&amp;lt;byte[], byte[]&amp;gt; consumer = new MockConsumer&amp;lt;&amp;gt;(OffsetResetStrategy.EARLIEST);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateDirectory = new StateDirectory(streamsConfig, mockTime);&lt;br/&gt;
+        stateDirectory = new StateDirectory(streamsConfig, mockWallClockTime);&lt;br/&gt;
         metrics = new Metrics();&lt;br/&gt;
         final StreamsMetricsImpl streamsMetrics = new StreamsMetricsImpl(&lt;br/&gt;
             metrics,&lt;br/&gt;
@@ -323,6 +313,7 @@ public void onRestoreEnd(final TopicPartition topicPartition, final String store&lt;br/&gt;
                 new LogContext()&lt;br/&gt;
             );&lt;br/&gt;
             globalStateTask.initialize();&lt;br/&gt;
+            globalProcessorContext.setRecordContext(new ProcessorRecordContext(0L, -1L, -1, null, new RecordHeaders()));&lt;br/&gt;
         } else 
{
             globalStateManager = null;
             globalStateTask = null;
@@ -342,12 +333,15 @@ public void onRestoreEnd(final TopicPartition topicPartition, final String store
                 streamsMetrics,
                 stateDirectory,
                 cache,
-                mockTime,
+                mockWallClockTime,
                 producer);
             task.initializeStateStores();
             task.initializeTopology();
+            context = (InternalProcessorContext) task.context();
+            context.setRecordContext(new ProcessorRecordContext(0L, -1L, -1, null, new RecordHeaders()));
         }
&lt;p&gt; else &lt;/p&gt;
{
             task = null;
+            context = null;
         }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -356,6 +350,7 @@ public void onRestoreEnd(final TopicPartition topicPartition, final String store&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return Map of all metrics.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(&quot;WeakerAccess&quot;)&lt;br/&gt;
     public Map&amp;lt;MetricName, ? extends Metric&amp;gt; metrics() 
{
         return Collections.unmodifiableMap(metrics.metrics());
     }
&lt;p&gt;@@ -390,13 +385,10 @@ public void pipeInput(final ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; consumerRecord) &lt;/p&gt;
{
                 consumerRecord.headers())));
 
             // Process the record ...
-            ((InternalProcessorContext) task.context()).setRecordContext(
-                    new ProcessorRecordContext(consumerRecord.timestamp(), offset, topicPartition.partition(), topicName, consumerRecord.headers()));
             task.process();
             task.maybePunctuateStreamTime();
             task.commit();
             captureOutputRecords();
-
         }
&lt;p&gt; else {&lt;br/&gt;
             final TopicPartition globalTopicPartition = globalPartitionsByTopic.get(topicName);&lt;br/&gt;
             if (globalTopicPartition == null) {&lt;br/&gt;
@@ -446,12 +438,7 @@ private void captureOutputRecords() {&lt;br/&gt;
         final List&amp;lt;ProducerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; output = producer.history();&lt;br/&gt;
         producer.clear();&lt;br/&gt;
         for (final ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record : output) {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Queue&amp;lt;ProducerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; outputRecords = outputRecordsByTopic.get(record.topic());&lt;/li&gt;
	&lt;li&gt;if (outputRecords == null) 
{
-                outputRecords = new LinkedList&amp;lt;&amp;gt;();
-                outputRecordsByTopic.put(record.topic(), outputRecords);
-            }&lt;/li&gt;
	&lt;li&gt;outputRecords.add(record);&lt;br/&gt;
+            outputRecordsByTopic.computeIfAbsent(record.topic(), k -&amp;gt; new LinkedList&amp;lt;&amp;gt;()).add(record);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             // Forward back into the topology if the produced record is to an internal or a source topic ...&lt;br/&gt;
             final String outputTopicName = record.topic();&lt;br/&gt;
@@ -497,7 +484,7 @@ public void pipeInput(final List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; records) {&lt;br/&gt;
      */&lt;br/&gt;
     @SuppressWarnings(&quot;WeakerAccess&quot;)&lt;br/&gt;
     public void advanceWallClockTime(final long advanceMs) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;mockTime.sleep(advanceMs);&lt;br/&gt;
+        mockWallClockTime.sleep(advanceMs);&lt;br/&gt;
         if (task != null) {&lt;br/&gt;
             task.maybePunctuateSystemTime();&lt;br/&gt;
             task.commit();&lt;br/&gt;
@@ -549,6 +536,8 @@ public void advanceWallClockTime(final long advanceMs) {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;This is often useful in test cases to pre-populate the store before the test case instructs the topology to&lt;/li&gt;
	&lt;li&gt;{@link #pipeInput(ConsumerRecord) process an input message}
&lt;p&gt;, and/or to check the store afterward.&lt;br/&gt;
+     * &amp;lt;p&amp;gt;&lt;br/&gt;
+     * Note, that &lt;/p&gt;
{@code StateStore}
&lt;p&gt; might be &lt;/p&gt;
{@code null} if a store is added but not connected to any processor.&lt;br/&gt;
      *&lt;br/&gt;
      * @return all stores my name&lt;br/&gt;
      * @see #getStateStore(String)&lt;br/&gt;
@@ -579,13 +568,24 @@ public void advanceWallClockTime(final long advanceMs) {&lt;br/&gt;
      * @see #getWindowStore(String)&lt;br/&gt;
      * @see #getSessionStore(String)&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(&quot;WeakerAccess&quot;)&lt;br/&gt;
     public StateStore getStateStore(final String name) {&lt;br/&gt;
-        StateStore stateStore = task == null ? null :&lt;br/&gt;
-            ((ProcessorContextImpl) task.context()).getStateMgr().getStore(name);&lt;br/&gt;
-        if (stateStore == null &amp;amp;&amp;amp; globalStateManager != null) {&lt;br/&gt;
-            stateStore = globalStateManager.getGlobalStore(name);&lt;br/&gt;
+        if (task != null) {&lt;br/&gt;
+            final StateStore stateStore = ((ProcessorContextImpl) task.context()).getStateMgr().getStore(name);&lt;br/&gt;
+            if (stateStore != null) {
+                return stateStore;
+            }&lt;br/&gt;
         }&lt;br/&gt;
-        return stateStore;&lt;br/&gt;
+&lt;br/&gt;
+        if (globalStateManager != null) {&lt;br/&gt;
+            final StateStore stateStore = globalStateManager.getGlobalStore(name);&lt;br/&gt;
+            if (stateStore != null) {+                return stateStore;+            }&lt;br/&gt;
+&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        return null;&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
@@ -651,6 +651,7 @@ public StateStore getStateStore(final String name) {&lt;br/&gt;
     /**&lt;br/&gt;
      * Close the driver, its topology, and all processors.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(&quot;WeakerAccess&quot;)&lt;br/&gt;
     public void close() {&lt;br/&gt;
         if (task != null) {
             task.close(true, false);
diff --git a/streams/test-utils/src/main/java/org/apache/kafka/streams/processor/MockProcessorContext.java b/streams/test-utils/src/main/java/org/apache/kafka/streams/processor/MockProcessorContext.java
index b14a7915dc9..cba02573b59 100644
--- a/streams/test-utils/src/main/java/org/apache/kafka/streams/processor/MockProcessorContext.java
+++ b/streams/test-utils/src/main/java/org/apache/kafka/streams/processor/MockProcessorContext.java
@@ -86,23 +86,27 @@ private CapturedPunctuator(final long intervalMs, final PunctuationType type, fi
             this.punctuator = punctuator;
         }&lt;br/&gt;
 &lt;br/&gt;
+        @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
         public long getIntervalMs() {
             return intervalMs;
         }&lt;br/&gt;
 &lt;br/&gt;
+        @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
         public PunctuationType getType() {
             return type;
         }&lt;br/&gt;
 &lt;br/&gt;
+        @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
         public Punctuator getPunctuator() {
             return punctuator;
         }&lt;br/&gt;
 &lt;br/&gt;
-        @SuppressWarnings(&quot;WeakerAccess&quot;)&lt;br/&gt;
+        @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
         public void cancel() {
             cancelled = true;
         }&lt;br/&gt;
 &lt;br/&gt;
+        @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
         public boolean cancelled() {
             return cancelled;
         }&lt;br/&gt;
@@ -127,6 +131,7 @@ private CapturedForward(final To to, final KeyValue keyValue) {&lt;br/&gt;
          *&lt;br/&gt;
          * @return The child name, or {@code null}
&lt;p&gt; if it was broadcast.&lt;br/&gt;
          */&lt;br/&gt;
+        @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
         public String childName() {
             return childName;
         }&lt;br/&gt;
@@ -136,6 +141,7 @@ public String childName() {&lt;br/&gt;
          *&lt;br/&gt;
          * @return A timestamp, or {@code -1} if none was forwarded.&lt;br/&gt;
          */&lt;br/&gt;
+        @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
         public long timestamp() &lt;/p&gt;
{
             return timestamp;
         }
&lt;p&gt;@@ -145,6 +151,7 @@ public long timestamp() {&lt;br/&gt;
          *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return A key/value pair. Not null.&lt;br/&gt;
          */&lt;br/&gt;
+        @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
         public KeyValue keyValue() {
             return keyValue;
         }&lt;br/&gt;
@@ -158,6 +165,7 @@ public KeyValue keyValue() {&lt;br/&gt;
      * and most unit tests should be able to get by with the&lt;br/&gt;
      * {@link InMemoryKeyValueStore}, so the stateDir won&apos;t matter.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public MockProcessorContext() {&lt;br/&gt;
         //noinspection DoubleBraceInitialization&lt;br/&gt;
         this(&lt;br/&gt;
@@ -179,6 +187,7 @@ public MockProcessorContext() {&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param config a Properties object, used to configure the context and the processor.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public MockProcessorContext(final Properties config) {
         this(config, new TaskId(0, 0), null);
     }&lt;br/&gt;
@@ -190,6 +199,7 @@ public MockProcessorContext(final Properties config) {&lt;br/&gt;
      * @param taskId   a {@link TaskId}, which the context makes available via {@link MockProcessorContext#taskId()}.&lt;br/&gt;
      * @param stateDir a {@link File}, which the context makes available viw {@link MockProcessorContext#stateDir()}.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public MockProcessorContext(final Properties config, final TaskId taskId, final File stateDir) {&lt;br/&gt;
         final StreamsConfig streamsConfig = new StreamsConfig(config);&lt;br/&gt;
         this.taskId = taskId;&lt;br/&gt;
@@ -252,6 +262,7 @@ public StreamsMetrics metrics() {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param offset    A record offset&lt;/li&gt;
	&lt;li&gt;@param timestamp A record timestamp&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public void setRecordMetadata(final String topic, final int partition, final long offset, final Headers headers, final long timestamp) {
         this.topic = topic;
         this.partition = partition;
@@ -260,13 +271,13 @@ public void setRecordMetadata(final String topic, final int partition, final lon
         this.timestamp = timestamp;
     }&lt;br/&gt;
 &lt;br/&gt;
-&lt;br/&gt;
     /**&lt;br/&gt;
      * The context exposes this metadata for use in the processor. Normally, they are set by the Kafka Streams framework,&lt;br/&gt;
      * but for the purpose of driving unit tests, you can set it directly. Setting this attribute doesn&apos;t affect the others.&lt;br/&gt;
      *&lt;br/&gt;
      * @param topic A topic name&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public void setTopic(final String topic) &lt;/p&gt;
{
         this.topic = topic;
     }
&lt;p&gt;@@ -277,21 +288,29 @@ public void setTopic(final String topic) {&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param partition A partition number&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public void setPartition(final int partition) {
         this.partition = partition;
     }&lt;br/&gt;
 &lt;br/&gt;
-&lt;br/&gt;
     /**&lt;br/&gt;
      * The context exposes this metadata for use in the processor. Normally, they are set by the Kafka Streams framework,&lt;br/&gt;
      * but for the purpose of driving unit tests, you can set it directly. Setting this attribute doesn&apos;t affect the others.&lt;br/&gt;
      *&lt;br/&gt;
      * @param offset A record offset&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public void setOffset(final long offset) &lt;/p&gt;
{
         this.offset = offset;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    /**&lt;br/&gt;
+     * The context exposes this metadata for use in the processor. Normally, they are set by the Kafka Streams framework,&lt;br/&gt;
+     * but for the purpose of driving unit tests, you can set it directly. Setting this attribute doesn&apos;t affect the others.&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param headers Record headers&lt;br/&gt;
+     */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public void setHeaders(final Headers headers) {
         this.headers = headers;
     }&lt;br/&gt;
@@ -302,6 +321,7 @@ public void setHeaders(final Headers headers) {&lt;br/&gt;
      *&lt;br/&gt;
      * @param timestamp A record timestamp&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public void setTimestamp(final long timestamp) &lt;/p&gt;
{
         this.timestamp = timestamp;
     }
&lt;p&gt;@@ -345,7 +365,6 @@ public long timestamp() {&lt;/p&gt;

&lt;p&gt;     // mocks ================================================&lt;/p&gt;

&lt;p&gt;-&lt;br/&gt;
     @Override&lt;br/&gt;
     public void register(final StateStore store,&lt;br/&gt;
                          final StateRestoreCallback stateRestoreCallbackIsIgnoredInMock) {&lt;br/&gt;
@@ -376,6 +395,7 @@ public void cancel() {&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return A list of captured punctuators.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public List&amp;lt;CapturedPunctuator&amp;gt; scheduledPunctuators() {&lt;br/&gt;
         final LinkedList&amp;lt;CapturedPunctuator&amp;gt; capturedPunctuators = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;
         capturedPunctuators.addAll(punctuators);&lt;br/&gt;
@@ -394,6 +414,7 @@ public void cancel() {
         capturedForwards.add(new CapturedForward(to, new KeyValue(key, value)));
     }&lt;br/&gt;
 &lt;br/&gt;
+    @SuppressWarnings(&quot;deprecation&quot;)&lt;br/&gt;
     @Override&lt;br/&gt;
     public &amp;lt;K, V&amp;gt; void forward(final K key, final V value, final int childIndex) {&lt;br/&gt;
         throw new UnsupportedOperationException(&lt;br/&gt;
@@ -402,6 +423,7 @@ public void cancel() {
         );
     }&lt;br/&gt;
 &lt;br/&gt;
+    @SuppressWarnings(&quot;deprecation&quot;)&lt;br/&gt;
     @Override&lt;br/&gt;
     public &amp;lt;K, V&amp;gt; void forward(final K key, final V value, final String childName) {&lt;br/&gt;
         throw new UnsupportedOperationException(&lt;br/&gt;
@@ -417,6 +439,7 @@ public void cancel() {&lt;br/&gt;
      *&lt;br/&gt;
      * @return A list of key/value pairs that were previously passed to the context.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public List&amp;lt;CapturedForward&amp;gt; forwarded() {&lt;br/&gt;
         final LinkedList&amp;lt;CapturedForward&amp;gt; result = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;
         result.addAll(capturedForwards);&lt;br/&gt;
@@ -431,6 +454,7 @@ public void cancel() {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param childName The child name to retrieve forwards for&lt;/li&gt;
	&lt;li&gt;@return A list of key/value pairs that were previously passed to the context.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public List&amp;lt;CapturedForward&amp;gt; forwarded(final String childName) {&lt;br/&gt;
         final LinkedList&amp;lt;CapturedForward&amp;gt; result = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;
         for (final CapturedForward capture : capturedForwards) {&lt;br/&gt;
@@ -444,6 +468,7 @@ public void cancel() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Clear the captured forwarded data.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public void resetForwards() &lt;/p&gt;
{
         capturedForwards.clear();
     }
&lt;p&gt;@@ -458,6 +483,7 @@ public void commit() {&lt;br/&gt;
      *&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@return 
{@code true} iff {@link ProcessorContext#commit()} has been called in this context since construction or reset.&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(&quot;WeakerAccess&quot;)&lt;br/&gt;
     public boolean committed() {
         return committed;
     }&lt;br/&gt;
@@ -465,6 +491,7 @@ public boolean committed() {&lt;br/&gt;
     /**&lt;br/&gt;
      * Reset the commit capture to {@code false} (whether or not it was previously {@code true}
&lt;p&gt;).&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public void resetCommit() {
         committed = false;
     }&lt;br/&gt;
diff --git a/streams/test-utils/src/main/java/org/apache/kafka/streams/test/ConsumerRecordFactory.java b/streams/test-utils/src/main/java/org/apache/kafka/streams/test/ConsumerRecordFactory.java&lt;br/&gt;
index 507249d0d2e..108dafdfdba 100644&lt;br/&gt;
&amp;#8212; a/streams/test-utils/src/main/java/org/apache/kafka/streams/test/ConsumerRecordFactory.java&lt;br/&gt;
+++ b/streams/test-utils/src/main/java/org/apache/kafka/streams/test/ConsumerRecordFactory.java&lt;br/&gt;
@@ -44,7 +44,7 @@&lt;br/&gt;
     private final Serializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
     private final Serializer&amp;lt;V&amp;gt; valueSerializer;&lt;br/&gt;
     private long timeMs;&lt;br/&gt;
-    private long advanceMs;&lt;br/&gt;
+    private final long advanceMs;&lt;br/&gt;
 &lt;br/&gt;
     /**&lt;br/&gt;
      * Create a new factory for the given topic.&lt;br/&gt;
@@ -54,6 +54,7 @@&lt;br/&gt;
      * @param keySerializer the key serializer&lt;br/&gt;
      * @param valueSerializer the value serializer&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecordFactory(final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
                                  final Serializer&amp;lt;V&amp;gt; valueSerializer) {&lt;br/&gt;
         this(null, keySerializer, valueSerializer, System.currentTimeMillis());&lt;br/&gt;
@@ -68,6 +69,7 @@ public ConsumerRecordFactory(final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param keySerializer the key serializer&lt;/li&gt;
	&lt;li&gt;@param valueSerializer the value serializer&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecordFactory(final String defaultTopicName,&lt;br/&gt;
                                  final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
                                  final Serializer&amp;lt;V&amp;gt; valueSerializer) {&lt;br/&gt;
@@ -82,6 +84,7 @@ public ConsumerRecordFactory(final String defaultTopicName,&lt;br/&gt;
      * @param valueSerializer the value serializer&lt;br/&gt;
      * @param startTimestampMs the initial timestamp for generated records&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecordFactory(final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
                                  final Serializer&amp;lt;V&amp;gt; valueSerializer,&lt;br/&gt;
                                  final long startTimestampMs) {&lt;br/&gt;
@@ -97,6 +100,7 @@ public ConsumerRecordFactory(final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param valueSerializer the value serializer&lt;/li&gt;
	&lt;li&gt;@param startTimestampMs the initial timestamp for generated records&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecordFactory(final String defaultTopicName,&lt;br/&gt;
                                  final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
                                  final Serializer&amp;lt;V&amp;gt; valueSerializer,&lt;br/&gt;
@@ -112,6 +116,7 @@ public ConsumerRecordFactory(final String defaultTopicName,&lt;br/&gt;
      * @param startTimestampMs the initial timestamp for generated records&lt;br/&gt;
      * @param autoAdvanceMs the time increment pre generated record&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecordFactory(final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
                                  final Serializer&amp;lt;V&amp;gt; valueSerializer,&lt;br/&gt;
                                  final long startTimestampMs,&lt;br/&gt;
@@ -128,6 +133,7 @@ public ConsumerRecordFactory(final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param startTimestampMs the initial timestamp for generated records&lt;/li&gt;
	&lt;li&gt;@param autoAdvanceMs the time increment pre generated record&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecordFactory(final String defaultTopicName,&lt;br/&gt;
                                  final Serializer&amp;lt;K&amp;gt; keySerializer,&lt;br/&gt;
                                  final Serializer&amp;lt;V&amp;gt; valueSerializer,&lt;br/&gt;
@@ -147,6 +153,7 @@ public ConsumerRecordFactory(final String defaultTopicName,&lt;br/&gt;
      *&lt;br/&gt;
      * @param advanceMs the amount of time to advance&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
         if (advanceMs &amp;lt; 0) {&lt;br/&gt;
             throw new IllegalArgumentException(&quot;advanceMs must be positive&quot;);&lt;br/&gt;
@@ -165,6 +172,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param timestampMs the record timestamp&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final K key,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
@@ -198,6 +206,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param timestampMs the record timestamp&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final K key,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
@@ -214,6 +223,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param timestampMs the record timestamp&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final K key,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
                                                  final long timestampMs) {&lt;br/&gt;
@@ -230,6 +240,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param timestampMs the record timestamp&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final K key,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
                                                  final Headers headers,&lt;br/&gt;
@@ -250,6 +261,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param value the record value&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final K key,&lt;br/&gt;
                                                  final V value) {&lt;br/&gt;
@@ -268,6 +280,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param headers the record headers&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final K key,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
@@ -285,6 +298,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param value the record value&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final K key,&lt;br/&gt;
                                                  final V value) {&lt;br/&gt;
         return create(key, value, new RecordHeaders());&lt;br/&gt;
@@ -299,6 +313,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param headers the record headers&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final K key,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
                                                  final Headers headers) {&lt;br/&gt;
@@ -318,6 +333,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param timestampMs the record timestamp&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
                                                  final long timestampMs) {&lt;br/&gt;
@@ -334,6 +350,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param timestampMs the record timestamp&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
                                                  final Headers headers,&lt;br/&gt;
@@ -349,6 +366,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param timestampMs the record timestamp&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final V value,&lt;br/&gt;
                                                  final long timestampMs) {&lt;br/&gt;
         return create(value, new RecordHeaders(), timestampMs);&lt;br/&gt;
@@ -363,6 +381,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param timestampMs the record timestamp&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final V value,&lt;br/&gt;
                                                  final Headers headers,&lt;br/&gt;
                                                  final long timestampMs) {&lt;br/&gt;
@@ -382,6 +401,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param headers the record headers&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final V value,&lt;br/&gt;
                                                  final Headers headers) {&lt;br/&gt;
@@ -396,6 +416,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param value the record value&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final String topicName,&lt;br/&gt;
                                                  final V value) {&lt;br/&gt;
         return create(topicName, null, value, new RecordHeaders());&lt;br/&gt;
@@ -408,6 +429,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param value the record value&lt;br/&gt;
      * @return the generated {@link ConsumerRecord}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final V value) &lt;/p&gt;
{
         return create(value, new RecordHeaders());
     }
&lt;p&gt;@@ -420,6 +442,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param headers the record headers&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; create(final V value,&lt;br/&gt;
                                                  final Headers headers) {&lt;br/&gt;
         if (topicName == null) {&lt;br/&gt;
@@ -437,6 +460,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param keyValues the record keys and values&lt;br/&gt;
      * @return the generated {@link ConsumerRecord consumer records}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; create(final String topicName,&lt;br/&gt;
                                                        final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; keyValues) {&lt;br/&gt;
         final List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; records = new ArrayList&amp;lt;&amp;gt;(keyValues.size());&lt;br/&gt;
@@ -455,6 +479,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param keyValues the record keys and values&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord consumer records}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; create(final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; keyValues) {&lt;br/&gt;
         if (topicName == null) {&lt;br/&gt;
             throw new IllegalStateException(&quot;ConsumerRecordFactory was created without defaultTopicName. &quot; +&lt;br/&gt;
@@ -474,6 +499,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param advanceMs the time difference between two consecutive generated records&lt;br/&gt;
      * @return the generated {@link ConsumerRecord consumer records}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; create(final String topicName,&lt;br/&gt;
                                                        final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; keyValues,&lt;br/&gt;
                                                        final long startTimestamp,&lt;br/&gt;
@@ -502,6 +528,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param advanceMs the time difference between two consecutive generated records&lt;br/&gt;
      * @return the generated {@link ConsumerRecord consumer records}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; create(final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; keyValues,&lt;br/&gt;
                                                        final long startTimestamp,&lt;br/&gt;
                                                        final long advanceMs) {&lt;br/&gt;
@@ -523,6 +550,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param startTimestamp the timestamp for the first generated record&lt;/li&gt;
	&lt;li&gt;@return the generated 
{@link ConsumerRecord consumer records}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; create(final String topicName,&lt;br/&gt;
                                                        final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; keyValues,&lt;br/&gt;
                                                        final long startTimestamp) {&lt;br/&gt;
@@ -538,6 +566,7 @@ public void advanceTimeMs(final long advanceMs) {&lt;br/&gt;
      * @param startTimestamp the timestamp for the first generated record&lt;br/&gt;
      * @return the generated {@link ConsumerRecord consumer records}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; create(final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; keyValues,&lt;br/&gt;
                                                        final long startTimestamp) {&lt;br/&gt;
         if (topicName == null) {&lt;br/&gt;
diff --git a/streams/test-utils/src/main/java/org/apache/kafka/streams/test/OutputVerifier.java b/streams/test-utils/src/main/java/org/apache/kafka/streams/test/OutputVerifier.java&lt;br/&gt;
index aedb910e28c..f78e926e431 100644&lt;br/&gt;
&amp;#8212; a/streams/test-utils/src/main/java/org/apache/kafka/streams/test/OutputVerifier.java&lt;br/&gt;
+++ b/streams/test-utils/src/main/java/org/apache/kafka/streams/test/OutputVerifier.java&lt;br/&gt;
@@ -39,6 +39,7 @@&lt;br/&gt;
      * @param &amp;lt;V&amp;gt; the value type&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s value is not equal to {@code expectedValue}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareValue(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                            final V expectedValue) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(record);&lt;br/&gt;
@@ -65,6 +66,7 @@&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@param &amp;lt;V&amp;gt; the value type&lt;/li&gt;
	&lt;li&gt;@throws AssertionError if 
{@code ProducerRecord}&apos;s value is not equal to {@code expectedRecord}&apos;s value&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareValue(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                            final ProducerRecord&amp;lt;K, V&amp;gt; expectedRecord) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(expectedRecord);&lt;br/&gt;
@@ -82,6 +84,7 @@&lt;br/&gt;
      * @param &amp;lt;V&amp;gt; the value type&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}
&lt;p&gt;&apos;s key or value is not equal to &lt;/p&gt;
{@code expectedKey} or {@code expectedValue}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValue(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                               final K expectedKey,&lt;br/&gt;
                                               final V expectedValue) throws AssertionError {&lt;br/&gt;
@@ -119,6 +122,7 @@&lt;br/&gt;
      * @param &amp;lt;V&amp;gt; the value type&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s key or value is not equal to {@code expectedRecord}&apos;s key or value&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValue(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                               final ProducerRecord&amp;lt;K, V&amp;gt; expectedRecord) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(expectedRecord);&lt;br/&gt;
@@ -136,6 +140,7 @@&lt;br/&gt;
      * @param &amp;lt;V&amp;gt; the value type&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s value or timestamp is not equal to {@code expectedValue} or {@code expectedTimestamp}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareValueTimestamp(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                     final V expectedValue,&lt;br/&gt;
                                                     final long expectedTimestamp) throws AssertionError {&lt;br/&gt;
@@ -169,6 +174,7 @@&lt;br/&gt;
      * @param &amp;lt;V&amp;gt; the value type&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s value or timestamp is not equal to {@code expectedRecord}&apos;s value or timestamp&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareValueTimestamp(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                     final ProducerRecord&amp;lt;K, V&amp;gt; expectedRecord) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(expectedRecord);&lt;br/&gt;
@@ -189,6 +195,7 @@&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s key, value, timestamp is not equal to {@code expectedKey}
&lt;p&gt;,&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;{@code expectedValue}, or {@code expectedTimestamps}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValueTimestamp(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                        final K expectedKey,&lt;br/&gt;
                                                        final V expectedValue,&lt;br/&gt;
@@ -233,6 +240,7 @@&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s key, value, or timestamp is not equal to&lt;br/&gt;
      * {@code expectedRecord}&apos;s key, value, or timestamp&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValueTimestamp(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                        final ProducerRecord&amp;lt;K, V&amp;gt; expectedRecord) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(expectedRecord);&lt;br/&gt;
@@ -250,6 +258,7 @@&lt;br/&gt;
      * @param &amp;lt;V&amp;gt; the value type&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s value or headers is not equal to {@code expectedValue}
&lt;p&gt; or &lt;/p&gt;
{@code expectedHeaders}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareValueHeaders(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                   final V expectedValue,&lt;br/&gt;
                                                   final Headers expectedHeaders) throws AssertionError {&lt;br/&gt;
@@ -287,6 +296,7 @@&lt;br/&gt;
      * @param &amp;lt;V&amp;gt; the value type&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s value or headers is not equal to {@code expectedRecord}&apos;s value or headers&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareValueHeaders(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                   final ProducerRecord&amp;lt;K, V&amp;gt; expectedRecord) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(expectedRecord);&lt;br/&gt;
@@ -307,6 +317,7 @@&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s key, value, headers is not equal to {@code expectedKey},&lt;br/&gt;
      *                        {@code expectedValue}, or {@code expectedHeaders}
&lt;p&gt;      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValueHeaders(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                      final K expectedKey,&lt;br/&gt;
                                                      final V expectedValue,&lt;br/&gt;
@@ -355,6 +366,7 @@&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}&apos;s key, value, or headers is not equal to&lt;br/&gt;
      *                        {@code expectedRecord}&apos;s key, value, or headers&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValueHeaders(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                      final ProducerRecord&amp;lt;K, V&amp;gt; expectedRecord) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(expectedRecord);&lt;br/&gt;
@@ -376,6 +388,7 @@&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@throws AssertionError if 
{@code ProducerRecord}&apos;s key, value, headers is not equal to {@code expectedKey},&lt;br/&gt;
      *                        {@code expectedValue}, or {@code expectedHeaders}&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings({&quot;WeakerAccess&quot;, &quot;unused&quot;})&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValueHeadersTimestamp(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                               final K expectedKey,&lt;br/&gt;
                                                               final V expectedValue,&lt;br/&gt;
@@ -432,6 +445,7 @@&lt;br/&gt;
      * @throws AssertionError if {@code ProducerRecord}
&lt;p&gt;&apos;s key, value, headers, or timestamp is not equal to&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;{@code expectedRecord}
&lt;p&gt;&apos;s key, value, headers, or timestamp&lt;br/&gt;
      */&lt;br/&gt;
+    @SuppressWarnings(&lt;/p&gt;
{&quot;WeakerAccess&quot;, &quot;unused&quot;}
&lt;p&gt;)&lt;br/&gt;
     public static &amp;lt;K, V&amp;gt; void compareKeyValueHeadersTimestamp(final ProducerRecord&amp;lt;K, V&amp;gt; record,&lt;br/&gt;
                                                               final ProducerRecord&amp;lt;K, V&amp;gt; expectedRecord) throws AssertionError {&lt;br/&gt;
         Objects.requireNonNull(expectedRecord);&lt;br/&gt;
diff --git a/streams/test-utils/src/test/java/org/apache/kafka/streams/MockProcessorContextTest.java b/streams/test-utils/src/test/java/org/apache/kafka/streams/MockProcessorContextTest.java&lt;br/&gt;
index 64d5b12dc0b..878aa357483 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/test-utils/src/test/java/org/apache/kafka/streams/MockProcessorContextTest.java&lt;br/&gt;
+++ b/streams/test-utils/src/test/java/org/apache/kafka/streams/MockProcessorContextTest.java&lt;br/&gt;
@@ -156,9 +156,9 @@ public void process(final String key, final Long value) {&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldThrowIfForwardedWithDeprecatedChildIndex() {&lt;br/&gt;
         final AbstractProcessor&amp;lt;String, Long&amp;gt; processor = new AbstractProcessor&amp;lt;String, Long&amp;gt;() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            @SuppressWarnings(&amp;quot;deprecation&amp;quot;)             @Override             public void process(final String key, final Long value) {
-                //noinspection deprecation
                 context().forward(key, value, 0);
             }         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
@@ -178,9 +178,9 @@ public void process(final String key, final Long value) {&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldThrowIfForwardedWithDeprecatedChildName() {&lt;br/&gt;
         final AbstractProcessor&amp;lt;String, Long&amp;gt; processor = new AbstractProcessor&amp;lt;String, Long&amp;gt;() &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            @SuppressWarnings(&amp;quot;deprecation&amp;quot;)             @Override             public void process(final String key, final Long value) {
-                //noinspection deprecation
                 context().forward(key, value, &quot;child1&quot;);
             }         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
@@ -347,12 +347,7 @@ public void init(final ProcessorContext context) {&lt;br/&gt;
                 context.schedule(&lt;br/&gt;
                     1000L,&lt;br/&gt;
                     PunctuationType.WALL_CLOCK_TIME,&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;new Punctuator() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void punctuate(final long timestamp) 
{
-                            context.commit();
-                        }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+                    timestamp -&amp;gt; context.commit()&lt;br/&gt;
                 );&lt;br/&gt;
             }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java b/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java&lt;br/&gt;
index 2d446d1de2c..7552637dc26 100644&lt;br/&gt;
&amp;#8212; a/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java&lt;br/&gt;
+++ b/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java&lt;br/&gt;
@@ -31,14 +31,15 @@&lt;br/&gt;
 import org.apache.kafka.common.serialization.StringSerializer;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.common.utils.SystemTime;&lt;br/&gt;
+import org.apache.kafka.streams.errors.TopologyException;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Consumed;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Materialized;&lt;br/&gt;
-import org.apache.kafka.streams.errors.TopologyException;&lt;br/&gt;
 import org.apache.kafka.streams.processor.Processor;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorSupplier;&lt;br/&gt;
 import org.apache.kafka.streams.processor.PunctuationType;&lt;br/&gt;
 import org.apache.kafka.streams.processor.Punctuator;&lt;br/&gt;
+import org.apache.kafka.streams.processor.StateStore;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueStore;&lt;br/&gt;
 import org.apache.kafka.streams.state.Stores;&lt;br/&gt;
@@ -64,6 +65,7 @@&lt;/p&gt;

&lt;p&gt; import static org.hamcrest.CoreMatchers.equalTo;&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertNotNull;&lt;br/&gt;
 import static org.junit.Assert.assertThat;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;br/&gt;
@@ -100,26 +102,27 @@&lt;br/&gt;
     };&lt;br/&gt;
     private KeyValueStore&amp;lt;String, Long&amp;gt; store;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private StringDeserializer stringDeserializer = new StringDeserializer();&lt;/li&gt;
	&lt;li&gt;private LongDeserializer longDeserializer = new LongDeserializer();&lt;/li&gt;
	&lt;li&gt;private ConsumerRecordFactory&amp;lt;String, Long&amp;gt; recordFactory = new ConsumerRecordFactory&amp;lt;&amp;gt;(&lt;br/&gt;
+    private final StringDeserializer stringDeserializer = new StringDeserializer();&lt;br/&gt;
+    private final LongDeserializer longDeserializer = new LongDeserializer();&lt;br/&gt;
+    private final ConsumerRecordFactory&amp;lt;String, Long&amp;gt; recordFactory = new ConsumerRecordFactory&amp;lt;&amp;gt;(&lt;br/&gt;
         new StringSerializer(),&lt;br/&gt;
         new LongSerializer());&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;     private final static class Record {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private Object key;&lt;/li&gt;
	&lt;li&gt;private Object value;&lt;/li&gt;
	&lt;li&gt;private long timestamp;&lt;/li&gt;
	&lt;li&gt;private long offset;&lt;/li&gt;
	&lt;li&gt;private String topic;&lt;/li&gt;
	&lt;li&gt;private Headers headers;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;Record(final ConsumerRecord consumerRecord) {&lt;br/&gt;
+        private final Object key;&lt;br/&gt;
+        private final Object value;&lt;br/&gt;
+        private final long timestamp;&lt;br/&gt;
+        private final long offset;&lt;br/&gt;
+        private final String topic;&lt;br/&gt;
+        private final Headers headers;&lt;br/&gt;
+&lt;br/&gt;
+        Record(final ConsumerRecord consumerRecord,&lt;br/&gt;
+               final long newOffset) 
{
             key = consumerRecord.key();
             value = consumerRecord.value();
             timestamp = consumerRecord.timestamp();
-            offset = consumerRecord.offset();
+            offset = newOffset;
             topic = consumerRecord.topic();
             headers = consumerRecord.headers();
         }
&lt;p&gt;@@ -184,7 +187,7 @@ public int hashCode() {&lt;br/&gt;
         private final List&amp;lt;Long&amp;gt; punctuatedAt = new LinkedList&amp;lt;&amp;gt;();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         @Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void punctuate(long timestamp) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        public void punctuate(final long timestamp) {
             punctuatedAt.add(timestamp);
         }     }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;@@ -202,7 +205,7 @@ public void punctuate(long timestamp) {&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         @Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void init(ProcessorContext context) {&lt;br/&gt;
+        public void init(final ProcessorContext context) {&lt;br/&gt;
             initialized = true;&lt;br/&gt;
             this.context = context;&lt;br/&gt;
             for (final Punctuation punctuation : punctuations) {&lt;br/&gt;
@@ -211,7 +214,7 @@ public void init(ProcessorContext context) {&lt;br/&gt;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         @Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void process(Object key, Object value) {&lt;br/&gt;
+        public void process(final Object key, final Object value) 
{
             processedRecords.add(new Record(key, value, context.headers(), context.timestamp(), context.offset(), context.topic()));
             context.forward(key, value);
         }
&lt;p&gt;@@ -228,7 +231,7 @@ public void close() {&lt;br/&gt;
         private final Collection&amp;lt;Punctuation&amp;gt; punctuations;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         private MockProcessorSupplier() &lt;/p&gt;
{
-            this(Collections.&amp;lt;Punctuation&amp;gt;emptySet());
+            this(Collections.emptySet());
         }

&lt;p&gt;         private MockProcessorSupplier(final Collection&amp;lt;Punctuation&amp;gt; punctuations) {&lt;br/&gt;
@@ -391,8 +394,7 @@ public void shouldSetRecordMetadata() &lt;/p&gt;
{
         assertEquals(1, processedRecords.size());
 
         final Record record = processedRecords.get(0);
-        final Record expectedResult = new Record(consumerRecord1);
-        expectedResult.offset = 0L;
+        final Record expectedResult = new Record(consumerRecord1, 0L);
 
         assertThat(record, equalTo(expectedResult));
     }
&lt;p&gt;@@ -410,8 +412,7 @@ public void shouldSendRecordViaCorrectSourceTopic() {&lt;br/&gt;
         assertEquals(0, processedRecords2.size());&lt;/p&gt;

&lt;p&gt;         Record record = processedRecords1.get(0);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Record expectedResult = new Record(consumerRecord1);&lt;/li&gt;
	&lt;li&gt;expectedResult.offset = 0L;&lt;br/&gt;
+        Record expectedResult = new Record(consumerRecord1, 0L);&lt;br/&gt;
         assertThat(record, equalTo(expectedResult));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         testDriver.pipeInput(consumerRecord2);&lt;br/&gt;
@@ -420,8 +421,7 @@ public void shouldSendRecordViaCorrectSourceTopic() &lt;/p&gt;
{
         assertEquals(1, processedRecords2.size());
 
         record = processedRecords2.get(0);
-        expectedResult = new Record(consumerRecord2);
-        expectedResult.offset = 0L;
+        expectedResult = new Record(consumerRecord2, 0L);
         assertThat(record, equalTo(expectedResult));
     }

&lt;p&gt;@@ -439,7 +439,7 @@ public void shouldUseSourceSpecificDeserializers() {&lt;br/&gt;
         topology.addSink(&lt;br/&gt;
             &quot;sink&quot;,&lt;br/&gt;
             SINK_TOPIC_1,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;new Serializer() {&lt;br/&gt;
+            new Serializer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public byte[] serialize(final String topic, final Object data) {&lt;br/&gt;
                     if (data instanceof Long) {&lt;br/&gt;
@@ -452,7 +452,7 @@ public void close() {}&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public void configure(final Map configs, final boolean isKey) {}&lt;br/&gt;
             },&lt;/li&gt;
	&lt;li&gt;new Serializer() {&lt;br/&gt;
+            new Serializer&amp;lt;Object&amp;gt;() {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public byte[] serialize(final String topic, final Object data) {&lt;br/&gt;
                     if (data instanceof String) {&lt;br/&gt;
@@ -560,13 +560,11 @@ public void shouldProcessConsumerRecordList() 
{
         assertEquals(1, processedRecords2.size());
 
         Record record = processedRecords1.get(0);
-        Record expectedResult = new Record(consumerRecord1);
-        expectedResult.offset = 0L;
+        Record expectedResult = new Record(consumerRecord1, 0L);
         assertThat(record, equalTo(expectedResult));
 
         record = processedRecords2.get(0);
-        expectedResult = new Record(consumerRecord2);
-        expectedResult.offset = 0L;
+        expectedResult = new Record(consumerRecord2, 0L);
         assertThat(record, equalTo(expectedResult));
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -601,8 +599,7 @@ public void shouldPopulateGlobalStore() &lt;/p&gt;
{
         assertEquals(1, processedRecords.size());
 
         final Record record = processedRecords.get(0);
-        final Record expectedResult = new Record(consumerRecord1);
-        expectedResult.offset = 0L;
+        final Record expectedResult = new Record(consumerRecord1, 0L);
         assertThat(record, equalTo(expectedResult));
     }

&lt;p&gt;@@ -687,13 +684,14 @@ public void shouldPunctuateOnWallClockTime() {&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldReturnAllStores() {&lt;br/&gt;
         final Topology topology = setupSourceSinkTopology();&lt;br/&gt;
+        topology.addProcessor(&quot;processor&quot;, () -&amp;gt; null);&lt;br/&gt;
         topology.addStateStore(&lt;br/&gt;
             new KeyValueStoreBuilder&amp;lt;&amp;gt;(&lt;br/&gt;
                 Stores.inMemoryKeyValueStore(&quot;store&quot;),&lt;br/&gt;
                 Serdes.ByteArray(),&lt;br/&gt;
                 Serdes.ByteArray(),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;new SystemTime())&lt;/li&gt;
	&lt;li&gt;.withLoggingDisabled());&lt;br/&gt;
+                new SystemTime()),&lt;br/&gt;
+            &quot;processor&quot;);&lt;br/&gt;
         topology.addGlobalStore(&lt;br/&gt;
             new KeyValueStoreBuilder&amp;lt;&amp;gt;(&lt;br/&gt;
                 Stores.inMemoryKeyValueStore(&quot;globalStore&quot;),&lt;br/&gt;
@@ -705,12 +703,41 @@ public void shouldReturnAllStores() {&lt;br/&gt;
             Serdes.ByteArray().deserializer(),&lt;br/&gt;
             &quot;globalTopicName&quot;,&lt;br/&gt;
             &quot;globalProcessorName&quot;,&lt;/li&gt;
	&lt;li&gt;new ProcessorSupplier() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Processor get() 
{
-                    return null;
-                }&lt;/li&gt;
	&lt;li&gt;});&lt;br/&gt;
+            () -&amp;gt; null);&lt;br/&gt;
+&lt;br/&gt;
+        testDriver = new TopologyTestDriver(topology, config);&lt;br/&gt;
+&lt;br/&gt;
+        final Set&amp;lt;String&amp;gt; expectedStoreNames = new HashSet&amp;lt;&amp;gt;();&lt;br/&gt;
+        expectedStoreNames.add(&quot;store&quot;);&lt;br/&gt;
+        expectedStoreNames.add(&quot;globalStore&quot;);&lt;br/&gt;
+        final Map&amp;lt;String, StateStore&amp;gt; allStores = testDriver.getAllStateStores();&lt;br/&gt;
+        assertThat(allStores.keySet(), equalTo(expectedStoreNames));&lt;br/&gt;
+        for (final StateStore store : allStores.values()) 
{
+            assertNotNull(store);
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldReturnAllStoresNames() {&lt;br/&gt;
+        final Topology topology = setupSourceSinkTopology();&lt;br/&gt;
+        topology.addStateStore(&lt;br/&gt;
+            new KeyValueStoreBuilder&amp;lt;&amp;gt;(&lt;br/&gt;
+                Stores.inMemoryKeyValueStore(&quot;store&quot;),&lt;br/&gt;
+                Serdes.ByteArray(),&lt;br/&gt;
+                Serdes.ByteArray(),&lt;br/&gt;
+                new SystemTime()));&lt;br/&gt;
+        topology.addGlobalStore(&lt;br/&gt;
+            new KeyValueStoreBuilder&amp;lt;&amp;gt;(&lt;br/&gt;
+                Stores.inMemoryKeyValueStore(&quot;globalStore&quot;),&lt;br/&gt;
+                Serdes.ByteArray(),&lt;br/&gt;
+                Serdes.ByteArray(),&lt;br/&gt;
+                new SystemTime()).withLoggingDisabled(),&lt;br/&gt;
+            &quot;sourceProcessorName&quot;,&lt;br/&gt;
+            Serdes.ByteArray().deserializer(),&lt;br/&gt;
+            Serdes.ByteArray().deserializer(),&lt;br/&gt;
+            &quot;globalTopicName&quot;,&lt;br/&gt;
+            &quot;globalProcessorName&quot;,&lt;br/&gt;
+            () -&amp;gt; null);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         testDriver = new TopologyTestDriver(topology, config);&lt;/p&gt;

&lt;p&gt;@@ -721,13 +748,13 @@ public Processor get() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     private void setup() {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Topology topology = new Topology();&lt;br/&gt;
+        final Topology topology = new Topology();&lt;br/&gt;
         topology.addSource(&quot;sourceProcessor&quot;, &quot;input-topic&quot;);&lt;br/&gt;
         topology.addProcessor(&quot;aggregator&quot;, new CustomMaxAggregatorSupplier(), &quot;sourceProcessor&quot;);&lt;br/&gt;
         topology.addStateStore(Stores.keyValueStoreBuilder(&lt;br/&gt;
             Stores.inMemoryKeyValueStore(&quot;aggStore&quot;),&lt;br/&gt;
             Serdes.String(),&lt;/li&gt;
	&lt;li&gt;Serdes.Long()).withLoggingDisabled(), // need to disable logging to allow store pre-populating&lt;br/&gt;
+            Serdes.Long()),&lt;br/&gt;
             &quot;aggregator&quot;);&lt;br/&gt;
         topology.addSink(&quot;sinkProcessor&quot;, &quot;result-topic&quot;, &quot;aggregator&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -812,18 +839,8 @@ public void shouldPunctuateIfWallClockTimeAdvances() {&lt;br/&gt;
         @Override&lt;br/&gt;
         public void init(final ProcessorContext context) {&lt;br/&gt;
             this.context = context;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;context.schedule(60000, PunctuationType.WALL_CLOCK_TIME, new Punctuator() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void punctuate(final long timestamp) 
{
-                    flushStore();
-                }&lt;br/&gt;
-            });&lt;br/&gt;
-            context.schedule(10000, PunctuationType.STREAM_TIME, new Punctuator() {&lt;br/&gt;
-                @Override&lt;br/&gt;
-                public void punctuate(final long timestamp) {-                    flushStore();-                }&lt;/li&gt;
	&lt;li&gt;});&lt;br/&gt;
+            context.schedule(60000, PunctuationType.WALL_CLOCK_TIME, timestamp -&amp;gt; flushStore());&lt;br/&gt;
+            context.schedule(10000, PunctuationType.STREAM_TIME, timestamp -&amp;gt; flushStore());&lt;br/&gt;
             store = (KeyValueStore&amp;lt;String, Long&amp;gt;) context.getStateStore(&quot;aggStore&quot;);&lt;br/&gt;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -908,7 +925,7 @@ public void shouldFeedStoreFromGlobalKTable() {&lt;br/&gt;
         final StreamsBuilder builder = new StreamsBuilder();&lt;br/&gt;
         builder.globalTable(&quot;topic&quot;,&lt;br/&gt;
             Consumed.with(Serdes.String(), Serdes.String()),&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Materialized.&amp;lt;String, String, KeyValueStore&amp;lt;Bytes, byte[]&amp;gt;&amp;gt;as(&quot;globalStore&quot;));&lt;br/&gt;
+            Materialized.as(&quot;globalStore&quot;));&lt;br/&gt;
         try (final TopologyTestDriver testDriver = new TopologyTestDriver(builder.build(), config)) {&lt;br/&gt;
             final KeyValueStore&amp;lt;String, String&amp;gt; globalStore = testDriver.getKeyValueStore(&quot;globalStore&quot;);&lt;br/&gt;
             Assert.assertNotNull(globalStore);&lt;br/&gt;
@@ -956,8 +973,7 @@ public void shouldProcessFromSourcesThatMatchMultiplePattern() {&lt;br/&gt;
         assertEquals(0, processedRecords2.size());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final Record record1 = processedRecords1.get(0);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Record expectedResult1 = new Record(consumerRecord1);&lt;/li&gt;
	&lt;li&gt;expectedResult1.offset = 0L;&lt;br/&gt;
+        final Record expectedResult1 = new Record(consumerRecord1, 0L);&lt;br/&gt;
         assertThat(record1, equalTo(expectedResult1));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         testDriver.pipeInput(consumerRecord2);&lt;br/&gt;
@@ -966,8 +982,7 @@ public void shouldProcessFromSourcesThatMatchMultiplePattern() &lt;/p&gt;
{
         assertEquals(1, processedRecords2.size());
 
         final Record record2 = processedRecords2.get(0);
-        final Record expectedResult2 = new Record(consumerRecord2);
-        expectedResult2.offset = 0L;
+        final Record expectedResult2 = new Record(consumerRecord2, 0L);
         assertThat(record2, equalTo(expectedResult2));
     }

&lt;p&gt;@@ -1004,7 +1019,7 @@ public void shouldThrowPatternNotValidForTopicNameException() {&lt;br/&gt;
         try &lt;/p&gt;
{
             testDriver.pipeInput(consumerRecord1);
         }
&lt;p&gt; catch (final TopologyException exception) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;String str =&lt;br/&gt;
+            final String str =&lt;br/&gt;
                     String.format(&lt;br/&gt;
                             &quot;Invalid topology: Topology add source of type String for topic: %s cannot contain regex pattern for &quot; +&lt;br/&gt;
                                     &quot;input record topic: %s and hence cannot process the message.&quot;,&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 23 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ua6f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>