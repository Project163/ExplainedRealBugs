<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:00:14 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-4959] remove controller concurrent access to non-threadsafe NetworkClient, Selector, and SSLEngine</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-4959</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;This brought down a cluster by causing continuous controller moves.&lt;/p&gt;

&lt;p&gt;ZkClient&apos;s ZkEventThread and a RequestSendThread can concurrently use objects that aren&apos;t thread-safe:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Selector&lt;/li&gt;
	&lt;li&gt;NetworkClient&lt;/li&gt;
	&lt;li&gt;SSLEngine (this was the big one for us. We turn on SSL for interbroker communication).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As per the &quot;Concurrency Notes&quot; section from the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;SSLEngine javadoc&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;two threads must not attempt to call the same method (either wrap() or unwrap()) concurrently&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;SSLEngine.wrap gets called in:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;SslTransportLayer.write&lt;/li&gt;
	&lt;li&gt;SslTransportLayer.handshake&lt;/li&gt;
	&lt;li&gt;SslTransportLayer.close&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It turns out that the ZkEventThread and RequestSendThread can concurrently call SSLEngine.wrap:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ZkEventThread calls SslTransportLayer.close from ControllerChannelManager.removeExistingBroker&lt;/li&gt;
	&lt;li&gt;RequestSendThread can call SslTransportLayer.write or SslTransportLayer.handshake from NetworkClient.poll&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Suppose the controller moves for whatever reason. The former controller could have had a RequestSendThread who was in the middle of sending out messages to the cluster while the ZkEventThread began executing KafkaController.onControllerResignation, which calls ControllerChannelManager.shutdown, which sequentially cleans up the controller-to-broker queue and connection for every broker in the cluster. This cleanup includes the call to ControllerChannelManager.removeExistingBroker as mentioned earlier, causing the concurrent call to SSLEngine.wrap. This concurrent call throws a BufferOverflowException which ControllerChannelManager.removeExistingBroker catches so the ControllerChannelManager.shutdown moves onto cleaning up the next controller-to-broker queue and connection, skipping the cleanup steps such as clearing the queue, stopping the RequestSendThread, and removing the entry from its brokerStateInfo map.&lt;/p&gt;

&lt;p&gt;By failing out of the Selector.close, the sensors corresponding to the broker connection has not been cleaned up. Any later attempt at initializing an identical Selector will result in a sensor collision and therefore cause Selector initialization to throw an exception. In other words, any later attempts by this broker to become controller again will fail on initialization. When controller initialization fails, the controller deletes the /controller znode and lets another broker take over.&lt;/p&gt;

&lt;p&gt;Now suppose the controller moves enough times such that every broker hits the BufferOverflowException concurrency issue. We&apos;re now guaranteed to fail controller initialization due to the sensor collision on every controller transition, so the controller will move across brokers continuously.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13059553">KAFKA-4959</key>
            <summary>remove controller concurrent access to non-threadsafe NetworkClient, Selector, and SSLEngine</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="onurkaraman">Onur Karaman</assignee>
                                    <reporter username="onurkaraman">Onur Karaman</reporter>
                        <labels>
                    </labels>
                <created>Mon, 27 Mar 2017 21:26:11 +0000</created>
                <updated>Tue, 28 Mar 2017 22:56:40 +0000</updated>
                            <resolved>Tue, 28 Mar 2017 22:56:40 +0000</resolved>
                                                    <fixVersion>0.10.2.1</fixVersion>
                    <fixVersion>0.11.0.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="15944120" author="githubbot" created="Mon, 27 Mar 2017 22:05:47 +0000"  >&lt;p&gt;GitHub user onurkaraman opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/2746&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/2746&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4959&quot; title=&quot;remove controller concurrent access to non-threadsafe NetworkClient, Selector, and SSLEngine&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4959&quot;&gt;&lt;del&gt;KAFKA-4959&lt;/del&gt;&lt;/a&gt;: remove controller concurrent access to non-threadsafe NetworkClient, Selector, and SSLEngine&lt;/p&gt;

&lt;p&gt;    This brought down a cluster by causing continuous controller moves.&lt;/p&gt;

&lt;p&gt;    ZkClient&apos;s ZkEventThread and a RequestSendThread can concurrently use objects that aren&apos;t thread-safe:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Selector&lt;/li&gt;
	&lt;li&gt;NetworkClient&lt;/li&gt;
	&lt;li&gt;SSLEngine (this was the big one for us. We turn on SSL for interbroker communication).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As per the &quot;Concurrency Notes&quot; section from &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html:&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html:&lt;/a&gt;&lt;br/&gt;
    &amp;gt; two threads must not attempt to call the same method (either wrap() or unwrap()) concurrently&lt;/p&gt;

&lt;p&gt;    SSLEngine.wrap gets called in:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;SslTransportLayer.write&lt;/li&gt;
	&lt;li&gt;SslTransportLayer.handshake&lt;/li&gt;
	&lt;li&gt;SslTransportLayer.close&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It turns out that the ZkEventThread and RequestSendThread can concurrently call SSLEngine.wrap:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ZkEventThread calls SslTransportLayer.close from ControllerChannelManager.removeExistingBroker&lt;/li&gt;
	&lt;li&gt;RequestSendThread can call SslTransportLayer.write or SslTransportLayer.handshake from NetworkClient.poll&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Suppose the controller moves for whatever reason. The former controller could have had a RequestSendThread who was in the middle of sending out messages to the cluster while the ZkEventThread began executing KafkaController.onControllerResignation, which calls ControllerChannelManager.shutdown, which sequentially cleans up the controller-to-broker queue and connection for every broker in the cluster. This cleanup includes the call to ControllerChannelManager.removeExistingBroker as mentioned earlier, causing the concurrent call to SSLEngine.wrap. This concurrent call throws a BufferOverflowException which ControllerChannelManager.removeExistingBroker catches so the ControllerChannelManager.shutdown moves onto cleaning up the next controller-to-broker queue and connection, skipping the cleanup steps such as clearing the queue, stopping the RequestSendThread, and removing the entry from its brokerStateInfo map.&lt;/p&gt;

&lt;p&gt;    By failing out of the Selector.close, the sensors corresponding to the broker connection has not been cleaned up. Any later attempt at initializing an identical Selector will result in a sensor collision and therefore cause Selector initialization to throw an exception. In other words, any later attempts by this broker to become controller again will fail on initialization. When controller initialization fails, the controller deletes the /controller znode and lets another broker take over.&lt;/p&gt;

&lt;p&gt;    Now suppose the controller moves enough times such that every broker hits the BufferOverflowException concurrency issue. We&apos;re now guaranteed to fail controller initialization due to the sensor collision on every controller transition, so the controller will move across brokers continuously.&lt;/p&gt;

&lt;p&gt;    This patch avoids the concurrent use of non-threadsafe classes in ControllerChannelManager.removeExistingBroker by shutting down the RequestSendThreaad before closing the NetworkClient.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/onurkaraman/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/onurkaraman/kafka&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4959&quot; title=&quot;remove controller concurrent access to non-threadsafe NetworkClient, Selector, and SSLEngine&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4959&quot;&gt;&lt;del&gt;KAFKA-4959&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/2746.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/2746.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #2746&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 7c956de3a95fd8080a682a48d0900ca39dee19f3&lt;br/&gt;
Author: Onur Karaman &amp;lt;okaraman@linkedin.com&amp;gt;&lt;br/&gt;
Date:   2017-03-27T21:10:53Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4959&quot; title=&quot;remove controller concurrent access to non-threadsafe NetworkClient, Selector, and SSLEngine&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4959&quot;&gt;&lt;del&gt;KAFKA-4959&lt;/del&gt;&lt;/a&gt;: remove controller concurrent access to non-threadsafe NetworkClient, Selector, and SSLEngine&lt;/p&gt;

&lt;p&gt;    This brought down a cluster by causing continuous controller moves.&lt;/p&gt;

&lt;p&gt;    ZkClient&apos;s ZkEventThread and a RequestSendThread can concurrently use objects that aren&apos;t thread-safe:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Selector&lt;/li&gt;
	&lt;li&gt;NetworkClient&lt;/li&gt;
	&lt;li&gt;SSLEngine (this was the big one for us. We turn on SSL for interbroker communication).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As per the &quot;Concurrency Notes&quot; section from &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html:&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLEngine.html:&lt;/a&gt;&lt;br/&gt;
    two threads must not attempt to call the same method (either wrap() or unwrap()) concurrently&lt;/p&gt;

&lt;p&gt;    SSLEngine.wrap gets called in:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;SslTransportLayer.write&lt;/li&gt;
	&lt;li&gt;SslTransportLayer.handshake&lt;/li&gt;
	&lt;li&gt;SslTransportLayer.close&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It turns out that the ZkEventThread and RequestSendThread can concurrently call SSLEngine.wrap:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;ZkEventThread calls SslTransportLayer.close from ControllerChannelManager.removeExistingBroker&lt;/li&gt;
	&lt;li&gt;RequestSendThread can call SslTransportLayer.write or SslTransportLayer.handshake from NetworkClient.poll&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Suppose the controller moves for whatever reason. The former controller could have had a RequestSendThread who was in the middle of sending out messages to the cluster while the ZkEventThread began executing KafkaController.onControllerResignation, which calls ControllerChannelManager.shutdown, which sequentially cleans up the controller-to-broker queue and connection for every broker in the cluster. This cleanup includes the call to ControllerChannelManager.removeExistingBroker as mentioned earlier, causing the concurrent call to SSLEngine.wrap. This concurrent call throws a BufferOverflowException which ControllerChannelManager.removeExistingBroker catches so the ControllerChannelManager.shutdown moves onto cleaning up the next controller-to-broker queue and connection, skipping the cleanup steps such as clearing the queue, stopping the RequestSendThread, and removing the entry from its brokerStateInfo map.&lt;/p&gt;

&lt;p&gt;    By failing out of the Selector.close, the sensors corresponding to the broker connection has not been cleaned up. Any later attempt at initializing an identical Selector will result in a sensor collision and therefore cause Selector initialization to throw an exception. In other words, any later attempts by this broker to become controller again will fail on initialization. When controller initialization fails, the controller deletes the /controller znode and lets another broker take over.&lt;/p&gt;

&lt;p&gt;    Now suppose the controller moves enough times such that every broker hits the BufferOverflowException concurrency issue. We&apos;re now guaranteed to fail controller initialization due to the sensor collision on every controller transition, so the controller will move across brokers continuously.&lt;/p&gt;

&lt;p&gt;    This patch avoids the concurrent use of non-threadsafe classes in ControllerChannelManager.removeExistingBroker by shutting down the RequestSendThreaad before closing the NetworkClient.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15946126" author="githubbot" created="Tue, 28 Mar 2017 22:54:45 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/2746&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/2746&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13056159">KAFKA-4900</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 33 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3cv2v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>