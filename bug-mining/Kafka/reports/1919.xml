<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:10:37 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6868] BufferUnderflowException in client when querying consumer group information</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6868</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Exceptions get thrown when describing consumer group or querying group offsets from a 1.0 cluster&lt;/p&gt;

&lt;p&gt;Stacktrace is a result of calling &lt;tt&gt;AdminClient.describeConsumerGroups(Collection&amp;lt;String&amp;gt; groupIds).describedGroups().entrySet()&lt;/tt&gt; followed by &lt;tt&gt;KafkaFuture&amp;lt;ConsumerGroupDescription&amp;gt;.whenComplete()&lt;/tt&gt;&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java.util.concurrent.ExecutionException: org.apache.kafka.common.protocol.types.SchemaException: Error reading field &lt;span class=&quot;code-quote&quot;&gt;&apos;version&apos;&lt;/span&gt;: java.nio.BufferUnderflowException
	at org.apache.kafka.common.internals.KafkaFutureImpl.wrapAndThrow(KafkaFutureImpl.java:45)
	at org.apache.kafka.common.internals.KafkaFutureImpl.access$000(KafkaFutureImpl.java:32)
	at org.apache.kafka.common.internals.KafkaFutureImpl$SingleWaiter.await(KafkaFutureImpl.java:104)
	at org.apache.kafka.common.internals.KafkaFutureImpl.get(KafkaFutureImpl.java:274)
	at
[snip]
Caused by: org.apache.kafka.common.protocol.types.SchemaException: Error reading field &lt;span class=&quot;code-quote&quot;&gt;&apos;version&apos;&lt;/span&gt;: java.nio.BufferUnderflowException
	at org.apache.kafka.common.protocol.types.Schema.read(Schema.java:76)
	at org.apache.kafka.clients.consumer.internals.ConsumerProtocol.deserializeAssignment(ConsumerProtocol.java:105)
	at org.apache.kafka.clients.admin.KafkaAdminClient$21$1.handleResponse(KafkaAdminClient.java:2307)
	at org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.handleResponses(KafkaAdminClient.java:960)
	at org.apache.kafka.clients.admin.KafkaAdminClient$AdminClientRunnable.run(KafkaAdminClient.java:1045)
	... 1 more
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="13157310">KAFKA-6868</key>
            <summary>BufferUnderflowException in client when querying consumer group information</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="cmccabe">Colin McCabe</assignee>
                                    <reporter username="xvrl">Xavier L&#233;aut&#233;</reporter>
                        <labels>
                    </labels>
                <created>Fri, 4 May 2018 23:12:32 +0000</created>
                <updated>Wed, 1 Aug 2018 18:13:57 +0000</updated>
                            <resolved>Mon, 21 May 2018 15:38:02 +0000</resolved>
                                                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16471303" author="hachikuji" created="Fri, 11 May 2018 00:03:51 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/kafka/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4980&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16482631" author="githubbot" created="Mon, 21 May 2018 15:37:38 +0000"  >&lt;p&gt;hachikuji closed pull request #4980: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6868&quot; title=&quot;BufferUnderflowException in client when querying consumer group information&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6868&quot;&gt;&lt;del&gt;KAFKA-6868&lt;/del&gt;&lt;/a&gt;: Fix buffer underflow and expose group state in the consumer groups API&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4980&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4980&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupDescription.java b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupDescription.java&lt;br/&gt;
index 0bfa8a782d5..bc3857d7aea 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupDescription.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/ConsumerGroupDescription.java&lt;br/&gt;
@@ -17,55 +17,56 @@&lt;/p&gt;

&lt;p&gt; package org.apache.kafka.clients.admin;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.ConsumerGroupState;&lt;br/&gt;
+import org.apache.kafka.common.Node;&lt;br/&gt;
 import org.apache.kafka.common.utils.Utils;&lt;/p&gt;

&lt;p&gt;-import java.util.List;&lt;br/&gt;
+import java.util.ArrayList;&lt;br/&gt;
+import java.util.Collection;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.Objects;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A detailed description of a single consumer group in the cluster.&lt;br/&gt;
  */&lt;br/&gt;
 public class ConsumerGroupDescription {&lt;br/&gt;
-&lt;br/&gt;
     private final String groupId;&lt;br/&gt;
     private final boolean isSimpleConsumerGroup;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final List&amp;lt;MemberDescription&amp;gt; members;&lt;br/&gt;
+    private final Collection&amp;lt;MemberDescription&amp;gt; members;&lt;br/&gt;
     private final String partitionAssignor;&lt;br/&gt;
+    private final ConsumerGroupState state;&lt;br/&gt;
+    private final Node coordinator;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Creates an instance with the specified parameters.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param groupId               The consumer group id&lt;/li&gt;
	&lt;li&gt;* @param isSimpleConsumerGroup If Consumer Group is simple&lt;/li&gt;
	&lt;li&gt;* @param members               The consumer group members&lt;/li&gt;
	&lt;li&gt;* @param partitionAssignor     The consumer group partition assignor&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public ConsumerGroupDescription(String groupId, boolean isSimpleConsumerGroup, List&amp;lt;MemberDescription&amp;gt; members, String partitionAssignor) {&lt;/li&gt;
	&lt;li&gt;this.groupId = groupId;&lt;br/&gt;
+    ConsumerGroupDescription(String groupId,&lt;br/&gt;
+            boolean isSimpleConsumerGroup,&lt;br/&gt;
+            Collection&amp;lt;MemberDescription&amp;gt; members,&lt;br/&gt;
+            String partitionAssignor,&lt;br/&gt;
+            ConsumerGroupState state,&lt;br/&gt;
+            Node coordinator) 
{
+        this.groupId = groupId == null ? &quot;&quot; : groupId;
         this.isSimpleConsumerGroup = isSimpleConsumerGroup;
-        this.members = members;
-        this.partitionAssignor = partitionAssignor;
+        this.members = members == null ? Collections.&amp;lt;MemberDescription&amp;gt;emptyList() :
+            Collections.unmodifiableList(new ArrayList&amp;lt;&amp;gt;(members));
+        this.partitionAssignor = partitionAssignor == null ? &quot;&quot; : partitionAssignor;
+        this.state = state;
+        this.coordinator = coordinator;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;br/&gt;
     public boolean equals(Object o) &lt;/p&gt;
{
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-
         ConsumerGroupDescription that = (ConsumerGroupDescription) o;
-
-        if (isSimpleConsumerGroup != that.isSimpleConsumerGroup) return false;
-        if (groupId != null ? !groupId.equals(that.groupId) : that.groupId != null) return false;
-        if (members != null ? !members.equals(that.members) : that.members != null) return false;
-        return partitionAssignor != null ? partitionAssignor.equals(that.partitionAssignor) : that.partitionAssignor == null;
+        return isSimpleConsumerGroup == that.isSimpleConsumerGroup &amp;amp;&amp;amp;
+            groupId.equals(that.groupId) &amp;amp;&amp;amp;
+            members.equals(that.members) &amp;amp;&amp;amp;
+            partitionAssignor.equals(that.partitionAssignor) &amp;amp;&amp;amp;
+            state.equals(that.state);
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public int hashCode() &lt;/p&gt;
{
-        int result = groupId != null ? groupId.hashCode() : 0;
-        result = 31 * result + (isSimpleConsumerGroup ? 1 : 0);
-        result = 31 * result + (members != null ? members.hashCode() : 0);
-        result = 31 * result + (partitionAssignor != null ? partitionAssignor.hashCode() : 0);
-        return result;
+        return Objects.hash(isSimpleConsumerGroup, groupId, members, partitionAssignor, state);
     }

&lt;p&gt;     /**&lt;br/&gt;
@@ -85,7 +86,7 @@ public boolean isSimpleConsumerGroup() {&lt;br/&gt;
     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A list of the members of the consumer group.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public List&amp;lt;MemberDescription&amp;gt; members() {&lt;br/&gt;
+    public Collection&amp;lt;MemberDescription&amp;gt; members() 
{
         return members;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -96,9 +97,28 @@ public String partitionAssignor() &lt;/p&gt;
{
         return partitionAssignor;
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * The consumer group state, or UNKNOWN if the state is too new for us to parse.&lt;br/&gt;
+     */&lt;br/&gt;
+    public ConsumerGroupState state() &lt;/p&gt;
{
+        return state;
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The consumer group coordinator, or null if the coordinator is not known.&lt;br/&gt;
+     */&lt;br/&gt;
+    public Node coordinator() &lt;/p&gt;
{
+        return coordinator;
+    }
&lt;p&gt;+&lt;br/&gt;
     @Override&lt;br/&gt;
     public String toString() &lt;/p&gt;
{
-        return &quot;(groupId=&quot; + groupId + &quot;, isSimpleConsumerGroup=&quot; + isSimpleConsumerGroup + &quot;, members=&quot; +
-            Utils.join(members, &quot;,&quot;) + &quot;, partitionAssignor=&quot; + partitionAssignor + &quot;)&quot;;
+        return &quot;(groupId=&quot; + groupId +
+            &quot;, isSimpleConsumerGroup=&quot; + isSimpleConsumerGroup +
+            &quot;, members=&quot; + Utils.join(members, &quot;,&quot;) +
+            &quot;, partitionAssignor=&quot; + partitionAssignor +
+            &quot;, state=&quot; + state +
+            &quot;, coordinator=&quot; + coordinator +
+            &quot;)&quot;;
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/DescribeConsumerGroupsResult.java b/clients/src/main/java/org/apache/kafka/clients/admin/DescribeConsumerGroupsResult.java&lt;br/&gt;
index ac2189cc6dc..8f0ebad4f7a 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/clients/admin/DescribeConsumerGroupsResult.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/DescribeConsumerGroupsResult.java&lt;br/&gt;
@@ -21,7 +21,9 @@&lt;br/&gt;
 import org.apache.kafka.common.annotation.InterfaceStability;&lt;/p&gt;

&lt;p&gt; import java.util.Collection;&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
+import java.util.concurrent.ExecutionException;&lt;/p&gt;


&lt;p&gt; /**&lt;br/&gt;
@@ -39,16 +41,32 @@ public DescribeConsumerGroupsResult(final Map&amp;lt;String, KafkaFuture&amp;lt;ConsumerGroupD&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Return a map from group id to futures which can be used to check the description of a consumer group.&lt;br/&gt;
+     * Return a map from group id to futures which yield group descriptions.&lt;br/&gt;
      */&lt;br/&gt;
     public Map&amp;lt;String, KafkaFuture&amp;lt;ConsumerGroupDescription&amp;gt;&amp;gt; describedGroups() 
{
         return futures;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Return a future which succeeds only if all the consumer group description succeed.&lt;br/&gt;
+     * Return a future which yields all ConsumerGroupDescription objects, if all the describes succeed.&lt;br/&gt;
      */&lt;/li&gt;
	&lt;li&gt;public KafkaFuture&amp;lt;Void&amp;gt; all() {&lt;/li&gt;
	&lt;li&gt;return KafkaFuture.allOf(futures.values().toArray(new KafkaFuture&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;));&lt;br/&gt;
+    public KafkaFuture&amp;lt;Map&amp;lt;String, ConsumerGroupDescription&amp;gt;&amp;gt; all() {&lt;br/&gt;
+        return KafkaFuture.allOf(futures.values().toArray(new KafkaFuture&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;)).thenApply(&lt;br/&gt;
+            new KafkaFuture.BaseFunction&amp;lt;Void, Map&amp;lt;String, ConsumerGroupDescription&amp;gt;&amp;gt;() {&lt;br/&gt;
+                @Override&lt;br/&gt;
+                public Map&amp;lt;String, ConsumerGroupDescription&amp;gt; apply(Void v) {&lt;br/&gt;
+                    try 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+                        Map&amp;lt;String, ConsumerGroupDescription&amp;gt; descriptions = new HashMap&amp;lt;&amp;gt;(futures.size());+                        for (Map.Entry&amp;lt;String, KafkaFuture&amp;lt;ConsumerGroupDescription&amp;gt;&amp;gt; entry }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (InterruptedException | ExecutionException e) &lt;/p&gt;
{
+                        // This should be unreachable, since the KafkaFuture#allOf already ensured
+                        // that all of the futures completed successfully.
+                        throw new RuntimeException(e);
+                    }
&lt;p&gt;+                }&lt;br/&gt;
+            });&lt;br/&gt;
     }&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java b/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java&lt;br/&gt;
index c9e0e186316..5f4eefe8279 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java&lt;br/&gt;
@@ -31,6 +31,7 @@&lt;br/&gt;
 import org.apache.kafka.clients.consumer.internals.ConsumerProtocol;&lt;br/&gt;
 import org.apache.kafka.clients.consumer.internals.PartitionAssignor;&lt;br/&gt;
 import org.apache.kafka.common.Cluster;&lt;br/&gt;
+import org.apache.kafka.common.ConsumerGroupState;&lt;br/&gt;
 import org.apache.kafka.common.KafkaException;&lt;br/&gt;
 import org.apache.kafka.common.KafkaFuture;&lt;br/&gt;
 import org.apache.kafka.common.Node;&lt;br/&gt;
@@ -120,11 +121,9 @@&lt;br/&gt;
 import org.apache.kafka.common.utils.KafkaThread;&lt;br/&gt;
 import org.apache.kafka.common.utils.LogContext;&lt;br/&gt;
 import org.apache.kafka.common.utils.Time;&lt;br/&gt;
-import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
 import org.slf4j.Logger;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import java.net.InetSocketAddress;&lt;br/&gt;
-import java.nio.ByteBuffer;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
 import java.util.Arrays;&lt;br/&gt;
 import java.util.Collection;&lt;br/&gt;
@@ -2347,14 +2346,21 @@ public DescribeConsumerGroupsResult describeConsumerGroups(final Collection&amp;lt;Stri&lt;/p&gt;

&lt;p&gt;                 @Override&lt;br/&gt;
                 void handleResponse(AbstractResponse abstractResponse) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final FindCoordinatorResponse response = (FindCoordinatorResponse) abstractResponse;&lt;br/&gt;
+                    final FindCoordinatorResponse fcResponse = (FindCoordinatorResponse) abstractResponse;&lt;br/&gt;
+                    Errors error = fcResponse.error();&lt;br/&gt;
+                    if (error == Errors.COORDINATOR_NOT_AVAILABLE) 
{
+                        // Retry COORDINATOR_NOT_AVAILABLE, in case the error is temporary.
+                        throw error.exception();
+                    }
&lt;p&gt; else if (error != Errors.NONE) &lt;/p&gt;
{
+                        // All other errors are immediate failures.
+                        KafkaFutureImpl&amp;lt;ConsumerGroupDescription&amp;gt; future = futures.get(groupId);
+                        future.completeExceptionally(error.exception());
+                        return;
+                    }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;                     final long nowDescribeConsumerGroups = time.milliseconds();&lt;br/&gt;
-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final int nodeId = response.node().id();&lt;br/&gt;
-&lt;br/&gt;
+                    final int nodeId = fcResponse.node().id();&lt;br/&gt;
                     runnable.call(new Call(&quot;describeConsumerGroups&quot;, deadline, new ConstantNodeIdProvider(nodeId)) {&lt;br/&gt;
-&lt;br/&gt;
                         @Override&lt;br/&gt;
                         AbstractRequest.Builder createRequest(int timeoutMs) {&lt;br/&gt;
                             return new DescribeGroupsRequest.Builder(Collections.singletonList(groupId));&lt;br/&gt;
@@ -2375,24 +2381,29 @@ void handleResponse(AbstractResponse abstractResponse) {&lt;br/&gt;
                                 final String protocolType = groupMetadata.protocolType();&lt;br/&gt;
                                 if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {&lt;br/&gt;
                                     final List&amp;lt;DescribeGroupsResponse.GroupMember&amp;gt; members = groupMetadata.members();&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;MemberDescription&amp;gt; consumers = new ArrayList&amp;lt;&amp;gt;(members.size());&lt;br/&gt;
+                                    final List&amp;lt;MemberDescription&amp;gt; memberDescriptions = new ArrayList&amp;lt;&amp;gt;(members.size());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;                                     for (DescribeGroupsResponse.GroupMember groupMember : members) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final PartitionAssignor.Assignment assignment =&lt;/li&gt;
	&lt;li&gt;ConsumerProtocol.deserializeAssignment(&lt;/li&gt;
	&lt;li&gt;ByteBuffer.wrap(Utils.readBytes(groupMember.memberAssignment())));&lt;br/&gt;
-&lt;br/&gt;
+                                        Set&amp;lt;TopicPartition&amp;gt; partitions = Collections.emptySet();&lt;br/&gt;
+                                        if (groupMember.memberAssignment().remaining() &amp;gt; 0) 
{
+                                            final PartitionAssignor.Assignment assignment = ConsumerProtocol.
+                                                deserializeAssignment(groupMember.memberAssignment().duplicate());
+                                            partitions = new HashSet&amp;lt;&amp;gt;(assignment.partitions());
+                                        }
&lt;p&gt;                                         final MemberDescription memberDescription =&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;new MemberDescription(&lt;/li&gt;
	&lt;li&gt;groupMember.memberId(),&lt;/li&gt;
	&lt;li&gt;groupMember.clientId(),&lt;/li&gt;
	&lt;li&gt;groupMember.clientHost(),&lt;/li&gt;
	&lt;li&gt;new MemberAssignment(assignment.partitions()));&lt;/li&gt;
	&lt;li&gt;consumers.add(memberDescription);&lt;br/&gt;
+                                            new MemberDescription(groupMember.memberId(),&lt;br/&gt;
+                                                groupMember.clientId(),&lt;br/&gt;
+                                                groupMember.clientHost(),&lt;br/&gt;
+                                                new MemberAssignment(partitions));&lt;br/&gt;
+                                        memberDescriptions.add(memberDescription);&lt;br/&gt;
                                     }&lt;/li&gt;
	&lt;li&gt;final String protocol = groupMetadata.protocol();&lt;br/&gt;
                                     final ConsumerGroupDescription consumerGroupDescription =&lt;/li&gt;
	&lt;li&gt;new ConsumerGroupDescription(groupId, protocolType.isEmpty(), consumers, protocol);&lt;br/&gt;
+                                            new ConsumerGroupDescription(groupId,&lt;br/&gt;
+                                                protocolType.isEmpty(),&lt;br/&gt;
+                                                memberDescriptions,&lt;br/&gt;
+                                                groupMetadata.protocol(),&lt;br/&gt;
+                                                ConsumerGroupState.parse(groupMetadata.state()),&lt;br/&gt;
+                                                fcResponse.node());&lt;br/&gt;
                                     future.complete(consumerGroupDescription);&lt;br/&gt;
                                 }&lt;br/&gt;
                             }&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/MemberAssignment.java b/clients/src/main/java/org/apache/kafka/clients/admin/MemberAssignment.java&lt;br/&gt;
index bd958132b7c..6c180ad574d 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/clients/src/main/java/org/apache/kafka/clients/admin/MemberAssignment.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/MemberAssignment.java&lt;br/&gt;
@@ -19,21 +19,24 @@&lt;br/&gt;
 import org.apache.kafka.common.TopicPartition;&lt;br/&gt;
 import org.apache.kafka.common.utils.Utils;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-import java.util.List;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.HashSet;&lt;br/&gt;
+import java.util.Set;&lt;/p&gt;

&lt;p&gt; /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A description of the assignments of a specific group member.&lt;br/&gt;
  */&lt;br/&gt;
 public class MemberAssignment {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final List&amp;lt;TopicPartition&amp;gt; topicPartitions;&lt;br/&gt;
+    private final Set&amp;lt;TopicPartition&amp;gt; topicPartitions;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Creates an instance with the specified parameters.&lt;br/&gt;
      *&lt;/li&gt;
	&lt;li&gt;@param topicPartitions List of topic partitions&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public MemberAssignment(List&amp;lt;TopicPartition&amp;gt; topicPartitions) {&lt;/li&gt;
	&lt;li&gt;this.topicPartitions = topicPartitions;&lt;br/&gt;
+    MemberAssignment(Set&amp;lt;TopicPartition&amp;gt; topicPartitions) 
{
+        this.topicPartitions = topicPartitions == null ? Collections.&amp;lt;TopicPartition&amp;gt;emptySet() :
+            Collections.unmodifiableSet(new HashSet&amp;lt;&amp;gt;(topicPartitions));
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;br/&gt;
@@ -54,7 +57,7 @@ public int hashCode() {&lt;br/&gt;
     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The topic partitions assigned to a group member.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public List&amp;lt;TopicPartition&amp;gt; topicPartitions() {&lt;br/&gt;
+    public Set&amp;lt;TopicPartition&amp;gt; topicPartitions() 
{
         return topicPartitions;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/clients/admin/MemberDescription.java b/clients/src/main/java/org/apache/kafka/clients/admin/MemberDescription.java&lt;br/&gt;
index 2ba19634208..895abadfdb8 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/clients/admin/MemberDescription.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/clients/admin/MemberDescription.java&lt;br/&gt;
@@ -17,49 +17,42 @@&lt;/p&gt;

&lt;p&gt; package org.apache.kafka.clients.admin;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.TopicPartition;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.Objects;&lt;br/&gt;
+&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;A detailed description of a single group instance in the cluster.&lt;br/&gt;
  */&lt;br/&gt;
 public class MemberDescription {&lt;br/&gt;
-&lt;br/&gt;
     private final String memberId;&lt;br/&gt;
     private final String clientId;&lt;br/&gt;
     private final String host;&lt;br/&gt;
     private final MemberAssignment assignment;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Creates an instance with the specified parameters.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param memberId The consumer id&lt;/li&gt;
	&lt;li&gt;* @param clientId   The client id&lt;/li&gt;
	&lt;li&gt;* @param host       The host&lt;/li&gt;
	&lt;li&gt;* @param assignment The assignment&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public MemberDescription(String memberId, String clientId, String host, MemberAssignment assignment) {&lt;/li&gt;
	&lt;li&gt;this.memberId = memberId;&lt;/li&gt;
	&lt;li&gt;this.clientId = clientId;&lt;/li&gt;
	&lt;li&gt;this.host = host;&lt;/li&gt;
	&lt;li&gt;this.assignment = assignment;&lt;br/&gt;
+    MemberDescription(String memberId, String clientId, String host, MemberAssignment assignment) 
{
+        this.memberId = memberId == null ? &quot;&quot; : memberId;
+        this.clientId = clientId == null ? &quot;&quot; : clientId;
+        this.host = host == null ? &quot;&quot; : host;
+        this.assignment = assignment == null ?
+            new MemberAssignment(Collections.&amp;lt;TopicPartition&amp;gt;emptySet()) : assignment;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;br/&gt;
     public boolean equals(Object o) &lt;/p&gt;
{
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-
         MemberDescription that = (MemberDescription) o;
-
-        if (memberId != null ? !memberId.equals(that.memberId) : that.memberId != null) return false;
-        if (clientId != null ? !clientId.equals(that.clientId) : that.clientId != null) return false;
-        return assignment != null ? assignment.equals(that.assignment) : that.assignment == null;
+        return memberId.equals(that.memberId) &amp;amp;&amp;amp;
+            clientId.equals(that.clientId) &amp;amp;&amp;amp;
+            host.equals(that.host) &amp;amp;&amp;amp;
+            assignment.equals(that.assignment);
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public int hashCode() &lt;/p&gt;
{
-        int result = memberId != null ? memberId.hashCode() : 0;
-        result = 31 * result + (clientId != null ? clientId.hashCode() : 0);
-        result = 31 * result + (assignment != null ? assignment.hashCode() : 0);
-        return result;
+        return Objects.hash(memberId, clientId, host, assignment);
     }

&lt;p&gt;     /**&lt;br/&gt;
@@ -92,7 +85,9 @@ public MemberAssignment assignment() {&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     public String toString() &lt;/p&gt;
{
-        return &quot;(memberId=&quot; + memberId + &quot;, clientId=&quot; + clientId + &quot;, host=&quot; + host + &quot;, assignment=&quot; +
-            assignment + &quot;)&quot;;
+        return &quot;(memberId=&quot; + memberId +
+            &quot;, clientId=&quot; + clientId +
+            &quot;, host=&quot; + host +
+            &quot;, assignment=&quot; + assignment + &quot;)&quot;;
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/ConsumerGroupState.java b/clients/src/main/java/org/apache/kafka/common/ConsumerGroupState.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..7f3d4f0883b&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/ConsumerGroupState.java&lt;br/&gt;
@@ -0,0 +1,61 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.kafka.common;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * The consumer group state.&lt;br/&gt;
+ */&lt;br/&gt;
+public enum ConsumerGroupState {&lt;br/&gt;
+    UNKNOWN(&quot;Unknown&quot;),&lt;br/&gt;
+    PREPARING_REBALANCE(&quot;PreparingRebalance&quot;),&lt;br/&gt;
+    COMPLETING_REBALANCE(&quot;CompletingRebalance&quot;),&lt;br/&gt;
+    STABLE(&quot;Stable&quot;),&lt;br/&gt;
+    DEAD(&quot;Dead&quot;),&lt;br/&gt;
+    EMPTY(&quot;Empty&quot;);&lt;br/&gt;
+&lt;br/&gt;
+    private final static HashMap&amp;lt;String, ConsumerGroupState&amp;gt; NAME_TO_ENUM;&lt;br/&gt;
+&lt;br/&gt;
+    static {&lt;br/&gt;
+        NAME_TO_ENUM = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+        for (ConsumerGroupState state : ConsumerGroupState.values()) &lt;/p&gt;
{
+            NAME_TO_ENUM.put(state.name, state);
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    private final String name;&lt;br/&gt;
+&lt;br/&gt;
+    ConsumerGroupState(String name) &lt;/p&gt;
{
+        this.name = name;
+    }
&lt;p&gt;+&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Parse a string into a consumer group state.&lt;br/&gt;
+     */&lt;br/&gt;
+    public static ConsumerGroupState parse(String name) &lt;/p&gt;
{
+        ConsumerGroupState state = NAME_TO_ENUM.get(name);
+        return state == null ? UNKNOWN : state;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public String toString() &lt;/p&gt;
{
+        return name;
+    }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/errors/GroupIdNotFoundException.java b/clients/src/main/java/org/apache/kafka/common/errors/GroupIdNotFoundException.java&lt;br/&gt;
index 1ff30f14fc0..a4d509d3a20 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/errors/GroupIdNotFoundException.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/errors/GroupIdNotFoundException.java&lt;br/&gt;
@@ -17,15 +17,7 @@&lt;br/&gt;
 package org.apache.kafka.common.errors;&lt;/p&gt;

&lt;p&gt; public class GroupIdNotFoundException extends ApiException {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final String groupId;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public GroupIdNotFoundException(String groupId) 
{
-        super(&quot;The group id &quot; + groupId + &quot; was not found&quot;);
-        this.groupId = groupId;
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public String groupId() {&lt;/li&gt;
	&lt;li&gt;return groupId;&lt;br/&gt;
+    public GroupIdNotFoundException(String message) 
{
+        super(message);
     }&lt;br/&gt;
-&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/errors/GroupNotEmptyException.java b/clients/src/main/java/org/apache/kafka/common/errors/GroupNotEmptyException.java&lt;br/&gt;
index 264e613719c..e15b3e6d57f 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/errors/GroupNotEmptyException.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/errors/GroupNotEmptyException.java&lt;br/&gt;
@@ -17,15 +17,7 @@&lt;br/&gt;
 package org.apache.kafka.common.errors;&lt;br/&gt;
 &lt;br/&gt;
 public class GroupNotEmptyException extends ApiException {&lt;br/&gt;
-    private final String groupId;&lt;br/&gt;
-&lt;br/&gt;
-    public GroupNotEmptyException(String groupId) {
-        super(&quot;The group &quot; + groupId + &quot; is not empty&quot;);
-        this.groupId = groupId;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    public String groupId() {&lt;br/&gt;
-        return groupId;&lt;br/&gt;
+    public GroupNotEmptyException(String message) {+        super(message);     }
&lt;p&gt;-&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/core/src/main/scala/kafka/tools/StreamsResetter.java b/core/src/main/scala/kafka/tools/StreamsResetter.java&lt;br/&gt;
index d7c4e435e58..3c045c69eb2 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/main/scala/kafka/tools/StreamsResetter.java&lt;br/&gt;
+++ b/core/src/main/scala/kafka/tools/StreamsResetter.java&lt;br/&gt;
@@ -157,7 +157,8 @@ private void validateNoActiveConsumers(final String groupId,&lt;br/&gt;
                                            final AdminClient adminClient) throws ExecutionException, InterruptedException {&lt;br/&gt;
         final DescribeConsumerGroupsResult describeResult = adminClient.describeConsumerGroups(Arrays.asList(groupId),&lt;br/&gt;
                 (new DescribeConsumerGroupsOptions()).timeoutMs(10 * 1000));&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;MemberDescription&amp;gt; members = describeResult.describedGroups().get(groupId).get().members();&lt;br/&gt;
+        final List&amp;lt;MemberDescription&amp;gt; members =&lt;br/&gt;
+            new ArrayList&amp;lt;MemberDescription&amp;gt;(describeResult.describedGroups().get(groupId).get().members());&lt;br/&gt;
         if (!members.isEmpty()) {&lt;br/&gt;
             throw new IllegalStateException(&quot;Consumer group &apos;&quot; + groupId + &quot;&apos; is still active &quot;&lt;br/&gt;
                     + &quot;and has following members: &quot; + members + &quot;. &quot;&lt;br/&gt;
diff --git a/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala b/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala&lt;br/&gt;
index b31c09d78d3..e7dd1084040 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/integration/kafka/api/AdminClientIntegrationTest.scala&lt;br/&gt;
@@ -31,10 +31,10 @@ import org.apache.kafka.clients.admin._&lt;br/&gt;
 import kafka.utils.
{Logging, TestUtils}
&lt;p&gt; import kafka.utils.Implicits._&lt;br/&gt;
 import org.apache.kafka.clients.admin.NewTopic&lt;br/&gt;
-import org.apache.kafka.clients.consumer.KafkaConsumer&lt;br/&gt;
+import org.apache.kafka.clients.consumer.&lt;/p&gt;
{ConsumerConfig, KafkaConsumer}
&lt;p&gt; import org.apache.kafka.clients.producer.KafkaProducer&lt;br/&gt;
 import org.apache.kafka.clients.producer.ProducerRecord&lt;br/&gt;
-import org.apache.kafka.common.&lt;/p&gt;
{KafkaFuture, TopicPartition, TopicPartitionReplica}
&lt;p&gt;+import org.apache.kafka.common.&lt;/p&gt;
{ConsumerGroupState, KafkaFuture, TopicPartition, TopicPartitionReplica}
&lt;p&gt; import org.apache.kafka.common.acl._&lt;br/&gt;
 import org.apache.kafka.common.config.ConfigResource&lt;br/&gt;
 import org.apache.kafka.common.errors._&lt;br/&gt;
@@ -49,6 +49,7 @@ import scala.collection.JavaConverters._&lt;br/&gt;
 import java.lang.&lt;/p&gt;
{Long =&amp;gt; JLong}&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import kafka.zk.KafkaZkClient&lt;br/&gt;
+import org.apache.kafka.common.internals.Topic&lt;br/&gt;
 import org.scalatest.Assertions.intercept&lt;/p&gt;

&lt;p&gt; import scala.concurrent.duration.Duration&lt;br/&gt;
@@ -98,6 +99,7 @@ class AdminClientIntegrationTest extends IntegrationTestHarness with Logging {&lt;br/&gt;
       config.setProperty(KafkaConfig.InterBrokerListenerNameProp, listenerName.value)&lt;br/&gt;
       config.setProperty(KafkaConfig.ListenerSecurityProtocolMapProp, s&quot;${listenerName.value}:${securityProtocol.name}&quot;)&lt;br/&gt;
       config.setProperty(KafkaConfig.DeleteTopicEnableProp, &quot;true&quot;)&lt;br/&gt;
+      config.setProperty(KafkaConfig.GroupInitialRebalanceDelayMsProp, &quot;0&quot;)&lt;br/&gt;
       // We set this in order to test that we don&apos;t expose sensitive data via describe configs. This will already be&lt;br/&gt;
       // set for subclasses with security enabled and we don&apos;t want to overwrite it.&lt;br/&gt;
       if (!config.containsKey(KafkaConfig.SslTruststorePasswordProp))&lt;br/&gt;
@@ -959,6 +961,120 @@ class AdminClientIntegrationTest extends IntegrationTestHarness with Logging &lt;/p&gt;
{
     client.close()
     assertEquals(1, factory.failuresInjected)
   }
&lt;p&gt;+&lt;br/&gt;
+  /**&lt;br/&gt;
+    * Test the consumer group APIs.&lt;br/&gt;
+    */&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testConsumerGroups(): Unit = {&lt;br/&gt;
+    val config = createConfig()&lt;br/&gt;
+    val client = AdminClient.create(config)&lt;br/&gt;
+    try {&lt;br/&gt;
+      // Verify that initially there are no consumer groups to list.&lt;br/&gt;
+      val list1 = client.listConsumerGroups()&lt;br/&gt;
+      assertTrue(0 == list1.all().get().size())&lt;br/&gt;
+      assertTrue(0 == list1.errors().get().size())&lt;br/&gt;
+      assertTrue(0 == list1.valid().get().size())&lt;br/&gt;
+      val testTopicName = &quot;test_topic&quot;&lt;br/&gt;
+      val testNumPartitions = 2&lt;br/&gt;
+      client.createTopics(Collections.singleton(&lt;br/&gt;
+        new NewTopic(testTopicName, testNumPartitions, 1))).all().get()&lt;br/&gt;
+      val producer = createNewProducer&lt;br/&gt;
+      try &lt;/p&gt;
{
+        producer.send(new ProducerRecord(testTopicName, 0, null, null)).get()
+      }
&lt;p&gt; finally &lt;/p&gt;
{
+        Utils.closeQuietly(producer, &quot;producer&quot;)
+      }
&lt;p&gt;+      val testGroupId = &quot;test_group_id&quot;&lt;br/&gt;
+      val testClientId = &quot;test_client_id&quot;&lt;br/&gt;
+      val fakeGroupId = &quot;fake_group_id&quot;&lt;br/&gt;
+      val newConsumerConfig = new Properties(consumerConfig)&lt;br/&gt;
+      newConsumerConfig.setProperty(ConsumerConfig.GROUP_ID_CONFIG, testGroupId)&lt;br/&gt;
+      newConsumerConfig.setProperty(ConsumerConfig.CLIENT_ID_CONFIG, testClientId)&lt;br/&gt;
+      val consumer = TestUtils.createNewConsumer(brokerList,&lt;br/&gt;
+        securityProtocol = this.securityProtocol,&lt;br/&gt;
+        trustStoreFile = this.trustStoreFile,&lt;br/&gt;
+        saslProperties = this.clientSaslProperties,&lt;br/&gt;
+        props = Some(newConsumerConfig))&lt;br/&gt;
+      try {&lt;br/&gt;
+        // Start a consumer in a thread that will subscribe to a new group.&lt;br/&gt;
+        val consumerThread = new Thread {&lt;br/&gt;
+          override def run {&lt;br/&gt;
+            consumer.subscribe(Collections.singleton(testTopicName))&lt;br/&gt;
+            while (true) &lt;/p&gt;
{
+              consumer.poll(5000)
+              consumer.commitSync()
+            }
&lt;p&gt;+          }&lt;br/&gt;
+        }&lt;br/&gt;
+        try {&lt;br/&gt;
+          consumerThread.start&lt;br/&gt;
+          // Test that we can list the new group.&lt;br/&gt;
+          TestUtils.waitUntilTrue(() =&amp;gt; &lt;/p&gt;
{
+            val matching = client.listConsumerGroups().all().get().asScala.
+              filter(listing =&amp;gt; listing.groupId().equals(testGroupId))
+            !matching.isEmpty
+          }
&lt;p&gt;, s&quot;Expected to be able to list $testGroupId&quot;)&lt;br/&gt;
+&lt;br/&gt;
+          val result = client.describeConsumerGroups(Seq(testGroupId, fakeGroupId).asJava)&lt;br/&gt;
+          assertEquals(2, result.describedGroups().size())&lt;br/&gt;
+&lt;br/&gt;
+          // Test that we can get information about the test consumer group.&lt;br/&gt;
+          assertTrue(result.describedGroups().containsKey(testGroupId))&lt;br/&gt;
+          val testGroupDescription = result.describedGroups().get(testGroupId).get()&lt;br/&gt;
+          assertEquals(testGroupId, testGroupDescription.groupId())&lt;br/&gt;
+          assertFalse(testGroupDescription.isSimpleConsumerGroup())&lt;br/&gt;
+          assertEquals(1, testGroupDescription.members().size())&lt;br/&gt;
+          val member = testGroupDescription.members().iterator().next()&lt;br/&gt;
+          assertEquals(testClientId, member.clientId())&lt;br/&gt;
+          val topicPartitions = member.assignment().topicPartitions()&lt;br/&gt;
+          assertEquals(testNumPartitions, topicPartitions.size())&lt;br/&gt;
+          assertEquals(testNumPartitions, topicPartitions.asScala.&lt;br/&gt;
+            count(tp =&amp;gt; tp.topic().equals(testTopicName)))&lt;br/&gt;
+&lt;br/&gt;
+          // Test that the fake group is listed as dead.&lt;br/&gt;
+          assertTrue(result.describedGroups().containsKey(fakeGroupId))&lt;br/&gt;
+          val fakeGroupDescription = result.describedGroups().get(fakeGroupId).get()&lt;br/&gt;
+          assertEquals(fakeGroupId, fakeGroupDescription.groupId())&lt;br/&gt;
+          assertEquals(0, fakeGroupDescription.members().size())&lt;br/&gt;
+          assertEquals(&quot;&quot;, fakeGroupDescription.partitionAssignor())&lt;br/&gt;
+          assertEquals(ConsumerGroupState.DEAD, fakeGroupDescription.state())&lt;br/&gt;
+&lt;br/&gt;
+          // Test that all() returns 2 results&lt;br/&gt;
+          assertEquals(2, result.all().get().size())&lt;br/&gt;
+&lt;br/&gt;
+          // Test listConsumerGroupOffsets&lt;br/&gt;
+          val parts = client.listConsumerGroupOffsets(testGroupId).partitionsToOffsetAndMetadata().get()&lt;br/&gt;
+          TestUtils.waitUntilTrue(() =&amp;gt; &lt;/p&gt;
{
+            val parts = client.listConsumerGroupOffsets(testGroupId).partitionsToOffsetAndMetadata().get()
+            val part = new TopicPartition(testTopicName, 0)
+            parts.containsKey(part) &amp;amp;&amp;amp; (parts.get(part).offset() == 1)
+          }
&lt;p&gt;, s&quot;Expected the offset for partition 0 to eventually become 1.&quot;)&lt;br/&gt;
+&lt;br/&gt;
+          // Test consumer group deletion&lt;br/&gt;
+          val deleteResult = client.deleteConsumerGroups(Seq(testGroupId, fakeGroupId).asJava)&lt;br/&gt;
+          assertEquals(2, deleteResult.deletedGroups().size())&lt;br/&gt;
+&lt;br/&gt;
+          // Deleting the fake group ID should get GroupIdNotFoundException.&lt;br/&gt;
+          assertTrue(deleteResult.deletedGroups().containsKey(fakeGroupId))&lt;br/&gt;
+          assertFutureExceptionTypeEquals(deleteResult.deletedGroups().get(fakeGroupId),&lt;br/&gt;
+            classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;GroupIdNotFoundException&amp;#93;&lt;/span&gt;)&lt;br/&gt;
+&lt;br/&gt;
+          // Deleting the real group ID should get GroupNotEmptyException&lt;br/&gt;
+          assertTrue(deleteResult.deletedGroups().containsKey(testGroupId))&lt;br/&gt;
+          assertFutureExceptionTypeEquals(deleteResult.deletedGroups().get(testGroupId),&lt;br/&gt;
+            classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;GroupNotEmptyException&amp;#93;&lt;/span&gt;)&lt;br/&gt;
+        } finally &lt;/p&gt;
{
+          consumerThread.interrupt()
+          consumerThread.join()
+        }
&lt;p&gt;+      } finally &lt;/p&gt;
{
+        Utils.closeQuietly(consumer, &quot;consumer&quot;)
+      }
&lt;p&gt;+    } finally &lt;/p&gt;
{
+      Utils.closeQuietly(client, &quot;adminClient&quot;)
+    }
&lt;p&gt;+  }&lt;br/&gt;
 }&lt;/p&gt;

&lt;p&gt; object AdminClientIntegrationTest {&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16565753" author="sriharsha" created="Wed, 1 Aug 2018 18:13:57 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hachikuji&quot; class=&quot;user-hover&quot; rel=&quot;hachikuji&quot;&gt;hachikuji&lt;/a&gt; can we include this into 1.1 branch. This is a critical fix affecting the clients from 0.10 onwards to query group offset info. If we are planning on doing a future 1.1.x release we should include this Jira as well.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 15 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3tdbj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>