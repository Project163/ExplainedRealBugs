<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:29:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-13425] KafkaConsumer#pause() will lose its effect after groupRebalance occurs, which maybe cause data loss on the consumer side</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-13425</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;&#160;&lt;br/&gt;
 &#160;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&quot;Foreword%3A&quot;&gt;&lt;/a&gt;Foreword:&lt;/h1&gt;

&lt;p&gt;Since I want to achieve the decoupling of the two processes of polling messages and consuming messages on the KafkaConsumer side, I use the &quot;poll --&amp;gt; push&quot; architecture model on the Kafka consumer side.&lt;/p&gt;

&lt;p&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a name=&quot;Architecture&quot;&gt;&lt;/a&gt;Architecture&lt;/h2&gt;

&lt;p&gt;&#160;see picture &quot;architecture_picture&quot;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;1%EF%BC%89ThreadPoolExecutor&quot;&gt;&lt;/a&gt;1&#65289;ThreadPoolExecutor&lt;/h3&gt;

&lt;p&gt;The key parameters of ThreadPoolExecutor threadPool are:&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;%281%29SelectArrayBlockingQueue%3CRunnable%3EforworkQueuetype&quot;&gt;&lt;/a&gt;(1) Select ArrayBlockingQueue&amp;lt;Runnable&amp;gt; for workQueue type&lt;/h4&gt;
&lt;h4&gt;&lt;a name=&quot;%282%29ThehandlerusestheRejectedExecutionHandlerinterface&quot;&gt;&lt;/a&gt;(2) The handler uses the RejectedExecutionHandler interface&lt;/h4&gt;
&lt;h4&gt;&lt;a name=&quot;%283%29threadPool.allowCoreThreadTimeOut%28true%29%3B&quot;&gt;&lt;/a&gt;(3)threadPool.allowCoreThreadTimeOut(true);&lt;/h4&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;2%29KafkaConsumer&quot;&gt;&lt;/a&gt;2) KafkaConsumer&lt;/h3&gt;

&lt;p&gt;The disadvantage of this architecture is that if the business side&#8217;s onMessage() method is time-consuming to execute, it will lead to&#65306;&lt;/p&gt;
&lt;h4&gt;&lt;a name=&quot;%EF%BC%881%EF%BC%89TheblockingQueueofThreadPoolExecutorwillaccumulatealargenumberofTasks%2Candeventuallythepushmessagewillfail.&quot;&gt;&lt;/a&gt;&#65288;1&#65289;The blockingQueue of ThreadPoolExecutor will accumulate a large number of Tasks, and eventually the push message will fail.&lt;/h4&gt;
&lt;h4&gt;&lt;a name=&quot;%EF%BC%882%EF%BC%89HowtodealwiththeKafkaConsumerpoll%28%29methodwhenthepushfails%EF%BC%9A&quot;&gt;&lt;/a&gt;&#65288;2&#65289;How to deal with the KafkaConsumer poll() method when the push fails&#65306;&lt;/h4&gt;
&lt;h5&gt;&lt;a name=&quot;1.stopcallpoll%28%29&quot;&gt;&lt;/a&gt;1. stop call poll()&lt;/h5&gt;

&lt;p&gt;KafkaConsumer needs to set &lt;b&gt;configs.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, Integer.MAX_VALUE);&lt;/b&gt; In order to prevent the heartbeat thread of KafkaConumser from discovering that KafkaConsumer does not call the poll() method for a long time, and automatically execute &lt;b&gt;maybeLeaveGroup(&quot;consumer poll timeout has expired.&quot;)&lt;/b&gt;;&lt;/p&gt;

&lt;p&gt;But the most serious consequence of this is that once the rebalance of the group is triggered for some reason, &lt;b&gt;the rebalance process of the entire group will not be completed because the kafkaConsumer does not call the poll() method. This will cause all consumers under the entire group to stop consumption.&lt;/b&gt;&lt;/p&gt;
&lt;h5&gt;&lt;a name=&quot;2.Whenthepushmessagefails%2Ccontinuetomaintainthepollmethod&quot;&gt;&lt;/a&gt;2. When the push message fails, continue to maintain the poll method&lt;/h5&gt;

&lt;p&gt;The purpose is to maintain the poll method call of kafkaConsumer, but at this time KafkaConsumer should not poll any messages, because the downstream BlockingQueue for storing messages is full. So at this time we need the help of KafkaConsumer#pause(...) and KafkaConsumer#resume(...). And I named this special poll method maintainPoll4Rebalance().&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&quot;maintainPoll4RebalancePreliminarydesignideas%3A&quot;&gt;&lt;/a&gt;maintainPoll4Rebalance Preliminary design ideas:&lt;/h1&gt;

&lt;p&gt;code Simple design&#65306;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {
        &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;) {
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; messages = kafkaConsumer.poll(Duration.ofSeconds(1));

                &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (!publish(message)) {
                    &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                        maintainPoll4Rebalance();
                    } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                        log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;maintain poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance with error {}&quot;&lt;/span&gt;, e.getMessage(), e);
                        CommonUtil.sleep(TimeUnit.SECONDS, 1);
                    }
                }

            } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;KafkaConsumer poll message has error: {}&quot;&lt;/span&gt;, e.getMessage(), e);
                CommonUtil.sleep(TimeUnit.MILLISECONDS, ClientConfig.CLIENT_SLEEP_INTERVAL_MS);
            }
        }
    }

    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; publish(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; message) {

        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {

            ...

            threadPool.execute(() -&amp;gt; onMessage(message));

        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (RejectedExecutionException e) {
            log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;consumer execute failed with error{}&quot;&lt;/span&gt;, e.getMessage(), e);
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
            log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;consumer execute failed with error{}&quot;&lt;/span&gt;, e.getMessage(), e);
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        }
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void maintainPoll4Rebalance() {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            kafkaConsumer.pause(kafkaConsumer.assignment());
            ConsumerRecords&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; records = kafkaConsumer.poll(Duration.ofSeconds(1));
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!records.isEmpty()) {
                log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;kafka poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance discard some record!&quot;&lt;/span&gt;);
                &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; consumerRecord : records) {
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (consumerRecord != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                        log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; record need to retry, partition {} ,offset {}&quot;&lt;/span&gt;, consumerRecord.partition(), consumerRecord.offset());
                    }
                }
            }
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
            log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;maintain poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance with error:{}&quot;&lt;/span&gt;, e.getMessage(), e);
        } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
            kafkaConsumer.resume(kafkaConsumer.assignment());
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The above code maintainPoll4Rebalance() seems to be a good solution to my problem. When downstream consumption is blocked, KafkaConsumer can maintain the continuous call of the poll method, and it avoids that KafkaConsumer can continue to pull messages when the push fails.&lt;/p&gt;

&lt;p&gt;But in reality, logs will appear during operation:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
[main] ERROR ConsumerTest3 - kafka poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance discard some record!
[main] ERROR ConsumerTest3 - &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; record need to retry, partition 0 ,offset 36901
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;I obviously have called kafkaConsumer.pause(kafkaConsumer.assignment()) before kafkaConsumer#poll is called. Why does kafkaConsumer still pull the message and cause the message to be lost? The reason for the loss is that the consumer turned on the auto-commit offset.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&quot;RootCauseAnalysis&quot;&gt;&lt;/a&gt;RootCause Analysis&lt;/h1&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;KafkaConsumer#poll&#65306;&lt;br/&gt;
 1) updateAssignmentMetadataIfNeeded&lt;br/&gt;
 2) fetcher.fetchedRecords()&lt;br/&gt;
 3) fetcher.sendFetches();&lt;/p&gt;

&lt;p&gt;These three methods are the three most critical operations in KafkaConsumer#poll. updateAssignmentMetadataIfNeeded is mainly responsible for group rebalance related work. And RC appears in the first and second steps.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h2&gt;&lt;a name=&quot;1.updateAssignmentMetadataIfNeeded&quot;&gt;&lt;/a&gt;1.updateAssignmentMetadataIfNeeded&lt;/h2&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;We trace directly to ConsumerCoordinator#onJoinPrepare(...)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;code-keyword&quot;&gt;switch&lt;/span&gt; (protocol) {
                &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; EAGER:
                    &lt;span class=&quot;code-comment&quot;&gt;// revoke all partitions
&lt;/span&gt;                    revokedPartitions = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(subscriptions.assignedPartitions());
                    exception = invokePartitionsRevoked(revokedPartitions);

                    subscriptions.assignFromSubscribed(Collections.emptySet());

                    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;

                &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; COOPERATIVE:
                    &lt;span class=&quot;code-comment&quot;&gt;// only revoke those partitions that are not in the subscription any more.
&lt;/span&gt;                    Set&amp;lt;TopicPartition&amp;gt; ownedPartitions = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(subscriptions.assignedPartitions());
                    revokedPartitions = ownedPartitions.stream()
                        .filter(tp -&amp;gt; !subscriptions.subscription().contains(tp.topic()))
                        .collect(Collectors.toSet());

                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!revokedPartitions.isEmpty()) {
                        exception = invokePartitionsRevoked(revokedPartitions);

                        ownedPartitions.removeAll(revokedPartitions);
                        subscriptions.assignFromSubscribed(ownedPartitions);
                    }

                    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
            }
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The value of the protocol instance variable here, see its initialization code&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-comment&quot;&gt;// select the rebalance protocol such that:
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//   1. only consider protocols that are supported by all the assignors. If there is no common protocols supported
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//      across all the assignors, &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; an exception.
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//   2. &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; there are multiple protocols that are commonly supported, select the one with the highest id (i.e. the
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//      id number indicates how advanced the protocol is).
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// we know there are at least one assignor in the list, no need to &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; check &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; NPE
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!assignors.isEmpty()) {
            List&amp;lt;RebalanceProtocol&amp;gt; supportedProtocols = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(assignors.get(0).supportedProtocols());

            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (ConsumerPartitionAssignor assignor : assignors) {
                supportedProtocols.retainAll(assignor.supportedProtocols());
            }

            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (supportedProtocols.isEmpty()) {
                &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Specified assignors &quot;&lt;/span&gt; +
                    assignors.stream().map(ConsumerPartitionAssignor::name).collect(Collectors.toSet()) +
                    &lt;span class=&quot;code-quote&quot;&gt;&quot; &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; not have commonly supported rebalance protocol&quot;&lt;/span&gt;);
            }

            Collections.sort(supportedProtocols);

            protocol = supportedProtocols.get(supportedProtocols.size() - 1);
        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
            protocol = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;After a simple analysis, we can understand that as long as supportedProtocols contains the RebalanceProtocol.COOPERATIVE element, the protocol value will be COOPERATIVE, otherwise it will be EAGER.&lt;/p&gt;

&lt;p&gt;But to check the ConsumerPartitionAssignor interface, I found that all its implementation classes except CooperativeStickyAssignor, all other PartitionAssignor implementation classes have adopted default values&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Indicate which rebalance protocol &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; assignor works with; By &lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; it should always work with ConsumerPartitionAssignor.RebalanceProtocol.EAGER.
&lt;span class=&quot;code-keyword&quot;&gt;default&lt;/span&gt; List&amp;lt;RebalanceProtocol&amp;gt; supportedProtocols() {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; Collections.singletonList(RebalanceProtocol.EAGER);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;So the code will run to&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
                &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; EAGER:
                    &lt;span class=&quot;code-comment&quot;&gt;// revoke all partitions
&lt;/span&gt;                    revokedPartitions = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(subscriptions.assignedPartitions());
                    exception = invokePartitionsRevoked(revokedPartitions);

                    subscriptions.assignFromSubscribed(Collections.emptySet());

                    &lt;span class=&quot;code-keyword&quot;&gt;break&lt;/span&gt;;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The problem is here, &lt;b&gt;subscriptions.assignFromSubscribed(Collections.emptySet()) will clear the assignment in my subscriptions, and then &lt;font color=&quot;#ff0000&quot;&gt;clear the paused mark for TopicPartition.&lt;/font&gt;&lt;/b&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a name=&quot;2.fetcher.fetchedRecords%28%29&quot;&gt;&lt;/a&gt;2.fetcher.fetchedRecords()&lt;/h2&gt;

&lt;p&gt;There is no need to go into the code here, fetchedRecords will verify the corresponding TopicPartition of each message set CompletedFetch in memory&lt;/p&gt;
&lt;h3&gt;&lt;a name=&quot;1%EF%BC%89if%28subscriptions.isPaused%28nextInLineFetch.partition%29%29&quot;&gt;&lt;/a&gt;1&#65289;if (subscriptions.isPaused(nextInLineFetch.partition))&lt;/h3&gt;
&lt;h3&gt;&lt;a name=&quot;2%EF%BC%89if%28%21subscriptions.isAssigned%28completedFetch.partition%29%29&quot;&gt;&lt;/a&gt;2&#65289;if (!subscriptions.isAssigned(completedFetch.partition))&lt;/h3&gt;
&lt;h3&gt;&lt;a name=&quot;3%EF%BC%89if%28%21subscriptions.isFetchable%28completedFetch.partition%29%29&quot;&gt;&lt;/a&gt;3&#65289;if (!subscriptions.isFetchable(completedFetch.partition))&lt;/h3&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The problem is: If within the pollTimer specified by the user, a poll(...) call completes the updateAssignmentMetadataIfNeeded operation, the updateAssignmentMetadataIfNeeded method returns true, and the paused flag for TopicPartition has also been cleared in updateAssignmentMetadataIfNeeded, and the new assignments of kafkaConsumer still hold this TopicPartition after the rebalance is completed. Then the verification of TopicPartition mentioned above will pass.&lt;/p&gt;

&lt;p&gt;And the &lt;b&gt;&lt;font color=&quot;#ff0000&quot;&gt;nextInLineFetch variable in KafkaConsumer memory stores TopicPartition messages,&lt;/font&gt; the KafkaConsumer#poll(...) method will still return the message after calling pause(...). Even if you always call pause(...) before each poll(...), it will Return the message corresponding to TopicPartition.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;If the business side cannot process the message at this time, and the KafkaConsumer turns on the automatic submission offset switch, the message will be lost on the consumer side. The maximum number of lost messages max.poll.records.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            kafkaConsumer.pause(kafkaConsumer.assignment());
            ConsumerRecords&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; records = kafkaConsumer.poll(Duration.ofSeconds(5));
            
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
            log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;maintain poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance with error:{}&quot;&lt;/span&gt;, e.getMessage(), e);
        } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
            kafkaConsumer.resume(kafkaConsumer.assignment());
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h1&gt;&lt;a name=&quot;maintainPoll4Rebalance%28%29Temporarysolution&quot;&gt;&lt;/a&gt;maintainPoll4Rebalance() Temporary solution&lt;/h1&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The paused mark of TopicPartition is remedied in ConsumerRebalanceListener#onPartitionsAssigned(...)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; maintainPoll4Rebalance;
   
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void initKafkaConsumer() {

        kafkaConsumer.subscribe(topics, () -&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ConsumerRebalanceListener() {

            @Override
            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void onPartitionsRevoked(Collection&amp;lt;TopicPartition&amp;gt; partitions) {
                confirmMessageSync();
                log.info(&lt;span class=&quot;code-quote&quot;&gt;&quot;consumer on  partition revoked!&quot;&lt;/span&gt;);
            }

            @Override
            &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void onPartitionsAssigned(Collection&amp;lt;TopicPartition&amp;gt; partitions) {

                &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (maintainPoll4Rebalance) {
                        kafkaConsumer.pause(kafkaConsumer.assignment());
                    }
                } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                    log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;consumer onPartitionsAssigned failed with error:{}!&quot;&lt;/span&gt;, e.getMessage(), e);
                }
                log.info(&lt;span class=&quot;code-quote&quot;&gt;&quot;consumer on  partition assigned!&quot;&lt;/span&gt;);
            }
        });
    }
    
    
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void maintainPoll4Rebalance() {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            maintainPoll4Rebalance = &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
            kafkaConsumer.pause(kafkaConsumer.assignment());
            ConsumerRecords&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; records = kafkaConsumer.poll(Duration.ofSeconds(1));
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!records.isEmpty()) {
                log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;kafka poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance discard some record!&quot;&lt;/span&gt;);
                &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; consumerRecord : records) {
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (consumerRecord != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                        log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; record need to retry, partition {} ,offset {}&quot;&lt;/span&gt;, consumerRecord.partition(), consumerRecord.offset());
                    }
                }
            }
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
            log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;maintain poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance with error:{}&quot;&lt;/span&gt;, e.getMessage(), e);
        } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
            maintainPoll4Rebalance = &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
            kafkaConsumer.resume(kafkaConsumer.assignment());
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;After testing, this problem can be temporarily solved. After calling kafkaConsumer#pause(...), kafkaConsumer.poll(...) will definitely not return the corresponding TopicPartition message.&lt;/p&gt;
&lt;h1&gt;&lt;a name=&quot;Suggestions&quot;&gt;&lt;/a&gt;Suggestions&lt;/h1&gt;

&lt;p&gt;&lt;tt&gt;1. Precise semantics of kafkaConsumer#pause(&#8230;)&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;First look at the comments on this method&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Suspend fetching from the requested partitions. Future calls to poll(Duration) will not &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; any records from these partitions until they have been resumed using resume(Collection). Note that &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; method does not affect partition subscription. In particular, it does not cause a group rebalance when automatic assignment is used.
Params:
partitions &#8211; The partitions which should be paused
Throws:
IllegalStateException &#8211; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; any of the provided partitions are not currently assigned to &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; consumer
@Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void pause(Collection&amp;lt;TopicPartition&amp;gt; partitions) {
        acquireAndEnsureOpen();
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Pausing partitions {}&quot;&lt;/span&gt;, partitions);
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (TopicPartition partition: partitions) {
                subscriptions.pause(partition);
            }
        } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
            release();
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;We don&#8217;t know from the comments that &lt;font color=&quot;#ff0000&quot;&gt;the pause method will lose its function after a groupRebalance.&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;And When cleaning the paused mark of topicPartitions, kafkaConsumer did not output any logs, and the customer could not perceive that the pause(...) method no longer works.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;2. When we execute invokePartitionsRevoked(revokedPartitions), do we consider the need to clean up the messages in KafkaConsumer memory corresponding to revokedPartitions?&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;If cleaned up, the cost is: After resume(...) , kafkaConsumer needs to re-initiate FetchRequests for resumedPartitions, which brings additional network transmission&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;tt&gt;3.We better support the pause(...) method on the KafkaConsumer side that is not affected by groupRebalance&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;1) When rebalance starts to prepare, add new logic to ConsumerCoordinator#onJoinPrepare(...)&lt;/p&gt;

&lt;p&gt;Before executing invokePartitionsRevoked(...) and subscriptions.assignFromSubscribed(...), filter out customerPausedPartitions from the subscriptions.assignment of the current KafkaConsumer, and customerPausedPartitions should be instance variables of ConsumerCoordinator.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
customerPausedPartitions = subscriptions.pausedPartitions();
&lt;span class=&quot;code-comment&quot;&gt;//Add &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; code in front of the following two codes
&lt;/span&gt;
exception = invokePartitionsRevoked(...);
subscriptions.assignFromSubscribed(...);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;2) After the rebalance is completed, add new logic to ConsumerCoordinator#onJoinComplete(...)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; void onJoinComplete(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; generation,
                                  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; memberId,
                                  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; assignmentStrategy,
                                  ByteBuffer assignmentBuffer) {
        log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Executing onJoinComplete with generation {} and memberId {}&quot;&lt;/span&gt;, generation, memberId);

        ......

        subscriptions.assignFromSubscribed(assignedPartitions);
        
        &lt;span class=&quot;code-comment&quot;&gt;//Add &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; code here
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (customerPausedPartitions != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; customerPausedPartitions.size() != 0){
            customerPausedPartitions.forEach(topicPartition -&amp;gt; {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(subscriptions.isAssigned(topicPartition))
                    subscriptions.pause(topicPartition);
            });
            customerPausedPartitions = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
        }

        &lt;span class=&quot;code-comment&quot;&gt;// Add partitions that were not previously owned but are now assigned
&lt;/span&gt;        firstException.compareAndSet(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;, invokePartitionsAssigned(addedPartitions));

        ......
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The above is just a first draft of the modified code. It can only guarantee that after a rebalance, the topicPartitions still held in the new assignment of KafkaConsumer will maintain the paused mark.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: If the new assignment of kafkaConsumer no longer contains topicPartitions that have been paused before rebalance, the paused mark of these topicPartitions will be lost forever on the kafkaConsumer side, even if in a future rebalance, the kafkaConsumer will hold these partitions again.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13409401">KAFKA-13425</key>
            <summary>KafkaConsumer#pause() will lose its effect after groupRebalance occurs, which maybe cause data loss on the consumer side</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="RivenSun">RivenSun</reporter>
                        <labels>
                            <label>new-consumer-threading-should-fix</label>
                    </labels>
                <created>Mon, 1 Nov 2021 10:14:08 +0000</created>
                <updated>Fri, 11 Feb 2022 07:30:41 +0000</updated>
                                            <version>3.0.0</version>
                                                    <component>consumer</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="17436729" author="rivensun" created="Mon, 1 Nov 2021 10:16:11 +0000"  >&lt;p&gt;Hi&#160;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&#160;and&#160;&#160;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Do you have any suggestions for this issue?&lt;br/&gt;
Thanks.&lt;/p&gt;</comment>
                            <comment id="17437060" author="guozhang" created="Mon, 1 Nov 2021 23:15:42 +0000"  >&lt;p&gt;Hello &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=RivenSun&quot; class=&quot;user-hover&quot; rel=&quot;RivenSun&quot;&gt;RivenSun&lt;/a&gt;, for such scenario, my common recommendation is to use &lt;/p&gt;
{Consumer#pause / resume}
&lt;p&gt; functions. I.e. when the blocking queue is full and &lt;/p&gt;
{publish}
&lt;p&gt; failed, the consumer could pause all the currently assigned partitions, and then subsequent &lt;/p&gt;
{Consumer#poll}
&lt;p&gt; would return no more data but only be used to keep consumer alive in the group. When detecting the queue is not full, then you can &lt;/p&gt;
{Consumer#resume}
&lt;p&gt; on those partitions.&lt;/p&gt;

&lt;p&gt;BTW, for questions like this, please feel free to send an email to the dev@kafka mailing thread instead of creating a JIRA (which is usually used to report a bug).&lt;/p&gt;</comment>
                            <comment id="17437071" author="rivensun" created="Mon, 1 Nov 2021 23:40:07 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;&#160;hello&#65292;Thank you for your reply&lt;/p&gt;

&lt;p&gt;Please take more time to read through this issue&lt;/p&gt;

&lt;p&gt;At the beginning, I did try it like your advice, and my approach is more violent.. When blocking queue is full or push failed, pause will be called before every poll call, but the poll method will &lt;b&gt;still return data&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;see maintainPoll4Rebalance method&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void maintainPoll4Rebalance() {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            kafkaConsumer.pause(kafkaConsumer.assignment());
            ConsumerRecords&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; records = kafkaConsumer.poll(Duration.ofSeconds(1));
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!records.isEmpty()) {
                log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;kafka poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance discard some record!&quot;&lt;/span&gt;);
                &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (ConsumerRecord&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;&amp;gt; consumerRecord : records) {
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (consumerRecord != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                        log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; record need to retry, partition {} ,offset {}&quot;&lt;/span&gt;, consumerRecord.partition(), consumerRecord.offset());
                    }
                }
            }
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
            log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;maintain poll &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; rebalance with error:{}&quot;&lt;/span&gt;, e.getMessage(), e);
        } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
            kafkaConsumer.resume(kafkaConsumer.assignment());
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;And I think this is indeed a problem on the KafkaConsumer side. You can browse the &lt;b&gt;RootCause Analysis&lt;/b&gt; and &lt;b&gt;Suggestion&lt;/b&gt; mentioned in Jira.&lt;br/&gt;
 Thanks.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17437169" author="showuon" created="Tue, 2 Nov 2021 07:36:51 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=RivenSun&quot; class=&quot;user-hover&quot; rel=&quot;RivenSun&quot;&gt;RivenSun&lt;/a&gt;, thanks for reporting this issue. But I think the original design of pause/resume is that:&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Rebalance does not preserve pause/resume state.&lt;/b&gt; (check &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-2350&quot; title=&quot;Add KafkaConsumer pause capability&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-2350&quot;&gt;&lt;del&gt;KAFKA-2350&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;So, back to your suggestions:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Precise semantics of kafkaConsumer#pause(&#8230;)&lt;br/&gt;
 --&amp;gt; I agree that the java doc is not clear about &lt;font color=&quot;#ff0000&quot;&gt;the pause method will lose its function after a groupRebalance. Welcome to submit PR to improve it!&lt;/font&gt;&lt;/li&gt;
	&lt;li&gt;When we execute invokePartitionsRevoked(revokedPartitions), do we consider the need to clean up the messages in KafkaConsumer memory corresponding to revokedPartitions?&lt;br/&gt;
 --&amp;gt; I&apos;m not sure I understand your suggestion here.&lt;/li&gt;
	&lt;li&gt;We better support the pause(...) method on the KafkaConsumer side that is not affected by groupRebalance&lt;br/&gt;
 --&amp;gt; I understand what you&apos;re trying to achieve. But your suggestion here won&apos;t succeed, because what you pointed out here (i.e. `onJoinComplete`) is actually the place where the consumer receive the assignment from consumer leader (or more specifically, from group coordinator). That is, after the rebalance, the original paused partitions might already assign to other consumers. Although you tried not to remove the paused partitions on `onJoinPrepare`, it only works on sticky-related assignor (where we&apos;ll do assignment depending on previously owned partitions), not other assignors. And what you&apos;re trying to do, will cause the same partition assigned to 2 consumers. I think if we want to allow `pause` not affect by rebalance, you should first throw out the question in dev channel, to see if this is a good feature(proposal) to go.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Thank you.&lt;/p&gt;</comment>
                            <comment id="17437196" author="rivensun" created="Tue, 2 Nov 2021 08:28:45 +0000"  >&lt;p&gt;Haha,&#160; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt; thank you for your reply and recognition of me&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/biggrin.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;1. Thank you for your suggestion, and I think it is better to print the relevant prompt log when cleaning the paused mark.&lt;/p&gt;

&lt;p&gt;2.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;tt&gt;When we execute invokePartitionsRevoked(revokedPartitions), do we consider the need to clean up the messages in KafkaConsumer memory corresponding to revokedPartitions?&lt;/tt&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;This means that when ConsumerCoordinator#onJoinPrepare(...) is executed, no matter &quot;protocol=EAGER&quot; or &quot;protocol=COOPERATIVE&quot;, the invokePartitionsRevoked(revokedPartitions) operation will be executed. In addition, COOPERATIVE will have a &quot;!revokedPartitions.isEmpty()&quot; restriction.&lt;/p&gt;

&lt;p&gt;After executing invokePartitionsRevoked(revokedPartitions), I understand that it means that after the rebalance is completed, kafkaConsumer will no longer hold this part of topicPartitions with &lt;b&gt;a high probability&lt;/b&gt;. So is it necessary for KafkaConsumer to keep the messages of this part of the partition? Especially the instance variable &lt;b&gt;nextInLineFetch&lt;/b&gt; in Fetcher may contain the message of revokedPartitions.&lt;/p&gt;

&lt;p&gt;Can we &lt;b&gt;try to clean up&lt;/b&gt; the messages in the memory corresponding to revokedPartitions while executing invokePartitionsRevoked(revokedPartitions)?&lt;br/&gt;
 In this way, you can avoid that after the paused mark is cleared, Fetcher#fetchedRecords() will return messages for these partitions.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;3.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;We better support the pause(...) method on the KafkaConsumer side that is not affected by groupRebalance&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Let&apos;s review this code again&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        ......

        subscriptions.assignFromSubscribed(assignedPartitions);
        
        &lt;span class=&quot;code-comment&quot;&gt;//Add &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; code here
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (customerPausedPartitions != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; customerPausedPartitions.size() != 0){
            customerPausedPartitions.forEach(topicPartition -&amp;gt; {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(subscriptions.isAssigned(topicPartition))
                    subscriptions.pause(topicPartition);
            });
            customerPausedPartitions = &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;;
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;1&#65289;My code change is &lt;b&gt;added after&lt;/b&gt; &#8221;subscriptions.assignFromSubscribed(assignedPartitions)&#8220; , so it will not cause the same partition to be assigned to multiple consumers.&lt;br/&gt;
 The purpose of the new code is: if the latest assignment of kafkaConsumer &lt;b&gt;still holds the topicPartitions&lt;/b&gt; marked paused before rebalance, kafkaConsumer will maintain the paused marking of these partitions&lt;/p&gt;

&lt;p&gt;2&#65289;If the original paused partitions are allocated to other consumers.&lt;/p&gt;

&lt;p&gt;&#160; &#160; &#160; I also stated in the note: If the new assignment of kafkaConsumer no longer contains topicPartitions that have been paused before rebalance, the paused mark of these topicPartitions will be lost forever on the kafkaConsumer side, even if in a future rebalance, the kafkaConsumer will hold these partitions again.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17437256" author="rivensun" created="Tue, 2 Nov 2021 10:04:18 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since I was not familiar with the Kafka PR process at the beginning, in my Kafka folk project, there is already a PR in the &lt;b&gt;trunk&lt;/b&gt; branch of my folk project.&lt;/p&gt;

&lt;p&gt;Please help review it, luke.&#160;&lt;a href=&quot;https://github.com/apache/kafka/pull/11340&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/11340&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As a result, I cannot create a new PR for this Jira here, and the new PR does not contain any code of PR-11340&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;And does dev channel refer to the mailbox dev@kafka?&lt;/p&gt;</comment>
                            <comment id="17437264" author="showuon" created="Tue, 2 Nov 2021 10:17:59 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=RivenSun&quot; class=&quot;user-hover&quot; rel=&quot;RivenSun&quot;&gt;RivenSun&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;dev channel refers to: &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;mailto:dev@kafka.apache.org&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;dev@kafka.apache.org&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/mail_small.gif&quot; height=&quot;12&quot; width=&quot;13&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;. Please remember to subscribe to it to get updated emails. Please check here: &lt;a href=&quot;https://kafka.apache.org/contact&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://kafka.apache.org/contact&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;About how to create another PR, I&apos;d like to guide you through it, but I think the simplest way is try to learn it by searching git process on web (ex: this one: &lt;a href=&quot;https://blog.scottlowe.org/2015/01/27/using-fork-branch-git-workflow/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://blog.scottlowe.org/2015/01/27/using-fork-branch-git-workflow/&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Hope that helps. Thank you.&lt;/p&gt;</comment>
                            <comment id="17437285" author="rivensun" created="Tue, 2 Nov 2021 10:52:02 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&#160; Thank you for your reply, it is helpful to me.&lt;br/&gt;
 In fact, I have already got&#160; a historical commitId from the trunk branch of apache:kafka, then&#160; checkout and create &quot;KAFKA_13425&quot; new branch, and pushed to my own folk project, and finally through the Fetch upstream function to ensure that RivenSun2:KAFKA_13425 and the latest code of apache:kafka are consistent&lt;/p&gt;</comment>
                            <comment id="17437330" author="showuon" created="Tue, 2 Nov 2021 12:31:47 +0000"  >&lt;p&gt;&amp;gt; 1&#65289;My code change is &lt;b&gt;added after&lt;/b&gt; &#8221;subscriptions.assignFromSubscribed(assignedPartitions)&#8220; , so it will not cause the same partition to be assigned to multiple consumers.&lt;br/&gt;
 The purpose of the new code is: if the latest assignment of kafkaConsumer &lt;b&gt;still holds the topicPartitions&lt;/b&gt; marked paused before rebalance, kafkaConsumer will maintain the paused marking of these partitions&lt;/p&gt;

&lt;p&gt;2&#65289;If the original paused partitions are allocated to other consumers.&lt;/p&gt;

&lt;p&gt;&#160; &#160; &#160; I also stated in the note: If the new assignment of kafkaConsumer no longer contains topicPartitions that have been paused before rebalance, the paused mark of these topicPartitions will be lost forever on the kafkaConsumer side, even if in a future rebalance, the kafkaConsumer will hold these partitions again.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;--&amp;gt; I understand now. It&apos;s just that some paused partitions will keep pausing, while some are resuming now. Compared to current design, I&apos;d prefer current design, to remove all paused partitions when rebalance happened.&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17437366" author="rivensun" created="Tue, 2 Nov 2021 13:41:32 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So we have reached a consensus&#65306;When the rebalance is completed, if protocol=EAGER, the paused mark in the assignment of kafkaConsumer will be all cleared.&lt;/p&gt;

&lt;p&gt;But &lt;b&gt;please note&lt;/b&gt; that if protocol=COOPERATIVE, in the ConsumerCoordinator#onJoinPrepare(...) method, it will not necessarily revoke all topicpartitions in the assignment of the consumer, see the comments on the code&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// only revoke those partitions that are not in the subscription any more.&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let&apos;s review the code in ConsumerCoordinator#onJoinComplete(...)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
subscriptions.assignFromSubscribed(assignedPartitions);&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Simply browse the SubscriptionState#assignFromSubscribed code implementation, you will know: it will maintain the paused mark of the kafkaConsumer current assignment.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;


&lt;p&gt;The result is:&lt;br/&gt;
For ConsumerPartitionAssignor that uses COOPERATIVE, such as CooperativeStickyAssignor, when the rebalance is completed,&lt;br/&gt;
1) PausedTopicpartitions of kafkaConsumer are still all in effect. Reason: It is possible that only the subscribed topic adds partitions&lt;br/&gt;
2) The pausedTopicpartitions part of kafkaConsumer takes effect. Reason: A new consumer may have been newly added, and part of the pausedTopicpartitions are allocated to the newly added consumer&lt;br/&gt;
3) All pausedTopicpartitions of kafkaConsumer are invalid. Reason: A large number of consumers are added to the group, groupConsumerSize &amp;gt; groupTopicPartitionSize,&#160; and this kafkaConsumer is not assigned any topicPartitions.&lt;/p&gt;

&lt;p&gt;In this way, it will cause a lot of ambiguity to KafkaConsumer#pause(...).&lt;/p&gt;

&lt;p&gt;Customers will also be very confused, no matter whether groupRebalance occurs, why does pause(...) sometimes work? Sometimes part of these pausedTopicpartitions work? Sometimes all does not work?&lt;/p&gt;

&lt;p&gt;What do you think, luke.&lt;/p&gt;</comment>
                            <comment id="17437413" author="rivensun" created="Tue, 2 Nov 2021 15:00:20 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In fact, the purpose of the modified code I added is to make the behavior of the EAGER and COOPERATIVE strategies &lt;b&gt;finally consistent&lt;/b&gt; : After the rebalance is completed, KafkaConsumer can continue to maintain the paused flags of topicPartitions that are still in the latest assignment.&lt;/p&gt;


&lt;p&gt;Currently &lt;b&gt;only the COOPERATIVE&lt;/b&gt; strategy achieves such semantics.&lt;/p&gt;</comment>
                            <comment id="17437705" author="rivensun" created="Wed, 3 Nov 2021 02:51:38 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Because the ConsumerCoordinator#invokePartitionsXXX(...) is always executed before the subscriptions.assignFromSubscribed(...) , so we can add logs in the invokePartitionsXXX(...) method uniformly.&lt;br/&gt;
This is the PR I created, please help to review it&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/kafka/pull/11460&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/11460&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thanks.&lt;/p&gt;</comment>
                            <comment id="17466697" author="rivensun" created="Thu, 30 Dec 2021 06:20:51 +0000"  >&lt;p&gt;more detail &#65292;please see in &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-13463&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-13463&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="13035549" name="architecture_picture.png" size="59569" author="RivenSun" created="Mon, 1 Nov 2021 10:13:53 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 45 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0wbyw:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>showuon</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>