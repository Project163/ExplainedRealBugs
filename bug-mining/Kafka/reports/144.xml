<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 16:36:25 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-544] Retain key in producer and expose it in the consumer</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-544</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-506&quot; title=&quot;Store logical offset in log&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-506&quot;&gt;&lt;del&gt;KAFKA-506&lt;/del&gt;&lt;/a&gt; added support for retaining a key in the messages, however this field is not yet set by the producer.&lt;/p&gt;

&lt;p&gt;The proposal for doing this is to change the producer api to change ProducerData to allow only a single key/value pair so it has a one-to-one mapping to Message. That is change from&lt;br/&gt;
  ProducerData(topic: String, key: K, data: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;V&amp;#93;&lt;/span&gt;)&lt;br/&gt;
to&lt;br/&gt;
  ProducerData(topic: String, key: K, data: V)&lt;/p&gt;

&lt;p&gt;The key itself needs to be encoded. There are several ways this could be handled. A few of the options:&lt;br/&gt;
1. Change the Encoder and Decoder to be MessageEncoder and MessageDecoder and have them take both a key and value.&lt;br/&gt;
2. Another option is to change the type of the encoder/decoder to not refer to Message so it could be used for both the key and value.&lt;/p&gt;

&lt;p&gt;I favor the second option but am open to feedback.&lt;/p&gt;

&lt;p&gt;One concern with our current approach to serialization as well as both of these proposals is that they are inefficient. We go from Object=&amp;gt;byte[]=&amp;gt;Message=&amp;gt;MessageSet with a copy at each step. In the case of compression there are a bunch of intermediate steps. We could theoretically clean this up by instead having an interface for the encoder that was something like&lt;br/&gt;
   Encoder.writeTo(buffer: ByteBuffer, object: AnyRef)&lt;br/&gt;
and&lt;br/&gt;
   Decoder.readFrom(buffer:ByteBuffer): AnyRef&lt;br/&gt;
However there are two problems with this. The first is that we don&apos;t actually know the size of the data until  it is serialized so we can&apos;t really allocate the bytebuffer properly and might need to resize it. The second is that in the case of compression there is a whole other path to consider. Originally I thought maybe it would be good to try to fix this, but now I think it should be out-of-scope and we should revisit the efficiency issue in a future release in conjunction with our internal handling of compression.&lt;/p&gt;


</description>
                <environment></environment>
        <key id="12610377">KAFKA-544</key>
            <summary>Retain key in producer and expose it in the consumer</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jkreps">Jay Kreps</assignee>
                                    <reporter username="jkreps">Jay Kreps</reporter>
                        <labels>
                            <label>bugs</label>
                    </labels>
                <created>Thu, 4 Oct 2012 19:23:51 +0000</created>
                <updated>Tue, 4 Dec 2012 23:43:08 +0000</updated>
                            <resolved>Mon, 26 Nov 2012 21:21:33 +0000</resolved>
                                    <version>0.8.0</version>
                                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="13470610" author="jkreps" created="Fri, 5 Oct 2012 20:00:47 +0000"  >&lt;p&gt;After looking at the code I think there is a fair amount of work here. I recommend we put off the user-facing API change until 0.9. Instead I propose the following intermediate hack for 0.8:&lt;br/&gt;
1. Use the existing ProducerData object to get the key and value. This is slightly unnatural because it allows you to associate a key with many values.&lt;br/&gt;
2. Use option (2) above for the encoders&lt;/p&gt;

&lt;p&gt;So specifically this means that the two interfaces would now be &lt;br/&gt;
trait Encoder&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; {&lt;br/&gt;
  def toBytes(t: T)&lt;br/&gt;
}&lt;br/&gt;
trait Decoder&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt; {&lt;br/&gt;
  def fromBytes(b: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;&lt;br/&gt;
}&lt;/p&gt;

&lt;p&gt;There would now be two encoders, one for the key and one for the value. The value would still be configured by the property &quot;serializer.class&quot; but we would add a new property &quot;key.serializer.class&quot; which would default to use the same value as the value serializer.&lt;/p&gt;

&lt;p&gt;The plan would be to hold off on any changes to the consumer for now.&lt;/p&gt;</comment>
                            <comment id="13472511" author="junrao" created="Tue, 9 Oct 2012 16:19:40 +0000"  >&lt;p&gt;This plan sounds good to me.&lt;/p&gt;</comment>
                            <comment id="13496885" author="jkreps" created="Wed, 14 Nov 2012 05:57:11 +0000"  >&lt;p&gt;This patch does the following:&lt;br/&gt;
1. Change Encoder and Decoder to map between object and byte[] rather than between Message and object.&lt;br/&gt;
2. Require two encoders for the producer and two decoders for the consumer. This follows the same pattern as before: in the producer there is now serializer.class and key.serializer.class. By default key.serializer takes the same value as serializer.class. If no key is specified then this parameter is essentially ignored. In the consumer ConsumerConnector now requires two decoders, one for the key and one for the value.&lt;br/&gt;
3. Message is now no longer exposed in the high level APIs.&lt;br/&gt;
4. All tests that used Message with high level apis (i.e. almost all tests) are now converted to use Strings. This is easier to read and debug (since you can print the value) and generally less code.&lt;/p&gt;

&lt;p&gt;Overall I have some concern that we are changing the API without deeply thinking it through, but this does expose the key functionality which is needed.&lt;/p&gt;

&lt;p&gt;This set of changes is wide but shallow--it touches a lot of classes but there is nothing too tricky.&lt;/p&gt;

&lt;p&gt;All unit tests pass, but I haven&apos;t yet verified system tests.&lt;/p&gt;</comment>
                            <comment id="13497205" author="jkreps" created="Wed, 14 Nov 2012 16:33:41 +0000"  >&lt;p&gt;One other minor thing in this patch:&lt;br/&gt;
5. Both the key and the partition are now exposed in MessageAndMetadata&lt;/p&gt;</comment>
                            <comment id="13497497" author="jkreps" created="Wed, 14 Nov 2012 21:51:33 +0000"  >&lt;p&gt;Updated patch. This patch fixes on of the uglier things in the producer API. Previously the producer took a ProducerData object which contained a topic, an optional key and one or more messages.&lt;/p&gt;

&lt;p&gt;The send method in the producer could take one or more of these. This is a little odd since sending many messages attached to a single ProducerData is the same as sending many ProducerData objects with the same key.&lt;/p&gt;

&lt;p&gt;Since we now associate a key per message, I changed this. I added a new class&lt;br/&gt;
  case class KeyedMessage(topic: String, key: K, message: V)&lt;br/&gt;
this replaces ProducerData. Note that this class takes only a single key-value pair, but since you can send many at once in a single send() call this does not make the API any less general.&lt;/p&gt;</comment>
                            <comment id="13497521" author="jkreps" created="Wed, 14 Nov 2012 22:10:11 +0000"  >&lt;p&gt;Okay one more change--added offset to MessageAndMetadata.&lt;/p&gt;</comment>
                            <comment id="13497671" author="jkreps" created="Thu, 15 Nov 2012 01:08:41 +0000"  >&lt;p&gt;Final patch fixes a bug that effected the system tests. This patch is ready for review.&lt;/p&gt;

&lt;p&gt;To summarize, here are the changes listed in one place&lt;br/&gt;
1. Change encoder/decoder to &lt;br/&gt;
     def toBytes(t: T)&lt;br/&gt;
     def fromBytes(bytes: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;): T&lt;br/&gt;
I also took the opportunity to pass properties into the encoders and decoders so encoders and decoders now require a constructor that takes a VerifiableProperties. This allows for things like schema registry url, character encoding, etc.&lt;br/&gt;
2. Rename ProducerData to KeyedMessage and make it only contain a single key-value pair.&lt;br/&gt;
3. Add a new property for the producer, key.serializer.class to complement the already existing serializer.class. The key serializer defaults to the same value as the value serializer since I think that will be common (e.g. both Avro).&lt;br/&gt;
4. ConsumerConnector now requires two decoders, one for the key and one for the value. The type of the resulting stream is now &lt;span class=&quot;error&quot;&gt;&amp;#91;K,V&amp;#93;&lt;/span&gt; rather than just &lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;.&lt;br/&gt;
5. Exposed partition and offset in MessageAndMetadata class&lt;br/&gt;
6. Changed unit tests to mostly use strings instead of Message or byte[]&lt;/p&gt;

&lt;p&gt;This code is ready for review (por favor).&lt;/p&gt;

&lt;p&gt;We also need to make a call whether we want this in 0.8. It is not a very tricky change, but it does touch a lot of files. Since it is a compatibility change it would be nice to do it in 0.8, but it is awfully late in the game for this...&lt;/p&gt;</comment>
                            <comment id="13497680" author="junrao" created="Thu, 15 Nov 2012 01:22:05 +0000"  >&lt;p&gt;Thanks for patch v3. Looks good overall. Some minor comments:&lt;/p&gt;

&lt;p&gt;30. Encoder: It seems that we require the constructor of  Encoder and Partitioner to take a VerifiableProperty. It would be good if we can add a comment on that in the trait.&lt;/p&gt;

&lt;p&gt;31. ConsumerConnector: Can we have a version of create,essageStreamsByFilter without the decoders?&lt;/p&gt;

&lt;p&gt;32. ConsumerFetcherManager: no change is needed.&lt;/p&gt;

&lt;p&gt;33. BlockingChannel: logger.debug() should be just debug().&lt;/p&gt;

&lt;p&gt;34. ChecksumMessageFormatter: We probably can&apos;t remove it since it may be used in our tests.&lt;/p&gt;</comment>
                            <comment id="13497739" author="jkreps" created="Thu, 15 Nov 2012 03:49:01 +0000"  >&lt;p&gt;30. Good point, added.&lt;br/&gt;
31. No, for some reason scala won&apos;t allow that since it causes confusion with the other method (probably why we didn&apos;t have the equivalent before). Instead I gave default arguments for the decoders, which accomplishes the same thing.&lt;br/&gt;
32. Fixed&lt;br/&gt;
33. Fixed&lt;br/&gt;
34. Added it back.&lt;/p&gt;

&lt;p&gt;New patch contains these changes.&lt;/p&gt;</comment>
                            <comment id="13497755" author="junrao" created="Thu, 15 Nov 2012 04:41:28 +0000"  >&lt;p&gt;+1 on patch v5. For 30, could you add the same constructor comment for Partitioner too?&lt;/p&gt;</comment>
                            <comment id="13499938" author="nehanarkhede" created="Sun, 18 Nov 2012 22:35:30 +0000"  >&lt;p&gt;Minor comment - The API docs are broken in Producer.scala, Producer.java and ConsumerConnector.java due to the stale param names&lt;/p&gt;</comment>
                            <comment id="13500803" author="jjkoshy" created="Tue, 20 Nov 2012 02:28:08 +0000"  >&lt;p&gt;Overall the patch looks good - I have a few scattered comments (apologies for the late review).&lt;/p&gt;

&lt;p&gt;Decoder.scala: What is the point of KeylessMessageDecoder - shouldn&apos;t it simply be called MessageDecoder? Phrased&lt;br/&gt;
differently, why does it matter to the message decoder whether the message has an associated key or not?&lt;/p&gt;

&lt;p&gt;ConsoleConsumer: Does it make sense to provide an option (through formatter args to NewLineMessageFormatter) to also&lt;br/&gt;
print the key?&lt;/p&gt;

&lt;p&gt;Nulls vs. options:&lt;br/&gt;
I&apos;m not sure if we discussed this much on the mailing list as far as coding convention goes, but there are some places&lt;br/&gt;
where I personally prefer options over nulls. E.g., KeyedMessage - using null forces the programmer to use hasKey/check&lt;br/&gt;
for null. If something is missed, it could result in an NPE @ runtime. Options would catch these at compile time.&lt;/p&gt;

&lt;p&gt;One problem is that options are unavailable to Java, but that can be handled by providing a javaapi class that does&lt;br/&gt;
use option.&lt;/p&gt;

&lt;p&gt;ProducerSendThread: can use ArrayBuffer instead of ListBuffer.&lt;/p&gt;

&lt;p&gt;Partitioner.scala&lt;br/&gt;
Why is it &lt;b&gt;required&lt;/b&gt; to have a verifiable props in the constructor? E.g., why should DefaultPartitioner have to take a&lt;br/&gt;
props argument?&lt;/p&gt;</comment>
                            <comment id="13502197" author="jkreps" created="Wed, 21 Nov 2012 18:51:23 +0000"  >&lt;p&gt;Hey Joel, those are good points. Here is a follow-up patch that adresses these issues. Specifically:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;KeylessMessageDecoder makes no sense it was a hold over from an older, lower impact approach to defining decoder that would have let us leave the consumer api more or less unchanged. It is irrelevant now. Deleted it.&lt;/li&gt;
	&lt;li&gt;This does make sense. I had planned to leave this as a follow-up future item since it is essentially a new feature. However it is not hard. I implemented this on both the producer and consumer side.&lt;/li&gt;
	&lt;li&gt;Null vs Options. This is controversial but I am one of the ones who think option is not so good for us. Two reasons: (1) You have to create a new object and if the value is a number, box it, (2) the resulting match statement is a lot less readable than if(x == null) imho. It is true that NullPointerExceptions are a drag but in my experience these are just not that common in our kind of software as a production issue because our testing and load is relatively heavy so these issues are flushed out very quickly.&lt;/li&gt;
	&lt;li&gt;ProducerSendThread: good call, changed.&lt;/li&gt;
	&lt;li&gt;Yeah I thought about this. I basically just thought it was simpler. The complication is what do you do if there is both a no-arg constructor and one that takes options--the user has to know which we will invoke. Seems simpler to just require the argument even if you don&apos;t use it.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13502310" author="jjkoshy" created="Wed, 21 Nov 2012 21:03:16 +0000"  >&lt;p&gt;Thanks a lot for addressing the above. Changes look good but for a few typos:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;misspelling (seperat*)&lt;/li&gt;
	&lt;li&gt;NewLineMessageFormatter may as well be called DefaultMessageFormatter given the arbitrary message separator.&lt;/li&gt;
	&lt;li&gt;ConsoleProducer - valueEncoderClass should use valueEncoderOpt (line 93).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;On null vs. options, I agree that it is cumbersome to use and generally try to avoid it, but lately I have begun to think it&apos;s not too bad especially for cases like this where it is easy to forget to check for null. E.g., there&apos;s if (xOpt.isDefined) which is only slightly more verbose than if (x != null). &lt;br/&gt;
or xOpt.foreach(process(_)) (or map if you need the result) instead of (x != null) process&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; removes the need for the isDefined check/match statement and is not much more verbose.&lt;/p&gt;

&lt;p&gt;All that said, you are right that something like this would be caught early on - so either way works.&lt;/p&gt;</comment>
                            <comment id="13502590" author="jkreps" created="Thu, 22 Nov 2012 05:26:35 +0000"  >&lt;p&gt;Nice catches, fixed.&lt;/p&gt;</comment>
                            <comment id="13503464" author="initialcontext" created="Sun, 25 Nov 2012 07:48:34 +0000"  >&lt;p&gt;I like it!&lt;/p&gt;</comment>
                            <comment id="13504003" author="jjkoshy" created="Mon, 26 Nov 2012 19:24:25 +0000"  >&lt;p&gt;+1 - although can you fix the typo?&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	&lt;ul&gt;
		&lt;li&gt;if(props.containsKey(&quot;key.seperator&quot;))&lt;br/&gt;
      keySeparator = props.getProperty(&quot;key.separator&quot;).getBytes&lt;/li&gt;
		&lt;li&gt;if(props.containsKey(&quot;line.seperator&quot;))&lt;br/&gt;
      lineSeparator = props.getProperty(&quot;line.separator&quot;).getBytes&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
</comment>
                    </comments>
                    <attachments>
                            <attachment id="12554634" name="KAFKA-544-joel-comments-v2.patch" size="10604" author="jkreps" created="Thu, 22 Nov 2012 05:26:35 +0000"/>
                            <attachment id="12554550" name="KAFKA-544-joel-comments.patch" size="8657" author="jkreps" created="Wed, 21 Nov 2012 18:51:23 +0000"/>
                            <attachment id="12553457" name="KAFKA-544-v1.patch" size="124530" author="jkreps" created="Wed, 14 Nov 2012 05:57:11 +0000"/>
                            <attachment id="12553569" name="KAFKA-544-v2.patch" size="179006" author="jkreps" created="Wed, 14 Nov 2012 21:51:33 +0000"/>
                            <attachment id="12553574" name="KAFKA-544-v3.patch" size="179033" author="jkreps" created="Wed, 14 Nov 2012 22:10:11 +0000"/>
                            <attachment id="12553600" name="KAFKA-544-v4.patch" size="180904" author="jkreps" created="Thu, 15 Nov 2012 01:08:41 +0000"/>
                            <attachment id="12553614" name="KAFKA-544-v5.patch" size="180740" author="jkreps" created="Thu, 15 Nov 2012 03:49:01 +0000"/>
                            <attachment id="12553699" name="KAFKA-544-v6.patch" size="181559" author="jkreps" created="Thu, 15 Nov 2012 21:44:58 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>8.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>240982</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i017jr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4992</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>