<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 16:37:00 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-702] Deadlock between request handler/processor threads</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-702</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;We have seen this a couple of times in the past few days in a test cluster. The request handler and processor threads deadlock on the request/response queues bringing the server to a halt&lt;/p&gt;

&lt;p&gt;&quot;kafka-processor-10251-7&quot; prio=10 tid=0x00007f4a0c3c9800 nid=0x4c39 waiting on condition &lt;span class=&quot;error&quot;&gt;&amp;#91;0x00007f46f698e000&amp;#93;&lt;/span&gt;&lt;br/&gt;
   java.lang.Thread.State: WAITING (parking)&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;parking to wait for  &amp;lt;0x00007f48c9dd2698&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)&lt;br/&gt;
        at java.util.concurrent.ArrayBlockingQueue.put(ArrayBlockingQueue.java:252)&lt;br/&gt;
        at kafka.network.RequestChannel.sendRequest(RequestChannel.scala:107)&lt;br/&gt;
        at kafka.network.Processor.read(SocketServer.scala:321)&lt;br/&gt;
        at kafka.network.Processor.run(SocketServer.scala:231)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:619)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;&quot;kafka-request-handler-7&quot; daemon prio=10 tid=0x00007f4a0c57f000 nid=0x4c47 waiting on condition &lt;span class=&quot;error&quot;&gt;&amp;#91;0x00007f46f5b80000&amp;#93;&lt;/span&gt;&lt;br/&gt;
   java.lang.Thread.State: WAITING (parking)&lt;br/&gt;
        at sun.misc.Unsafe.park(Native Method)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;parking to wait for  &amp;lt;0x00007f48c9dd6348&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:158)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1987)&lt;br/&gt;
        at java.util.concurrent.ArrayBlockingQueue.put(ArrayBlockingQueue.java:252)&lt;br/&gt;
        at kafka.network.RequestChannel.sendResponse(RequestChannel.scala:112)&lt;br/&gt;
        at kafka.server.KafkaApis.handleProducerRequest(KafkaApis.scala:198)&lt;br/&gt;
        at kafka.server.KafkaApis.handle(KafkaApis.scala:58)&lt;br/&gt;
        at kafka.server.KafkaRequestHandler.run(KafkaRequestHandler.scala:41)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:619)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This is because there is a cycle in the wait-for graph of processor threads and request handler threads. If the request handling slows down on a busy server, the request queue fills up. All processor threads quickly block on adding incoming requests to the request queue. Due to this, those threads do not processes responses filling up their response queues. At this moment, the request handler threads start blocking on adding responses to the respective response queues. This can lead to a deadlock where every thread is holding a lock on one queue and asking a lock for the other queue. This brings the server to a halt where it accepts connections but every request gets timed out.&lt;/p&gt;

&lt;p&gt;One way to resolve this is by breaking the cycle in the wait-for graph of the request handler and processor threads. Instead of having the processor threads dispatching the responses, we can have one or more dedicated response handler threads that dequeue responses from the queue and write those on the socket. One downside of this approach is that now access to the selector will have to be synchronized.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12627479">KAFKA-702</key>
            <summary>Deadlock between request handler/processor threads</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jkreps">Jay Kreps</assignee>
                                    <reporter username="jjkoshy">Joel Jacob Koshy</reporter>
                        <labels>
                            <label>bugs</label>
                    </labels>
                <created>Mon, 14 Jan 2013 18:58:53 +0000</created>
                <updated>Wed, 16 Jan 2013 21:42:43 +0000</updated>
                            <resolved>Wed, 16 Jan 2013 18:01:08 +0000</resolved>
                                    <version>0.8.0</version>
                                    <fixVersion>0.8.0</fixVersion>
                                    <component>network</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="13553499" author="junrao" created="Tue, 15 Jan 2013 05:23:11 +0000"  >&lt;p&gt;I am wondering if the following approach will break the deadlock.&lt;/p&gt;

&lt;p&gt;In RequestChannel.sendRequest(), instead of doing a blocking put(), we do offer() and return false if the queue is full. We propagate this flag to Processor.read(). Then, In Processor.run(), we only remove the selected key if read returns true. This way, read() will never block, which allows us to handle the responses even when the request queue is full.&lt;/p&gt;</comment>
                            <comment id="13553509" author="nehanarkhede" created="Tue, 15 Jan 2013 05:33:12 +0000"  >&lt;p&gt;I like this idea better than having separate response threads and locking between the processor and response handler threads. In the non blocking request put approach, we will have to be careful when the queue is full to not select new ready keys when the previous ones have not been successfully enqueued. This can be a little tricky.&lt;/p&gt;</comment>
                            <comment id="13554763" author="jkreps" created="Wed, 16 Jan 2013 05:35:19 +0000"  >&lt;p&gt;TLDR: attached one-line patch should fix the deadlock, but there is a larger issue (though not a blocker).&lt;/p&gt;

&lt;p&gt;I don&apos;t like the idea of splitting response and request between different threads. The reason our socket server is simple is because each network thread is totally independent of all others, so there are no threading issues. Mixing these is slow (because of all the locking) and error prone. I have seen this done before and it is a big mess.&lt;/p&gt;

&lt;p&gt;Jun&apos;s second idea is better, but its not as simple as described. We have to put the newly attached request somewhere and trigger a second attempt on adding it to the queue. Registering again for reading doesn&apos;t really work because there won&apos;t be more data to read. Registering for writing doesn&apos;t work because sockets are always writable so we would end up busy waiting. So to make this work we would need some kind of list where we stored requests that had been read but didn&apos;t fit in the queue. But we need something that will check this list periodically and it is hard to guarantee that that would happen with any more frequency that the poll timeout.&lt;/p&gt;

&lt;p&gt;But I think we are muddling things a bit. Let&apos;s step back and think about this from first principles.&lt;/p&gt;

&lt;p&gt;Why do queues have limits? The reason is to bound memory usage. So taking data off the socket and putting it in a list is silly, that defeats the original purpose of having the bound (the queue after all is just a list).&lt;/p&gt;

&lt;p&gt;But think about this more. Why are we blocking adding responses to the response queue? The reason would be to bound memory usage. But the response queue doesn&apos;t actually bound memory usage. Things going into the response queue come either directly from processors or from purgatory, and in either case they are taking up memory there. Preventing responses from going out isn&apos;t helping anything.&lt;/p&gt;

&lt;p&gt;So the short term fix is just to remove the bound on the response queue.&lt;/p&gt;

&lt;p&gt;The larger problem is that regardless of this change in 0.8 &lt;b&gt;we aren&apos;t effectively bounding memory usage&lt;/b&gt;. The reason is the purgatory. The purgatory will accumulate requests any time expiration gets slow. This could be due to a misconfigured client or due to a slow broker.&lt;/p&gt;

&lt;p&gt;So the error is that we are using queue size to indicate &quot;backlog&quot; but really the proper measure of backlog is the total number of requests in flight including all requests in queues OR in purgatory.&lt;/p&gt;

&lt;p&gt;But even once we understand the correct limit, it isn&apos;t clear what to do once we hit that limit. There are two choices: (1) stop taking new requests, (2) prematurely start responding to requests in the purgatory. Neither of these is great. Consider the case where one broker gets slow and umpteen produce requests pile up in purgatory. If we stop taking new requests that is like a GC pause, but since the timeout could be 30 seconds away it will be a long one. If we start dumping the purgatory prematurely we will have to respond with an error because we lack sufficient acknowledgements.&lt;/p&gt;</comment>
                            <comment id="13554807" author="nehanarkhede" created="Wed, 16 Jan 2013 07:20:04 +0000"  >&lt;p&gt;Agree that a longer term fix is to be able to bound the total memory usage by counting the requests in flight in the purgatory. But when we do reach this limit, we should load shed from the purgatory like you suggested. One way of doing that is by implementing client quotas and shedding requests coming from the faulty clients. This might require more thought and probably a big refactoring. I think we should checkin this patch and tune GC and see how that goes.&lt;/p&gt;

&lt;p&gt;+1 on patch v1&lt;/p&gt;</comment>
                            <comment id="13555148" author="junrao" created="Wed, 16 Jan 2013 15:56:14 +0000"  >&lt;p&gt;First of all, +1 on the simple patch. I think it solves the immediate problem.&lt;/p&gt;

&lt;p&gt;For socket selector, my understanding after reading the java doc is that the selected keys are always there unless you explicitly remove it. In other words, those selected keys won&apos;t magically go away after the socket key is being consumed. Everytime we call select(), only newly available keys are added and existing selected keys are untouched. So, even if we have finished reading from a socket, if the key is not automatically removed and select() will still give the same key back. However, my suggestion is probably worse than this patch. Before the request queue has space again, the processor thread could be doing the busy loop by keeping trying to add the same request from a socket to the request queue.&lt;/p&gt;

&lt;p&gt;A second thing is that, currently, the number of outstanding requests on the broker is bounded by the number of clients since each client can have at most one outstanding request. So, if we bound the number of clients, we can somewhat bound the memory used by outstanding requests. This limit is probably useful for not running out of open file handlers too.&lt;/p&gt;</comment>
                            <comment id="13555219" author="sriramsub" created="Wed, 16 Jan 2013 17:08:49 +0000"  >&lt;p&gt;I would like to add my thoughts to this. &lt;/p&gt;

&lt;p&gt;1. Load shedding arbitrary clients will bound the memory but would essentially cause the system to fail most of the requests and not recover from it till the load goes down. We have quite a few inter-dependencies between requests (producer depends on replica requests, replica depends on produce requests and consumer requests depend on produce requests) and dropping requests would essentially cause the requests depending on it to stay longer in the purgatory and fail. &lt;/p&gt;

&lt;p&gt;2. Having client quotas may not work because we do not have one faulty client. Each client can at most have only one request.&lt;/p&gt;

&lt;p&gt;Few improvements might reduce the failure scenarios&lt;/p&gt;

&lt;p&gt;1. Currently replica request wait on a hard limit (min bytes). Instead they could be made to return earlier to free the purgatory and accept more requests during high load scenarios.&lt;br/&gt;
2. Direct consumers to read from other replicas in the isr that have lesser load. This is going to be harder.&lt;/p&gt;
</comment>
                            <comment id="13555274" author="nehanarkhede" created="Wed, 16 Jan 2013 18:01:08 +0000"  >&lt;p&gt;Checked this in to proceed with deployment&lt;/p&gt;</comment>
                            <comment id="13555350" author="nehanarkhede" created="Wed, 16 Jan 2013 19:13:43 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; 2. Having client quotas may not work because we do not have one faulty client. Each client can at most have only one request.&lt;/p&gt;

&lt;p&gt;We understand that. Client quotas are better done probably in terms of expirations per second. Basically, if you setup your partitions with a large replication factor (let&apos;s say 6) and set the num.acks in your producer to -1. At the same time, if you set your timeout too low, all requests will timeout and expire. This will allow your client to send many requests that all timeout.&lt;/p&gt;

&lt;p&gt;Load shedding needs more thought. It is not as straightforward and when we scope it out, we will need to obviously keep in mind consequences of load shedding.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12565076" name="KAFKA-702-v1.patch" size="1213" author="jkreps" created="Wed, 16 Jan 2013 05:35:19 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>304263</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            12 years, 44 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i17kun:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>252347</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>