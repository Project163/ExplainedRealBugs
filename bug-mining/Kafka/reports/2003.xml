<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:13:47 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-7255] Timing issue in SimpleAclAuthorizer with concurrent create/update</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-7255</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;There is a small timing window in SimpleAclAuthorizer where ACL updates may be lost if two brokers create ACLs for a resource at the same time.&lt;/p&gt;

&lt;p&gt;Scenario: Administrator creates new.topic and sends one ACL request to add ACL for UserA for new.topic and a second request to add ACL for UserB for new.topic using AdminClient. These requests may be sent to different brokers by AdminClient. In most cases, both ACLs are added for the resource new.topic, but there is a small timing window where one broker may overwrite the ACL written by the other broker, resulting in only one of the ACLs (either UserA or UserB) being actually stored in ZooKeeper. The timing window itself is very small, but we have seen intermittent failures in SimpleAclAuthorizerTest.testHighConcurrencyModificationOfResourceAcls as a result of this window.&lt;/p&gt;

&lt;p&gt;Even though this issue can result in incorrect ACLs affecting security, we have not raised this as a security vulnerability since this is not an exploitable issue. ACLs can only be set by privileged users in Kafka who have Alter access on the Cluster resource. Users without this privileged access cannot use this issue to gain additional access to any resource.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13177630">KAFKA-7255</key>
            <summary>Timing issue in SimpleAclAuthorizer with concurrent create/update</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rsivaram">Rajini Sivaram</assignee>
                                    <reporter username="rsivaram">Rajini Sivaram</reporter>
                        <labels>
                    </labels>
                <created>Wed, 8 Aug 2018 09:32:13 +0000</created>
                <updated>Sun, 12 Aug 2018 18:16:57 +0000</updated>
                            <resolved>Sun, 12 Aug 2018 17:44:26 +0000</resolved>
                                    <version>0.11.0.3</version>
                    <version>1.0.2</version>
                    <version>1.1.1</version>
                    <version>2.0.0</version>
                                    <fixVersion>0.11.0.4</fixVersion>
                    <fixVersion>1.0.3</fixVersion>
                    <fixVersion>1.1.2</fixVersion>
                    <fixVersion>2.0.1</fixVersion>
                    <fixVersion>2.1.0</fixVersion>
                                    <component>security</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16572970" author="githubbot" created="Wed, 8 Aug 2018 10:01:27 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #5478: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7255&quot; title=&quot;Timing issue in SimpleAclAuthorizer with concurrent create/update&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7255&quot;&gt;&lt;del&gt;KAFKA-7255&lt;/del&gt;&lt;/a&gt;: Fix timing issue with create/update in SimpleAclAuthorizer&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5478&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5478&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   ACL updates currently  get `(currentAcls, currentVersion)` for the resource from ZK and do a conditional update using `(currentAcls+newAcl, currentVersion)`. This supports concurrent atomic updates if the resource path already exists in ZK. If the path doesn&apos;t exist, we currently do a conditional createOrUpdate using `(newAcl, -1)`. But `-1` has a special meaning in ZooKeeper for update operations - it means match any version. So two brokers adding acls using `(newAcl1, -1)` and `(newAcl2, -1)` will result in one broker creating the path and setting `newAcl1`, while the other broker can potentially update the path with `(newAcl2, -1)`, losing `newAcl1`. The timing window is very small, but we have seen intermittent failures in `SimpleAclAuthorizerTest.testHighConcurrencyModificationOfResourceAcls` as a result of this window. &lt;/p&gt;

&lt;p&gt;   This PR fixes the version used for conditional updates in ZooKeeper. It also replaces the confusing `ZkVersion.NoVersion=-1` used for set(any-version) and get(return not-found) with `ZkVersion.MatchAnyVersion` for set(any-version) and `ZkVersion.UnknownVersion` for get(return not-found) to avoid the return value from `get` matching arbitrary values in `set`.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16573484" author="githubbot" created="Wed, 8 Aug 2018 16:45:00 +0000"  >&lt;p&gt;rajinisivaram closed pull request #5478: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7255&quot; title=&quot;Timing issue in SimpleAclAuthorizer with concurrent create/update&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7255&quot;&gt;&lt;del&gt;KAFKA-7255&lt;/del&gt;&lt;/a&gt;: Fix timing issue with create/update in SimpleAclAuthorizer&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5478&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5478&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala b/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala&lt;br/&gt;
index e77656d748c..7ec572caa66 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/security/auth/SimpleAclAuthorizer.scala&lt;br/&gt;
@@ -22,11 +22,11 @@ import java.util.concurrent.locks.ReentrantReadWriteLock&lt;br/&gt;
 import com.typesafe.scalalogging.Logger&lt;br/&gt;
 import kafka.api.KAFKA_2_0_IV1&lt;br/&gt;
 import kafka.network.RequestChannel.Session&lt;br/&gt;
-import kafka.security.auth.SimpleAclAuthorizer.VersionedAcls&lt;br/&gt;
+import kafka.security.auth.SimpleAclAuthorizer.&lt;/p&gt;
{VersionedAcls, NoAcls}&lt;br/&gt;
 import kafka.server.KafkaConfig&lt;br/&gt;
 import kafka.utils.CoreUtils.{inReadLock, inWriteLock}&lt;br/&gt;
 import kafka.utils._&lt;br/&gt;
-import kafka.zk.{AclChangeNotificationHandler, AclChangeSubscription, KafkaZkClient, ZkAclChangeStore, ZkAclStore}&lt;br/&gt;
+import kafka.zk.{AclChangeNotificationHandler, AclChangeSubscription, KafkaZkClient, ZkAclChangeStore, ZkAclStore, ZkVersion}&lt;br/&gt;
 import org.apache.kafka.common.errors.UnsupportedVersionException&lt;br/&gt;
 import org.apache.kafka.common.resource.PatternType&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipal&lt;br/&gt;
@@ -48,7 +48,10 @@ object SimpleAclAuthorizer {&lt;br/&gt;
   //If set to true when no acls are found for a resource , authorizer allows access to everyone. Defaults to false.&lt;br/&gt;
   val AllowEveryoneIfNoAclIsFoundProp = &quot;allow.everyone.if.no.acl.found&quot;&lt;br/&gt;
 &lt;br/&gt;
-  case class VersionedAcls(acls: Set&lt;span class=&quot;error&quot;&gt;&amp;#91;Acl&amp;#93;&lt;/span&gt;, zkVersion: Int)&lt;br/&gt;
+  case class VersionedAcls(acls: Set&lt;span class=&quot;error&quot;&gt;&amp;#91;Acl&amp;#93;&lt;/span&gt;, zkVersion: Int) {
+    def exists: Boolean = zkVersion != ZkVersion.UnknownVersion
+  }&lt;br/&gt;
+  val NoAcls = VersionedAcls(Set.empty, ZkVersion.UnknownVersion)&lt;br/&gt;
 }&lt;br/&gt;
 &lt;br/&gt;
 class SimpleAclAuthorizer extends Authorizer with Logging {&lt;br/&gt;
@@ -204,7 +207,7 @@ class SimpleAclAuthorizer extends Authorizer with Logging {&lt;br/&gt;
   override def removeAcls(resource: Resource): Boolean = {&lt;br/&gt;
     inWriteLock(lock) {
       val result = zkClient.deleteResource(resource)
-      updateCache(resource, VersionedAcls(Set(), 0))
+      updateCache(resource, NoAcls)
       updateAclChangedFlag(resource)
       result
     }&lt;br/&gt;
@@ -314,7 +317,10 @@ class SimpleAclAuthorizer extends Authorizer with Logging {&lt;br/&gt;
       val newAcls = getNewAcls(currentVersionedAcls.acls)&lt;br/&gt;
       val (updateSucceeded, updateVersion) =&lt;br/&gt;
         if (newAcls.nonEmpty) {
-          zkClient.conditionalSetOrCreateAclsForResource(resource, newAcls, currentVersionedAcls.zkVersion)
+          if (currentVersionedAcls.exists)
+            zkClient.conditionalSetAclsForResource(resource, newAcls, currentVersionedAcls.zkVersion)
+          else
+            zkClient.createAclsForResourceIfNotExists(resource, newAcls)
         } else {&lt;br/&gt;
           trace(s&quot;Deleting path for $resource because it had no ACLs remaining&quot;)&lt;br/&gt;
           (zkClient.conditionalDelete(resource, currentVersionedAcls.zkVersion), 0)&lt;br/&gt;
diff --git a/core/src/main/scala/kafka/zk/KafkaZkClient.scala b/core/src/main/scala/kafka/zk/KafkaZkClient.scala&lt;br/&gt;
index c45a90f6076..c8079654d69 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/zk/KafkaZkClient.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/zk/KafkaZkClient.scala&lt;br/&gt;
@@ -24,7 +24,7 @@ import kafka.cluster.Broker&lt;br/&gt;
 import kafka.controller.LeaderIsrAndControllerEpoch&lt;br/&gt;
 import kafka.log.LogConfig&lt;br/&gt;
 import kafka.metrics.KafkaMetricsGroup&lt;br/&gt;
-import kafka.security.auth.SimpleAclAuthorizer.VersionedAcls&lt;br/&gt;
+import kafka.security.auth.SimpleAclAuthorizer.{VersionedAcls, NoAcls}
&lt;p&gt; import kafka.security.auth.&lt;/p&gt;
{Acl, Resource, ResourceType}
&lt;p&gt; import kafka.server.ConfigType&lt;br/&gt;
 import kafka.utils.Logging&lt;br/&gt;
@@ -98,7 +98,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;

&lt;p&gt;   def updateBrokerInfo(brokerInfo: BrokerInfo): Unit = {&lt;br/&gt;
     val brokerIdPath = brokerInfo.path&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val setDataRequest = SetDataRequest(brokerIdPath, brokerInfo.toJsonBytes, ZkVersion.NoVersion)&lt;br/&gt;
+    val setDataRequest = SetDataRequest(brokerIdPath, brokerInfo.toJsonBytes, ZkVersion.MatchAnyVersion)&lt;br/&gt;
     val response = retryRequestUntilConnected(setDataRequest)&lt;br/&gt;
     response.maybeThrow()&lt;br/&gt;
     info(&quot;Updated broker %d at path %s with addresses: %s&quot;.format(brokerInfo.broker.id, brokerIdPath, brokerInfo.broker.endPoints))&lt;br/&gt;
@@ -270,7 +270,8 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
   def setOrCreateEntityConfigs(rootEntityType: String, sanitizedEntityName: String, config: Properties) = {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     def set(configData: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;): SetDataResponse = &lt;/p&gt;
{
-      val setDataRequest = SetDataRequest(ConfigEntityZNode.path(rootEntityType, sanitizedEntityName), ConfigEntityZNode.encode(config), ZkVersion.NoVersion)
+      val setDataRequest = SetDataRequest(ConfigEntityZNode.path(rootEntityType, sanitizedEntityName),
+        ConfigEntityZNode.encode(config), ZkVersion.MatchAnyVersion)
       retryRequestUntilConnected(setDataRequest)
     }

&lt;p&gt;@@ -383,7 +384,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return SetDataResponse&lt;br/&gt;
    */&lt;br/&gt;
   def setTopicAssignmentRaw(topic: String, assignment: collection.Map[TopicPartition, Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;]): SetDataResponse = 
{
-    val setDataRequest = SetDataRequest(TopicZNode.path(topic), TopicZNode.encode(assignment), ZkVersion.NoVersion)
+    val setDataRequest = SetDataRequest(TopicZNode.path(topic), TopicZNode.encode(assignment), ZkVersion.MatchAnyVersion)
     retryRequestUntilConnected(setDataRequest)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -458,7 +459,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
    */&lt;br/&gt;
   def deleteLogDirEventNotifications(sequenceNumbers: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
     val deleteRequests = sequenceNumbers.map &lt;/p&gt;
{ sequenceNumber =&amp;gt;
-      DeleteRequest(LogDirEventNotificationSequenceZNode.path(sequenceNumber), ZkVersion.NoVersion)
+      DeleteRequest(LogDirEventNotificationSequenceZNode.path(sequenceNumber), ZkVersion.MatchAnyVersion)
     }
&lt;p&gt;     retryRequestsUntilConnected(deleteRequests)&lt;br/&gt;
   }&lt;br/&gt;
@@ -558,12 +559,12 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param path zk node path&lt;/li&gt;
	&lt;li&gt;@return A tuple of 2 elements, where first element is zk node data as an array of bytes&lt;/li&gt;
	&lt;li&gt;and second element is zk node version.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*         returns (None, ZkVersion.NoVersion) if node doesn&apos;t exists and throws exception for any error&lt;br/&gt;
+   *         returns (None, ZkVersion.UnknownVersion) if node doesn&apos;t exist and throws exception for any error&lt;br/&gt;
    */&lt;br/&gt;
   def getDataAndVersion(path: String): (Option[Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;], Int) = 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {     val (data, stat) = getDataAndStat(path)     stat match {
-      case ZkStat.NoStat =&amp;gt; (data, ZkVersion.NoVersion)
+      case ZkStat.NoStat =&amp;gt; (data, ZkVersion.UnknownVersion)
       case _ =&amp;gt; (data, stat.getVersion)
     }   }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;@@ -602,7 +603,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Conditional update the persistent path data, return (true, newVersion) if it succeeds, otherwise (the path doesn&apos;t&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* exist, the current version is not the expected version, etc.) return (false, ZkVersion.NoVersion)&lt;br/&gt;
+   * exist, the current version is not the expected version, etc.) return (false, ZkVersion.UnknownVersion)&lt;br/&gt;
    *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;When there is a ConnectionLossException during the conditional update, ZookeeperClient will retry the update and may fail&lt;/li&gt;
	&lt;li&gt;since the previous update may have succeeded (but the stored zkVersion no longer matches the expected one).&lt;br/&gt;
@@ -627,13 +628,13 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
             debug(&quot;Checker method is not passed skipping zkData match&quot;)&lt;br/&gt;
             debug(&quot;Conditional update of path %s with data %s and expected version %d failed due to %s&quot;&lt;br/&gt;
               .format(path, Utils.utf8(data), expectVersion, setDataResponse.resultException.get.getMessage))&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(false, ZkVersion.NoVersion)&lt;br/&gt;
+            (false, ZkVersion.UnknownVersion)&lt;br/&gt;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       case Code.NONODE =&amp;gt;&lt;br/&gt;
         debug(&quot;Conditional update of path %s with data %s and expected version %d failed due to %s&quot;.format(path,&lt;br/&gt;
           Utils.utf8(data), expectVersion, setDataResponse.resultException.get.getMessage))&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(false, ZkVersion.NoVersion)&lt;br/&gt;
+        (false, ZkVersion.UnknownVersion)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       case _ =&amp;gt;&lt;br/&gt;
         debug(&quot;Conditional update of path %s with data %s and expected version %d failed due to %s&quot;.format(path,&lt;br/&gt;
@@ -678,7 +679,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param topics the topics to remove.&lt;br/&gt;
    */&lt;br/&gt;
   def deleteTopicDeletions(topics: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = 
{
-    val deleteRequests = topics.map(topic =&amp;gt; DeleteRequest(DeleteTopicsTopicZNode.path(topic), ZkVersion.NoVersion))
+    val deleteRequests = topics.map(topic =&amp;gt; DeleteRequest(DeleteTopicsTopicZNode.path(topic), ZkVersion.MatchAnyVersion))
     retryRequestsUntilConnected(deleteRequests)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -712,7 +713,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
   def setOrCreatePartitionReassignment(reassignment: collection.Map[TopicPartition, Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Int&amp;#93;&lt;/span&gt;]): Unit = {&lt;/p&gt;

&lt;p&gt;     def set(reassignmentData: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;): SetDataResponse = &lt;/p&gt;
{
-      val setDataRequest = SetDataRequest(ReassignPartitionsZNode.path, reassignmentData, ZkVersion.NoVersion)
+      val setDataRequest = SetDataRequest(ReassignPartitionsZNode.path, reassignmentData, ZkVersion.MatchAnyVersion)
       retryRequestUntilConnected(setDataRequest)
     }

&lt;p&gt;@@ -745,7 +746,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Deletes the partition reassignment znode.&lt;br/&gt;
    */&lt;br/&gt;
   def deletePartitionReassignment(): Unit = 
{
-    val deleteRequest = DeleteRequest(ReassignPartitionsZNode.path, ZkVersion.NoVersion)
+    val deleteRequest = DeleteRequest(ReassignPartitionsZNode.path, ZkVersion.MatchAnyVersion)
     retryRequestUntilConnected(deleteRequest)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -866,7 +867,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
    */&lt;br/&gt;
   def deleteIsrChangeNotifications(sequenceNumbers: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
     val deleteRequests = sequenceNumbers.map &lt;/p&gt;
{ sequenceNumber =&amp;gt;
-      DeleteRequest(IsrChangeNotificationSequenceZNode.path(sequenceNumber), ZkVersion.NoVersion)
+      DeleteRequest(IsrChangeNotificationSequenceZNode.path(sequenceNumber), ZkVersion.MatchAnyVersion)
     }
&lt;p&gt;     retryRequestsUntilConnected(deleteRequests)&lt;br/&gt;
   }&lt;br/&gt;
@@ -898,7 +899,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Deletes the preferred replica election znode.&lt;br/&gt;
    */&lt;br/&gt;
   def deletePreferredReplicaElection(): Unit = 
{
-    val deleteRequest = DeleteRequest(PreferredReplicaElectionZNode.path, ZkVersion.NoVersion)
+    val deleteRequest = DeleteRequest(PreferredReplicaElectionZNode.path, ZkVersion.MatchAnyVersion)
     retryRequestUntilConnected(deleteRequest)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -920,7 +921,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Deletes the controller znode.&lt;br/&gt;
    */&lt;br/&gt;
   def deleteController(): Unit = 
{
-    val deleteRequest = DeleteRequest(ControllerZNode.path, ZkVersion.NoVersion)
+    val deleteRequest = DeleteRequest(ControllerZNode.path, ZkVersion.MatchAnyVersion)
     retryRequestUntilConnected(deleteRequest)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -953,7 +954,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param topics the topics whose configs we wish to delete.&lt;br/&gt;
    */&lt;br/&gt;
   def deleteTopicConfigs(topics: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = 
{
-    val deleteRequests = topics.map(topic =&amp;gt; DeleteRequest(ConfigEntityZNode.path(ConfigType.Topic, topic), ZkVersion.NoVersion))
+    val deleteRequests = topics.map(topic =&amp;gt; DeleteRequest(ConfigEntityZNode.path(ConfigType.Topic, topic), ZkVersion.MatchAnyVersion))
     retryRequestsUntilConnected(deleteRequests)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -981,7 +982,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
     val getDataResponse = retryRequestUntilConnected(getDataRequest)&lt;br/&gt;
     getDataResponse.resultCode match &lt;/p&gt;
{
       case Code.OK =&amp;gt; ResourceZNode.decode(getDataResponse.data, getDataResponse.stat)
-      case Code.NONODE =&amp;gt; VersionedAcls(Set(), -1)
+      case Code.NONODE =&amp;gt; NoAcls
       case _ =&amp;gt; throw getDataResponse.resultException.get
     }
&lt;p&gt;   }&lt;br/&gt;
@@ -994,12 +995,26 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param expectedVersion&lt;/li&gt;
	&lt;li&gt;@return true if the update was successful and the new version&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def conditionalSetOrCreateAclsForResource(resource: Resource, aclsSet: Set&lt;span class=&quot;error&quot;&gt;&amp;#91;Acl&amp;#93;&lt;/span&gt;, expectedVersion: Int): (Boolean, Int) = {&lt;br/&gt;
+  def conditionalSetAclsForResource(resource: Resource, aclsSet: Set&lt;span class=&quot;error&quot;&gt;&amp;#91;Acl&amp;#93;&lt;/span&gt;, expectedVersion: Int): (Boolean, Int) = {&lt;br/&gt;
     def set(aclData: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;,  expectedVersion: Int): SetDataResponse = 
{
       val setDataRequest = SetDataRequest(ResourceZNode.path(resource), aclData, expectedVersion)
       retryRequestUntilConnected(setDataRequest)
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    if (expectedVersion &amp;lt; 0)&lt;br/&gt;
+      throw new IllegalArgumentException(s&quot;Invalid version $expectedVersion provided for conditional update&quot;)&lt;br/&gt;
+&lt;br/&gt;
+    val aclData = ResourceZNode.encode(aclsSet)&lt;br/&gt;
+&lt;br/&gt;
+    val setDataResponse = set(aclData, expectedVersion)&lt;br/&gt;
+    setDataResponse.resultCode match &lt;/p&gt;
{
+      case Code.OK =&amp;gt; (true, setDataResponse.stat.getVersion)
+      case Code.NONODE | Code.BADVERSION  =&amp;gt; (false, ZkVersion.UnknownVersion)
+      case _ =&amp;gt; throw setDataResponse.resultException.get
+    }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  def createAclsForResourceIfNotExists(resource: Resource, aclsSet: Set&lt;span class=&quot;error&quot;&gt;&amp;#91;Acl&amp;#93;&lt;/span&gt;): (Boolean, Int) = {&lt;br/&gt;
     def create(aclData: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;): CreateResponse = {&lt;br/&gt;
       val path = ResourceZNode.path(resource)&lt;br/&gt;
       val createRequest = CreateRequest(path, aclData, acls(path), CreateMode.PERSISTENT)&lt;br/&gt;
@@ -1008,19 +1023,11 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;

&lt;p&gt;     val aclData = ResourceZNode.encode(aclsSet)&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val setDataResponse = set(aclData, expectedVersion)&lt;/li&gt;
	&lt;li&gt;setDataResponse.resultCode match {&lt;/li&gt;
	&lt;li&gt;case Code.OK =&amp;gt; (true, setDataResponse.stat.getVersion)&lt;/li&gt;
	&lt;li&gt;case Code.NONODE =&amp;gt; {&lt;/li&gt;
	&lt;li&gt;val createResponse = create(aclData)&lt;/li&gt;
	&lt;li&gt;createResponse.resultCode match 
{
-          case Code.OK =&amp;gt; (true, 0)
-          case Code.NODEEXISTS =&amp;gt; (false, 0)
-          case _ =&amp;gt; throw createResponse.resultException.get
-        }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;case Code.BADVERSION =&amp;gt; (false, 0)&lt;/li&gt;
	&lt;li&gt;case _ =&amp;gt; throw setDataResponse.resultException.get&lt;br/&gt;
+    val createResponse = create(aclData)&lt;br/&gt;
+    createResponse.resultCode match 
{
+      case Code.OK =&amp;gt; (true, 0)
+      case Code.NODEEXISTS =&amp;gt; (false, ZkVersion.UnknownVersion)
+      case _ =&amp;gt; throw createResponse.resultException.get
     }
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -1071,7 +1078,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
     */&lt;br/&gt;
   private def deleteAclChangeNotifications(aclChangePath: String, sequenceNodes: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;): Unit = {&lt;br/&gt;
     val deleteRequests = sequenceNodes.map &lt;/p&gt;
{ sequenceNode =&amp;gt;
-      DeleteRequest(s&quot;$aclChangePath/$sequenceNode&quot;, ZkVersion.NoVersion)
+      DeleteRequest(s&quot;$aclChangePath/$sequenceNode&quot;, ZkVersion.MatchAnyVersion)
     }

&lt;p&gt;     val deleteResponses = retryRequestsUntilConnected(deleteRequests)&lt;br/&gt;
@@ -1173,7 +1180,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
   def setOrCreateDelegationToken(token: DelegationToken): Unit = {&lt;/p&gt;

&lt;p&gt;     def set(tokenData: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;): SetDataResponse = &lt;/p&gt;
{
-      val setDataRequest = SetDataRequest(DelegationTokenInfoZNode.path(token.tokenInfo().tokenId()), tokenData, ZkVersion.NoVersion)
+      val setDataRequest = SetDataRequest(DelegationTokenInfoZNode.path(token.tokenInfo().tokenId()), tokenData, ZkVersion.MatchAnyVersion)
       retryRequestUntilConnected(setDataRequest)
     }

&lt;p&gt;@@ -1355,7 +1362,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@return sequence number as the broker id&lt;br/&gt;
     */&lt;br/&gt;
   def generateBrokerSequenceId(): Int = {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val setDataRequest = SetDataRequest(BrokerSequenceIdZNode.path, Array.empty&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;, -1)&lt;br/&gt;
+    val setDataRequest = SetDataRequest(BrokerSequenceIdZNode.path, Array.empty&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;, ZkVersion.MatchAnyVersion)&lt;br/&gt;
     val setDataResponse = retryRequestUntilConnected(setDataRequest)&lt;br/&gt;
     setDataResponse.resultCode match {&lt;br/&gt;
       case Code.OK =&amp;gt; setDataResponse.stat.getVersion&lt;br/&gt;
@@ -1384,7 +1391,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   private def setConsumerOffset(group: String, topicPartition: TopicPartition, offset: Long): SetDataResponse = &lt;/p&gt;
{
     val setDataRequest = SetDataRequest(ConsumerOffset.path(group, topicPartition.topic, topicPartition.partition),
-      ConsumerOffset.encode(offset), ZkVersion.NoVersion)
+      ConsumerOffset.encode(offset), ZkVersion.MatchAnyVersion)
     retryRequestUntilConnected(setDataRequest)
   }

&lt;p&gt;@@ -1404,7 +1411,7 @@ class KafkaZkClient private (zooKeeperClient: ZooKeeperClient, isSecure: Boolean&lt;br/&gt;
     getChildrenResponse.resultCode match {&lt;br/&gt;
       case Code.OK =&amp;gt;&lt;br/&gt;
         getChildrenResponse.children.foreach(child =&amp;gt; deleteRecursive(s&quot;$path/$child&quot;))&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val deleteResponse = retryRequestUntilConnected(DeleteRequest(path, ZkVersion.NoVersion))&lt;br/&gt;
+        val deleteResponse = retryRequestUntilConnected(DeleteRequest(path, ZkVersion.MatchAnyVersion))&lt;br/&gt;
         if (deleteResponse.resultCode != Code.OK &amp;amp;&amp;amp; deleteResponse.resultCode != Code.NONODE) 
{
           throw deleteResponse.resultException.get
         }
&lt;p&gt;diff --git a/core/src/main/scala/kafka/zk/ZkData.scala b/core/src/main/scala/kafka/zk/ZkData.scala&lt;br/&gt;
index d2b2333e705..f918b616024 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/main/scala/kafka/zk/ZkData.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/zk/ZkData.scala&lt;br/&gt;
@@ -436,7 +436,8 @@ object ConsumerOffset {&lt;br/&gt;
 }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; object ZkVersion &lt;/p&gt;
{
-  val NoVersion = -1
+  val MatchAnyVersion = -1 // if used in a conditional set, matches any version (the value should match ZooKeeper codebase)
+  val UnknownVersion = -2  // Version returned from get if node does not exist (internal constant for Kafka codebase, unused value in ZK)
 }

&lt;p&gt; object ZkStat {&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/zk/KafkaZkClientTest.scala b/core/src/test/scala/unit/kafka/zk/KafkaZkClientTest.scala&lt;br/&gt;
index df009e8136c..9cffb517c09 100644&lt;br/&gt;
&amp;#8212; a/core/src/test/scala/unit/kafka/zk/KafkaZkClientTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/zk/KafkaZkClientTest.scala&lt;br/&gt;
@@ -176,7 +176,7 @@ class KafkaZkClientTest extends ZooKeeperTestHarness {&lt;br/&gt;
     // test with non-existing path&lt;br/&gt;
     val (data0, version0) = zkClient.getDataAndVersion(path)&lt;br/&gt;
     assertTrue(data0.isEmpty)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertEquals(-1, version0)&lt;br/&gt;
+    assertEquals(ZkVersion.UnknownVersion, version0)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     // create a test path&lt;br/&gt;
     zkClient.createRecursive(path)&lt;br/&gt;
@@ -200,7 +200,7 @@ class KafkaZkClientTest extends ZooKeeperTestHarness {&lt;br/&gt;
     // test with non-existing path&lt;br/&gt;
     var statusAndVersion = zkClient.conditionalUpdatePath(path, &quot;version0&quot;.getBytes(UTF_8), 0)&lt;br/&gt;
     assertFalse(statusAndVersion._1)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertEquals(-1, statusAndVersion._2)&lt;br/&gt;
+    assertEquals(ZkVersion.UnknownVersion, statusAndVersion._2)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     // create path&lt;br/&gt;
     zkClient.createRecursive(path)&lt;br/&gt;
@@ -213,7 +213,7 @@ class KafkaZkClientTest extends ZooKeeperTestHarness &lt;/p&gt;
{
     // test with invalid expected version
     statusAndVersion = zkClient.conditionalUpdatePath(path, &quot;version2&quot;.getBytes(UTF_8), 2)
     assertFalse(statusAndVersion._1)
-    assertEquals(-1, statusAndVersion._2)
+    assertEquals(ZkVersion.UnknownVersion, statusAndVersion._2)
   }

&lt;p&gt;   @Test&lt;br/&gt;
@@ -446,7 +446,7 @@ class KafkaZkClientTest extends ZooKeeperTestHarness {&lt;br/&gt;
       // try getting acls for non-existing resource&lt;br/&gt;
       var versionedAcls = zkClient.getVersionedAclsForResource(resource1)&lt;br/&gt;
       assertTrue(versionedAcls.acls.isEmpty)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertEquals(-1, versionedAcls.zkVersion)&lt;br/&gt;
+      assertEquals(ZkVersion.UnknownVersion, versionedAcls.zkVersion)&lt;br/&gt;
       assertFalse(zkClient.resourceExists(resource1))&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;@@ -454,9 +454,15 @@ class KafkaZkClientTest extends ZooKeeperTestHarness {&lt;br/&gt;
       val acl2 = new Acl(new KafkaPrincipal(KafkaPrincipal.USER_TYPE, &quot;bob&quot;), Allow, &quot;*&quot;, Read)&lt;br/&gt;
       val acl3 = new Acl(new KafkaPrincipal(KafkaPrincipal.USER_TYPE, &quot;bob&quot;), Deny, &quot;host1&quot;, Read)&lt;/p&gt;

&lt;p&gt;+      // Conditional set should fail if path not created&lt;br/&gt;
+      assertFalse(zkClient.conditionalSetAclsForResource(resource1, Set(acl1, acl3), 0)._1)&lt;br/&gt;
+&lt;br/&gt;
       //create acls for resources&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;zkClient.conditionalSetOrCreateAclsForResource(resource1, Set(acl1, acl2), 0)&lt;/li&gt;
	&lt;li&gt;zkClient.conditionalSetOrCreateAclsForResource(resource2, Set(acl1, acl3), 0)&lt;br/&gt;
+      assertTrue(zkClient.createAclsForResourceIfNotExists(resource1, Set(acl1, acl2))._1)&lt;br/&gt;
+      assertTrue(zkClient.createAclsForResourceIfNotExists(resource2, Set(acl1, acl3))._1)&lt;br/&gt;
+&lt;br/&gt;
+      // Create should fail if path already exists&lt;br/&gt;
+      assertFalse(zkClient.createAclsForResourceIfNotExists(resource2, Set(acl1, acl3))._1)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       versionedAcls = zkClient.getVersionedAclsForResource(resource1)&lt;br/&gt;
       assertEquals(Set(acl1, acl2), versionedAcls.acls)&lt;br/&gt;
@@ -464,7 +470,7 @@ class KafkaZkClientTest extends ZooKeeperTestHarness {&lt;br/&gt;
       assertTrue(zkClient.resourceExists(resource1))&lt;/p&gt;

&lt;p&gt;       //update acls for resource&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;zkClient.conditionalSetOrCreateAclsForResource(resource1, Set(acl1, acl3), 0)&lt;br/&gt;
+      assertTrue(zkClient.conditionalSetAclsForResource(resource1, Set(acl1, acl3), 0)._1)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;       versionedAcls = zkClient.getVersionedAclsForResource(resource1)&lt;br/&gt;
       assertEquals(Set(acl1, acl3), versionedAcls.acls)&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 14 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3wtkn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>junrao</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>