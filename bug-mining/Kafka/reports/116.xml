<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 16:36:02 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-506] Store logical offset in log</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-506</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Currently we only support retention by dropping entire segment files. A more nuanced retention policy would allow dropping individual messages from a segment file by recopying it. This is not currently possible because the lookup structure we use to locate messages is based on the file offset directly.&lt;/p&gt;

&lt;p&gt;To fix this we should move to a sequential, logical offset (0,1,2,3,...) which would allow deleting individual messages (e.g. 2) without deleting the entire segment.&lt;/p&gt;

&lt;p&gt;It is desirable to make this change in the 0.8 timeframe since we are already doing data format changes.&lt;/p&gt;

&lt;p&gt;As part of this we would explicitly store the key field given by the producer for partitioning (right now there is no way for the consumer to find the value used for partitioning).&lt;/p&gt;

&lt;p&gt;This combination of features would allow a key-based retention policy that would clean obsolete values either by a user defined key.&lt;/p&gt;

&lt;p&gt;The specific use case I am targeting is a commit log for local state maintained by a process doing some kind of near-real-time processing. The process could log out its local state changes and be able to restore from this log in the event of a failure. However I think this is a broadly useful feature.&lt;/p&gt;

&lt;p&gt;The following changes would be part of this:&lt;br/&gt;
1. The log format would now be&lt;br/&gt;
      8 byte offset&lt;br/&gt;
      4 byte message_size&lt;br/&gt;
      N byte message&lt;br/&gt;
2. The offsets would be changed to a sequential, logical number rather than the byte offset (e.g. 0,1,2,3,...)&lt;br/&gt;
3. A local memory-mapped lookup structure will be kept for each log segment that contains the mapping from logical to physical offset.&lt;/p&gt;

&lt;p&gt;I propose to break this into two patches. The first makes the log format changes, but retains the physical offset. The second adds the lookup structure and moves to logical offset.&lt;/p&gt;

&lt;p&gt;Here are a few issues to be considered for the first patch:&lt;br/&gt;
1. Currently a MessageSet implements Iterable&lt;span class=&quot;error&quot;&gt;&amp;#91;MessageAndOffset&amp;#93;&lt;/span&gt;. One surprising thing is that the offset is actually the offset of the next message. I think there are actually several uses for the current offset. I would propose making this hold the current message offset since with logical offsets the next offset is always just current_offset+1. Note that since we no longer require messages to be dense, it is not true that if the next offset is N the current offset is N-1 (because N-1 may have been deleted). Thoughts or objections?&lt;br/&gt;
2. Currently during iteration over a ByteBufferMessageSet we throw an exception if there are zero messages in the set. This is used to detect fetches that are smaller than a single message size. I think this behavior is misplaced and should be moved up into the consumer.&lt;br/&gt;
3. In addition to adding a key in Message, I made two other changes: (1) I moved the CRC to the first field and made it cover the entire message contents (previously it only covered the payload), (2) I dropped support for Magic=0, effectively making the attributes field required, which simplifies the code (since we are breaking compatibility anyway).&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12607147">KAFKA-506</key>
            <summary>Store logical offset in log</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jkreps">Jay Kreps</assignee>
                                    <reporter username="jkreps">Jay Kreps</reporter>
                        <labels>
                    </labels>
                <created>Tue, 11 Sep 2012 23:23:52 +0000</created>
                <updated>Thu, 16 Nov 2017 10:04:09 +0000</updated>
                            <resolved>Mon, 8 Oct 2012 19:15:32 +0000</resolved>
                                    <version>0.8.0</version>
                                    <fixVersion>0.8.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="13455324" author="jkreps" created="Thu, 13 Sep 2012 21:27:33 +0000"  >&lt;p&gt;Add key to message and reorder some fields&lt;br/&gt;
Bump up Message magic number to 2&lt;br/&gt;
Add offset to MessageSet format&lt;br/&gt;
Make MessageAndOffset contain the current offset and add a nextOffset() method to get the next offset&lt;br/&gt;
Some misc. cleanups (delete some obsolete files, fix bad formatting)&lt;/p&gt;

&lt;p&gt;There are still two problems with this patch:&lt;br/&gt;
1. Not handling offsets properly in compressed messages&lt;br/&gt;
2. Unit test failures in LogRecoveryTest&lt;/p&gt;</comment>
                            <comment id="13456203" author="jkreps" created="Fri, 14 Sep 2012 22:41:43 +0000"  >&lt;p&gt;Updated the patch. This patch fixes the remaining failing tests and correctly handles compressed messages.&lt;/p&gt;

&lt;p&gt;This patch is ready for review.&lt;/p&gt;</comment>
                            <comment id="13456207" author="jkreps" created="Fri, 14 Sep 2012 22:42:17 +0000"  >&lt;p&gt;I am going to begin phase two of this, implementing the logical offset management in Log.&lt;/p&gt;</comment>
                            <comment id="13456744" author="junrao" created="Mon, 17 Sep 2012 03:47:47 +0000"  >&lt;p&gt;Thanks for patch v1. Overall, the log format change is reasonable. Some comments:&lt;/p&gt;

&lt;p&gt;1. MessageAndOffset: nextOffset is not correct for compressed messages. Currently, in the high-level consumer, after iterating each message, the consume offset is moved to the offset of the next message. So, if one consumes a message and then commits the offset, the committed offset points to the next message to be consumed. We could probably change the protocol to move the consumer offset to the offset of the current message. Then, the caller will need to commit the offset first and then consumes the message to get the same semantics.&lt;/p&gt;

&lt;p&gt;2. Message:&lt;br/&gt;
2.1 The comment of the message has a bug. Payload should have (N- K - 10) bytes.&lt;br/&gt;
2.2 In constructor, should we assert that offset is btw 0 and bytes.length-1? Also, just to be clear that offset and size are for the payload, should we rename bytes, offset and size to something like payload, payloadOffset and payloadSize?&lt;br/&gt;
2.3 computeChecksum(): can use MagicOffset for both starting offset and length&lt;br/&gt;
2.4 remove unused import&lt;/p&gt;

&lt;p&gt;3. MessageSet: Fix the comment in second line &quot;A The format&quot;.&lt;/p&gt;

&lt;p&gt;4. ByteBufferMessageSet: remove unused comment&lt;/p&gt;

&lt;p&gt;5. Log:&lt;br/&gt;
5.1 append(): For verifying message size, we need to use the shallow iterator since a compressed message has to be smaller than the configured max message size.&lt;br/&gt;
5.2 append(): Compressed messages are forced to be decompressed and then compressed again. This will introduce some CPU overhead. What&apos;s the increase in CPU utilization if incoming messages are compressed? Also, for replicaFetchThread, it can just put the data fetched from the leader directly into the log without recomputing the offsets. Could we add a flag in append to bypass regenerating the offsets?&lt;br/&gt;
5.3 trimInvalidBytes(): There is a bug in the following statement: messages.size should be messages.sizeInBytes.&lt;br/&gt;
    if(messageSetValidBytes == messages.size) {&lt;/p&gt;

&lt;p&gt;6. javaapi.ByteBufferMessageSet: Java users shouldn&apos;t really be using buffer. So, we don&apos;t need the bean property.&lt;/p&gt;

&lt;p&gt;7. PartitionData: Do we need to override equal and hash since this is already a case class?&lt;/p&gt;

&lt;p&gt;8. ZkUtils.conditionalUpdatePersistenPath(): This method expects exception due to version conflict. So there is no need to log the exception.&lt;/p&gt;

&lt;p&gt;9. SyncProducerTest: remove unused imports&lt;/p&gt;

&lt;p&gt;10. How do we handle the case that a consumer uses too small a fetch size?&lt;/p&gt;</comment>
                            <comment id="13457106" author="jkreps" created="Mon, 17 Sep 2012 15:57:48 +0000"  >&lt;p&gt;Great feedback, thanks.&lt;/p&gt;

&lt;p&gt;1. Good point about nextOffset. I think this is slightly tricky to fix. I think I will ignore this problem and work on phase 2 which will fix that issue by making nextOffset=offset+1. This means taking both patches at once which will be a bit big. Sound feasible?&lt;br/&gt;
2-4 Good feedback&lt;br/&gt;
5.1. Good point.&lt;br/&gt;
5.2. I will do a little micro-benchmark on decompression/re-compression. Yes, we can definitely avoid this for the replica fetcher thread. Depending on how much we want to optimize that path there are a lot of options. On the extreme side of total trust I think it might actually possible to do FileChannel.transferTo directly from the socket buffer, though there are complications around metrics and hw mark. I think for now it makes sense to just skip decompression. One question: let&apos;s say recompression turns out to be expensive, there are two options: (1) do not set internal offsets (as today), (2) eat the cost and recommend snappy instead of gzip. Personally I prefer (2) since I think we need to fix the correctness bugs, but I am open to implementing either if there is a consensus.&lt;br/&gt;
5.3. Good catch&lt;br/&gt;
6. OK&lt;br/&gt;
7. I am not sure. We had a custom implementation of equals but no hashcode which I think was likely wrong. We can remove both, but I would want to figure out why we added the equals.&lt;br/&gt;
8-9. OK&lt;br/&gt;
10. Ah, forgot to add that. I think the right thing is just to check (currentDataChunk.messages.size &amp;gt; 0 &amp;amp;&amp;amp; currentDataChunk.buffer.size == fetchSize) throw Exception() in the ConsumerIterator. The only thing to consider is that this means there is no check for the simpleconsumer.&lt;/p&gt;</comment>
                            <comment id="13457338" author="junrao" created="Mon, 17 Sep 2012 21:16:50 +0000"  >&lt;p&gt;Actually, there is another thing.&lt;/p&gt;

&lt;p&gt;11. We need to change DefaultEventHandler to put the key data into messages sent to the broker. Also, Producer currently can take any type as key, do we want to restrict it to bytes or do we want to define a serializer for key too?&lt;/p&gt;</comment>
                            <comment id="13459975" author="nehanarkhede" created="Thu, 20 Sep 2012 21:17:19 +0000"  >&lt;p&gt;Thanks for the patch ! The log format change doesn&apos;t interfere with replication as of this patch. A few comments in addition to Jun&apos;s -&lt;/p&gt;

&lt;p&gt;1. CompressionUtils: How about re-using the ByteBufferMessageSet.writeMessage() API for serializing the compressed message to a byte buffer ?&lt;/p&gt;

&lt;p&gt;2. ByteBufferMessageSet.scala, FileMessageSet: Can we use MessageSet.LogOverhead instead of 12 for byte arithmetic ?&lt;/p&gt;

&lt;p&gt;3. ConsumerIterator&lt;br/&gt;
The nextOffset issue for compressed message sets will get resolved when we actually use the sequential logical offsets. With that, the advantage is that the consumer will be able to fetch a message even if it is inside a compressed message. Today, there is no good way to achieve this unless we have level-2 message offsets for compressed messages. Even if we cannot make that change in time for replication, we can take this change and leave the message set iterator to return the next offset (valid fetch offset), just like we do today. So, either way, we are covered here.&lt;/p&gt;</comment>
                            <comment id="13464469" author="jkreps" created="Thu, 27 Sep 2012 05:44:23 +0000"  >&lt;p&gt;This patch is incremental from the previous one. I will rebase and provide an up-to-date patch that covers both phases, but this shows the new work required to support logical offsets.&lt;/p&gt;

&lt;p&gt;I think I have addressed most of the comments on the original patch, except:&lt;br/&gt;
1. I have put off any performance optimization (avoiding recompression for replicas, memory-mapping the log, etc). I would like to break this into a separate JIRA and write a reasonable standalone Log benchmark that covers these cases and then work against that. I have several other cleanups I would like to do as well: (1) get rid of SegmentList, (2) move more functionality in Log into LogSegment.&lt;br/&gt;
2. I am not yet storing the key in the message, this may change the produce api slightly so i think this should be a seperate JIRA too.&lt;br/&gt;
3. Neha--I change most of the uses of magical numbers except where the concrete number is more clear.&lt;/p&gt;

&lt;p&gt;Here is a description of the new changes.&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Offset now always refers to a logical log offset. I have tried to change any instances where offset meant file offset to instead use the terminology &quot;position&quot;. References to file positions should only occur in Log.scala and classes internal to that.&lt;/li&gt;
	&lt;li&gt;As in the previous patch MessageAndOffset gives three things: (1) the message, (2) the offset of THAT message, and (3) a helper method to calculate the next offset.&lt;/li&gt;
	&lt;li&gt;Log.append() is responsible for maintaining the logEndOffset and using it to assign offsets to the messageset before appending to the log.&lt;/li&gt;
	&lt;li&gt;Offsets are now assigned to compressed messages too. One nuance is that the offset of the wrapper message is equal to the last offset of the messages it contains. This will be more clear in the discussion of the offset search changes.&lt;/li&gt;
	&lt;li&gt;Log.read now accepts a new argument maxOffset, which is the largest (logical) offset that will be returned in addition to the maxSize which limits the size in bytes.&lt;/li&gt;
	&lt;li&gt;I have changed Log.read to now support sparse offsets. That is, it is valid to have missing offsets. This sparseness is needed both for the key-retention but also for the correct handling of compressed messages. I will describe the read path in more detail below.&lt;/li&gt;
	&lt;li&gt;I moved FileMessageSet to the package kafka.log as already much of its functionality was specific to the log implementation.&lt;/li&gt;
	&lt;li&gt;I changed FetchPurgatory back to use a simple counter for accumulated bytes. It was previously re-calculating the available bytes, but because this now is a more expensive operation, and because this calculation is redone for each topic/partition produce (i.e. potentially 200 times per produce request), I think this is better. This is less accurate, but since long poll is a heuristic anyway I think that is okay.&lt;/li&gt;
	&lt;li&gt;I changed the default suffix of .kafka files to .log and added a new .index file that contains a sparse index of offset=&amp;gt;file_position to help efficiently resolve logical offsets.&lt;/li&gt;
	&lt;li&gt;Entries are added to this index at a configurable frequency, controlled by a new configuration log.index.interval.bytes which defaults to 4096&lt;/li&gt;
	&lt;li&gt;I removed numerous instances of byte calculations. I think this is a good thing for code quality.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Here is a description of the new read path.&lt;br/&gt;
1. First log tries to find the correct segment to read from using the existing binary search on log segments. I modified this search slightly in two ways. First we had a corner case bug which only occurred if you have two files with successive offsets (unlikely now, impossible before). Second, I now no longer check ranges but instead return the largest segment file less than or equal to the requested offset.&lt;br/&gt;
2. Once the segment is found we check the index on that segment. The index returns the largest offset less than or equal to the requested offset and the associated file position in the log file. This position represents a least upper bound on the position in the file, and it is the position from which we begin a linear search checking each message. The index itself is just a sorted sequence of (offset, position) pairs. Complete details are in the header comments on kafka.log.OffsetIndex.scala. It is not required that all messages have an entry in the OffsetIndex, instead there is a confgurable frequency in terms of bytes which is set in LogSegment. So, for example, we might have an entry every 4096 bytes. This frequency is approximate, since a single message may be larger than that.&lt;br/&gt;
3. Once we have a greatest lower bound on the location we use FileMessageSet.searchFor to search for the position of the first message with an offset at least as large as the target offset. This search just skips through the file checking the offset only.&lt;/p&gt;</comment>
                            <comment id="13465262" author="jkreps" created="Fri, 28 Sep 2012 01:05:17 +0000"  >&lt;p&gt;Okay attached a fully rebased patch that contains both phase 1 and phase 2 changes.&lt;/p&gt;</comment>
                            <comment id="13465936" author="jkreps" created="Fri, 28 Sep 2012 21:54:31 +0000"  >&lt;p&gt;Three preliminary comments from Neha while she does deeper interogations:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Would be nice if the DumpLogSegment tool also dumped the contents of the index file&lt;/li&gt;
	&lt;li&gt;This patch implicitly assumes file segments are limited to 2GB (I use a 4 byte position pointer in the index). Turns out this isn&apos;t true. Proposed fix is to limit log segments to 2GB.&lt;/li&gt;
	&lt;li&gt;We decided the corner case with sparse messages at the end of a segment isn&apos;t really a corner case as it effects compressed messages too. So I will fix that in the scope of this patch.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13465976" author="nehanarkhede" created="Fri, 28 Sep 2012 22:43:30 +0000"  >&lt;p&gt;2 additions to the preliminary comments -&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;3 unit tests fail on patch v2 - &lt;a href=&quot;http://pastebin.com/ECUA2n1f&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://pastebin.com/ECUA2n1f&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;It will be nice for maxIndexEntries to be a configurable property on the server&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13466626" author="junrao" created="Mon, 1 Oct 2012 03:55:56 +0000"  >&lt;p&gt;Thanks for patch v2. Some more comments:&lt;/p&gt;

&lt;p&gt;20. Log:&lt;br/&gt;
20.1 findRange(): Add to the comment that now this method returns the largest segment file &amp;lt;= the requested offset.&lt;br/&gt;
20.2 close(): move the closing } for the for loop to a new line.&lt;br/&gt;
20.3 bytesSinceLastIndexEntry is only set but is never read.&lt;br/&gt;
20.4 append(): This method returns the offset of the first message to be appended. This is ok for the purpose of returning the offset to the producer. However, when determining whether all replicas have received the appended messages, we need to use the log end offset after the messages are appended. So, what we should do is to have append() return 2 offsets, one before the append and one after the append. We use the former in producer response and use the latter for the replica check. To avoid complicating this patch further, another approach is to, in the jira, have append return the log end offset after the append and use it in both producer response and replica check. We can file a separate jira to have append return 2 offsets.&lt;br/&gt;
20.5 read(): The trace statement: last format pattern should be %d instead of %s.&lt;br/&gt;
20.6 truncateTo(): The usage of logEndOffset in the following statement is incorrect. It should be the offset of the next segment.&lt;br/&gt;
          segments.view.find(segment =&amp;gt; targetOffset &amp;gt;= segment.start &amp;amp;&amp;amp; targetOffset &amp;lt; logEndOffset)&lt;br/&gt;
20.7 There are several places where we need to create a log segment and the code for creating the new data file and the new index file is duplicate. Could we create a utility function createNewSegment to share the code?&lt;/p&gt;

&lt;p&gt;21. LogSegment: bytesSinceLastIndexEntry needs to be updated in append().&lt;/p&gt;

&lt;p&gt;22. FileMessageSet.searchFor(): The following check seems to be a bit strange. Shouldn&apos;t we use position + 12 or just position instead?&lt;br/&gt;
    while(position + 8 &amp;lt; size) {&lt;/p&gt;

&lt;p&gt;23. OffsetIndex:&lt;br/&gt;
23.1 In the comment, &quot;mutable index can be created to&quot; seems to have a grammar bug.&lt;br/&gt;
23.2 mmap initialization: The following statement seems unnecessary. However, we do need to set the mapped buffer&apos;s position to end of file for mutable indexes. &lt;br/&gt;
          idx.position(idx.limit).asInstanceOf&lt;span class=&quot;error&quot;&gt;&amp;#91;MappedByteBuffer&amp;#93;&lt;/span&gt;&lt;br/&gt;
23.3 append(): If index entry is full, should we automatically roll the log segment? It&apos;s ok if this is tracked in a separate jira.&lt;br/&gt;
23.4 makeReadOnly(): should we call flush after raf.setLength()? Also, should we remap the index file to the current length and make it read only?&lt;/p&gt;

&lt;p&gt;24. LogManager.shutdown(): log indentation already adds LogManager in the prefix of each log entry.&lt;/p&gt;

&lt;p&gt;25. KafkaApis:&lt;br/&gt;
25.1 handleFetchRequest: topicDatas is weird since data is the plural form of datum. How about topicDataMap?&lt;br/&gt;
25.2 ProducerRequestPurgatory: It seems that it&apos;s useful to keep the logIndent since it can distinguish logs from the ProducerRequestPurgatory and FetchRequestPurgatory. Also, it&apos;s probably useful to pass in brokerId to RequestPurgatory for debugging unit tests.&lt;/p&gt;

&lt;p&gt;26. Partition: There are a few places that the first character of info log is changed to lower case. The current convention is to already use upper case.&lt;/p&gt;

&lt;p&gt;27. javaapi.ByteBufferMessageSet: underlying should be private val.&lt;/p&gt;

&lt;p&gt;28. DumpLogSegment: Now that each message stores an offset, we should just print the offset in MessageAndOffset. There is no need for var offset now.&lt;/p&gt;

&lt;p&gt;29. FetchedDataChunk: No need to use val for parameters in constructor since this is a case class now.&lt;/p&gt;

&lt;p&gt;30. PartitionData:&lt;br/&gt;
30.1 No need to redefine equals and hashcode since this is already a case class.&lt;br/&gt;
30.2 initialOffset is no longer needed.&lt;/p&gt;

&lt;p&gt;31. PartitionTopicInfo.enqueue(): It seems that next can be computed using shallow iterator since the offset of a compressed message is always the offset of the last internal message.&lt;/p&gt;

&lt;p&gt;32. ByteBufferMessageSet: In create() and decompress(), we probably should close the output and the input stream in a finally clause in case we hit any exception during compression and decompression.&lt;/p&gt;

&lt;p&gt;33. remove unused imports.&lt;/p&gt;

&lt;p&gt;The following comment from the first round of review is still not addressed.&lt;br/&gt;
10. How do we handle the case that a consumer uses too small a fetch size?&lt;/p&gt;</comment>
                            <comment id="13468094" author="jkreps" created="Tue, 2 Oct 2012 21:33:08 +0000"  >&lt;p&gt;New patch with a few new things:&lt;/p&gt;

&lt;p&gt;I rebased a few more times to pick up changes.&lt;/p&gt;

&lt;p&gt;WRT Neha&apos;s comments:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;I made maxIndexEntries configurable by adding the property log.index.max.size. I did this in terms of index file size rather than entries since the user doesn&apos;t really know the entry size but may care about the file size.&lt;/li&gt;
	&lt;li&gt;For the failing tests: (1) The message set failure is due to scalatest not handling parameterized tests, i had fixed this but somehow it didn&apos;t make it into the previous patch. It is in the current one. testHWCheckpointWithFailuresSingleLogSegment is a timing assumption in that test. Fixed it by adding a sleep &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. The producer test failure I cannot reproduce.&lt;/li&gt;
	&lt;li&gt;Wrote a test case using compressed messages to try to produce the corner case at the end of a segment. But actually this turns out not to be possible with compressed messages since the numbering is by the last offset. So effectively our segments are always dense right now. As such I would rather wait until I refactor segment list to fix it since it will be duplicate work otherwise.&lt;/li&gt;
	&lt;li&gt;Turns out that log segments are limited to 2GB already, via a restriction in the config. Not actually sure why this is. Given this limitation one cleanup that might be nice to do would be to convert MessageSet.sizeInBytes to an Int, which would remove a lot of casts. Since this is an unrelated cleanup I will not do it in this patch.&lt;/li&gt;
	&lt;li&gt;I added support to DumpLogSegment tool to display the index file. I had to revert Jun&apos;s change to check that last offset=file size since this is no longer true.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Jun&apos;s Comments:&lt;br/&gt;
First of all, this is an impressively thorough code review. Thanks!&lt;br/&gt;
20.1 Made the Log.findRange comment more reflective of what the method does. I hope to remove this entirely in the next phase.&lt;br/&gt;
20.2 Fixed mangled paren in close()&lt;br/&gt;
20.3 bytesSinceLastIndexEntry. Yes, good catch. This is screwed up. This was moved into LogSegment, but the read and update are split in two places. Fixed.&lt;br/&gt;
20.4 append(): &quot;We need to have both the begin offset and the end offset returned by Log.append()&quot;. Made Log.append return (Long, Long). I am not wild about this change, but I see the need. I had to refactor KafkaApis slightly since we were constructing an intermediate response object in the produceToLocalLog method (which was kind of weird anyway) so there was only one offset and since this is an API object we can&apos;t change it. I think the use of API objects in the business logic is a bit dangerous for this reason.&lt;br/&gt;
20.5 Fixed broken log statement to use correct format param.&lt;br/&gt;
20.6 truncateTo(): The usage of logEndOffset in the following statement is incorrect. Changed this to use Log.findInRange which I think is the intention.&lt;br/&gt;
20.7 &quot;There are several places where we need to create a log segment and the code for creating the new data file and the new index file is duplicate. Could we create a utility function createNewSegment to share the code?&quot; Good idea, done. There is still a lot more refactoring that could be done between Log and LogSegment, but I am kind of putting that off.&lt;br/&gt;
21. LogSegment: &quot;bytesSinceLastIndexEntry needs to be updated in append().&quot; Fixed.&lt;br/&gt;
22. FileMessageSet.searchFor() fixed bad byte arithmetic.&lt;br/&gt;
23. OffsetIndex:&lt;br/&gt;
23.1 Fixed bad english in comment&lt;br/&gt;
23.2 mmap initialization: Yes, this doesn&apos;t make sense. The correct logic is that the mutable case must be set to index 0, and the read-only case doesn&apos;t matter. This was happening implicitly since byte buffers initialize to 0, but I switched it to make it explicit.&lt;br/&gt;
23.3 append(): &quot;If index entry is full, should we automatically roll the log segment?&quot; This is already handled in Log.maybeRoll(segment) which checks segment.index.isFull&lt;br/&gt;
23.4 makeReadOnly(): &quot;should we call flush after raf.setLength()?&quot; This is a good point. I think&lt;br/&gt;
what you are saying is that the truncate call itself needs the metadata to flush to be considered stable. Calling force on the mmap after the setLength won&apos;t do this. Instead I changed the file open to use synchronous mode &quot;rws&quot; which should automatically fsync metadata when we call setLength. The existing flush is okay: I verified that flush doesn&apos;t cause the sparse file to desparsify or anything like that. &quot;Also, should we remap the index file to the current length and make it read only?&quot; Well, this isn&apos;t really needed. There is no problem with truncating a file post mmap, but I guess making the mapping read-only could prevent corruption due to any bugs we might have so I made that change.&lt;br/&gt;
LogManager&lt;br/&gt;
24. &quot;log indentation already adds LogManager in the prefix of each log entry.&quot; Oops.&lt;br/&gt;
25. KafkaApis:&lt;br/&gt;
25.1 &quot;handleFetchRequest: topicDatas is weird since data is the plural form of datum. How about topicDataMap?&quot; Changed to dataRead (I don&apos;t like having the type in the name).&lt;br/&gt;
25.2 &quot;ProducerRequestPurgatory: It seems that it&apos;s useful to keep the logIndent since it can distinguish logs from the ProducerRequestPurgatory and FetchRequestPurgatory. Also, it&apos;s probably useful to pass in brokerId to RequestPurgatory for debugging unit tests.&quot; Agreed, accidentally removed this; added it back.&lt;br/&gt;
26. &quot;Partition: There are a few places that the first character of info log is changed to lower case. The current convention is to already use upper case.&quot; Made all upper case.&lt;br/&gt;
27. &quot;javaapi.ByteBufferMessageSet: underlying should be private val.&quot; Changed.&lt;br/&gt;
28. &quot;DumpLogSegment: Now that each message stores an offset, we should just print the offset in MessageAndOffset. There is no need for var offset now.&quot; Removed.&lt;br/&gt;
29. &quot;FetchedDataChunk: No need to use val for parameters in constructor since this is a case class now.&quot; Wait is everything a val in a case class? I made this change, but don&apos;t know what it means...&lt;br/&gt;
30. PartitionData:&lt;br/&gt;
30.1 &quot;No need to redefine equals and hashcode since this is already a case class.&quot; Yeah, this was fixing a bug in the equals/hashcode stuff due to the array that went away when i rebased. Removed it&lt;br/&gt;
30.2 &quot;initialOffset is no longer needed.&quot; I think PartitionData is also used by ProducerRequest. This is a bug, but I think we do need the initial offset for the other case. Until we separate these two I don&apos;t think I can remove it.&lt;br/&gt;
31. &quot;PartitionTopicInfo.enqueue(): It seems that next can be computed using shallow iterator.&quot; Ah, very nice. Changed that.&lt;br/&gt;
32. &quot;ByteBufferMessageSet: In create() and decompress(), we probably should close the output and the input stream in a finally clause in case we hit any exception during compression and decompression.&quot; These are not real output streams. I can close them, but they are just arrays so I think it is just noise, no?&lt;br/&gt;
33. &quot;remove unused imports.&quot; Eclipse doesn&apos;t identify them, will swing by.&lt;br/&gt;
34. &quot;How do we handle the case that a consumer uses too small a fetch size?&quot; Added a check and throw for this in ConsumerIterator.&lt;/p&gt;</comment>
                            <comment id="13468095" author="jkreps" created="Tue, 2 Oct 2012 21:33:45 +0000"  >&lt;p&gt;Ran system test, passes:&lt;/p&gt;


&lt;p&gt;2012-10-02 14:11:50,376 - INFO - ======================================================&lt;br/&gt;
2012-10-02 14:11:50,376 - INFO - stopping all entities&lt;br/&gt;
2012-10-02 14:11:50,376 - INFO - ======================================================&lt;/p&gt;

&lt;p&gt;2012-10-02 14:12:43,105 - INFO - =================================================&lt;br/&gt;
2012-10-02 14:12:43,105 - INFO -                  TEST REPORTS&lt;br/&gt;
2012-10-02 14:12:43,105 - INFO - =================================================&lt;br/&gt;
2012-10-02 14:12:43,105 - INFO - test_case_name : testcase_1&lt;br/&gt;
2012-10-02 14:12:43,105 - INFO - test_class_name : ReplicaBasicTest&lt;br/&gt;
2012-10-02 14:12:43,105 - INFO - validation_status : &lt;br/&gt;
2012-10-02 14:12:43,105 - INFO -     Leader Election Latency - iter 2 brokerid 3 : 49636.00 ms&lt;br/&gt;
2012-10-02 14:12:43,105 - INFO -     Validate leader election successful : PASSED&lt;br/&gt;
2012-10-02 14:12:43,106 - INFO -     Unique messages from consumer : 850&lt;br/&gt;
2012-10-02 14:12:43,106 - INFO -     Validate for data matched : PASSED&lt;br/&gt;
2012-10-02 14:12:43,106 - INFO -     Unique messages from producer : 850&lt;br/&gt;
2012-10-02 14:12:43,106 - INFO -     Leader Election Latency - iter 1 brokerid 2 : 354.00 ms&lt;/p&gt;</comment>
                            <comment id="13468350" author="junrao" created="Wed, 3 Oct 2012 05:08:58 +0000"  >&lt;p&gt;Thanks for patch v3. We are almost there. A few more comments:&lt;/p&gt;

&lt;p&gt;40. Log.append: It seems that it&apos;s easier if lastOffset returned is just nextOffset instead of nextOffset -1. Then, in KafkaApis, we can just pass end, instead of end+1 to ProducerResponseStatus.&lt;/p&gt;

&lt;p&gt;41. OffsetIndex: When initializing mmap, if the index is mutable, shouldn&apos;t we move the position to the end of the buffer for append operations?&lt;/p&gt;

&lt;p&gt;42. KafkaApis: It&apos;s useful to pass in brokerId to RequestPurgatory for debugging unit tests.&lt;/p&gt;

&lt;p&gt;43. DumpLogSegments: Currently, the message iterator in FileMessageSet will stop when it hits the first non parsable message. So, we need to check if at the end of the message iteration, location == FileMessageSet.sizeInBytes(). If not, we should report the offset from which data is corrupted.&lt;/p&gt;

&lt;p&gt;44. ConsumerIterator: The check for guarding small fetch size doesn&apos;t work. This is because in PartitionTopicInfo.enqueue(), we only add ByteBufferMessageSet that has positive valid bytes. We can log an error in PartitionTopicInfo.enqueue() and enqueue a special instance of FetchedDataChunk that indicates an error. In ConsumerIterator, when seeing the special FetchedDataChunk, it can throw an exception.&lt;/p&gt;

&lt;p&gt;29. Yes, all parameters in the constructor in a case class are implicitly val.&lt;/p&gt;</comment>
                            <comment id="13468644" author="junrao" created="Wed, 3 Oct 2012 16:09:08 +0000"  >&lt;p&gt;There is another issue:&lt;/p&gt;

&lt;p&gt;45. ConsumerIterator: Now that we index each message inside a compressed message, we need to handle the case when a fetch request starting on an offset in the middle of a compressed message. In makeNext(), we need to first skip messages whose offset is less than currentDataChunk.fetchOffset. Otherwise, the consumer would get duplicates. We probably can do this in a followup jira since currently the consumer can get duplicates on compressed messages too.&lt;/p&gt;
</comment>
                            <comment id="13468822" author="jkreps" created="Wed, 3 Oct 2012 20:52:34 +0000"  >&lt;p&gt;Here is a new patch that addresses these comments. I also did an incremental diff against the previous patch so you can see the specific changes for the below items (that is &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-506&quot; title=&quot;Store logical offset in log&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-506&quot;&gt;&lt;del&gt;KAFKA-506&lt;/del&gt;&lt;/a&gt;-v4-changes-since-v3.patch)&lt;/p&gt;

&lt;p&gt;Also rebased again.&lt;/p&gt;

&lt;p&gt;40. I actually disagree. It is more code to add and subtract, but I think it makes more sense. This way we would say the append api returns &quot;the first and last offset for the messages you appended&quot; rather than &quot;the first offset for the messages you appended and the offset of the next message that would be appended&quot;. This is not a huge deal so I can go either way, but I did think about it both ways and that was my rationale.&lt;/p&gt;

&lt;p&gt;41. My thinking was that there were only two cases: re-creating a new, mutable index (at position 0) and opening a read-only index. In reality there are three cases: in addition to the previous two you can be re-opening an existing log that went through clean shutdown. I was not handling this properly and in fact was truncating the index on re-open, so the existing entries in the last segment would be unindexed. There are now two cases for mutable indexes. Recall that on clean-shutdown the index is always truncated to the max valid entry. So now when we open an index, if the file exists, I set the position to the end of the file. If the file doesn&apos;t exist I allocate it and start at position 0. The recovery process well still re-create the index if it runs, if the shutdown was clean then we will just roll to a new segment on the first append (since the index was truncated, it is now full).&lt;/p&gt;

&lt;p&gt;43. I removed that feature since the iterator only has the offset not the file position. However after thinking about it I can add it back by just using MessageSet.entrySize(message) on each entry and use the sum of these to compare to the messageSet.sizeInBytes. Added that.&lt;/p&gt;

&lt;p&gt;44. Changed the check to be the messageSet.sizeInBytes. This check was really meant to guard the case where we are at the end of the log and get an empty set. I think it was using validBytes because it needed to calculate the next offset. Now that calculation is gone, so I think it is okay to just use messageSet.sizeInBytes. This would result in a set with 0 valid bytes being enqueued, and then the error getting thrown to the consumer. The fetcher would likely continue to fetch this message set, but that should be bounded by the consumer queue size.&lt;/p&gt;

&lt;p&gt;45. The behavior after this patch should be exactly the same as the current behavior, so my hope was to do this as a follow up patch.&lt;/p&gt;

&lt;p&gt;Also: Found that I wasn&apos;t closing the index when the log was closed, and found a bug in the index re-creation logic in recovery; fixed both, and expanded tests for this.&lt;/p&gt;</comment>
                            <comment id="13468896" author="junrao" created="Wed, 3 Oct 2012 22:01:30 +0000"  >&lt;p&gt;Patch v4 looks good overall. A couple of remaining issues:&lt;/p&gt;

&lt;p&gt;50. testCompressionSetConsumption seems to fail transiently for me with the following exception. This seems to be related to the change made for #44.&lt;br/&gt;
kafka.common.MessageSizeTooLargeException: The broker contains a message larger than the maximum fetch size of this consumer. Increase the fetch size, or decrease the maximum message size the broker will allow.&lt;br/&gt;
	at kafka.consumer.ConsumerIterator.makeNext(ConsumerIterator.scala:87)&lt;/p&gt;

&lt;p&gt;51. ConsumerIterator: When throwing MessageSizeTooLargeException, could we add the topic/partition/offset to the message string in the exception?&lt;/p&gt;</comment>
                            <comment id="13469525" author="jkreps" created="Thu, 4 Oct 2012 17:22:07 +0000"  >&lt;p&gt;Rebased again and fixed the above issues to make v5&lt;/p&gt;

&lt;p&gt;50. I looked into this. It is slightly subtle. The problem was that validBytes is cached in a local variable, and the incremental computation was done on the member variable in ByteBufferMessageSet. The next problem was that AbstractFetcherThread and the ConsumerIterator could both be calling this at the same time, which would lead to setting validBytes to 0 and then iterating over the messages to count the bytes. If the check and the computation occurred at precisely the same time it is possible for validBytes to return essentially any value. The fix is (1) avoid mucking with the MessageSet once it is handed over to ConsumerFetcherThread.processPartitionData, and (2) use a local variable to compute the validbytes, this way even if we do have future threading bugs the worst case is that we recompute the same cached value twice instead of accessing a partial computation (we could also make the variable volatile, but that doesn&apos;t really add any additional protection since we don&apos;t need precise memory visibility).&lt;/p&gt;

&lt;p&gt;51. Done.&lt;/p&gt;</comment>
                            <comment id="13469655" author="junrao" created="Thu, 4 Oct 2012 20:31:58 +0000"  >&lt;p&gt;Thanks for patch v5. &lt;/p&gt;

&lt;p&gt;50. There is still a potential issue in that shallowValidByteCount is a long and long value is not guaranteed to be exposed atomically without synchronization in java. So, 1 thread could see a partially updated long value. Thinking about this, since ByteBufferMessageSet is not updatable, is it better to compute validBytes once in the constructor?&lt;/p&gt;

&lt;p&gt;51. ConsumerIterator: Could you include currentDataChunk.fetchOffset in the message string in MessageSizeTooLargeException? This will make debugging easier.&lt;/p&gt;

&lt;p&gt;Since this is a large patch, it would be good if someone else takes a closer look at it too. At least Neha expressed interests in taking another look at the latest patch.&lt;/p&gt;</comment>
                            <comment id="13469726" author="jkreps" created="Thu, 4 Oct 2012 21:25:28 +0000"  >&lt;p&gt;50. It can actually only take Int values, so I don&apos;t think this can happen. I will file a follow-up clean-up issue to change sizeInBytes to be an Int (I had mentioned that earlier in the thread) since this anyways leads to innumerable safe-but-annoying casts to int. I think this is better than pre-computing it because in many cases we instantiate a ByteBufferMessageSet without necessarily using validBytes.&lt;/p&gt;

&lt;p&gt;51. Yes, I will add this as part of the checkin.&lt;/p&gt;</comment>
                            <comment id="13469780" author="nehanarkhede" created="Thu, 4 Oct 2012 22:20:15 +0000"  >&lt;p&gt;I will free up tomorrow after Grace Hopper conference is over. Would like to take another closer look at the follow up patches. If you guys don&apos;t mind, please can we hold this at least for this weekend ?&lt;/p&gt;</comment>
                            <comment id="13469794" author="jkreps" created="Thu, 4 Oct 2012 22:42:22 +0000"  >&lt;p&gt;It is really hard/error-prone to keep this patch alive and functioning, I basically spend half of each day on rebasing then debugging the new bugs i introduce during rebasing. Could we do it as a post commit review? I am totally down to fix/change things, but the problem is each new change may take a few iterations and meanwhile the whole hunk has to be kept alive. In an ideal world I would have found a way to have done this in smaller pieces, but it is kind of a cross-cutting change so that was hard.&lt;/p&gt;</comment>
                            <comment id="13469945" author="junrao" created="Fri, 5 Oct 2012 01:14:04 +0000"  >&lt;p&gt;What we can do is to hold off committing other conflicting patches for now and have this patch more thoroughly reviewed. If there are no major concerns, we can just commit the patch and have follow-up jiras to address minor issues. Neha, do you think that you can finish the review by Saturday?&lt;/p&gt;</comment>
                            <comment id="13469949" author="jjkoshy" created="Fri, 5 Oct 2012 01:19:53 +0000"  >&lt;p&gt;Rebasing is painful for sure, especially since 0.8 is moving quite fast. I think the other patches in flight are either small or otherwise straightforward to rebase as they don&apos;t have significant overlap. So it seems holding off all check-ins until after this weekend would work for everyone right?&lt;/p&gt;</comment>
                            <comment id="13470497" author="jkreps" created="Fri, 5 Oct 2012 17:42:57 +0000"  >&lt;p&gt;jkreps-mn:kafka-git jkreps$ git pull&lt;br/&gt;
remote: Counting objects: 72, done.&lt;br/&gt;
remote: Compressing objects: 100% (37/37), done.&lt;br/&gt;
remote: Total 42 (delta 26), reused 0 (delta 0)&lt;br/&gt;
Unpacking objects: 100% (42/42), done.&lt;br/&gt;
From git://git.apache.org/kafka&lt;br/&gt;
   0aa1500..65e139c  0.8        -&amp;gt; origin/0.8&lt;br/&gt;
Auto-merging core/src/main/scala/kafka/api/FetchResponse.scala&lt;br/&gt;
CONFLICT (content): Merge conflict in core/src/main/scala/kafka/api/FetchResponse.scala&lt;br/&gt;
Auto-merging core/src/main/scala/kafka/api/ProducerRequest.scala&lt;br/&gt;
CONFLICT (content): Merge conflict in core/src/main/scala/kafka/api/ProducerRequest.scala&lt;br/&gt;
Auto-merging core/src/main/scala/kafka/consumer/ConsumerFetcherThread.scala&lt;br/&gt;
Auto-merging core/src/main/scala/kafka/server/AbstractFetcherThread.scala&lt;br/&gt;
CONFLICT (content): Merge conflict in core/src/main/scala/kafka/server/AbstractFetcherThread.scala&lt;br/&gt;
Auto-merging core/src/main/scala/kafka/server/KafkaApis.scala&lt;br/&gt;
CONFLICT (content): Merge conflict in core/src/main/scala/kafka/server/KafkaApis.scala&lt;br/&gt;
Auto-merging core/src/main/scala/kafka/server/ReplicaFetcherThread.scala&lt;br/&gt;
Auto-merging core/src/test/scala/unit/kafka/api/RequestResponseSerializationTest.scala&lt;br/&gt;
Auto-merging core/src/test/scala/unit/kafka/producer/SyncProducerTest.scala&lt;br/&gt;
Auto-merging core/src/test/scala/unit/kafka/utils/TestUtils.scala&lt;br/&gt;
Automatic merge failed; fix conflicts and then commit the result.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="13470620" author="jkreps" created="Fri, 5 Oct 2012 20:18:05 +0000"  >&lt;p&gt;Rebased patch and improved error message for the MessageSizeTooLargeException.&lt;/p&gt;</comment>
                            <comment id="13471628" author="nehanarkhede" created="Mon, 8 Oct 2012 15:55:07 +0000"  >&lt;p&gt;Agree that rebasing is painful. In addition to more reviews, the hope was to check in ~20 more test cases as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-502&quot; title=&quot;Simplify setup / initialization in replication_basic_test.py&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-502&quot;&gt;&lt;del&gt;KAFKA-502&lt;/del&gt;&lt;/a&gt;, so we could test it out thoroughly. But we can check it in and return to fixing issues later as well. &lt;/p&gt;</comment>
                            <comment id="13471631" author="nehanarkhede" created="Mon, 8 Oct 2012 16:00:49 +0000"  >&lt;p&gt;Btw, which svn revision does patch v5 apply correctly on ? &lt;/p&gt;</comment>
                            <comment id="13471637" author="jkreps" created="Mon, 8 Oct 2012 16:06:36 +0000"  >&lt;p&gt;Should apply on HEAD.&lt;/p&gt;</comment>
                            <comment id="13471698" author="junrao" created="Mon, 8 Oct 2012 17:54:24 +0000"  >&lt;p&gt;+1 from me.&lt;/p&gt;</comment>
                            <comment id="13471783" author="jkreps" created="Mon, 8 Oct 2012 19:15:32 +0000"  >&lt;p&gt;Committed.&lt;/p&gt;</comment>
                            <comment id="13472753" author="nehanarkhede" created="Tue, 9 Oct 2012 21:11:43 +0000"  >&lt;p&gt;I have to mention that there is a possibility that some of my comments are not related to this patch directly, but were found while inspecting the new code closely &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; Since you know the code better, feel free to file follow up JIRAs&lt;/p&gt;

&lt;p&gt;1. Log&lt;/p&gt;

&lt;p&gt;1.2 In findRange, the following statements runs the risk of hitting overflow, giving incorrect results from the binary search -&lt;br/&gt;
      val mid = ceil((high + low) / 2.0).toInt&lt;br/&gt;
Will probably be better to use&lt;br/&gt;
     val mid = low + ceil((high - low)/2.0).toInt&lt;br/&gt;
1.3 It seems that there are only 2 usages of the findRange API that takes in the array length . We already have an API that covers that use case - findRange&lt;span class=&quot;error&quot;&gt;&amp;#91;T &amp;lt;: Range&amp;#93;&lt;/span&gt;(ranges: Array&lt;span class=&quot;error&quot;&gt;&amp;#91;T&amp;#93;&lt;/span&gt;, value: Long) and this is used by a majority of API calls.&lt;br/&gt;
We can make the findRange method that has the actual binary search logic private and changes the 2 use cases in Log.scala to use the public method that assumes the array length.&lt;br/&gt;
1.4 In truncateTo, it is possible that the log file was successfully deleted but the index file was not. In this case, we would end up an unused index file that is never deleted from the kafka log directory.&lt;br/&gt;
1.5 In loadSegments, we need to rebuild any missing index files. Or it will error out at a later time. Do we have a follow up JIRA to cover this, it seems like a blocker to me.&lt;/p&gt;

&lt;p&gt;2. LogManager&lt;br/&gt;
2.1 numPartitions is an unused class variable&lt;/p&gt;

&lt;p&gt;3. FileMessageSet&lt;br/&gt;
3.1. In searchFor API, fix comment to mention that it searches for the first/least offset that is &amp;gt;= the target offset. Right now it says search for the last offset that is &amp;gt;= target offset&lt;br/&gt;
3.2 The searchFor API returns a pair of (offset, position). Right now, it does not always return the offset of the message at the returned position. If the file message set is sparse, it returns the offset of the next message, so the offset and position do not point to the same message in the log. Currently, we are not using the offset returned by the read() API, but in the future if we do, it will be good for it to be consistent.&lt;br/&gt;
3.3 In searchFor API, one of the statements uses 12 and the other uses MessageSet.LogOverhead. I think the while condition is better understood if it said MessageSet.LogOverhead.&lt;/p&gt;

&lt;p&gt;4. LogSegment&lt;br/&gt;
4.1 It is better to make translateOffset return an Option. That way, every usage of this API will be forced to handle the case when the position was not found in the log segment.&lt;br/&gt;
4.2 I guess it might make sense to have all the places that uses this segment size to a an Int instead of Long. &lt;/p&gt;

&lt;p&gt;5. ConsumerIterator&lt;/p&gt;

&lt;p&gt;Right now, while committing offsets for a compressed message set, the consumer can still get duplicates. However, we could probably fix this by making the ConsumerIterator smarter and discarding messages with offset &amp;lt; fetch offset.&lt;/p&gt;

&lt;p&gt;6. ReplicaFetcherThread&lt;/p&gt;

&lt;p&gt;When the follower fetches data from the leader, it uses log.append which re-computes the logical message ids. This involves recompression when the data is compressed, which it is in production. This can be avoided by making the data copy from leader -&amp;gt; follower smarter&lt;/p&gt;

&lt;p&gt;7. MessageCompressionTest&lt;br/&gt;
There are 2 unused imports in this file&lt;/p&gt;

&lt;p&gt;8. ByteBufferMessageSet&lt;br/&gt;
8.1 There are 3 unused imports in this file&lt;br/&gt;
8.2 The return statement in create() API is redundant&lt;/p&gt;

&lt;p&gt;9. OffsetIndex&lt;br/&gt;
9.1 The last return statement in indexSlotFor is redundant&lt;br/&gt;
9.1 The first return statement in indexSlotFor can be safely removed by using case-match or putting the rest of the logic in the else part of if-else block.&lt;/p&gt;

&lt;p&gt;10. Performance&lt;br/&gt;
Performance test to see the impact on throughput/latency if any due to this patch. What I am curious about is the performance impact due to the following, which are the changes that can impact performance as compared to pre &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-506&quot; title=&quot;Store logical offset in log&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-506&quot;&gt;&lt;del&gt;KAFKA-506&lt;/del&gt;&lt;/a&gt; -&lt;br/&gt;
10.1 Recompression of data during replica reads&lt;br/&gt;
10.2 Recompression of data to assign correct offsets inside a compressed message set&lt;br/&gt;
10.3 The linear search in the file segment to find the message with a given id. This depends on the index interval and there needs to be a balance between index size and index interval.&lt;br/&gt;
10.4 The impact of making the log memory mapped.&lt;br/&gt;
10.5 Overhead of using the index to read/write data in Kafka&lt;/p&gt;

&lt;p&gt;11. KafkaApis&lt;br/&gt;
Unused imports in this file&lt;/p&gt;

&lt;p&gt;Just to summarize so that we understand the follow up work and also the JIRAs that got automatically resolved due to this feature. Please correct me if I missed something here -&lt;/p&gt;

&lt;p&gt;Follow up JIRAs&lt;br/&gt;
1. Retain key in producer (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-544&quot; title=&quot;Retain key in producer and expose it in the consumer&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-544&quot;&gt;&lt;del&gt;KAFKA-544&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
2. Change sizeInBytes() to Int (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-556&quot; title=&quot;Change MessageSet.sizeInBytes to Int&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-556&quot;&gt;&lt;del&gt;KAFKA-556&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
3. Fix consumer offset commit in ConsumerIterator for compressed message sets (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-546&quot; title=&quot;Fix commit() in zk consumer for compressed messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-546&quot;&gt;&lt;del&gt;KAFKA-546&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
4. Remove the recompression involved while fetching data from follower to leader (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-557&quot; title=&quot;Replica fetch thread doesn&amp;#39;t need to recompute message id&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-557&quot;&gt;&lt;del&gt;KAFKA-557&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
5. Rebuild missing index files (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-561&quot; title=&quot;Rebuild index file for a log segment if there is none&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-561&quot;&gt;&lt;del&gt;KAFKA-561&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
6. Add performance test for log subsystem (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-545&quot; title=&quot;Add a Performance Suite for the Log subsystem&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-545&quot;&gt;&lt;del&gt;KAFKA-545&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
7. Overall Performance analysis due to the factors listed above&lt;/p&gt;

&lt;p&gt;JIRAs resolved due to this feature&lt;br/&gt;
1. Fix offsets returned as part of producer response (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-511&quot; title=&quot;offset returned in Producer response may not be correct&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-511&quot;&gt;&lt;del&gt;KAFKA-511&lt;/del&gt;&lt;/a&gt;)&lt;br/&gt;
2. Consumer offset issue during unclean leader election (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-497&quot; title=&quot;recover consumer during unclean leadership change&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-497&quot;&gt;&lt;del&gt;KAFKA-497&lt;/del&gt;&lt;/a&gt;)&lt;/p&gt;

</comment>
                            <comment id="13472974" author="jkreps" created="Wed, 10 Oct 2012 03:59:29 +0000"  >&lt;p&gt;Hi Neha, here are some comments on your comments and a patch that addresses the comments we are in agreement on.&lt;/p&gt;

&lt;p&gt;1. Log&lt;br/&gt;
1.2, 1.3 True. This problem exists in both OffsetIndex and Log, though I don&apos;t think either are actually possible. In Log this requires one to have 2 billion segment files, though, which is not physically possible; in OffsetIndex one would need to have ~2 billion entries in an index, which isn&apos;t possible as the message overhead would fill up the log segment first. I am going to leave it alone in Log since that code I want to delete asap anyway. I fixed it in the OffsetIndex since that code is meant to last.&lt;br/&gt;
1.4. This logic is a little odd, I will fix it, but actually this reminds me of a bigger problem. If file.delete() fails on the log file, the presence of that log file will effectively corrupt the log on restart (since we will have a file with the given offset but will also start another log with a parallel offset that we actually append to--on restart the bad file will mask part of the new file). Obviously if file.delete() fails things are pretty fucked and there is nothing we can do in software to recover. So what I would like to do is throw KafkaStorageException and have Partition.makeFollower() shut down the server. What would happen in the leadership transfer if I did that?&lt;br/&gt;
1.5 Filed a JIRA for this.&lt;/p&gt;

&lt;p&gt;LogManager&lt;br/&gt;
2.1 Deleted numPartitions (not related to this patch, I don&apos;t think)&lt;/p&gt;

&lt;p&gt;FileMessageSet&lt;br/&gt;
3.1 Good catch, fixed.&lt;br/&gt;
3.2 Right, so I return the offset specifically to be able to differentiate the case where I found the exact location versus the next message. This is important for things like truncate. I always return the offset and corresponding file position of the first offset that meets the &amp;gt;= criteria. So either I am confused, or I think it works the way you are saying it should.&lt;br/&gt;
3.3 Well, but the code actually reads and Int and Long out of the resulting buffer, so if MessageSet.LogOverhead != 12 there is a bug, so we aren&apos;t abstracting anything just adding a layer of obfuscation. But, yes, it should be consistent, so changed it.&lt;/p&gt;

&lt;p&gt;LogSegment&lt;br/&gt;
4. LogSegment&lt;br/&gt;
4.1 I don&apos;t want to allocate an object for each call as this method is internal to LogSegment. I will make it private to emphasize that.&lt;br/&gt;
4.2 I agree, though we have had the 2gb limit for a while now so this isn&apos;t new. We repurposed &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-556&quot; title=&quot;Change MessageSet.sizeInBytes to Int&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-556&quot;&gt;&lt;del&gt;KAFKA-556&lt;/del&gt;&lt;/a&gt; for this.&lt;/p&gt;

&lt;p&gt;5. ConsumerIterator&lt;br/&gt;
Agreed. Broke this into a separate issue since current state is no worse than 0.7.x. JIRA is &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-546&quot; title=&quot;Fix commit() in zk consumer for compressed messages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-546&quot;&gt;&lt;del&gt;KAFKA-546&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;6. ReplicaFetcherThread&lt;br/&gt;
Agreed this was discussed above. JIRA is &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-557&quot; title=&quot;Replica fetch thread doesn&amp;#39;t need to recompute message id&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-557&quot;&gt;&lt;del&gt;KAFKA-557&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;7. Only IDEA detects this, which I don&apos;t have. So can&apos;t help on this.&lt;/p&gt;

&lt;p&gt;8. ByteBufferMessageSet&lt;br/&gt;
8.2 Fixed&lt;/p&gt;

&lt;p&gt;9. OffsetIndex &lt;br/&gt;
9.1 Fixed&lt;br/&gt;
9.2 This is true but I think it would be more convoluted. Simple test and exits make it so you don&apos;t have to add another layer of nesting.&lt;/p&gt;

&lt;p&gt;10 Agreed, of the various things on my plate I think this is the most important. Any issues here are resolvable, but we need to first get the data.&lt;/p&gt;</comment>
                            <comment id="13473703" author="jkreps" created="Wed, 10 Oct 2012 23:48:54 +0000"  >&lt;p&gt;This patch is identical to the previous Neha related patch except that now in the event that a log segment can&apos;t be deleted we throw KafkaStorageException. In KafkaApis.handleLeaderAndISRRequest we catch this exception and shutdown the server.&lt;/p&gt;</comment>
                            <comment id="13473821" author="nehanarkhede" created="Thu, 11 Oct 2012 04:04:38 +0000"  >&lt;p&gt;+1. Looks good and thanks for addressing the late review comments. One minor comment -&lt;/p&gt;

&lt;p&gt;The following error statement is slightly misleading. The broker could either be in the middle of becoming a leader or a follower, not necessarily the former. &lt;/p&gt;

&lt;p&gt;fatal(&quot;Disk error while becoming leader.&quot;)&lt;/p&gt;</comment>
                            <comment id="13474269" author="jkreps" created="Thu, 11 Oct 2012 16:07:18 +0000"  >&lt;p&gt;Ah, nice catch. Changed it to &quot;Disk error during leadership change.&quot;&lt;/p&gt;

&lt;p&gt;Checked in with the change.&lt;/p&gt;</comment>
                            <comment id="13474652" author="smeder" created="Fri, 12 Oct 2012 00:05:20 +0000"  >&lt;p&gt;I think you missed a change to KafkaETLContext. It needs:&lt;/p&gt;

&lt;p&gt;diff --git a/contrib/hadoop-consumer/src/main/java/kafka/etl/KafkaETLContext.java b/contrib/hadoop-consumer/src/main/java/kafka/etl/KafkaETLContext.java&lt;br/&gt;
index bca1757..9498169 100644&lt;br/&gt;
&amp;#8212; a/contrib/hadoop-consumer/src/main/java/kafka/etl/KafkaETLContext.java&lt;br/&gt;
+++ b/contrib/hadoop-consumer/src/main/java/kafka/etl/KafkaETLContext.java&lt;br/&gt;
@@ -205,7 +205,7 @@ public class KafkaETLContext {&lt;/p&gt;

&lt;p&gt;             key.set(_index, _offset, messageAndOffset.message().checksum());&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;_offset = messageAndOffset.offset();  //increase offset&lt;br/&gt;
+            _offset = messageAndOffset.nextOffset();  //increase offset&lt;br/&gt;
             _count ++;  //increase count&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             return true;&lt;/p&gt;

&lt;p&gt;or something similar. As it stands it&apos;ll run forever...&lt;/p&gt;</comment>
                            <comment id="13474661" author="jkreps" created="Fri, 12 Oct 2012 00:16:01 +0000"  >&lt;p&gt;Ack, nice catch, fixed it.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310060">
                    <name>Container</name>
                                            <outwardlinks description="contains">
                                        <issuelink>
            <issuekey id="12600100">KAFKA-414</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12617847">KAFKA-634</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12548670" name="KAFKA-506-neha-post-review-v2.patch" size="5804" author="jkreps" created="Wed, 10 Oct 2012 23:48:54 +0000"/>
                            <attachment id="12548519" name="KAFKA-506-neha-post-review.patch" size="4425" author="jkreps" created="Wed, 10 Oct 2012 03:59:29 +0000"/>
                            <attachment id="12546937" name="KAFKA-506-phase-2-v1.patch" size="268475" author="jkreps" created="Fri, 28 Sep 2012 01:05:17 +0000"/>
                            <attachment id="12547038" name="KAFKA-506-phase-2-v2.patch" size="268475" author="jkreps" created="Fri, 28 Sep 2012 20:20:27 +0000"/>
                            <attachment id="12547447" name="KAFKA-506-phase-2-v3.patch" size="288148" author="jkreps" created="Tue, 2 Oct 2012 21:33:08 +0000"/>
                            <attachment id="12547593" name="KAFKA-506-phase-2-v4.patch" size="290820" author="jkreps" created="Wed, 3 Oct 2012 20:52:34 +0000"/>
                            <attachment id="12548036" name="KAFKA-506-phase-2-v5.patch" size="292733" author="jkreps" created="Fri, 5 Oct 2012 20:18:05 +0000"/>
                            <attachment id="12547788" name="KAFKA-506-phase-2-v5.patch" size="292733" author="jkreps" created="Thu, 4 Oct 2012 17:22:07 +0000"/>
                            <attachment id="12546813" name="KAFKA-506-phase-2.patch" size="166476" author="jkreps" created="Thu, 27 Sep 2012 05:44:23 +0000"/>
                            <attachment id="12545057" name="KAFKA-506-v1-draft.patch" size="103720" author="jkreps" created="Thu, 13 Sep 2012 21:27:33 +0000"/>
                            <attachment id="12545234" name="KAFKA-506-v1.patch" size="127674" author="jkreps" created="Fri, 14 Sep 2012 22:41:43 +0000"/>
                            <attachment id="12547594" name="KAFKA-506-v4-changes-since-v3.patch" size="16382" author="jkreps" created="Wed, 3 Oct 2012 20:52:34 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>12.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>240554</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 6 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i013bb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>4306</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>