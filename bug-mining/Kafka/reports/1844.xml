<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:07:13 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6606] Regression in consumer auto-commit backoff behavior</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6606</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;We introduced a regression in the auto-commit behavior in&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6362&quot; title=&quot;auto commit not work since coordinatorUnknown() is always true.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6362&quot;&gt;&lt;del&gt;KAFKA-6362&lt;/del&gt;&lt;/a&gt;. After initiating a send, the consumer does not reset its next commit deadline, so it will send auto-commits as fast as the user can call poll() until the first offset commit returns.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13142202">KAFKA-6606</key>
            <summary>Regression in consumer auto-commit backoff behavior</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hachikuji">Jason Gustafson</assignee>
                                    <reporter username="hachikuji">Jason Gustafson</reporter>
                        <labels>
                    </labels>
                <created>Fri, 2 Mar 2018 21:33:39 +0000</created>
                <updated>Sat, 3 Mar 2018 21:39:10 +0000</updated>
                            <resolved>Sat, 3 Mar 2018 21:39:10 +0000</resolved>
                                                    <fixVersion>1.1.0</fixVersion>
                                    <component>consumer</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="16384401" author="githubbot" created="Sat, 3 Mar 2018 01:22:11 +0000"  >&lt;p&gt;hachikuji opened a new pull request #4641: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6606&quot; title=&quot;Regression in consumer auto-commit backoff behavior&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6606&quot;&gt;&lt;del&gt;KAFKA-6606&lt;/del&gt;&lt;/a&gt;; Ensure consumer awaits auto-commit interval after sending&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4641&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4641&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   We need to reset the auto-commit deadline after sending the offset commit request so that we do not resend it while the request is still inflight. &lt;/p&gt;

&lt;p&gt;   Added unit tests ensuring this behavior and proper backoff in the case of a failure.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16384862" author="githubbot" created="Sat, 3 Mar 2018 21:27:32 +0000"  >&lt;p&gt;hachikuji closed pull request #4641: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6606&quot; title=&quot;Regression in consumer auto-commit backoff behavior&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6606&quot;&gt;&lt;del&gt;KAFKA-6606&lt;/del&gt;&lt;/a&gt;; Ensure consumer awaits auto-commit interval after sending&#8230;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4641&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4641&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java&lt;br/&gt;
index 2afa1ff9236..3c99c966d54 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java&lt;br/&gt;
@@ -621,6 +621,7 @@ public boolean commitOffsetsSync(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets,&lt;/p&gt;

&lt;p&gt;     public void maybeAutoCommitOffsetsAsync(long now) {&lt;br/&gt;
         if (autoCommitEnabled &amp;amp;&amp;amp; now &amp;gt;= nextAutoCommitDeadline) &lt;/p&gt;
{
+            this.nextAutoCommitDeadline = now + autoCommitIntervalMs;
             doAutoCommitOffsetsAsync();
         }
&lt;p&gt;     }&lt;br/&gt;
@@ -633,14 +634,15 @@ private void doAutoCommitOffsetsAsync() {&lt;br/&gt;
             @Override&lt;br/&gt;
             public void onComplete(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Exception exception) {&lt;br/&gt;
                 if (exception != null) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;log.warn(&quot;Asynchronous auto-commit of offsets {} failed: {}&quot;, offsets, exception.getMessage());&lt;/li&gt;
	&lt;li&gt;if (exception instanceof RetriableException)&lt;br/&gt;
+                    if (exception instanceof RetriableException) {&lt;br/&gt;
+                        log.debug(&quot;Asynchronous auto-commit of offsets {} failed due to retriable error: {}&quot;, offsets,&lt;br/&gt;
+                                exception);&lt;br/&gt;
                         nextAutoCommitDeadline = Math.min(time.milliseconds() + retryBackoffMs, nextAutoCommitDeadline);&lt;/li&gt;
	&lt;li&gt;else&lt;/li&gt;
	&lt;li&gt;nextAutoCommitDeadline = time.milliseconds() + autoCommitIntervalMs;&lt;br/&gt;
+                    } else {&lt;br/&gt;
+                        log.warn(&quot;Asynchronous auto-commit of offsets {} failed: {}&quot;, offsets, exception.getMessage());&lt;br/&gt;
+                    }&lt;br/&gt;
                 } else {&lt;br/&gt;
                     log.debug(&quot;Completed asynchronous auto-commit of offsets {}&quot;, offsets);&lt;/li&gt;
	&lt;li&gt;nextAutoCommitDeadline = time.milliseconds() + autoCommitIntervalMs;&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;br/&gt;
         });&lt;br/&gt;
diff --git a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java&lt;br/&gt;
index ac392055f9b..3e3c423a428 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java&lt;br/&gt;
@@ -99,7 +99,6 @@&lt;br/&gt;
     private int sessionTimeoutMs = 10000;&lt;br/&gt;
     private int heartbeatIntervalMs = 5000;&lt;br/&gt;
     private long retryBackoffMs = 100;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;private boolean autoCommitEnabled = false;&lt;br/&gt;
     private int autoCommitIntervalMs = 2000;&lt;br/&gt;
     private MockPartitionAssignor partitionAssignor = new MockPartitionAssignor();&lt;br/&gt;
     private List&amp;lt;PartitionAssignor&amp;gt; assignors = Collections.&amp;lt;PartitionAssignor&amp;gt;singletonList(partitionAssignor);&lt;br/&gt;
@@ -134,7 +133,7 @@ public void setup() 
{
         this.partitionAssignor.clear();
 
         client.setNode(node);
-        this.coordinator = buildCoordinator(metrics, assignors, ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, autoCommitEnabled, true);
+        this.coordinator = buildCoordinator(metrics, assignors, ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, false, true);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @After&lt;br/&gt;
@@ -209,7 +208,7 @@ public void testManyInFlightAsyncCommitsWithCoordinatorDisconnect() throws Excep&lt;br/&gt;
         final AtomicInteger responses = new AtomicInteger(0);&lt;/p&gt;

&lt;p&gt;         for (int i = 0; i &amp;lt; numRequests; i++) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets = Collections.singletonMap(tp, new OffsetAndMetadata&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;);&lt;br/&gt;
+            Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets = singletonMap(tp, new OffsetAndMetadata&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;);&lt;br/&gt;
             coordinator.commitOffsetsAsync(offsets, new OffsetCommitCallback() {&lt;br/&gt;
                 @Override&lt;br/&gt;
                 public void onComplete(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Exception exception) {&lt;br/&gt;
@@ -237,7 +236,7 @@ public void testCoordinatorUnknownInUnsentCallbacksAfterCoordinatorDead() throws&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final AtomicBoolean asyncCallbackInvoked = new AtomicBoolean(false);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;TopicPartition, OffsetCommitRequest.PartitionData&amp;gt; offsets = Collections.singletonMap(&lt;br/&gt;
+        Map&amp;lt;TopicPartition, OffsetCommitRequest.PartitionData&amp;gt; offsets = singletonMap(&lt;br/&gt;
                 new TopicPartition(&quot;foo&quot;, 0), new OffsetCommitRequest.PartitionData(13L, &quot;&quot;));&lt;br/&gt;
         consumerClient.send(coordinator.checkAndGetCoordinator(), new OffsetCommitRequest.Builder(groupId, offsets))&lt;br/&gt;
                 .compose(new RequestFutureAdapter&amp;lt;ClientResponse, Object&amp;gt;() {&lt;br/&gt;
@@ -379,8 +378,8 @@ public void testNormalJoinGroupLeader() {&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // normal join group&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = Collections.singletonMap(consumerId, singletonList(topic1));&lt;/li&gt;
	&lt;li&gt;partitionAssignor.prepare(Collections.singletonMap(consumerId, singletonList(t1p)));&lt;br/&gt;
+        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = singletonMap(consumerId, singletonList(topic1));&lt;br/&gt;
+        partitionAssignor.prepare(singletonMap(consumerId, singletonList(t1p)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         client.prepareResponse(joinGroupLeaderResponse(1, consumerId, memberSubscriptions, Errors.NONE));&lt;br/&gt;
         client.prepareResponse(new MockClient.RequestMatcher() {&lt;br/&gt;
@@ -418,8 +417,8 @@ public void testPatternJoinGroupLeader() {&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/p&gt;

&lt;p&gt;         // normal join group&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = Collections.singletonMap(consumerId, singletonList(topic1));&lt;/li&gt;
	&lt;li&gt;partitionAssignor.prepare(Collections.singletonMap(consumerId, Arrays.asList(t1p, t2p)));&lt;br/&gt;
+        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = singletonMap(consumerId, singletonList(topic1));&lt;br/&gt;
+        partitionAssignor.prepare(singletonMap(consumerId, Arrays.asList(t1p, t2p)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         client.prepareResponse(joinGroupLeaderResponse(1, consumerId, memberSubscriptions, Errors.NONE));&lt;br/&gt;
         client.prepareResponse(new MockClient.RequestMatcher() {&lt;br/&gt;
@@ -521,8 +520,8 @@ public void testWakeupDuringJoin() {&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = Collections.singletonMap(consumerId, singletonList(topic1));&lt;/li&gt;
	&lt;li&gt;partitionAssignor.prepare(Collections.singletonMap(consumerId, singletonList(t1p)));&lt;br/&gt;
+        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = singletonMap(consumerId, singletonList(topic1));&lt;br/&gt;
+        partitionAssignor.prepare(singletonMap(consumerId, singletonList(t1p)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // prepare only the first half of the join and then trigger the wakeup&lt;br/&gt;
         client.prepareResponse(joinGroupLeaderResponse(1, consumerId, memberSubscriptions, Errors.NONE));&lt;br/&gt;
@@ -621,13 +620,7 @@ public void testLeaveGroupOnClose() {&lt;br/&gt;
         final String consumerId = &quot;consumer&quot;;&lt;/p&gt;

&lt;p&gt;         subscriptions.subscribe(singleton(topic1), rebalanceListener);&lt;br/&gt;
-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.ensureCoordinatorReady();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(joinGroupFollowerResponse(1, consumerId, &quot;leader&quot;, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(syncGroupResponse(singletonList(t1p), Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.joinGroupIfNeeded();&lt;br/&gt;
+        joinAsFollowerAndReceiveAssignment(consumerId, coordinator, singletonList(t1p));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final AtomicBoolean received = new AtomicBoolean(false);&lt;br/&gt;
         client.prepareResponse(new MockClient.RequestMatcher() {&lt;br/&gt;
@@ -648,13 +641,7 @@ public void testMaybeLeaveGroup() {&lt;br/&gt;
         final String consumerId = &quot;consumer&quot;;&lt;/p&gt;

&lt;p&gt;         subscriptions.subscribe(singleton(topic1), rebalanceListener);&lt;br/&gt;
-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.ensureCoordinatorReady();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(joinGroupFollowerResponse(1, consumerId, &quot;leader&quot;, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(syncGroupResponse(singletonList(t1p), Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.joinGroupIfNeeded();&lt;br/&gt;
+        joinAsFollowerAndReceiveAssignment(consumerId, coordinator, singletonList(t1p));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final AtomicBoolean received = new AtomicBoolean(false);&lt;br/&gt;
         client.prepareResponse(new MockClient.RequestMatcher() {&lt;br/&gt;
@@ -782,8 +769,8 @@ public void testMetadataChangeTriggersRebalance() {&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = Collections.singletonMap(consumerId, singletonList(topic1));&lt;/li&gt;
	&lt;li&gt;partitionAssignor.prepare(Collections.singletonMap(consumerId, singletonList(t1p)));&lt;br/&gt;
+        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = singletonMap(consumerId, singletonList(topic1));&lt;br/&gt;
+        partitionAssignor.prepare(singletonMap(consumerId, singletonList(t1p)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // the leader is responsible for picking up metadata changes and forcing a group rebalance&lt;br/&gt;
         client.prepareResponse(joinGroupLeaderResponse(1, consumerId, memberSubscriptions, Errors.NONE));&lt;br/&gt;
@@ -820,8 +807,8 @@ public void testUpdateMetadataDuringRebalance() {&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/p&gt;

&lt;p&gt;         // prepare initial rebalance&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = Collections.singletonMap(consumerId, topics);&lt;/li&gt;
	&lt;li&gt;partitionAssignor.prepare(Collections.singletonMap(consumerId, Collections.singletonList(tp1)));&lt;br/&gt;
+        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = singletonMap(consumerId, topics);&lt;br/&gt;
+        partitionAssignor.prepare(singletonMap(consumerId, Collections.singletonList(tp1)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         client.prepareResponse(joinGroupLeaderResponse(1, consumerId, memberSubscriptions, Errors.NONE));&lt;br/&gt;
         client.prepareResponse(new MockClient.RequestMatcher() {&lt;br/&gt;
@@ -888,7 +875,7 @@ else if (patternSubscribe)&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = Collections.singletonMap(consumerId, singletonList(topic1));&lt;br/&gt;
+        Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; memberSubscriptions = singletonMap(consumerId, singletonList(topic1));&lt;br/&gt;
         partitionAssignor.prepare(Collections.&amp;lt;String, List&amp;lt;TopicPartition&amp;gt;&amp;gt;emptyMap());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         client.prepareResponse(joinGroupLeaderResponse(1, consumerId, memberSubscriptions, Errors.NONE));&lt;br/&gt;
@@ -938,13 +925,8 @@ public void testRejoinGroup() {&lt;/p&gt;

&lt;p&gt;         subscriptions.subscribe(singleton(topic1), rebalanceListener);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.ensureCoordinatorReady();&lt;br/&gt;
-&lt;br/&gt;
         // join the group once&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(joinGroupFollowerResponse(1, &quot;consumer&quot;, &quot;leader&quot;, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(syncGroupResponse(singletonList(t1p), Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.joinGroupIfNeeded();&lt;br/&gt;
+        joinAsFollowerAndReceiveAssignment(&quot;consumer&quot;, coordinator, singletonList(t1p));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         assertEquals(1, rebalanceListener.revokedCount);&lt;br/&gt;
         assertTrue(rebalanceListener.revoked.isEmpty());&lt;br/&gt;
@@ -1003,10 +985,10 @@ public void testCommitOffsetOnly() &lt;/p&gt;
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
         coordinator.ensureCoordinatorReady();
 
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);
 
         AtomicBoolean success = new AtomicBoolean(false);
-        coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success));
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success));
         coordinator.invokeCompletedOffsetCommitCallbacks();
         assertTrue(success.get());
     }
&lt;p&gt;@@ -1030,10 +1012,10 @@ private void testInFlightRequestsFailedAfterCoordinatorMarkedDead(Errors error)&lt;/p&gt;

&lt;p&gt;         MockCommitCallback firstCommitCallback = new MockCommitCallback();&lt;br/&gt;
         MockCommitCallback secondCommitCallback = new MockCommitCallback();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), firstCommitCallback);&lt;/li&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), secondCommitCallback);&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), firstCommitCallback);&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), secondCommitCallback);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.respond(offsetCommitResponse(Collections.singletonMap(t1p, error)));&lt;br/&gt;
+        respondToOffsetCommitRequest(singletonMap(t1p, 100L), error);&lt;br/&gt;
         consumerClient.pollNoWakeup();&lt;br/&gt;
         consumerClient.pollNoWakeup(); // second poll since coordinator disconnect is async&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;br/&gt;
@@ -1051,20 +1033,85 @@ public void testAutoCommitDynamicAssignment() 
{
                 ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, true, true);
 
         subscriptions.subscribe(singleton(topic1), rebalanceListener);
+        joinAsFollowerAndReceiveAssignment(consumerId, coordinator, singletonList(t1p));
+        subscriptions.seek(t1p, 100);
 
-        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
-        coordinator.ensureCoordinatorReady();
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);
+        time.sleep(autoCommitIntervalMs);
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertFalse(client.hasPendingResponses());
+    }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(joinGroupFollowerResponse(1, consumerId, &quot;leader&quot;, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(syncGroupResponse(singletonList(t1p), Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.joinGroupIfNeeded();&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testAutoCommitRetryBackoff() 
{
+        final String consumerId = &quot;consumer&quot;;
+        ConsumerCoordinator coordinator = buildCoordinator(new Metrics(), assignors,
+                ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, true, true);
+        subscriptions.subscribe(singleton(topic1), rebalanceListener);
+        joinAsFollowerAndReceiveAssignment(consumerId, coordinator, singletonList(t1p));
 
         subscriptions.seek(t1p, 100);
+        time.sleep(autoCommitIntervalMs);
+
+        // Send an offset commit, but let it fail with a retriable error
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NOT_COORDINATOR);
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertTrue(coordinator.coordinatorUnknown());
+
+        // After the disconnect, we should rediscover the coordinator
+        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+
+        subscriptions.seek(t1p, 200);
+
+        // Until the retry backoff has expired, we should not retry the offset commit
+        time.sleep(retryBackoffMs / 2);
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertEquals(0, client.inFlightRequestCount());
+
+        // Once the backoff expires, we should retry
+        time.sleep(retryBackoffMs / 2);
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertEquals(1, client.inFlightRequestCount());
+        respondToOffsetCommitRequest(singletonMap(t1p, 200L), Errors.NONE);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testAutoCommitAwaitsInterval() &lt;/p&gt;
{
+        final String consumerId = &quot;consumer&quot;;
+        ConsumerCoordinator coordinator = buildCoordinator(new Metrics(), assignors,
+                ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, true, true);
+        subscriptions.subscribe(singleton(topic1), rebalanceListener);
+        joinAsFollowerAndReceiveAssignment(consumerId, coordinator, singletonList(t1p));
 
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));
+        subscriptions.seek(t1p, 100);
         time.sleep(autoCommitIntervalMs);
+
+        // Send the offset commit request, but do not respond
         coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
-        assertFalse(client.hasPendingResponses());
+        assertEquals(1, client.inFlightRequestCount());
+
+        time.sleep(autoCommitIntervalMs / 2);
+
+        // Ensure that no additional offset commit is sent
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertEquals(1, client.inFlightRequestCount());
+
+        respondToOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertEquals(0, client.inFlightRequestCount());
+
+        subscriptions.seek(t1p, 200);
+
+        // If we poll again before the auto-commit interval, there should be no new sends
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertEquals(0, client.inFlightRequestCount());
+
+        // After the remainder of the interval passes, we send a new offset commit
+        time.sleep(autoCommitIntervalMs / 2);
+        coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
+        assertEquals(1, client.inFlightRequestCount());
+        respondToOffsetCommitRequest(singletonMap(t1p, 200L), Errors.NONE);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;br/&gt;
@@ -1089,7 +1136,7 @@ public void testAutoCommitDynamicAssignmentRebalance() {&lt;/p&gt;

&lt;p&gt;         subscriptions.seek(t1p, 100);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);&lt;br/&gt;
         time.sleep(autoCommitIntervalMs);&lt;br/&gt;
         coordinator.poll(time.milliseconds(), Long.MAX_VALUE);&lt;br/&gt;
         assertFalse(client.hasPendingResponses());&lt;br/&gt;
@@ -1106,7 +1153,7 @@ public void testAutoCommitManualAssignment() {&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);&lt;br/&gt;
         time.sleep(autoCommitIntervalMs);&lt;br/&gt;
         coordinator.poll(time.milliseconds(), Long.MAX_VALUE);&lt;br/&gt;
         assertFalse(client.hasPendingResponses());&lt;br/&gt;
@@ -1131,7 +1178,7 @@ public void testAutoCommitManualAssignmentCoordinatorUnknown() 
{
 
         // sleep only for the retry backoff
         time.sleep(retryBackoffMs);
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);
         coordinator.poll(time.milliseconds(), Long.MAX_VALUE);
         assertFalse(client.hasPendingResponses());
     }
&lt;p&gt;@@ -1143,11 +1190,11 @@ public void testCommitOffsetMetadata() {&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         AtomicBoolean success = new AtomicBoolean(false);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets = Collections.singletonMap(t1p, new OffsetAndMetadata(100L, &quot;hello&quot;));&lt;br/&gt;
+        Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets = singletonMap(t1p, new OffsetAndMetadata(100L, &quot;hello&quot;));&lt;br/&gt;
         coordinator.commitOffsetsAsync(offsets, callback(offsets, success));&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;br/&gt;
         assertTrue(success.get());&lt;br/&gt;
@@ -1158,8 +1205,8 @@ public void testCommitOffsetAsyncWithDefaultCallback() {&lt;br/&gt;
         int invokedBeforeTest = mockOffsetCommitCallback.invoked;&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;/li&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), mockOffsetCommitCallback);&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), mockOffsetCommitCallback);&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;br/&gt;
         assertEquals(invokedBeforeTest + 1, mockOffsetCommitCallback.invoked);&lt;br/&gt;
         assertNull(mockOffsetCommitCallback.exception);&lt;br/&gt;
@@ -1170,15 +1217,7 @@ public void testCommitAfterLeaveGroup() {&lt;br/&gt;
         // enable auto-assignment&lt;br/&gt;
         subscriptions.subscribe(singleton(topic1), rebalanceListener);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;coordinator.ensureCoordinatorReady();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(joinGroupFollowerResponse(1, &quot;consumer&quot;, &quot;leader&quot;, Errors.NONE));&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(syncGroupResponse(singletonList(t1p), Errors.NONE));&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;client.prepareMetadataUpdate(cluster, Collections.&amp;lt;String&amp;gt;emptySet());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;coordinator.joinGroupIfNeeded();&lt;br/&gt;
+        joinAsFollowerAndReceiveAssignment(&quot;consumer&quot;, coordinator, singletonList(t1p));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // now switch to manual assignment&lt;br/&gt;
         client.prepareResponse(new LeaveGroupResponse(Errors.NONE));&lt;br/&gt;
@@ -1194,10 +1233,10 @@ public boolean matches(AbstractRequest body) &lt;/p&gt;
{
                 return commitRequest.memberId().equals(OffsetCommitRequest.DEFAULT_MEMBER_ID) &amp;amp;&amp;amp;
                         commitRequest.generationId() == OffsetCommitRequest.DEFAULT_GENERATION_ID;
             }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;}, offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;br/&gt;
+        }, offsetCommitResponse(singletonMap(t1p, Errors.NONE)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         AtomicBoolean success = new AtomicBoolean(false);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success));&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), callback(success));&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;br/&gt;
         assertTrue(success.get());&lt;br/&gt;
     }&lt;br/&gt;
@@ -1207,8 +1246,8 @@ public void testCommitOffsetAsyncFailedWithDefaultCallback() {&lt;br/&gt;
         int invokedBeforeTest = mockOffsetCommitCallback.invoked;&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;br/&gt;
         coordinator.ensureCoordinatorReady();&lt;/li&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.COORDINATOR_NOT_AVAILABLE)));&lt;/li&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), mockOffsetCommitCallback);&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.COORDINATOR_NOT_AVAILABLE);&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), mockOffsetCommitCallback);&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;br/&gt;
         assertEquals(invokedBeforeTest + 1, mockOffsetCommitCallback.invoked);&lt;br/&gt;
         assertTrue(mockOffsetCommitCallback.exception instanceof RetriableCommitFailedException);&lt;br/&gt;
@@ -1221,8 +1260,8 @@ public void testCommitOffsetAsyncCoordinatorNotAvailable() {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // async commit with coordinator not available&lt;br/&gt;
         MockCommitCallback cb = new MockCommitCallback();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.COORDINATOR_NOT_AVAILABLE)));&lt;/li&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), cb);&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.COORDINATOR_NOT_AVAILABLE);&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), cb);&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         assertTrue(coordinator.coordinatorUnknown());&lt;br/&gt;
@@ -1237,8 +1276,8 @@ public void testCommitOffsetAsyncNotCoordinator() {&lt;/p&gt;

&lt;p&gt;         // async commit with not coordinator&lt;br/&gt;
         MockCommitCallback cb = new MockCommitCallback();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NOT_COORDINATOR)));&lt;/li&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), cb);&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.COORDINATOR_NOT_AVAILABLE);&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), cb);&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         assertTrue(coordinator.coordinatorUnknown());&lt;br/&gt;
@@ -1253,8 +1292,8 @@ public void testCommitOffsetAsyncDisconnected() {&lt;/p&gt;

&lt;p&gt;         // async commit with coordinator disconnected&lt;br/&gt;
         MockCommitCallback cb = new MockCommitCallback();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)), true);&lt;/li&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), cb);&lt;br/&gt;
+        prepareOffsetCommitRequestDisconnect(singletonMap(t1p, 100L));&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(100L)), cb);&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         assertTrue(coordinator.coordinatorUnknown());&lt;br/&gt;
@@ -1268,10 +1307,10 @@ public void testCommitOffsetSyncNotCoordinator() &lt;/p&gt;
{
         coordinator.ensureCoordinatorReady();
 
         // sync commit with coordinator disconnected (should connect, get metadata, and then submit the commit request)
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NOT_COORDINATOR)));
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NOT_COORDINATOR);
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test&lt;br/&gt;
@@ -1280,10 +1319,10 @@ public void testCommitOffsetSyncCoordinatorNotAvailable() &lt;/p&gt;
{
         coordinator.ensureCoordinatorReady();
 
         // sync commit with coordinator disconnected (should connect, get metadata, and then submit the commit request)
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.COORDINATOR_NOT_AVAILABLE)));
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.COORDINATOR_NOT_AVAILABLE);
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test&lt;br/&gt;
@@ -1292,10 +1331,10 @@ public void testCommitOffsetSyncCoordinatorDisconnected() &lt;/p&gt;
{
         coordinator.ensureCoordinatorReady();
 
         // sync commit with coordinator disconnected (should connect, get metadata, and then submit the commit request)
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)), true);
+        prepareOffsetCommitRequestDisconnect(singletonMap(t1p, 100L));
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test&lt;br/&gt;
@@ -1307,7 +1346,7 @@ public void testAsyncCommitCallbacksInvokedPriorToSyncCommitCompletion() throws&lt;br/&gt;
         final OffsetAndMetadata firstOffset = new OffsetAndMetadata(0L);&lt;br/&gt;
         final OffsetAndMetadata secondOffset = new OffsetAndMetadata(1L);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, firstOffset), new OffsetCommitCallback() {&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, firstOffset), new OffsetCommitCallback() {&lt;br/&gt;
             @Override&lt;br/&gt;
             public void onComplete(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Exception exception) {&lt;br/&gt;
                 committedOffsets.add(firstOffset);&lt;br/&gt;
@@ -1318,7 +1357,7 @@ public void onComplete(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Exception&lt;br/&gt;
         Thread thread = new Thread() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {             @Override             public void run() {
-                coordinator.commitOffsetsSync(Collections.singletonMap(t1p, secondOffset), 10000);
+                coordinator.commitOffsetsSync(singletonMap(t1p, secondOffset), 10000);
                 committedOffsets.add(secondOffset);
             }         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
@@ -1326,8 +1365,8 @@ public void run() {&lt;br/&gt;
         thread.start();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         client.waitForRequests(2, 5000);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.respond(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;/li&gt;
	&lt;li&gt;client.respond(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;br/&gt;
+        respondToOffsetCommitRequest(singletonMap(t1p, firstOffset.offset()), Errors.NONE);&lt;br/&gt;
+        respondToOffsetCommitRequest(singletonMap(t1p, secondOffset.offset()), Errors.NONE);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         thread.join();&lt;/p&gt;

&lt;p&gt;@@ -1339,8 +1378,8 @@ public void testCommitUnknownTopicOrPartition() &lt;/p&gt;
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
         coordinator.ensureCoordinatorReady();
 
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.UNKNOWN_TOPIC_OR_PARTITION)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_TOPIC_OR_PARTITION);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test(expected = OffsetMetadataTooLarge.class)&lt;br/&gt;
@@ -1349,8 +1388,8 @@ public void testCommitOffsetMetadataTooLarge() &lt;/p&gt;
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
         coordinator.ensureCoordinatorReady();
 
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.OFFSET_METADATA_TOO_LARGE)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.OFFSET_METADATA_TOO_LARGE);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test(expected = CommitFailedException.class)&lt;br/&gt;
@@ -1359,8 +1398,8 @@ public void testCommitOffsetIllegalGeneration() &lt;/p&gt;
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
         coordinator.ensureCoordinatorReady();
 
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.ILLEGAL_GENERATION)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.ILLEGAL_GENERATION);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test(expected = CommitFailedException.class)&lt;br/&gt;
@@ -1369,8 +1408,8 @@ public void testCommitOffsetUnknownMemberId() &lt;/p&gt;
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
         coordinator.ensureCoordinatorReady();
 
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.UNKNOWN_MEMBER_ID)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_MEMBER_ID);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test(expected = CommitFailedException.class)&lt;br/&gt;
@@ -1379,8 +1418,8 @@ public void testCommitOffsetRebalanceInProgress() &lt;/p&gt;
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
         coordinator.ensureCoordinatorReady();
 
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.REBALANCE_IN_PROGRESS)));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.REBALANCE_IN_PROGRESS);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L, &quot;metadata&quot;)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test(expected = KafkaException.class)&lt;br/&gt;
@@ -1389,21 +1428,21 @@ public void testCommitOffsetSyncCallbackWithNonRetriableException() &lt;/p&gt;
{
         coordinator.ensureCoordinatorReady();
 
         // sync commit with invalid partitions should throw if we have no callback
-        client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.UNKNOWN_SERVER_ERROR)), false);
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.UNKNOWN_SERVER_ERROR);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test(expected = IllegalArgumentException.class)&lt;br/&gt;
     public void testCommitSyncNegativeOffset() &lt;/p&gt;
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
-        coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(-1L)), Long.MAX_VALUE);
+        coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(-1L)), Long.MAX_VALUE);
     }

&lt;p&gt;     @Test&lt;br/&gt;
     public void testCommitAsyncNegativeOffset() {&lt;br/&gt;
         int invokedBeforeTest = mockOffsetCommitCallback.invoked;&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;coordinator.commitOffsetsAsync(Collections.singletonMap(t1p, new OffsetAndMetadata(-1L)), mockOffsetCommitCallback);&lt;br/&gt;
+        coordinator.commitOffsetsAsync(singletonMap(t1p, new OffsetAndMetadata(-1L)), mockOffsetCommitCallback);&lt;br/&gt;
         coordinator.invokeCompletedOffsetCommitCallbacks();&lt;br/&gt;
         assertEquals(invokedBeforeTest + 1, mockOffsetCommitCallback.invoked);&lt;br/&gt;
         assertTrue(mockOffsetCommitCallback.exception instanceof IllegalArgumentException);&lt;br/&gt;
@@ -1413,7 +1452,7 @@ public void testCommitAsyncNegativeOffset() {&lt;br/&gt;
     public void testCommitOffsetSyncWithoutFutureGetsCompleted() 
{
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
         coordinator.ensureCoordinatorReady();
-        assertFalse(coordinator.commitOffsetsSync(Collections.singletonMap(t1p, new OffsetAndMetadata(100L)), 0));
+        assertFalse(coordinator.commitOffsetsSync(singletonMap(t1p, new OffsetAndMetadata(100L)), 0));
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;br/&gt;
@@ -1684,7 +1723,7 @@ public void testAutoCommitAfterCoordinatorBackToService() {&lt;br/&gt;
         coordinator.markCoordinatorUnknown();&lt;br/&gt;
         assertTrue(coordinator.coordinatorUnknown());&lt;br/&gt;
         client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;client.prepareResponse(offsetCommitResponse(Collections.singletonMap(t1p, Errors.NONE)));&lt;br/&gt;
+        prepareOffsetCommitRequest(singletonMap(t1p, 100L), Errors.NONE);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // async commit offset should find coordinator&lt;br/&gt;
         time.sleep(autoCommitIntervalMs); // sleep for a while to ensure auto commit does happen&lt;br/&gt;
@@ -1852,7 +1891,7 @@ private OffsetFetchResponse offsetFetchResponse(Errors topLevelError) {&lt;/p&gt;

&lt;p&gt;     private OffsetFetchResponse offsetFetchResponse(TopicPartition tp, Errors partitionLevelError, String metadata, long offset) &lt;/p&gt;
{
         OffsetFetchResponse.PartitionData data = new OffsetFetchResponse.PartitionData(offset, metadata, partitionLevelError);
-        return new OffsetFetchResponse(Errors.NONE, Collections.singletonMap(tp, data));
+        return new OffsetFetchResponse(Errors.NONE, singletonMap(tp, data));
     }

&lt;p&gt;     private OffsetCommitCallback callback(final AtomicBoolean success) &lt;/p&gt;
{
@@ -1865,6 +1904,67 @@ public void onComplete(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Exception
         }
&lt;p&gt;;&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    private void joinAsFollowerAndReceiveAssignment(String consumerId,&lt;br/&gt;
+                                                    ConsumerCoordinator coordinator,&lt;br/&gt;
+                                                    List&amp;lt;TopicPartition&amp;gt; assignment) &lt;/p&gt;
{
+        client.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));
+        coordinator.ensureCoordinatorReady();
+        client.prepareResponse(joinGroupFollowerResponse(1, consumerId, &quot;leader&quot;, Errors.NONE));
+        client.prepareResponse(syncGroupResponse(assignment, Errors.NONE));
+        coordinator.joinGroupIfNeeded();
+    }
&lt;p&gt;+&lt;br/&gt;
+    private void prepareOffsetCommitRequest(Map&amp;lt;TopicPartition, Long&amp;gt; expectedOffsets, Errors error) &lt;/p&gt;
{
+        prepareOffsetCommitRequest(expectedOffsets, error, false);
+    }
&lt;p&gt;+&lt;br/&gt;
+    private void prepareOffsetCommitRequestDisconnect(Map&amp;lt;TopicPartition, Long&amp;gt; expectedOffsets) &lt;/p&gt;
{
+        prepareOffsetCommitRequest(expectedOffsets, Errors.NONE, true);
+    }
&lt;p&gt;+&lt;br/&gt;
+    private void prepareOffsetCommitRequest(final Map&amp;lt;TopicPartition, Long&amp;gt; expectedOffsets,&lt;br/&gt;
+                                            Errors error,&lt;br/&gt;
+                                            boolean disconnected) &lt;/p&gt;
{
+        Map&amp;lt;TopicPartition, Errors&amp;gt; errors = partitionErrors(expectedOffsets.keySet(), error);
+        client.prepareResponse(offsetCommitRequestMatcher(expectedOffsets), offsetCommitResponse(errors), disconnected);
+    }
&lt;p&gt;+&lt;br/&gt;
+    private Map&amp;lt;TopicPartition, Errors&amp;gt; partitionErrors(Collection&amp;lt;TopicPartition&amp;gt; partitions, Errors error) {&lt;br/&gt;
+        final Map&amp;lt;TopicPartition, Errors&amp;gt; errors = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+        for (TopicPartition partition : partitions) &lt;/p&gt;
{
+            errors.put(partition, error);
+        }
&lt;p&gt;+        return errors;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    private void respondToOffsetCommitRequest(final Map&amp;lt;TopicPartition, Long&amp;gt; expectedOffsets, Errors error) &lt;/p&gt;
{
+        Map&amp;lt;TopicPartition, Errors&amp;gt; errors = partitionErrors(expectedOffsets.keySet(), error);
+        client.respond(offsetCommitRequestMatcher(expectedOffsets), offsetCommitResponse(errors));
+    }
&lt;p&gt;+&lt;br/&gt;
+    private MockClient.RequestMatcher offsetCommitRequestMatcher(final Map&amp;lt;TopicPartition, Long&amp;gt; expectedOffsets) {&lt;br/&gt;
+        return new MockClient.RequestMatcher() {&lt;br/&gt;
+            @Override&lt;br/&gt;
+            public boolean matches(AbstractRequest body) {&lt;br/&gt;
+                OffsetCommitRequest req = (OffsetCommitRequest) body;&lt;br/&gt;
+                Map&amp;lt;TopicPartition, OffsetCommitRequest.PartitionData&amp;gt; offsets = req.offsetData();&lt;br/&gt;
+                if (offsets.size() != expectedOffsets.size())&lt;br/&gt;
+                    return false;&lt;br/&gt;
+&lt;br/&gt;
+                for (Map.Entry&amp;lt;TopicPartition, Long&amp;gt; expectedOffset : expectedOffsets.entrySet()) &lt;/p&gt;
{
+                    if (!offsets.containsKey(expectedOffset.getKey()))
+                        return false;
+
+                    OffsetCommitRequest.PartitionData offsetCommitData = offsets.get(expectedOffset.getKey());
+                    if (offsetCommitData.offset != expectedOffset.getValue())
+                        return false;
+                }
&lt;p&gt;+&lt;br/&gt;
+                return true;&lt;br/&gt;
+            }&lt;br/&gt;
+        };&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
     private OffsetCommitCallback callback(final Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; expectedOffsets,&lt;br/&gt;
                                           final AtomicBoolean success) {&lt;br/&gt;
         return new OffsetCommitCallback() &lt;/p&gt;
{
@@ -1876,7 +1976,6 @@ public void onComplete(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Exception
         }
&lt;p&gt;;&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;-&lt;br/&gt;
     private static class MockCommitCallback implements OffsetCommitCallback {&lt;br/&gt;
         public int invoked = 0;&lt;br/&gt;
         public Exception exception = null;&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16384865" author="hachikuji" created="Sat, 3 Mar 2018 21:39:10 +0000"  >&lt;p&gt;Note this issue did not affect any released version.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 37 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3qtaf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>