<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:10:11 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6879] Controller deadlock following session expiration</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6879</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;We have observed an apparent deadlock situation which occurs following a session expiration. The suspected deadlock occurs between the zookeeper &quot;initializationLock&quot; and the latch inside the Expire event which we use to ensure all events have been handled.&lt;/p&gt;

&lt;p&gt;In the logs, we see the &quot;Session expired&quot; message following acquisition of the initialization lock: &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala#L358&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala#L358&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But we never see any logs indicating that the new session is being initialized. In fact, the controller logs are basically empty from that point on. The problem we suspect is that completion of the &lt;tt&gt;beforeInitializingSession&lt;/tt&gt; callback requires that all events have finished processing in order to count down the latch: &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/controller/KafkaController.scala#L1525&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/controller/KafkaController.scala#L1525&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;But an event which was dequeued just prior to the acquisition of the write lock may be unable to complete because it is awaiting acquisition of the initialization lock: &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala#L137&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala#L137&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The impact is that the broker continues in a zombie state. It continues fetching and is periodically added to ISRs, but it never receives any further requests from the controller since it is not registered.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13157744">KAFKA-6879</key>
            <summary>Controller deadlock following session expiration</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hachikuji">Jason Gustafson</assignee>
                                    <reporter username="hachikuji">Jason Gustafson</reporter>
                        <labels>
                    </labels>
                <created>Mon, 7 May 2018 23:49:36 +0000</created>
                <updated>Fri, 17 Jan 2020 09:10:58 +0000</updated>
                            <resolved>Wed, 9 May 2018 06:53:01 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>1.1.1</fixVersion>
                    <fixVersion>2.0.0</fixVersion>
                                    <component>controller</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>10</watches>
                                                                                                                <comments>
                            <comment id="16466661" author="ijuma" created="Tue, 8 May 2018 00:18:32 +0000"  >&lt;p&gt;We discussed a possible fix offline:&#160;only run `initialize` with initializationLock held and run the callbacks `beforeInitializingSession` and `afterInitializingSession` without the lock. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=onurkaraman&quot; class=&quot;user-hover&quot; rel=&quot;onurkaraman&quot;&gt;onurkaraman&lt;/a&gt;,&#160;can you think of any reason why this would be an issue? Also cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=junrao&quot; class=&quot;user-hover&quot; rel=&quot;junrao&quot;&gt;junrao&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="16466713" author="yuzhihong@gmail.com" created="Tue, 8 May 2018 01:17:09 +0000"  >&lt;p&gt;Moving only &lt;tt&gt;beforeInitializingSession&lt;/tt&gt; outside of &lt;tt&gt;initializationLock&lt;/tt&gt; scope should be enough, right ?&lt;/p&gt;</comment>
                            <comment id="16466901" author="githubbot" created="Tue, 8 May 2018 05:39:04 +0000"  >&lt;p&gt;hachikuji opened a new pull request #4977: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6879&quot; title=&quot;Controller deadlock following session expiration&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6879&quot;&gt;&lt;del&gt;KAFKA-6879&lt;/del&gt;&lt;/a&gt;; Invoke session init callbacks outside lock to avoid deadlock&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4977&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4977&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Fixes a deadlock between the controller&apos;s `beforeInitializingSession` callback which holds the zookeeper client initialization lock while awaiting completion of an asynchronous event which itself depends on the same lock.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16468075" author="githubbot" created="Tue, 8 May 2018 22:52:47 +0000"  >&lt;p&gt;ijuma closed pull request #4977: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6879&quot; title=&quot;Controller deadlock following session expiration&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6879&quot;&gt;&lt;del&gt;KAFKA-6879&lt;/del&gt;&lt;/a&gt;; Invoke session init callbacks outside lock to avoid deadlock&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4977&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4977&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/core/src/main/scala/kafka/controller/KafkaController.scala b/core/src/main/scala/kafka/controller/KafkaController.scala&lt;br/&gt;
index bc721e39f96..d3d1a81c41f 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/controller/KafkaController.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/controller/KafkaController.scala&lt;br/&gt;
@@ -160,7 +160,10 @@ class KafkaController(val config: KafkaConfig, zkClient: KafkaZkClient, time: Ti&lt;br/&gt;
       override def beforeInitializingSession(): Unit = &lt;/p&gt;
{
         val expireEvent = new Expire
         eventManager.clearAndPut(expireEvent)
-        expireEvent.waitUntilProcessed()
+
+        // Block initialization of the new session until the expiration event is being handled,
+        // which ensures that all pending events have been processed before creating the new session
+        expireEvent.waitUntilProcessingStarted()
       }
&lt;p&gt;     })&lt;br/&gt;
     eventManager.put(Startup)&lt;br/&gt;
@@ -1518,17 +1521,17 @@ class KafkaController(val config: KafkaConfig, zkClient: KafkaZkClient, time: Ti&lt;/p&gt;

&lt;p&gt;   // We can&apos;t make this a case object due to the countDownLatch field&lt;br/&gt;
   class Expire extends ControllerEvent {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private val countDownLatch = new CountDownLatch(1)&lt;br/&gt;
+    private val processingStarted = new CountDownLatch(1)&lt;br/&gt;
     override def state = ControllerState.ControllerChange&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     override def process(): Unit = &lt;/p&gt;
{
-      countDownLatch.countDown()
+      processingStarted.countDown()
       activeControllerId = -1
       onControllerResignation()
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def waitUntilProcessed(): Unit = {&lt;/li&gt;
	&lt;li&gt;countDownLatch.await()&lt;br/&gt;
+    def waitUntilProcessingStarted(): Unit = 
{
+      processingStarted.await()
     }
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/core/src/main/scala/kafka/utils/KafkaScheduler.scala b/core/src/main/scala/kafka/utils/KafkaScheduler.scala&lt;br/&gt;
index 5407934e987..24eb17770ec 100755&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/utils/KafkaScheduler.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/utils/KafkaScheduler.scala&lt;br/&gt;
@@ -99,11 +99,15 @@ class KafkaScheduler(val threads: Int,&lt;br/&gt;
     }&lt;br/&gt;
   }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def schedule(name: String, fun: ()=&amp;gt;Unit, delay: Long, period: Long, unit: TimeUnit) {&lt;br/&gt;
+  def scheduleOnce(name: String, fun: () =&amp;gt; Unit): Unit = 
{
+    schedule(name, fun, delay = 0L, period = -1L, unit = TimeUnit.MILLISECONDS)
+  }
&lt;p&gt;+&lt;br/&gt;
+  def schedule(name: String, fun: () =&amp;gt; Unit, delay: Long, period: Long, unit: TimeUnit) {&lt;br/&gt;
     debug(&quot;Scheduling task %s with initial delay %d ms and period %d ms.&quot;&lt;br/&gt;
         .format(name, TimeUnit.MILLISECONDS.convert(delay, unit), TimeUnit.MILLISECONDS.convert(period, unit)))&lt;br/&gt;
     this synchronized {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;ensureRunning&lt;br/&gt;
+      ensureRunning()&lt;br/&gt;
       val runnable = CoreUtils.runnable {&lt;br/&gt;
         try 
{
           trace(&quot;Beginning execution of scheduled task &apos;%s&apos;.&quot;.format(name))
diff --git a/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala b/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala
index 5c4cd685565..5cb127c3c7e 100755
--- a/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala
+++ b/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala
@@ -59,7 +59,7 @@ class ZooKeeperClient(connectString: String,
   private val zNodeChildChangeHandlers = new ConcurrentHashMap[String, ZNodeChildChangeHandler]().asScala
   private val inFlightRequests = new Semaphore(maxInFlightRequests)
   private val stateChangeHandlers = new ConcurrentHashMap[String, StateChangeHandler]().asScala
-  private[zookeeper] val expiryScheduler = new KafkaScheduler(0, &quot;zk-session-expiry-handler&quot;)
+  private[zookeeper] val expiryScheduler = new KafkaScheduler(threads = 1, &quot;zk-session-expiry-handler&quot;)
 
   private val metricNames = Set[String]()
 
@@ -325,43 +325,65 @@ class ZooKeeperClient(connectString: String,
     zooKeeper
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private def initialize(): Unit = {&lt;/li&gt;
	&lt;li&gt;if (!connectionState.isAlive) {&lt;/li&gt;
	&lt;li&gt;zooKeeper.close()&lt;/li&gt;
	&lt;li&gt;info(s&quot;Initializing a new session to $connectString.&quot;)&lt;/li&gt;
	&lt;li&gt;// retry forever until ZooKeeper can be instantiated&lt;/li&gt;
	&lt;li&gt;var connected = false&lt;/li&gt;
	&lt;li&gt;while (!connected) {&lt;/li&gt;
	&lt;li&gt;try 
{
-          zooKeeper = new ZooKeeper(connectString, sessionTimeoutMs, ZooKeeperClientWatcher)
-          connected = true
-        }
&lt;p&gt; catch {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;case e: Exception =&amp;gt;&lt;/li&gt;
	&lt;li&gt;info(&quot;Error when recreating ZooKeeper, retrying after a short sleep&quot;, e)&lt;/li&gt;
	&lt;li&gt;Thread.sleep(1000)&lt;br/&gt;
+  private def reinitialize(): Unit = {&lt;br/&gt;
+    // Initialization callbacks are invoked outside of the lock to avoid deadlock potential since their completion&lt;br/&gt;
+    // may require additional Zookeeper requests, which will block to acquire the initialization lock&lt;br/&gt;
+    stateChangeHandlers.values.foreach(callBeforeInitializingSession _)&lt;br/&gt;
+&lt;br/&gt;
+    inWriteLock(initializationLock) {&lt;br/&gt;
+      if (!connectionState.isAlive) {&lt;br/&gt;
+        zooKeeper.close()&lt;br/&gt;
+        info(s&quot;Initializing a new session to $connectString.&quot;)&lt;br/&gt;
+        // retry forever until ZooKeeper can be instantiated&lt;br/&gt;
+        var connected = false&lt;br/&gt;
+        while (!connected) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+          try {
+            zooKeeper = new ZooKeeper(connectString, sessionTimeoutMs, ZooKeeperClientWatcher)
+            connected = true
+          } catch {
+            case e: Exception =&amp;gt;
+              info(&quot;Error when recreating ZooKeeper, retrying after a short sleep&quot;, e)
+              Thread.sleep(1000)
+          }         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;       }&lt;br/&gt;
     }&lt;br/&gt;
+&lt;br/&gt;
+    stateChangeHandlers.values.foreach(callAfterInitializingSession _)&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* reinitialize method to use in unit tests&lt;br/&gt;
+   * Close the zookeeper client to force session reinitialization. This is visible for testing only.&lt;br/&gt;
    */&lt;/li&gt;
	&lt;li&gt;private&lt;span class=&quot;error&quot;&gt;&amp;#91;zookeeper&amp;#93;&lt;/span&gt; def reinitialize(): Unit = {&lt;br/&gt;
+  private&lt;span class=&quot;error&quot;&gt;&amp;#91;zookeeper&amp;#93;&lt;/span&gt; def forceReinitialize(): Unit = 
{
     zooKeeper.close()
-    initialize()
+    reinitialize()
+  }
&lt;p&gt;+&lt;br/&gt;
+  private def callBeforeInitializingSession(handler: StateChangeHandler): Unit = {&lt;br/&gt;
+    try &lt;/p&gt;
{
+      handler.beforeInitializingSession()
+    }
&lt;p&gt; catch {&lt;br/&gt;
+      case t: Throwable =&amp;gt;&lt;br/&gt;
+        error(s&quot;Uncaught error in handler ${handler.name}&quot;, t)&lt;br/&gt;
+    }&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  private def callAfterInitializingSession(handler: StateChangeHandler): Unit = {&lt;br/&gt;
+    try &lt;/p&gt;
{
+      handler.afterInitializingSession()
+    }
&lt;p&gt; catch {&lt;br/&gt;
+      case t: Throwable =&amp;gt;&lt;br/&gt;
+        error(s&quot;Uncaught error in handler ${handler.name}&quot;, t)&lt;br/&gt;
+    }&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   // Visibility for testing&lt;br/&gt;
   private&lt;span class=&quot;error&quot;&gt;&amp;#91;zookeeper&amp;#93;&lt;/span&gt; def scheduleSessionExpiryHandler(): Unit = {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;expiryScheduler.schedule(&quot;zk-session-expired&quot;, () =&amp;gt; {&lt;/li&gt;
	&lt;li&gt;inWriteLock(initializationLock) 
{
-        info(&quot;Session expired.&quot;)
-        stateChangeHandlers.values.foreach(_.beforeInitializingSession())
-        initialize()
-        stateChangeHandlers.values.foreach(_.afterInitializingSession())
-      }&lt;/li&gt;
	&lt;li&gt;}, delay = 0L, period = -1L, unit = TimeUnit.MILLISECONDS)&lt;br/&gt;
+    expiryScheduler.scheduleOnce(&quot;zk-session-expired&quot;, () =&amp;gt; 
{
+      info(&quot;Session expired.&quot;)
+      reinitialize()
+    }
&lt;p&gt;)&lt;br/&gt;
   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   // package level visibility for testing only&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala b/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala&lt;br/&gt;
index 77e11eae716..c4143e2a8e6 100644&lt;br/&gt;
&amp;#8212; a/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala&lt;br/&gt;
@@ -18,7 +18,7 @@ package kafka.zookeeper&lt;/p&gt;

&lt;p&gt; import java.nio.charset.StandardCharsets&lt;br/&gt;
 import java.util.UUID&lt;br/&gt;
-import java.util.concurrent.atomic.AtomicBoolean&lt;br/&gt;
+import java.util.concurrent.atomic.&lt;/p&gt;
{AtomicBoolean, AtomicInteger}
&lt;p&gt; import java.util.concurrent.&lt;/p&gt;
{ArrayBlockingQueue, ConcurrentLinkedQueue, CountDownLatch, Executors, Semaphore, TimeUnit}

&lt;p&gt; import com.yammer.metrics.Metrics&lt;br/&gt;
@@ -304,6 +304,82 @@ class ZooKeeperClientTest extends ZooKeeperTestHarness &lt;/p&gt;
{
     assertTrue(&quot;Failed to receive data change notification&quot;, znodeChangeHandlerCountDownLatch.await(5, TimeUnit.SECONDS))
   }

&lt;p&gt;+  @Test&lt;br/&gt;
+  def testBlockOnRequestCompletionFromStateChangeHandler(): Unit = {&lt;br/&gt;
+    // This tests the scenario exposed by &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6879&quot; title=&quot;Controller deadlock following session expiration&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6879&quot;&gt;&lt;del&gt;KAFKA-6879&lt;/del&gt;&lt;/a&gt; in which the expiration callback awaits&lt;br/&gt;
+    // completion of a request which is handled by another thread&lt;br/&gt;
+&lt;br/&gt;
+    val latch = new CountDownLatch(1)&lt;br/&gt;
+    val stateChangeHandler = new StateChangeHandler {&lt;br/&gt;
+      override val name = this.getClass.getName&lt;br/&gt;
+      override def beforeInitializingSession(): Unit = &lt;/p&gt;
{
+        latch.await()
+      }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    val client = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, Int.MaxValue, time,&lt;br/&gt;
+      &quot;testMetricGroup&quot;, &quot;testMetricType&quot;)&lt;br/&gt;
+    client.registerStateChangeHandler(stateChangeHandler)&lt;br/&gt;
+&lt;br/&gt;
+    val requestThread = new Thread() {&lt;br/&gt;
+      override def run(): Unit = &lt;/p&gt;
{
+        try
+          client.handleRequest(CreateRequest(mockPath, Array.empty[Byte],
+            ZooDefs.Ids.OPEN_ACL_UNSAFE.asScala, CreateMode.PERSISTENT))
+        finally
+          latch.countDown()
+      }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    val reinitializeThread = new Thread() {&lt;br/&gt;
+      override def run(): Unit = &lt;/p&gt;
{
+        client.forceReinitialize()
+      }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    reinitializeThread.start()&lt;br/&gt;
+&lt;br/&gt;
+    // sleep briefly before starting the request thread so that the initialization&lt;br/&gt;
+    // thread is blocking on the latch&lt;br/&gt;
+    Thread.sleep(100)&lt;br/&gt;
+    requestThread.start()&lt;br/&gt;
+&lt;br/&gt;
+    reinitializeThread.join()&lt;br/&gt;
+    requestThread.join()&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testExceptionInBeforeInitializingSession(): Unit = {&lt;br/&gt;
+    val faultyHandler = new StateChangeHandler {&lt;br/&gt;
+      override val name = this.getClass.getName&lt;br/&gt;
+      override def beforeInitializingSession(): Unit = &lt;/p&gt;
{
+        throw new RuntimeException()
+      }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    val goodHandler = new StateChangeHandler {&lt;br/&gt;
+      val calls = new AtomicInteger(0)&lt;br/&gt;
+      override val name = this.getClass.getName&lt;br/&gt;
+      override def beforeInitializingSession(): Unit = &lt;/p&gt;
{
+        calls.incrementAndGet()
+      }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    val client = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, Int.MaxValue, time,&lt;br/&gt;
+      &quot;testMetricGroup&quot;, &quot;testMetricType&quot;)&lt;br/&gt;
+    client.registerStateChangeHandler(faultyHandler)&lt;br/&gt;
+    client.registerStateChangeHandler(goodHandler)&lt;br/&gt;
+&lt;br/&gt;
+    client.forceReinitialize()&lt;br/&gt;
+&lt;br/&gt;
+    assertEquals(1, goodHandler.calls.get)&lt;br/&gt;
+&lt;br/&gt;
+    // Client should be usable even if the callback throws an error&lt;br/&gt;
+    val createResponse = zooKeeperClient.handleRequest(CreateRequest(mockPath, Array.empty&lt;span class=&quot;error&quot;&gt;&amp;#91;Byte&amp;#93;&lt;/span&gt;,&lt;br/&gt;
+      ZooDefs.Ids.OPEN_ACL_UNSAFE.asScala, CreateMode.PERSISTENT))&lt;br/&gt;
+    assertEquals(&quot;Response code for create should be OK&quot;, Code.OK, createResponse.resultCode)&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
   @Test&lt;br/&gt;
   def testZNodeChildChangeHandlerForChildChange(): Unit = {&lt;br/&gt;
     import scala.collection.JavaConverters._&lt;br/&gt;
@@ -343,7 +419,7 @@ class ZooKeeperClientTest extends ZooKeeperTestHarness {&lt;br/&gt;
       &quot;testMetricGroup&quot;, &quot;testMetricType&quot;)&lt;br/&gt;
     try &lt;/p&gt;
{
       zooKeeperClient.registerStateChangeHandler(stateChangeHandler)
-      zooKeeperClient.reinitialize()
+      zooKeeperClient.forceReinitialize()
 
       assertTrue(&quot;Failed to receive auth failed notification&quot;, stateChangeHandlerCountDownLatch.await(5, TimeUnit.SECONDS))
     }
&lt;p&gt; finally zooKeeperClient.close()&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="17017827" author="lbdai3190" created="Fri, 17 Jan 2020 09:10:58 +0000"  >&lt;p&gt;Hello &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hachikuji&quot; class=&quot;user-hover&quot; rel=&quot;hachikuji&quot;&gt;hachikuji&lt;/a&gt;,&#160; I have met this issue on kafka 2.1.1 many times , and the description is here&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-8532&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-8532&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;So I think the controller deadlock problem is not solved completely.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 43 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3tfzz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>