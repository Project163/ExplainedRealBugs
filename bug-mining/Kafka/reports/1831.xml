<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:06:55 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6517] ZooKeeperClient holds a lock while waiting for responses, blocking shutdown</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6517</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Stack traces from a local test run that was deadlocked because shutdown couldn&apos;t acquire the lock:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;kafka-scheduler-7: acquired read lock in kafka.zookeeper.ZooKeeperClient.handleRequests&lt;/li&gt;
	&lt;li&gt;Test worker-EventThread waiting for write lock to process SessionExpired in kafka.zookeeper.ZooKeeperClient$ZooKeeperClientWatcher$.process&lt;/li&gt;
	&lt;li&gt;ForkJoinPool-1-worker-11 processing KafkaServer.shutdown is queued behind 2) waiting to acquire read lock for kafka.zookeeper.ZooKeeperClient.unregisterStateChangeHandler&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Stack traces of the relevant threads:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&quot;kafka-scheduler-7&quot; daemon prio=5 tid=0x00007fade918d800 nid=0xd317 waiting on condition &lt;span class=&quot;error&quot;&gt;&amp;#91;0x000070000b371000&amp;#93;&lt;/span&gt;&lt;br/&gt;
&#160;&#160; java.lang.Thread.State: WAITING (parking)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; - parking to wait for&#160; &amp;lt;0x00000007e4c6e698&amp;gt; (a java.util.concurrent.CountDownLatch$Sync)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(AbstractQueuedSynchronizer.java:994)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1303)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:236)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zookeeper.ZooKeeperClient$$anonfun$handleRequests$1.apply(ZooKeeperClient.scala:146)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zookeeper.ZooKeeperClient$$anonfun$handleRequests$1.apply(ZooKeeperClient.scala:126)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:250)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inReadLock(CoreUtils.scala:256)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zookeeper.ZooKeeperClient.handleRequests(ZooKeeperClient.scala:125)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zk.KafkaZkClient.retryRequestsUntilConnected(KafkaZkClient.scala:1432)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zk.KafkaZkClient.kafka$zk$KafkaZkClient$$retryRequestUntilConnected(KafkaZkClient.scala:1425)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zk.KafkaZkClient.conditionalUpdatePath(KafkaZkClient.scala:583)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.ReplicationUtils$.updateLeaderAndIsr(ReplicationUtils.scala:33)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.cluster.Partition.kafka$cluster$Partition$$updateIsr(Partition.scala:665)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.cluster.Partition$$anonfun$4.apply$mcZ$sp(Partition.scala:509)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.cluster.Partition$$anonfun$4.apply(Partition.scala:500)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.cluster.Partition$$anonfun$4.apply(Partition.scala:500)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:250)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inWriteLock(CoreUtils.scala:258)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.cluster.Partition.maybeShrinkIsr(Partition.scala:499)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.server.ReplicaManager$$anonfun$kafka$server$ReplicaManager$$maybeShrinkIsr$2.apply(ReplicaManager.scala:1335)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.server.ReplicaManager$$anonfun$kafka$server$ReplicaManager$$maybeShrinkIsr$2.apply(ReplicaManager.scala:1335)&lt;/p&gt;

&lt;p&gt;......&lt;/p&gt;

&lt;p&gt;&quot;Test worker-EventThread&quot; daemon prio=5 tid=0x00007fade90cf800 nid=0xef13 waiting on condition &lt;span class=&quot;error&quot;&gt;&amp;#91;0x000070000a23f000&amp;#93;&lt;/span&gt;&lt;br/&gt;
&#160;&#160; java.lang.Thread.State: WAITING (parking)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; - parking to wait for&#160; &amp;lt;0x0000000781847620&amp;gt; (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(AbstractQueuedSynchronizer.java:867)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(AbstractQueuedSynchronizer.java:1197)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.ReentrantReadWriteLock$WriteLock.lock(ReentrantReadWriteLock.java:945)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:248)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inWriteLock(CoreUtils.scala:258)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zookeeper.ZooKeeperClient$ZooKeeperClientWatcher$.process(ZooKeeperClient.scala:355)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.zookeeper.ClientCnxn$EventThread.processEvent(ClientCnxn.java:531)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.zookeeper.ClientCnxn$EventThread.run(ClientCnxn.java:506)&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&quot;ForkJoinPool-1-worker-11&quot; daemon prio=5 tid=0x00007fade9a83000 nid=0x17907 waiting on condition &lt;span class=&quot;error&quot;&gt;&amp;#91;0x0000700011eaf000&amp;#93;&lt;/span&gt;&lt;br/&gt;
&#160;&#160; java.lang.Thread.State: WAITING (parking)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.misc.Unsafe.park(Native Method)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; - parking to wait for&#160; &amp;lt;0x0000000781847620&amp;gt; (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:834)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:964)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1282)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:731)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:248)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.inReadLock(CoreUtils.scala:256)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zookeeper.ZooKeeperClient.unregisterStateChangeHandler(ZooKeeperClient.scala:295)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.zk.KafkaZkClient.unregisterStateChangeHandler(KafkaZkClient.scala:1217)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.common.ZkNodeChangeNotificationListener.close(ZkNodeChangeNotificationListener.scala:68)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.server.DynamicConfigManager.shutdown(DynamicConfigManager.scala:181)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.server.KafkaServer$$anonfun$shutdown$2.apply$mcV$sp(KafkaServer.scala:552)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.utils.CoreUtils$.swallow(CoreUtils.scala:85)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at kafka.server.KafkaServer.shutdown(KafkaServer.scala:552)&lt;/p&gt;&lt;/blockquote&gt;</description>
                <environment></environment>
        <key id="13135409">KAFKA-6517</key>
            <summary>ZooKeeperClient holds a lock while waiting for responses, blocking shutdown</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rsivaram">Rajini Sivaram</assignee>
                                    <reporter username="rsivaram">Rajini Sivaram</reporter>
                        <labels>
                    </labels>
                <created>Thu, 1 Feb 2018 12:50:25 +0000</created>
                <updated>Thu, 15 Feb 2018 20:51:36 +0000</updated>
                            <resolved>Thu, 15 Feb 2018 20:48:10 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16357199" author="githubbot" created="Thu, 8 Feb 2018 16:46:54 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #4551: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6517&quot; title=&quot;ZooKeeperClient holds a lock while waiting for responses, blocking shutdown&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6517&quot;&gt;&lt;del&gt;KAFKA-6517&lt;/del&gt;&lt;/a&gt;: Avoid deadlock in ZooKeeperClient during session expiry&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4551&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4551&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   `ZooKeeperClient` acquires `initializationLock#writeLock` to establish a new connection while processing session expiry WatchEvent. `ZooKeeperClient#handleRequests` acquires  `initializationLock#readLock`, allowing multiple batches of requests to be processed concurrently, but preventing reconnections while processing requests. At the moment, `handleRequests` holds onto the readLock throughout the method, even while waiting for responses and inflight requests to complete. But responses cannot be delivered if event thread is blocked on the writeLock to process session expiry event. This results in a deadlock. During broker shutdown, the shutdown thread is also blocked since it needs the readLock to perform `ZooKeeperClient#unregisterStateChangeHandler`, which cannot be acquired if a session expiry had occurred earlier since this thread gets queued behind the event handler thread waiting for writeLock.&lt;/p&gt;

&lt;p&gt;   This PR fixes the issue by limiting locking in `ZooKeeperClient#handleRequests` to just the non-blocking send, so that session expiry handling doesn&apos;t get blocked.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16366212" author="githubbot" created="Thu, 15 Feb 2018 20:21:15 +0000"  >&lt;p&gt;rajinisivaram closed pull request #4551: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6517&quot; title=&quot;ZooKeeperClient holds a lock while waiting for responses, blocking shutdown&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6517&quot;&gt;&lt;del&gt;KAFKA-6517&lt;/del&gt;&lt;/a&gt;: Avoid deadlock in ZooKeeperClient during session expiry&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4551&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4551&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala b/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala&lt;br/&gt;
index 9a1d16274df..3934fd0ad5d 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/zookeeper/ZooKeeperClient.scala&lt;br/&gt;
@@ -24,7 +24,7 @@ import java.util.concurrent.{ArrayBlockingQueue, ConcurrentHashMap, CountDownLat&lt;br/&gt;
 import com.yammer.metrics.core.&lt;/p&gt;
{Gauge, MetricName}
&lt;p&gt; import kafka.metrics.KafkaMetricsGroup&lt;br/&gt;
 import kafka.utils.CoreUtils.&lt;/p&gt;
{inLock, inReadLock, inWriteLock}
&lt;p&gt;-import kafka.utils.Logging&lt;br/&gt;
+import kafka.utils.&lt;/p&gt;
{KafkaScheduler, Logging}
&lt;p&gt; import org.apache.kafka.common.utils.Time&lt;br/&gt;
 import org.apache.zookeeper.AsyncCallback.&lt;/p&gt;
{ACLCallback, Children2Callback, DataCallback, StatCallback, StringCallback, VoidCallback}
&lt;p&gt; import org.apache.zookeeper.KeeperException.Code&lt;br/&gt;
@@ -59,6 +59,7 @@ class ZooKeeperClient(connectString: String,&lt;br/&gt;
   private val zNodeChildChangeHandlers = new ConcurrentHashMap&lt;span class=&quot;error&quot;&gt;&amp;#91;String, ZNodeChildChangeHandler&amp;#93;&lt;/span&gt;().asScala&lt;br/&gt;
   private val inFlightRequests = new Semaphore(maxInFlightRequests)&lt;br/&gt;
   private val stateChangeHandlers = new ConcurrentHashMap&lt;span class=&quot;error&quot;&gt;&amp;#91;String, StateChangeHandler&amp;#93;&lt;/span&gt;().asScala&lt;br/&gt;
+  private&lt;span class=&quot;error&quot;&gt;&amp;#91;zookeeper&amp;#93;&lt;/span&gt; val expiryScheduler = new KafkaScheduler(0, &quot;zk-session-expiry-handler&quot;)&lt;/p&gt;

&lt;p&gt;   private val metricNames = Set&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;()&lt;/p&gt;

&lt;p&gt;@@ -90,6 +91,7 @@ class ZooKeeperClient(connectString: String,&lt;/p&gt;

&lt;p&gt;   metricNames += &quot;SessionState&quot;&lt;/p&gt;

&lt;p&gt;+  expiryScheduler.startup()&lt;br/&gt;
   waitUntilConnected(connectionTimeoutMs, TimeUnit.MILLISECONDS)&lt;/p&gt;

&lt;p&gt;   override def metricName(name: String, metricTags: scala.collection.Map&lt;span class=&quot;error&quot;&gt;&amp;#91;String, String&amp;#93;&lt;/span&gt;): MetricName = {&lt;br/&gt;
@@ -122,7 +124,7 @@ class ZooKeeperClient(connectString: String,&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;response type (e.g. Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;CreateRequest&amp;#93;&lt;/span&gt; -&amp;gt; Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;CreateResponse&amp;#93;&lt;/span&gt;). Otherwise, the most specific common supertype&lt;/li&gt;
	&lt;li&gt;will be used (e.g. Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;AsyncRequest&amp;#93;&lt;/span&gt; -&amp;gt; Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;AsyncResponse&amp;#93;&lt;/span&gt;).&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def handleRequests&lt;span class=&quot;error&quot;&gt;&amp;#91;Req &amp;lt;: AsyncRequest&amp;#93;&lt;/span&gt;(requests: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Req&amp;#93;&lt;/span&gt;): Seq&lt;a href=&quot;#Response&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Req#Response&lt;/a&gt; = inReadLock(initializationLock) {&lt;br/&gt;
+  def handleRequests&lt;span class=&quot;error&quot;&gt;&amp;#91;Req &amp;lt;: AsyncRequest&amp;#93;&lt;/span&gt;(requests: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Req&amp;#93;&lt;/span&gt;): Seq&lt;a href=&quot;#Response&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Req#Response&lt;/a&gt; = {&lt;br/&gt;
     if (requests.isEmpty)&lt;br/&gt;
       Seq.empty&lt;br/&gt;
     else {&lt;br/&gt;
@@ -132,10 +134,12 @@ class ZooKeeperClient(connectString: String,&lt;br/&gt;
       requests.foreach { request =&amp;gt;&lt;br/&gt;
         inFlightRequests.acquire()&lt;br/&gt;
         try {&lt;/li&gt;
	&lt;li&gt;send(request) { response =&amp;gt;&lt;/li&gt;
	&lt;li&gt;responseQueue.add(response)&lt;/li&gt;
	&lt;li&gt;inFlightRequests.release()&lt;/li&gt;
	&lt;li&gt;countDownLatch.countDown()&lt;br/&gt;
+          inReadLock(initializationLock) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            send(request) { response =&amp;gt;
+              responseQueue.add(response)
+              inFlightRequests.release()
+              countDownLatch.countDown()
+            }           }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;         } catch &lt;/p&gt;
{
           case e: Throwable =&amp;gt;
@@ -148,7 +152,8 @@ class ZooKeeperClient(connectString: String,
     }
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private def send&lt;span class=&quot;error&quot;&gt;&amp;#91;Req &amp;lt;: AsyncRequest&amp;#93;&lt;/span&gt;(request: Req)(processResponse: Req#Response =&amp;gt; Unit): Unit = {&lt;br/&gt;
+  // Visibility to override for testing&lt;br/&gt;
+  private&lt;span class=&quot;error&quot;&gt;&amp;#91;zookeeper&amp;#93;&lt;/span&gt; def send&lt;span class=&quot;error&quot;&gt;&amp;#91;Req &amp;lt;: AsyncRequest&amp;#93;&lt;/span&gt;(request: Req)(processResponse: Req#Response =&amp;gt; Unit): Unit = 
{
     // Safe to cast as we always create a response of the right type
     def callback(response: AsyncResponse): Unit = processResponse(response.asInstanceOf[Req#Response])
 
@@ -303,12 +308,18 @@ class ZooKeeperClient(connectString: String,
     stateChangeHandlers.clear()
     zooKeeper.close()
     metricNames.foreach(removeMetric(_))
+    expiryScheduler.shutdown()
     info(&quot;Closed.&quot;)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   def sessionId: Long = inReadLock(initializationLock) &lt;/p&gt;
{
     zooKeeper.getSessionId
   }
&lt;p&gt;+&lt;br/&gt;
+  // Only for testing&lt;br/&gt;
+  private&lt;span class=&quot;error&quot;&gt;&amp;#91;zookeeper&amp;#93;&lt;/span&gt; def currentZooKeeper: ZooKeeper = inReadLock(initializationLock) &lt;/p&gt;
{
+    zooKeeper
+  }

&lt;p&gt;   private def initialize(): Unit = {&lt;br/&gt;
     if (!connectionState.isAlive) &lt;/p&gt;
{
@@ -352,12 +363,14 @@ class ZooKeeperClient(connectString: String,
             error(&quot;Auth failed.&quot;)
             stateChangeHandlers.values.foreach(_.onAuthFailure())
           }
&lt;p&gt; else if (state == KeeperState.Expired) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;inWriteLock(initializationLock) 
{
-              info(&quot;Session expired.&quot;)
-              stateChangeHandlers.values.foreach(_.beforeInitializingSession())
-              initialize()
-              stateChangeHandlers.values.foreach(_.afterInitializingSession())
-            }
&lt;p&gt;+            expiryScheduler.schedule(&quot;zk-session-expired&quot;, () =&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+              inWriteLock(initializationLock) {
+                info(&quot;Session expired.&quot;)
+                stateChangeHandlers.values.foreach(_.beforeInitializingSession())
+                initialize()
+                stateChangeHandlers.values.foreach(_.afterInitializingSession())
+              }+            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;, delay = 0L, period = -1L, unit = TimeUnit.MILLISECONDS)&lt;br/&gt;
           }&lt;br/&gt;
         case Some(path) =&amp;gt;&lt;br/&gt;
           (event.getType: @unchecked) match {&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala b/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala&lt;br/&gt;
index c8ebaa90735..f1c09d7308d 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/zookeeper/ZooKeeperClientTest.scala&lt;br/&gt;
@@ -19,7 +19,7 @@ package kafka.zookeeper&lt;br/&gt;
 import java.nio.charset.StandardCharsets&lt;br/&gt;
 import java.util.UUID&lt;br/&gt;
 import java.util.concurrent.atomic.AtomicBoolean&lt;br/&gt;
-import java.util.concurrent.
{ArrayBlockingQueue, CountDownLatch, TimeUnit}
&lt;p&gt;+import java.util.concurrent.&lt;/p&gt;
{ArrayBlockingQueue, ConcurrentLinkedQueue, CountDownLatch, Executors, Semaphore, TimeUnit}&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import com.yammer.metrics.Metrics&lt;br/&gt;
 import com.yammer.metrics.core.&lt;/p&gt;
{Gauge, Meter, MetricName}
&lt;p&gt;@@ -29,8 +29,8 @@ import org.apache.kafka.common.utils.Time&lt;br/&gt;
 import org.apache.zookeeper.KeeperException.&lt;/p&gt;
{Code, NoNodeException}
&lt;p&gt; import org.apache.zookeeper.Watcher.Event.&lt;/p&gt;
{EventType, KeeperState}
&lt;p&gt; import org.apache.zookeeper.ZooKeeper.States&lt;br/&gt;
-import org.apache.zookeeper.&lt;/p&gt;
{CreateMode, WatchedEvent, ZooDefs}
&lt;p&gt;-import org.junit.Assert.&lt;/p&gt;
{assertArrayEquals, assertEquals, assertTrue}
&lt;p&gt;+import org.apache.zookeeper.&lt;/p&gt;
{CreateMode, WatchedEvent, Watcher, ZooDefs, ZooKeeper}
&lt;p&gt;+import org.junit.Assert.&lt;/p&gt;
{assertArrayEquals, assertEquals, assertFalse, assertNull, assertTrue}
&lt;p&gt; import org.junit.&lt;/p&gt;
{After, Before, Test}

&lt;p&gt; import scala.collection.JavaConverters._&lt;br/&gt;
@@ -385,6 +385,114 @@ class ZooKeeperClientTest extends ZooKeeperTestHarness {&lt;br/&gt;
     } finally zooKeeperClient.close()&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  /**&lt;br/&gt;
+    * Tests that if session expiry notification is received while a thread is processing requests,&lt;br/&gt;
+    * session expiry is handled and the request thread completes with responses to all requests,&lt;br/&gt;
+    * even though some requests may fail due to session expiry or disconnection.&lt;br/&gt;
+    *&lt;br/&gt;
+    * Sequence of events on different threads:&lt;br/&gt;
+    *   Request thread:&lt;br/&gt;
+    *       - Sends `maxInflightRequests` requests (these may complete before session is expired)&lt;br/&gt;
+    *   Main thread:&lt;br/&gt;
+    *       - Waits for at least one request to be processed (this should succeed)&lt;br/&gt;
+    *       - Expires session by creating new client with same session id&lt;br/&gt;
+    *       - Unblocks another `maxInflightRequests` requests before and after new client is closed (these may fail)&lt;br/&gt;
+    *   ZooKeeperClient Event thread:&lt;br/&gt;
+    *       - Delivers responses and session expiry (no ordering guarantee between these, both are processed asynchronously)&lt;br/&gt;
+    *   Response executor thread:&lt;br/&gt;
+    *       - Blocks subsequent sends by delaying response until session expiry is processed&lt;br/&gt;
+    *   ZooKeeperClient Session Expiry Handler:&lt;br/&gt;
+    *       - Unblocks subsequent sends&lt;br/&gt;
+    *   Main thread:&lt;br/&gt;
+    *       - Waits for all sends to complete. The requests sent after session expiry processing should succeed.&lt;br/&gt;
+    */&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testSessionExpiry(): Unit = {&lt;br/&gt;
+    val maxInflightRequests = 2&lt;br/&gt;
+    val responseExecutor = Executors.newSingleThreadExecutor&lt;br/&gt;
+    val sendSemaphore = new Semaphore(0)&lt;br/&gt;
+    val sendCompleteSemaphore = new Semaphore(0)&lt;br/&gt;
+    val sendSize = maxInflightRequests * 5&lt;br/&gt;
+    @volatile var resultCodes: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;Code&amp;#93;&lt;/span&gt; = null&lt;br/&gt;
+    val stateChanges = new ConcurrentLinkedQueue&lt;span class=&quot;error&quot;&gt;&amp;#91;String&amp;#93;&lt;/span&gt;()&lt;br/&gt;
+    val zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, maxInflightRequests,&lt;br/&gt;
+      time, &quot;testGroupType&quot;, &quot;testGroupName&quot;) {&lt;br/&gt;
+      override def send&lt;span class=&quot;error&quot;&gt;&amp;#91;Req &amp;lt;: AsyncRequest&amp;#93;&lt;/span&gt;(request: Req)(processResponse: Req#Response =&amp;gt; Unit): Unit = {&lt;br/&gt;
+        super.send(request)( response =&amp;gt; {&lt;br/&gt;
+          responseExecutor.submit(new Runnable {&lt;br/&gt;
+            override def run(): Unit = &lt;/p&gt;
{
+              sendCompleteSemaphore.release()
+              sendSemaphore.acquire()
+              processResponse(response)
+            }
&lt;p&gt;+          })&lt;br/&gt;
+        })&lt;br/&gt;
+      }&lt;br/&gt;
+    }&lt;br/&gt;
+    try {&lt;br/&gt;
+      zooKeeperClient.registerStateChangeHandler(new StateChangeHandler {&lt;br/&gt;
+        override val name: String =&quot;test-state-change-handler&quot;&lt;br/&gt;
+        override def afterInitializingSession(): Unit = &lt;/p&gt;
{
+          verifyHandlerThread()
+          stateChanges.add(&quot;afterInitializingSession&quot;)
+        }
&lt;p&gt;+        override def beforeInitializingSession(): Unit = &lt;/p&gt;
{
+          verifyHandlerThread()
+          stateChanges.add(&quot;beforeInitializingSession&quot;)
+          sendSemaphore.release(sendSize) // Resume remaining sends
+        }
&lt;p&gt;+        private def verifyHandlerThread(): Unit = &lt;/p&gt;
{
+          val threadName = Thread.currentThread.getName
+          assertTrue(s&quot;Unexpected thread + $threadName&quot;, threadName.startsWith(zooKeeperClient.expiryScheduler.threadNamePrefix))
+        }
&lt;p&gt;+      })&lt;br/&gt;
+&lt;br/&gt;
+      val requestThread = new Thread {&lt;br/&gt;
+        override def run(): Unit = &lt;/p&gt;
{
+          val requests = (1 to sendSize).map(i =&amp;gt; GetDataRequest(s&quot;/$i&quot;))
+          resultCodes = zooKeeperClient.handleRequests(requests).map(_.resultCode)
+        }
&lt;p&gt;+      }&lt;br/&gt;
+      requestThread.start()&lt;br/&gt;
+      sendCompleteSemaphore.acquire() // Wait for request thread to start processing requests&lt;br/&gt;
+&lt;br/&gt;
+      // Trigger session expiry by reusing the session id in another client&lt;br/&gt;
+      val dummyWatcher = new Watcher {&lt;br/&gt;
+        override def process(event: WatchedEvent): Unit = {}&lt;br/&gt;
+      }&lt;br/&gt;
+      val anotherZkClient = new ZooKeeper(zkConnect, 1000, dummyWatcher,&lt;br/&gt;
+        zooKeeperClient.currentZooKeeper.getSessionId,&lt;br/&gt;
+        zooKeeperClient.currentZooKeeper.getSessionPasswd)&lt;br/&gt;
+      assertNull(anotherZkClient.exists(&quot;/nonexistent&quot;, false)) // Make sure new client works&lt;br/&gt;
+      sendSemaphore.release(maxInflightRequests) // Resume a few more sends which may fail&lt;br/&gt;
+      anotherZkClient.close()&lt;br/&gt;
+      sendSemaphore.release(maxInflightRequests) // Resume a few more sends which may fail&lt;br/&gt;
+&lt;br/&gt;
+      requestThread.join(10000)&lt;br/&gt;
+      if (requestThread.isAlive) &lt;/p&gt;
{
+        requestThread.interrupt()
+        fail(&quot;Request thread did not complete&quot;)
+      }
&lt;p&gt;+      assertEquals(Seq(&quot;beforeInitializingSession&quot;, &quot;afterInitializingSession&quot;), stateChanges.asScala.toSeq)&lt;br/&gt;
+&lt;br/&gt;
+      assertEquals(resultCodes.size, sendSize)&lt;br/&gt;
+      val connectionLostCount = resultCodes.count(_ == Code.CONNECTIONLOSS)&lt;br/&gt;
+      assertTrue(s&quot;Unexpected connection lost requests $resultCodes&quot;, connectionLostCount &amp;lt;= maxInflightRequests)&lt;br/&gt;
+      val expiredCount = resultCodes.count(_ == Code.SESSIONEXPIRED)&lt;br/&gt;
+      assertTrue(s&quot;Unexpected session expired requests $resultCodes&quot;, expiredCount &amp;lt;= maxInflightRequests)&lt;br/&gt;
+      assertTrue(s&quot;No connection lost or expired requests $resultCodes&quot;, connectionLostCount + expiredCount &amp;gt; 0)&lt;br/&gt;
+      assertEquals(Code.NONODE, resultCodes.head)&lt;br/&gt;
+      assertEquals(Code.NONODE, resultCodes.last)&lt;br/&gt;
+      assertTrue(s&quot;Unexpected result code $resultCodes&quot;,&lt;br/&gt;
+        resultCodes.filterNot(Set(Code.NONODE, Code.SESSIONEXPIRED, Code.CONNECTIONLOSS).contains).isEmpty)&lt;br/&gt;
+&lt;br/&gt;
+    } finally &lt;/p&gt;
{
+      zooKeeperClient.close()
+      responseExecutor.shutdownNow()
+    }
&lt;p&gt;+    assertFalse(&quot;Expiry executor not shutdown&quot;, zooKeeperClient.expiryScheduler.isStarted)&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
   def isExpectedMetricName(metricName: MetricName, name: String): Boolean =&lt;br/&gt;
     metricName.getName == name &amp;amp;&amp;amp; metricName.getGroup == &quot;testMetricGroup&quot; &amp;amp;&amp;amp; metricName.getType == &quot;testMetricType&quot;&lt;/p&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="13137402">KAFKA-6549</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 39 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3pngn:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>junrao</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>