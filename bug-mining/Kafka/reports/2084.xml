<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:15:49 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-5462] Add a configuration for users to specify a template for building a custom principal name</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-5462</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Add a configuration for users to specify a template for building a custom principal name.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13080448">KAFKA-5462</key>
            <summary>Add a configuration for users to specify a template for building a custom principal name</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="omkreddy">Manikumar</assignee>
                                    <reporter username="Koelli">Koelli Mungee</reporter>
                        <labels>
                    </labels>
                <created>Fri, 16 Jun 2017 16:21:01 +0000</created>
                <updated>Tue, 8 Jan 2019 21:05:05 +0000</updated>
                            <resolved>Thu, 25 Oct 2018 11:46:20 +0000</resolved>
                                    <version>0.10.2.1</version>
                                    <fixVersion>2.2.0</fixVersion>
                                    <component>security</component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16052548" author="vahid" created="Sat, 17 Jun 2017 00:05:52 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Koelli&quot; class=&quot;user-hover&quot; rel=&quot;Koelli&quot;&gt;Koelli&lt;/a&gt; Could you please elaborate and provide details about this bug?&lt;/p&gt;</comment>
                            <comment id="16056509" author="koelli" created="Tue, 20 Jun 2017 21:40:23 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=vahid&quot; class=&quot;user-hover&quot; rel=&quot;vahid&quot;&gt;vahid&lt;/a&gt; - currently in order to configure Kafka&apos;s PrincipalBuilder interface a customized principal builder is required. This is seen in cases with SSL where the full DN is not desired. In such scenarios having a property that allows a template for building the principal name would be useful. &lt;/p&gt;</comment>
                            <comment id="16625697" author="githubbot" created="Mon, 24 Sep 2018 11:42:37 +0000"  >&lt;p&gt;omkreddy opened a new pull request #5684: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-5462&quot; title=&quot;Add a configuration for users to specify a template for building a custom principal name&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-5462&quot;&gt;&lt;del&gt;KAFKA-5462&lt;/del&gt;&lt;/a&gt;: Add configuration to build custom SSL principal name (KIP-371)&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5684&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5684&lt;/a&gt;&lt;/p&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16663625" author="githubbot" created="Thu, 25 Oct 2018 11:42:55 +0000"  >&lt;p&gt;omkreddy closed pull request #5684: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-5462&quot; title=&quot;Add a configuration for users to specify a template for building a custom principal name&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-5462&quot;&gt;&lt;del&gt;KAFKA-5462&lt;/del&gt;&lt;/a&gt;: Add configuration to build custom SSL principal name (KIP-371)&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5684&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5684&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/config/internals/BrokerSecurityConfigs.java b/clients/src/main/java/org/apache/kafka/common/config/internals/BrokerSecurityConfigs.java&lt;br/&gt;
index a29d8069b99..e3a8a774a51 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/config/internals/BrokerSecurityConfigs.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/config/internals/BrokerSecurityConfigs.java&lt;br/&gt;
@@ -34,17 +34,28 @@&lt;br/&gt;
     public static final String SSL_CLIENT_AUTH_CONFIG = &quot;ssl.client.auth&quot;;&lt;br/&gt;
     public static final String SASL_ENABLED_MECHANISMS_CONFIG = &quot;sasl.enabled.mechanisms&quot;;&lt;br/&gt;
     public static final String SASL_SERVER_CALLBACK_HANDLER_CLASS = &quot;sasl.server.callback.handler.class&quot;;&lt;br/&gt;
+    public static final String SSL_PRINCIPAL_MAPPING_RULES_CONFIG = &quot;ssl.principal.mapping.rules&quot;;&lt;/p&gt;

&lt;p&gt;     public static final String PRINCIPAL_BUILDER_CLASS_DOC = &quot;The fully qualified name of a class that implements the &quot; +&lt;br/&gt;
             &quot;KafkaPrincipalBuilder interface, which is used to build the KafkaPrincipal object used during &quot; +&lt;br/&gt;
             &quot;authorization. This config also supports the deprecated PrincipalBuilder interface which was previously &quot; +&lt;br/&gt;
             &quot;used for client authentication over SSL. If no principal builder is defined, the default behavior depends &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;on the security protocol in use. For SSL authentication, the principal name will be the distinguished &quot; +&lt;br/&gt;
+            &quot;on the security protocol in use. For SSL authentication,  the principal will be derived using the&quot; +&lt;br/&gt;
+            &quot; rules defined by &amp;lt;code&amp;gt;&quot; + SSL_PRINCIPAL_MAPPING_RULES_CONFIG + &quot;&amp;lt;/code&amp;gt; applied on the distinguished &quot; +&lt;br/&gt;
             &quot;name from the client certificate if one is provided; otherwise, if client authentication is not required, &quot; +&lt;br/&gt;
             &quot;the principal name will be ANONYMOUS. For SASL authentication, the principal will be derived using the &quot; +&lt;br/&gt;
             &quot;rules defined by &amp;lt;code&amp;gt;&quot; + SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_CONFIG + &quot;&amp;lt;/code&amp;gt; if GSSAPI is in use, &quot; +&lt;br/&gt;
             &quot;and the SASL authentication ID for other mechanisms. For PLAINTEXT, the principal will be ANONYMOUS.&quot;;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    public static final String SSL_PRINCIPAL_MAPPING_RULES_DOC = &quot;A list of rules for mapping from distinguished name&quot; +&lt;br/&gt;
+            &quot; from the client certificate to short name. The rules are evaluated in order and the first rule that matches&quot; +&lt;br/&gt;
+            &quot; a principal name is used to map it to a short name. Any later rules in the list are ignored. By default,&quot; +&lt;br/&gt;
+            &quot; distinguished name of the X.500 certificate will be the principal. For more details on the format please&quot; +&lt;br/&gt;
+            &quot; see &amp;lt;a href=\&quot;#security_authz\&quot;&amp;gt; security authorization and acls&amp;lt;/a&amp;gt;. Note that this configuration is ignored&quot; +&lt;br/&gt;
+            &quot; if an extension of KafkaPrincipalBuilder is provided by the &amp;lt;code&amp;gt;&quot; + PRINCIPAL_BUILDER_CLASS_CONFIG + &quot;&amp;lt;/code&amp;gt;&quot; +&lt;br/&gt;
+           &quot; configuration.&quot;;&lt;br/&gt;
+    public static final List&amp;lt;String&amp;gt; DEFAULT_SSL_PRINCIPAL_MAPPING_RULES = Collections.singletonList(&quot;DEFAULT&quot;);&lt;br/&gt;
+&lt;br/&gt;
     public static final String SASL_KERBEROS_PRINCIPAL_TO_LOCAL_RULES_DOC = &quot;A list of rules for mapping from principal &quot; +&lt;br/&gt;
             &quot;names to short names (typically operating system usernames). The rules are evaluated in order and the &quot; +&lt;br/&gt;
             &quot;first rule that matches a principal name is used to map it to a short name. Any later rules in the list are &quot; +&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/network/ChannelBuilders.java b/clients/src/main/java/org/apache/kafka/common/network/ChannelBuilders.java&lt;br/&gt;
index 10779b7881f..b3040f3ef73 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/network/ChannelBuilders.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/network/ChannelBuilders.java&lt;br/&gt;
@@ -26,6 +26,7 @@&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder;&lt;br/&gt;
 import org.apache.kafka.common.security.authenticator.CredentialCache;&lt;br/&gt;
 import org.apache.kafka.common.security.kerberos.KerberosShortNamer;&lt;br/&gt;
+import org.apache.kafka.common.security.ssl.SslPrincipalMapper;&lt;br/&gt;
 import org.apache.kafka.common.security.token.delegation.internals.DelegationTokenCache;&lt;br/&gt;
 import org.apache.kafka.common.utils.Utils;&lt;/p&gt;

&lt;p&gt;@@ -163,12 +164,13 @@ private static void requireNonNullMode(Mode mode, SecurityProtocol securityProto&lt;br/&gt;
     public static KafkaPrincipalBuilder createPrincipalBuilder(Map&amp;lt;String, ?&amp;gt; configs,&lt;br/&gt;
                                                                TransportLayer transportLayer,&lt;br/&gt;
                                                                Authenticator authenticator,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;KerberosShortNamer kerberosShortNamer) {&lt;br/&gt;
+                                                               KerberosShortNamer kerberosShortNamer,&lt;br/&gt;
+                                                               SslPrincipalMapper sslPrincipalMapper) {&lt;br/&gt;
         Class&amp;lt;?&amp;gt; principalBuilderClass = (Class&amp;lt;?&amp;gt;) configs.get(BrokerSecurityConfigs.PRINCIPAL_BUILDER_CLASS_CONFIG);&lt;br/&gt;
         final KafkaPrincipalBuilder builder;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         if (principalBuilderClass == null || principalBuilderClass == DefaultKafkaPrincipalBuilder.class) &lt;/p&gt;
{
-            builder = new DefaultKafkaPrincipalBuilder(kerberosShortNamer);
+            builder = new DefaultKafkaPrincipalBuilder(kerberosShortNamer, sslPrincipalMapper);
         }
&lt;p&gt; else if (KafkaPrincipalBuilder.class.isAssignableFrom(principalBuilderClass)) &lt;/p&gt;
{
             builder = (KafkaPrincipalBuilder) Utils.newInstance(principalBuilderClass);
         }
&lt;p&gt; else if (org.apache.kafka.common.security.auth.PrincipalBuilder.class.isAssignableFrom(principalBuilderClass)) {&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/network/PlaintextChannelBuilder.java b/clients/src/main/java/org/apache/kafka/common/network/PlaintextChannelBuilder.java&lt;br/&gt;
index e397f05060f..e5dc778705f 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/network/PlaintextChannelBuilder.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/network/PlaintextChannelBuilder.java&lt;br/&gt;
@@ -70,7 +70,7 @@ public void close() {}&lt;/p&gt;

&lt;p&gt;         private PlaintextAuthenticator(Map&amp;lt;String, ?&amp;gt; configs, PlaintextTransportLayer transportLayer, ListenerName listenerName) &lt;/p&gt;
{
             this.transportLayer = transportLayer;
-            this.principalBuilder = ChannelBuilders.createPrincipalBuilder(configs, transportLayer, this, null);
+            this.principalBuilder = ChannelBuilders.createPrincipalBuilder(configs, transportLayer, this, null, null);
             this.listenerName = listenerName;
         }

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/network/SslChannelBuilder.java b/clients/src/main/java/org/apache/kafka/common/network/SslChannelBuilder.java&lt;br/&gt;
index 86d41d08518..ffa8deb3127 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/network/SslChannelBuilder.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/network/SslChannelBuilder.java&lt;br/&gt;
@@ -18,10 +18,12 @@&lt;/p&gt;

&lt;p&gt; import org.apache.kafka.common.KafkaException;&lt;br/&gt;
 import org.apache.kafka.common.config.SslConfigs;&lt;br/&gt;
+import org.apache.kafka.common.config.internals.BrokerSecurityConfigs;&lt;br/&gt;
 import org.apache.kafka.common.memory.MemoryPool;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipal;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.SslAuthenticationContext;&lt;br/&gt;
+import org.apache.kafka.common.security.ssl.SslPrincipalMapper;&lt;br/&gt;
 import org.apache.kafka.common.security.ssl.SslFactory;&lt;br/&gt;
 import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
 import org.slf4j.Logger;&lt;br/&gt;
@@ -33,6 +35,7 @@&lt;br/&gt;
 import java.net.InetSocketAddress;&lt;br/&gt;
 import java.nio.channels.SelectionKey;&lt;br/&gt;
 import java.nio.channels.SocketChannel;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
 import java.util.Map;&lt;br/&gt;
 import java.util.Set;&lt;/p&gt;

&lt;p&gt;@@ -44,6 +47,7 @@&lt;br/&gt;
     private SslFactory sslFactory;&lt;br/&gt;
     private Mode mode;&lt;br/&gt;
     private Map&amp;lt;String, ?&amp;gt; configs;&lt;br/&gt;
+    private SslPrincipalMapper sslPrincipalMapper;&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs a SSL channel builder. ListenerName is provided only&lt;br/&gt;
@@ -58,6 +62,10 @@ public SslChannelBuilder(Mode mode, ListenerName listenerName, boolean isInterBr&lt;br/&gt;
     public void configure(Map&amp;lt;String, ?&amp;gt; configs) throws KafkaException {&lt;br/&gt;
         try 
{
             this.configs = configs;
+            @SuppressWarnings(&quot;unchecked&quot;)
+            List&amp;lt;String&amp;gt; sslPrincipalMappingRules = (List&amp;lt;String&amp;gt;) configs.get(BrokerSecurityConfigs.SSL_PRINCIPAL_MAPPING_RULES_CONFIG);
+            if (sslPrincipalMappingRules != null)
+                sslPrincipalMapper = SslPrincipalMapper.fromRules(sslPrincipalMappingRules);
             this.sslFactory = new SslFactory(mode, null, isInterBrokerListener);
             this.sslFactory.configure(this.configs);
         }
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
@@ -89,7 +97,7 @@ public ListenerName listenerName() {&lt;br/&gt;
     public KafkaChannel buildChannel(String id, SelectionKey key, int maxReceiveSize, MemoryPool memoryPool) throws KafkaException {&lt;br/&gt;
         try &lt;/p&gt;
{
             SslTransportLayer transportLayer = buildTransportLayer(sslFactory, id, key, peerHost(key));
-            Authenticator authenticator = new SslAuthenticator(configs, transportLayer, listenerName);
+            Authenticator authenticator = new SslAuthenticator(configs, transportLayer, listenerName, sslPrincipalMapper);
             return new KafkaChannel(id, transportLayer, authenticator, maxReceiveSize,
                     memoryPool != null ? memoryPool : MemoryPool.NONE);
         }
&lt;p&gt; catch (Exception e) {&lt;br/&gt;
@@ -154,9 +162,9 @@ private String peerHost(SelectionKey key) {&lt;br/&gt;
         private final KafkaPrincipalBuilder principalBuilder;&lt;br/&gt;
         private final ListenerName listenerName;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private SslAuthenticator(Map&amp;lt;String, ?&amp;gt; configs, SslTransportLayer transportLayer, ListenerName listenerName) {&lt;br/&gt;
+        private SslAuthenticator(Map&amp;lt;String, ?&amp;gt; configs, SslTransportLayer transportLayer, ListenerName listenerName, SslPrincipalMapper sslPrincipalMapper) 
{
             this.transportLayer = transportLayer;
-            this.principalBuilder = ChannelBuilders.createPrincipalBuilder(configs, transportLayer, this, null);
+            this.principalBuilder = ChannelBuilders.createPrincipalBuilder(configs, transportLayer, this, null, sslPrincipalMapper);
             this.listenerName = listenerName;
         }
&lt;p&gt;         /**&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/security/authenticator/DefaultKafkaPrincipalBuilder.java b/clients/src/main/java/org/apache/kafka/common/security/authenticator/DefaultKafkaPrincipalBuilder.java&lt;br/&gt;
index 30b0a3e0980..38c303f5266 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/clients/src/main/java/org/apache/kafka/common/security/authenticator/DefaultKafkaPrincipalBuilder.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/security/authenticator/DefaultKafkaPrincipalBuilder.java&lt;br/&gt;
@@ -16,6 +16,7 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.common.security.authenticator;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+import javax.security.auth.x500.X500Principal;&lt;br/&gt;
 import org.apache.kafka.common.KafkaException;&lt;br/&gt;
 import org.apache.kafka.common.config.SaslConfigs;&lt;br/&gt;
 import org.apache.kafka.common.network.Authenticator;&lt;br/&gt;
@@ -32,6 +33,8 @@&lt;br/&gt;
 import javax.net.ssl.SSLPeerUnverifiedException;&lt;br/&gt;
 import javax.net.ssl.SSLSession;&lt;br/&gt;
 import javax.security.sasl.SaslServer;&lt;br/&gt;
+import org.apache.kafka.common.security.ssl.SslPrincipalMapper;&lt;br/&gt;
+&lt;br/&gt;
 import java.io.Closeable;&lt;br/&gt;
 import java.io.IOException;&lt;br/&gt;
 import java.security.Principal;&lt;br/&gt;
@@ -55,6 +58,7 @@&lt;br/&gt;
     private final Authenticator authenticator;&lt;br/&gt;
     private final TransportLayer transportLayer;&lt;br/&gt;
     private final KerberosShortNamer kerberosShortNamer;&lt;br/&gt;
+    private final SslPrincipalMapper sslPrincipalMapper;&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Construct a new instance which wraps an instance of the older 
{@link org.apache.kafka.common.security.auth.PrincipalBuilder}
&lt;p&gt;.&lt;br/&gt;
@@ -73,27 +77,31 @@ public static DefaultKafkaPrincipalBuilder fromOldPrincipalBuilder(Authenticator&lt;br/&gt;
                 requireNonNull(authenticator),&lt;br/&gt;
                 requireNonNull(transportLayer),&lt;br/&gt;
                 requireNonNull(oldPrincipalBuilder),&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;kerberosShortNamer);&lt;br/&gt;
+                kerberosShortNamer,&lt;br/&gt;
+                null);&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @SuppressWarnings(&quot;deprecation&quot;)&lt;br/&gt;
     private DefaultKafkaPrincipalBuilder(Authenticator authenticator,&lt;br/&gt;
                                          TransportLayer transportLayer,&lt;br/&gt;
                                          org.apache.kafka.common.security.auth.PrincipalBuilder oldPrincipalBuilder,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;KerberosShortNamer kerberosShortNamer) {&lt;br/&gt;
+                                         KerberosShortNamer kerberosShortNamer,&lt;br/&gt;
+                                         SslPrincipalMapper sslPrincipalMapper) 
{
         this.authenticator = authenticator;
         this.transportLayer = transportLayer;
         this.oldPrincipalBuilder = oldPrincipalBuilder;
         this.kerberosShortNamer = kerberosShortNamer;
+        this.sslPrincipalMapper =  sslPrincipalMapper;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Construct a new instance.&lt;br/&gt;
      *&lt;/li&gt;
	&lt;li&gt;@param kerberosShortNamer Kerberos name rewrite rules or null if none have been configured&lt;br/&gt;
+     * @param sslPrincipalMapper SSL Principal mapper or null if none have been configured&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public DefaultKafkaPrincipalBuilder(KerberosShortNamer kerberosShortNamer) {&lt;/li&gt;
	&lt;li&gt;this(null, null, null, kerberosShortNamer);&lt;br/&gt;
+    public DefaultKafkaPrincipalBuilder(KerberosShortNamer kerberosShortNamer, SslPrincipalMapper sslPrincipalMapper) 
{
+        this(null, null, null, kerberosShortNamer, sslPrincipalMapper);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;br/&gt;
@@ -110,7 +118,7 @@ public KafkaPrincipal build(AuthenticationContext context) {&lt;br/&gt;
                 return convertToKafkaPrincipal(oldPrincipalBuilder.buildPrincipal(transportLayer, authenticator));&lt;/p&gt;

&lt;p&gt;             try &lt;/p&gt;
{
-                return convertToKafkaPrincipal(sslSession.getPeerPrincipal());
+                return applySslPrincipalMapper(sslSession.getPeerPrincipal());
             }
&lt;p&gt; catch (SSLPeerUnverifiedException se) &lt;/p&gt;
{
                 return KafkaPrincipal.ANONYMOUS;
             }
&lt;p&gt;@@ -136,6 +144,19 @@ private KafkaPrincipal applyKerberosShortNamer(String authorizationId) {&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;+    private KafkaPrincipal applySslPrincipalMapper(Principal principal) {&lt;br/&gt;
+        try {&lt;br/&gt;
+            if (!(principal instanceof X500Principal) || principal == KafkaPrincipal.ANONYMOUS) &lt;/p&gt;
{
+                return new KafkaPrincipal(KafkaPrincipal.USER_TYPE, principal.getName());
+            }
&lt;p&gt; else &lt;/p&gt;
{
+                return new KafkaPrincipal(KafkaPrincipal.USER_TYPE, sslPrincipalMapper.getName(principal.getName()));
+            }
&lt;p&gt;+        } catch (IOException e) &lt;/p&gt;
{
+            throw new KafkaException(&quot;Failed to map name for &apos;&quot; + principal.getName() +
+                    &quot;&apos; based on SSL principal mapping rules.&quot;, e);
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
     private KafkaPrincipal convertToKafkaPrincipal(Principal principal) &lt;/p&gt;
{
         return new KafkaPrincipal(KafkaPrincipal.USER_TYPE, principal.getName());
     }
&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java&lt;br/&gt;
index 48a49fe4e94..4db1971b377 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/security/authenticator/SaslServerAuthenticator.java&lt;br/&gt;
@@ -153,7 +153,7 @@ public SaslServerAuthenticator(Map&amp;lt;String, ?&amp;gt; configs,&lt;/p&gt;

&lt;p&gt;         // Note that the old principal builder does not support SASL, so we do not need to pass the&lt;br/&gt;
         // authenticator or the transport layer&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.principalBuilder = ChannelBuilders.createPrincipalBuilder(configs, null, null, kerberosNameParser);&lt;br/&gt;
+        this.principalBuilder = ChannelBuilders.createPrincipalBuilder(configs, null, null, kerberosNameParser, null);&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private void createSaslServer(String mechanism) throws IOException {&lt;br/&gt;
diff --git a/clients/src/main/java/org/apache/kafka/common/security/ssl/SslPrincipalMapper.java b/clients/src/main/java/org/apache/kafka/common/security/ssl/SslPrincipalMapper.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..7ec4a79b2eb&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/security/ssl/SslPrincipalMapper.java&lt;br/&gt;
@@ -0,0 +1,197 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.common.security.ssl;&lt;br/&gt;
+&lt;br/&gt;
+import java.io.IOException;&lt;br/&gt;
+import java.util.ArrayList;&lt;br/&gt;
+import java.util.Collections;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+import java.util.Locale;&lt;br/&gt;
+import java.util.regex.Matcher;&lt;br/&gt;
+import java.util.regex.Pattern;&lt;br/&gt;
+&lt;br/&gt;
+public class SslPrincipalMapper {&lt;br/&gt;
+&lt;br/&gt;
+    private static final Pattern RULE_PARSER = Pattern.compile(&quot;((DEFAULT)|(RULE&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/sad.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;(&lt;span class=&quot;error&quot;&gt;&amp;#91;^/&amp;#93;&lt;/span&gt;&lt;b&gt;)/(&lt;span class=&quot;error&quot;&gt;&amp;#91;^/&amp;#93;&lt;/span&gt;&lt;/b&gt;))/(&lt;span class=&quot;error&quot;&gt;&amp;#91;LU&amp;#93;&lt;/span&gt;)?))&quot;);&lt;br/&gt;
+&lt;br/&gt;
+    private final List&amp;lt;Rule&amp;gt; rules;&lt;br/&gt;
+&lt;br/&gt;
+    public SslPrincipalMapper(List&amp;lt;Rule&amp;gt; sslPrincipalMappingRules) &lt;/p&gt;
{
+        this.rules = sslPrincipalMappingRules;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static SslPrincipalMapper fromRules(List&amp;lt;String&amp;gt; sslPrincipalMappingRules) &lt;/p&gt;
{
+        List&amp;lt;String&amp;gt; rules = sslPrincipalMappingRules == null ? Collections.singletonList(&quot;DEFAULT&quot;) : sslPrincipalMappingRules;
+        return new SslPrincipalMapper(parseRules(rules));
+    }
&lt;p&gt;+&lt;br/&gt;
+    private static List&amp;lt;Rule&amp;gt; parseRules(List&amp;lt;String&amp;gt; rules) {&lt;br/&gt;
+        List&amp;lt;Rule&amp;gt; result = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
+        for (String rule : rules) {&lt;br/&gt;
+            Matcher matcher = RULE_PARSER.matcher(rule);&lt;br/&gt;
+            if (!matcher.lookingAt()) &lt;/p&gt;
{
+                throw new IllegalArgumentException(&quot;Invalid rule: &quot; + rule);
+            }
&lt;p&gt;+            if (rule.length() != matcher.end()) &lt;/p&gt;
{
+                throw new IllegalArgumentException(&quot;Invalid rule: `&quot; + rule + &quot;`, unmatched substring: `&quot; + rule.substring(matcher.end()) + &quot;`&quot;);
+            }
&lt;p&gt;+            if (matcher.group(2) != null) &lt;/p&gt;
{
+                result.add(new Rule());
+            }
&lt;p&gt; else &lt;/p&gt;
{
+                result.add(new Rule(matcher.group(5),
+                                    matcher.group(6),
+                                    &quot;L&quot;.equals(matcher.group(7)),
+                                    &quot;U&quot;.equals(matcher.group(7))));
+            }
&lt;p&gt;+        }&lt;br/&gt;
+        return result;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public String getName(String distinguishedName) throws IOException {&lt;br/&gt;
+        for (Rule r : rules) {&lt;br/&gt;
+            String principalName = r.apply(distinguishedName);&lt;br/&gt;
+            if (principalName != null) &lt;/p&gt;
{
+                return principalName;
+            }
&lt;p&gt;+        }&lt;br/&gt;
+        throw new NoMatchingRule(&quot;No rules apply to &quot; + distinguishedName + &quot;, rules &quot; + rules);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public String toString() &lt;/p&gt;
{
+        return &quot;SslPrincipalMapper(rules = &quot; + rules + &quot;)&quot;;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static class NoMatchingRule extends IOException {&lt;br/&gt;
+        NoMatchingRule(String msg) &lt;/p&gt;
{
+            super(msg);
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    private static class Rule {&lt;br/&gt;
+        private static final Pattern BACK_REFERENCE_PATTERN = Pattern.compile(&quot;\\$(&lt;br class=&quot;atl-forced-newline&quot; /&gt;d+)&quot;);&lt;br/&gt;
+&lt;br/&gt;
+        private final boolean isDefault;&lt;br/&gt;
+        private final Pattern pattern;&lt;br/&gt;
+        private final String replacement;&lt;br/&gt;
+        private final boolean toLowerCase;&lt;br/&gt;
+        private final boolean toUpperCase;&lt;br/&gt;
+&lt;br/&gt;
+        Rule() &lt;/p&gt;
{
+            isDefault = true;
+            pattern = null;
+            replacement = null;
+            toLowerCase = false;
+            toUpperCase = false;
+        }
&lt;p&gt;+&lt;br/&gt;
+        Rule(String pattern, String replacement, boolean toLowerCase, boolean toUpperCase) &lt;/p&gt;
{
+            isDefault = false;
+            this.pattern = pattern == null ? null : Pattern.compile(pattern);
+            this.replacement = replacement;
+            this.toLowerCase = toLowerCase;
+            this.toUpperCase = toUpperCase;
+        }
&lt;p&gt;+&lt;br/&gt;
+        String apply(String distinguishedName) {&lt;br/&gt;
+            if (isDefault) &lt;/p&gt;
{
+                return distinguishedName;
+            }
&lt;p&gt;+&lt;br/&gt;
+            String result = null;&lt;br/&gt;
+            final Matcher m = pattern.matcher(distinguishedName);&lt;br/&gt;
+&lt;br/&gt;
+            if (m.matches()) &lt;/p&gt;
{
+                result = distinguishedName.replaceAll(pattern.pattern(), escapeLiteralBackReferences(replacement, m.groupCount()));
+            }
&lt;p&gt;+&lt;br/&gt;
+            if (toLowerCase &amp;amp;&amp;amp; result != null) &lt;/p&gt;
{
+                result = result.toLowerCase(Locale.ENGLISH);
+            }
&lt;p&gt; else if (toUpperCase &amp;amp; result != null) &lt;/p&gt;
{
+                result = result.toUpperCase(Locale.ENGLISH);
+            }
&lt;p&gt;+&lt;br/&gt;
+            return result;&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        //If we find a back reference that is not valid, then we will treat it as a literal string. For example, if we have 3 capturing&lt;br/&gt;
+        //groups and the Replacement Value has the value is &quot;$1@$4&quot;, then we want to treat the $4 as a literal &quot;$4&quot;, rather&lt;br/&gt;
+        //than attempting to use it as a back reference.&lt;br/&gt;
+        //This method was taken from Apache Nifi project : org.apache.nifi.authorization.util.IdentityMappingUtil&lt;br/&gt;
+        private String escapeLiteralBackReferences(final String unescaped, final int numCapturingGroups) {&lt;br/&gt;
+            if (numCapturingGroups == 0) &lt;/p&gt;
{
+                return unescaped;
+            }
&lt;p&gt;+&lt;br/&gt;
+            String value = unescaped;&lt;br/&gt;
+            final Matcher backRefMatcher = BACK_REFERENCE_PATTERN.matcher(value);&lt;br/&gt;
+            while (backRefMatcher.find()) {&lt;br/&gt;
+                final String backRefNum = backRefMatcher.group(1);&lt;br/&gt;
+                if (backRefNum.startsWith(&quot;0&quot;)) &lt;/p&gt;
{
+                    continue;
+                }
&lt;p&gt;+                final int originalBackRefIndex = Integer.parseInt(backRefNum);&lt;br/&gt;
+                int backRefIndex = originalBackRefIndex;&lt;br/&gt;
+&lt;br/&gt;
+&lt;br/&gt;
+                // if we have a replacement value like $123, and we have less than 123 capturing groups, then&lt;br/&gt;
+                // we want to truncate the 3 and use capturing group 12; if we have less than 12 capturing groups,&lt;br/&gt;
+                // then we want to truncate the 2 and use capturing group 1; if we don&apos;t have a capturing group then&lt;br/&gt;
+                // we want to truncate the 1 and get 0.&lt;br/&gt;
+                while (backRefIndex &amp;gt; numCapturingGroups &amp;amp;&amp;amp; backRefIndex &amp;gt;= 10) &lt;/p&gt;
{
+                    backRefIndex /= 10;
+                }
&lt;p&gt;+&lt;br/&gt;
+                if (backRefIndex &amp;gt; numCapturingGroups) &lt;/p&gt;
{
+                    final StringBuilder sb = new StringBuilder(value.length() + 1);
+                    final int groupStart = backRefMatcher.start(1);
+
+                    sb.append(value.substring(0, groupStart - 1));
+                    sb.append(&quot;\\&quot;);
+                    sb.append(value.substring(groupStart - 1));
+                    value = sb.toString();
+                }
&lt;p&gt;+            }&lt;br/&gt;
+&lt;br/&gt;
+            return value;&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        @Override&lt;br/&gt;
+        public String toString() {&lt;br/&gt;
+            StringBuilder buf = new StringBuilder();&lt;br/&gt;
+            if (isDefault) &lt;/p&gt;
{
+                buf.append(&quot;DEFAULT&quot;);
+            }
&lt;p&gt; else {&lt;br/&gt;
+                buf.append(&quot;RULE:&quot;);&lt;br/&gt;
+                if (pattern != null) &lt;/p&gt;
{
+                    buf.append(pattern);
+                }
&lt;p&gt;+                if (replacement != null) &lt;/p&gt;
{
+                    buf.append(&quot;/&quot;);
+                    buf.append(replacement);
+                }
&lt;p&gt;+                if (toLowerCase) &lt;/p&gt;
{
+                    buf.append(&quot;/L&quot;);
+                }
&lt;p&gt; else if (toUpperCase) &lt;/p&gt;
{
+                    buf.append(&quot;/U&quot;);
+                }
&lt;p&gt;+            }&lt;br/&gt;
+            return buf.toString();&lt;br/&gt;
+        }&lt;br/&gt;
+&lt;br/&gt;
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/clients/src/test/java/org/apache/kafka/common/network/ChannelBuildersTest.java b/clients/src/test/java/org/apache/kafka/common/network/ChannelBuildersTest.java&lt;br/&gt;
index 27daf0face8..630cba1f3e1 100644&lt;br/&gt;
&amp;#8212; a/clients/src/test/java/org/apache/kafka/common/network/ChannelBuildersTest.java&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/common/network/ChannelBuildersTest.java&lt;br/&gt;
@@ -45,7 +45,7 @@ public void testCreateOldPrincipalBuilder() throws Exception {&lt;/p&gt;

&lt;p&gt;         Map&amp;lt;String, Object&amp;gt; configs = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
         configs.put(BrokerSecurityConfigs.PRINCIPAL_BUILDER_CLASS_CONFIG, OldPrincipalBuilder.class);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;KafkaPrincipalBuilder builder = ChannelBuilders.createPrincipalBuilder(configs, transportLayer, authenticator, null);&lt;br/&gt;
+        KafkaPrincipalBuilder builder = ChannelBuilders.createPrincipalBuilder(configs, transportLayer, authenticator, null, null);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // test old principal builder is properly configured and delegated to&lt;br/&gt;
         assertTrue(OldPrincipalBuilder.configured);&lt;br/&gt;
@@ -60,7 +60,7 @@ public void testCreateOldPrincipalBuilder() throws Exception {&lt;br/&gt;
     public void testCreateConfigurableKafkaPrincipalBuilder() &lt;/p&gt;
{
         Map&amp;lt;String, Object&amp;gt; configs = new HashMap&amp;lt;&amp;gt;();
         configs.put(BrokerSecurityConfigs.PRINCIPAL_BUILDER_CLASS_CONFIG, ConfigurableKafkaPrincipalBuilder.class);
-        KafkaPrincipalBuilder builder = ChannelBuilders.createPrincipalBuilder(configs, null, null, null);
+        KafkaPrincipalBuilder builder = ChannelBuilders.createPrincipalBuilder(configs, null, null, null, null);
         assertTrue(builder instanceof ConfigurableKafkaPrincipalBuilder);
         assertTrue(((ConfigurableKafkaPrincipalBuilder) builder).configured);
     }
&lt;p&gt;diff --git a/clients/src/test/java/org/apache/kafka/common/security/auth/DefaultKafkaPrincipalBuilderTest.java b/clients/src/test/java/org/apache/kafka/common/security/auth/DefaultKafkaPrincipalBuilderTest.java&lt;br/&gt;
index a05a8502bf1..dd5087a84b3 100644&lt;br/&gt;
&amp;#8212; a/clients/src/test/java/org/apache/kafka/common/security/auth/DefaultKafkaPrincipalBuilderTest.java&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/common/security/auth/DefaultKafkaPrincipalBuilderTest.java&lt;br/&gt;
@@ -16,23 +16,28 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.common.security.auth;&lt;/p&gt;

&lt;p&gt;+import javax.security.auth.x500.X500Principal;&lt;br/&gt;
 import org.apache.kafka.common.config.SaslConfigs;&lt;br/&gt;
 import org.apache.kafka.common.network.Authenticator;&lt;br/&gt;
 import org.apache.kafka.common.network.TransportLayer;&lt;br/&gt;
 import org.apache.kafka.common.security.authenticator.DefaultKafkaPrincipalBuilder;&lt;br/&gt;
 import org.apache.kafka.common.security.kerberos.KerberosShortNamer;&lt;br/&gt;
 import org.apache.kafka.common.security.scram.internals.ScramMechanism;&lt;br/&gt;
+import org.apache.kafka.common.security.ssl.SslPrincipalMapper;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt; import javax.net.ssl.SSLSession;&lt;br/&gt;
 import javax.security.sasl.SaslServer;&lt;br/&gt;
 import java.net.InetAddress;&lt;br/&gt;
 import java.security.Principal;&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+import java.util.List;&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.mockito.ArgumentMatchers.any;&lt;br/&gt;
 import static org.mockito.Mockito.atLeastOnce;&lt;br/&gt;
 import static org.mockito.Mockito.mock;&lt;br/&gt;
+import static org.mockito.Mockito.times;&lt;br/&gt;
 import static org.mockito.Mockito.verify;&lt;br/&gt;
 import static org.mockito.Mockito.when;&lt;/p&gt;

&lt;p&gt;@@ -63,7 +68,7 @@ public void testUseOldPrincipalBuilderForPlaintextIfProvided() throws Exception&lt;/p&gt;

&lt;p&gt;     @Test&lt;br/&gt;
     public void testReturnAnonymousPrincipalForPlaintext() throws Exception {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try (DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null)) {&lt;br/&gt;
+        try (DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null, null)) 
{
             assertEquals(KafkaPrincipal.ANONYMOUS, builder.build(
                     new PlaintextAuthenticationContext(InetAddress.getLocalHost(), SecurityProtocol.PLAINTEXT.name())));
         }
&lt;p&gt;@@ -100,7 +105,7 @@ public void testUseSessionPeerPrincipalForSsl() throws Exception {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         when(session.getPeerPrincipal()).thenReturn(new DummyPrincipal(&quot;foo&quot;));&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null);&lt;br/&gt;
+        DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null, null);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         KafkaPrincipal principal = builder.build(&lt;br/&gt;
                 new SslAuthenticationContext(session, InetAddress.getLocalHost(), SecurityProtocol.PLAINTEXT.name()));&lt;br/&gt;
@@ -112,6 +117,60 @@ public void testUseSessionPeerPrincipalForSsl() throws Exception &lt;/p&gt;
{
         verify(session, atLeastOnce()).getPeerPrincipal();
     }

&lt;p&gt;+    @Test&lt;br/&gt;
+    public void testPrincipalIfSSLPeerIsNotAuthenticated() throws Exception &lt;/p&gt;
{
+        SSLSession session = mock(SSLSession.class);
+
+        when(session.getPeerPrincipal()).thenReturn(KafkaPrincipal.ANONYMOUS);
+
+        DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null, null);
+
+        KafkaPrincipal principal = builder.build(
+                new SslAuthenticationContext(session, InetAddress.getLocalHost(), SecurityProtocol.PLAINTEXT.name()));
+        assertEquals(KafkaPrincipal.ANONYMOUS, principal);
+
+        builder.close();
+        verify(session, atLeastOnce()).getPeerPrincipal();
+    }
&lt;p&gt;+&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testPrincipalWithSslPrincipalMapper() throws Exception &lt;/p&gt;
{
+        SSLSession session = mock(SSLSession.class);
+
+        when(session.getPeerPrincipal()).thenReturn(new X500Principal(&quot;CN=Duke, OU=ServiceUsers, O=Org, C=US&quot;))
+                                        .thenReturn(new X500Principal(&quot;CN=Duke, OU=SME, O=mycp, L=Fulton, ST=MD, C=US&quot;))
+                                        .thenReturn(new X500Principal(&quot;CN=duke, OU=JavaSoft, O=Sun Microsystems&quot;))
+                                        .thenReturn(new X500Principal(&quot;OU=JavaSoft, O=Sun Microsystems, C=US&quot;));
+
+        List&amp;lt;String&amp;gt; rules = Arrays.asList(
+            &quot;RULE:^CN=(.*),OU=ServiceUsers.*$/$1/L&quot;,
+            &quot;RULE:^CN=(.*),OU=(.*),O=(.*),L=(.*),ST=(.*),C=(.*)$/$1@$2/L&quot;,
+            &quot;RULE:^.*[Cc][Nn]=([a-zA-Z0-9.]*).*$/$1/U&quot;,
+            &quot;DEFAULT&quot;
+        );
+
+        SslPrincipalMapper mapper = SslPrincipalMapper.fromRules(rules);
+        DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null, mapper);
+
+        SslAuthenticationContext sslContext = new SslAuthenticationContext(session, InetAddress.getLocalHost(), SecurityProtocol.PLAINTEXT.name());
+
+        KafkaPrincipal principal = builder.build(sslContext);
+        assertEquals(&quot;duke&quot;, principal.getName());
+
+        principal = builder.build(sslContext);
+        assertEquals(&quot;duke@sme&quot;, principal.getName());
+
+        principal = builder.build(sslContext);
+        assertEquals(&quot;DUKE&quot;, principal.getName());
+
+        principal = builder.build(sslContext);
+        assertEquals(&quot;OU=JavaSoft,O=Sun Microsystems,C=US&quot;, principal.getName());
+
+        builder.close();
+        verify(session, times(4)).getPeerPrincipal();
+    }
&lt;p&gt;+&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testPrincipalBuilderScram() throws Exception {&lt;br/&gt;
         SaslServer server = mock(SaslServer.class);&lt;br/&gt;
@@ -119,7 +178,7 @@ public void testPrincipalBuilderScram() throws Exception {&lt;br/&gt;
         when(server.getMechanismName()).thenReturn(ScramMechanism.SCRAM_SHA_256.mechanismName());&lt;br/&gt;
         when(server.getAuthorizationID()).thenReturn(&quot;foo&quot;);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null);&lt;br/&gt;
+        DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(null, null);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         KafkaPrincipal principal = builder.build(new SaslAuthenticationContext(server,&lt;br/&gt;
                 SecurityProtocol.SASL_PLAINTEXT, InetAddress.getLocalHost(), SecurityProtocol.SASL_PLAINTEXT.name()));&lt;br/&gt;
@@ -141,7 +200,7 @@ public void testPrincipalBuilderGssapi() throws Exception {&lt;br/&gt;
         when(server.getAuthorizationID()).thenReturn(&quot;foo/host@REALM.COM&quot;);&lt;br/&gt;
         when(kerberosShortNamer.shortName(any())).thenReturn(&quot;foo&quot;);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(kerberosShortNamer);&lt;br/&gt;
+        DefaultKafkaPrincipalBuilder builder = new DefaultKafkaPrincipalBuilder(kerberosShortNamer, null);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         KafkaPrincipal principal = builder.build(new SaslAuthenticationContext(server,&lt;br/&gt;
                 SecurityProtocol.SASL_PLAINTEXT, InetAddress.getLocalHost(), SecurityProtocol.SASL_PLAINTEXT.name()));&lt;br/&gt;
diff --git a/clients/src/test/java/org/apache/kafka/common/security/ssl/SslPrincipalMapperTest.java b/clients/src/test/java/org/apache/kafka/common/security/ssl/SslPrincipalMapperTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..c647fd00a3d&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/common/security/ssl/SslPrincipalMapperTest.java&lt;br/&gt;
@@ -0,0 +1,85 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.common.security.ssl;&lt;br/&gt;
+&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Arrays;&lt;br/&gt;
+import java.util.List;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.fail;&lt;br/&gt;
+&lt;br/&gt;
+public class SslPrincipalMapperTest {&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testValidRules() &lt;/p&gt;
{
+        testValidRule(Arrays.asList(&quot;DEFAULT&quot;));
+        testValidRule(Arrays.asList(&quot;RULE:^CN=(.*?),OU=ServiceUsers.*$/$1/&quot;));
+        testValidRule(Arrays.asList(&quot;RULE:^CN=(.*?),OU=ServiceUsers.*$/$1/L&quot;, &quot;DEFAULT&quot;));
+        testValidRule(Arrays.asList(&quot;RULE:^CN=(.*?),OU=(.*?),O=(.*?),L=(.*?),ST=(.*?),C=(.*?)$/$1@$2/&quot;));
+        testValidRule(Arrays.asList(&quot;RULE:^.*[Cc][Nn]=([a-zA-Z0-9.]*).*$/$1/L&quot;));
+        testValidRule(Arrays.asList(&quot;RULE:^cn=(.?),ou=(.?),dc=(.?),dc=(.?)$/$1@$2/U&quot;));
+    }
&lt;p&gt;+&lt;br/&gt;
+    private void testValidRule(List&amp;lt;String&amp;gt; rules) &lt;/p&gt;
{
+        SslPrincipalMapper.fromRules(rules);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testInvalidRules() &lt;/p&gt;
{
+        testInvalidRule(Arrays.asList(&quot;default&quot;));
+        testInvalidRule(Arrays.asList(&quot;DEFAUL&quot;));
+        testInvalidRule(Arrays.asList(&quot;DEFAULT/L&quot;));
+        testInvalidRule(Arrays.asList(&quot;DEFAULT/U&quot;));
+
+        testInvalidRule(Arrays.asList(&quot;RULE:CN=(.*?),OU=ServiceUsers.*/$1&quot;));
+        testInvalidRule(Arrays.asList(&quot;rule:^CN=(.*?),OU=ServiceUsers.*$/$1/&quot;));
+        testInvalidRule(Arrays.asList(&quot;RULE:^CN=(.*?),OU=ServiceUsers.*$/$1/L/U&quot;));
+        testInvalidRule(Arrays.asList(&quot;RULE:^CN=(.*?),OU=ServiceUsers.*$/L&quot;));
+        testInvalidRule(Arrays.asList(&quot;RULE:^CN=(.*?),OU=ServiceUsers.*$/U&quot;));
+        testInvalidRule(Arrays.asList(&quot;RULE:^CN=(.*?),OU=ServiceUsers.*$/LU&quot;));
+    }
&lt;p&gt;+&lt;br/&gt;
+    private void testInvalidRule(List&amp;lt;String&amp;gt; rules) {&lt;br/&gt;
+        try &lt;/p&gt;
{
+            System.out.println(SslPrincipalMapper.fromRules(rules));
+            fail(&quot;should have thrown IllegalArgumentException&quot;);
+        }
&lt;p&gt; catch (IllegalArgumentException e) &lt;/p&gt;
{
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testSslPrincipalMapper() throws Exception &lt;/p&gt;
{
+        List&amp;lt;String&amp;gt; rules = Arrays.asList(
+            &quot;RULE:^CN=(.*?),OU=ServiceUsers.*$/$1/L&quot;,
+            &quot;RULE:^CN=(.*?),OU=(.*?),O=(.*?),L=(.*?),ST=(.*?),C=(.*?)$/$1@$2/L&quot;,
+            &quot;RULE:^cn=(.*?),ou=(.*?),dc=(.*?),dc=(.*?)$/$1@$2/U&quot;,
+            &quot;RULE:^.*[Cc][Nn]=([a-zA-Z0-9.]*).*$/$1/U&quot;,
+            &quot;DEFAULT&quot;
+        );
+
+        SslPrincipalMapper mapper = SslPrincipalMapper.fromRules(rules);
+
+        assertEquals(&quot;duke&quot;, mapper.getName(&quot;CN=Duke,OU=ServiceUsers,O=Org,C=US&quot;));
+        assertEquals(&quot;duke@sme&quot;, mapper.getName(&quot;CN=Duke,OU=SME,O=mycp,L=Fulton,ST=MD,C=US&quot;));
+        assertEquals(&quot;DUKE@SME&quot;, mapper.getName(&quot;cn=duke,ou=sme,dc=mycp,dc=com&quot;));
+        assertEquals(&quot;DUKE&quot;, mapper.getName(&quot;cN=duke,OU=JavaSoft,O=Sun Microsystems&quot;));
+        assertEquals(&quot;OU=JavaSoft,O=Sun Microsystems,C=US&quot;, mapper.getName(&quot;OU=JavaSoft,O=Sun Microsystems,C=US&quot;));
+    }
&lt;p&gt;+&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/core/src/main/scala/kafka/server/KafkaConfig.scala b/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
index 9edda4ea7f1..9bf41a1e054 100755&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
@@ -220,6 +220,7 @@ object Defaults {&lt;br/&gt;
   val SslClientAuthRequested = &quot;requested&quot;&lt;br/&gt;
   val SslClientAuthNone = &quot;none&quot;&lt;br/&gt;
   val SslClientAuth = SslClientAuthNone&lt;br/&gt;
+  val SslPrincipalMappingRules = BrokerSecurityConfigs.DEFAULT_SSL_PRINCIPAL_MAPPING_RULES&lt;/p&gt;

&lt;p&gt;   /** ********* Sasl configuration ***********/&lt;br/&gt;
   val SaslMechanismInterBrokerProtocol = SaslConfigs.DEFAULT_SASL_MECHANISM&lt;br/&gt;
@@ -439,6 +440,7 @@ object KafkaConfig {&lt;br/&gt;
   val SslEndpointIdentificationAlgorithmProp = SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG&lt;br/&gt;
   val SslSecureRandomImplementationProp = SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG&lt;br/&gt;
   val SslClientAuthProp = BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG&lt;br/&gt;
+  val SslPrincipalMappingRulesProp = BrokerSecurityConfigs.SSL_PRINCIPAL_MAPPING_RULES_CONFIG&lt;/p&gt;

&lt;p&gt;   /** ********* SASL Configuration ****************/&lt;br/&gt;
   val SaslMechanismInterBrokerProtocolProp = &quot;sasl.mechanism.inter.broker.protocol&quot;&lt;br/&gt;
@@ -760,6 +762,7 @@ object KafkaConfig {&lt;br/&gt;
   val SslEndpointIdentificationAlgorithmDoc = SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC&lt;br/&gt;
   val SslSecureRandomImplementationDoc = SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_DOC&lt;br/&gt;
   val SslClientAuthDoc = BrokerSecurityConfigs.SSL_CLIENT_AUTH_DOC&lt;br/&gt;
+  val SslPrincipalMappingRulesDoc = BrokerSecurityConfigs.SSL_PRINCIPAL_MAPPING_RULES_DOC&lt;/p&gt;

&lt;p&gt;   /** ********* Sasl Configuration ****************/&lt;br/&gt;
   val SaslMechanismInterBrokerProtocolDoc = &quot;SASL mechanism used for inter-broker communication. Default is GSSAPI.&quot;&lt;br/&gt;
@@ -998,6 +1001,7 @@ object KafkaConfig {&lt;br/&gt;
       .define(SslSecureRandomImplementationProp, STRING, null, LOW, SslSecureRandomImplementationDoc)&lt;br/&gt;
       .define(SslClientAuthProp, STRING, Defaults.SslClientAuth, in(Defaults.SslClientAuthRequired, Defaults.SslClientAuthRequested, Defaults.SslClientAuthNone), MEDIUM, SslClientAuthDoc)&lt;br/&gt;
       .define(SslCipherSuitesProp, LIST, Collections.emptyList(), MEDIUM, SslCipherSuitesDoc)&lt;br/&gt;
+      .define(SslPrincipalMappingRulesProp, LIST, Defaults.SslPrincipalMappingRules, LOW, SslPrincipalMappingRulesDoc)&lt;/p&gt;

&lt;p&gt;       /** ********* Sasl Configuration ****************/&lt;br/&gt;
       .define(SaslMechanismInterBrokerProtocolProp, STRING, Defaults.SaslMechanismInterBrokerProtocol, MEDIUM, SaslMechanismInterBrokerProtocolDoc)&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/server/KafkaConfigTest.scala b/core/src/test/scala/unit/kafka/server/KafkaConfigTest.scala&lt;br/&gt;
index b75c3e7eb24..ba8e54b2eac 100755&lt;br/&gt;
&amp;#8212; a/core/src/test/scala/unit/kafka/server/KafkaConfigTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/server/KafkaConfigTest.scala&lt;br/&gt;
@@ -691,6 +691,7 @@ class KafkaConfigTest {&lt;br/&gt;
         case KafkaConfig.SslEndpointIdentificationAlgorithmProp =&amp;gt; // ignore string&lt;br/&gt;
         case KafkaConfig.SslSecureRandomImplementationProp =&amp;gt; // ignore string&lt;br/&gt;
         case KafkaConfig.SslCipherSuitesProp =&amp;gt; // ignore string&lt;br/&gt;
+        case KafkaConfig.SslPrincipalMappingRulesProp =&amp;gt; // ignore string&lt;/p&gt;

&lt;p&gt;         //Sasl Configs&lt;br/&gt;
         case KafkaConfig.SaslMechanismInterBrokerProtocolProp =&amp;gt; // ignore&lt;br/&gt;
diff --git a/docs/security.html b/docs/security.html&lt;br/&gt;
index b0183343a4b..1cd7c784d09 100644&lt;br/&gt;
&amp;#8212; a/docs/security.html&lt;br/&gt;
+++ b/docs/security.html&lt;br/&gt;
@@ -1020,8 +1020,37 @@ &amp;lt;h3&amp;gt;&amp;lt;a id=&quot;security_authz&quot; href=&quot;#security_authz&quot;&amp;gt;7.4 Authorization and ACLs&amp;lt;/a&amp;gt;&lt;br/&gt;
     &amp;lt;pre&amp;gt;allow.everyone.if.no.acl.found=true&amp;lt;/pre&amp;gt;&lt;br/&gt;
     One can also add super users in server.properties like the following (note that the delimiter is semicolon since SSL user names may contain comma). Default PrincipalType string &quot;User&quot; is case sensitive.&lt;br/&gt;
     &amp;lt;pre&amp;gt;super.users=User:Bob;User:Alice&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;By default, the SSL user name will be of the form &quot;CN=writeuser,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown&quot;. One can change that by setting a customized PrincipalBuilder in server.properties like the following.&lt;br/&gt;
+&lt;br/&gt;
+    &amp;lt;h5&amp;gt;&amp;lt;a id=&quot;security_authz_ssl&quot; href=&quot;#security_authz_ssl&quot;&amp;gt;Customizing SSL User Name&amp;lt;/a&amp;gt;&amp;lt;/h5&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+    By default, the SSL user name will be of the form &quot;CN=writeuser,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown&quot;. One can change that by setting &amp;lt;code&amp;gt;ssl.principal.mapping.rules&amp;lt;/code&amp;gt; to a customized rule in server.properties.&lt;br/&gt;
+    This config allows a list of rules for mapping X.500 distinguished name to short name. The rules are evaluated in order and the first rule that matches a distinguished name is used to map it to a short name. Any later rules in the list are ignored.&lt;br/&gt;
+&lt;br/&gt;
+    &amp;lt;br&amp;gt;The format of &amp;lt;code&amp;gt;ssl.principal.mapping.rules&amp;lt;/code&amp;gt; is a list where each rule starts with &quot;RULE:&quot; and contains an expression as the following formats. Default rule will return&lt;br/&gt;
+    string representation of the X.500 certificate distinguished name. If the distinguished name matches the pattern, then the replacement command will be run over the name.&lt;br/&gt;
+    This also supports lowercase/uppercase options, to force the translated result to be all lower/uppercase case. This is done by adding a &quot;/L&quot; or &quot;/U&apos; to the end of the rule.&lt;br/&gt;
+&lt;br/&gt;
+    &amp;lt;pre&amp;gt;&lt;br/&gt;
+        RULE:pattern/replacement/&lt;br/&gt;
+        RULE:pattern/replacement/&lt;span class=&quot;error&quot;&gt;&amp;#91;LU&amp;#93;&lt;/span&gt;&lt;br/&gt;
+    &amp;lt;/pre&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+    Example &amp;lt;code&amp;gt;ssl.principal.mapping.rules&amp;lt;/code&amp;gt; values are:&lt;br/&gt;
+    &amp;lt;pre&amp;gt;&lt;br/&gt;
+        RULE:^CN=(.&lt;b&gt;?),OU=ServiceUsers.&lt;/b&gt;$/$1/,&lt;br/&gt;
+        RULE:^CN=(.&lt;b&gt;?),OU=(.&lt;/b&gt;?),O=(.&lt;b&gt;?),L=(.&lt;/b&gt;?),ST=(.&lt;b&gt;?),C=(.&lt;/b&gt;?)$/$1@$2/L,&lt;br/&gt;
+        RULE:^.&lt;b&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Cc&amp;#93;&lt;/span&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;Nn&amp;#93;&lt;/span&gt;=(&lt;span class=&quot;error&quot;&gt;&amp;#91;a-zA-Z0-9.&amp;#93;&lt;/span&gt;&lt;/b&gt;).*$/$1/L,&lt;br/&gt;
+        DEFAULT&lt;br/&gt;
+    &amp;lt;/pre&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+    Above rules translate distinguished name &quot;CN=serviceuser,OU=ServiceUsers,O=Unknown,L=Unknown,ST=Unknown,C=Unknown&quot; to &quot;serviceuser&quot;&lt;br/&gt;
+    and &quot;CN=adminUser,OU=Admin,O=Unknown,L=Unknown,ST=Unknown,C=Unknown&quot; to &quot;adminuser@admin&quot;.&lt;br/&gt;
+&lt;br/&gt;
+    &amp;lt;br&amp;gt;For advanced use cases, one can customize the name by setting a customized PrincipalBuilder in server.properties like the following.&lt;br/&gt;
     &amp;lt;pre&amp;gt;principal.builder.class=CustomizedPrincipalBuilderClass&amp;lt;/pre&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+    &amp;lt;h5&amp;gt;&amp;lt;a id=&quot;security_authz_sasl&quot; href=&quot;#security_authz_sasl&quot;&amp;gt;Customizing SASL User Name&amp;lt;/a&amp;gt;&amp;lt;/h5&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
     By default, the SASL user name will be the primary part of the Kerberos principal. One can change that by setting &amp;lt;code&amp;gt;sasl.kerberos.principal.to.local.rules&amp;lt;/code&amp;gt; to a customized rule in server.properties.&lt;br/&gt;
     The format of &amp;lt;code&amp;gt;sasl.kerberos.principal.to.local.rules&amp;lt;/code&amp;gt; is a list where each rule works in the same way as the auth_to_local in &amp;lt;a href=&quot;http://web.mit.edu/Kerberos/krb5-latest/doc/admin/conf_files/krb5_conf.html&quot;&amp;gt;Kerberos configuration file (krb5.conf)&amp;lt;/a&amp;gt;. This also support additional lowercase rule, to force the translated result to be all lower case. This is done by adding a &quot;/L&quot; to the end of the rule. check below formats for syntax.&lt;br/&gt;
     Each rules starts with RULE: and contains an expression as the following formats. See the kerberos documentation for more details.&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="12957273">KAFKA-3532</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 3 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3gdon:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>