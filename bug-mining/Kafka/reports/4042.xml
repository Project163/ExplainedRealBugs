<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:41:32 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-18326] Cached stores may return deleted values</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-18326</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Reported in community Slack by Stanislav Savulchik. I&apos;ve attached a patch fix, and am waiting for the reporter to submit a PR if they want to since they were the first to identify it!&lt;/p&gt;

&lt;p&gt;It affects basically every version of Kafka Streams out there...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Hi everyone,&lt;br/&gt;
I&#8217;m investigating an unexpected behavior of a KeyValueStore.prefixScan &#160;method that sometimes returns previously deleted keys if caching is enabled. Example pseudocode:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 val keyPrefixSerializer: Serializer[Int] = ??? &lt;span class=&quot;code-comment&quot;&gt;// 4 bytes big endian
&lt;/span&gt;val store: KeyValueStore[(Int, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;), &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;] = ???
&lt;span class=&quot;code-comment&quot;&gt;// store contents
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// (1, &lt;span class=&quot;code-quote&quot;&gt;&quot;A&quot;&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;A&quot;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// (1, &lt;span class=&quot;code-quote&quot;&gt;&quot;B&quot;&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;B&quot;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// using put instead of delete to avoid reading previous value
&lt;/span&gt;store.put((1, &lt;span class=&quot;code-quote&quot;&gt;&quot;B&quot;&lt;/span&gt;), &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)
&lt;span class=&quot;code-comment&quot;&gt;// reading all key value pairs using key prefix
&lt;/span&gt;val result: List[KeyValue[(Int, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;), &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;]] =&#160;
&#160; &#160; store.prefixScan(1, keyPrefixSerializer).asScala.toList
&lt;span class=&quot;code-comment&quot;&gt;// expected result&#160;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// (1, &lt;span class=&quot;code-quote&quot;&gt;&quot;A&quot;&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;A&quot;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// actual result&#160;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// (1, &lt;span class=&quot;code-quote&quot;&gt;&quot;A&quot;&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;A&quot;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// (1, &lt;span class=&quot;code-quote&quot;&gt;&quot;B&quot;&lt;/span&gt;) -&amp;gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;B&quot;&lt;/span&gt; (was previously deleted, but returned by the iterator)&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I tried to come up with a unit test for MergedSortedCacheKeyValueBytesStoreIterator (returned by KeyValueStore.prefixScan and other methods like range, all) in order to reproduce the behavior. And it also showed that the iterator returns more items than expected if I delete a larger key:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 @Test
&#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void shouldSkipAllDeletedFromCache1() {
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[][] bytes = {{0}, {1}};
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] aByte : bytes) {
&#160; &#160; &#160; &#160; &#160; &#160; store.put(Bytes.wrap(aByte), aByte);
&#160; &#160; &#160; &#160; }
&#160; &#160; &#160; &#160; cache.put(namespace, Bytes.wrap(bytes[1]), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LRUCacheEntry(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)); &lt;span class=&quot;code-comment&quot;&gt;// simulate key deletion from store that is cached
&lt;/span&gt;&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; MergedSortedCacheKeyValueBytesStoreIterator iterator = createIterator()) {
&#160; &#160; &#160; &#160; &#160; &#160; assertArrayEquals(bytes[0], iterator.next().key.get());
&#160; &#160; &#160; &#160; &#160; &#160; assertFalse(iterator.hasNext()); &lt;span class=&quot;code-comment&quot;&gt;// org.opentest4j.AssertionFailedError: expected: &amp;lt;&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;&amp;gt; but was: &amp;lt;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&amp;gt;
&lt;/span&gt;&#160; &#160; &#160; &#160; }
&#160; &#160; }&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160; &lt;br/&gt;
But if I delete a smaller key the test is successful:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 @Test
&#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void shouldSkipAllDeletedFromCache0() {
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[][] bytes = {{0}, {1}};
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] aByte : bytes) {
&#160; &#160; &#160; &#160; &#160; &#160; store.put(Bytes.wrap(aByte), aByte);
&#160; &#160; &#160; &#160; }
&#160; &#160; &#160; &#160; cache.put(namespace, Bytes.wrap(bytes[0]), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LRUCacheEntry(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;));
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; MergedSortedCacheKeyValueBytesStoreIterator iterator = createIterator()) {
&#160; &#160; &#160; &#160; &#160; &#160; assertArrayEquals(bytes[1], iterator.next().key.get());
&#160; &#160; &#160; &#160; &#160; &#160; assertFalse(iterator.hasNext());
&#160; &#160; &#160; &#160; }
&#160; &#160; }&#160; &#160; 
Could someone help me verify &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; it is a bug or am I missing something?
Thank you.&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="13602729">KAFKA-18326</key>
            <summary>Cached stores may return deleted values</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="agavra">Almog Gavra</assignee>
                                    <reporter username="agavra">Almog Gavra</reporter>
                        <labels>
                    </labels>
                <created>Thu, 19 Dec 2024 17:41:02 +0000</created>
                <updated>Wed, 8 Jan 2025 07:17:43 +0000</updated>
                            <resolved>Wed, 8 Jan 2025 07:17:43 +0000</resolved>
                                                    <fixVersion>3.8.2</fixVersion>
                    <fixVersion>3.9.1</fixVersion>
                    <fixVersion>4.0.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="17907138" author="agavra" created="Thu, 19 Dec 2024 17:42:57 +0000"  >&lt;p&gt;Note that existing tests did not capture this because they first inserted non-tombstone entries into the cache. The following change causes the test to fail.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java
index a678908b04..70e9ca8786 100644
--- a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheKeyValueBytesStoreIteratorTest.java
@@ -154,7 +154,6 @@ &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MergedSortedCacheKeyValueBytesStoreIteratorTest {
&#160; &#160; &#160; &#160; &#160;&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] aByte : bytes) {
&#160; &#160; &#160; &#160; &#160; &#160; &#160;&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bytes aBytes = Bytes.wrap(aByte);
&#160; &#160; &#160; &#160; &#160; &#160; &#160;store.put(aBytes, aByte);
- &#160; &#160; &#160; &#160; &#160; &#160;cache.put(namespace, aBytes, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LRUCacheEntry(aByte));
&#160; &#160; &#160; &#160; &#160;}
&#160; &#160; &#160; &#160; &#160;cache.put(namespace, Bytes.wrap(bytes[1]), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LRUCacheEntry(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;));
&#160; &#160; &#160; &#160; &#160;cache.put(namespace, Bytes.wrap(bytes[2]), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LRUCacheEntry(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)); &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="17909090" author="guozhang" created="Tue, 31 Dec 2024 18:52:14 +0000"  >&lt;p&gt;I&apos;ve just tested the modified unit test myself and confirmed it, thanks for reporting! Will take a look at the PR soon.&lt;/p&gt;</comment>
                            <comment id="17909114" author="savulchik" created="Wed, 1 Jan 2025 07:07:14 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; , thanks for reviewing the PR.&lt;/p&gt;

&lt;p&gt;Let me answer your &lt;a href=&quot;https://github.com/apache/kafka/pull/18287#pullrequestreview-2526664288&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;question&lt;/a&gt;&#160;here:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;For the original reported scenario where if deleting the second key &quot;1&quot; this bug gets exposed bug if deleting the first key &quot;0&quot; this bug will not be exposed, I&apos;m a bit unclear how it would be the case. The only case I can think of is that the cache is small enough such that both &quot;0&quot; and &quot;1&quot; are flushed to store while &quot;1&quot; is in the cache.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Indeed, my original example didn&apos;t explain how I created the state store records in the first place before deleting one of them to reproduce the bug.&lt;/p&gt;

&lt;p&gt;There is a topology with two custom processors and a shared key value state store connected to both processors.&lt;/p&gt;

&lt;p&gt;The first processor handles a very small rate of input records and does (in order):&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;store.put(key, value or null)&lt;/li&gt;
	&lt;li&gt;store.prefixScan(keyPrefix)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The second processor handles a very large rate of input records (various keyPrefixes) and does (in order):&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;store.prefixScan(keyPrefix)&lt;/li&gt;
	&lt;li&gt;store.putAll(keyValues)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;I believe that by the time the first processor did a delete in a form of store.put(key, null) and store.prefixScan(keyPrefix) that key wasn&apos;t in the cache (and other keys with its keyPrefix) because it had already been evicted from cache by other reads and updates in the second processor.&lt;/p&gt;

&lt;p&gt;I hope that helps to clarify the scenario I had.&#160;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="13073592" name="range-scan-fix.patch" size="2767" author="agavra" created="Thu, 19 Dec 2024 17:40:10 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            44 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z1t89k:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>