<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:29:36 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-13310] KafkaConsumer cannot jump out of the poll method, and the consumer is blocked in the ConsumerCoordinator method maybeAutoCommitOffsetsSync(Timer timer). Cpu and traffic of  Broker&apos;s side increase sharply</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-13310</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;h2&gt;&lt;a name=&quot;Foreword&quot;&gt;&lt;/a&gt;Foreword&lt;/h2&gt;

&lt;p&gt;&#160; &#160; &#160; Because our consumers&apos; consumption logic is sometimes heavier, we refer to the configuration of Kafka stream &lt;a href=&quot;https://kafka.apache.org/documentation/#upgrade_10201_notable&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://kafka.apache.org/documentation/#upgrade_10201_notable&lt;/a&gt;&lt;br/&gt;
 Set max.poll.interval.ms to Integer.MAX_VALUE&lt;br/&gt;
 Our consumers have adopted method : consumer.subscribe(Pattern.compile(&quot;.&lt;b&gt;riven.&lt;/b&gt;&quot;));&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h2&gt;&lt;a name=&quot;Recurrenceoftheproblemscene&quot;&gt;&lt;/a&gt;Recurrence of the problem scene&lt;/h2&gt;

&lt;p&gt;operate steps are&lt;br/&gt;
 (1) Test environment Kafka cluster: three brokers&lt;br/&gt;
 (2) Topics conforming to regular expressions include rivenTest1, rivenTest2, and rivenTest88&lt;br/&gt;
 (3) Only one consumer is needed, group.id is &quot;rivenReassign&quot;, consumer.subscribe(Pattern.compile(&quot;.&lt;b&gt;riven.&lt;/b&gt;&quot;));&lt;br/&gt;
 (4) At the beginning, the group status is stable, and everything is normal for consumers, then I delete topic: rivenTest88&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h2&gt;&lt;a name=&quot;Phenomenon&quot;&gt;&lt;/a&gt;Phenomenon&lt;/h2&gt;

&lt;p&gt;&#160; &#160; &#160; Problem phenomenon&lt;br/&gt;
 &#160;(1) The consumer is blocked in the poll method, no longer consume any messages, and the consumer log is always printing&lt;br/&gt;
 &lt;span class=&quot;error&quot;&gt;&amp;#91;main&amp;#93;&lt;/span&gt; WARN org.apache.kafka.clients.consumer.internals.ConsumerCoordinator-&lt;span class=&quot;error&quot;&gt;&amp;#91;Consumer clientId=consumer-rivenReassign-1, groupId=rivenReassign&amp;#93;&lt;/span&gt; Offset commit failed on partition rivenTest88-1 at offset 0: This server does not host this topic-partition.&lt;br/&gt;
 (2) The describe consumerGroup interface of Adminclient&#160; has always timed out, and the group status is no longer stable&lt;br/&gt;
 (3) The cpu and traffic of the broker are &lt;b&gt;significantly increased&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h2&gt;&lt;a name=&quot;Problemtracking&quot;&gt;&lt;/a&gt;Problem tracking&lt;/h2&gt;

&lt;p&gt;&#160; &#160;By analyzing the kafkaConsumer code, the version is 2.8.1.&lt;br/&gt;
 I found that you introduced the waitForJoinGroup variable in the updateAssignmentMetadataIfNeeded method. For the reason, I attached the comment on the method: &quot;try to update assignment metadata BUT do not need to block on the timer for join group&quot;. See as below:&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (includeMetadataInTimeout) {
    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to update assignment metadata BUT &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; not need to block on the timer &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; join group
&lt;/span&gt;    updateAssignmentMetadataIfNeeded(timer, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (!updateAssignmentMetadataIfNeeded(time.timer(&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;.MAX_VALUE), &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;)) {
        log.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Still waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; metadata&quot;&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;By tracing the code back layer by layer, it is found that the function of this variable is to construct a time.timer(0L) and pass it back to the method joinGroupIfNeeded (final Timer timer) in AbstractCoordinator. See as below:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; not wait &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; join group, we would just use a timer of 0
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!ensureActiveGroup(waitForJoinGroup ? timer : time.timer(0L))) {
&lt;span class=&quot;code-comment&quot;&gt;// since we may use a different timer in the callee, we&apos;d still need 
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// to update the original timer&apos;s current time after the call 
&lt;/span&gt;      timer.update(time.milliseconds()); 
      &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;; 
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;But you will find that there is a submethod onJoinPrepare in the method stack of joinGroupIfNeeded, and then there is a line of code in the onJoinPrepare method&lt;br/&gt;
 maybeAutoCommitOffsetsSync(time.timer(rebalanceConfig.rebalanceTimeoutMs)), the value of rebalanceConfig.rebalanceTimeoutMs is actually max.poll.interval.ms.&lt;br/&gt;
 Finally, I tracked down ConsumerCoordinator&apos;s method commitOffsetsSync(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Timer timer)&lt;br/&gt;
 The input parameter offsets is subscriptions.allConsumed(), when I delete the topic: rivenTest88, commitOffsetsSync(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Timer timer) method will &lt;b&gt;fall into an infinite loop! !&lt;/b&gt;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; commitOffsetsSync(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Timer timer) {
 invokeCompletedOffsetCommitCallbacks();

 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (offsets.isEmpty())
 &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;

 &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; {
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (coordinatorUnknown() &amp;amp;&amp;amp; !ensureCoordinatorReady(timer)) {
 &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
 }

 RequestFuture&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt; = sendOffsetCommitRequest(offsets);
 client.poll(&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;, timer);

 &lt;span class=&quot;code-comment&quot;&gt;// We may have had in-flight offset commits when the synchronous commit began. If so, ensure that
&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// the corresponding callbacks are invoked prior to returning in order to preserve the order that
&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// the offset commits were applied.
&lt;/span&gt; invokeCompletedOffsetCommitCallbacks();

 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.succeeded()) {
 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (interceptors != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;)
 interceptors.onCommit(offsets);
 &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
 }

 &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.failed() &amp;amp;&amp;amp; !&lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.isRetriable())
 &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;future&lt;/span&gt;.exception();

 timer.sleep(rebalanceConfig.retryBackoffMs);
 } &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (timer.notExpired());

 &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;The reason for the endless loop is:&lt;/b&gt;&lt;br/&gt;
 (1) The expiration time of the timer is too long, which is max.poll.interval.ms&lt;br/&gt;
 (2) The offsets to be submitted contain dirty data and TopicPartition that no longer exists&lt;br/&gt;
 (3) The response future of sendOffsetCommitRequest(final Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets) has always failed, and the exception in the future is UnknownTopicOrPartitionException. This exception is allowed to be retried.&lt;/p&gt;

&lt;p&gt;Then since the infinite loop interval above is 100ms by default, timer.sleep(rebalanceConfig.retryBackoffMs);&lt;br/&gt;
 If a large number of consumers have this problem at the same time, a large number of network requests will be generated to the Kafka broker, &lt;b&gt;resulting in a sharp increase in the cpu and traffic of the broker machine!&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;h2&gt;&lt;a name=&quot;Suggest&quot;&gt;&lt;/a&gt;Suggest&lt;/h2&gt;

&lt;p&gt;1.maybeAutoCommitOffsetsSync(time.timer(rebalanceConfig.rebalanceTimeoutMs)), the time of this method is recommended not to use max.poll.interval.ms,&lt;br/&gt;
 This parameter is open to users to configure. Through the explanation of this parameter on the official website, I would never think that this parameter will be used in this place. At the same time, it will block KafkaConsumer&apos;s poll (final Duration timeout), even if I set consumer.poll (Duration.ofMillis(1000)).&lt;br/&gt;
 2. In fact, in the poll (Timer timer, boolean waitForJoinGroup) method of ConsumerCoordinatord, before calling the ensureActiveGroup method, the consumer ensures that the local metadata is up to date, see the code&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (rejoinNeededOrPending()) {
    &lt;span class=&quot;code-comment&quot;&gt;// due to a race condition between the initial metadata fetch and the initial rebalance,
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// we need to ensure that the metadata is fresh before joining initially. This ensures
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// that we have matched the pattern against the cluster&apos;s topics at least once before joining.
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (subscriptions.hasPatternSubscription()) {
        &lt;span class=&quot;code-comment&quot;&gt;// For consumer group that uses pattern-based subscription, after a topic is created,
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// any consumer that discovers the topic after metadata refresh can trigger rebalance
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// across the entire consumer group. Multiple rebalances can be triggered after one topic
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// creation &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; consumers refresh metadata at vastly different times. We can significantly
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// reduce the number of rebalances caused by single topic creation by asking consumer to
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// refresh metadata before re-joining the group as &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; as the refresh backoff time has
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// passed.
&lt;/span&gt;        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.metadata.timeToAllowUpdate(time.milliseconds()) == 0) {
            &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.metadata.requestUpdate();
        }

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!client.ensureFreshMetadata(timer)) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        }
    }

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!ensureActiveGroup(timer)) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;That is to say, the consumer knows which topic/topicPartition is legal before onJoinPrepare. In this case, why didn&apos;t you find the UnknownTopicOrPartitionException in the commitOffsetsSync method mentioned above,do not put the submitted offsets and the latest local metadata together for analysis, remove the non-existent topicpartitions, and then try to submit the offsets again. I think I can break out of the infinite loop by doing this&lt;/p&gt;

&lt;p&gt;3. Why must the offset be submitted synchronously in the onJoinPrepare method? Can&apos;t the offset be submitted asynchronously? Or provide a parameter for the user to choose whether to submit synchronously or asynchronously. Or provide a new parameter to control the maximum number of retries for synchronous submission here, instead of using the Timer constructed by max.poll.interval.ms.&lt;br/&gt;
 And if you don&#8217;t really submit the offset here, it will not have much impact. It may cause repeated consumption of some messages. I still suggest to provide a new parameter to control whether you need to submit the offset.&lt;/p&gt;</description>
                <environment>prod</environment>
        <key id="13401979">KAFKA-13310</key>
            <summary>KafkaConsumer cannot jump out of the poll method, and the consumer is blocked in the ConsumerCoordinator method maybeAutoCommitOffsetsSync(Timer timer). Cpu and traffic of  Broker&apos;s side increase sharply</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="RivenSun">RivenSun</assignee>
                                    <reporter username="RivenSun">RivenSun</reporter>
                        <labels>
                            <label>new-consumer-threading-should-fix</label>
                    </labels>
                <created>Sat, 18 Sep 2021 08:10:01 +0000</created>
                <updated>Wed, 7 Feb 2024 19:06:55 +0000</updated>
                            <resolved>Wed, 9 Feb 2022 07:07:20 +0000</resolved>
                                    <version>2.8.1</version>
                                    <fixVersion>3.2.0</fixVersion>
                                    <component>consumer</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="17417083" author="rivensun" created="Sat, 18 Sep 2021 08:36:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;&#160;hi Guozhang, can you help deal with this issue? Thanks a lot.&lt;/p&gt;</comment>
                            <comment id="17417130" author="showuon" created="Sat, 18 Sep 2021 12:50:29 +0000"  >&lt;p&gt;Nice RCA and good suggestions.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;My 2 cents:&lt;/p&gt;

&lt;p&gt;For suggestion(1), I think, in general, we set &quot;rebalanceTimeout&quot; as &quot;maxPollInterval&quot; makes sense, because the rebalance period implies the delay between 2 polls (before and after rebalance). But I agree that, during poll(duration), it&apos;s not good to have another timer (set as max poll interval) to wait for commit offsets, which will delay the poll process. Maybe we can pass the timer from poll() to the `onJoinPrepare`?&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;For suggestion(2), I think even we use the metadata got before `ensureActiveGroup`, there&apos;s still possibility to have race condition after committing offsets. It&apos;s pretty difficult to identify the `UnknownTopicOrPartitionException` is topic deleted or not ready yet or other reasons, so I think the point here should be: set a good wait time (so, back to suggestion(1))&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;For suggestion(3), I also think we should set the wait time properly as described in (1).&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Thank you.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17417145" author="rivensun" created="Sat, 18 Sep 2021 13:51:52 +0000"  >&lt;p&gt;Thank you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt; very much for your reply&lt;/p&gt;

&lt;p&gt;I performed the second scene reappearance,&#160; consumerGroup still only has &lt;b&gt;one consumer&lt;/b&gt;, and the phenomenon remains the same as before.&lt;br/&gt;
 For consumer logs, see the attachment: &lt;b&gt;&lt;em&gt;SecondDeleteConsumerLog&lt;/em&gt;&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;In fact, when kafkaConsumer falls into the above-mentioned infinite loop code, please refer to the attached &lt;b&gt;&lt;em&gt;SecondDeleteDebugLog&lt;/em&gt;&lt;/b&gt;.&lt;br/&gt;
 In this endless loop code, we can find that the &lt;b&gt;Set&amp;lt;String&amp;gt; subscription&lt;/b&gt; in the instance variable metadata in ConsumerCoordinator has been refreshed to the latest valid &lt;b&gt;subscription&lt;/b&gt;.&#160; SourceCode for update&#160; &lt;b&gt;subscription&lt;/b&gt;&#160;can refer as below:&lt;/p&gt;

&lt;p&gt;ConsumerCoordinator.java&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

void maybeUpdateSubscriptionMetadata() {
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; version = metadata.updateVersion();
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (version &amp;gt; metadataSnapshot.version) {
        Cluster cluster = metadata.fetch();

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (subscriptions.hasPatternSubscription())
            updatePatternSubscription(cluster);

        &lt;span class=&quot;code-comment&quot;&gt;// Update the current snapshot, which will be used to check &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; subscription
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// changes that would require a rebalance (e.g. &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; partitions).
&lt;/span&gt;        metadataSnapshot = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MetadataSnapshot(subscriptions, cluster, version);
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;SubscriptionState.java&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; changeSubscription(Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; topicsToSubscribe) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (subscription.equals(topicsToSubscribe))
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;

    subscription = topicsToSubscribe;
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;So if there is an exception of `UnknownTopicOrPartitionException`, we can use this valid &lt;b&gt;subscription&lt;/b&gt; to clean up the &lt;b&gt;dirty topicPartitions&lt;/b&gt; in the offsets we will submit. If you are not sure whether `UnknownTopicOrPartitionException` really means that the topic is deleted, you can further call the listTopics(final ListTopicsOptions options) method in KafkaAdminClient to confirm.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Later I will download the sourceCode of Kafka-client 2.8.1 version, try to write the code change scheme I mentioned above, build and generate the test jar package for testing, and hope that the problem will be fixed.&lt;/p&gt;

&lt;p&gt;Thanks again.&lt;/p&gt;</comment>
                            <comment id="17417165" author="rivensun" created="Sat, 18 Sep 2021 15:50:03 +0000"  >&lt;p&gt;And I think the most important and critical point is &lt;b&gt;not to find a good wait time&lt;/b&gt; for the method commitOffsetsSync(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; offsets, Timer timer), but to &lt;b&gt;immediately clean up/give up&lt;/b&gt; unknownTopicPartitions when submitting offsets in this infinite loop code.&lt;/p&gt;

&lt;p&gt;Even if you think that `UnknownTopicOrPartitionException` may not really mean that the topic is really deleted. But when we encounter this exception, shouldn&apos;t we temporarily give up submitting offsets for these unknownTopicPartitions?&#160; What is the point of submitting offsets for these unknownTopicPartitions repeatedly?&lt;/p&gt;

&lt;p&gt;&lt;b&gt;The worst effect&lt;/b&gt; is that if unknownTopicPartitions may not be deleted by the broker, we will consume a small portion of the partition messages (if we give up submitting these unknownTopicPartitions)&lt;/p&gt;

&lt;p&gt;What do you think? &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17417270" author="rivensun" created="Sun, 19 Sep 2021 00:00:10 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;After thinking about it, here is my latest points.&lt;br/&gt;
 Hope you can reply me as soon as possible, thank you.&lt;/p&gt;

&lt;p&gt;&#160; &#160; &#160;1. Because the poll method of KafkaConsumer promises to return within the time specified by the customer, unless the customer sets the ConsumerRebalanceListener to perform a time-consuming operation.&#160;See the comment of poll(final Duration timeout) method as below:&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
This method returns immediately &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; there are records available. Otherwise, it will await the passed timeout. If the timeout expires, an empty record set will be returned. Note that &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; method may block beyond the timeout in order to execute custom ConsumerRebalanceListener callbacks.&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;In order to keep this promise, I also suggest passing the &lt;b&gt;Timer set by the customer for poll()&lt;/b&gt; to the maybeAutoCommitOffsetsSync(&lt;b&gt;Timer timer&lt;/b&gt;) method of ConsumerCoordinator&lt;br/&gt;
And the poll()&apos;s Timer should be applied to &lt;b&gt;onJoinPrepare&lt;/b&gt;.&lt;br/&gt;
However, due to other comprehensive considerations, the timers &lt;b&gt;in other code blocks&lt;/b&gt; in ensureActiveGroup (final Timer timer) &lt;b&gt;should remain as they are&lt;/b&gt;, using the Timer passed from the upper layer, perhaps time.timer(0L)&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160; &#160; &#160;2. Modify ConsumerCoordinator&apos;s maybeAutoCommitOffsetsSync(Timer timer) method&lt;br/&gt;
 Below are my preliminary code changes&#65306;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void maybeAutoCommitOffsetsSync(Timer timer) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (autoCommitEnabled) {
        Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; allConsumedOffsets = subscriptions.allConsumed();
        
        cleanUpConsumedOffsets(allConsumedOffsets);
        
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Sending synchronous auto-commit of offsets {}&quot;&lt;/span&gt;, allConsumedOffsets);
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!commitOffsetsSync(allConsumedOffsets, timer))
                log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Auto-commit of offsets {} timed out before completion&quot;&lt;/span&gt;, allConsumedOffsets);
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (WakeupException | InterruptException e) {
            log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Auto-commit of offsets {} was interrupted before completion&quot;&lt;/span&gt;, allConsumedOffsets);
            &lt;span class=&quot;code-comment&quot;&gt;// rethrow wakeups since they are triggered by the user
&lt;/span&gt;            &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; e;
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;code-comment&quot;&gt;// consistent with async auto-commit failures, we &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; not propagate the exception
&lt;/span&gt;            log.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Synchronous auto-commit of offsets {} failed: {}&quot;&lt;/span&gt;, allConsumedOffsets, e.getMessage());
        }
    }
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void cleanUpConsumedOffsets(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; willCommitOffsets) {

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (willCommitOffsets.isEmpty())
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;

    Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; subscription = subscriptions.subscription();
    Set&amp;lt;TopicPartition&amp;gt; toGiveUpTopicPartitions = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();

    Iterator&amp;lt;Map.Entry&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt;&amp;gt; iterator = willCommitOffsets.entrySet().iterator();

    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (iterator.hasNext()) {

        Map.Entry&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; entry = iterator.next();

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!subscription.contains(entry.getKey().topic())) {

            toGiveUpTopicPartitions.add(entry.getKey());
            iterator.remove();
        }

    }

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (toGiveUpTopicPartitions.size() &amp;gt; 0) {

        &lt;span class=&quot;code-comment&quot;&gt;//Because toGiveUpTopicPartitions may receive `UnknownTopicOrPartitionException` when submitting their offsets.
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//We are prepared to abandon them. The worst effect is that these partitions may repeatedly consume some messages
&lt;/span&gt;        log.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Synchronous auto-commit of offsets {} will be abandoned&quot;&lt;/span&gt;, toGiveUpTopicPartitions);

    }
}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17417277" author="showuon" created="Sun, 19 Sep 2021 02:47:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=RivenSun&quot; class=&quot;user-hover&quot; rel=&quot;RivenSun&quot;&gt;RivenSun&lt;/a&gt;, thanks for your response. For your latest comment, I understand what you are trying to achieve, to update the offset metadata (to remove non-existed partitions), before go to the &quot;possible&quot; infinite commit offset loop before timeout. But unfortunately, it could still have possibility to cause the issue you reported, because there&apos;s still a race condition. Simply put, thread A tried to commit offsets, thread B tried to delete topics, we never know who will reach broker first, and which command will be processed first. So, even you update to the &quot;latest&quot; metadata before committing offset in thread A, it&apos;s still possible thread B comes and deletes the some topics before thread A committing offsets.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;So, to achieve what you wanted, we need to `cleanUpConsumedOffsets` inside the while loop in the `commitOffsetsSync`. Each time there&apos;s an `UnknownTopicOrPartitionException` returned, we tried to update the metadata. And in the `cleanUpConsumedOffsets`, we need to make sure to get an up-to-date subscription there.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;This is a way to fix this issue, of course. However, this way, it will make the commitOffsets method more complex, and might have other errors to handle (during request metadata update).&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;For me, I still prefer to control the commitOffset method via the timeout, and if the metadata is already updated by other threads (ex: topics deleted), this commit will fail with timeout. And the caller should do their own metadata update for next retry.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Let&apos;s see if there are other opinions from other experts. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="17417285" author="rivensun" created="Sun, 19 Sep 2021 06:02:54 +0000"  >&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Thank you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&#160; very much for your reply, I very much agree with your points of view above&lt;/p&gt;

&lt;p&gt;I also considered what you said about a race condition,&lt;br/&gt;
 So I suggest to modify the &lt;b&gt;two points&lt;/b&gt; together&lt;/p&gt;

&lt;p&gt;1. Try `cleanUpConsumedOffsets` before submitting the offsets, maybe 90% of abnormal situations can be avoided.&lt;br/&gt;
 I didn&apos;t do it (`cleanUpConsumedOffsets`)&#160;&lt;b&gt;in commitOffsetsSync&lt;/b&gt;. As you said, that would make the infinite loop more complicated. We just need to &lt;b&gt;try to&lt;/b&gt; clean up unKnownTopicPartitions before entering the loop&lt;/p&gt;

&lt;p&gt;2. Pass the poll()&apos;s timer set by the customer to commitOffsetsSync(allConsumedOffsets, timer). to avoid &lt;b&gt;exceeding the timeout expected by the customer&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;I am also very happy to invite other experts to analyze this problem, thank you everyone for making Kafka more perfect&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/biggrin.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="17417317" author="rivensun" created="Sun, 19 Sep 2021 11:02:22 +0000"  >&lt;p&gt;helo &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt; , here is my latest progress&lt;/p&gt;

&lt;p&gt;1. I have pulled the latest version of Kafka code, modified the code locally, compiled and tested, the problem can be resolved.&lt;br/&gt;
The result of the debugTest can refer to the attachments ThirdDebugLog1 and ThirdDebugLog2&lt;/p&gt;

&lt;p&gt;2. I have submitted a PullRequest, please help to review it, or have a better solution, thank you very much.&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/kafka/pull/11340&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/11340&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17417509" author="showuon" created="Mon, 20 Sep 2021 07:58:58 +0000"  >&lt;p&gt;Before dive into the PR, I&apos;d like to hear comments from other experts. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dajac&quot; class=&quot;user-hover&quot; rel=&quot;dajac&quot;&gt;dajac&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ableegoldman&quot; class=&quot;user-hover&quot; rel=&quot;ableegoldman&quot;&gt;ableegoldman&lt;/a&gt; , any comments?&lt;/p&gt;</comment>
                            <comment id="17417587" author="rivensun" created="Mon, 20 Sep 2021 11:26:25 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thank you for your reply, after my test subscribe(Collection&amp;lt;String&amp;gt; topics) also has the same problem.&lt;br/&gt;
 But we can no longer use the &lt;b&gt;SubscriptionState subscriptions&lt;/b&gt; variable in&#160; &apos;cleanUpConsumedOffsets&apos; method. Because in the AUTO_TOPIC type, the subscriptions variable will not be updated to the latest valid value. SourceCode see as below:&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
   void maybeUpdateSubscriptionMetadata() {
    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; version = metadata.updateVersion();
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (version &amp;gt; metadataSnapshot.version) {
        Cluster cluster = metadata.fetch();

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (subscriptions.hasPatternSubscription())
            updatePatternSubscription(cluster);

        &lt;span class=&quot;code-comment&quot;&gt;// Update the current snapshot, which will be used to check &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; subscription
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// changes that would require a rebalance (e.g. &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; partitions).
&lt;/span&gt;        metadataSnapshot = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MetadataSnapshot(subscriptions, cluster, version);
    }
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;So the most elegant way to clean up unKnownTopicPartitions for AUTO_PATTERN and AUTO_TOPICS is to use &lt;b&gt;metadata.fetch().topics()&lt;/b&gt;&#65292;see as below&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void cleanUpConsumedOffsets(Map&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; willCommitOffsets) {

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (willCommitOffsets.isEmpty())
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;

    Set&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; validTopics = metadata.fetch().topics();
    Set&amp;lt;TopicPartition&amp;gt; toGiveUpTopicPartitions = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();

    Iterator&amp;lt;Map.Entry&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt;&amp;gt; iterator = willCommitOffsets.entrySet().iterator();

    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (iterator.hasNext()) {

        Map.Entry&amp;lt;TopicPartition, OffsetAndMetadata&amp;gt; entry = iterator.next();

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!validTopics.contains(entry.getKey().topic())) {

            toGiveUpTopicPartitions.add(entry.getKey());
            iterator.remove();
        }

    }

    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (toGiveUpTopicPartitions.size() &amp;gt; 0) {

        &lt;span class=&quot;code-comment&quot;&gt;//Because toGiveUpTopicPartitions may receive `UnknownTopicOrPartitionException` when submitting their offsets.
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;//We are prepared to abandon them. The worst effect is that these partitions may repeatedly consume some messages
&lt;/span&gt;        log.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Synchronous auto-commit of offsets {} will be abandoned&quot;&lt;/span&gt;, toGiveUpTopicPartitions);

    }
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17417615" author="dajac" created="Mon, 20 Sep 2021 12:19:56 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=RivenSun&quot; class=&quot;user-hover&quot; rel=&quot;RivenSun&quot;&gt;RivenSun&lt;/a&gt;&#160;Thanks for the bug report. The ticket says that this affects 2.8.1, which was released during the weekend. I suppose that you don&apos;t use it already, right? Therefore, I suppose that it affects older versions as well? Do you know which ones, if not all?&lt;/p&gt;</comment>
                            <comment id="17417644" author="rivensun" created="Mon, 20 Sep 2021 13:01:58 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dajac&quot; class=&quot;user-hover&quot; rel=&quot;dajac&quot;&gt;dajac&lt;/a&gt;,&#160;&lt;/p&gt;

&lt;p&gt;May all current versions have this issue&lt;/p&gt;

&lt;p&gt;The version of Kafka-client used in my production environment is &lt;b&gt;2.2.2&lt;/b&gt;.&#160; The consumer block in the poll method,cannot consume any messages, and the broker-side cpu and traffic increase sharply.&lt;/p&gt;

&lt;p&gt;After the local test using 2.2.2 version, the phenomenon of the production can be reproduced, I want to know whether the latest version of Kafka-client fixes this issue. So I downloaded the &lt;b&gt;2.8.1&lt;/b&gt; version for kafka-client from the maven repository. After local debugging, I found that the production problem can still be reproduced, even if you introduced the new `&lt;b&gt;waitForJoinGroup&lt;/b&gt;`&#160; variable in the KafkaConsumer&apos;s &lt;b&gt;updateAssignmentMetadataIfNeeded&lt;/b&gt; method in the hign version SDK.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (includeMetadataInTimeout) {
    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to update assignment metadata BUT &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; not need to block on the timer &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; join group
&lt;/span&gt;    updateAssignmentMetadataIfNeeded(timer, &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;);
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (!updateAssignmentMetadataIfNeeded(time.timer(&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;.MAX_VALUE), &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;)) {
        log.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Still waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; metadata&quot;&lt;/span&gt;);
    }
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
  &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; updateAssignmentMetadataIfNeeded(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Timer timer, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; waitForJoinGroup) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (coordinator != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !coordinator.poll(timer, waitForJoinGroup)) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
    }

    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; updateFetchPositions(timer);
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;So I folked a copy of the latest code from GitHub(&lt;a href=&quot;https://github.com/apache/kafka/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/&lt;/a&gt;). &lt;br/&gt;
 After local code modification and debug, this Jira issue&#160;can be fixed finally &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/biggrin.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;.&lt;/p&gt;

&lt;p&gt;You can see my code changes here&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/kafka/pull/11340&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/11340&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Maybe you can consider some of the suggestions I mentioned above. &lt;br/&gt;
Thanks a lot.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310060">
                    <name>Container</name>
                                            <outwardlinks description="contains">
                                        <issuelink>
            <issuekey id="13355557">KAFKA-12256</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13567793">KAFKA-16235</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="13033798" name="SecondDeleteConsumerLog.png" size="221191" author="RivenSun" created="Sat, 18 Sep 2021 13:50:39 +0000"/>
                            <attachment id="13033799" name="SecondDeleteDebugLog.png" size="196078" author="RivenSun" created="Sat, 18 Sep 2021 13:51:44 +0000"/>
                            <attachment id="13033813" name="ThirdDebugLog1.png" size="247730" author="RivenSun" created="Sun, 19 Sep 2021 11:08:41 +0000"/>
                            <attachment id="13033811" name="ThirdDebugLog2.png" size="263329" author="RivenSun" created="Sun, 19 Sep 2021 11:03:04 +0000"/>
                            <attachment id="13033794" name="brokerCpu.png" size="68464" author="RivenSun" created="Sat, 18 Sep 2021 08:09:05 +0000"/>
                            <attachment id="13033793" name="brokerNetBytes.png" size="132279" author="RivenSun" created="Sat, 18 Sep 2021 08:09:20 +0000"/>
                            <attachment id="13033795" name="kafkaConsumerLog.png" size="119823" author="RivenSun" created="Sat, 18 Sep 2021 08:08:57 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>7.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310250" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10431"><![CDATA[Important]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            4 years, 8 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0v27c:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>guozhang</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>