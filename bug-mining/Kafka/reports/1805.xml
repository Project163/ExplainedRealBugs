<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:06:21 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6323] punctuate with WALL_CLOCK_TIME triggered immediately</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6323</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;When working on a custom Processor from which I am scheduling a punctuation using WALL_CLOCK_TIME. I&apos;ve noticed that whatever the punctuation interval I set, a call to my Punctuator is always triggered immediately.&lt;/p&gt;

&lt;p&gt;Having a quick look at kafka-streams&apos; code, I could find that all PunctuationSchedule&apos;s timestamps are matched against the current time in order to decide whether or not to trigger the punctuator (org.apache.kafka.streams.processor.internals.PunctuationQueue#mayPunctuate). However, I&apos;ve only seen code that initializes PunctuationSchedule&apos;s timestamp to 0, which I guess is what is causing an immediate punctuation.&lt;/p&gt;

&lt;p&gt;At least when using WALL_CLOCK_TIME, shouldn&apos;t the PunctuationSchedule&apos;s timestamp be initialized to current time + interval?&lt;/p&gt;</description>
                <environment></environment>
        <key id="13123372">KAFKA-6323</key>
            <summary>punctuate with WALL_CLOCK_TIME triggered immediately</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="frederica">Frederic Arno</assignee>
                                    <reporter username="frederica">Frederic Arno</reporter>
                        <labels>
                    </labels>
                <created>Thu, 7 Dec 2017 06:12:51 +0000</created>
                <updated>Wed, 31 Jan 2018 02:25:24 +0000</updated>
                            <resolved>Wed, 31 Jan 2018 02:25:24 +0000</resolved>
                                    <version>1.0.0</version>
                                    <fixVersion>1.0.1</fixVersion>
                    <fixVersion>1.1.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="16281498" author="githubbot" created="Thu, 7 Dec 2017 08:37:57 +0000"  >&lt;p&gt;GitHub user fredfp opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/4301&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4301&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt;: punctuate with WALL_CLOCK_TIME triggered immediately&lt;/p&gt;

&lt;p&gt;    This is the only way I found to fix the issue without altering the API.&lt;/p&gt;

&lt;p&gt;    @mihbor @mjsax &lt;/p&gt;

&lt;p&gt;    the contribution is my original work and I license the work to the project under the project&apos;s open source license&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/fredfp/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/fredfp/kafka&lt;/a&gt; trunk&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/4301.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4301.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4301&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 0c9b6cac6a5de8e6db81e6ae6f42fe8933012621&lt;br/&gt;
Author: Frederic Arno &amp;lt;fredericarno@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-12-07T08:18:42Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt;: fix punctuate with WALL_CLOCK_TIME triggered immediately&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16283003" author="githubbot" created="Fri, 8 Dec 2017 03:34:57 +0000"  >&lt;p&gt;GitHub user fredfp opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/4304&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4304&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt;: document that punctuation is called immediately.&lt;/p&gt;

&lt;p&gt;    If &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt; is not a bug, then it needs better documentation.&lt;/p&gt;

&lt;p&gt;    Alternative to &lt;a href=&quot;https://github.com/apache/kafka/pull/4301&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4301&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @mihbor @mjsax&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/fredfp/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/fredfp/kafka&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/4304.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4304.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4304&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 935d0fc61084f383ec528d28f9c18f8b51fff1d2&lt;br/&gt;
Author: Frederic Arno &amp;lt;fredericarno@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-12-08T03:22:52Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt;: document that punctuation is called immediately.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16283863" author="guozhang" created="Fri, 8 Dec 2017 17:15:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=frederica&quot; class=&quot;user-hover&quot; rel=&quot;frederica&quot;&gt;frederica&lt;/a&gt; I have added you to the contributor list. You can assign tickets to yourself now.&lt;/p&gt;</comment>
                            <comment id="16283901" author="guozhang" created="Fri, 8 Dec 2017 17:43:28 +0000"  >&lt;p&gt;Here are my thoughts on punctuation semantics (on both &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6092&quot; title=&quot;Time passed in punctuate call is currentTime, not punctuate schedule time. &quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6092&quot;&gt;&lt;del&gt;KAFKA-6092&lt;/del&gt;&lt;/a&gt;):&lt;/p&gt;

&lt;p&gt;&lt;b&gt;First trigger&lt;/b&gt;: we should only punctuate the first time after the specified period has elapsed. And here is a slight difference with wall-clock time and stream time:&lt;/p&gt;

&lt;p&gt;1. WALL_CLOCK_TIME: when the stream application starts at t0 (system wall clock time), punctuate first-time on t0 + t_scheduled.&lt;br/&gt;
2. STREAM_TIME: when the stream application starts, we do no schedule the first punctuation until the stream time is known (i.e. we have received at least one record from each input topic), say it is T01, punctuate first-time on T0 + T_scheduled.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Interval&lt;/b&gt;: again I think there is a slight difference with wall-clock time and stream time:&lt;/p&gt;

&lt;p&gt;1. WALL_CLOCK_TIME: when the stream application last punctuation at t1, punctuate next-time on t1 + t_scheduled, even if there is no data arrived during this period of time.&lt;br/&gt;
2. STREAM_TIME: this is data driven, and hence: when the stream application last punctuation at T1, and then stream time is updated and advanced to T2, where (T2 - T1) &amp;gt; t_scheduled, punctuate at T2 once even if (T2 - T1) &amp;gt;= t_scheduled * 2.&lt;/p&gt;

&lt;p&gt;WDYT? cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stephane.maarek%40gmail.com&quot; class=&quot;user-hover&quot; rel=&quot;stephane.maarek@gmail.com&quot;&gt;stephane.maarek@gmail.com&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mihbor%40wp.pl&quot; class=&quot;user-hover&quot; rel=&quot;mihbor@wp.pl&quot;&gt;mihbor@wp.pl&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16284366" author="stephane.maarek@gmail.com" created="Fri, 8 Dec 2017 22:55:34 +0000"  >&lt;p&gt;Fully agree &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; . I fully agree on the punctuate once as well (even if T2 is 5 intervals away), I have observed punctuate being called way to many times if the data does a big jump. &lt;/p&gt;

&lt;p&gt;Finally, is there any interest or use cases in using both a wall clock and event driven punctuate? Might require a KIP for that one&lt;/p&gt;</comment>
                            <comment id="16284417" author="mjsax" created="Fri, 8 Dec 2017 23:33:22 +0000"  >&lt;p&gt;We discussed &quot;mix mode&quot; during the KIP (&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/KIP-138%3A+Change+punctuate+semantics&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://cwiki.apache.org/confluence/display/KAFKA/KIP-138%3A+Change+punctuate+semantics&lt;/a&gt;) discussion &amp;#8211; we buried this idea. Users can build this by themselves (note, you can register as many independent punctuation schedules for a singe processes as you want &amp;#8211; and can also mix wall-clock and stream-time)&lt;/p&gt;

&lt;p&gt;I also second Guozhang&apos;s proposal!&lt;/p&gt;</comment>
                            <comment id="16293719" author="frederica" created="Sat, 16 Dec 2017 09:05:11 +0000"  >&lt;p&gt;Although I&apos;ve got very little experience with Kafka (and none at all with STREAM_TIME punctuation), Guozhang&apos;s proposal sounds good to me.&lt;/p&gt;

&lt;p&gt;I think there&apos;s something to discuss about managing the gap between punctuations. Let&apos;s say the last punctuation happened at T0, and the next is planned at T1. Let&apos;s also consider T2 = T1 + x*interval, where x &amp;gt;= 2.&lt;/p&gt;

&lt;p&gt;With STREAM_TIME, if we get no data until T2, the gap is bigger than interval and according to Guozhang&apos;s proposal we punctuate only once at T2. And will punctuate next at T2+interval.&lt;/p&gt;

&lt;p&gt;With WALL_CLOCK_TIME it could also happen that we don&apos;t effectively punctuate before T2 (GC pause, overload, ...). If that happens should we also only punctuate once at T2 and next at T2+interval?&lt;/p&gt;</comment>
                            <comment id="16293898" author="mjsax" created="Sat, 16 Dec 2017 18:15:49 +0000"  >&lt;p&gt;I like this. Having consistent behavior should improve user experience! We just need to document it in detail.&lt;/p&gt;</comment>
                            <comment id="16294014" author="frederica" created="Sun, 17 Dec 2017 06:35:57 +0000"  >&lt;p&gt;I updated my PR according to the above discussion, see &lt;a href=&quot;https://github.com/apache/kafka/pull/4301&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4301&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16294539" author="frederica" created="Mon, 18 Dec 2017 05:58:00 +0000"  >&lt;p&gt;I&apos;d like to discuss about alignment as requested by &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt; in my updated PR, especially here: &lt;a href=&quot;https://github.com/apache/kafka/pull/4301#discussion_r157378045&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4301#discussion_r157378045&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With the code I pushed, the punctuations stay aligned (best effort), until there&apos;s a gap bigger than 2*interval. After a big gap, my code triggers a punctuation as early as possible and then aligns on that punctuation time, not matching the alignment we had before the gap.&lt;/p&gt;

&lt;p&gt;In the discussion below, I&apos;m only talking about alignment over a big gap (&amp;gt; 2*interval), and I don&apos;t see the value of staying aligned (but as stated before I have very little experience with all of that), here&apos;s why:&lt;/p&gt;

&lt;p&gt;1. The current API doesn&apos;t suggest alignment is important, it could be different if we had schedule(final long start, final long interval, final PunctuationType type, final Punctuator punctuator), where the start parameter would indicate the desired time of the first punctuation. In that case I could agree to only punctuate at start+x*interval. But that&apos;s not what we currently have, and it would come with further complications: we would need to decide what to do for incomplete intervals, either skip a punctuation, or have 2 punctuations spaced by less than interval.&lt;/p&gt;

&lt;p&gt;2. Because we don&apos;t have a start parameter (see previous point), the first punctuation can happen at anytime. Does it make sense to align on that time which is an almost random time? Indeed with STREAM_TIME, the first punctuation happens as soon as we have a stream time and that time comes from the data&apos;s timestamps which I don&apos;t expect to be aligned to anything meaningful. With WALL_CLOCK_TIME, the first punctuation happens roughly at now()+interval, now() being the time at which the schedule call was made, that can&apos;t be aligned to anything.&lt;/p&gt;

&lt;p&gt;Am I missing something?&lt;/p&gt;</comment>
                            <comment id="16295406" author="mjsax" created="Mon, 18 Dec 2017 18:40:02 +0000"  >&lt;p&gt;It&apos;s a fair question. I personally like code that is as predictable as possible, thus, I tend to say we should align schedules to fixed intervals (for both, system time and stream time). Thus, each time we need to &quot;anchor&quot; the punctuation because we register the first schedule or missed a schedule, we fix the schedule time to align. Ie., if one registers a schedule interval X, we should align to the &lt;tt&gt;floor(currentTimestamp + interval)&lt;/tt&gt; where &lt;tt&gt;floor&lt;/tt&gt; computes  &lt;tt&gt;max(n * X) &amp;lt;= currentTimestamp + interval&lt;/tt&gt;. This is especially valuable for &quot;stream-time&quot; punctuations IMHO. Note, we also align windows in a similar way.&lt;/p&gt;

&lt;p&gt;Just my two cents. \cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=damianguy&quot; class=&quot;user-hover&quot; rel=&quot;damianguy&quot;&gt;damianguy&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bbejeck&quot; class=&quot;user-hover&quot; rel=&quot;bbejeck&quot;&gt;bbejeck&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; &lt;/p&gt;</comment>
                            <comment id="16297570" author="guozhang" created="Tue, 19 Dec 2017 23:11:18 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=frederica&quot; class=&quot;user-hover&quot; rel=&quot;frederica&quot;&gt;frederica&lt;/a&gt; I&apos;d suggest the following:&lt;/p&gt;

&lt;p&gt;1) STREAM_TIME punctuation: I agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt; for aligning on scheduled timestamp; to be more specific, suppose user provided interval is &lt;tt&gt;T&lt;/tt&gt;, we would first schedule the next timstamp as &lt;tt&gt;T&lt;/tt&gt; exactly; then at any point suppose our next scheduled the next timestamp &lt;tt&gt;T1&lt;/tt&gt;, and stream time has advanced to &lt;tt&gt;T2&lt;/tt&gt; because of received data where &lt;tt&gt;T2 &amp;gt;= T1&lt;/tt&gt;, then we just punctuate with parameter &lt;tt&gt;floor(T2, T)&lt;/tt&gt; and schedule the next punctuation at &lt;tt&gt;floor(T2, T) + T&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;2) WALL_CLOCK_TIME: we do not try to align on interval, i.e. with user provided interval &lt;tt&gt;T&lt;/tt&gt;, next scheduled time is &lt;tt&gt;now + T&lt;/tt&gt;, and at the time we did the check with scheduled timestamp &lt;tt&gt;T1&lt;/tt&gt;, if the current system time is &lt;tt&gt;T2 (T2 &amp;gt;= T1)&lt;/tt&gt; we punctuate at &lt;tt&gt;T2&lt;/tt&gt; and schedule the next punctuation at timestamp &lt;tt&gt;T2 + T&lt;/tt&gt;. The argument is that with long GC / single-record-taking-long-time-to-process / etc scenarios, we can never have a precise or predictable punctuation based on system wall-clock time, so instead we&apos;d just try to expose the exact current system time when punctuation is triggered.&lt;/p&gt;</comment>
                            <comment id="16298166" author="frederica" created="Wed, 20 Dec 2017 09:30:42 +0000"  >&lt;p&gt;I&apos;m fine with most of that, I only have a doubt about not aligning wall-clock punctuations on &lt;tt&gt;now + N*interval&lt;/tt&gt;, which could effectively make punctuations calls drift away. Do you have use cases where spacing punctuations by at least interval is critical and requires that behavior?&lt;/p&gt;

&lt;p&gt;I&apos;ve pushed updated code, in which I do not allow punctuation time drift (this makes the behavior more coherent between stream-time and wall-clock-time punctuation).&lt;/p&gt;

&lt;p&gt;By default, the new code aligns punctuations as discussed above.&lt;/p&gt;

&lt;p&gt;I&apos;ve also added an overload, enabling users to choose the first punctuation time, the first punctuation time then becomes the reference on which further punctuations are aligned.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Cancellable schedule(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; startTime, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; interval, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; PunctuationType type, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Punctuator punctuator)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In my use case, I use wall-clock time punctuation to punctuate every day at 2am. I would use the new API the following way, allowing me to call &lt;tt&gt;context.schedule()&lt;/tt&gt; once instead of twice currently:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
context.schedule(timeUntil2Am, 24 * 60 * 60 * 1000, WALL_CLOCK_TIME, (callTime) -&amp;gt; doStuffRightAfter2am(callTime))
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16298167" author="frederica" created="Wed, 20 Dec 2017 09:30:42 +0000"  >&lt;p&gt;I&apos;m fine with most of that, I only have a doubt about not aligning wall-clock punctuations on &lt;tt&gt;now + N*interval&lt;/tt&gt;, which could effectively make punctuations calls drift away. Do you have use cases where spacing punctuations by at least interval is critical and requires that behavior?&lt;/p&gt;

&lt;p&gt;I&apos;ve pushed updated code, in which I do not allow punctuation time drift (this makes the behavior more coherent between stream-time and wall-clock-time punctuation).&lt;/p&gt;

&lt;p&gt;By default, the new code aligns punctuations as discussed above.&lt;/p&gt;

&lt;p&gt;I&apos;ve also added an overload, enabling users to choose the first punctuation time, the first punctuation time then becomes the reference on which further punctuations are aligned.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; Cancellable schedule(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; startTime, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; interval, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; PunctuationType type, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Punctuator punctuator)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In my use case, I use wall-clock time punctuation to punctuate every day at 2am. I would use the new API the following way, allowing me to call &lt;tt&gt;context.schedule()&lt;/tt&gt; once instead of twice currently:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
context.schedule(timeUntil2Am, 24 * 60 * 60 * 1000, WALL_CLOCK_TIME, (callTime) -&amp;gt; doStuffRightAfter2am(callTime))
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16298169" author="githubbot" created="Wed, 20 Dec 2017 09:33:11 +0000"  >&lt;p&gt;Github user fredfp closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/4304&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4304&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16299140" author="mjsax" created="Wed, 20 Dec 2017 21:40:19 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=frederica&quot; class=&quot;user-hover&quot; rel=&quot;frederica&quot;&gt;frederica&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We cannot simply change the interface of &lt;tt&gt;schedule()&lt;/tt&gt; method &amp;#8211; this is a public API change and requires a KIP (&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals&lt;/a&gt;). If you think it&apos;s a valuable addition, feel free to do a KIP on it (including a new JIRA to cover the change).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I see your point that aligning start wall-clock time punctuations might not be as valuable as aligning stream-time ones. However, I agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=frederica&quot; class=&quot;user-hover&quot; rel=&quot;frederica&quot;&gt;frederica&lt;/a&gt; that if we move from &lt;tt&gt;T2 (T2 &amp;gt;= T1)&lt;/tt&gt; to &lt;tt&gt;T2 + T&lt;/tt&gt; punctuation shift into the future and I think this would be undesired behavior. For long GC pauses etc, we would just skip the corresponding punctuation similarly to the skipping behavior for stream-time in case stream-time make a larger advance that 2x punctuation interval.&lt;/p&gt;</comment>
                            <comment id="16299273" author="guozhang" created="Wed, 20 Dec 2017 23:50:21 +0000"  >&lt;p&gt;My concern of doing alignment with wall-clock time is that we would intentionally trigger &lt;tt&gt;puncuate(T2)&lt;/tt&gt; where the passed in parameter &lt;tt&gt;T&lt;/tt&gt; is actually not the current system wall-clock time &lt;tt&gt;NOW&lt;/tt&gt;, but would be smaller to it. For user punctuation logics that rely on the accuracy of the passed in system time that might be a real problem (on the other hand, for stream time I consider this a much less of an issue since it is data drive anyways and hence stream time is defined on record timestamps only but not on when it is being processed).&lt;/p&gt;

&lt;p&gt;That being said, I do not feel strong against aligning with wall-clock time, just throwing my two cents here. If people are in favor of doing this I&apos;m OK as well. Just remind that we need to document the behavior clearly in javadoc.&lt;/p&gt;</comment>
                            <comment id="16299347" author="frederica" created="Thu, 21 Dec 2017 01:01:02 +0000"  >&lt;p&gt;Thanks for your comments, I&apos;ll consider a KIP for the added API method when I&apos;m back from a 2 weeks leave.&lt;/p&gt;</comment>
                            <comment id="16299415" author="mjsax" created="Thu, 21 Dec 2017 02:10:17 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; I agree that we should pass in current wall-clock time &lt;tt&gt;NOW&lt;/tt&gt; when calling a punctuation. But from my understanding, that is what we are doing atm anyway. And this holds for wall-clock as well as stream-time. Or do I miss something.&lt;/p&gt;</comment>
                            <comment id="16300491" author="guozhang" created="Thu, 21 Dec 2017 19:48:02 +0000"  >&lt;p&gt;Yes that is what we are doing atm. But by aligning the punctuation timestamp to &lt;tt&gt;floor(T, interval)&lt;/tt&gt; we are going to not do this anymore right?&lt;/p&gt;</comment>
                            <comment id="16300584" author="mjsax" created="Thu, 21 Dec 2017 21:48:30 +0000"  >&lt;p&gt;I don&apos;t think so &amp;#8211; we only align the schedule, but not the timestamp we pass into the `punctuate()` call itself. Ie, atm we would do the following In practice, I would assume that punctuation are actually never called at the actual scheduled time, but always a couple of milliseconds late, taking this into account, without alignment we even shift without a long GC pause:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;interval 10000

old: 
scheduled punctuation: 10000   20003   30005   40010   50012
calling punctuation:   10003   20005   30010   40012
new:
scheduled punctuation: 10000   20000   30000   40000   50000
calling punctuation:   10003   20002   30005   40002
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thus, the delays to the schedule do not add up over time with the alignment. Note, that the timestamp we pass into the punctuation call is never the timestamp of the schedule but `NOW`. For example, in the first example, we might be able to call punctuate at 40002 but we scheduled at 40010 and thus cannot call before the schedule.&lt;/p&gt;</comment>
                            <comment id="16301845" author="guozhang" created="Fri, 22 Dec 2017 19:22:46 +0000"  >&lt;p&gt;Thanks for the explanation, that makes sense; my previous question was mainly on what timestamp value we pass into the &lt;tt&gt;punctuate&lt;/tt&gt; call, and I was leaning towards &quot;passing the actual timestamp`, i.e. in your example 10003, 20002, 30005, etc. Seems we are on the same page for that.&lt;/p&gt;

&lt;p&gt;As for rescheduling for the next punctuation event, I agree with you that we should align with the interval.&lt;/p&gt;</comment>
                            <comment id="16301919" author="mjsax" created="Fri, 22 Dec 2017 20:26:07 +0000"  >&lt;p&gt;Great!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=frederica&quot; class=&quot;user-hover&quot; rel=&quot;frederica&quot;&gt;frederica&lt;/a&gt; Do you agree as well? If yes, please update the PR accordingly if necessary. Thanks a lot!&lt;/p&gt;</comment>
                            <comment id="16321878" author="frederica" created="Thu, 11 Jan 2018 08:50:11 +0000"  >&lt;p&gt;I agree and the PR doesn&apos;t need to be updated for the above, as it already works like that (see the tests).&lt;/p&gt;</comment>
                            <comment id="16346143" author="githubbot" created="Wed, 31 Jan 2018 02:18:58 +0000"  >&lt;p&gt;mjsax closed pull request #4301: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6323&quot; title=&quot;punctuate with WALL_CLOCK_TIME triggered immediately&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6323&quot;&gt;&lt;del&gt;KAFKA-6323&lt;/del&gt;&lt;/a&gt;: punctuate with WALL_CLOCK_TIME triggered immediately&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4301&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4301&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/ProcessorContext.java b/streams/src/main/java/org/apache/kafka/streams/processor/ProcessorContext.java&lt;br/&gt;
index d4393aacba7..42902a866b1 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/ProcessorContext.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/ProcessorContext.java&lt;br/&gt;
@@ -102,11 +102,22 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;ul&amp;gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;li&amp;gt;
{@link PunctuationType#STREAM_TIME} - uses &quot;stream time&quot;, which is advanced by the processing of messages&lt;br/&gt;
      *   in accordance with the timestamp as extracted by the {@link TimestampExtractor} in use.&lt;br/&gt;
+     *   The first punctuation will be triggered by the first record that is processed.&lt;br/&gt;
      *   &amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; Only advanced if messages arrive&amp;lt;/li&amp;gt;&lt;br/&gt;
      *   &amp;lt;li&amp;gt;{@link PunctuationType#WALL_CLOCK_TIME} - uses system time (the wall-clock time),&lt;br/&gt;
      *   which is advanced at the polling interval ({@link org.apache.kafka.streams.StreamsConfig#POLL_MS_CONFIG})&lt;br/&gt;
-     *   independent of whether new messages arrive. &amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; This is best effort only as its granularity is limited&lt;br/&gt;
-     *   by how long an iteration of the processing loop takes to complete&amp;lt;/li&amp;gt;&lt;br/&gt;
+     *   independent of whether new messages arrive.&lt;br/&gt;
+     *   The first punctuation will be triggered after interval has elapsed.&lt;br/&gt;
+     *   &amp;lt;b&amp;gt;NOTE:&amp;lt;/b&amp;gt; This is best effort only as its granularity is limited by how long an iteration of the&lt;br/&gt;
+     *   processing loop takes to complete&amp;lt;/li&amp;gt;&lt;br/&gt;
+     * &amp;lt;/ul&amp;gt;&lt;br/&gt;
+     *&lt;br/&gt;
+     * &amp;lt;b&amp;gt;Skipping punctuations:&amp;lt;/b&amp;gt; Punctuations will not be triggered more than once at any given timestamp.&lt;br/&gt;
+     * This means that &quot;missed&quot; punctuation will be skipped.&lt;br/&gt;
+     * It&apos;s possible to &quot;miss&quot; a punctuation if:&lt;br/&gt;
+     * &amp;lt;ul&amp;gt;&lt;br/&gt;
+     *   &amp;lt;li&amp;gt;with {@link PunctuationType#STREAM_TIME}
&lt;p&gt;, when stream time advances more than interval&amp;lt;/li&amp;gt;&lt;br/&gt;
+     *   &amp;lt;li&amp;gt;with &lt;/p&gt;
{@link PunctuationType#WALL_CLOCK_TIME}
&lt;p&gt;, on GC pause, too short interval, ...&amp;lt;/li&amp;gt;&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&amp;lt;/ul&amp;gt;&lt;br/&gt;
      *&lt;/li&gt;
	&lt;li&gt;@param intervalMs the time interval between punctuations in milliseconds&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/PunctuationSchedule.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/PunctuationSchedule.java&lt;br/&gt;
index cf50005fcd1..9c0ec88b69f 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/processor/internals/PunctuationSchedule.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/PunctuationSchedule.java&lt;br/&gt;
@@ -27,12 +27,19 @@&lt;br/&gt;
     // this Cancellable will be re-pointed at the successor schedule in next()&lt;br/&gt;
     private final RepointableCancellable cancellable;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;PunctuationSchedule(ProcessorNode node, long interval, Punctuator punctuator) {&lt;/li&gt;
	&lt;li&gt;this(node, 0L, interval, punctuator, new RepointableCancellable());&lt;br/&gt;
+    PunctuationSchedule(final ProcessorNode node,&lt;br/&gt;
+                        final long time,&lt;br/&gt;
+                        final long interval,&lt;br/&gt;
+                        final Punctuator punctuator) 
{
+        this(node, time, interval, punctuator, new RepointableCancellable());
         cancellable.setSchedule(this);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private PunctuationSchedule(ProcessorNode node, long time, long interval, Punctuator punctuator, RepointableCancellable cancellable) {&lt;br/&gt;
+    private PunctuationSchedule(final ProcessorNode node,&lt;br/&gt;
+                                final long time,&lt;br/&gt;
+                                final long interval,&lt;br/&gt;
+                                final Punctuator punctuator,&lt;br/&gt;
+                                final RepointableCancellable cancellable) {&lt;br/&gt;
         super(node, time);&lt;br/&gt;
         this.interval = interval;&lt;br/&gt;
         this.punctuator = punctuator;&lt;br/&gt;
@@ -59,14 +66,19 @@ boolean isCancelled() 
{
         return isCancelled;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public PunctuationSchedule next(long currTimestamp) {&lt;/li&gt;
	&lt;li&gt;PunctuationSchedule nextSchedule;&lt;/li&gt;
	&lt;li&gt;// we need to special handle the case when it is firstly triggered (i.e. the timestamp&lt;/li&gt;
	&lt;li&gt;// is equal to the interval) by reschedule based on the currTimestamp&lt;/li&gt;
	&lt;li&gt;if (timestamp == 0L)&lt;/li&gt;
	&lt;li&gt;nextSchedule = new PunctuationSchedule(value, currTimestamp + interval, interval, punctuator, cancellable);&lt;/li&gt;
	&lt;li&gt;else&lt;/li&gt;
	&lt;li&gt;nextSchedule = new PunctuationSchedule(value, timestamp + interval, interval, punctuator, cancellable);&lt;br/&gt;
+    public PunctuationSchedule next(final long currTimestamp) {&lt;br/&gt;
+        long nextPunctuationTime = timestamp + interval;&lt;br/&gt;
+        if (currTimestamp &amp;gt;= nextPunctuationTime) 
{
+            // we missed one ore more punctuations
+            // avoid scheduling a new punctuations immediately, this can happen:
+            // - when using STREAM_TIME punctuation and there was a gap i.e., no data was
+            //   received for at least 2*interval
+            // - when using WALL_CLOCK_TIME and there was a gap i.e., punctuation was delayed for at least 2*interval (GC pause, overload, ...)
+            final long intervalsMissed = (currTimestamp - timestamp) / interval;
+            nextPunctuationTime = timestamp + (intervalsMissed + 1) * interval;
+        }
&lt;p&gt;+&lt;br/&gt;
+        final PunctuationSchedule nextSchedule = new PunctuationSchedule(value, nextPunctuationTime, interval, punctuator, cancellable);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         cancellable.setSchedule(nextSchedule);&lt;/p&gt;

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java&lt;br/&gt;
index 11b2f89317b..56c0ab31f4b 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java&lt;br/&gt;
@@ -578,16 +578,40 @@ public int addRecords(final TopicPartition partition, final Iterable&amp;lt;ConsumerRec&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@throws IllegalStateException if the current node is not null&lt;br/&gt;
      */&lt;br/&gt;
     public Cancellable schedule(final long interval, final PunctuationType type, final Punctuator punctuator) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        switch (type) {
+            case STREAM_TIME:
+                // align punctuation to 0L, punctuate as soon as we have data
+                return schedule(0L, interval, type, punctuator);
+            case WALL_CLOCK_TIME:
+                // align punctuation to now, punctuate after interval has elapsed
+                return schedule(time.milliseconds() + interval, interval, type, punctuator);
+            default:
+                throw new IllegalArgumentException(&quot;Unrecognized PunctuationType: &quot; + type);
+        }+    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Schedules a punctuation for the processor&lt;br/&gt;
+     *&lt;br/&gt;
+     * @param startTime time of the first punctuation&lt;br/&gt;
+     * @param interval the interval in milliseconds&lt;br/&gt;
+     * @param type the punctuation type&lt;br/&gt;
+     * @throws IllegalStateException if the current node is not null&lt;br/&gt;
+     */&lt;br/&gt;
+    Cancellable schedule(final long startTime, final long interval, final PunctuationType type, final Punctuator punctuator) {&lt;br/&gt;
         if (processorContext.currentNode() == null) &lt;/p&gt;
{
             throw new IllegalStateException(String.format(&quot;%sCurrent node is null&quot;, logPrefix));
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final PunctuationSchedule schedule = new PunctuationSchedule(processorContext.currentNode(), interval, punctuator);&lt;br/&gt;
+        final PunctuationSchedule schedule = new PunctuationSchedule(processorContext.currentNode(), startTime, interval, punctuator);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         switch (type) {&lt;br/&gt;
             case STREAM_TIME:&lt;br/&gt;
+                // STREAM_TIME punctuation is data driven, will first punctuate as soon as stream-time is known and &amp;gt;= time,&lt;br/&gt;
+                // stream-time is known when we have received at least one record from each input topic&lt;br/&gt;
                 return streamTimePunctuationQueue.schedule(schedule);&lt;br/&gt;
             case WALL_CLOCK_TIME:&lt;br/&gt;
+                // WALL_CLOCK_TIME is driven by the wall clock time, will first punctuate when now &amp;gt;= time&lt;br/&gt;
                 return systemTimePunctuationQueue.schedule(schedule);&lt;br/&gt;
             default:&lt;br/&gt;
                 throw new IllegalArgumentException(&quot;Unrecognized PunctuationType: &quot; + type);&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/PunctuationQueueTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/PunctuationQueueTest.java&lt;br/&gt;
index 1570c9bdd13..09c7a0a3183 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/processor/internals/PunctuationQueueTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/PunctuationQueueTest.java&lt;br/&gt;
@@ -40,7 +40,7 @@ public void punctuate(long timestamp) {&lt;br/&gt;
             }&lt;br/&gt;
         };&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final PunctuationSchedule sched = new PunctuationSchedule(node, 100L, punctuator);&lt;br/&gt;
+        final PunctuationSchedule sched = new PunctuationSchedule(node, 0L, 100L, punctuator);&lt;br/&gt;
         final long now = sched.timestamp - 100L;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         queue.schedule(sched);&lt;br/&gt;
@@ -66,6 +66,64 @@ public void punctuate(ProcessorNode node, long time, PunctuationType type, Punct&lt;/p&gt;

&lt;p&gt;         queue.mayPunctuate(now + 200L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
         assertEquals(2, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 1001L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(3, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 1002L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(3, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 1100L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(4, processor.punctuatedAt.size());&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testPunctuationIntervalCustomAlignment() {&lt;br/&gt;
+        final TestProcessor processor = new TestProcessor();&lt;br/&gt;
+        final ProcessorNode&amp;lt;String, String&amp;gt; node = new ProcessorNode&amp;lt;&amp;gt;(&quot;test&quot;, processor, null);&lt;br/&gt;
+        final PunctuationQueue queue = new PunctuationQueue();&lt;br/&gt;
+        final Punctuator punctuator = new Punctuator() {&lt;br/&gt;
+            @Override&lt;br/&gt;
+            public void punctuate(long timestamp) &lt;/p&gt;
{
+                node.processor().punctuate(timestamp);
+            }
&lt;p&gt;+        };&lt;br/&gt;
+&lt;br/&gt;
+        final PunctuationSchedule sched = new PunctuationSchedule(node, 50L, 100L, punctuator);&lt;br/&gt;
+        final long now = sched.timestamp - 50L;&lt;br/&gt;
+&lt;br/&gt;
+        queue.schedule(sched);&lt;br/&gt;
+&lt;br/&gt;
+        ProcessorNodePunctuator processorNodePunctuator = new ProcessorNodePunctuator() {&lt;br/&gt;
+            @Override&lt;br/&gt;
+            public void punctuate(ProcessorNode node, long time, PunctuationType type, Punctuator punctuator) &lt;/p&gt;
{
+                punctuator.punctuate(time);
+            }
&lt;p&gt;+        };&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(0, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 49L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(0, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 50L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(1, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 149L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(1, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 150L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(2, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 1051L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(3, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 1052L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(3, processor.punctuatedAt.size());&lt;br/&gt;
+&lt;br/&gt;
+        queue.mayPunctuate(now + 1150L, PunctuationType.STREAM_TIME, processorNodePunctuator);&lt;br/&gt;
+        assertEquals(4, processor.punctuatedAt.size());&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     private static class TestProcessor extends AbstractProcessor&amp;lt;String, String&amp;gt; {&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java&lt;br/&gt;
index 92cfe66c3f6..1165d76cf2e 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java&lt;br/&gt;
@@ -322,63 +322,173 @@ public void testMaybePunctuateStreamTime() &lt;/p&gt;
{
         task.initializeTopology();
 
         task.addRecords(partition1, records(
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 0, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
                 new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 20, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
-                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 30, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
-                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 40, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 32, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 40, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 60, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)
         ));
 
         task.addRecords(partition2, records(
                 new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 25, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
                 new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 35, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
-                new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 45, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)
+                new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 45, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 61, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)
         ));
 
         assertTrue(task.maybePunctuateStreamTime());
 
         assertTrue(task.process());
-        assertEquals(5, task.numBuffered());
+        assertEquals(8, task.numBuffered());
         assertEquals(1, source1.numReceived);
         assertEquals(0, source2.numReceived);
 
+        assertTrue(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(7, task.numBuffered());
+        assertEquals(2, source1.numReceived);
+        assertEquals(0, source2.numReceived);
+
         assertFalse(task.maybePunctuateStreamTime());
 
         assertTrue(task.process());
-        assertEquals(4, task.numBuffered());
-        assertEquals(1, source1.numReceived);
+        assertEquals(6, task.numBuffered());
+        assertEquals(2, source1.numReceived);
+        assertEquals(1, source2.numReceived);
+
+        assertTrue(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(5, task.numBuffered());
+        assertEquals(3, source1.numReceived);
         assertEquals(1, source2.numReceived);
 
+        assertFalse(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(4, task.numBuffered());
+        assertEquals(3, source1.numReceived);
+        assertEquals(2, source2.numReceived);
+
         assertTrue(task.maybePunctuateStreamTime());
 
         assertTrue(task.process());
         assertEquals(3, task.numBuffered());
+        assertEquals(4, source1.numReceived);
+        assertEquals(2, source2.numReceived);
+
+        assertFalse(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(2, task.numBuffered());
+        assertEquals(4, source1.numReceived);
+        assertEquals(3, source2.numReceived);
+
+        assertTrue(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(1, task.numBuffered());
+        assertEquals(5, source1.numReceived);
+        assertEquals(3, source2.numReceived);
+
+        assertFalse(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(0, task.numBuffered());
+        assertEquals(5, source1.numReceived);
+        assertEquals(4, source2.numReceived);
+
+        assertFalse(task.process());
+        assertFalse(task.maybePunctuateStreamTime());
+
+        processorStreamTime.supplier.checkAndClearPunctuateResult(PunctuationType.STREAM_TIME, 0L, 20L, 32L, 40L, 60L);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldPunctuateOnceStreamTimeAfterGap() &lt;/p&gt;
{
+        task = createStatelessTask(false);
+        task.initializeStateStores();
+        task.initializeTopology();
+
+        task.addRecords(partition1, records(
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 20, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 142, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 155, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition1.topic(), partition1.partition(), 160, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)
+        ));
+
+        task.addRecords(partition2, records(
+                new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 25, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 145, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 159, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue),
+                new ConsumerRecord&amp;lt;&amp;gt;(partition2.topic(), partition2.partition(), 161, 0L, TimestampType.CREATE_TIME, 0L, 0, 0, recordKey, recordValue)
+        ));
+
+        assertTrue(task.maybePunctuateStreamTime()); // punctuate at 20
+
+        assertTrue(task.process());
+        assertEquals(7, task.numBuffered());
+        assertEquals(1, source1.numReceived);
+        assertEquals(0, source2.numReceived);
+
+        assertFalse(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(6, task.numBuffered());
+        assertEquals(1, source1.numReceived);
+        assertEquals(1, source2.numReceived);
+
+        assertTrue(task.maybePunctuateStreamTime()); // punctuate at 142
+
+        // only one punctuation after 100ms gap
+        assertFalse(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(5, task.numBuffered());
         assertEquals(2, source1.numReceived);
         assertEquals(1, source2.numReceived);
 
         assertFalse(task.maybePunctuateStreamTime());
 
         assertTrue(task.process());
-        assertEquals(2, task.numBuffered());
+        assertEquals(4, task.numBuffered());
         assertEquals(2, source1.numReceived);
         assertEquals(2, source2.numReceived);
 
-        assertTrue(task.maybePunctuateStreamTime());
+        assertTrue(task.maybePunctuateStreamTime()); // punctuate at 155
 
         assertTrue(task.process());
-        assertEquals(1, task.numBuffered());
+        assertEquals(3, task.numBuffered());
         assertEquals(3, source1.numReceived);
         assertEquals(2, source2.numReceived);
 
         assertFalse(task.maybePunctuateStreamTime());
 
         assertTrue(task.process());
-        assertEquals(0, task.numBuffered());
+        assertEquals(2, task.numBuffered());
         assertEquals(3, source1.numReceived);
         assertEquals(3, source2.numReceived);
 
+        assertTrue(task.maybePunctuateStreamTime()); // punctuate at 160, still aligned on the initial punctuation
+
+        assertTrue(task.process());
+        assertEquals(1, task.numBuffered());
+        assertEquals(4, source1.numReceived);
+        assertEquals(3, source2.numReceived);
+
+        assertFalse(task.maybePunctuateStreamTime());
+
+        assertTrue(task.process());
+        assertEquals(0, task.numBuffered());
+        assertEquals(4, source1.numReceived);
+        assertEquals(4, source2.numReceived);
+
         assertFalse(task.process());
         assertFalse(task.maybePunctuateStreamTime());
 
-        processorStreamTime.supplier.checkAndClearPunctuateResult(PunctuationType.STREAM_TIME, 20L, 30L, 40L);
+        processorStreamTime.supplier.checkAndClearPunctuateResult(PunctuationType.STREAM_TIME, 20L, 142L, 155L, 160L);
     }

&lt;p&gt;     @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
@@ -425,9 +535,14 @@ public void shouldPunctuateSystemTimeWhenIntervalElapsed() &lt;/p&gt;
{
         assertTrue(task.maybePunctuateSystemTime());
         time.sleep(10);
         assertTrue(task.maybePunctuateSystemTime());
-        time.sleep(10);
+        time.sleep(9);
+        assertFalse(task.maybePunctuateSystemTime());
+        time.sleep(1);
+        assertTrue(task.maybePunctuateSystemTime());
+        time.sleep(20);
         assertTrue(task.maybePunctuateSystemTime());
-        processorSystemTime.supplier.checkAndClearPunctuateResult(PunctuationType.WALL_CLOCK_TIME, now + 10, now + 20, now + 30);
+        assertFalse(task.maybePunctuateSystemTime());
+        processorSystemTime.supplier.checkAndClearPunctuateResult(PunctuationType.WALL_CLOCK_TIME, now + 10, now + 20, now + 30, now + 50);
     }

&lt;p&gt;     @Test&lt;br/&gt;
@@ -435,11 +550,36 @@ public void shouldNotPunctuateSystemTimeWhenIntervalNotElapsed() &lt;/p&gt;
{
         task = createStatelessTask(false);
         task.initializeStateStores();
         task.initializeTopology();
-        long now = time.milliseconds();
-        assertTrue(task.maybePunctuateSystemTime()); // first time we always punctuate
+        assertFalse(task.maybePunctuateSystemTime());
         time.sleep(9);
         assertFalse(task.maybePunctuateSystemTime());
-        processorSystemTime.supplier.checkAndClearPunctuateResult(PunctuationType.WALL_CLOCK_TIME, now);
+        processorSystemTime.supplier.checkAndClearPunctuateResult(PunctuationType.WALL_CLOCK_TIME);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldPunctuateOnceSystemTimeAfterGap() &lt;/p&gt;
{
+        task = createStatelessTask(false);
+        task.initializeStateStores();
+        task.initializeTopology();
+        long now = time.milliseconds();
+        time.sleep(100);
+        assertTrue(task.maybePunctuateSystemTime());
+        assertFalse(task.maybePunctuateSystemTime());
+        time.sleep(10);
+        assertTrue(task.maybePunctuateSystemTime());
+        time.sleep(12);
+        assertTrue(task.maybePunctuateSystemTime());
+        time.sleep(7);
+        assertFalse(task.maybePunctuateSystemTime());
+        time.sleep(1); // punctuate at now + 130
+        assertTrue(task.maybePunctuateSystemTime());
+        time.sleep(105); // punctuate at now + 235
+        assertTrue(task.maybePunctuateSystemTime());
+        assertFalse(task.maybePunctuateSystemTime());
+        time.sleep(5); // punctuate at now + 240, still aligned on the initial punctuation
+        assertTrue(task.maybePunctuateSystemTime());
+        assertFalse(task.maybePunctuateSystemTime());
+        processorSystemTime.supplier.checkAndClearPunctuateResult(PunctuationType.WALL_CLOCK_TIME, now + 100, now + 110, now + 122, now + 130, now + 235, now + 240);
     }

&lt;p&gt;     @Test&lt;br/&gt;
diff --git a/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java b/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java&lt;br/&gt;
index 4100f186566..5073efdb64c 100644&lt;br/&gt;
&amp;#8212; a/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java&lt;br/&gt;
+++ b/streams/test-utils/src/test/java/org/apache/kafka/streams/TopologyTestDriverTest.java&lt;br/&gt;
@@ -593,36 +593,35 @@ public void shouldPunctuateOnStreamsTime() &lt;/p&gt;
{
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 42L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
+        expectedPunctuations.add(51L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 51L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
-        expectedPunctuations.add(52L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 52L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
+        expectedPunctuations.add(61L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 61L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
-        expectedPunctuations.add(65L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 65L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
+        expectedPunctuations.add(71L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 71L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
-        expectedPunctuations.add(72L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 72L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
-        expectedPunctuations.add(95L);
         expectedPunctuations.add(95L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 95L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
+        expectedPunctuations.add(101L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 101L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
-        expectedPunctuations.add(102L);
         testDriver.pipeInput(consumerRecordFactory.create(SOURCE_TOPIC_1, key1, value1, 102L));
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
     }
&lt;p&gt;@@ -637,21 +636,23 @@ public void shouldPunctuateOnWallClockTime() &lt;/p&gt;
{
 
         final List&amp;lt;Long&amp;gt; expectedPunctuations = new LinkedList&amp;lt;&amp;gt;();
 
-        expectedPunctuations.add(5L);
         testDriver.advanceWallClockTime(5L);
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
+        expectedPunctuations.add(14L);
         testDriver.advanceWallClockTime(9L);
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
-        expectedPunctuations.add(15L);
         testDriver.advanceWallClockTime(1L);
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
 
-        expectedPunctuations.add(35L);
         expectedPunctuations.add(35L);
         testDriver.advanceWallClockTime(20L);
         assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
+
+        expectedPunctuations.add(40L);
+        testDriver.advanceWallClockTime(5L);
+        assertThat(mockPunctuator.punctuatedAt, equalTo(expectedPunctuations));
     }

&lt;p&gt;     @Test&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13110796">KAFKA-6092</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 41 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3nmun:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>