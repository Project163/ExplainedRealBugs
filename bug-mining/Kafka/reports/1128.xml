<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 16:55:22 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-3933] Kafka OOM During Log Recovery Due to Leaked Native Memory</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-3933</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Hi there. We&apos;ve been tracking an issue where Kafka hits an java.lang.OutOfMemoryError during log recovery.&lt;br/&gt;
After a bunch of tracking work, we&apos;ve realized we&apos;ve hit an instance of a long known issue: &lt;a href=&quot;http://www.evanjones.ca/java-native-leak-bug.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.evanjones.ca/java-native-leak-bug.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TLDR: Kafka breaks the rule &quot;Always close GZIPInputStream and GZIPOutputStream since they use native memory via zlib&quot; from that article.&lt;/p&gt;

&lt;p&gt;As such, during broker startup, when you&apos;re recovering log segments that have been compressed with gzip, Kafka leaks `GZIPInputStream` all over the place.&lt;br/&gt;
Our crashes during startup have this profile - the JVM heap is empty (a few hundred MB), but the offheap memory is full of allocations caused by `Java_java_util_zip_Deflater_init` and `deflatInit2`.&lt;br/&gt;
This leads to broker crashes during startup. The only real mitigation is having &lt;b&gt;far&lt;/b&gt; more memory than you need to boot (which I&apos;d guess is why folk haven&apos;t noticed this in production that much yet).&lt;/p&gt;

&lt;p&gt;To dig into the code more (this is based on trunk). Log recovery on unflushed segments eventually calls `LogSegment.recover`: &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/log/LogSegment.scala#L172&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/log/LogSegment.scala#L172&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;On compressed segments, that leads to a call to `deepIterator`: &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/log/LogSegment.scala#L189&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/log/LogSegment.scala#L189&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;That leads to a call to `CompressionFactory`: &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/message/ByteBufferMessageSet.scala#L95&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/message/ByteBufferMessageSet.scala#L95&lt;/a&gt; which creates a `GZIPInputStream`: &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/message/CompressionFactory.scala#L46&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/message/CompressionFactory.scala#L46&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;That `GZIPInputStream` is never closed anywhere, and the low &lt;b&gt;heap&lt;/b&gt; pressure means that the finalizer on `GZIPInputStream` that deallocates the native buffers is never called, because GC is never triggered. Instead, we just exhaust the offheap memory and then Kafka dies from an OutOfMemory error.&lt;/p&gt;

&lt;p&gt;Kafka &lt;b&gt;does&lt;/b&gt; trigger an `inputstream.close()` call, but only when &lt;b&gt;fully&lt;/b&gt; reading the whole input stream (see &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/message/ByteBufferMessageSet.scala#L156&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/message/ByteBufferMessageSet.scala#L156&lt;/a&gt;). When it&apos;s performing log recovery, in &lt;a href=&quot;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/log/LogSegment.scala#L189&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/log/LogSegment.scala#L189&lt;/a&gt; it doesn&apos;t read to the end of the stream, but instead reads the first offset and leaves things alone.&lt;/p&gt;

&lt;p&gt;This issue likely impacts `lz4` and `snappy` compressed topics in exactly the same way. I think (but haven&apos;t 100% verified) that it impacts all versions of Kafka that are supported (0.8 -&amp;gt; 0.10).&lt;/p&gt;

&lt;p&gt;Fixing this seems relatively annoying, but only because of some &quot;small matters of coding&quot;, nothing hugely problematic.&lt;/p&gt;

&lt;p&gt;The main issue is that `deepIterator` only returns an `Iterator`, which doesn&apos;t have a `close()` method of any kind. We could create a new `ClosableIterator` trait and have it extend Java&apos;s `AutoCloseable` (&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html&lt;/a&gt;), then explicitly call `close()` everywhere we use a `deepIterator()` and don&apos;t always read to the end. Scala unfortunately doesn&apos;t seem to have a built in version of Java&apos;s `try-with-resources` statement, but we can explicitly call close everywhere perfectly happily.&lt;/p&gt;

&lt;p&gt;Another (but much more hacky) solution would be to always read to the end of the iterator in `LogSegment.recover`, but that seems pretty bad, using far more resources than is needed during recovery.&lt;/p&gt;

&lt;p&gt;I can&apos;t think of any other reasonable solutions for now, but would love to hear input from the community.&lt;/p&gt;

&lt;p&gt;We&apos;re happy doing the work of developing a patch, but thought we&apos;d report the issue before starting down that path.&lt;/p&gt;</description>
                <environment>Linux, latest oracle java-8</environment>
        <key id="12987484">KAFKA-3933</key>
            <summary>Kafka OOM During Log Recovery Due to Leaked Native Memory</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="tcrayford-heroku">Tom Crayford</assignee>
                                    <reporter username="tcrayford-heroku">Tom Crayford</reporter>
                        <labels>
                    </labels>
                <created>Thu, 7 Jul 2016 13:31:39 +0000</created>
                <updated>Tue, 26 Jul 2016 01:59:30 +0000</updated>
                            <resolved>Tue, 26 Jul 2016 01:59:29 +0000</resolved>
                                    <version>0.8.2.2</version>
                    <version>0.9.0.1</version>
                    <version>0.10.0.0</version>
                                    <fixVersion>0.10.0.1</fixVersion>
                                    <component>log</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>9</watches>
                                                                                                                <comments>
                            <comment id="15366174" author="ijuma" created="Thu, 7 Jul 2016 14:16:48 +0000"  >&lt;p&gt;Nice catch. The suggested solution sounds good to me, but I think the `CloseableIterator` should probably live in `common` as `RecordsIterator` probably has a similar issue?&lt;/p&gt;</comment>
                            <comment id="15366329" author="tcrayford-heroku" created="Thu, 7 Jul 2016 16:08:15 +0000"  >&lt;p&gt;That makes sense to me. Thanks for the pointer.&lt;/p&gt;</comment>
                            <comment id="15366526" author="ijuma" created="Thu, 7 Jul 2016 18:11:06 +0000"  >&lt;p&gt;Shall I assign the JIRA to you?&lt;/p&gt;</comment>
                            <comment id="15366721" author="tcrayford-heroku" created="Thu, 7 Jul 2016 20:37:02 +0000"  >&lt;p&gt;Done. I hope to work on a fix tomorrow.&lt;/p&gt;</comment>
                            <comment id="15367613" author="githubbot" created="Fri, 8 Jul 2016 12:47:32 +0000"  >&lt;p&gt;GitHub user tcrayford opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1598&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1598&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: close deepIterator during log recovery&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Introduces `kafka.common.ClosableIterator`, which is an iterator that&lt;br/&gt;
    can be closed, and changes the signature of&lt;br/&gt;
    `ByteBufferMessageSet.deepIterator` to return it, then changes the&lt;br/&gt;
    caller `LogSegment` to always close the iterator.&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-3933&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/heroku/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/heroku/kafka&lt;/a&gt; dont_leak_native_memory&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1598.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1598.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #1598&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 06e748f4cddddc7dd8c2a860bd938b535e8172e1&lt;br/&gt;
Author: Tom Crayford &amp;lt;tcrayford@googlemail.com&amp;gt;&lt;br/&gt;
Date:   2016-07-08T11:50:21Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: close deepIterator during log recovery&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Introduces `kafka.common.ClosableIterator`, which is an iterator that&lt;br/&gt;
    can be closed, and changes the signature of&lt;br/&gt;
    `ByteBufferMessageSet.deepIterator` to return it, then changes the&lt;br/&gt;
    caller `LogSegment` to always close the iterator.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15367625" author="tcrayford-heroku" created="Fri, 8 Jul 2016 12:51:28 +0000"  >&lt;p&gt;Ismael: I&apos;ve pushed the PR here: &lt;a href=&quot;https://github.com/apache/kafka/pull/1598&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1598&lt;/a&gt;. For now, I&apos;ve only fixed the precise memory issue that has been causing us notable production issues. I&apos;m happy picking up other parts of the codebase where this can happen, but would rather get feedback on the first part of the approach for now (this is my first time contributing code to Kafka). I couldn&apos;t see a good or easy way to write any unit tests for this code right now.&lt;/p&gt;</comment>
                            <comment id="15371341" author="easyfmxu" created="Mon, 11 Jul 2016 18:18:38 +0000"  >&lt;p&gt;It also happens with snappy since snappy also uses jni, off heap memory as discussed.&lt;/p&gt;</comment>
                            <comment id="15371428" author="githubbot" created="Mon, 11 Jul 2016 19:08:20 +0000"  >&lt;p&gt;Github user tcrayford closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1598&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1598&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15372882" author="githubbot" created="Tue, 12 Jul 2016 13:33:49 +0000"  >&lt;p&gt;GitHub user tcrayford opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1614&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1614&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: close deepIterator during log recovery&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Introduces `kafka.common.ClosableIterator`, which is an iterator that&lt;br/&gt;
    can be closed, and changes the signature of&lt;br/&gt;
    `ByteBufferMessageSet.deepIterator` to return it, then changes the&lt;br/&gt;
    callers to always close the iterator.&lt;/p&gt;

&lt;p&gt;    This is a followup from &lt;a href=&quot;https://github.com/apache/kafka/pull/1598&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1598&lt;/a&gt; with more native memory leaks in the broker code found and fixed.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/heroku/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/heroku/kafka&lt;/a&gt; dont_leak_native_memory&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1614.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1614.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #1614&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 7fa608371ff8e380350029f3ab1dcffeb0e26c73&lt;br/&gt;
Author: Tom Crayford &amp;lt;tcrayford@googlemail.com&amp;gt;&lt;br/&gt;
Date:   2016-07-08T11:50:21Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: close deepIterator during log recovery&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Introduces `kafka.common.ClosableIterator`, which is an iterator that&lt;br/&gt;
    can be closed, and changes the signature of&lt;br/&gt;
    `ByteBufferMessageSet.deepIterator` to return it, then changes the&lt;br/&gt;
    callers to always close the iterator.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15391894" author="githubbot" created="Mon, 25 Jul 2016 13:36:09 +0000"  >&lt;p&gt;Github user tcrayford closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1614&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1614&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15391896" author="githubbot" created="Mon, 25 Jul 2016 13:36:16 +0000"  >&lt;p&gt;GitHub user tcrayford opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1660&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1660&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: always fully read deepIterator&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Seeeing as `messageFormat &amp;gt; 0` always reads the full compressed message&lt;br/&gt;
    set and is the default going forwards, we can use that behaviour to&lt;br/&gt;
    always close the compressor when calling `deepIterator`&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/heroku/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/heroku/kafka&lt;/a&gt; dont_leak_native_memory_round_2&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1660.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1660.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #1660&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 6ec70c1aa63f3d400d286a9893d0fa175f471d09&lt;br/&gt;
Author: Tom Crayford &amp;lt;tcrayford@googlemail.com&amp;gt;&lt;br/&gt;
Date:   2016-07-25T13:26:52Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: always fully read deepIterator&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Seeeing as `messageFormat &amp;gt; 0` always reads the full compressed message&lt;br/&gt;
    set and is the default going forwards, we can use that behaviour to&lt;br/&gt;
    always close the compressor when calling `deepIterator`&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15392082" author="githubbot" created="Mon, 25 Jul 2016 15:23:15 +0000"  >&lt;p&gt;Github user tcrayford closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1660&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1660&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15392083" author="githubbot" created="Mon, 25 Jul 2016 15:23:16 +0000"  >&lt;p&gt;GitHub user tcrayford reopened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1660&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1660&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: always fully read deepIterator&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Seeeing as `messageFormat &amp;gt; 0` always reads the full compressed message&lt;br/&gt;
    set and is the default going forwards, we can use that behaviour to&lt;br/&gt;
    always close the compressor when calling `deepIterator`&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/heroku/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/heroku/kafka&lt;/a&gt; dont_leak_native_memory_round_2&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1660.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1660.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #1660&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit a1f12a64628365db708c1217cf93e4802f1f03eb&lt;br/&gt;
Author: Tom Crayford &amp;lt;tcrayford@googlemail.com&amp;gt;&lt;br/&gt;
Date:   2016-07-25T13:26:52Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3933&quot; title=&quot;Kafka OOM During Log Recovery Due to Leaked Native Memory&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3933&quot;&gt;&lt;del&gt;KAFKA-3933&lt;/del&gt;&lt;/a&gt;: always fully read deepIterator&lt;/p&gt;

&lt;p&gt;    Avoids leaking native memory and hence crashing brokers on bootup due to&lt;br/&gt;
    running out of memory.&lt;/p&gt;

&lt;p&gt;    Seeeing as `messageFormat &amp;gt; 0` always reads the full compressed message&lt;br/&gt;
    set and is the default going forwards, we can use that behaviour to&lt;br/&gt;
    always close the compressor when calling `deepIterator`&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15393038" author="ijuma" created="Tue, 26 Jul 2016 01:59:29 +0000"  >&lt;p&gt;Issue resolved by pull request 1660&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/kafka/pull/1660&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1660&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15393039" author="githubbot" created="Tue, 26 Jul 2016 01:59:30 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1660&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1660&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 17 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i30ni7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>