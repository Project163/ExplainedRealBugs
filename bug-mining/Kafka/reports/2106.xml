<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:16:19 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-7697] Possible deadlock in kafka.cluster.Partition</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-7697</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;After upgrading a fairly busy broker from 0.10.2.0 to 2.1.0, it locked up within a few minutes (by &quot;locked up&quot; I mean that all request handler threads were busy, and other brokers reported that they couldn&apos;t communicate with it). I restarted it a few times and it did the same thing each time. After downgrading to 0.10.2.0, the broker was stable. I attached a threaddump.txt from the last attempt on 2.1.0 that shows lots of kafka-request-handler- threads trying to acquire the leaderIsrUpdateLock lock in kafka.cluster.Partition.&lt;/p&gt;

&lt;p&gt;It jumps out that there are two threads that already have some read lock (can&apos;t tell which one) and are trying to acquire a second one (on two different read locks: 0x0000000708184b88 and 0x000000070821f188): kafka-request-handler-1 and kafka-request-handler-4. Both are handling a produce request, and in the process of doing so, are calling Partition.fetchOffsetSnapshot while trying to complete a DelayedFetch. At the same time, both of those locks have writers from other threads waiting on them (kafka-request-handler-2 and kafka-scheduler-6). Neither of those locks appear to have writers that hold them (if only because no threads in the dump are deep enough in inWriteLock to indicate that).&lt;/p&gt;

&lt;p&gt;ReentrantReadWriteLock in nonfair mode prioritizes waiting writers over readers. Is it possible that kafka-request-handler-1 and kafka-request-handler-4 are each trying to read-lock the partition that is currently locked by the other one, and they&apos;re both parked waiting for kafka-request-handler-2 and kafka-scheduler-6 to get write locks, which they never will, because the former two threads own read locks and aren&apos;t giving them up?&lt;/p&gt;</description>
                <environment></environment>
        <key id="13202053">KAFKA-7697</key>
            <summary>Possible deadlock in kafka.cluster.Partition</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rsivaram">Rajini Sivaram</assignee>
                                    <reporter username="gian">Gian Merlino</reporter>
                        <labels>
                    </labels>
                <created>Mon, 3 Dec 2018 17:20:02 +0000</created>
                <updated>Fri, 30 Apr 2021 01:40:06 +0000</updated>
                            <resolved>Wed, 5 Dec 2018 12:47:05 +0000</resolved>
                                    <version>2.1.0</version>
                                    <fixVersion>2.1.1</fixVersion>
                    <fixVersion>2.2.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>29</watches>
                                                                                                                <comments>
                            <comment id="16707609" author="ijuma" created="Mon, 3 Dec 2018 18:09:05 +0000"  >&lt;p&gt;Marking as blocker until we understand the details.&lt;/p&gt;</comment>
                            <comment id="16707975" author="rsivaram" created="Mon, 3 Dec 2018 23:33:24 +0000"  >&lt;p&gt;Changes made under &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7395&quot; title=&quot;Add fencing to replication protocol (KIP-320)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7395&quot;&gt;&lt;del&gt;KAFKA-7395&lt;/del&gt;&lt;/a&gt; now protect fetch using the Partition&apos;s &lt;tt&gt;leaderIsrUpdateLock&lt;/tt&gt;. This results in the read lock being acquired while completing a delayed fetch. This is unsafe since delayed operations can be completed while holding onto another Partition lock. For example the thread dump for request-handler-4 shows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;        at sun.misc.Unsafe.park(Native Method)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;parking to wait for  &amp;lt;0x000000070821f188&amp;gt; (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)&lt;br/&gt;
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:967)&lt;br/&gt;
        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1283)&lt;br/&gt;
        at java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:727)&lt;br/&gt;
        at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:249)&lt;br/&gt;
        at kafka.utils.CoreUtils$.inReadLock(CoreUtils.scala:257)&lt;br/&gt;
        at kafka.cluster.Partition.fetchOffsetSnapshot(Partition.scala:832)&lt;br/&gt;
        at kafka.server.DelayedFetch.$anonfun$tryComplete$1(DelayedFetch.scala:87)&lt;br/&gt;
        at kafka.server.DelayedFetch.$anonfun$tryComplete$1$adapted(DelayedFetch.scala:79)&lt;br/&gt;
        at kafka.server.DelayedFetch$$Lambda$912/582152661.apply(Unknown Source)&lt;br/&gt;
        at scala.collection.mutable.ResizableArray.foreach(ResizableArray.scala:58)&lt;br/&gt;
        at scala.collection.mutable.ResizableArray.foreach$(ResizableArray.scala:51)&lt;br/&gt;
        at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:47)&lt;br/&gt;
        at kafka.server.DelayedFetch.tryComplete(DelayedFetch.scala:79)&lt;br/&gt;
        at kafka.server.DelayedOperation.maybeTryComplete(DelayedOperation.scala:121)&lt;br/&gt;
        at kafka.server.DelayedOperationPurgatory$Watchers.tryCompleteWatched(DelayedOperation.scala:371)&lt;br/&gt;
        at kafka.server.DelayedOperationPurgatory.checkAndComplete(DelayedOperation.scala:277)&lt;br/&gt;
        at kafka.server.ReplicaManager.tryCompleteDelayedFetch(ReplicaManager.scala:307)&lt;br/&gt;
        at kafka.cluster.Partition.$anonfun$appendRecordsToLeader$1(Partition.scala:743)&lt;br/&gt;
        at kafka.cluster.Partition$$Lambda$917/80048373.apply(Unknown Source)&lt;br/&gt;
        at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:251)&lt;br/&gt;
        at kafka.utils.CoreUtils$.inReadLock(CoreUtils.scala:257)&lt;br/&gt;
        at kafka.cluster.Partition.appendRecordsToLeader(Partition.scala:729)&lt;br/&gt;
        at kafka.server.ReplicaManager.$anonfun$appendToLocalLog$2(ReplicaManager.scala:735)&lt;br/&gt;
        at kafka.server.ReplicaManager$$Lambda$915/220982367.apply(Unknown Source)&lt;br/&gt;
        at scala.collection.TraversableLike.$anonfun$map$1(TraversableLike.scala:233)&lt;br/&gt;
        at scala.collection.TraversableLike$$Lambda$12/1209669119.apply(Unknown Source)&lt;br/&gt;
        at scala.collection.mutable.HashMap.$anonfun$foreach$1(HashMap.scala:145)&lt;br/&gt;
        at scala.collection.mutable.HashMap$$Lambda$24/477289012.apply(Unknown Source)&lt;br/&gt;
        at scala.collection.mutable.HashTable.foreachEntry(HashTable.scala:235)&lt;br/&gt;
        at scala.collection.mutable.HashTable.foreachEntry$(HashTable.scala:228)&lt;br/&gt;
        at scala.collection.mutable.HashMap.foreachEntry(HashMap.scala:40)&lt;br/&gt;
        at scala.collection.mutable.HashMap.foreach(HashMap.scala:145)&lt;br/&gt;
        at scala.collection.TraversableLike.map(TraversableLike.scala:233)&lt;br/&gt;
        at scala.collection.TraversableLike.map$(TraversableLike.scala:226)&lt;br/&gt;
        at scala.collection.AbstractTraversable.map(Traversable.scala:104)&lt;br/&gt;
        at kafka.server.ReplicaManager.appendToLocalLog(ReplicaManager.scala:723)&lt;br/&gt;
        at kafka.server.ReplicaManager.appendRecords(ReplicaManager.scala:470)&lt;br/&gt;
        at kafka.server.KafkaApis.handleProduceRequest(KafkaApis.scala:482)&lt;br/&gt;
        at kafka.server.KafkaApis.handle(KafkaApis.scala:106)&lt;br/&gt;
        at kafka.server.KafkaRequestHandler.run(KafkaRequestHandler.scala:69)&lt;br/&gt;
        at java.lang.Thread.run(Thread.java:748)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;A whole bunch of threads including all request handler threads seem to be deadlocked as a result of &lt;tt&gt;leaderIsrUpdateLock&lt;/tt&gt; of two partitions that are blocked while completing delayed fetch as a result of waiting writers.&lt;/p&gt;

&lt;p&gt;For purgatory operations that acquire a lock, we use that lock as the delayed operation lock, but that is not an option here since fetch could contain multiple partitions. So we need some other way to avoid blocking for a Partition lock while holding onto another Partition lock.&lt;/p&gt;</comment>
                            <comment id="16708006" author="githubbot" created="Tue, 4 Dec 2018 00:15:53 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #5997: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7697&quot; title=&quot;Possible deadlock in kafka.cluster.Partition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7697&quot;&gt;&lt;del&gt;KAFKA-7697&lt;/del&gt;&lt;/a&gt;: Avoid blocking for leaderIsrUpdateLock in DelayedFetch&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5997&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5997&lt;/a&gt;&lt;/p&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16708017" author="githubbot" created="Tue, 4 Dec 2018 00:36:55 +0000"  >&lt;p&gt;rajinisivaram closed pull request #5997: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7697&quot; title=&quot;Possible deadlock in kafka.cluster.Partition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7697&quot;&gt;&lt;del&gt;KAFKA-7697&lt;/del&gt;&lt;/a&gt;: Avoid blocking for leaderIsrUpdateLock in DelayedFetch&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5997&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5997&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/core/src/main/scala/kafka/cluster/Partition.scala b/core/src/main/scala/kafka/cluster/Partition.scala&lt;br/&gt;
index 745c89a393b..a5655c77e2d 100755&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/cluster/Partition.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/cluster/Partition.scala&lt;br/&gt;
@@ -836,6 +836,20 @@ class Partition(val topicPartition: TopicPartition,&lt;br/&gt;
     localReplica.offsetSnapshot&lt;br/&gt;
   }&lt;/p&gt;

&lt;p&gt;+  def maybeFetchOffsetSnapshot(currentLeaderEpoch: Optional&lt;span class=&quot;error&quot;&gt;&amp;#91;Integer&amp;#93;&lt;/span&gt;,&lt;br/&gt;
+                          fetchOnlyFromLeader: Boolean): Option&lt;span class=&quot;error&quot;&gt;&amp;#91;LogOffsetSnapshot&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
+    if (leaderIsrUpdateLock.readLock().tryLock()) {&lt;br/&gt;
+      try &lt;/p&gt;
{
+        // decide whether to only fetch from leader
+        val localReplica = localReplicaWithEpochOrException(currentLeaderEpoch, fetchOnlyFromLeader)
+        Some(localReplica.offsetSnapshot)
+      }
&lt;p&gt; finally &lt;/p&gt;
{
+        leaderIsrUpdateLock.readLock().unlock()
+      }
&lt;p&gt;+    } else&lt;br/&gt;
+      None&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
   def fetchOffsetSnapshotOrError(currentLeaderEpoch: Optional&lt;span class=&quot;error&quot;&gt;&amp;#91;Integer&amp;#93;&lt;/span&gt;,&lt;br/&gt;
                                  fetchOnlyFromLeader: Boolean): Either&lt;span class=&quot;error&quot;&gt;&amp;#91;LogOffsetSnapshot, Errors&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
     inReadLock(leaderIsrUpdateLock) {&lt;br/&gt;
diff --git a/core/src/main/scala/kafka/server/DelayedFetch.scala b/core/src/main/scala/kafka/server/DelayedFetch.scala&lt;br/&gt;
index 90200991759..d6504e64de9 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/server/DelayedFetch.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/server/DelayedFetch.scala&lt;br/&gt;
@@ -84,34 +84,35 @@ class DelayedFetch(delayMs: Long,&lt;br/&gt;
           if (fetchOffset != LogOffsetMetadata.UnknownOffsetMetadata) {&lt;br/&gt;
             val partition = replicaManager.getPartitionOrException(topicPartition,&lt;br/&gt;
               expectLeader = fetchMetadata.fetchOnlyLeader)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val offsetSnapshot = partition.fetchOffsetSnapshot(fetchLeaderEpoch, fetchMetadata.fetchOnlyLeader)&lt;br/&gt;
+            partition.maybeFetchOffsetSnapshot(fetchLeaderEpoch, fetchMetadata.fetchOnlyLeader).foreach { offsetSnapshot =&amp;gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val endOffset = fetchMetadata.fetchIsolation match 
{
-              case FetchLogEnd =&amp;gt; offsetSnapshot.logEndOffset
-              case FetchHighWatermark =&amp;gt; offsetSnapshot.highWatermark
-              case FetchTxnCommitted =&amp;gt; offsetSnapshot.lastStableOffset
-            }
&lt;p&gt;+              val endOffset = fetchMetadata.fetchIsolation match &lt;/p&gt;
{
+                case FetchLogEnd =&amp;gt; offsetSnapshot.logEndOffset
+                case FetchHighWatermark =&amp;gt; offsetSnapshot.highWatermark
+                case FetchTxnCommitted =&amp;gt; offsetSnapshot.lastStableOffset
+              }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Go directly to the check for Case D if the message offsets are the same. If the log segment&lt;/li&gt;
	&lt;li&gt;// has just rolled, then the high watermark offset will remain the same but be on the old segment,&lt;/li&gt;
	&lt;li&gt;// which would incorrectly be seen as an instance of Case C.&lt;/li&gt;
	&lt;li&gt;if (endOffset.messageOffset != fetchOffset.messageOffset) {&lt;/li&gt;
	&lt;li&gt;if (endOffset.onOlderSegment(fetchOffset)) 
{
-                // Case C, this can happen when the new fetch operation is on a truncated leader
-                debug(s&quot;Satisfying fetch $fetchMetadata since it is fetching later segments of partition $topicPartition.&quot;)
-                return forceComplete()
-              }
&lt;p&gt; else if (fetchOffset.onOlderSegment(endOffset)) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Case C, this can happen when the fetch operation is falling behind the current segment&lt;/li&gt;
	&lt;li&gt;// or the partition has just rolled a new segment&lt;/li&gt;
	&lt;li&gt;debug(s&quot;Satisfying fetch $fetchMetadata immediately since it is fetching older segments.&quot;)&lt;/li&gt;
	&lt;li&gt;// We will not force complete the fetch request if a replica should be throttled.&lt;/li&gt;
	&lt;li&gt;if (!replicaManager.shouldLeaderThrottle(quota, topicPartition, fetchMetadata.replicaId))&lt;br/&gt;
+              // Go directly to the check for Case D if the message offsets are the same. If the log segment&lt;br/&gt;
+              // has just rolled, then the high watermark offset will remain the same but be on the old segment,&lt;br/&gt;
+              // which would incorrectly be seen as an instance of Case C.&lt;br/&gt;
+              if (endOffset.messageOffset != fetchOffset.messageOffset) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+                if (endOffset.onOlderSegment(fetchOffset)) {
+                  // Case C, this can happen when the new fetch operation is on a truncated leader
+                  debug(s&quot;Satisfying fetch $fetchMetadata since it is fetching later segments of partition $topicPartition.&quot;)
                   return forceComplete()
-              } else if (fetchOffset.messageOffset &amp;lt; endOffset.messageOffset) {
-                // we take the partition fetch size as upper bound when accumulating the bytes (skip if a throttled partition)
-                val bytesAvailable = math.min(endOffset.positionDiff(fetchOffset), fetchStatus.fetchInfo.maxBytes)
-                if (!replicaManager.shouldLeaderThrottle(quota, topicPartition, fetchMetadata.replicaId))
-                  accumulatedSize += bytesAvailable
+                } else if (fetchOffset.onOlderSegment(endOffset)) {
+                  // Case C, this can happen when the fetch operation is falling behind the current segment
+                  // or the partition has just rolled a new segment
+                  debug(s&quot;Satisfying fetch $fetchMetadata immediately since it is fetching older segments.&quot;)
+                  // We will not force complete the fetch request if a replica should be throttled.
+                  if (!replicaManager.shouldLeaderThrottle(quota, topicPartition, fetchMetadata.replicaId))
+                    return forceComplete()
+                } else if (fetchOffset.messageOffset &amp;lt; endOffset.messageOffset) {
+                  // we take the partition fetch size as upper bound when accumulating the bytes (skip if a throttled partition)
+                  val bytesAvailable = math.min(endOffset.positionDiff(fetchOffset), fetchStatus.fetchInfo.maxBytes)
+                  if (!replicaManager.shouldLeaderThrottle(quota, topicPartition, fetchMetadata.replicaId))
+                    accumulatedSize += bytesAvailable
+                }               }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;             }&lt;br/&gt;
           }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16708719" author="githubbot" created="Tue, 4 Dec 2018 13:46:43 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #5999: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7697&quot; title=&quot;Possible deadlock in kafka.cluster.Partition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7697&quot;&gt;&lt;del&gt;KAFKA-7697&lt;/del&gt;&lt;/a&gt;: Process DelayedFetch without holding leaderIsrUpdateLock&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5999&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5999&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Delayed fetch operations acquire leaderIsrUpdate read lock of one or more Partitions from the fetch request when attempting to complete the fetch operation. When attempting to complete delayed fetch after appending new records, completion should be attempted only after releasing the leaderIsrUpdate of the Partition to which records were appended. Otherwise, waiting writers (e.g. to check if ISR needs to be shrinked) can cause deadlocks in request handler threads when trying to acquire lock of a different partition while holding on to lock of one partition.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16709777" author="githubbot" created="Wed, 5 Dec 2018 09:05:29 +0000"  >&lt;p&gt;rajinisivaram closed pull request #5999: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7697&quot; title=&quot;Possible deadlock in kafka.cluster.Partition&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7697&quot;&gt;&lt;del&gt;KAFKA-7697&lt;/del&gt;&lt;/a&gt;: Process DelayedFetch without holding leaderIsrUpdateLock&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5999&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5999&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/core/src/main/scala/kafka/cluster/Partition.scala b/core/src/main/scala/kafka/cluster/Partition.scala&lt;br/&gt;
index 745c89a393b..1f52bd769cf 100755&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/cluster/Partition.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/cluster/Partition.scala&lt;br/&gt;
@@ -740,8 +740,6 @@ class Partition(val topicPartition: TopicPartition,&lt;br/&gt;
           }&lt;/p&gt;

&lt;p&gt;           val info = log.appendAsLeader(records, leaderEpoch = this.leaderEpoch, isFromClient)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// probably unblock some follower fetch requests since log end offset has been updated&lt;/li&gt;
	&lt;li&gt;replicaManager.tryCompleteDelayedFetch(TopicPartitionOperationKey(this.topic, this.partitionId))&lt;br/&gt;
           // we may need to increment high watermark since ISR could be down to 1&lt;br/&gt;
           (info, maybeIncrementLeaderHW(leaderReplica))&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -754,6 +752,10 @@ class Partition(val topicPartition: TopicPartition,&lt;br/&gt;
     // some delayed operations may be unblocked after HW changed&lt;br/&gt;
     if (leaderHWIncremented)&lt;br/&gt;
       tryCompleteDelayedRequests()&lt;br/&gt;
+    else &lt;/p&gt;
{
+      // probably unblock some follower fetch requests since log end offset has been updated
+      replicaManager.tryCompleteDelayedFetch(new TopicPartitionOperationKey(topicPartition))
+    }

&lt;p&gt;     info&lt;br/&gt;
   }&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/cluster/PartitionTest.scala b/core/src/test/scala/unit/kafka/cluster/PartitionTest.scala&lt;br/&gt;
index 6e38ca9575b..cfaa147f407 100644&lt;br/&gt;
&amp;#8212; a/core/src/test/scala/unit/kafka/cluster/PartitionTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/cluster/PartitionTest.scala&lt;br/&gt;
@@ -19,14 +19,14 @@ package kafka.cluster&lt;br/&gt;
 import java.io.File&lt;br/&gt;
 import java.nio.ByteBuffer&lt;br/&gt;
 import java.util.&lt;/p&gt;
{Optional, Properties}
&lt;p&gt;-import java.util.concurrent.CountDownLatch&lt;br/&gt;
+import java.util.concurrent.&lt;/p&gt;
{CountDownLatch, Executors, TimeUnit, TimeoutException}
&lt;p&gt; import java.util.concurrent.atomic.AtomicBoolean&lt;/p&gt;

&lt;p&gt; import kafka.api.Request&lt;br/&gt;
 import kafka.common.UnexpectedAppendOffsetException&lt;br/&gt;
 import kafka.log.&lt;/p&gt;
{Defaults =&amp;gt; _, _}
&lt;p&gt; import kafka.server._&lt;br/&gt;
-import kafka.utils.&lt;/p&gt;
{MockScheduler, MockTime, TestUtils}
&lt;p&gt;+import kafka.utils.&lt;/p&gt;
{CoreUtils, MockScheduler, MockTime, TestUtils}
&lt;p&gt; import kafka.zk.KafkaZkClient&lt;br/&gt;
 import org.apache.kafka.common.TopicPartition&lt;br/&gt;
 import org.apache.kafka.common.errors.ReplicaNotAvailableException&lt;br/&gt;
@@ -39,7 +39,7 @@ import org.apache.kafka.common.requests.{IsolationLevel, LeaderAndIsrRequest, Li&lt;br/&gt;
 import org.junit.&lt;/p&gt;
{After, Before, Test}
&lt;p&gt; import org.junit.Assert._&lt;br/&gt;
 import org.scalatest.Assertions.assertThrows&lt;br/&gt;
-import org.easymock.EasyMock&lt;br/&gt;
+import org.easymock.&lt;/p&gt;
{Capture, EasyMock, IAnswer}

&lt;p&gt; import scala.collection.JavaConverters._&lt;/p&gt;

&lt;p&gt;@@ -671,7 +671,95 @@ class PartitionTest &lt;/p&gt;
{
     partition.updateReplicaLogReadResult(follower1Replica,
                                          readResult(FetchDataInfo(LogOffsetMetadata(currentLeaderEpochStartOffset), batch3), leaderReplica))
     assertEquals(&quot;ISR&quot;, Set[Integer](leader, follower1, follower2), partition.inSyncReplicas.map(_.brokerId))
- }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+   * Verify that delayed fetch operations which are completed when records are appended don&apos;t result in deadlocks.&lt;br/&gt;
+   * Delayed fetch operations acquire Partition leaderIsrUpdate read lock for one or more partitions. So they&lt;br/&gt;
+   * need to be completed after releasing the lock acquired to append records. Otherwise, waiting writers&lt;br/&gt;
+   * (e.g. to check if ISR needs to be shrinked) can trigger deadlock in request handler threads waiting for&lt;br/&gt;
+   * read lock of one Partition while holding on to read lock of another Partition.&lt;br/&gt;
+   */&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testDelayedFetchAfterAppendRecords(): Unit = {&lt;br/&gt;
+    val replicaManager: ReplicaManager = EasyMock.mock(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;ReplicaManager&amp;#93;&lt;/span&gt;)&lt;br/&gt;
+    val zkClient: KafkaZkClient = EasyMock.mock(classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;KafkaZkClient&amp;#93;&lt;/span&gt;)&lt;br/&gt;
+    val controllerId = 0&lt;br/&gt;
+    val controllerEpoch = 0&lt;br/&gt;
+    val leaderEpoch = 5&lt;br/&gt;
+    val replicaIds = List&lt;span class=&quot;error&quot;&gt;&amp;#91;Integer&amp;#93;&lt;/span&gt;(brokerId, brokerId + 1).asJava&lt;br/&gt;
+    val isr = replicaIds&lt;br/&gt;
+    val logConfig = LogConfig(new Properties)&lt;br/&gt;
+&lt;br/&gt;
+    val topicPartitions = (0 until 5).map &lt;/p&gt;
{ i =&amp;gt; new TopicPartition(&quot;test-topic&quot;, i) }
&lt;p&gt;+    val logs = topicPartitions.map &lt;/p&gt;
{ tp =&amp;gt; logManager.getOrCreateLog(tp, logConfig) }
&lt;p&gt;+    val replicas = logs.map &lt;/p&gt;
{ log =&amp;gt; new Replica(brokerId, log.topicPartition, time, log = Some(log)) }
&lt;p&gt;+    val partitions = replicas.map &lt;/p&gt;
{ replica =&amp;gt;
+      val tp = replica.topicPartition
+      val partition = new Partition(tp,
+        isOffline = false,
+        replicaLagTimeMaxMs = Defaults.ReplicaLagTimeMaxMs,
+        localBrokerId = brokerId,
+        time,
+        replicaManager,
+        logManager,
+        zkClient)
+      partition.addReplicaIfNotExists(replica)
+      partition.makeLeader(controllerId, new LeaderAndIsrRequest.PartitionState(controllerEpoch, brokerId,
+        leaderEpoch, isr, 1, replicaIds, true), 0)
+      partition
+    }
&lt;p&gt;+&lt;br/&gt;
+    // Acquire leaderIsrUpdate read lock of a different partition when completing delayed fetch&lt;br/&gt;
+    val tpKey: Capture&lt;span class=&quot;error&quot;&gt;&amp;#91;TopicPartitionOperationKey&amp;#93;&lt;/span&gt; = EasyMock.newCapture()&lt;br/&gt;
+    EasyMock.expect(replicaManager.tryCompleteDelayedFetch(EasyMock.capture(tpKey)))&lt;br/&gt;
+      .andAnswer(new IAnswer&lt;span class=&quot;error&quot;&gt;&amp;#91;Unit&amp;#93;&lt;/span&gt; {&lt;br/&gt;
+        override def answer(): Unit = &lt;/p&gt;
{
+          val anotherPartition = (tpKey.getValue.partition + 1) % topicPartitions.size
+          val partition = partitions(anotherPartition)
+          partition.fetchOffsetSnapshot(Optional.of(leaderEpoch), fetchOnlyFromLeader = true)
+        }
&lt;p&gt;+      }).anyTimes()&lt;br/&gt;
+    EasyMock.replay(replicaManager, zkClient)&lt;br/&gt;
+&lt;br/&gt;
+    def createRecords(baseOffset: Long): MemoryRecords = &lt;/p&gt;
{
+      val records = List(
+        new SimpleRecord(&quot;k1&quot;.getBytes, &quot;v1&quot;.getBytes),
+        new SimpleRecord(&quot;k2&quot;.getBytes, &quot;v2&quot;.getBytes))
+      val buf = ByteBuffer.allocate(DefaultRecordBatch.sizeInBytes(records.asJava))
+      val builder = MemoryRecords.builder(
+        buf, RecordBatch.CURRENT_MAGIC_VALUE, CompressionType.NONE, TimestampType.CREATE_TIME,
+        baseOffset, time.milliseconds, 0)
+      records.foreach(builder.append)
+      builder.build()
+    }
&lt;p&gt;+&lt;br/&gt;
+    val done = new AtomicBoolean()&lt;br/&gt;
+    val executor = Executors.newFixedThreadPool(topicPartitions.size + 1)&lt;br/&gt;
+    try {&lt;br/&gt;
+      // Invoke some operation that acquires leaderIsrUpdate write lock on one thread&lt;br/&gt;
+      executor.submit(CoreUtils.runnable {&lt;br/&gt;
+        while (!done.get) &lt;/p&gt;
{
+          partitions.foreach(_.maybeShrinkIsr(10000))
+        }
&lt;p&gt;+      })&lt;br/&gt;
+      // Append records to partitions, one partition-per-thread&lt;br/&gt;
+      val futures = partitions.map { partition =&amp;gt;&lt;br/&gt;
+        executor.submit(CoreUtils.runnable {&lt;br/&gt;
+          (1 to 10000).foreach &lt;/p&gt;
{ _ =&amp;gt; partition.appendRecordsToLeader(createRecords(baseOffset = 0), isFromClient = true) }
&lt;p&gt;+        })&lt;br/&gt;
+      }&lt;br/&gt;
+      futures.foreach(_.get(10, TimeUnit.SECONDS))&lt;br/&gt;
+      done.set(true)&lt;br/&gt;
+    } catch &lt;/p&gt;
{
+      case e: TimeoutException =&amp;gt;
+        val allThreads = TestUtils.allThreadStackTraces()
+        fail(s&quot;Test timed out with exception $e, thread stack traces: $allThreads&quot;)
+    }
&lt;p&gt; finally &lt;/p&gt;
{
+      executor.shutdownNow()
+      executor.awaitTermination(5, TimeUnit.SECONDS)
+    }
&lt;p&gt;+  }&lt;/p&gt;

&lt;p&gt;   def createRecords(records: Iterable&lt;span class=&quot;error&quot;&gt;&amp;#91;SimpleRecord&amp;#93;&lt;/span&gt;, baseOffset: Long, partitionLeaderEpoch: Int = 0): MemoryRecords = {&lt;br/&gt;
     val buf = ByteBuffer.allocate(DefaultRecordBatch.sizeInBytes(records.asJava))&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/utils/TestUtils.scala b/core/src/test/scala/unit/kafka/utils/TestUtils.scala&lt;br/&gt;
index bcb05816353..e5ea6a4baae 100755&lt;br/&gt;
&amp;#8212; a/core/src/test/scala/unit/kafka/utils/TestUtils.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/utils/TestUtils.scala&lt;br/&gt;
@@ -958,6 +958,12 @@ object TestUtils extends Logging &lt;/p&gt;
{
     assertEquals(0, threadCount)
   }

&lt;p&gt;+  def allThreadStackTraces(): String = {&lt;br/&gt;
+    Thread.getAllStackTraces.asScala.map &lt;/p&gt;
{ case (thread, stackTrace) =&amp;gt;
+      thread.getName + &quot;\n\t&quot; + stackTrace.toList.map(_.toString).mkString(&quot;\n\t&quot;)
+    }
&lt;p&gt;.mkString(&quot;\n&quot;)&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Create new LogManager instance with default configuration for testing&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16741842" author="candicewan" created="Mon, 14 Jan 2019 08:15:40 +0000"  >&lt;p&gt;when 2.1.1 is expected to be released?&lt;/p&gt;</comment>
                            <comment id="16755438" author="jnadler" created="Tue, 29 Jan 2019 22:27:10 +0000"  >&lt;p&gt;Hi all!&#160; &#160;We just had this bug hit a second cluster - deadlocked node with fast growing FD consumption.&#160; &#160; Any chance we can get a release quickly that contains this fix?&#160; &#160;&lt;/p&gt;</comment>
                            <comment id="16755874" author="mah82" created="Wed, 30 Jan 2019 09:00:05 +0000"  >&lt;p&gt;Same here. After upgrading from v2.0.0 to v2.1.0 we also hit this bug.&lt;/p&gt;</comment>
                            <comment id="16756129" author="rsivaram" created="Wed, 30 Jan 2019 13:52:24 +0000"  >&lt;p&gt;Apache Kafka 2.1.1 containing the fix is currently going through the release process and RC1 is available for testing and voting - see &lt;a href=&quot;http://mail-archives.apache.org/mod_mbox/kafka-users/201901.mbox/%3C67fc2ed5-0cc3-4fc6-8e14-ba562f6e4c56@www.fastmail.com%3E&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://mail-archives.apache.org/mod_mbox/kafka-users/201901.mbox/%3C67fc2ed5-0cc3-4fc6-8e14-ba562f6e4c56@www.fastmail.com%3E&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16760906" author="amoratti" created="Tue, 5 Feb 2019 15:00:50 +0000"  >&lt;p&gt;Also hit this bug after upgrading from 2.0.0 to 2.1.0.&lt;/p&gt;</comment>
                            <comment id="16792529" author="shaharmor" created="Thu, 14 Mar 2019 10:30:57 +0000"  >&lt;p&gt;Is there anything that can be done as a workaround for this issue in the mean time? Any configuration that can be changed?&lt;/p&gt;

&lt;p&gt;WIll a restart of all Kafka brokers help?&lt;/p&gt;</comment>
                            <comment id="16792537" author="rsivaram" created="Thu, 14 Mar 2019 10:42:48 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=shaharmor&quot; class=&quot;user-hover&quot; rel=&quot;shaharmor&quot;&gt;shaharmor&lt;/a&gt; Apache Kafka 2.1.1 containing the fix has been released. So an upgrade is recommended. With 2.1.0, you will need to restart affected brokers whenever they run into the issue.&lt;/p&gt;</comment>
                            <comment id="16792705" author="jnadler" created="Thu, 14 Mar 2019 14:22:32 +0000"  >&lt;p&gt;2.1.1 has other issues.&#160; &#160;I&apos;d recommend proceeding with caution.&#160; &#160;Had to downgrade all of our clusters back to 2.0.1 to get stable.&lt;/p&gt;</comment>
                            <comment id="16792723" author="ijuma" created="Thu, 14 Mar 2019 14:40:55 +0000"  >&lt;p&gt;What issues &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jnadler&quot; class=&quot;user-hover&quot; rel=&quot;jnadler&quot;&gt;jnadler&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="16793469" author="ankit.jhil" created="Fri, 15 Mar 2019 09:09:11 +0000"  >&lt;p&gt;We also hit the same issue. Had to restart the broker after almost every 6 hours!&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jnadler&quot; class=&quot;user-hover&quot; rel=&quot;jnadler&quot;&gt;jnadler&lt;/a&gt; what is the issue with 2.1.1 ? We are planning to move to this version..&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt; Shall we move to 2.0.1 since 2.1.1 is just released and we might hit other issues? 2.0.1 seems pretty stable!&lt;/p&gt;</comment>
                            <comment id="16808327" author="little brother ma" created="Wed, 3 Apr 2019 03:48:48 +0000"  >&lt;p&gt;we also hit the same issue with 2.1.1 !&lt;/p&gt;

&lt;p&gt;Get the metric &quot;kafka.network:type=RequestChannel,name=RequestQueueSize&quot; value is always 1000, and we config queued.max.requests=1000&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;kafka-network-thread-5-ListenerName(PLAINTEXT)-PLAINTEXT-4&quot; #97 prio=5 os_prio=0 tid=0x00007fb7ce0ba800 nid=0x2d5 waiting on condition &lt;span class=&quot;error&quot;&gt;&amp;#91;0x00007fad6e5f8000&amp;#93;&lt;/span&gt;&lt;br/&gt;
 java.lang.Thread.State: WAITING (parking)&lt;br/&gt;
 at sun.misc.Unsafe.park(Native Method)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;parking to wait for &amp;lt;0x00000004530783a0&amp;gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)&lt;br/&gt;
 at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)&lt;br/&gt;
 at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)&lt;br/&gt;
 at java.util.concurrent.ArrayBlockingQueue.put(ArrayBlockingQueue.java:353)&lt;br/&gt;
 at kafka.network.RequestChannel.sendRequest(RequestChannel.scala:310)&lt;br/&gt;
 at kafka.network.Processor.$anonfun$processCompletedReceives$1(SocketServer.scala:709)&lt;br/&gt;
 at kafka.network.Processor.$anonfun$processCompletedReceives$1$adapted(SocketServer.scala:699)&lt;br/&gt;
 at kafka.network.Processor$$Lambda$877/855310793.apply(Unknown Source)&lt;br/&gt;
 at scala.collection.Iterator.foreach(Iterator.scala:937)&lt;br/&gt;
 at scala.collection.Iterator.foreach$(Iterator.scala:937)&lt;br/&gt;
 at scala.collection.AbstractIterator.foreach(Iterator.scala:1425)&lt;br/&gt;
 at scala.collection.IterableLike.foreach(IterableLike.scala:70)&lt;br/&gt;
 at scala.collection.IterableLike.foreach$(IterableLike.scala:69)&lt;br/&gt;
 at scala.collection.AbstractIterable.foreach(Iterable.scala:54)&lt;br/&gt;
 at kafka.network.Processor.processCompletedReceives(SocketServer.scala:699)&lt;br/&gt;
 at kafka.network.Processor.run(SocketServer.scala:595)&lt;br/&gt;
 at java.lang.Thread.run(Thread.java:748)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Locked ownable synchronizers:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;None&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&quot;kafka-request-handler-15&quot; #87 daemon prio=5 os_prio=0 tid=0x00007fb7ceee6800 nid=0x2cb waiting on condition &lt;span class=&quot;error&quot;&gt;&amp;#91;0x00007fad71af4000&amp;#93;&lt;/span&gt;&lt;br/&gt;
 java.lang.Thread.State: WAITING (parking)&lt;br/&gt;
 at sun.misc.Unsafe.park(Native Method)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;parking to wait for &amp;lt;0x00000004540423f0&amp;gt; (a java.util.concurrent.locks.ReentrantReadWriteLock$NonfairSync)&lt;br/&gt;
 at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)&lt;br/&gt;
 at java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt(AbstractQueuedSynchronizer.java:836)&lt;br/&gt;
 at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared(AbstractQueuedSynchronizer.java:967)&lt;br/&gt;
 at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared(AbstractQueuedSynchronizer.java:1283)&lt;br/&gt;
 at java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock.lock(ReentrantReadWriteLock.java:727)&lt;br/&gt;
 at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:249)&lt;br/&gt;
 at kafka.utils.CoreUtils$.inReadLock(CoreUtils.scala:257)&lt;br/&gt;
 at kafka.cluster.Partition.appendRecordsToLeader(Partition.scala:729)&lt;br/&gt;
 at kafka.server.ReplicaManager.$anonfun$appendToLocalLog$2(ReplicaManager.scala:735)&lt;br/&gt;
 at kafka.server.ReplicaManager$$Lambda$1567/915411568.apply(Unknown Source)&lt;br/&gt;
 at scala.collection.TraversableLike.$anonfun$map$1(TraversableLike.scala:233)&lt;br/&gt;
 at scala.collection.TraversableLike$$Lambda$12/811760110.apply(Unknown Source)&lt;br/&gt;
 at scala.collection.immutable.Map$Map1.foreach(Map.scala:125)&lt;br/&gt;
 at scala.collection.TraversableLike.map(TraversableLike.scala:233)&lt;br/&gt;
 at scala.collection.TraversableLike.map$(TraversableLike.scala:226)&lt;br/&gt;
 at scala.collection.AbstractTraversable.map(Traversable.scala:104)&lt;br/&gt;
 at kafka.server.ReplicaManager.appendToLocalLog(ReplicaManager.scala:723)&lt;br/&gt;
 at kafka.server.ReplicaManager.appendRecords(ReplicaManager.scala:470)&lt;br/&gt;
 at kafka.coordinator.group.GroupMetadataManager.appendForGroup(GroupMetadataManager.scala:280)&lt;br/&gt;
 at kafka.coordinator.group.GroupMetadataManager.storeOffsets(GroupMetadataManager.scala:423)&lt;br/&gt;
 at kafka.coordinator.group.GroupCoordinator.$anonfun$doCommitOffsets$1(GroupCoordinator.scala:518)&lt;br/&gt;
 at kafka.coordinator.group.GroupCoordinator$$Lambda$1816/513285617.apply$mcV$sp(Unknown Source)&lt;br/&gt;
 at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)&lt;br/&gt;
 at kafka.utils.CoreUtils$.inLock(CoreUtils.scala:251)&lt;br/&gt;
 at kafka.coordinator.group.GroupMetadata.inLock(GroupMetadata.scala:197)&lt;br/&gt;
 at kafka.coordinator.group.GroupCoordinator.doCommitOffsets(GroupCoordinator.scala:503)&lt;br/&gt;
 at kafka.coordinator.group.GroupCoordinator.handleCommitOffsets(GroupCoordinator.scala:482)&lt;br/&gt;
 at kafka.server.KafkaApis.handleOffsetCommitRequest(KafkaApis.scala:365)&lt;br/&gt;
 at kafka.server.KafkaApis.handle(KafkaApis.scala:114)&lt;br/&gt;
 at kafka.server.KafkaRequestHandler.run(KafkaRequestHandler.scala:69)&lt;br/&gt;
 at java.lang.Thread.run(Thread.java:748)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Locked ownable synchronizers:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&amp;lt;0x0000000794ea4248&amp;gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)&#160; &#160;&#160;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;The thread dumps of a broker:&#160;&lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12967843/12967843_kafka_jstack.txt&quot; title=&quot;kafka_jstack.txt attached to KAFKA-7697&quot;&gt;kafka_jstack.txt&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="16826694" author="boge" created="Fri, 26 Apr 2019 06:33:23 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=little+brother+ma&quot; class=&quot;user-hover&quot; rel=&quot;little brother ma&quot;&gt;little brother ma&lt;/a&gt;&#160; wo also&#160;hit the same issue with 2.1.1 .I checked the source code for version 2.1.1 and found that partition. Scala did not incorporate the changes&lt;/p&gt;</comment>
                            <comment id="16827784" author="yanrui" created="Sun, 28 Apr 2019 01:33:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt; We also encountered the same problem&#65292;and controller-event-thread looks like deadlock.&lt;br/&gt;
Newly created topic which isr and leader is none&#65292;the topicChangeListener can not work&lt;/p&gt;</comment>
                            <comment id="16830251" author="rsivaram" created="Tue, 30 Apr 2019 12:43:07 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=little+brother+ma&quot; class=&quot;user-hover&quot; rel=&quot;little brother ma&quot;&gt;little brother ma&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=boge&quot; class=&quot;user-hover&quot; rel=&quot;boge&quot;&gt;boge&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=yanrui&quot; class=&quot;user-hover&quot; rel=&quot;yanrui&quot;&gt;yanrui&lt;/a&gt; Can you provide full thread dumps of a broker that encountered this issue with 2.1.1? Thank you!&lt;/p&gt;</comment>
                            <comment id="16831713" author="jwesteen" created="Thu, 2 May 2019 15:54:33 +0000"  >&lt;p&gt;Currently experiencing this on Kafka 2.1.0, happen to have a thread dump handy if it&apos;s useful! We&apos;re noticing&#160;it&#160;occur seemingly randomly, however partition reassignment and heavy produce bursts seem to exacerbate this issue. kill -9&#160;has been the only solution for us thus far, tons of open file descriptors start to accumulate.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12967665/12967665_kafka.log&quot; title=&quot;kafka.log attached to KAFKA-7697&quot;&gt;kafka.log&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="16831714" author="nsnmurthy" created="Thu, 2 May 2019 15:54:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt;&#160; We also encountered the same issue with 2.1.0 in our production stack.&lt;/p&gt;

&lt;p&gt;Below is the sample stack trace. If we want to up grade/down grade Kafka in our setup, which version we can go.&lt;/p&gt;

&lt;p&gt;kafka-request-handler-3 tid=53 &lt;span class=&quot;error&quot;&gt;&amp;#91;WAITING&amp;#93;&lt;/span&gt; &lt;span class=&quot;error&quot;&gt;&amp;#91;DAEMON&amp;#93;&lt;/span&gt;&lt;br/&gt;
java.util.concurrent.locks.ReentrantReadWriteLock$ReadLock.lock() ReentrantReadWriteLock.java:727&lt;br/&gt;
kafka.utils.CoreUtils$.inLock(Lock, Function0) CoreUtils.scala:249&lt;br/&gt;
kafka.utils.CoreUtils$.inReadLock(ReadWriteLock, Function0) CoreUtils.scala:257&lt;br/&gt;
kafka.cluster.Partition.fetchOffsetSnapshot(Optional, boolean) Partition.scala:832&lt;br/&gt;
kafka.server.DelayedFetch.$anonfun$tryComplete$1(DelayedFetch, IntRef, Object, Tuple2) DelayedFetch.scala:87&lt;br/&gt;
kafka.server.DelayedFetch.$anonfun$tryComplete$1$adapted(DelayedFetch, IntRef, Object, Tuple2) DelayedFetch.scala:79&lt;br/&gt;
kafka.server.DelayedFetch$$Lambda$969.apply(Object)&lt;br/&gt;
scala.collection.mutable.ResizableArray.foreach(Function1) ResizableArray.scala:58&lt;br/&gt;
scala.collection.mutable.ResizableArray.foreach$(ResizableArray, Function1) ResizableArray.scala:51&lt;br/&gt;
scala.collection.mutable.ArrayBuffer.foreach(Function1) ArrayBuffer.scala:47&lt;br/&gt;
kafka.server.DelayedFetch.tryComplete() DelayedFetch.scala:79&lt;br/&gt;
kafka.server.DelayedOperation.maybeTryComplete() DelayedOperation.scala:121&lt;br/&gt;
kafka.server.DelayedOperationPurgatory$Watchers.tryCompleteWatched() DelayedOperation.scala:371&lt;br/&gt;
kafka.server.DelayedOperationPurgatory.checkAndComplete(Object) DelayedOperation.scala:277&lt;br/&gt;
kafka.server.ReplicaManager.tryCompleteDelayedFetch(DelayedOperationKey) ReplicaManager.scala:307&lt;br/&gt;
kafka.cluster.Partition.$anonfun$appendRecordsToLeader$1(Partition, MemoryRecords, boolean, int) Partition.scala:743&lt;br/&gt;
kafka.cluster.Partition$$Lambda$856.apply()&lt;br/&gt;
kafka.utils.CoreUtils$.inLock(Lock, Function0) CoreUtils.scala:251&lt;br/&gt;
kafka.utils.CoreUtils$.inReadLock(ReadWriteLock, Function0) CoreUtils.scala:257&lt;br/&gt;
kafka.cluster.Partition.appendRecordsToLeader(MemoryRecords, boolean, int) Partition.scala:729&lt;br/&gt;
kafka.server.ReplicaManager.$anonfun$appendToLocalLog$2(ReplicaManager, boolean, boolean, short, Tuple2) ReplicaManager.scala:735&lt;br/&gt;
kafka.server.ReplicaManager$$Lambda$844.apply(Object)&lt;br/&gt;
scala.collection.TraversableLike.$anonfun$map$1(Function1, Builder, Object) TraversableLike.scala:233&lt;br/&gt;
scala.collection.TraversableLike$$Lambda$10.apply(Object)&lt;br/&gt;
scala.collection.mutable.HashMap.$anonfun$foreach$1(Function1, DefaultEntry) HashMap.scala:145&lt;br/&gt;
scala.collection.mutable.HashMap$$Lambda$22.apply(Object)&lt;br/&gt;
scala.collection.mutable.HashTable.foreachEntry(Function1) HashTable.scala:235&lt;br/&gt;
scala.collection.mutable.HashTable.foreachEntry$(HashTable, Function1) HashTable.scala:228&lt;br/&gt;
scala.collection.mutable.HashMap.foreachEntry(Function1) HashMap.scala:40&lt;br/&gt;
scala.collection.mutable.HashMap.foreach(Function1) HashMap.scala:145&lt;br/&gt;
scala.collection.TraversableLike.map(Function1, CanBuildFrom) TraversableLike.scala:233&lt;br/&gt;
scala.collection.TraversableLike.map$(TraversableLike, Function1, CanBuildFrom) TraversableLike.scala:226&lt;br/&gt;
scala.collection.AbstractTraversable.map(Function1, CanBuildFrom) Traversable.scala:104&lt;br/&gt;
kafka.server.ReplicaManager.appendToLocalLog(boolean, boolean, Map, short) ReplicaManager.scala:723&lt;br/&gt;
kafka.server.ReplicaManager.appendRecords(long, short, boolean, boolean, Map, Function1, Option, Function1) ReplicaManager.scala:470&lt;br/&gt;
kafka.server.KafkaApis.handleProduceRequest(RequestChannel$Request) KafkaApis.scala:482&lt;br/&gt;
kafka.server.KafkaApis.handle(RequestChannel$Request) KafkaApis.scala:106&lt;br/&gt;
kafka.server.KafkaRequestHandler.run() KafkaRequestHandler.scala:69&lt;br/&gt;
java.lang.Thread.run() Thread.java:748&lt;/p&gt;

&lt;p&gt;-Murthy&lt;/p&gt;</comment>
                            <comment id="16832406" author="rsivaram" created="Fri, 3 May 2019 10:08:05 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jwesteen&quot; class=&quot;user-hover&quot; rel=&quot;jwesteen&quot;&gt;jwesteen&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=nsnmurthy&quot; class=&quot;user-hover&quot; rel=&quot;nsnmurthy&quot;&gt;nsnmurthy&lt;/a&gt; Thank you! The deadlock was fixed in 2.2.0 and 2.1.1. We are keen to see if there are other similar issues still remaining in these two releases, so that we can fix them before the next release. If experiencing this issue in 2.1.0, please upgrade to 2.1.1.&lt;/p&gt;</comment>
                            <comment id="16833183" author="yanrui" created="Sun, 5 May 2019 01:15:43 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt;&lt;br/&gt;
I have put file called kafka_jstack.txt  which contain full thread dumps of a broker that encountered this issue with 2.1.1 in the attachment&lt;/p&gt;</comment>
                            <comment id="16833193" author="yanrui" created="Sun, 5 May 2019 02:23:54 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt;This problem usually occurs with kafka and zk broken chains&#65292;it seems to be this situation triggers a lot of write lock operations and the write lock is not released at the end.&lt;/p&gt;</comment>
                            <comment id="16833591" author="yanrui" created="Mon, 6 May 2019 08:25:35 +0000"  >&lt;p&gt; use 2.1.1 kafka which deadlock happen  a moment ago&#65292;I have put file  called 322.tdump  in the attachment&lt;/p&gt;</comment>
                            <comment id="16834581" author="rsivaram" created="Tue, 7 May 2019 09:44:31 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=yanrui&quot; class=&quot;user-hover&quot; rel=&quot;yanrui&quot;&gt;yanrui&lt;/a&gt; Thanks for the thread dumps. It looks like kafka_jstack.txt was using an older release (not 2.1.1, perhaps 2.1.0 or earlier) since it doesn&apos;t seem to have the fix for this Jira. Can you confirm that?&lt;/p&gt;

&lt;p&gt;322.dump shows the issue described in &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-8151&quot; title=&quot;Broker hangs and lockups after Zookeeper outages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-8151&quot;&gt;KAFKA-8151&lt;/a&gt; for 2.1.1 due to ZK session expiry.&#160; As a workaround, you can increase ZK session timeouts for the broker until &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-8151&quot; title=&quot;Broker hangs and lockups after Zookeeper outages&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-8151&quot;&gt;KAFKA-8151&lt;/a&gt; is fixed if you are regularly running into this issue. It will be good to know if you see the issue with 2.2.0 if you are able to recreate. Thanks.&lt;/p&gt;</comment>
                            <comment id="16835272" author="yanrui" created="Wed, 8 May 2019 03:35:35 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt;Thank you very much, let me increase this parameters and try it for a few days&lt;/p&gt;</comment>
                            <comment id="16872190" author="muchl" created="Tue, 25 Jun 2019 09:29:06 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt; The problem was fixed after the upgrade 2.1.1, but there was a new problem.I&apos;m not sure if the two questions are related, but the logs they print when the problem occurs are similar.&lt;br/&gt;
A similar broker hangs was encountered in 2.1.1 . the problem cause broker crash in 2.1.0, but will automatically recovered in a few minutes in 2.1.1, and the cluster was unavailable during this time. &lt;br/&gt;
I uploaded a log whose file name is 2.1.1-hangs.log  &lt;span class=&quot;nobr&quot;&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/attachment/12972839/12972839_2.1.1-hangs.log&quot; title=&quot;2.1.1-hangs.log attached to KAFKA-7697&quot;&gt;2.1.1-hangs.log&lt;sup&gt;&lt;img class=&quot;rendericon&quot; src=&quot;https://issues.apache.org/jira/images/icons/link_attachment_7.gif&quot; height=&quot;7&quot; width=&quot;7&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/sup&gt;&lt;/a&gt;&lt;/span&gt; . When we find and log in to the server, the cluster was restored. All the stack information has not yet been obtained, but we can see that there is a problem from the logs of the broker and consumer. Could you give me some help,Thank you !&lt;/p&gt;</comment>
                            <comment id="16873214" author="rsivaram" created="Wed, 26 Jun 2019 10:56:55 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=muchl&quot; class=&quot;user-hover&quot; rel=&quot;muchl&quot;&gt;muchl&lt;/a&gt; This Jira addressed the deadlock which is fixed in 2.1.1. There is a separate Jira&#160; to reduce lock contention (&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7538&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-7538&lt;/a&gt;) which could be the issue you ran into in 2.1.1.&lt;/p&gt;</comment>
                            <comment id="16873850" author="muchl" created="Thu, 27 Jun 2019 06:20:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt; Thank you very much.&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7538&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;KAFKA-7538 &lt;/a&gt; This seems to be the problem I encountered.I will focus on the &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7538&quot; title=&quot;Improve locking model used to update ISRs and HW&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7538&quot;&gt;&lt;del&gt;KAFKA-7538&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="16876720" author="shaharmor" created="Tue, 2 Jul 2019 06:47:07 +0000"  >&lt;p&gt;Is it possible to overcome this issue by simply increasing the number of threads?&lt;/p&gt;

&lt;p&gt;Maybe using num.io.threads or num.network.threads?&lt;/p&gt;</comment>
                            <comment id="16990593" author="vinayzxzx" created="Sat, 7 Dec 2019 19:54:15 +0000"  >&lt;p&gt;Does increasing num.network.threads help improve the performance when kafka has high load in terms of more no. of producer/consumer requests?&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="13211766">KAFKA-7870</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13239373">KAFKA-8537</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13208480">KAFKA-7802</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13205442">KAFKA-7757</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13214783">KAFKA-7913</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13212159">KAFKA-7876</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12972839" name="2.1.1-hangs.log" size="93162" author="muchl" created="Tue, 25 Jun 2019 09:28:24 +0000"/>
                            <attachment id="12967905" name="322.tdump" size="91111" author="yanrui" created="Mon, 6 May 2019 08:25:53 +0000"/>
                            <attachment id="12967665" name="kafka.log" size="111049" author="jwesteen" created="Thu, 2 May 2019 15:53:07 +0000"/>
                            <attachment id="12967843" name="kafka_jstack.txt" size="262547" author="yanrui" created="Sun, 5 May 2019 01:10:38 +0000"/>
                            <attachment id="12950425" name="threaddump.txt" size="79853" author="gian" created="Mon, 3 Dec 2018 17:18:20 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>5.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 49 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|s0146w:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>hachikuji</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>