<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:06:51 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6511] Connect header parser incorrectly parses arrays</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6511</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;An incorrect input like &quot;&lt;span class=&quot;error&quot;&gt;&amp;#91;1, 2, 3,,,&amp;#93;&lt;/span&gt;&quot; is misinterpreted by the Values parser. An example&#160;test can be found here:&#160;&lt;a href=&quot;https://github.com/apache/kafka/pull/4319#discussion_r165155768&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4319#discussion_r165155768&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13135193">KAFKA-6511</key>
            <summary>Connect header parser incorrectly parses arrays</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rhauch">Randall Hauch</assignee>
                                    <reporter username="wicknicks">Arjun Satish</reporter>
                        <labels>
                    </labels>
                <created>Wed, 31 Jan 2018 19:37:35 +0000</created>
                <updated>Tue, 13 Feb 2018 19:47:23 +0000</updated>
                            <resolved>Tue, 13 Feb 2018 19:47:23 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>connect</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16350764" author="githubbot" created="Fri, 2 Feb 2018 18:21:22 +0000"  >&lt;p&gt;rhauch opened a new pull request #4516: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6511&quot; title=&quot;Connect header parser incorrectly parses arrays&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6511&quot;&gt;&lt;del&gt;KAFKA-6511&lt;/del&gt;&lt;/a&gt;: Corrected list parsing logic&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4516&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4516&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   Corrected the parsing of invalid list values. A list can only be parsed if it contains elements that have a common type, and a map can only be parsed if it contains keys with a common type and values with a common type.&lt;/p&gt;

&lt;p&gt;   This should only be merged to `trunk`.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16362936" author="githubbot" created="Tue, 13 Feb 2018 19:44:16 +0000"  >&lt;p&gt;hachikuji closed pull request #4516: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6511&quot; title=&quot;Connect header parser incorrectly parses arrays&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6511&quot;&gt;&lt;del&gt;KAFKA-6511&lt;/del&gt;&lt;/a&gt;: Corrected list parsing logic&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4516&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4516&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/connect/api/src/main/java/org/apache/kafka/connect/data/Values.java b/connect/api/src/main/java/org/apache/kafka/connect/data/Values.java&lt;br/&gt;
index 41040c7f051..05248efaa0f 100644&lt;br/&gt;
&amp;#8212; a/connect/api/src/main/java/org/apache/kafka/connect/data/Values.java&lt;br/&gt;
+++ b/connect/api/src/main/java/org/apache/kafka/connect/data/Values.java&lt;br/&gt;
@@ -749,10 +749,16 @@ protected static SchemaAndValue parse(Parser parser, boolean embedded) throws No&lt;br/&gt;
                 Schema elementSchema = null;&lt;br/&gt;
                 while (parser.hasNext()) {&lt;br/&gt;
                     if (parser.canConsume(ARRAY_END_DELIMITER)) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Schema listSchema = elementSchema == null ? null : SchemaBuilder.array(elementSchema).schema();&lt;br/&gt;
+                        Schema listSchema = null;&lt;br/&gt;
+                        if (elementSchema != null) 
{
+                            listSchema = SchemaBuilder.array(elementSchema).schema();
+                        }
&lt;p&gt;                         result = alignListEntriesWithSchema(listSchema, result);&lt;br/&gt;
                         return new SchemaAndValue(listSchema, result);&lt;br/&gt;
                     }&lt;br/&gt;
+                    if (parser.canConsume(COMMA_DELIMITER)) &lt;/p&gt;
{
+                        throw new DataException(&quot;Unable to parse an empty array element: &quot; + parser.original());
+                    }
&lt;p&gt;                     SchemaAndValue element = parse(parser, true);&lt;br/&gt;
                     elementSchema = commonSchemaFor(elementSchema, element);&lt;br/&gt;
                     result.add(element.value());&lt;br/&gt;
@@ -760,9 +766,9 @@ protected static SchemaAndValue parse(Parser parser, boolean embedded) throws No&lt;br/&gt;
                 }&lt;br/&gt;
                 // Missing either a comma or an end delimiter&lt;br/&gt;
                 if (COMMA_DELIMITER.equals(parser.previous())) &lt;/p&gt;
{
-                    throw new DataException(&quot;Malformed array: missing element after &apos;,&apos;&quot;);
+                    throw new DataException(&quot;Array is missing element after &apos;,&apos;: &quot; + parser.original());
                 }&lt;/li&gt;
	&lt;li&gt;throw new DataException(&quot;Malformed array: missing terminating &apos;]&apos;&quot;);&lt;br/&gt;
+                throw new DataException(&quot;Array is missing terminating &apos;]&apos;: &quot; + parser.original());&lt;br/&gt;
             }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             if (parser.canConsume(MAP_BEGIN_DELIMITER)) {&lt;br/&gt;
@@ -771,17 +777,22 @@ protected static SchemaAndValue parse(Parser parser, boolean embedded) throws No&lt;br/&gt;
                 Schema valueSchema = null;&lt;br/&gt;
                 while (parser.hasNext()) {&lt;br/&gt;
                     if (parser.canConsume(MAP_END_DELIMITER)) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Schema mapSchema =&lt;/li&gt;
	&lt;li&gt;keySchema == null || valueSchema == null ? null : SchemaBuilder.map(keySchema, valueSchema).schema();&lt;br/&gt;
+                        Schema mapSchema = null;&lt;br/&gt;
+                        if (keySchema != null &amp;amp;&amp;amp; valueSchema != null) 
{
+                            mapSchema = SchemaBuilder.map(keySchema, valueSchema).schema();
+                        }
&lt;p&gt;                         result = alignMapKeysAndValuesWithSchema(mapSchema, result);&lt;br/&gt;
                         return new SchemaAndValue(mapSchema, result);&lt;br/&gt;
                     }&lt;br/&gt;
+                    if (parser.canConsume(COMMA_DELIMITER)) &lt;/p&gt;
{
+                        throw new DataException(&quot;Unable to parse a map entry has no key or value: &quot; + parser.original());
+                    }
&lt;p&gt;                     SchemaAndValue key = parse(parser, true);&lt;br/&gt;
                     if (key == null || key.value() == null) &lt;/p&gt;
{
-                        throw new DataException(&quot;Malformed map entry: null key&quot;);
+                        throw new DataException(&quot;Map entry may not have a null key: &quot; + parser.original());
                     }
&lt;p&gt;                     if (!parser.canConsume(ENTRY_DELIMITER)) &lt;/p&gt;
{
-                        throw new DataException(&quot;Malformed map entry: missing &apos;=&apos;&quot;);
+                        throw new DataException(&quot;Map entry is missing &apos;=&apos;: &quot; + parser.original());
                     }
&lt;p&gt;                     SchemaAndValue value = parse(parser, true);&lt;br/&gt;
                     Object entryValue = value != null ? value.value() : null;&lt;br/&gt;
@@ -792,9 +803,9 @@ protected static SchemaAndValue parse(Parser parser, boolean embedded) throws No&lt;br/&gt;
                 }&lt;br/&gt;
                 // Missing either a comma or an end delimiter&lt;br/&gt;
                 if (COMMA_DELIMITER.equals(parser.previous())) &lt;/p&gt;
{
-                    throw new DataException(&quot;Malformed map: missing element after &apos;,&apos;&quot;);
+                    throw new DataException(&quot;Map is missing element after &apos;,&apos;: &quot; + parser.original());
                 }&lt;/li&gt;
	&lt;li&gt;throw new DataException(&quot;Malformed array: missing terminating &apos;]&apos;&quot;);&lt;br/&gt;
+                throw new DataException(&quot;Map is missing terminating &apos;]&apos;: &quot; + parser.original());&lt;br/&gt;
             }&lt;br/&gt;
         } catch (DataException e) {&lt;br/&gt;
             LOG.debug(&quot;Unable to parse the value as a map; reverting to string&quot;, e);&lt;br/&gt;
diff --git a/connect/api/src/test/java/org/apache/kafka/connect/data/ValuesTest.java b/connect/api/src/test/java/org/apache/kafka/connect/data/ValuesTest.java&lt;br/&gt;
index 70835c8afba..c2caf08d5f9 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/connect/api/src/test/java/org/apache/kafka/connect/data/ValuesTest.java&lt;br/&gt;
+++ b/connect/api/src/test/java/org/apache/kafka/connect/data/ValuesTest.java&lt;br/&gt;
@@ -16,7 +16,9 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.connect.data;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+import org.apache.kafka.connect.data.Schema.Type;&lt;br/&gt;
 import org.apache.kafka.connect.data.Values.Parser;&lt;br/&gt;
+import org.apache.kafka.connect.errors.DataException;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt; import java.util.ArrayList;&lt;br/&gt;
@@ -159,6 +161,116 @@ public void shouldConvertListWithIntegerValues() &lt;/p&gt;
{
         assertRoundTrip(INT_LIST_SCHEMA, INT_LIST_SCHEMA, INT_LIST);
     }

&lt;p&gt;+    /**&lt;br/&gt;
+     * The parsed array has byte values and one int value, so we should return list with single unified type of integers.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldConvertStringOfListWithOnlyNumericElementTypesIntoListOfLargestNumericType() &lt;/p&gt;
{
+        int thirdValue = Short.MAX_VALUE + 1;
+        List&amp;lt;?&amp;gt; list = Values.convertToList(Schema.STRING_SCHEMA, &quot;[1, 2, &quot; + thirdValue + &quot;]&quot;);
+        assertEquals(3, list.size());
+        assertEquals(1, ((Number) list.get(0)).intValue());
+        assertEquals(2, ((Number) list.get(1)).intValue());
+        assertEquals(thirdValue, ((Number) list.get(2)).intValue());
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * The parsed array has byte values and one int value, so we should return list with single unified type of integers.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldConvertStringOfListWithMixedElementTypesIntoListWithDifferentElementTypes() &lt;/p&gt;
{
+        String str = &quot;[1, 2, \&quot;three\&quot;]&quot;;
+        List&amp;lt;?&amp;gt; list = Values.convertToList(Schema.STRING_SCHEMA, str);
+        assertEquals(3, list.size());
+        assertEquals(1, ((Number) list.get(0)).intValue());
+        assertEquals(2, ((Number) list.get(1)).intValue());
+        assertEquals(&quot;three&quot;, list.get(2));
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * We parse into different element types, but cannot infer a common element schema.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldParseStringListWithMultipleElementTypesAndReturnListWithNoSchema() &lt;/p&gt;
{
+        String str = &quot;[1, 2, 3, \&quot;four\&quot;]&quot;;
+        SchemaAndValue result = Values.parseString(str);
+        assertNull(result.schema());
+        List&amp;lt;?&amp;gt; list = (List&amp;lt;?&amp;gt;) result.value();
+        assertEquals(4, list.size());
+        assertEquals(1, ((Number) list.get(0)).intValue());
+        assertEquals(2, ((Number) list.get(1)).intValue());
+        assertEquals(3, ((Number) list.get(2)).intValue());
+        assertEquals(&quot;four&quot;, list.get(3));
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * We can&apos;t infer or successfully parse into a different type, so this returns the same string.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldParseStringListWithExtraDelimitersAndReturnString() &lt;/p&gt;
{
+        String str = &quot;[1, 2, 3,,,]&quot;;
+        SchemaAndValue result = Values.parseString(str);
+        assertEquals(Type.STRING, result.schema().type());
+        assertEquals(str, result.value());
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * This is technically invalid JSON, and we don&apos;t want to simply ignore the blank elements.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test(expected = DataException.class)&lt;br/&gt;
+    public void shouldFailToConvertToListFromStringWithExtraDelimiters() &lt;/p&gt;
{
+        Values.convertToList(Schema.STRING_SCHEMA, &quot;[1, 2, 3,,,]&quot;);
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Schema of type ARRAY requires a schema for the values, but Connect has no union or &quot;any&quot; schema type.&lt;br/&gt;
+     * Therefore, we can&apos;t represent this.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test(expected = DataException.class)&lt;br/&gt;
+    public void shouldFailToConvertToListFromStringWithNonCommonElementTypeAndBlankElement() &lt;/p&gt;
{
+        Values.convertToList(Schema.STRING_SCHEMA, &quot;[1, 2, 3, \&quot;four\&quot;,,,]&quot;);
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * This is technically invalid JSON, and we don&apos;t want to simply ignore the blank entry.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test(expected = DataException.class)&lt;br/&gt;
+    public void shouldFailToParseStringOfMapWithIntValuesWithBlankEntry() {&lt;br/&gt;
+        Values.convertToList(Schema.STRING_SCHEMA, &quot; &lt;/p&gt;
{ \&quot;foo\&quot; :  1234567890 ,, \&quot;bar\&quot; : 0,  \&quot;baz\&quot; : -987654321 }
&lt;p&gt;  &quot;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * This is technically invalid JSON, and we don&apos;t want to simply ignore the malformed entry.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test(expected = DataException.class)&lt;br/&gt;
+    public void shouldFailToParseStringOfMalformedMap() {&lt;br/&gt;
+        Values.convertToList(Schema.STRING_SCHEMA, &quot; &lt;/p&gt;
{ \&quot;foo\&quot; :  1234567890 , \&quot;a\&quot;, \&quot;bar\&quot; : 0,  \&quot;baz\&quot; : -987654321 }
&lt;p&gt;  &quot;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * This is technically invalid JSON, and we don&apos;t want to simply ignore the blank entries.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test(expected = DataException.class)&lt;br/&gt;
+    public void shouldFailToParseStringOfMapWithIntValuesWithOnlyBlankEntries() {&lt;br/&gt;
+        Values.convertToList(Schema.STRING_SCHEMA, &quot; &lt;/p&gt;
{ ,,  , , }
&lt;p&gt;  &quot;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * This is technically invalid JSON, and we don&apos;t want to simply ignore the blank entry.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test(expected = DataException.class)&lt;br/&gt;
+    public void shouldFailToParseStringOfMapWithIntValuesWithBlankEntries() {&lt;br/&gt;
+        Values.convertToList(Schema.STRING_SCHEMA, &quot; &lt;/p&gt;
{ \&quot;foo\&quot; :  \&quot;1234567890\&quot; ,, \&quot;bar\&quot; : \&quot;0\&quot;,  \&quot;baz\&quot; : \&quot;boz\&quot; }
&lt;p&gt;  &quot;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Schema for Map requires a schema for key and value, but we have no key or value and Connect has no &quot;any&quot; type&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test(expected = DataException.class)&lt;br/&gt;
+    public void shouldFailToParseStringOfEmptyMap() {&lt;br/&gt;
+        Values.convertToList(Schema.STRING_SCHEMA, &quot; { }  &quot;);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldParseStringsWithoutDelimiters() {&lt;br/&gt;
         //assertParsed(&quot;&quot;);&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 39 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3pm4n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>