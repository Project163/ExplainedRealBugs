<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:11:32 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-3665] Default ssl.endpoint.identification.algorithm should be https</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-3665</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;The default `ssl.endpoint.identification.algorithm` is `null` which is not a secure default (man in the middle attacks are possible).&lt;/p&gt;

&lt;p&gt;We should probably use `https` instead. A more conservative alternative would be to update the documentation instead of changing the default.&lt;/p&gt;

&lt;p&gt;A paper on the topic (thanks to Ryan Pridgeon for the reference): &lt;a href=&quot;http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="12965543">KAFKA-3665</key>
            <summary>Default ssl.endpoint.identification.algorithm should be https</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rsivaram">Rajini Sivaram</assignee>
                                    <reporter username="ijuma">Ismael Juma</reporter>
                        <labels>
                    </labels>
                <created>Fri, 6 May 2016 09:30:22 +0000</created>
                <updated>Thu, 18 Oct 2018 15:02:08 +0000</updated>
                            <resolved>Tue, 5 Jun 2018 11:09:40 +0000</resolved>
                                    <version>0.9.0.1</version>
                    <version>0.10.0.0</version>
                                    <fixVersion>2.0.0</fixVersion>
                                    <component>security</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>7</watches>
                                                                                                                <comments>
                            <comment id="15273900" author="githubbot" created="Fri, 6 May 2016 10:35:21 +0000"  >&lt;p&gt;GitHub user ijuma opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1330&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1330&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3665&quot; title=&quot;Default ssl.endpoint.identification.algorithm should be https&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3665&quot;&gt;&lt;del&gt;KAFKA-3665&lt;/del&gt;&lt;/a&gt;; Default ssl.endpoint.identification.algorithm should be https&lt;/p&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/ijuma/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/ijuma/kafka&lt;/a&gt; kafka-3665-ssl-endpoint-identification-https&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/1330.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1330.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #1330&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 8939bde7c99dcccd1e5d5496b64447d6e74507c0&lt;br/&gt;
Author: Ismael Juma &amp;lt;ismael@juma.me.uk&amp;gt;&lt;br/&gt;
Date:   2016-05-06T09:36:27Z&lt;/p&gt;

&lt;p&gt;    Default ssl.endpoint.identification.algorithm should be `https`&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15273902" author="ijuma" created="Fri, 6 May 2016 10:37:11 +0000"  >&lt;p&gt;Thoughts &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=junrao&quot; class=&quot;user-hover&quot; rel=&quot;junrao&quot;&gt;junrao&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=gwenshap&quot; class=&quot;user-hover&quot; rel=&quot;gwenshap&quot;&gt;gwenshap&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=harsha_ch&quot; class=&quot;user-hover&quot; rel=&quot;harsha_ch&quot;&gt;harsha_ch&lt;/a&gt;?&lt;/p&gt;</comment>
                            <comment id="15273917" author="rsivaram" created="Fri, 6 May 2016 11:07:58 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ijuma&quot; class=&quot;user-hover&quot; rel=&quot;ijuma&quot;&gt;ijuma&lt;/a&gt; I agree that secure installations of Kafka would always turn on hostname verification. But this change could potentially catch people out. Perhaps it doesn&apos;t matter because this is a major release? The documentation should say how to disable it - set ssl.endpoint.identification.algorithm to empty string?&lt;/p&gt;</comment>
                            <comment id="15273931" author="ijuma" created="Fri, 6 May 2016 11:31:14 +0000"  >&lt;p&gt;Thanks &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rsivaram&quot; class=&quot;user-hover&quot; rel=&quot;rsivaram&quot;&gt;rsivaram&lt;/a&gt;. I agree that this could catch some people. However, note that our documentation currently states:&lt;/p&gt;

&lt;p&gt;&quot;Ensure that common name (CN) matches exactly with the fully qualified domain name (FQDN) of the server. The client compares the CN with the DNS domain name to ensure that it is indeed connecting to the desired server, not the malicious one.&quot;&lt;/p&gt;

&lt;p&gt;So, I would claim that it&apos;s a bug that we don&apos;t do it. I updated the upgrade note in the PR to mention how to restore the old behaviour (as per your suggestion).&lt;/p&gt;</comment>
                            <comment id="15274001" author="ryan p" created="Fri, 6 May 2016 12:59:54 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ijuma&quot; class=&quot;user-hover&quot; rel=&quot;ijuma&quot;&gt;ijuma&lt;/a&gt;, just a nit but &lt;a href=&quot;https://tools.ietf.org/search/rfc6125&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;RFC 6125&lt;/a&gt; advises against the use of the CN for hostname verification. &lt;/p&gt;

&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;Existing certificates often use a CN-ID in the subject field to&lt;br/&gt;
   represent a fully qualified DNS domain name; for example, consider&lt;br/&gt;
   the following three subject names, where the attribute of type Common&lt;br/&gt;
   Name contains a string whose form matches that of a fully qualified&lt;br/&gt;
   DNS domain name (&quot;im.example.org&quot;, &quot;mail.example.net&quot;, and&lt;br/&gt;
   &quot;www.example.com&quot;, respectively):&lt;/p&gt;

&lt;p&gt;      CN=im.example.org,O=Example Org,C=GB&lt;br/&gt;
      C=CA,O=Example Internetworking,CN=mail.example.net&lt;br/&gt;
      O=Examples-R-Us,CN=www.example.com,C=US&lt;/p&gt;

&lt;p&gt;   However, the Common Name is not strongly typed because a Common Name&lt;br/&gt;
   might contain a human-friendly string for the service, rather than a&lt;br/&gt;
   string whose form matches that of a fully qualified DNS domain name&lt;br/&gt;
   (a certificate with such a single Common Name will typically have at&lt;br/&gt;
   least one subjectAltName entry containing the fully qualified DNS&lt;br/&gt;
   domain name):&lt;/p&gt;

&lt;p&gt;      CN=A Free Chat Service,O=Example Org,C=GB&lt;/p&gt;

&lt;p&gt;   Or, a certificate&apos;s subject might contain both a CN-ID as well as&lt;br/&gt;
   another common name attribute containing a human-friendly string:&lt;/p&gt;

&lt;p&gt;      CN=A Free Chat Service,CN=im.example.org,O=Example Org,C=GB&lt;/p&gt;

&lt;p&gt;   In general, this specification recommends and prefers use of&lt;br/&gt;
   subjectAltName entries (DNS-ID, SRV-ID, URI-ID, etc.) over use of the&lt;br/&gt;
   subject field (CN-ID) where possible, as more completely described in&lt;br/&gt;
   the following sections.  However, specifications that reuse this one&lt;br/&gt;
   can legitimately encourage continued support for the CN-ID identifier&lt;br/&gt;
   type if they have good reasons to do so, such as backward&lt;br/&gt;
   compatibility with deployed infrastructure&lt;/p&gt;
{/quote}

&lt;p&gt;Using the CN subject field is still completely valid but if we are going to amend the docs anyway it may be worth adding the steps to generate key pairs  as described in the RFC.  &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/technotes/tools/windows/keytool.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://docs.oracle.com/javase/7/docs/technotes/tools/windows/keytool.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;keytool -genkeypair \&lt;br/&gt;
   -keystore keystore.jks \&lt;br/&gt;
  -dname &quot;CN=example.com, OU=Kafka, O=Org, L=Raleigh, ST=NC, C=US&quot; \&lt;br/&gt;
  -keypass password \&lt;br/&gt;
  -storepass password \&lt;br/&gt;
  -keyalg RSA \&lt;br/&gt;
  -keysize 2048 \&lt;br/&gt;
  -alias san \&lt;br/&gt;
  -ext SAN=DNS:example.com \&lt;/p&gt;</comment>
                            <comment id="15274012" author="ijuma" created="Fri, 6 May 2016 13:15:22 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Ryan+P&quot; class=&quot;user-hover&quot; rel=&quot;Ryan P&quot;&gt;Ryan P&lt;/a&gt;, I agree that this would be better. The paper also touches on this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;After the chain of trust is established, the&lt;br/&gt;
client must verify the server&#8217;s identity. RFC 2818 advises the implementors&lt;br/&gt;
to use &#8220;SubjectAltNames&#8221; as the main source of server&lt;br/&gt;
identifiers and support &#8220;Common Name&#8221; for backward compatibility&lt;br/&gt;
only, but most of the software we tested does it the other way&lt;br/&gt;
around and checks &#8220;Common Name&#8221; first.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;However, I think we should tackle this separately. Would you mind filing a separate JIRA for that?&lt;/p&gt;</comment>
                            <comment id="15274035" author="ryan p" created="Fri, 6 May 2016 13:42:40 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ijuma&quot; class=&quot;user-hover&quot; rel=&quot;ijuma&quot;&gt;ijuma&lt;/a&gt;, I can absolutely do that. &lt;/p&gt;

&lt;p&gt;Would you like me to include the documentation changes that will be needed for this JIRA as well? Might be easier to just merge both Doc enhancements into one since adding the SAN is useless without configuring the endpoint algorithm to HTTPS.&lt;/p&gt;

&lt;p&gt;For what it&apos;s worth the &lt;a href=&quot;https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/sun/security/util/HostnameChecker.java#L174-L209&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;OpenJDK &lt;/a&gt; handles hostname verification in the proper order.  &lt;/p&gt;

&lt;p&gt;With that said I&apos;d be glad to open the JIRA. &lt;/p&gt;</comment>
                            <comment id="15274052" author="ijuma" created="Fri, 6 May 2016 13:51:05 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Ryan+P&quot; class=&quot;user-hover&quot; rel=&quot;Ryan P&quot;&gt;Ryan P&lt;/a&gt;, that sounds great. The reason why I want to do that separately is that we have a bit more time to update the documentation (as it&apos;s not included with released artifacts), but if we want to do a code change for 0.10.0.0, then it has to be merged before the next RC.&lt;/p&gt;

&lt;p&gt;If we decide to just do the documentation change, then we can close this issue and just keep the other one. Does that make sense?&lt;/p&gt;</comment>
                            <comment id="15274195" author="junrao" created="Fri, 6 May 2016 15:22:09 +0000"  >&lt;p&gt;Thanks for the patch. A couple of questions.&lt;/p&gt;

&lt;p&gt;1. Is the requirement only on the server side certificate? Does https require the client side certificate to have CN match the client host name?&lt;/p&gt;

&lt;p&gt;2. If https is turned on, what&apos;s our recommendation on using a VIP for the client to connect to the broker? In this case, the client doesn&apos;t get the true broker host name from the socket connection.&lt;/p&gt;</comment>
                            <comment id="15275873" author="ijuma" created="Mon, 9 May 2016 02:33:17 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=junrao&quot; class=&quot;user-hover&quot; rel=&quot;junrao&quot;&gt;junrao&lt;/a&gt;, good questions. With regards to 1, both the server and client can use `SubjectAltNames` with multiple DNS names instead of CN so that the CN can be more meaningful. `SubjectAltNames` seems to be the answer to question 2 as well.&lt;/p&gt;

&lt;p&gt;A relevant quote of RFC2818 is:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; If the client has external information as to the expected identity of&lt;br/&gt;
   the server, the hostname check MAY be omitted. (For instance, a&lt;br/&gt;
   client may be connecting to a machine whose address and hostname are&lt;br/&gt;
   dynamic but the client knows the certificate that the server will&lt;br/&gt;
   present.) In such cases, it is important to narrow the scope of&lt;br/&gt;
   acceptable certificates as much as possible in order to prevent man&lt;br/&gt;
   in the middle attacks.  In special cases, it may be appropriate for&lt;br/&gt;
   the client to simply ignore the server&apos;s identity, but it must be&lt;br/&gt;
   understood that this leaves the connection open to active attack.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;It seems that for cases where the server and client use a truststore that restricts the certificates to only trusted ones (which is what our documentation says), it may be acceptable to skip hostname verification. We need to double-check this, however.&lt;/p&gt;

&lt;p&gt;I paste 3.1 and 3.2 sections of RFC2818:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.1.  Server Identity&lt;/p&gt;

&lt;p&gt;   In general, HTTP/TLS requests are generated by dereferencing a URI.&lt;br/&gt;
   As a consequence, the hostname for the server is known to the client.&lt;br/&gt;
   If the hostname is available, the client MUST check it against the&lt;br/&gt;
   server&apos;s identity as presented in the server&apos;s Certificate message,&lt;br/&gt;
   in order to prevent man-in-the-middle attacks.&lt;/p&gt;

&lt;p&gt;   If the client has external information as to the expected identity of&lt;br/&gt;
   the server, the hostname check MAY be omitted. (For instance, a&lt;br/&gt;
   client may be connecting to a machine whose address and hostname are&lt;br/&gt;
   dynamic but the client knows the certificate that the server will&lt;br/&gt;
   present.) In such cases, it is important to narrow the scope of&lt;br/&gt;
   acceptable certificates as much as possible in order to prevent man&lt;br/&gt;
   in the middle attacks.  In special cases, it may be appropriate for&lt;br/&gt;
   the client to simply ignore the server&apos;s identity, but it must be&lt;br/&gt;
   understood that this leaves the connection open to active attack.&lt;/p&gt;

&lt;p&gt;   If a subjectAltName extension of type dNSName is present, that MUST&lt;br/&gt;
   be used as the identity. Otherwise, the (most specific) Common Name&lt;br/&gt;
   field in the Subject field of the certificate MUST be used. Although&lt;br/&gt;
   the use of the Common Name is existing practice, it is deprecated and&lt;br/&gt;
   Certification Authorities are encouraged to use the dNSName instead.&lt;/p&gt;

&lt;p&gt;   Matching is performed using the matching rules specified by&lt;br/&gt;
   &lt;span class=&quot;error&quot;&gt;&amp;#91;RFC2459&amp;#93;&lt;/span&gt;.  If more than one identity of a given type is present in&lt;br/&gt;
   the certificate (e.g., more than one dNSName name, a match in any one&lt;br/&gt;
   of the set is considered acceptable.) Names may contain the wildcard&lt;br/&gt;
   character * which is considered to match any single domain name&lt;br/&gt;
   component or component fragment. E.g., *.a.com matches foo.a.com but&lt;br/&gt;
   not bar.foo.a.com. f*.com matches foo.com but not bar.com.&lt;/p&gt;

&lt;p&gt;   In some cases, the URI is specified as an IP address rather than a&lt;br/&gt;
   hostname. In this case, the iPAddress subjectAltName must be present&lt;br/&gt;
   in the certificate and must exactly match the IP in the URI.&lt;/p&gt;

&lt;p&gt;   If the hostname does not match the identity in the certificate, user&lt;br/&gt;
   oriented clients MUST either notify the user (clients MAY give the&lt;br/&gt;
   user the opportunity to continue with the connection in any case) or&lt;br/&gt;
   terminate the connection with a bad certificate error. Automated&lt;br/&gt;
   clients MUST log the error to an appropriate audit log (if available)&lt;br/&gt;
   and SHOULD terminate the connection (with a bad certificate error).&lt;br/&gt;
   Automated clients MAY provide a configuration setting that disables&lt;br/&gt;
   this check, but MUST provide a setting which enables it.&lt;/p&gt;

&lt;p&gt;   Note that in many cases the URI itself comes from an untrusted&lt;br/&gt;
   source. The above-described check provides no protection against&lt;br/&gt;
   attacks where this source is compromised. For example, if the URI was&lt;br/&gt;
   obtained by clicking on an HTML page which was itself obtained&lt;br/&gt;
   without using HTTP/TLS, a man in the middle could have replaced the&lt;br/&gt;
   URI.  In order to prevent this form of attack, users should carefully&lt;br/&gt;
   examine the certificate presented by the server to determine if it&lt;br/&gt;
   meets their expectations.&lt;/p&gt;

&lt;p&gt;3.2.  Client Identity&lt;/p&gt;

&lt;p&gt;   Typically, the server has no external knowledge of what the client&apos;s&lt;br/&gt;
   identity ought to be and so checks (other than that the client has a&lt;br/&gt;
   certificate chain rooted in an appropriate CA) are not possible. If a&lt;br/&gt;
   server has such knowledge (typically from some source external to&lt;br/&gt;
   HTTP or TLS) it SHOULD check the identity as described above.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2818.txt&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.ietf.org/rfc/rfc2818.txt&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15275926" author="junrao" created="Mon, 9 May 2016 04:35:12 +0000"  >&lt;p&gt;Interesting, the difference is that in https, if a VIP is used, all client requests go through the VIP. However, in Kafka&apos;s case, only the initial metadata request goes through the VIP. Subsequent requests go to the broker directly. For the client to verify the broker&apos;s host name, does that mean the broker&apos;s certificate needs to include both the VIP and the broker&apos;s host name in SubjectAltNames? What about the client certificate?&lt;/p&gt;</comment>
                            <comment id="15276118" author="rsivaram" created="Mon, 9 May 2016 08:42:32 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ijuma&quot; class=&quot;user-hover&quot; rel=&quot;ijuma&quot;&gt;ijuma&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=junrao&quot; class=&quot;user-hover&quot; rel=&quot;junrao&quot;&gt;junrao&lt;/a&gt; I dont believe HTTPS validates client hostname/IP address and Kafka definitely doesn&apos;t. For client requests that go through a VIP for the initial request, each broker&apos;s certificate would need SubjectAltNames with the VIP as well as its advertised host name.&lt;/p&gt;</comment>
                            <comment id="15405659" author="ryan p" created="Wed, 3 Aug 2016 10:03:10 +0000"  >&lt;p&gt;RFC-6066 describes an extension to the TLS protocol to handle the VIP case. &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6066#page-6&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://tools.ietf.org/html/rfc6066#page-6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Setting the SNI field within a client request, JSSE sets this field by default, allows the VIP to determine the correct named virtual host for the request and set the connection up accordingly from the start.&lt;/p&gt;
</comment>
                            <comment id="15407964" author="junrao" created="Thu, 4 Aug 2016 15:42:06 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Ryan+P&quot; class=&quot;user-hover&quot; rel=&quot;Ryan P&quot;&gt;Ryan P&lt;/a&gt;, is SNI really relevant here? According to Rajini, only the client validates the server hostname/IP. So, the suggestion of using SubjectAltNames with the VIP on the server side seems more relevant.&lt;/p&gt;</comment>
                            <comment id="15408544" author="ryan p" created="Thu, 4 Aug 2016 21:45:51 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=junrao&quot; class=&quot;user-hover&quot; rel=&quot;junrao&quot;&gt;junrao&lt;/a&gt; yes I do think that SNI is still relevant despite the presence of the SAN certificate extension. Adding the VIP to each brokers SAN means that the client can establish a security context with any terminal endpoint which also contains the VIP hostname within the SAN extension. Since we cannot guarantee the identity of the terminal entity it sort of takes away from the idea of hostname verification.I personally prefer to take a more prudent approach with client/server authentication. I&apos;m actually curious if the SAN extension is actually required at all in the wild. By default the Oracle JDK already leverages SNI so your VIP is likely passing the request along to the correct name based host to begin with. Disabling this functionality is actually a known workaround when dealing with dated software which is not compatible with the extension. &lt;/p&gt;
</comment>
                            <comment id="15410268" author="junrao" created="Fri, 5 Aug 2016 23:20:14 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Ryan+P&quot; class=&quot;user-hover&quot; rel=&quot;Ryan P&quot;&gt;Ryan P&lt;/a&gt;, thanks for the explanation. In the common case, the client only talks to the VIP for the very first MetadataRequest. At this point, the client doesn&apos;t know any broker host except for the VIP. So, it can&apos;t set SNI. After receiving the MetadataResponse, the client knows the broker hosts. However, for subsequent requests, the client just sends the requests to the broker host directly w/o going through the VIP. So, with SSL, we really need to solve the host verification problem for the very first request. It seems that SNI won&apos;t help in the that case?&lt;/p&gt;</comment>
                            <comment id="16461049" author="githubbot" created="Wed, 2 May 2018 13:42:16 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #4956: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3665&quot; title=&quot;Default ssl.endpoint.identification.algorithm should be https&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3665&quot;&gt;&lt;del&gt;KAFKA-3665&lt;/del&gt;&lt;/a&gt;: Make HTTPS the default ssl.endpoint.identification.algorithm&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4956&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4956&lt;/a&gt;&lt;/p&gt;



&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16501597" author="githubbot" created="Tue, 5 Jun 2018 11:08:16 +0000"  >&lt;p&gt;ijuma closed pull request #4956: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3665&quot; title=&quot;Default ssl.endpoint.identification.algorithm should be https&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3665&quot;&gt;&lt;del&gt;KAFKA-3665&lt;/del&gt;&lt;/a&gt;: Enable TLS hostname verification by default (KIP-294)&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4956&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4956&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java b/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java&lt;br/&gt;
index 9a3215f7a50..2ed177b6fbc 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java&lt;br/&gt;
@@ -105,6 +105,7 @@&lt;/p&gt;

&lt;p&gt;     public static final String SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG = &quot;ssl.endpoint.identification.algorithm&quot;;&lt;br/&gt;
     public static final String SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC = &quot;The endpoint identification algorithm to validate server hostname using server certificate. &quot;;&lt;br/&gt;
+    public static final String DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM = &quot;https&quot;;&lt;/p&gt;

&lt;p&gt;     public static final String SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG = &quot;ssl.secure.random.implementation&quot;;&lt;br/&gt;
     public static final String SSL_SECURE_RANDOM_IMPLEMENTATION_DOC = &quot;The SecureRandom PRNG implementation to use for SSL cryptography operations. &quot;;&lt;br/&gt;
@@ -134,7 +135,7 @@ public static void addClientSslSupport(ConfigDef config) &lt;/p&gt;
{
                 .define(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, ConfigDef.Type.PASSWORD, null, ConfigDef.Importance.HIGH, SslConfigs.SSL_TRUSTSTORE_PASSWORD_DOC)
                 .define(SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_KEYMANGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_KEYMANAGER_ALGORITHM_DOC)
                 .define(SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_TRUSTMANAGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_DOC)
-                .define(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, ConfigDef.Type.STRING, null, ConfigDef.Importance.LOW, SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC)
+                .define(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC)
                 .define(SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG, ConfigDef.Type.STRING, null, ConfigDef.Importance.LOW, SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_DOC);
     }

&lt;p&gt;diff --git a/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java b/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java&lt;br/&gt;
index 2df4c4fe90f..f5af400dd44 100644&lt;br/&gt;
&amp;#8212; a/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java&lt;br/&gt;
@@ -237,23 +237,41 @@ public void testInvalidEndpointIdentification() throws Exception {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Tests that server certificate with invalid IP address is accepted by&lt;br/&gt;
+     * Tests that server certificate with invalid host name is accepted by&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;a client that has disabled endpoint validation&lt;br/&gt;
      */&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testEndpointIdentificationDisabled() throws Exception 
{
-        String node = &quot;0&quot;;
-        String serverHost = InetAddress.getLocalHost().getHostAddress();
+        serverCertStores = new CertStores(true, &quot;server&quot;, &quot;notahost&quot;);
+        clientCertStores = new CertStores(false, &quot;client&quot;, &quot;localhost&quot;);
+        sslServerConfigs = serverCertStores.getTrustingConfig(clientCertStores);
+        sslClientConfigs = clientCertStores.getTrustingConfig(serverCertStores);
+
         SecurityProtocol securityProtocol = SecurityProtocol.SSL;
-        server = new NioEchoServer(ListenerName.forSecurityProtocol(securityProtocol), securityProtocol,
-                new TestSecurityConfig(sslServerConfigs), serverHost, null, null);
-        server.start();
-        sslClientConfigs.remove(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG);
+        server = createEchoServer(SecurityProtocol.SSL);
+        InetSocketAddress addr = new InetSocketAddress(&quot;localhost&quot;, server.port());
+
+        // Disable endpoint validation, connection should succeed
+        String node = &quot;1&quot;;
+        sslClientConfigs.put(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, &quot;&quot;);
         createSelector(sslClientConfigs);
-        InetSocketAddress addr = new InetSocketAddress(serverHost, server.port());
         selector.connect(node, addr, BUFFER_SIZE, BUFFER_SIZE);
-
         NetworkTestUtils.checkClientConnection(selector, node, 100, 10);
+
+        // Disable endpoint validation using null value, connection should succeed
+        String node2 = &quot;2&quot;;
+        sslClientConfigs.put(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, null);
+        createSelector(sslClientConfigs);
+        selector.connect(node2, addr, BUFFER_SIZE, BUFFER_SIZE);
+        NetworkTestUtils.checkClientConnection(selector, node2, 100, 10);
+
+        // Connection should fail with endpoint validation enabled
+        String node3 = &quot;3&quot;;
+        sslClientConfigs.put(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, &quot;HTTPS&quot;);
+        createSelector(sslClientConfigs);
+        selector.connect(node3, addr, BUFFER_SIZE, BUFFER_SIZE);
+        NetworkTestUtils.waitForChannelClose(selector, node3, ChannelState.State.AUTHENTICATION_FAILED);
+        selector.close();
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;br/&gt;
diff --git a/clients/src/test/java/org/apache/kafka/common/security/authenticator/SaslAuthenticatorTest.java b/clients/src/test/java/org/apache/kafka/common/security/authenticator/SaslAuthenticatorTest.java&lt;br/&gt;
index d7860ff6618..aa677db89a8 100644&lt;br/&gt;
&amp;#8212; a/clients/src/test/java/org/apache/kafka/common/security/authenticator/SaslAuthenticatorTest.java&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/common/security/authenticator/SaslAuthenticatorTest.java&lt;br/&gt;
@@ -472,7 +472,7 @@ public void testUnauthenticatedApiVersionsRequestOverSslHandshakeVersion0() thro&lt;br/&gt;
      */&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testUnauthenticatedApiVersionsRequestOverSslHandshakeVersion1() throws Exception &lt;/p&gt;
{
-        testUnauthenticatedApiVersionsRequest(SecurityProtocol.SASL_PLAINTEXT, (short) 1);
+        testUnauthenticatedApiVersionsRequest(SecurityProtocol.SASL_SSL, (short) 1);
     }

&lt;p&gt;     /**&lt;br/&gt;
@@ -1466,7 +1466,7 @@ private NioEchoServer createEchoServer(ListenerName listenerName, SecurityProtoc&lt;/p&gt;

&lt;p&gt;     private void createClientConnection(SecurityProtocol securityProtocol, String node) throws Exception &lt;/p&gt;
{
         createSelector(securityProtocol, saslClientConfigs);
-        InetSocketAddress addr = new InetSocketAddress(&quot;127.0.0.1&quot;, server.port());
+        InetSocketAddress addr = new InetSocketAddress(&quot;localhost&quot;, server.port());
         selector.connect(node, addr, BUFFER_SIZE, BUFFER_SIZE);
     }

&lt;p&gt;diff --git a/core/src/main/scala/kafka/admin/ConfigCommand.scala b/core/src/main/scala/kafka/admin/ConfigCommand.scala&lt;br/&gt;
index c19599d3cc0..d08e452f78c 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/admin/ConfigCommand.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/admin/ConfigCommand.scala&lt;br/&gt;
@@ -173,11 +173,13 @@ object ConfigCommand extends Config {&lt;br/&gt;
   private&lt;span class=&quot;error&quot;&gt;&amp;#91;admin&amp;#93;&lt;/span&gt; def parseConfigsToBeAdded(opts: ConfigCommandOptions): Properties = {&lt;br/&gt;
     val props = new Properties&lt;br/&gt;
     if (opts.options.has(opts.addConfig)) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;//split by commas, but avoid those in [], then into KV pairs&lt;br/&gt;
+      // Split list by commas, but avoid those in [], then into KV pairs&lt;br/&gt;
+      // Each KV pair is of format key=value, split them into key and value, using -1 as the limit for split() to&lt;br/&gt;
+      // include trailing empty strings. This is to support empty value (e.g. &apos;ssl.endpoint.identification.algorithm=&apos;)&lt;br/&gt;
       val pattern = &quot;(?=&lt;span class=&quot;error&quot;&gt;&amp;#91;^\\]&amp;#93;&lt;/span&gt;*(?:&lt;br class=&quot;atl-forced-newline&quot; /&gt;[|$))&quot;&lt;br/&gt;
       val configsToBeAdded = opts.options.valueOf(opts.addConfig)&lt;br/&gt;
         .split(&quot;,&quot; + pattern)&lt;/li&gt;
	&lt;li&gt;.map(_.split(&quot;&quot;&quot;\s*=\s*&quot;&quot;&quot; + pattern))&lt;br/&gt;
+        .map(_.split(&quot;&quot;&quot;\s*=\s*&quot;&quot;&quot; + pattern, -1))&lt;br/&gt;
       require(configsToBeAdded.forall(config =&amp;gt; config.length == 2), &quot;Invalid entity config: all configs to be added must be in the format \&quot;key=val\&quot;.&quot;)&lt;br/&gt;
       //Create properties, parsing square brackets from values if necessary&lt;br/&gt;
       configsToBeAdded.foreach(pair =&amp;gt; props.setProperty(pair(0).trim, pair(1).replaceAll(&quot;\\[?&lt;br class=&quot;atl-forced-newline&quot; /&gt;]?&quot;, &quot;&quot;).trim))&lt;br/&gt;
diff --git a/core/src/main/scala/kafka/server/KafkaConfig.scala b/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
index a78bb4d406f..19bb8074958 100755
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
@@ -208,6 +208,7 @@ object Defaults {&lt;br/&gt;
   val SslTruststoreType = SslConfigs.DEFAULT_SSL_TRUSTSTORE_TYPE&lt;br/&gt;
   val SslKeyManagerAlgorithm = SslConfigs.DEFAULT_SSL_KEYMANGER_ALGORITHM&lt;br/&gt;
   val SslTrustManagerAlgorithm = SslConfigs.DEFAULT_SSL_TRUSTMANAGER_ALGORITHM&lt;br/&gt;
+  val SslEndpointIdentificationAlgorithm = SslConfigs.DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM&lt;br/&gt;
   val SslClientAuthRequired = &quot;required&quot;&lt;br/&gt;
   val SslClientAuthRequested = &quot;requested&quot;&lt;br/&gt;
   val SslClientAuthNone = &quot;none&quot;&lt;br/&gt;
@@ -955,7 +956,7 @@ object KafkaConfig {&lt;br/&gt;
       .define(SslTruststorePasswordProp, PASSWORD, null, MEDIUM, SslTruststorePasswordDoc)&lt;br/&gt;
       .define(SslKeyManagerAlgorithmProp, STRING, Defaults.SslKeyManagerAlgorithm, MEDIUM, SslKeyManagerAlgorithmDoc)&lt;br/&gt;
       .define(SslTrustManagerAlgorithmProp, STRING, Defaults.SslTrustManagerAlgorithm, MEDIUM, SslTrustManagerAlgorithmDoc)&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;.define(SslEndpointIdentificationAlgorithmProp, STRING, null, LOW, SslEndpointIdentificationAlgorithmDoc)&lt;br/&gt;
+      .define(SslEndpointIdentificationAlgorithmProp, STRING, Defaults.SslEndpointIdentificationAlgorithm, LOW, SslEndpointIdentificationAlgorithmDoc)&lt;br/&gt;
       .define(SslSecureRandomImplementationProp, STRING, null, LOW, SslSecureRandomImplementationDoc)&lt;br/&gt;
       .define(SslClientAuthProp, STRING, Defaults.SslClientAuth, in(Defaults.SslClientAuthRequired, Defaults.SslClientAuthRequested, Defaults.SslClientAuthNone), MEDIUM, SslClientAuthDoc)&lt;br/&gt;
       .define(SslCipherSuitesProp, LIST, Collections.emptyList(), MEDIUM, SslCipherSuitesDoc)&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala b/core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala&lt;br/&gt;
index 66e98f5b1ce..8238650911c 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala&lt;br/&gt;
@@ -137,6 +137,20 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging 
{
     val deletedProps = ConfigCommand.parseConfigsToBeDeleted(createOpts)
     assertEquals(1, deletedProps.size)
     assertEquals(&quot;a&quot;, deletedProps.head)
+
+    createOpts = new ConfigCommandOptions(Array(&quot;--zookeeper&quot;, zkConnect,
+      &quot;--entity-name&quot;, &quot;x&quot;,
+      &quot;--entity-type&quot;, entityType,
+      &quot;--alter&quot;,
+      &quot;--add-config&quot;, &quot;a=b,c=,d=e,f=&quot;))
+    createOpts.checkArgs()
+
+    val addedProps2 = ConfigCommand.parseConfigsToBeAdded(createOpts)
+    assertEquals(4, addedProps2.size())
+    assertEquals(&quot;b&quot;, addedProps2.getProperty(&quot;a&quot;))
+    assertEquals(&quot;e&quot;, addedProps2.getProperty(&quot;d&quot;))
+    assertTrue(addedProps2.getProperty(&quot;c&quot;).isEmpty)
+    assertTrue(addedProps2.getProperty(&quot;f&quot;).isEmpty)
   }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   @Test(expected = classOf&lt;span class=&quot;error&quot;&gt;&amp;#91;IllegalArgumentException&amp;#93;&lt;/span&gt;)&lt;br/&gt;
diff --git a/docs/security.html b/docs/security.html&lt;br/&gt;
index 4fcbdad72a5..06dd8fbd1fc 100644&lt;br/&gt;
&amp;#8212; a/docs/security.html&lt;br/&gt;
+++ b/docs/security.html&lt;br/&gt;
@@ -52,11 +52,29 @@ &amp;lt;h3&amp;gt;&amp;lt;a id=&quot;security_ssl&quot; href=&quot;#security_ssl&quot;&amp;gt;7.2 Encryption and Authentication&lt;br/&gt;
                 &amp;lt;li&amp;gt;validity: the valid time of the certificate in days.&amp;lt;/li&amp;gt;&lt;br/&gt;
             &amp;lt;/ol&amp;gt;&lt;br/&gt;
             &amp;lt;br&amp;gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Note: By default the property &amp;lt;code&amp;gt;ssl.endpoint.identification.algorithm&amp;lt;/code&amp;gt; is not defined, so hostname verification is not performed. In order to enable hostname verification, set the following property:&lt;br/&gt;
+&lt;br/&gt;
+        &amp;lt;h5&amp;gt;&amp;lt;a id=&quot;security_confighostname&quot; href=&quot;#security_confighostname&quot;&amp;gt;Configuring Host Name Verification&amp;lt;/a&amp;gt;&amp;lt;/h5&amp;gt;&lt;br/&gt;
+        From Kafka version 2.0.0 onwards, host name verification of servers is enabled by default for client connections&lt;br/&gt;
+        as well as inter-broker connections to prevent man-in-the-middle attacks. Server host name verification may be disabled&lt;br/&gt;
+        by setting &amp;lt;code&amp;gt;ssl.endpoint.identification.algorithm&amp;lt;/code&amp;gt; to an empty string. For example,&lt;br/&gt;
+        &amp;lt;pre class=&quot;brush: text;&quot;&amp;gt;	ssl.endpoint.identification.algorithm=&amp;lt;/pre&amp;gt;&lt;br/&gt;
+        For dynamically configured broker listeners, hostname verification may be disabled using &amp;lt;code&amp;gt;kafka-configs.sh&amp;lt;/code&amp;gt;.&lt;br/&gt;
+        For example,&lt;br/&gt;
+        &amp;lt;pre class=&quot;brush: text;&quot;&amp;gt;&lt;br/&gt;
+        bin/kafka-configs.sh --bootstrap-server localhost:9093 --entity-type brokers --entity-name 0 --alter --add-config &quot;listener.name.internal.ssl.endpoint.identification.algorithm=&quot;&lt;br/&gt;
+        &amp;lt;/pre&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+        For older versions of Kafka, &amp;lt;code&amp;gt;ssl.endpoint.identification.algorithm&amp;lt;/code&amp;gt; is not defined by default, so host name&lt;br/&gt;
+        verification is not performed. The property should be set to &amp;lt;code&amp;gt;HTTPS&amp;lt;/code&amp;gt; to enable host name verification.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         &amp;lt;pre class=&quot;brush: text;&quot;&amp;gt;	ssl.endpoint.identification.algorithm=HTTPS &amp;lt;/pre&amp;gt;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Once enabled, clients will verify the server&apos;s fully qualified domain name (FQDN) against one of the following two fields:&lt;br/&gt;
+        Host name verification must be enabled to prevent man-in-the-middle attacks if server endpoints are not validated&lt;br/&gt;
+        externally.&lt;br/&gt;
+&lt;br/&gt;
+        &amp;lt;h5&amp;gt;&amp;lt;a id=&quot;security_configcerthostname&quot; href=&quot;#security_configcerthstname&quot;&amp;gt;Configuring Host Name In Certificates&amp;lt;/a&amp;gt;&amp;lt;/h5&amp;gt;&lt;br/&gt;
+        If host name verification is enabled, clients will verify the server&apos;s fully qualified domain name (FQDN) against one of&lt;br/&gt;
+        the following two fields:&lt;br/&gt;
         &amp;lt;ol&amp;gt;&lt;br/&gt;
             &amp;lt;li&amp;gt;Common Name (CN)&lt;br/&gt;
             &amp;lt;li&amp;gt;Subject Alternative Name (SAN)&lt;br/&gt;
diff --git a/docs/upgrade.html b/docs/upgrade.html&lt;br/&gt;
index 056fb8366e4..a399a620f40 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/docs/upgrade.html&lt;br/&gt;
+++ b/docs/upgrade.html&lt;br/&gt;
@@ -67,6 +67,7 @@ &amp;lt;h5&amp;gt;&amp;lt;a id=&quot;upgrade_200_notable&quot; href=&quot;#upgrade_200_notable&quot;&amp;gt;Notable changes in 2&lt;br/&gt;
 &amp;lt;ul&amp;gt;&lt;br/&gt;
     &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://cwiki.apache.org/confluence/x/oYtjB&quot;&amp;gt;KIP-186&amp;lt;/a&amp;gt; increases the default offset retention time from 1 day to 7 days. This makes it less likely to &quot;lose&quot; offsets in an application that commits infrequently. It also increases the active set of offsets and therefore can increase memory usage on the broker. Note that the console consumer currently enables offset commit by default and can be the source of a large number of offsets which this change will now preserve for 7 days instead of 1. You can preserve the existing behavior by setting the broker config &amp;lt;code&amp;gt;offsets.retention.minutes&amp;lt;/code&amp;gt; to 1440.&amp;lt;/li&amp;gt;&lt;br/&gt;
     &amp;lt;li&amp;gt;Support for Java 7 has been dropped, Java 8 is now the minimum version required.&amp;lt;/li&amp;gt;&lt;br/&gt;
+    &amp;lt;li&amp;gt; The default value for &amp;lt;code&amp;gt;ssl.endpoint.identification.algorithm&amp;lt;/code&amp;gt; was changed to &amp;lt;code&amp;gt;https&amp;lt;/code&amp;gt;, which performs hostname verification (man-in-the-middle attacks are possible otherwise). Set &amp;lt;code&amp;gt;ssl.endpoint.identification.algorithm&amp;lt;/code&amp;gt; to an empty string to restore the previous behaviour. &amp;lt;/li&amp;gt;&lt;br/&gt;
     &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-5674&quot;&amp;gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-5674&quot; title=&quot;max.connections.per.ip minimum value to be zero to allow IP address blocking&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-5674&quot;&gt;&lt;del&gt;KAFKA-5674&lt;/del&gt;&lt;/a&gt;&amp;lt;/a&amp;gt; extends the lower interval of &amp;lt;code&amp;gt;max.connections.per.ip minimum&amp;lt;/code&amp;gt; to zero and therefore allows IP-based filtering of inbound connections.&amp;lt;/li&amp;gt;&lt;br/&gt;
     &amp;lt;li&amp;gt;&amp;lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/KIP-272%3A+Add+API+version+tag+to+broker%27s+RequestsPerSec+metric&quot;&amp;gt;KIP-272&amp;lt;/a&amp;gt;&lt;br/&gt;
         added API version tag to the metric &amp;lt;code&amp;gt;kafka.network:type=RequestMetrics,name=RequestsPerSec,request=
{Produce|FetchConsumer|FetchFollower|...}
&lt;p&gt;&amp;lt;/code&amp;gt;.&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/integration/utils/KafkaEmbedded.java b/streams/src/test/java/org/apache/kafka/streams/integration/utils/KafkaEmbedded.java&lt;br/&gt;
index 55986bb5820..c884320fc1c 100644&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/integration/utils/KafkaEmbedded.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/integration/utils/KafkaEmbedded.java&lt;br/&gt;
@@ -87,7 +87,7 @@ public KafkaEmbedded(final Properties config, final MockTime time) throws IOExce&lt;br/&gt;
     private Properties effectiveConfigFrom(final Properties initialConfig) throws IOException 
{
         final Properties effectiveConfig = new Properties();
         effectiveConfig.put(KafkaConfig$.MODULE$.BrokerIdProp(), 0);
-        effectiveConfig.put(KafkaConfig$.MODULE$.HostNameProp(), &quot;127.0.0.1&quot;);
+        effectiveConfig.put(KafkaConfig$.MODULE$.HostNameProp(), &quot;localhost&quot;);
         effectiveConfig.put(KafkaConfig$.MODULE$.PortProp(), &quot;9092&quot;);
         effectiveConfig.put(KafkaConfig$.MODULE$.NumPartitionsProp(), 1);
         effectiveConfig.put(KafkaConfig$.MODULE$.AutoCreateTopicsEnableProp(), true);
@@ -100,7 +100,7 @@ private Properties effectiveConfigFrom(final Properties initialConfig) throws IO
     }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* This broker&apos;s `metadata.broker.list` value.  Example: `127.0.0.1:9092`.&lt;br/&gt;
+     * This broker&apos;s `metadata.broker.list` value.  Example: `localhost:9092`.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;&amp;lt;p&amp;gt;&lt;/li&gt;
	&lt;li&gt;You can use this to tell Kafka producers and consumers how to connect to this instance.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16655370" author="githubbot" created="Thu, 18 Oct 2018 15:02:08 +0000"  >&lt;p&gt;omkreddy closed pull request #1330: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-3665&quot; title=&quot;Default ssl.endpoint.identification.algorithm should be https&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-3665&quot;&gt;&lt;del&gt;KAFKA-3665&lt;/del&gt;&lt;/a&gt;; Default ssl.endpoint.identification.algorithm should be https&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/1330&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/1330&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java b/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java&lt;br/&gt;
index 1ccd039fb12..14963636955 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java&lt;br/&gt;
@@ -84,6 +84,7 @@&lt;/p&gt;

&lt;p&gt;     public static final String SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG = &quot;ssl.endpoint.identification.algorithm&quot;;&lt;br/&gt;
     public static final String SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC = &quot;The endpoint identification algorithm to validate server hostname using server certificate. &quot;;&lt;br/&gt;
+    public static final String DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM = &quot;https&quot;;&lt;/p&gt;

&lt;p&gt;     public static final String SSL_CLIENT_AUTH_CONFIG = &quot;ssl.client.auth&quot;;&lt;br/&gt;
     public static final String SSL_CLIENT_AUTH_DOC = &quot;Configures kafka broker to request client authentication.&quot;&lt;br/&gt;
@@ -109,6 +110,6 @@ public static void addClientSslSupport(ConfigDef config) &lt;/p&gt;
{
                 .define(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, ConfigDef.Type.PASSWORD, null, ConfigDef.Importance.HIGH, SslConfigs.SSL_TRUSTSTORE_PASSWORD_DOC)
                 .define(SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_KEYMANGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_KEYMANAGER_ALGORITHM_DOC)
                 .define(SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_TRUSTMANAGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_DOC)
-                .define(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, ConfigDef.Type.STRING, null, ConfigDef.Importance.LOW, SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC);
+                .define(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC);
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/core/src/main/scala/kafka/server/KafkaConfig.scala b/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
index f9a12a910fb..c575f0f7ccd 100755&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/server/KafkaConfig.scala&lt;br/&gt;
@@ -169,6 +169,7 @@ object Defaults {&lt;br/&gt;
   val SslTruststoreType = SslConfigs.DEFAULT_SSL_TRUSTSTORE_TYPE&lt;br/&gt;
   val SslKeyManagerAlgorithm = SslConfigs.DEFAULT_SSL_KEYMANGER_ALGORITHM&lt;br/&gt;
   val SslTrustManagerAlgorithm = SslConfigs.DEFAULT_SSL_TRUSTMANAGER_ALGORITHM&lt;br/&gt;
+  val SslEndpointIdentificationAlgorithm = SslConfigs.DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM&lt;br/&gt;
   val SslClientAuthRequired = &quot;required&quot;&lt;br/&gt;
   val SslClientAuthRequested = &quot;requested&quot;&lt;br/&gt;
   val SslClientAuthNone = &quot;none&quot;&lt;br/&gt;
@@ -705,7 +706,7 @@ object KafkaConfig {&lt;br/&gt;
       .define(SslTruststorePasswordProp, PASSWORD, null, MEDIUM, SslTruststorePasswordDoc)&lt;br/&gt;
       .define(SslKeyManagerAlgorithmProp, STRING, Defaults.SslKeyManagerAlgorithm, MEDIUM, SslKeyManagerAlgorithmDoc)&lt;br/&gt;
       .define(SslTrustManagerAlgorithmProp, STRING, Defaults.SslTrustManagerAlgorithm, MEDIUM, SslTrustManagerAlgorithmDoc)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;.define(SslEndpointIdentificationAlgorithmProp, STRING, null, LOW, SslEndpointIdentificationAlgorithmDoc)&lt;br/&gt;
+      .define(SslEndpointIdentificationAlgorithmProp, STRING, Defaults.SslEndpointIdentificationAlgorithm, LOW, SslEndpointIdentificationAlgorithmDoc)&lt;br/&gt;
       .define(SslClientAuthProp, STRING, Defaults.SslClientAuth, in(Defaults.SslClientAuthRequired, Defaults.SslClientAuthRequested, Defaults.SslClientAuthNone), MEDIUM, SslClientAuthDoc)&lt;br/&gt;
       .define(SslCipherSuitesProp, LIST, null, MEDIUM, SslCipherSuitesDoc)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/docs/upgrade.html b/docs/upgrade.html&lt;br/&gt;
index dec0808c2e3..986e8c23ac8 100644&lt;br/&gt;
&amp;#8212; a/docs/upgrade.html&lt;br/&gt;
+++ b/docs/upgrade.html&lt;br/&gt;
@@ -17,6 +17,12 @@&lt;/p&gt;

&lt;p&gt; &amp;lt;h3&amp;gt;&amp;lt;a id=&quot;upgrade&quot; href=&quot;#upgrade&quot;&amp;gt;1.5 Upgrading From Previous Versions&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;&lt;/p&gt;

&lt;p&gt;+&amp;lt;h5&amp;gt;&amp;lt;a id=&quot;upgrade_101_notable&quot; href=&quot;#upgrade_101_notable&quot;&amp;gt;Notable changes in 0.10.1.0&amp;lt;/a&amp;gt;&amp;lt;/h5&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
+&amp;lt;ul&amp;gt;&lt;br/&gt;
+    &amp;lt;li&amp;gt; The default value for &amp;lt;code&amp;gt;ssl.endpoint.identification.algorithm&amp;lt;/code&amp;gt; was changed to &amp;lt;code&amp;gt;https&amp;lt;/code&amp;gt;, which performs hostname verification (man-in-the-middle attacks are possible otherwise). Set &amp;lt;code&amp;gt;ssl.endpoint.identification.algorithm&amp;lt;/code&amp;gt; to an empty string to restore the previous behaviour. &amp;lt;/li&amp;gt;&lt;br/&gt;
+&amp;lt;/ul&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
 &amp;lt;h4&amp;gt;&amp;lt;a id=&quot;upgrade_10&quot; href=&quot;#upgrade_10&quot;&amp;gt;Upgrading from 0.8.x or 0.9.x to 0.10.0.0&amp;lt;/a&amp;gt;&amp;lt;/h4&amp;gt;&lt;br/&gt;
 0.10.0.0 has &amp;lt;a href=&quot;#upgrade_10_breaking&quot;&amp;gt;potential breaking changes&amp;lt;/a&amp;gt; (please review before upgrading) and&lt;br/&gt;
 there may be a &amp;lt;a href=&quot;#upgrade_10_performance_impact&quot;&amp;gt;performance impact during the upgrade&amp;lt;/a&amp;gt;. Because new protocols&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12965612">KAFKA-3667</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 4 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2x96n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>