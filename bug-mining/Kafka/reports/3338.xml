<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:31:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-14196] Duplicated consumption during rebalance, causing OffsetValidationTest to act flaky</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-14196</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Several flaky tests under OffsetValidationTest are indicating potential consumer duplication issue, when autocommit is enabled.&#160; I believe this is affecting&#160;&lt;b&gt;3.2&lt;/b&gt; and onward.&#160; Below shows the failure message:&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Total consumed records 3366 did not match consumed position 3331 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;After investigating the log, I discovered that the data consumed between the start of a rebalance event and the async commit was lost for those failing tests.&#160; In the example below, the rebalance event kicks in at around 1662054846995 (first record), and the async commit of the offset 3739 is completed at around 1662054847015 (right before partitions_revoked).&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
{&lt;span class=&quot;code-quote&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;:1662054846995,&lt;span class=&quot;code-quote&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;records_consumed&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:3,&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions&quot;&lt;/span&gt;:[{&lt;span class=&quot;code-quote&quot;&gt;&quot;topic&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_topic&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partition&quot;&lt;/span&gt;:0,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:3,&lt;span class=&quot;code-quote&quot;&gt;&quot;minOffset&quot;&lt;/span&gt;:3739,&lt;span class=&quot;code-quote&quot;&gt;&quot;maxOffset&quot;&lt;/span&gt;:3741}]}
{&lt;span class=&quot;code-quote&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;:1662054846998,&lt;span class=&quot;code-quote&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;records_consumed&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:2,&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions&quot;&lt;/span&gt;:[{&lt;span class=&quot;code-quote&quot;&gt;&quot;topic&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_topic&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partition&quot;&lt;/span&gt;:0,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:2,&lt;span class=&quot;code-quote&quot;&gt;&quot;minOffset&quot;&lt;/span&gt;:3742,&lt;span class=&quot;code-quote&quot;&gt;&quot;maxOffset&quot;&lt;/span&gt;:3743}]}
{&lt;span class=&quot;code-quote&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;:1662054847008,&lt;span class=&quot;code-quote&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;records_consumed&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:2,&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions&quot;&lt;/span&gt;:[{&lt;span class=&quot;code-quote&quot;&gt;&quot;topic&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_topic&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partition&quot;&lt;/span&gt;:0,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:2,&lt;span class=&quot;code-quote&quot;&gt;&quot;minOffset&quot;&lt;/span&gt;:3744,&lt;span class=&quot;code-quote&quot;&gt;&quot;maxOffset&quot;&lt;/span&gt;:3745}]}
{&lt;span class=&quot;code-quote&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;:1662054847016,&lt;span class=&quot;code-quote&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions_revoked&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions&quot;&lt;/span&gt;:[{&lt;span class=&quot;code-quote&quot;&gt;&quot;topic&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_topic&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partition&quot;&lt;/span&gt;:0}]}
{&lt;span class=&quot;code-quote&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;:1662054847031,&lt;span class=&quot;code-quote&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions_assigned&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions&quot;&lt;/span&gt;:[{&lt;span class=&quot;code-quote&quot;&gt;&quot;topic&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_topic&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partition&quot;&lt;/span&gt;:0}]}
{&lt;span class=&quot;code-quote&quot;&gt;&quot;timestamp&quot;&lt;/span&gt;:1662054847038,&lt;span class=&quot;code-quote&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;records_consumed&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:23,&lt;span class=&quot;code-quote&quot;&gt;&quot;partitions&quot;&lt;/span&gt;:[{&lt;span class=&quot;code-quote&quot;&gt;&quot;topic&quot;&lt;/span&gt;:&lt;span class=&quot;code-quote&quot;&gt;&quot;test_topic&quot;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&quot;partition&quot;&lt;/span&gt;:0,&lt;span class=&quot;code-quote&quot;&gt;&quot;count&quot;&lt;/span&gt;:23,&lt;span class=&quot;code-quote&quot;&gt;&quot;minOffset&quot;&lt;/span&gt;:3739,&lt;span class=&quot;code-quote&quot;&gt;&quot;maxOffset&quot;&lt;/span&gt;:3761}]} &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;A few things to note here:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Manually calling commitSync in the onPartitionsRevoke cb seems to alleviate the issue&lt;/li&gt;
	&lt;li&gt;Setting includeMetadataInTimeout to false also seems to alleviate the issue.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The above tries seems to suggest that contract between poll() and asyncCommit() is broken.&#160; AFAIK, we implicitly uses poll() to ack the previously fetched data, and the consumer would (try to) commit these offsets in the current poll() loop.&#160; However, it seems like as the poll continues to loop, the &quot;acked&quot; data isn&apos;t being committed.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;I believe this could be introduced in &#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-14024&quot; title=&quot;Consumer stuck during cooperative rebalance for Commit offset in onJoinPrepare&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-14024&quot;&gt;&lt;del&gt;KAFKA-14024&lt;/del&gt;&lt;/a&gt;, which originated from &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-13310&quot; title=&quot;KafkaConsumer cannot jump out of the poll method, and the consumer is blocked in the ConsumerCoordinator method maybeAutoCommitOffsetsSync(Timer timer). Cpu and traffic of  Broker&amp;#39;s side increase sharply&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-13310&quot;&gt;&lt;del&gt;KAFKA-13310&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;More specifically, (see the comments below), the ConsumerCoordinator will alway return before async commit, due to the previous incomplete commit.&#160; However, this is a bit contradictory here because:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;I think we want to commit asynchronously while the poll continues, and if we do that, we are back to &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-14024&quot; title=&quot;Consumer stuck during cooperative rebalance for Commit offset in onJoinPrepare&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-14024&quot;&gt;&lt;del&gt;KAFKA-14024&lt;/del&gt;&lt;/a&gt;, that the consumer will get rebalance timeout and get kicked out of the group.&lt;/li&gt;
	&lt;li&gt;But we also need to commit all the &quot;acked&quot; offsets before revoking the partition, and this has to be blocked.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;b&gt;Steps to Reproduce the Issue:&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Check out AK 3.2&lt;/li&gt;
	&lt;li&gt;Run this several times: (Recommend to only run runs with autocommit enabled in consumer_test.py to save time)
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
_DUCKTAPE_OPTIONS=&lt;span class=&quot;code-quote&quot;&gt;&quot;--debug&quot;&lt;/span&gt; TC_PATHS=&lt;span class=&quot;code-quote&quot;&gt;&quot;tests/kafkatest/tests/client/consumer_test.py::OffsetValidationTest.test_consumer_failure&quot;&lt;/span&gt; bash tests/docker/run_tests.sh &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;b&gt;Steps to Diagnose the Issue:&lt;/b&gt;&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Open the test results in&#160;&lt;b&gt;results/&lt;/b&gt;&lt;/li&gt;
	&lt;li&gt;Go to the consumer log.&#160; It might look like this&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
results/2022-09-03--005/OffsetValidationTest/test_consumer_failure/clean_shutdown=True.enable_autocommit=True.metadata_quorum=ZK/2/VerifiableConsumer-0-xxxxxxxxxx/dockerYY &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;3. Find the docker instance that has partition getting revoked and rejoined.&#160; Observed the offset before and after.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Propose Fixes:&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&#160;TBD&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/kafka/pull/12603&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/12603&lt;/a&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13479762">KAFKA-14196</key>
            <summary>Duplicated consumption during rebalance, causing OffsetValidationTest to act flaky</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="pnee">Philip Nee</assignee>
                                    <reporter username="pnee">Philip Nee</reporter>
                        <labels>
                            <label>new-consumer-threading-should-fix</label>
                    </labels>
                <created>Fri, 2 Sep 2022 02:28:39 +0000</created>
                <updated>Fri, 20 Oct 2023 00:37:26 +0000</updated>
                            <resolved>Tue, 13 Sep 2022 08:11:32 +0000</resolved>
                                    <version>3.2.1</version>
                                    <fixVersion>3.2.3</fixVersion>
                    <fixVersion>3.3.0</fixVersion>
                                    <component>clients</component>
                    <component>consumer</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="17600166" author="JIRAUSER283568" created="Mon, 5 Sep 2022 03:31:02 +0000"  >&lt;p&gt;If I understand this correctly: Seems like this is introduced in &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-14024&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-14024&lt;/a&gt;, which originated from &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-13310&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-13310&lt;/a&gt;.&#160; I think the cause of the flakiness/duplication is, the consumer is busy waiting for the prior async commit to complete (in order to complete the rebalance process), while fetching new data.&#160; After the async complete finished, the partition gets revoked, and the fetch progress will be lost, and eventually causes duplicated consumption.&lt;/p&gt;

&lt;p&gt;A few comments:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Do we want to continue to fetch, while waiting for the async commit to complete? I believe this is the expectation of the new poll API.&lt;/li&gt;
	&lt;li&gt;If we don&apos;t want to block consumer from fetching, then we will need to continue to commit asynchronously.&#160; I see this could be problematic, as the consumer could stuck in the poll loop while busy catching up with committing the fetched data, and never complete the rebalance process.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="17600552" author="JIRAUSER283568" created="Tue, 6 Sep 2022 02:31:02 +0000"  >&lt;p&gt;Kind of originated from this commit: &lt;a href=&quot;https://github.com/apache/kafka/pull/12349/files&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/12349/files&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17600675" author="showuon" created="Tue, 6 Sep 2022 08:50:09 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnee&quot; class=&quot;user-hover&quot; rel=&quot;pnee&quot;&gt;pnee&lt;/a&gt; , thanks for the analysis. Yes, we forgot about during the following poll, the offset might advance while we&apos;re waiting for the old async offset commit completion.&lt;/p&gt;

&lt;p&gt;Actually, while checking the code, even if we don&apos;t do the change for &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-14024&quot; title=&quot;Consumer stuck during cooperative rebalance for Commit offset in onJoinPrepare&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-14024&quot;&gt;&lt;del&gt;KAFKA-14024&lt;/del&gt;&lt;/a&gt;,and &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-13310&quot; title=&quot;KafkaConsumer cannot jump out of the poll method, and the consumer is blocked in the ConsumerCoordinator method maybeAutoCommitOffsetsSync(Timer timer). Cpu and traffic of  Broker&amp;#39;s side increase sharply&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-13310&quot;&gt;&lt;del&gt;KAFKA-13310&lt;/del&gt;&lt;/a&gt;, (that is, changing sync commit to async commit) the issue will still happen, just not that easily. The issue is, in the consumer#poll process, we do onJoinPrepare (i.e. commit the offset), and then fetch new records. I&apos;m thinking we should have a way to terminate poll process to avoid it keep fetching new records and return.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Maybe in `KafkaConsumer#updateAssignmentMetadataIfNeeded`, we passed in a parameter to allow the `onJoinPrepare` method to change the flag to notify if we need to terminate the poll and not to fetch records. WDYT?&lt;/p&gt;

&lt;p&gt;cc &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;&#160;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=dajac&quot; class=&quot;user-hover&quot; rel=&quot;dajac&quot;&gt;dajac&lt;/a&gt;&#160; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=aiquestion&quot; class=&quot;user-hover&quot; rel=&quot;aiquestion&quot;&gt;aiquestion&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17600897" author="JIRAUSER283568" created="Tue, 6 Sep 2022 17:00:50 +0000"  >&lt;p&gt;Thanks Luke, per your suggestion, could you elaborate more about the reason to terminate the poll?&lt;/p&gt;

&lt;p&gt;I&apos;ve got a few questions to clarify here:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;I don&apos;t think we need to pause the fetch if the previous async commit (autocommit) hasn&apos;t yet go through, for the normal situation (not rebalancing)? Because as long as we are sending out the commit, I think we could tentatively assume the acked data has been committed. Am I right?&lt;/li&gt;
	&lt;li&gt;I think we only need to pause the fetch, if there&apos;s a rebalance process taking place, because it only waits for the current in-flight commit, then revoke the partition.&#160; Once the partition is revoked, I don&apos;t think we can do anything about the uncommitted data.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;And because this regression was caused by the &quot;rebalancing internal state&quot; (pardon me if the words use is confusing), do you think it might be worth exposing the rebalance internal states? and perhaps adding a state to represent the current rebalancing progress, to prevent more fetching from happening during onJoinPrepare?&lt;/p&gt;</comment>
                            <comment id="17600985" author="guozhang" created="Tue, 6 Sep 2022 21:03:04 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnee&quot; class=&quot;user-hover&quot; rel=&quot;pnee&quot;&gt;pnee&lt;/a&gt; Thanks for reporting this. While reviewing &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-13310&quot; title=&quot;KafkaConsumer cannot jump out of the poll method, and the consumer is blocked in the ConsumerCoordinator method maybeAutoCommitOffsetsSync(Timer timer). Cpu and traffic of  Broker&amp;#39;s side increase sharply&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-13310&quot;&gt;&lt;del&gt;KAFKA-13310&lt;/del&gt;&lt;/a&gt; I have realized this, but as Luke said this is not a new regression (we would potentially have duplicates even before this, since as we commit sync, and if the commit fails, we still log a warning and move forward with the revocation, in which case we would also have duplicates), I suggested we add a TODO there indicating it&apos;s sub-optimal but is allowed under at least once semantics.&lt;/p&gt;

&lt;p&gt;I think in the long run, as we move the rebalancing related procedure all to the background thread, this would no longer be an issue since between the time background thread received an response telling it to start rebalancing (of which, the first step is to potentially revoking partitions in `onJoinPrepare`), and the time after the auto commit has been completed, the background thread could simply mark those revoking partitions as &quot;not retrievable&quot; so that calling thread&apos;s `poll` calls would not return any more data for those partitions. Right?&lt;/p&gt;

&lt;p&gt;If that&apos;s the case, then we only need to consider before that comes, what we should do with this. Like I said, the behaviors before are 1) we commit sync, and even if it fails we still move forward, which would cause duplicates, or 2) we commit async so that `poll` timeout could be respected, but we would still potentially return data for those revoking partitions. I&apos;m thinking what about just taking the middle ground: we still commit async, while at the same time mark those revoking partitions as &quot;not retrievable&quot; to not return any more data, note this would still not forbid duplicates completely, but would basically take us to where we were in the likelihood of the duplicates. And then we rely on the threading remodeling (there&apos;s a WIP page that Philip would be sending out soon) to completely resolve this issue.&lt;/p&gt;</comment>
                            <comment id="17601095" author="showuon" created="Wed, 7 Sep 2022 01:48:57 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=pnee&quot; class=&quot;user-hover&quot; rel=&quot;pnee&quot;&gt;pnee&lt;/a&gt;&#160;&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;I don&apos;t think we need to pause the fetch if the previous async commit (autocommit) hasn&apos;t yet go through, for the normal situation (not rebalancing)? Because as long as we are sending out the commit, I think we could tentatively assume the acked data has been committed. Am I right?&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&#160;--&amp;gt; correct. for normal situation (not rebalancing), we don&apos;t pause anything&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;I think we only need to pause the fetch, if there&apos;s a rebalance process taking place, because it only waits for the current in-flight commit, then revoke the partition.&#160; Once the partition is revoked, I don&apos;t think we can do anything about the uncommitted data.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;--&amp;gt; correct.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; , thanks for the suggestion.&lt;/p&gt;

&lt;p&gt;&amp;gt; I suggested we add a TODO there indicating it&apos;s sub-optimal but is allowed under at least once semantics.&lt;/p&gt;

&lt;p&gt;Agree!&lt;/p&gt;

&lt;p&gt;&amp;gt; we still commit async, while at the same time mark those revoking partitions as &quot;not retrievable&quot; to not return any more data&lt;/p&gt;

&lt;p&gt;Sounds good to me!&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;From Philip:&lt;/p&gt;

&lt;p&gt;&amp;gt; And because this regression was caused by the &quot;rebalancing internal state&quot; (pardon me if the words use is confusing), do you think it might be worth exposing the rebalance internal states? and perhaps adding a state to represent the current rebalancing progress, to prevent more fetching from happening during onJoinPrepare?&lt;/p&gt;

&lt;p&gt;I think we can just `pause` the SubscriptionState of the partitions that we&apos;re going to revoked. From the javadoc:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
/**
 * Suspend fetching from the requested partitions. Future calls to {@link #poll(Duration)} will not &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;
 * any records from these partitions until they have been resumed using {@link #resume(Collection)}.
 * Note that &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; method does not affect partition subscription. In particular, it does not cause a group
 * rebalance when automatic assignment is used.
 *
 * Note: Rebalance will not preserve the pause/resume state.
 * @param partitions The partitions which should be paused
 * @&lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IllegalStateException &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; any of the provided partitions are not currently assigned to &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; consumer
 */
@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void pause(Collection&amp;lt;TopicPartition&amp;gt; partitions) {&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;I think that&apos;s what we want, right?&lt;/p&gt;</comment>
                            <comment id="17601379" author="JIRAUSER283568" created="Wed, 7 Sep 2022 16:10:22 +0000"  >&lt;p&gt;Thanks Luke and GW, it looks like we could just pause it, but I&apos;ll test it out to see if that does what we want... I&apos;ll get back to you guys soon. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="17601523" author="JIRAUSER283568" created="Wed, 7 Sep 2022 21:59:12 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; - I think pausing should probably work, and it&apos;s also kind of convenient because the partition revocation will unpausing these partition automatically.&#160; Let me know if you think the draft is ok, I&apos;ll add tests later on: &lt;a href=&quot;https://github.com/apache/kafka/pull/12603&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/12603&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Though a few questions here:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Should we consider the difference between cooperative and eager protocol.&#160; Because, cooperative doesn&apos;t revoke all partitions.&#160; However, I worry that the subscription might change during the onJoinPrepare, so I meant there could be edge cases we need to handle here.&lt;/li&gt;
	&lt;li&gt;I believe this only applies to autocommit enabled.&#160; I think for non-autocommit case, user should handle the offset during the revocation, so we are good there?&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="17601609" author="showuon" created="Thu, 8 Sep 2022 03:29:50 +0000"  >&lt;ol&gt;
	&lt;li&gt;Should we consider the difference between cooperative and eager protocol.&#160; Because, cooperative doesn&apos;t revoke all partitions.&#160; However, I worry that the subscription might change during the onJoinPrepare, so I meant there could be edge cases we need to handle here.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;--&amp;gt; I think we should consider the difference between cooperative and eager protocol, because one of the purpose for cooperative rebalance is to allow &quot;non-revoking&quot; partitions can keep processing during rebalance. About the edge case, I think that&apos;s fine because in the your PR, we&apos;ll check and pause the partitions each time we enter onJoinPrepare, right? So, even if there&apos;s subscription change while we&apos;re waiting commitAsync, we can pause the updated subscription partitions in onJoinPrepare each time. Besides, that&apos;s really rare. WDYT?&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;I believe this only applies to autocommit enabled.&#160; I think for non-autocommit case, user should handle the offset during the revocation, so we are good there?&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;--&amp;gt; Yes, we only need to worry about autocmmit enabled case&lt;/p&gt;</comment>
                            <comment id="17602049" author="guozhang" created="Thu, 8 Sep 2022 23:59:28 +0000"  >&lt;p&gt;Thanks Philip, and regarding your two questions above I agree with &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=showuon&quot; class=&quot;user-hover&quot; rel=&quot;showuon&quot;&gt;showuon&lt;/a&gt;&apos;s thoughts as well. Especially for 1), I think even if subscriptions changed in between consecutive onJoinPrepare, as long as they will not change the assigned partitions (i.e. as long as `assignFromSubscribed()` has not called) I think we are fine, since the returned records depend on that assigned partitions.&lt;/p&gt;</comment>
                            <comment id="17602906" author="ijuma" created="Sun, 11 Sep 2022 19:35:32 +0000"  >&lt;p&gt;To clarify, this was introduced in 3.2.1 (not 3.2.0), correct?&lt;/p&gt;

&lt;p&gt;Also, this is currently marked as a blocker. Is there a crisp description of the regression?&lt;/p&gt;</comment>
                            <comment id="17602912" author="JIRAUSER283568" created="Sun, 11 Sep 2022 21:38:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ijuma&quot; class=&quot;user-hover&quot; rel=&quot;ijuma&quot;&gt;ijuma&lt;/a&gt; - I think that&apos;s right, according to the &lt;a href=&quot;https://downloads.apache.org/kafka/3.2.1/RELEASE_NOTES.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;release notes&lt;/a&gt; (I see 10424 there).&#160; I can add the description but I don&apos;t really know where, do you mean by updating the description/title of this ticket?&lt;/p&gt;</comment>
                            <comment id="17603328" author="hachikuji" created="Tue, 13 Sep 2022 04:14:52 +0000"  >&lt;p&gt;&amp;gt;&#160; Also, this is currently marked as a blocker. Is there a crisp description of the regression?&lt;/p&gt;

&lt;p&gt;Prior to revocation, eager rebalance strategies will attempt to auto-commit offsets before revoking partitions and joining the rebalance. Originally this logic was synchronous, which meant there was no opportunity for additional data to be returned before the revocation completed. This changed when we introduced asynchronous offset commit logic. Any progress made between the time the asynchronous offset commit was sent and the revocation completed would be lost. This results in duplicate consumption.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 9 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z189bc:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>