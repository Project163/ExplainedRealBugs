<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:05:55 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6383] StreamThread.shutdown doesn&apos;t clean up completely when called before StreamThread.start</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6383</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;The following code leaks a producer network thread:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
ks = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KafkaStreams(...);
ks.close();
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The underlying issue is that KafkaStreams creates a bunch of StreamsThreads via StreamThread.create, which in turn creates a bunch of stuff (including a producer). These resources are cleaned up only when the thread exits. So if the thread was never started, then they are never cleaned up. StreamThread.shutdown should clean up if it sees that the thread has never been started.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13125752">KAFKA-6383</key>
            <summary>StreamThread.shutdown doesn&apos;t clean up completely when called before StreamThread.start</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rohanpd">Rohan Desai</assignee>
                                    <reporter username="rohanpd">Rohan Desai</reporter>
                        <labels>
                    </labels>
                <created>Tue, 19 Dec 2017 00:04:22 +0000</created>
                <updated>Thu, 11 Jan 2018 00:25:03 +0000</updated>
                            <resolved>Thu, 11 Jan 2018 00:25:03 +0000</resolved>
                                    <version>1.0.0</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16297249" author="githubbot" created="Tue, 19 Dec 2017 18:49:11 +0000"  >&lt;p&gt;GitHub user rodesai opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/4343&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4343&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6383&quot; title=&quot;StreamThread.shutdown doesn&amp;#39;t clean up completely when called before StreamThread.start&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6383&quot;&gt;&lt;del&gt;KAFKA-6383&lt;/del&gt;&lt;/a&gt;: complete shutdown for CREATED StreamThreads&lt;/p&gt;

&lt;p&gt;    When transitioning StreamThread from CREATED to PENDING_SHUTDOWN&lt;br/&gt;
    free up resources from the caller, rather than the stream thread,&lt;br/&gt;
    since in this case the stream thread was never actually started.&lt;/p&gt;

&lt;p&gt;    In KakfaStreams.close, shut down the streams threads from the&lt;br/&gt;
    close thread. StreamThread.shutdown may now block, so call this&lt;br/&gt;
    from the close thread so that the timeout is honored.&lt;/p&gt;

&lt;p&gt;    *More detailed description of your change,&lt;br/&gt;
    if necessary. The PR title and PR message become&lt;br/&gt;
    the squashed commit message, so use a separate&lt;br/&gt;
    comment to ping reviewers.*&lt;/p&gt;

&lt;p&gt;    *Summary of testing strategy (including rationale)&lt;br/&gt;
    for the feature or bug fix. Unit and/or integration&lt;br/&gt;
    tests are expected for any behaviour change and&lt;br/&gt;
    system tests should be considered for larger changes.*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/rodesai/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/rodesai/kafka&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6383&quot; title=&quot;StreamThread.shutdown doesn&amp;#39;t clean up completely when called before StreamThread.start&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6383&quot;&gt;&lt;del&gt;KAFKA-6383&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/4343.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4343.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #4343&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit ab98a90027189dc12e3df99caf3d4f2aab8fefa0&lt;br/&gt;
Author: Rohan Desai &amp;lt;desai.p.rohan@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-12-19T18:14:20Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6383&quot; title=&quot;StreamThread.shutdown doesn&amp;#39;t clean up completely when called before StreamThread.start&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6383&quot;&gt;&lt;del&gt;KAFKA-6383&lt;/del&gt;&lt;/a&gt;: complete shutdown for CREATED StreamThreads&lt;/p&gt;

&lt;p&gt;    When transitioning StreamThread from CREATED to PENDING_SHUTDOWN&lt;br/&gt;
    free up resources from the caller, rather than the stream thread,&lt;br/&gt;
    since in this case the stream thread was never actually started.&lt;/p&gt;

&lt;p&gt;    In KakfaStreams.close, shut down the streams threads from the&lt;br/&gt;
    close thread. StreamThread.shutdown may now block, so call this&lt;br/&gt;
    from the close thread so that the timeout is honored.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16297675" author="guozhang" created="Wed, 20 Dec 2017 00:13:05 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rohanpd&quot; class=&quot;user-hover&quot; rel=&quot;rohanpd&quot;&gt;rohanpd&lt;/a&gt; I have added you to the contributor list, you can assign yourself to JIRAs now.&lt;/p&gt;</comment>
                            <comment id="16308405" author="githubbot" created="Tue, 2 Jan 2018 17:32:20 +0000"  >&lt;p&gt;guozhangwang closed pull request #4343: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6383&quot; title=&quot;StreamThread.shutdown doesn&amp;#39;t clean up completely when called before StreamThread.start&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6383&quot;&gt;&lt;del&gt;KAFKA-6383&lt;/del&gt;&lt;/a&gt;: complete shutdown for CREATED StreamThreads&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4343&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4343&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
index 696081d36c7..ff440cc49a3 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
@@ -173,23 +173,26 @@ public State state() {&lt;br/&gt;
     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Sets the state&lt;/li&gt;
	&lt;li&gt;@param newState New state&lt;br/&gt;
+     * @return The state prior to the call to setState, or null if the transition is invalid&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;boolean setState(final State newState) {&lt;/li&gt;
	&lt;li&gt;final State oldState = state;&lt;br/&gt;
+    State setState(final State newState) {&lt;br/&gt;
+        final State oldState;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         synchronized (stateLock) {&lt;br/&gt;
+            oldState = state;&lt;br/&gt;
+&lt;br/&gt;
             if (state == State.PENDING_SHUTDOWN &amp;amp;&amp;amp; newState != State.DEAD) &lt;/p&gt;
{
                 // when the state is already in PENDING_SHUTDOWN, all other transitions will be
                 // refused but we do not throw exception here
-                return false;
+                return null;
             }
&lt;p&gt; else if (state == State.DEAD) &lt;/p&gt;
{
                 // when the state is already in NOT_RUNNING, all its transitions
                 // will be refused but we do not throw exception here
-                return false;
+                return null;
             }
&lt;p&gt; else if (state == State.PARTITIONS_REVOKED &amp;amp;&amp;amp; newState == State.PARTITIONS_REVOKED) &lt;/p&gt;
{
                 // when the state is already in PARTITIONS_REVOKED, its transition to itself will be
                 // refused but we do not throw exception here
-                return false;
+                return null;
             }
&lt;p&gt; else if (!state.isValidTransition(newState)) {&lt;br/&gt;
                 log.error(&quot;Unexpected state transition from {} to {}&quot;, oldState, newState);&lt;br/&gt;
                 throw new StreamsException(logPrefix + &quot;Unexpected state transition from &quot; + oldState + &quot; to &quot; + newState);&lt;br/&gt;
@@ -209,7 +212,7 @@ boolean setState(final State newState) &lt;/p&gt;
{
             stateListener.onChange(this, state, oldState);
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return true;&lt;br/&gt;
+        return oldState;&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     public boolean isRunningAndNotRebalancing() {&lt;br/&gt;
@@ -251,7 +254,7 @@ public void onPartitionsAssigned(final Collection&amp;lt;TopicPartition&amp;gt; assignment) {&lt;/p&gt;

&lt;p&gt;             final long start = time.milliseconds();&lt;br/&gt;
             try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (!streamThread.setState(State.PARTITIONS_ASSIGNED)) {&lt;br/&gt;
+                if (streamThread.setState(State.PARTITIONS_ASSIGNED) == null) 
{
                     return;
                 }
&lt;p&gt;                 taskManager.createTasks(assignment);&lt;br/&gt;
@@ -281,7 +284,7 @@ public void onPartitionsRevoked(final Collection&amp;lt;TopicPartition&amp;gt; assignment) {&lt;br/&gt;
                 taskManager.activeTaskIds(),&lt;br/&gt;
                 taskManager.standbyTaskIds());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (streamThread.setState(State.PARTITIONS_REVOKED)) {&lt;br/&gt;
+            if (streamThread.setState(State.PARTITIONS_REVOKED) != null) {&lt;br/&gt;
                 final long start = time.milliseconds();&lt;br/&gt;
                 try {&lt;br/&gt;
                     // suspend active tasks&lt;br/&gt;
@@ -714,7 +717,11 @@ public StreamThread(final Time time,&lt;br/&gt;
     @Override&lt;br/&gt;
     public void run() {&lt;br/&gt;
         log.info(&quot;Starting&quot;);&lt;/li&gt;
	&lt;li&gt;setState(State.RUNNING);&lt;br/&gt;
+        if (setState(State.RUNNING) == null) 
{
+            log.info(&quot;StreamThread already shutdown. Not running&quot;);
+            completeShutdown(true);
+            return;
+        }
&lt;p&gt;         boolean cleanRun = false;&lt;br/&gt;
         try {&lt;br/&gt;
             runLoop();&lt;br/&gt;
@@ -1088,7 +1095,11 @@ private long computeLatency() {&lt;br/&gt;
      */&lt;br/&gt;
     public void shutdown() {&lt;br/&gt;
         log.info(&quot;Informed to shut down&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;setState(State.PENDING_SHUTDOWN);&lt;br/&gt;
+        State oldState = setState(State.PENDING_SHUTDOWN);&lt;br/&gt;
+        if (oldState == State.CREATED) 
{
+            // Start so that we shutdown on the thread
+            this.start();
+        }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private void completeShutdown(final boolean cleanRun) {&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
index d70c8f393e4..bdc1c00153f 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
@@ -274,7 +274,11 @@ void shutdown(final boolean clean) {&lt;br/&gt;
         standby.close(clean);&lt;/p&gt;

&lt;p&gt;         // remove the changelog partitions from restore consumer&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;restoreConsumer.unsubscribe();&lt;br/&gt;
+        try 
{
+            restoreConsumer.unsubscribe();
+        }
&lt;p&gt; catch (final RuntimeException fatalException) &lt;/p&gt;
{
+            firstException.compareAndSet(null, fatalException);
+        }
&lt;p&gt;         taskCreator.close();&lt;br/&gt;
         standbyTaskCreator.close();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java b/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java&lt;br/&gt;
index 8746c62a50f..a2084b02aea 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java&lt;br/&gt;
@@ -16,6 +16,7 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.clients.producer.MockProducer;&lt;br/&gt;
 import org.apache.kafka.common.Metric;&lt;br/&gt;
 import org.apache.kafka.common.MetricName;&lt;br/&gt;
 import org.apache.kafka.common.config.ConfigException;&lt;br/&gt;
@@ -31,6 +32,7 @@&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.GlobalStreamThread;&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.StreamThread;&lt;br/&gt;
 import org.apache.kafka.test.IntegrationTest;&lt;br/&gt;
+import org.apache.kafka.test.MockClientSupplier;&lt;br/&gt;
 import org.apache.kafka.test.MockMetricsReporter;&lt;br/&gt;
 import org.apache.kafka.test.MockStateRestoreListener;&lt;br/&gt;
 import org.apache.kafka.test.TestCondition;&lt;br/&gt;
@@ -113,6 +115,28 @@ public void testStateCloseAfterCreate() &lt;/p&gt;
{
         Assert.assertEquals(KafkaStreams.State.NOT_RUNNING, streams.state());
     }

&lt;p&gt;+    @Test&lt;br/&gt;
+    public void shouldCleanupResourcesOnCloseWithoutPreviousStart() throws Exception {&lt;br/&gt;
+        final StreamsBuilder builder = new StreamsBuilder();&lt;br/&gt;
+        builder.globalTable(&quot;anyTopic&quot;);&lt;br/&gt;
+        MockClientSupplier clientSupplier = new MockClientSupplier();&lt;br/&gt;
+        final KafkaStreams streams = new KafkaStreams(builder.build(), new StreamsConfig(props), clientSupplier);&lt;br/&gt;
+        streams.close();&lt;br/&gt;
+        TestUtils.waitForCondition(new TestCondition() {&lt;br/&gt;
+            @Override&lt;br/&gt;
+            public boolean conditionMet() &lt;/p&gt;
{
+                return streams.state() == KafkaStreams.State.NOT_RUNNING;
+            }
&lt;p&gt;+        }, 10 * 1000, &quot;Streams never stopped.&quot;);&lt;br/&gt;
+&lt;br/&gt;
+        // Ensure that any created clients are closed&lt;br/&gt;
+        assertTrue(clientSupplier.consumer.closed());&lt;br/&gt;
+        assertTrue(clientSupplier.restoreConsumer.closed());&lt;br/&gt;
+        for (MockProducer p : clientSupplier.producers) &lt;/p&gt;
{
+            assertTrue(p.closed());
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testStateThreadClose() throws Exception {&lt;br/&gt;
         final StreamsBuilder builder = new StreamsBuilder();&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java&lt;br/&gt;
index 8bcd6fb4ed4..fca380fac2e 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java&lt;br/&gt;
@@ -438,8 +438,13 @@ public void shouldShutdownTaskManagerOnClose() throws InterruptedException {&lt;br/&gt;
         EasyMock.expectLastCall();&lt;br/&gt;
         EasyMock.replay(taskManager, consumer);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;StreamThread.StreamsMetricsThreadImpl streamsMetrics = new StreamThread.StreamsMetricsThreadImpl(metrics, &quot;&quot;, &quot;&quot;, Collections.&amp;lt;String, String&amp;gt;emptyMap());&lt;/li&gt;
	&lt;li&gt;final StreamThread thread = new StreamThread(mockTime,&lt;br/&gt;
+        final StreamThread.StreamsMetricsThreadImpl streamsMetrics = new StreamThread.StreamsMetricsThreadImpl(&lt;br/&gt;
+                metrics,&lt;br/&gt;
+                &quot;&quot;,&lt;br/&gt;
+                &quot;&quot;,&lt;br/&gt;
+                Collections.&amp;lt;String, String&amp;gt;emptyMap());&lt;br/&gt;
+        final StreamThread thread = new StreamThread(&lt;br/&gt;
+                mockTime,&lt;br/&gt;
                 config,&lt;br/&gt;
                 consumer,&lt;br/&gt;
                 consumer,&lt;br/&gt;
@@ -455,6 +460,40 @@ public void shouldShutdownTaskManagerOnClose() throws InterruptedException 
{
         EasyMock.verify(taskManager);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    @Test&lt;br/&gt;
+    public void shouldShutdownTaskManagerOnCloseWithoutStart() {&lt;br/&gt;
+        final Consumer&amp;lt;byte[], byte[]&amp;gt; consumer = EasyMock.createNiceMock(Consumer.class);&lt;br/&gt;
+        final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);&lt;br/&gt;
+        taskManager.shutdown(true);&lt;br/&gt;
+        EasyMock.expectLastCall();&lt;br/&gt;
+        EasyMock.replay(taskManager, consumer);&lt;br/&gt;
+&lt;br/&gt;
+        final StreamThread.StreamsMetricsThreadImpl streamsMetrics = new StreamThread.StreamsMetricsThreadImpl(&lt;br/&gt;
+                metrics,&lt;br/&gt;
+                &quot;&quot;,&lt;br/&gt;
+                &quot;&quot;,&lt;br/&gt;
+                Collections.&amp;lt;String, String&amp;gt;emptyMap());&lt;br/&gt;
+        final StreamThread thread = new StreamThread(&lt;br/&gt;
+                mockTime,&lt;br/&gt;
+                config,&lt;br/&gt;
+                consumer,&lt;br/&gt;
+                consumer,&lt;br/&gt;
+                null,&lt;br/&gt;
+                taskManager,&lt;br/&gt;
+                streamsMetrics,&lt;br/&gt;
+                internalTopologyBuilder,&lt;br/&gt;
+                clientId,&lt;br/&gt;
+                new LogContext(&quot;&quot;));&lt;br/&gt;
+        thread.shutdown();&lt;br/&gt;
+        try &lt;/p&gt;
{
+            thread.join(1000);
+        }
&lt;p&gt; catch (final InterruptedException e) &lt;/p&gt;
{
+            fail(&quot;Join interrupted&quot;);
+        }
&lt;p&gt;+        assertFalse(thread.isAlive());&lt;br/&gt;
+        EasyMock.verify(taskManager);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldNotNullPointerWhenStandbyTasksAssignedAndNoStateStoresForTopology() throws InterruptedException {&lt;br/&gt;
         internalTopologyBuilder.addSource(null, &quot;name&quot;, null, null, null, &quot;topic&quot;);&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16308733" author="githubbot" created="Tue, 2 Jan 2018 21:27:17 +0000"  >&lt;p&gt;rodesai opened a new pull request #4378: Revert &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6383&quot; title=&quot;StreamThread.shutdown doesn&amp;#39;t clean up completely when called before StreamThread.start&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6383&quot;&gt;&lt;del&gt;KAFKA-6383&lt;/del&gt;&lt;/a&gt;: complete shutdown for CREATED StreamThreads (#4343)&quot;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4378&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4378&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   This reverts commit 47db063c310cf47e4c544196acab2abfe62977b0.&lt;/p&gt;

&lt;p&gt;   *More detailed description of your change,&lt;br/&gt;
   if necessary. The PR title and PR message become&lt;br/&gt;
   the squashed commit message, so use a separate&lt;br/&gt;
   comment to ping reviewers.*&lt;/p&gt;

&lt;p&gt;   *Summary of testing strategy (including rationale)&lt;br/&gt;
   for the feature or bug fix. Unit and/or integration&lt;br/&gt;
   tests are expected for any behaviour change and&lt;br/&gt;
   system tests should be considered for larger changes.*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16308794" author="rohanpd" created="Tue, 2 Jan 2018 22:02:52 +0000"  >&lt;p&gt;I missed a race condition in my fix. If we start and then shutdown a streams thread without the streams thread running in between, then shutdown() throws an IllegalThreadStateException. This happens because shutdown() uses StreamThread.state to decide whether to call start(), and the state is transitioned from run which may not have executed yet.&lt;/p&gt;</comment>
                            <comment id="16308810" author="githubbot" created="Tue, 2 Jan 2018 22:24:09 +0000"  >&lt;p&gt;rodesai closed pull request #4378: Revert &quot;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6383&quot; title=&quot;StreamThread.shutdown doesn&amp;#39;t clean up completely when called before StreamThread.start&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6383&quot;&gt;&lt;del&gt;KAFKA-6383&lt;/del&gt;&lt;/a&gt;: complete shutdown for CREATED StreamThreads (#4343)&quot;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4378&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4378&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
index ff440cc49a3..696081d36c7 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
@@ -173,26 +173,23 @@ public State state() {&lt;br/&gt;
     /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Sets the state&lt;/li&gt;
	&lt;li&gt;@param newState New state&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @return The state prior to the call to setState, or null if the transition is invalid&lt;br/&gt;
      */&lt;/li&gt;
	&lt;li&gt;State setState(final State newState) {&lt;/li&gt;
	&lt;li&gt;final State oldState;&lt;br/&gt;
+    boolean setState(final State newState) {&lt;br/&gt;
+        final State oldState = state;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         synchronized (stateLock) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;oldState = state;&lt;br/&gt;
-&lt;br/&gt;
             if (state == State.PENDING_SHUTDOWN &amp;amp;&amp;amp; newState != State.DEAD) 
{
                 // when the state is already in PENDING_SHUTDOWN, all other transitions will be
                 // refused but we do not throw exception here
-                return null;
+                return false;
             }
&lt;p&gt; else if (state == State.DEAD) &lt;/p&gt;
{
                 // when the state is already in NOT_RUNNING, all its transitions
                 // will be refused but we do not throw exception here
-                return null;
+                return false;
             }
&lt;p&gt; else if (state == State.PARTITIONS_REVOKED &amp;amp;&amp;amp; newState == State.PARTITIONS_REVOKED) &lt;/p&gt;
{
                 // when the state is already in PARTITIONS_REVOKED, its transition to itself will be
                 // refused but we do not throw exception here
-                return null;
+                return false;
             }
&lt;p&gt; else if (!state.isValidTransition(newState)) {&lt;br/&gt;
                 log.error(&quot;Unexpected state transition from {} to {}&quot;, oldState, newState);&lt;br/&gt;
                 throw new StreamsException(logPrefix + &quot;Unexpected state transition from &quot; + oldState + &quot; to &quot; + newState);&lt;br/&gt;
@@ -212,7 +209,7 @@ State setState(final State newState) &lt;/p&gt;
{
             stateListener.onChange(this, state, oldState);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;return oldState;&lt;br/&gt;
+        return true;&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     public boolean isRunningAndNotRebalancing() {&lt;br/&gt;
@@ -254,7 +251,7 @@ public void onPartitionsAssigned(final Collection&amp;lt;TopicPartition&amp;gt; assignment) {&lt;/p&gt;

&lt;p&gt;             final long start = time.milliseconds();&lt;br/&gt;
             try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (streamThread.setState(State.PARTITIONS_ASSIGNED) == null) {&lt;br/&gt;
+                if (!streamThread.setState(State.PARTITIONS_ASSIGNED)) 
{
                     return;
                 }
&lt;p&gt;                 taskManager.createTasks(assignment);&lt;br/&gt;
@@ -284,7 +281,7 @@ public void onPartitionsRevoked(final Collection&amp;lt;TopicPartition&amp;gt; assignment) {&lt;br/&gt;
                 taskManager.activeTaskIds(),&lt;br/&gt;
                 taskManager.standbyTaskIds());&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (streamThread.setState(State.PARTITIONS_REVOKED) != null) {&lt;br/&gt;
+            if (streamThread.setState(State.PARTITIONS_REVOKED)) {&lt;br/&gt;
                 final long start = time.milliseconds();&lt;br/&gt;
                 try {&lt;br/&gt;
                     // suspend active tasks&lt;br/&gt;
@@ -717,11 +714,7 @@ public StreamThread(final Time time,&lt;br/&gt;
     @Override&lt;br/&gt;
     public void run() {&lt;br/&gt;
         log.info(&quot;Starting&quot;);&lt;/li&gt;
	&lt;li&gt;if (setState(State.RUNNING) == null) 
{
-            log.info(&quot;StreamThread already shutdown. Not running&quot;);
-            completeShutdown(true);
-            return;
-        }
&lt;p&gt;+        setState(State.RUNNING);&lt;br/&gt;
         boolean cleanRun = false;&lt;br/&gt;
         try {&lt;br/&gt;
             runLoop();&lt;br/&gt;
@@ -1095,11 +1088,7 @@ private long computeLatency() {&lt;br/&gt;
      */&lt;br/&gt;
     public void shutdown() {&lt;br/&gt;
         log.info(&quot;Informed to shut down&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;State oldState = setState(State.PENDING_SHUTDOWN);&lt;/li&gt;
	&lt;li&gt;if (oldState == State.CREATED) 
{
-            // Start so that we shutdown on the thread
-            this.start();
-        }
&lt;p&gt;+        setState(State.PENDING_SHUTDOWN);&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private void completeShutdown(final boolean cleanRun) {&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
index bdc1c00153f..d70c8f393e4 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
@@ -274,11 +274,7 @@ void shutdown(final boolean clean) {&lt;br/&gt;
         standby.close(clean);&lt;/p&gt;

&lt;p&gt;         // remove the changelog partitions from restore consumer&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try 
{
-            restoreConsumer.unsubscribe();
-        }
&lt;p&gt; catch (final RuntimeException fatalException) &lt;/p&gt;
{
-            firstException.compareAndSet(null, fatalException);
-        }
&lt;p&gt;+        restoreConsumer.unsubscribe();&lt;br/&gt;
         taskCreator.close();&lt;br/&gt;
         standbyTaskCreator.close();&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java b/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java&lt;br/&gt;
index a2084b02aea..8746c62a50f 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java&lt;br/&gt;
@@ -16,7 +16,6 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams;&lt;/p&gt;

&lt;p&gt;-import org.apache.kafka.clients.producer.MockProducer;&lt;br/&gt;
 import org.apache.kafka.common.Metric;&lt;br/&gt;
 import org.apache.kafka.common.MetricName;&lt;br/&gt;
 import org.apache.kafka.common.config.ConfigException;&lt;br/&gt;
@@ -32,7 +31,6 @@&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.GlobalStreamThread;&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.StreamThread;&lt;br/&gt;
 import org.apache.kafka.test.IntegrationTest;&lt;br/&gt;
-import org.apache.kafka.test.MockClientSupplier;&lt;br/&gt;
 import org.apache.kafka.test.MockMetricsReporter;&lt;br/&gt;
 import org.apache.kafka.test.MockStateRestoreListener;&lt;br/&gt;
 import org.apache.kafka.test.TestCondition;&lt;br/&gt;
@@ -115,28 +113,6 @@ public void testStateCloseAfterCreate() &lt;/p&gt;
{
         Assert.assertEquals(KafkaStreams.State.NOT_RUNNING, streams.state());
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldCleanupResourcesOnCloseWithoutPreviousStart() throws Exception {&lt;/li&gt;
	&lt;li&gt;final StreamsBuilder builder = new StreamsBuilder();&lt;/li&gt;
	&lt;li&gt;builder.globalTable(&quot;anyTopic&quot;);&lt;/li&gt;
	&lt;li&gt;MockClientSupplier clientSupplier = new MockClientSupplier();&lt;/li&gt;
	&lt;li&gt;final KafkaStreams streams = new KafkaStreams(builder.build(), new StreamsConfig(props), clientSupplier);&lt;/li&gt;
	&lt;li&gt;streams.close();&lt;/li&gt;
	&lt;li&gt;TestUtils.waitForCondition(new TestCondition() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public boolean conditionMet() 
{
-                return streams.state() == KafkaStreams.State.NOT_RUNNING;
-            }&lt;/li&gt;
	&lt;li&gt;}, 10 * 1000, &quot;Streams never stopped.&quot;);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// Ensure that any created clients are closed&lt;/li&gt;
	&lt;li&gt;assertTrue(clientSupplier.consumer.closed());&lt;/li&gt;
	&lt;li&gt;assertTrue(clientSupplier.restoreConsumer.closed());&lt;/li&gt;
	&lt;li&gt;for (MockProducer p : clientSupplier.producers) 
{
-            assertTrue(p.closed());
-        }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testStateThreadClose() throws Exception {&lt;br/&gt;
         final StreamsBuilder builder = new StreamsBuilder();&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java&lt;br/&gt;
index cca7045b19a..42504655117 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java&lt;br/&gt;
@@ -441,13 +441,8 @@ public void shouldShutdownTaskManagerOnClose() throws InterruptedException {&lt;br/&gt;
         EasyMock.expectLastCall();&lt;br/&gt;
         EasyMock.replay(taskManager, consumer);&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final StreamThread.StreamsMetricsThreadImpl streamsMetrics = new StreamThread.StreamsMetricsThreadImpl(&lt;/li&gt;
	&lt;li&gt;metrics,&lt;/li&gt;
	&lt;li&gt;&quot;&quot;,&lt;/li&gt;
	&lt;li&gt;&quot;&quot;,&lt;/li&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap());&lt;/li&gt;
	&lt;li&gt;final StreamThread thread = new StreamThread(&lt;/li&gt;
	&lt;li&gt;mockTime,&lt;br/&gt;
+        StreamThread.StreamsMetricsThreadImpl streamsMetrics = new StreamThread.StreamsMetricsThreadImpl(metrics, &quot;&quot;, &quot;&quot;, Collections.&amp;lt;String, String&amp;gt;emptyMap());&lt;br/&gt;
+        final StreamThread thread = new StreamThread(mockTime,&lt;br/&gt;
                 config,&lt;br/&gt;
                 consumer,&lt;br/&gt;
                 consumer,&lt;br/&gt;
@@ -463,40 +458,6 @@ public void shouldShutdownTaskManagerOnClose() throws InterruptedException 
{
         EasyMock.verify(taskManager);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldShutdownTaskManagerOnCloseWithoutStart() {&lt;/li&gt;
	&lt;li&gt;final Consumer&amp;lt;byte[], byte[]&amp;gt; consumer = EasyMock.createNiceMock(Consumer.class);&lt;/li&gt;
	&lt;li&gt;final TaskManager taskManager = EasyMock.createNiceMock(TaskManager.class);&lt;/li&gt;
	&lt;li&gt;taskManager.shutdown(true);&lt;/li&gt;
	&lt;li&gt;EasyMock.expectLastCall();&lt;/li&gt;
	&lt;li&gt;EasyMock.replay(taskManager, consumer);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final StreamThread.StreamsMetricsThreadImpl streamsMetrics = new StreamThread.StreamsMetricsThreadImpl(&lt;/li&gt;
	&lt;li&gt;metrics,&lt;/li&gt;
	&lt;li&gt;&quot;&quot;,&lt;/li&gt;
	&lt;li&gt;&quot;&quot;,&lt;/li&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap());&lt;/li&gt;
	&lt;li&gt;final StreamThread thread = new StreamThread(&lt;/li&gt;
	&lt;li&gt;mockTime,&lt;/li&gt;
	&lt;li&gt;config,&lt;/li&gt;
	&lt;li&gt;consumer,&lt;/li&gt;
	&lt;li&gt;consumer,&lt;/li&gt;
	&lt;li&gt;null,&lt;/li&gt;
	&lt;li&gt;taskManager,&lt;/li&gt;
	&lt;li&gt;streamsMetrics,&lt;/li&gt;
	&lt;li&gt;internalTopologyBuilder,&lt;/li&gt;
	&lt;li&gt;clientId,&lt;/li&gt;
	&lt;li&gt;new LogContext(&quot;&quot;));&lt;/li&gt;
	&lt;li&gt;thread.shutdown();&lt;/li&gt;
	&lt;li&gt;try 
{
-            thread.join(1000);
-        }
&lt;p&gt; catch (final InterruptedException e) &lt;/p&gt;
{
-            fail(&quot;Join interrupted&quot;);
-        }&lt;/li&gt;
	&lt;li&gt;assertFalse(thread.isAlive());&lt;/li&gt;
	&lt;li&gt;EasyMock.verify(taskManager);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldNotNullPointerWhenStandbyTasksAssignedAndNoStateStoresForTopology() throws InterruptedException {&lt;br/&gt;
         internalTopologyBuilder.addSource(null, &quot;name&quot;, null, null, null, &quot;topic&quot;);&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16321443" author="guozhang" created="Thu, 11 Jan 2018 00:25:03 +0000"  >&lt;p&gt;Issue resolved by pull request 4382&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/kafka/pull/4382&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4382&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 44 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3o1gv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>