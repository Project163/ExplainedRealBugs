<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:08:02 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6653] Delayed operations may not be completed when there is lock contention</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6653</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;If there is lock contention while multiple threads check if a delayed operation may be completed (e.g. a produce request with acks=-1), only the thread that acquires the lock without blocking attempts to complete the operation. This change was made to avoid deadlocks under &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-5970&quot; title=&quot;Deadlock due to locking of DelayedProduce and group&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-5970&quot;&gt;&lt;del&gt;KAFKA-5970&lt;/del&gt;&lt;/a&gt;. But this leaves a timing window when an operation becomes ready to complete after another thread has acquired the lock and performed the check for completion, but not yet released the lock. In this case, the operation may never be completed and will timeout unless there are other operations with the same key. The timeout was observed in a failed system test where a produce request timed out, causing the test failure.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13144962">KAFKA-6653</key>
            <summary>Delayed operations may not be completed when there is lock contention</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rsivaram">Rajini Sivaram</assignee>
                                    <reporter username="rsivaram">Rajini Sivaram</reporter>
                        <labels>
                    </labels>
                <created>Wed, 14 Mar 2018 08:40:04 +0000</created>
                <updated>Thu, 15 Mar 2018 07:14:49 +0000</updated>
                            <resolved>Thu, 15 Mar 2018 07:14:49 +0000</resolved>
                                    <version>0.11.0.2</version>
                    <version>1.0.1</version>
                    <version>1.1.0</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>core</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16400019" author="githubbot" created="Thu, 15 Mar 2018 07:09:51 +0000"  >&lt;p&gt;hachikuji closed pull request #4704: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6653&quot; title=&quot;Delayed operations may not be completed when there is lock contention&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6653&quot;&gt;&lt;del&gt;KAFKA-6653&lt;/del&gt;&lt;/a&gt;: Complete delayed operations even when there is lock contention&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4704&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4704&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/core/src/main/scala/kafka/server/DelayedOperation.scala b/core/src/main/scala/kafka/server/DelayedOperation.scala&lt;br/&gt;
index 894d30e2d7c..2a096e1a811 100644&lt;br/&gt;
&amp;#8212; a/core/src/main/scala/kafka/server/DelayedOperation.scala&lt;br/&gt;
+++ b/core/src/main/scala/kafka/server/DelayedOperation.scala&lt;br/&gt;
@@ -47,6 +47,7 @@ abstract class DelayedOperation(override val delayMs: Long,&lt;br/&gt;
     lockOpt: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;Lock&amp;#93;&lt;/span&gt; = None) extends TimerTask with Logging {&lt;/p&gt;

&lt;p&gt;   private val completed = new AtomicBoolean(false)&lt;br/&gt;
+  private val tryCompletePending = new AtomicBoolean(false)&lt;br/&gt;
   // Visible for testing&lt;br/&gt;
   private&lt;span class=&quot;error&quot;&gt;&amp;#91;server&amp;#93;&lt;/span&gt; val lock: Lock = lockOpt.getOrElse(new ReentrantLock)&lt;/p&gt;

&lt;p&gt;@@ -101,16 +102,38 @@ abstract class DelayedOperation(override val delayMs: Long,&lt;br/&gt;
   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Thread-safe variant of tryComplete() that attempts completion only if the lock can be acquired&lt;/li&gt;
	&lt;li&gt;without blocking.&lt;br/&gt;
+   *&lt;br/&gt;
+   * If threadA acquires the lock and performs the check for completion before completion criteria is met&lt;br/&gt;
+   * and threadB satisfies the completion criteria, but fails to acquire the lock because threadA has not&lt;br/&gt;
+   * yet released the lock, we need to ensure that completion is attempted again without blocking threadA&lt;br/&gt;
+   * or threadB. `tryCompletePending` is set by threadB when it fails to acquire the lock and at least one&lt;br/&gt;
+   * of threadA or threadB will attempt completion of the operation if this flag is set. This ensures that&lt;br/&gt;
+   * every invocation of `maybeTryComplete` is followed by at least one invocation of `tryComplete` until&lt;br/&gt;
+   * the operation is actually completed.&lt;br/&gt;
    */&lt;br/&gt;
   private&lt;span class=&quot;error&quot;&gt;&amp;#91;server&amp;#93;&lt;/span&gt; def maybeTryComplete(): Boolean = {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (lock.tryLock()) {&lt;/li&gt;
	&lt;li&gt;try 
{
-        tryComplete()
-      }
&lt;p&gt; finally {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;lock.unlock()&lt;br/&gt;
+    var retry = false&lt;br/&gt;
+    var done = false&lt;br/&gt;
+    do {&lt;br/&gt;
+      if (lock.tryLock()) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        try {
+          tryCompletePending.set(false)
+          done = tryComplete()
+        } finally {
+          lock.unlock()
+        }+        // While we were holding the lock, another thread may have invoked `maybeTryComplete` and set+        // `tryCompletePending`. In this case we should retry.+        retry = tryCompletePending.get()+      }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; else &lt;/p&gt;
{
+        // Another thread is holding the lock. If `tryCompletePending` is already set and this thread failed to
+        // acquire the lock, then the thread that is holding the lock is guaranteed to see the flag and retry.
+        // Otherwise, we should set the flag and retry on this thread since the thread holding the lock may have
+        // released the lock and returned by the time the flag is set.
+        retry = !tryCompletePending.getAndSet(true)
       }&lt;/li&gt;
	&lt;li&gt;} else&lt;/li&gt;
	&lt;li&gt;false&lt;br/&gt;
+    } while (!isCompleted &amp;amp;&amp;amp; retry)&lt;br/&gt;
+    done&lt;br/&gt;
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /*&lt;br/&gt;
diff --git a/core/src/test/scala/unit/kafka/server/DelayedOperationTest.scala b/core/src/test/scala/unit/kafka/server/DelayedOperationTest.scala&lt;br/&gt;
index d4d79e554c7..3b077a0b438 100644&lt;br/&gt;
&amp;#8212; a/core/src/test/scala/unit/kafka/server/DelayedOperationTest.scala&lt;br/&gt;
+++ b/core/src/test/scala/unit/kafka/server/DelayedOperationTest.scala&lt;br/&gt;
@@ -17,11 +17,13 @@&lt;/p&gt;

&lt;p&gt; package kafka.server&lt;/p&gt;

&lt;p&gt;-import java.util.concurrent.&lt;/p&gt;
{Executors, Future}
&lt;p&gt;+import java.util.Random&lt;br/&gt;
+import java.util.concurrent._&lt;br/&gt;
+import java.util.concurrent.atomic.AtomicInteger&lt;br/&gt;
 import java.util.concurrent.locks.ReentrantLock&lt;/p&gt;

&lt;p&gt; import kafka.utils.CoreUtils.inLock&lt;br/&gt;
-&lt;br/&gt;
+import kafka.utils.TestUtils&lt;br/&gt;
 import org.apache.kafka.common.utils.Time&lt;br/&gt;
 import org.junit.&lt;/p&gt;
{After, Before, Test}
&lt;p&gt; import org.junit.Assert._&lt;br/&gt;
@@ -29,6 +31,7 @@ import org.junit.Assert._&lt;br/&gt;
 class DelayedOperationTest {&lt;/p&gt;

&lt;p&gt;   var purgatory: DelayedOperationPurgatory&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt; = null&lt;br/&gt;
+  var executorService: ExecutorService = null&lt;/p&gt;

&lt;p&gt;   @Before&lt;br/&gt;
   def setUp() {&lt;br/&gt;
@@ -38,6 +41,8 @@ class DelayedOperationTest {&lt;br/&gt;
   @After&lt;br/&gt;
   def tearDown() &lt;/p&gt;
{
     purgatory.shutdown()
+    if (executorService != null)
+      executorService.shutdown()
   }

&lt;p&gt;   @Test&lt;br/&gt;
@@ -122,6 +127,94 @@ class DelayedOperationTest &lt;/p&gt;
{
     assertEquals(Nil, cancelledOperations)
   }

&lt;p&gt;+  /**&lt;br/&gt;
+    * Verify that if there is lock contention between two threads attempting to complete,&lt;br/&gt;
+    * completion is performed without any blocking in either thread.&lt;br/&gt;
+    */&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testTryCompleteLockContention(): Unit = {&lt;br/&gt;
+    executorService = Executors.newSingleThreadExecutor()&lt;br/&gt;
+    val completionAttemptsRemaining = new AtomicInteger(Int.MaxValue)&lt;br/&gt;
+    val tryCompleteSemaphore = new Semaphore(1)&lt;br/&gt;
+    val key = &quot;key&quot;&lt;br/&gt;
+&lt;br/&gt;
+    val op = new MockDelayedOperation(100000L, None, None) {&lt;br/&gt;
+      override def tryComplete() = {&lt;br/&gt;
+        val shouldComplete = completionAttemptsRemaining.decrementAndGet &amp;lt;= 0&lt;br/&gt;
+        tryCompleteSemaphore.acquire()&lt;br/&gt;
+        try &lt;/p&gt;
{
+          if (shouldComplete)
+            forceComplete()
+          else
+            false
+        }
&lt;p&gt; finally &lt;/p&gt;
{
+          tryCompleteSemaphore.release()
+        }
&lt;p&gt;+      }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    purgatory.tryCompleteElseWatch(op, Seq(key))&lt;br/&gt;
+    completionAttemptsRemaining.set(2)&lt;br/&gt;
+    tryCompleteSemaphore.acquire()&lt;br/&gt;
+    val future = runOnAnotherThread(purgatory.checkAndComplete(key), shouldComplete = false)&lt;br/&gt;
+    TestUtils.waitUntilTrue(() =&amp;gt; tryCompleteSemaphore.hasQueuedThreads, &quot;Not attempting to complete&quot;)&lt;br/&gt;
+    purgatory.checkAndComplete(key) // this should not block even though lock is not free&lt;br/&gt;
+    assertFalse(&quot;Operation should not have completed&quot;, op.isCompleted)&lt;br/&gt;
+    tryCompleteSemaphore.release()&lt;br/&gt;
+    future.get(10, TimeUnit.SECONDS)&lt;br/&gt;
+    assertTrue(&quot;Operation should have completed&quot;, op.isCompleted)&lt;br/&gt;
+  }&lt;br/&gt;
+&lt;br/&gt;
+  /**&lt;br/&gt;
+    * Test `tryComplete` with multiple threads to verify that there are no timing windows&lt;br/&gt;
+    * when completion is not performed even if the thread that makes the operation completable&lt;br/&gt;
+    * may not be able to acquire the operation lock. Since it is difficult to test all scenarios,&lt;br/&gt;
+    * this test uses random delays with a large number of threads.&lt;br/&gt;
+    */&lt;br/&gt;
+  @Test&lt;br/&gt;
+  def testTryCompleteWithMultipleThreads(): Unit = {&lt;br/&gt;
+    val executor = Executors.newScheduledThreadPool(20)&lt;br/&gt;
+    this.executorService = executor&lt;br/&gt;
+    val random = new Random&lt;br/&gt;
+    val maxDelayMs = 10&lt;br/&gt;
+    val completionAttempts = 20&lt;br/&gt;
+&lt;br/&gt;
+    class TestDelayOperation(index: Int) extends MockDelayedOperation(10000L) {&lt;br/&gt;
+      val key = s&quot;key$index&quot;&lt;br/&gt;
+      val completionAttemptsRemaining = new AtomicInteger(completionAttempts)&lt;br/&gt;
+&lt;br/&gt;
+      override def tryComplete(): Boolean = &lt;/p&gt;
{
+        val shouldComplete = completable
+        Thread.sleep(random.nextInt(maxDelayMs))
+        if (shouldComplete)
+          forceComplete()
+        else
+          false
+      }
&lt;p&gt;+    }&lt;br/&gt;
+    val ops = (0 until 100).map &lt;/p&gt;
{ index =&amp;gt;
+      val op = new TestDelayOperation(index)
+      purgatory.tryCompleteElseWatch(op, Seq(op.key))
+      op
+    }
&lt;p&gt;+&lt;br/&gt;
+    def scheduleTryComplete(op: TestDelayOperation, delayMs: Long): Future&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
+      executor.schedule(new Runnable {&lt;br/&gt;
+        override def run(): Unit = &lt;/p&gt;
{
+          if (op.completionAttemptsRemaining.decrementAndGet() == 0)
+            op.completable = true
+          purgatory.checkAndComplete(op.key)
+        }
&lt;p&gt;+      }, delayMs, TimeUnit.MILLISECONDS)&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    (1 to completionAttempts).flatMap { _ =&amp;gt;&lt;br/&gt;
+      ops.map &lt;/p&gt;
{ op =&amp;gt; scheduleTryComplete(op, random.nextInt(maxDelayMs)) }
&lt;p&gt;+    }.foreach &lt;/p&gt;
{ future =&amp;gt; future.get }
&lt;p&gt;+&lt;br/&gt;
+    ops.foreach &lt;/p&gt;
{ op =&amp;gt; assertTrue(&quot;Operation should have completed&quot;, op.isCompleted) }
&lt;p&gt;+  }&lt;br/&gt;
+&lt;br/&gt;
   @Test&lt;br/&gt;
   def testDelayedOperationLock() {&lt;br/&gt;
     verifyDelayedOperationLock(new MockDelayedOperation(100000L), mismatchedLocks = false)&lt;br/&gt;
@@ -141,102 +234,97 @@ class DelayedOperationTest {&lt;/p&gt;

&lt;p&gt;   def verifyDelayedOperationLock(mockDelayedOperation: =&amp;gt; MockDelayedOperation, mismatchedLocks: Boolean) {&lt;br/&gt;
     val key = &quot;key&quot;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;val executorService = Executors.newSingleThreadExecutor&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;def createDelayedOperations(count: Int): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt; = {&lt;/li&gt;
	&lt;li&gt;(1 to count).map 
{ _ =&amp;gt;
-          val op = mockDelayedOperation
-          purgatory.tryCompleteElseWatch(op, Seq(key))
-          assertFalse(&quot;Not completable&quot;, op.isCompleted)
-          op
-        }
&lt;p&gt;+    executorService = Executors.newSingleThreadExecutor&lt;br/&gt;
+    def createDelayedOperations(count: Int): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt; = &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+      (1 to count).map { _ =&amp;gt;
+        val op = mockDelayedOperation
+        purgatory.tryCompleteElseWatch(op, Seq(key))
+        assertFalse(&quot;Not completable&quot;, op.isCompleted)
+        op
       }+    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def createCompletableOperations(count: Int): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt; = {&lt;/li&gt;
	&lt;li&gt;(1 to count).map 
{ _ =&amp;gt;
-          val op = mockDelayedOperation
-          op.completable = true
-          op
-        }
&lt;p&gt;+    def createCompletableOperations(count: Int): Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt; = &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+      (1 to count).map { _ =&amp;gt;
+        val op = mockDelayedOperation
+        op.completable = true
+        op
       }+    }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def runOnAnotherThread(fun: =&amp;gt; Unit, shouldComplete: Boolean): Future&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = {&lt;/li&gt;
	&lt;li&gt;val future = executorService.submit(new Runnable 
{
-          def run() = fun
-        }
&lt;p&gt;)&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (shouldComplete)&lt;/li&gt;
	&lt;li&gt;future.get()&lt;/li&gt;
	&lt;li&gt;else&lt;/li&gt;
	&lt;li&gt;assertFalse(&quot;Should not have completed&quot;, future.isDone)&lt;/li&gt;
	&lt;li&gt;future&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+    def checkAndComplete(completableOps: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt;, expectedComplete: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt;): Unit = 
{
+      completableOps.foreach(op =&amp;gt; op.completable = true)
+      val completed = purgatory.checkAndComplete(key)
+      assertEquals(expectedComplete.size, completed)
+      expectedComplete.foreach(op =&amp;gt; assertTrue(&quot;Should have completed&quot;, op.isCompleted))
+      val expectedNotComplete = completableOps.toSet -- expectedComplete
+      expectedNotComplete.foreach(op =&amp;gt; assertFalse(&quot;Should not have completed&quot;, op.isCompleted))
+    }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def checkAndComplete(completableOps: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt;, expectedComplete: Seq&lt;span class=&quot;error&quot;&gt;&amp;#91;MockDelayedOperation&amp;#93;&lt;/span&gt;): Unit = 
{
-        completableOps.foreach(op =&amp;gt; op.completable = true)
-        val completed = purgatory.checkAndComplete(key)
-        assertEquals(expectedComplete.size, completed)
-        expectedComplete.foreach(op =&amp;gt; assertTrue(&quot;Should have completed&quot;, op.isCompleted))
-        val expectedNotComplete = completableOps.toSet -- expectedComplete
-        expectedNotComplete.foreach(op =&amp;gt; assertFalse(&quot;Should not have completed&quot;, op.isCompleted))
-      }
&lt;p&gt;+    // If locks are free all completable operations should complete&lt;br/&gt;
+    var ops = createDelayedOperations(2)&lt;br/&gt;
+    checkAndComplete(ops, ops)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// If locks are free all completable operations should complete&lt;/li&gt;
	&lt;li&gt;var ops = createDelayedOperations(2)&lt;br/&gt;
+    // Lock held by current thread, completable operations should complete&lt;br/&gt;
+    ops = createDelayedOperations(2)&lt;br/&gt;
+    inLock(ops(1).lock) 
{
       checkAndComplete(ops, ops)
+    }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Lock held by current thread, completable operations should complete&lt;/li&gt;
	&lt;li&gt;ops = createDelayedOperations(2)&lt;/li&gt;
	&lt;li&gt;inLock(ops(1).lock) 
{
-        checkAndComplete(ops, ops)
-      }
&lt;p&gt;+    // Lock held by another thread, should not block, only operations that can be&lt;br/&gt;
+    // locked without blocking on the current thread should complete&lt;br/&gt;
+    ops = createDelayedOperations(2)&lt;br/&gt;
+    runOnAnotherThread(ops(0).lock.lock(), true)&lt;br/&gt;
+    try &lt;/p&gt;
{
+      checkAndComplete(ops, Seq(ops(1)))
+    }
&lt;p&gt; finally &lt;/p&gt;
{
+      runOnAnotherThread(ops(0).lock.unlock(), true)
+      checkAndComplete(Seq(ops(0)), Seq(ops(0)))
+    }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Lock held by another thread, should not block, only operations that can be&lt;/li&gt;
	&lt;li&gt;// locked without blocking on the current thread should complete&lt;/li&gt;
	&lt;li&gt;ops = createDelayedOperations(2)&lt;/li&gt;
	&lt;li&gt;runOnAnotherThread(ops(0).lock.lock(), true)&lt;br/&gt;
+    // Lock acquired by response callback held by another thread, should not block&lt;br/&gt;
+    // if the response lock is used as operation lock, only operations&lt;br/&gt;
+    // that can be locked without blocking on the current thread should complete&lt;br/&gt;
+    ops = createDelayedOperations(2)&lt;br/&gt;
+    ops(0).responseLockOpt.foreach { lock =&amp;gt;&lt;br/&gt;
+      runOnAnotherThread(lock.lock(), true)&lt;br/&gt;
       try 
{
-        checkAndComplete(ops, Seq(ops(1)))
-      }
&lt;p&gt; finally &lt;/p&gt;
{
-        runOnAnotherThread(ops(0).lock.unlock(), true)
-        checkAndComplete(Seq(ops(0)), Seq(ops(0)))
-      }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Lock acquired by response callback held by another thread, should not block&lt;/li&gt;
	&lt;li&gt;// if the response lock is used as operation lock, only operations&lt;/li&gt;
	&lt;li&gt;// that can be locked without blocking on the current thread should complete&lt;/li&gt;
	&lt;li&gt;ops = createDelayedOperations(2)&lt;/li&gt;
	&lt;li&gt;ops(0).responseLockOpt.foreach { lock =&amp;gt;&lt;/li&gt;
	&lt;li&gt;runOnAnotherThread(lock.lock(), true)&lt;br/&gt;
         try {&lt;/li&gt;
	&lt;li&gt;try 
{
-            checkAndComplete(ops, Seq(ops(1)))
-            assertFalse(&quot;Should have failed with mismatched locks&quot;, mismatchedLocks)
-          }
&lt;p&gt; catch &lt;/p&gt;
{
-            case e: IllegalStateException =&amp;gt;
-              assertTrue(&quot;Should not have failed with valid locks&quot;, mismatchedLocks)
-          }&lt;/li&gt;
	&lt;li&gt;} finally 
{
-          runOnAnotherThread(lock.unlock(), true)
-          checkAndComplete(Seq(ops(0)), Seq(ops(0)))
+          checkAndComplete(ops, Seq(ops(1)))
+          assertFalse(&quot;Should have failed with mismatched locks&quot;, mismatchedLocks)
+        }
&lt;p&gt; catch &lt;/p&gt;
{
+          case e: IllegalStateException =&amp;gt;
+            assertTrue(&quot;Should not have failed with valid locks&quot;, mismatchedLocks)
         }
&lt;p&gt;+      } finally &lt;/p&gt;
{
+        runOnAnotherThread(lock.unlock(), true)
+        checkAndComplete(Seq(ops(0)), Seq(ops(0)))
       }
&lt;p&gt;+    }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Immediately completable operations should complete without locking&lt;/li&gt;
	&lt;li&gt;ops = createCompletableOperations(2)&lt;/li&gt;
	&lt;li&gt;ops.foreach 
{ op =&amp;gt;
-        assertTrue(&quot;Should have completed&quot;, purgatory.tryCompleteElseWatch(op, Seq(key)))
-        assertTrue(&quot;Should have completed&quot;, op.isCompleted)
-      }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;} finally {&lt;/li&gt;
	&lt;li&gt;executorService.shutdown()&lt;br/&gt;
+    // Immediately completable operations should complete without locking&lt;br/&gt;
+    ops = createCompletableOperations(2)&lt;br/&gt;
+    ops.foreach 
{ op =&amp;gt;
+      assertTrue(&quot;Should have completed&quot;, purgatory.tryCompleteElseWatch(op, Seq(key)))
+      assertTrue(&quot;Should have completed&quot;, op.isCompleted)
     }
&lt;p&gt;   }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  private def runOnAnotherThread(fun: =&amp;gt; Unit, shouldComplete: Boolean): Future&lt;span class=&quot;error&quot;&gt;&amp;#91;_&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
+    val future = executorService.submit(new Runnable &lt;/p&gt;
{
+      def run() = fun
+    }
&lt;p&gt;)&lt;br/&gt;
+    if (shouldComplete)&lt;br/&gt;
+      future.get()&lt;br/&gt;
+    else&lt;br/&gt;
+      assertFalse(&quot;Should not have completed&quot;, future.isDone)&lt;br/&gt;
+    future&lt;br/&gt;
+  }&lt;/p&gt;

&lt;p&gt;   class MockDelayedOperation(delayMs: Long,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;lockOpt: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;ReentrantLock&amp;#93;&lt;/span&gt; = None,&lt;/li&gt;
	&lt;li&gt;val responseLockOpt: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;ReentrantLock&amp;#93;&lt;/span&gt; = None) extends DelayedOperation(delayMs, lockOpt) {&lt;br/&gt;
+                             lockOpt: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;ReentrantLock&amp;#93;&lt;/span&gt; = None,&lt;br/&gt;
+                             val responseLockOpt: Option&lt;span class=&quot;error&quot;&gt;&amp;#91;ReentrantLock&amp;#93;&lt;/span&gt; = None)&lt;br/&gt;
+                             extends DelayedOperation(delayMs, lockOpt) {&lt;br/&gt;
     var completable = false&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     def awaitExpiration() {&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 35 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3r9vz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>hachikuji</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>