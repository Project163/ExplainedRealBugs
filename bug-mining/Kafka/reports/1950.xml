<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:12:01 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6860] NPE when reinitializeStateStores with eos enabled</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6860</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;&lt;b&gt;Symptom&lt;/b&gt;&lt;br/&gt;
 With EOS enabled , Reinitializing stateStores get an NPE because checkpoint is null.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
2018-05-02 18:05:17.156 ERROR 60836 --- [-StreamThread-1] o.a.k.s.p.internals.StreamThread         : stream-thread [kafka-stream-application-d6ec1dfb-9b7f-42dd-8b28-899ff3d1ad98-StreamThread-1] Encountered the following error during processing:
java.lang.NullPointerException: &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;
        at org.apache.kafka.streams.processor.internals.AbstractStateManager.reinitializeStateStoresForPartitions(AbstractStateManager.java:66) ~[kafka-streams-1.1.0.jar:na]
        at org.apache.kafka.streams.processor.internals.ProcessorStateManager.reinitializeStateStoresForPartitions(ProcessorStateManager.java:155) ~[kafka-streams-1.1.0.jar:na]
        at org.apache.kafka.streams.processor.internals.AbstractTask.reinitializeStateStoresForPartitions(AbstractTask.java:230) ~[kafka-streams-1.1.0.jar:na]
        at org.apache.kafka.streams.processor.internals.StoreChangelogReader.restore(StoreChangelogReader.java:94) ~[kafka-streams-1.1.0.jar:na]
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;b&gt;How to reproduce&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;configure as&lt;/b&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;changelog topic with short `retention.ms` and `delete` policy (just to reproduce the symptom easily)&lt;br/&gt;
 ex) retention.ms=30000,cleanup.policy=delete&#160;&lt;/li&gt;
	&lt;li&gt;exaclty once semantic enabled&lt;/li&gt;
	&lt;li&gt;no cleanup&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;b&gt;Step&lt;/b&gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;two task&lt;span class=&quot;error&quot;&gt;&amp;#91;0_0&amp;#93;&lt;/span&gt;,&lt;span class=&quot;error&quot;&gt;&amp;#91;0,1&amp;#93;&lt;/span&gt; , two Spring Boot (assign was#1:task&lt;span class=&quot;error&quot;&gt;&amp;#91;0_0&amp;#93;&lt;/span&gt;, was#2:task&lt;span class=&quot;error&quot;&gt;&amp;#91;0_1&amp;#93;&lt;/span&gt;)&lt;/li&gt;
	&lt;li&gt;write some data each state store(changelog topic will soon erase those messages. by short &quot;retentin.ms&quot;)&lt;/li&gt;
	&lt;li&gt;when was#2 is killed, then was#1 will restore task&lt;span class=&quot;error&quot;&gt;&amp;#91;0_1&amp;#93;&lt;/span&gt;&apos;s data on its own rocksDB&lt;/li&gt;
	&lt;li&gt;In the process, it finds a checkpoint and an error occurs.(AbstractStateManager #66)&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// My code
&lt;/span&gt;Map&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; topicConfiguration = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        topicConfiguration.putIfAbsent(&lt;span class=&quot;code-quote&quot;&gt;&quot;cleanup.policy&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;delete&quot;&lt;/span&gt;);
        topicConfiguration.putIfAbsent(&lt;span class=&quot;code-quote&quot;&gt;&quot;file.delete.delay.ms&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;0&quot;&lt;/span&gt;);
        topicConfiguration.putIfAbsent(&lt;span class=&quot;code-quote&quot;&gt;&quot;retention.ms&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;3000&quot;&lt;/span&gt;);

builder.stream(properties.getSourceTopic(),
               Consumed.with(Serdes.&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;(), Serdes.&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()))
       .groupByKey()
       .count(Materialized
                  .&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;, KeyValueStore&amp;lt;Bytes, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[]&amp;gt;&amp;gt;as(ORDER_STORE_NAME)
                  .withKeySerde(Serdes.&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;())
                  .withValueSerde(Serdes.&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;())
                  .withLoggingEnabled(topicConfiguration));
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Suggestion&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;When EOS is enabled, the checkpoint will be null.&lt;br/&gt;
 I think , need to add some code to create a Checkpoint. &lt;br/&gt;
 As follows&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// # At org.apache.kafka.streams.processor.internals.AbstractStateManager #66
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// # suggestion start
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (checkpoint == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
    checkpoint = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; OffsetCheckpoint(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; File(baseDir, CHECKPOINT_FILE_NAME));
}
&lt;span class=&quot;code-comment&quot;&gt;// # suggestion end
&lt;/span&gt;
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
    checkpoint.write(checkpointableOffsets);
} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; IOException fatalException) {
    log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;Failed to write offset checkpoint file to {} &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; re-initializing {}: {}&quot;&lt;/span&gt;, checkpoint, stateStores, fatalException);
 &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; StreamsException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Failed to reinitialize global store.&quot;&lt;/span&gt;, fatalException);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment>mac, kafka1.1</environment>
        <key id="13157027">KAFKA-6860</key>
            <summary>NPE when reinitializeStateStores with eos enabled</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="mjsax">Matthias J. Sax</assignee>
                                    <reporter username="bk.ko">ko byoung kwon</reporter>
                        <labels>
                    </labels>
                <created>Fri, 4 May 2018 02:43:25 +0000</created>
                <updated>Wed, 13 Jun 2018 22:23:34 +0000</updated>
                            <resolved>Wed, 13 Jun 2018 22:23:34 +0000</resolved>
                                    <version>1.1.0</version>
                                    <fixVersion>1.1.1</fixVersion>
                    <fixVersion>2.0.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                    <workratio workratioPercent="0"/>
                                    <progress percentage="0">
                                    <originalProgress>
                                                    <row percentage="100" backgroundColor="#89afd7"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="0" backgroundColor="#51a825"/>
                                                    <row percentage="100" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="0">
                                    <originalProgress>
                                                    <row percentage="100" backgroundColor="#89afd7"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="0" backgroundColor="#51a825"/>
                                                    <row percentage="100" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                    <timeoriginalestimate seconds="7200">2h</timeoriginalestimate>
                            <timeestimate seconds="7200">2h</timeestimate>
                                        <comments>
                            <comment id="16498733" author="guozhang" created="Fri, 1 Jun 2018 23:59:37 +0000"  >&lt;p&gt;Thanks for the detailed explanation of the issue. I looked at the code of 1.1, and the `checkpoint` object is always initialized in the constructor of `ProcessorStateManager`. So it is still not clear to me why EOS would hit this issue. Could you share more of your findings?&lt;/p&gt;</comment>
                            <comment id="16507604" author="mjsax" created="Mon, 11 Jun 2018 02:46:07 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; Note that `checkpoint` is not `final` and indeed, `ProcessorStateManager` sets `checkpoint = null` when EOS is enabled in it&apos;s own constructor. This is by design, because the checkpoint file is deleted to make sure we do full restore in case of error. Only in a clean shutdown, the checkpoint file is recreated.&lt;/p&gt;

&lt;p&gt;Thus, a proper fix would be to check if EOS is enabled and only write the checkpoint file if disabled. Let me know what you think about this? If you agree that it is a proper fix, we can include it in 2.0 release. But we should not rush it &#8211; EOS is sensitive. Also, the describe scenario is a corner case that only happens is offsets get invalid for a changelog topic when we try to restore it.&lt;/p&gt;</comment>
                            <comment id="16508317" author="guozhang" created="Mon, 11 Jun 2018 16:31:28 +0000"  >&lt;p&gt;I see. Thanks for the explanation &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt;. And your proposed fix makes sense to me. I think a more general solution would involve also fixing the double checkpointing for non-EOS case: today we checkpoint in `suspend` if EOS is not turned in and in `closeSuspended` always. So for EOS, we only checkpoint in `closeSuspended`, while in non EOS we checkpoint in both, hence we have unnecessarily written twice of the checkpoints when closing. But for this general fix, I think it may be better to consider fixing with some refactoring on the ProcessorStateManager code, and hence not necessarily to be included for this JIRA.&lt;/p&gt;</comment>
                            <comment id="16508424" author="githubbot" created="Mon, 11 Jun 2018 17:42:01 +0000"  >&lt;p&gt;mjsax opened a new pull request #5187: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6860&quot; title=&quot;NPE when reinitializeStateStores with eos enabled&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6860&quot;&gt;&lt;del&gt;KAFKA-6860&lt;/del&gt;&lt;/a&gt;: Fix NPE in Kafka Streams with EOS enabled&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5187&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5187&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   *More detailed description of your change,&lt;br/&gt;
   if necessary. The PR title and PR message become&lt;br/&gt;
   the squashed commit message, so use a separate&lt;br/&gt;
   comment to ping reviewers.*&lt;/p&gt;

&lt;p&gt;   *Summary of testing strategy (including rationale)&lt;br/&gt;
   for the feature or bug fix. Unit and/or integration&lt;br/&gt;
   tests are expected for any behaviour change and&lt;br/&gt;
   system tests should be considered for larger changes.*&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16511726" author="githubbot" created="Wed, 13 Jun 2018 22:14:42 +0000"  >&lt;p&gt;mjsax closed pull request #5187: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6860&quot; title=&quot;NPE when reinitializeStateStores with eos enabled&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6860&quot;&gt;&lt;del&gt;KAFKA-6860&lt;/del&gt;&lt;/a&gt;: Fix NPE in Kafka Streams with EOS enabled&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5187&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5187&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractStateManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractStateManager.java&lt;br/&gt;
index b270e03f2e0..66ddec950c8 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractStateManager.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractStateManager.java&lt;br/&gt;
@@ -36,17 +36,18 @@&lt;br/&gt;
     static final String CHECKPOINT_FILE_NAME = &quot;.checkpoint&quot;;&lt;/p&gt;

&lt;p&gt;     final File baseDir;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Map&amp;lt;TopicPartition, Long&amp;gt; checkpointableOffsets = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
-&lt;br/&gt;
+    private final boolean eosEnabled;&lt;br/&gt;
     OffsetCheckpoint checkpoint;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    final Map&amp;lt;TopicPartition, Long&amp;gt; checkpointableOffsets = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     final Map&amp;lt;String, StateStore&amp;gt; stores = new LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     final Map&amp;lt;String, StateStore&amp;gt; globalStores = new LinkedHashMap&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;AbstractStateManager(final File baseDir) {&lt;br/&gt;
+    AbstractStateManager(final File baseDir,&lt;br/&gt;
+                         final boolean eosEnabled) 
{
         this.baseDir = baseDir;
+        this.eosEnabled = eosEnabled;
         this.checkpoint = new OffsetCheckpoint(new File(baseDir, CHECKPOINT_FILE_NAME));
-
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     public void reinitializeStateStoresForPartitions(final Logger log,&lt;br/&gt;
@@ -62,11 +63,14 @@ public void reinitializeStateStoresForPartitions(final Logger log,&lt;br/&gt;
             checkpointableOffsets.remove(topicPartition);&lt;br/&gt;
             storeToBeReinitialized.add(changelogTopicToStore.get(topicPartition.topic()));&lt;br/&gt;
         }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try 
{
-            checkpoint.write(checkpointableOffsets);
-        }
&lt;p&gt; catch (final IOException fatalException) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.error(&quot;Failed to write offset checkpoint file to {} while re-initializing {}: {}&quot;, checkpoint, stateStores, fatalException);&lt;/li&gt;
	&lt;li&gt;throw new StreamsException(&quot;Failed to reinitialize global store.&quot;, fatalException);&lt;br/&gt;
+&lt;br/&gt;
+        if (!eosEnabled) {&lt;br/&gt;
+            try 
{
+                checkpoint.write(checkpointableOffsets);
+            }
&lt;p&gt; catch (final IOException fatalException) {&lt;br/&gt;
+                log.error(&quot;Failed to write offset checkpoint file to {} while re-initializing {}: {}&quot;, checkpoint, stateStores, fatalException);&lt;br/&gt;
+                throw new StreamsException(&quot;Failed to reinitialize global store.&quot;, fatalException);&lt;br/&gt;
+            }&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         for (final Map.Entry&amp;lt;String, StateStore&amp;gt; entry : storesCopy.entrySet()) {&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImpl.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImpl.java&lt;br/&gt;
index 79088d98806..78c4a363f29 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImpl.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImpl.java&lt;br/&gt;
@@ -69,7 +69,7 @@ public GlobalStateManagerImpl(final LogContext logContext,&lt;br/&gt;
                                   final StateDirectory stateDirectory,&lt;br/&gt;
                                   final StateRestoreListener stateRestoreListener,&lt;br/&gt;
                                   final StreamsConfig config) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;super(stateDirectory.globalStateDir());&lt;br/&gt;
+        super(stateDirectory.globalStateDir(), StreamsConfig.EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG)));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         this.log = logContext.logger(GlobalStateManagerImpl.class);&lt;br/&gt;
         this.topology = topology;&lt;br/&gt;
@@ -92,16 +92,16 @@ public void setGlobalProcessorContext(final InternalProcessorContext processorCo&lt;br/&gt;
             if (!stateDirectory.lockGlobalState()) &lt;/p&gt;
{
                 throw new LockException(String.format(&quot;Failed to lock the global state directory: %s&quot;, baseDir));
             }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;} catch (IOException e) 
{
+        } catch (final IOException e) {
             throw new LockException(String.format(&quot;Failed to lock the global state directory: %s&quot;, baseDir));
         }&lt;br/&gt;
 &lt;br/&gt;
         try {
             this.checkpointableOffsets.putAll(checkpoint.read());
-        } catch (IOException e) {+        }
&lt;p&gt; catch (final IOException e) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {             try {
                 stateDirectory.unlockGlobalState();
-            } catch (IOException e1) {
+            } catch (final IOException e1) {
                 log.error(&quot;Failed to unlock the global state directory&quot;, e);
             }&lt;br/&gt;
             throw new StreamsException(&quot;Failed to read checkpoints for global state globalStores&quot;, e);&lt;br/&gt;
@@ -232,7 +232,7 @@ public void register(final StateStore store,&lt;br/&gt;
         }&lt;br/&gt;
 &lt;br/&gt;
         final List&amp;lt;TopicPartition&amp;gt; topicPartitions = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-        for (PartitionInfo partition : partitionInfos) {&lt;br/&gt;
+        for (final PartitionInfo partition : partitionInfos) {
             topicPartitions.add(new TopicPartition(partition.topic(), partition.partition()));
         }&lt;br/&gt;
         return topicPartitions;&lt;br/&gt;
@@ -253,8 +253,7 @@ private void restoreState(final StateRestoreCallback stateRestoreCallback,&lt;br/&gt;
 &lt;br/&gt;
             long offset = globalConsumer.position(topicPartition);&lt;br/&gt;
             final Long highWatermark = highWatermarks.get(topicPartition);&lt;br/&gt;
-            BatchingStateRestoreCallback&lt;br/&gt;
-                stateRestoreAdapter =&lt;br/&gt;
+            final BatchingStateRestoreCallback stateRestoreAdapter =&lt;br/&gt;
                 (BatchingStateRestoreCallback) ((stateRestoreCallback instanceof&lt;br/&gt;
                                                      BatchingStateRestoreCallback)&lt;br/&gt;
                                                 ? stateRestoreCallback&lt;br/&gt;
@@ -267,7 +266,7 @@ private void restoreState(final StateRestoreCallback stateRestoreCallback,&lt;br/&gt;
                 try {&lt;br/&gt;
                     final ConsumerRecords&amp;lt;byte[], byte[]&amp;gt; records = globalConsumer.poll(pollTime);&lt;br/&gt;
                     final List&amp;lt;KeyValue&amp;lt;byte[], byte[]&amp;gt;&amp;gt; restoreRecords = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
-                    for (ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; record : records) {&lt;br/&gt;
+                    for (final ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; record : records) {&lt;br/&gt;
                         if (record.key() != null) {
                             restoreRecords.add(KeyValue.pair(record.key(), record.value()));
                         }&lt;br/&gt;
@@ -294,11 +293,11 @@ private void restoreState(final StateRestoreCallback stateRestoreCallback,&lt;br/&gt;
     @Override&lt;br/&gt;
     public void flush() {&lt;br/&gt;
         log.debug(&quot;Flushing all global globalStores registered in the state manager&quot;);&lt;br/&gt;
-        for (StateStore store : this.globalStores.values()) {&lt;br/&gt;
+        for (final StateStore store : this.globalStores.values()) {&lt;br/&gt;
             try {&lt;br/&gt;
                 log.trace(&quot;Flushing global store={}&quot;, store.name());&lt;br/&gt;
                 store.flush();&lt;br/&gt;
-            } catch (Exception e) {+            } catch (final Exception e) {
                 throw new ProcessorStateException(String.format(&quot;Failed to flush global state store %s&quot;, store.name()), e);
             }         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;@@ -316,7 +315,7 @@ public void close(final Map&amp;lt;TopicPartition, Long&amp;gt; offsets) throws IOException {&lt;br/&gt;
                 log.debug(&quot;Closing global storage engine {}&quot;, entry.getKey());&lt;br/&gt;
                 try &lt;/p&gt;
{
                     entry.getValue().close();
-                }
&lt;p&gt; catch (Exception e) &lt;/p&gt;
{
+                }
&lt;p&gt; catch (final Exception e) {&lt;br/&gt;
                     log.error(&quot;Failed to close global state store {}&quot;, entry.getKey(), e);&lt;br/&gt;
                     closeFailed.append(&quot;Failed to close global state store:&quot;)&lt;br/&gt;
                             .append(entry.getKey())&lt;br/&gt;
@@ -341,7 +340,7 @@ public void checkpoint(final Map&amp;lt;TopicPartition, Long&amp;gt; offsets) {&lt;br/&gt;
         if (!checkpointableOffsets.isEmpty()) {&lt;br/&gt;
             try &lt;/p&gt;
{
                 checkpoint.write(checkpointableOffsets);
-            }
&lt;p&gt; catch (IOException e) &lt;/p&gt;
{
+            }
&lt;p&gt; catch (final IOException e) {&lt;br/&gt;
                 log.warn(&quot;Failed to write offset checkpoint file to {} for global stores: {}&quot;, checkpoint, e);&lt;br/&gt;
             }&lt;br/&gt;
         }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java&lt;br/&gt;
index 054333b7a8f..afb56c1ac1b 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java&lt;br/&gt;
@@ -67,7 +67,7 @@ public ProcessorStateManager(final TaskId taskId,&lt;br/&gt;
                                  final ChangelogReader changelogReader,&lt;br/&gt;
                                  final boolean eosEnabled,&lt;br/&gt;
                                  final LogContext logContext) throws IOException {&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;super(stateDirectory.directoryForTask(taskId));&lt;br/&gt;
+        super(stateDirectory.directoryForTask(taskId), eosEnabled);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         this.log = logContext.logger(ProcessorStateManager.class);&lt;br/&gt;
         this.taskId = taskId;&lt;br/&gt;
@@ -81,12 +81,11 @@ public ProcessorStateManager(final TaskId taskId,&lt;br/&gt;
         offsetLimits = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
         standbyRestoredOffsets = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
         this.isStandby = isStandby;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;restoreCallbacks = isStandby ? new HashMap&amp;lt;String, StateRestoreCallback&amp;gt;() : null;&lt;br/&gt;
+        restoreCallbacks = isStandby ? new HashMap&amp;lt;&amp;gt;() : null;&lt;br/&gt;
         this.storeToChangelogTopic = storeToChangelogTopic;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // load the checkpoint information&lt;br/&gt;
         checkpointableOffsets.putAll(checkpoint.read());&lt;br/&gt;
-&lt;br/&gt;
         if (eosEnabled) {&lt;br/&gt;
             // delete the checkpoint file after finish loading its stored offsets&lt;br/&gt;
             checkpoint.delete();&lt;br/&gt;
@@ -169,11 +168,7 @@ public void reinitializeStateStoresForPartitions(final Collection&amp;lt;TopicPartition&lt;br/&gt;
             final int partition = getPartition(topicName);&lt;br/&gt;
             final TopicPartition storePartition = new TopicPartition(topicName, partition);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (checkpointableOffsets.containsKey(storePartition)) 
{
-                partitionsAndOffsets.put(storePartition, checkpointableOffsets.get(storePartition));
-            }
&lt;p&gt; else &lt;/p&gt;
{
-                partitionsAndOffsets.put(storePartition, -1L);
-            }
&lt;p&gt;+            partitionsAndOffsets.put(storePartition, checkpointableOffsets.getOrDefault(storePartition, -1L));&lt;br/&gt;
         }&lt;br/&gt;
         return partitionsAndOffsets;&lt;br/&gt;
     }&lt;br/&gt;
@@ -340,7 +335,7 @@ public StateStore getGlobalStore(final String name) &lt;/p&gt;
{
         return globalStores.get(name);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private BatchingStateRestoreCallback getBatchingRestoreCallback(StateRestoreCallback callback) {&lt;br/&gt;
+    private BatchingStateRestoreCallback getBatchingRestoreCallback(final StateRestoreCallback callback) {&lt;br/&gt;
         if (callback instanceof BatchingStateRestoreCallback) 
{
             return (BatchingStateRestoreCallback) callback;
         }
&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorStateManagerTest.java b/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorStateManagerTest.java&lt;br/&gt;
index 6a20cd92b6b..1b03cd4f294 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorStateManagerTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/processor/internals/ProcessorStateManagerTest.java&lt;br/&gt;
@@ -123,7 +123,7 @@ public void shouldRestoreStoreWithBatchingRestoreSpecification() throws Exceptio&lt;br/&gt;
             assertThat(batchingRestoreCallback.getRestoredRecords().size(), is(1));&lt;br/&gt;
             assertTrue(batchingRestoreCallback.getRestoredRecords().contains(expectedKeyValue));&lt;br/&gt;
         } finally 
{
-            stateMgr.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());
+            stateMgr.close(Collections.emptyMap());
         }&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
@@ -141,7 +141,7 @@ public void shouldRestoreStoreWithSinglePutRestoreSpecification() throws Excepti&lt;br/&gt;
             assertThat(persistentStore.keys.size(), is(1));&lt;br/&gt;
             assertTrue(persistentStore.keys.contains(intKey));&lt;br/&gt;
         } finally {-            stateMgr.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());+            stateMgr.close(Collections.emptyMap());         }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -169,7 +169,7 @@ public void testRegisterPersistentStore() throws IOException &lt;/p&gt;
{
             stateMgr.register(persistentStore, persistentStore.stateRestoreCallback);
             assertTrue(changelogReader.wasRegistered(new TopicPartition(persistentStoreTopicName, 2)));
         }
&lt;p&gt; finally &lt;/p&gt;
{
-            stateMgr.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());
+            stateMgr.close(Collections.emptyMap());
         }&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
@@ -196,7 +196,7 @@ public void testRegisterNonPersistentStore() throws IOException {
             stateMgr.register(nonPersistentStore, nonPersistentStore.stateRestoreCallback);
             assertTrue(changelogReader.wasRegistered(new TopicPartition(nonPersistentStoreTopicName, 2)));
         } finally {-            stateMgr.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());+            stateMgr.close(Collections.emptyMap());         }
&lt;p&gt;     }&lt;/p&gt;

&lt;p&gt;@@ -257,7 +257,7 @@ public void testChangeLogOffsets() throws IOException &lt;/p&gt;
{
             assertEquals(-1L, (long) changeLogOffsets.get(partition3));
 
         }
&lt;p&gt; finally &lt;/p&gt;
{
-            stateMgr.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());
+            stateMgr.close(Collections.emptyMap());
         }&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
@@ -269,7 +269,7 @@ public void testGetStore() throws IOException {&lt;br/&gt;
             noPartitions,&lt;br/&gt;
             false,&lt;br/&gt;
             stateDirectory,&lt;br/&gt;
-            Collections.&amp;lt;String, String&amp;gt;emptyMap(),&lt;br/&gt;
+            Collections.emptyMap(),&lt;br/&gt;
             changelogReader,&lt;br/&gt;
             false,&lt;br/&gt;
             logContext);&lt;br/&gt;
@@ -280,13 +280,13 @@ public void testGetStore() throws IOException {
             assertEquals(mockStateStore, stateMgr.getStore(nonPersistentStoreName));
 
         } finally {-            stateMgr.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());+            stateMgr.close(Collections.emptyMap());         }
&lt;p&gt;     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;br/&gt;
     public void testFlushAndClose() throws IOException {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;checkpoint.write(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());&lt;br/&gt;
+        checkpoint.write(Collections.emptyMap());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // set up ack&apos;ed offsets&lt;br/&gt;
         final HashMap&amp;lt;TopicPartition, Long&amp;gt; ackedOffsets = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
@@ -339,7 +339,7 @@ public void shouldRegisterStoreWithoutLoggingEnabledAndNotBackedByATopic() throw&lt;br/&gt;
             noPartitions,&lt;br/&gt;
             false,&lt;br/&gt;
             stateDirectory,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap(),&lt;br/&gt;
+            Collections.emptyMap(),&lt;br/&gt;
             changelogReader,&lt;br/&gt;
             false,&lt;br/&gt;
             logContext);&lt;br/&gt;
@@ -358,7 +358,7 @@ public void shouldNotChangeOffsetsIfAckedOffsetsIsNull() throws IOException {&lt;br/&gt;
             noPartitions,&lt;br/&gt;
             false,&lt;br/&gt;
             stateDirectory,&lt;/li&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap(),&lt;br/&gt;
+            Collections.emptyMap(),&lt;br/&gt;
             changelogReader,&lt;br/&gt;
             false,&lt;br/&gt;
             logContext);&lt;br/&gt;
@@ -408,7 +408,7 @@ public void shouldWriteCheckpointForStandbyReplica() throws IOException {&lt;br/&gt;
                                                                   bytes,&lt;br/&gt;
                                                                   bytes)));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;stateMgr.checkpoint(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());&lt;br/&gt;
+        stateMgr.checkpoint(Collections.emptyMap());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final Map&amp;lt;TopicPartition, Long&amp;gt; read = checkpoint.read();&lt;br/&gt;
         assertThat(read, equalTo(Collections.singletonMap(persistentStorePartition, 889L)));&lt;br/&gt;
@@ -433,7 +433,7 @@ public void shouldNotWriteCheckpointForNonPersistent() throws IOException &lt;/p&gt;
{
         stateMgr.checkpoint(Collections.singletonMap(topicPartition, 876L));
 
         final Map&amp;lt;TopicPartition, Long&amp;gt; read = checkpoint.read();
-        assertThat(read, equalTo(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap()));
+        assertThat(read, equalTo(Collections.emptyMap()));
     }

&lt;p&gt;     @Test&lt;br/&gt;
@@ -443,7 +443,7 @@ public void shouldNotWriteCheckpointForStoresWithoutChangelogTopic() throws IOEx&lt;br/&gt;
             noPartitions,&lt;br/&gt;
             true, // standby&lt;br/&gt;
             stateDirectory,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap(),&lt;br/&gt;
+            Collections.emptyMap(),&lt;br/&gt;
             changelogReader,&lt;br/&gt;
             false,&lt;br/&gt;
             logContext);&lt;br/&gt;
@@ -453,10 +453,9 @@ public void shouldNotWriteCheckpointForStoresWithoutChangelogTopic() throws IOEx&lt;br/&gt;
         stateMgr.checkpoint(Collections.singletonMap(persistentStorePartition, 987L));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final Map&amp;lt;TopicPartition, Long&amp;gt; read = checkpoint.read();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertThat(read, equalTo(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap()));&lt;br/&gt;
+        assertThat(read, equalTo(Collections.emptyMap()));&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldThrowIllegalArgumentExceptionIfStoreNameIsSameAsCheckpointFileName() throws IOException {&lt;br/&gt;
         final ProcessorStateManager stateManager = new ProcessorStateManager(&lt;br/&gt;
@@ -464,7 +463,7 @@ public void shouldThrowIllegalArgumentExceptionIfStoreNameIsSameAsCheckpointFile&lt;br/&gt;
             noPartitions,&lt;br/&gt;
             false,&lt;br/&gt;
             stateDirectory,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap(),&lt;br/&gt;
+            Collections.emptyMap(),&lt;br/&gt;
             changelogReader,&lt;br/&gt;
             false,&lt;br/&gt;
             logContext);&lt;br/&gt;
@@ -484,7 +483,7 @@ public void shouldThrowIllegalArgumentExceptionOnRegisterWhenStoreHasAlreadyBeen&lt;br/&gt;
             noPartitions,&lt;br/&gt;
             false,&lt;br/&gt;
             stateDirectory,&lt;/li&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap(),&lt;br/&gt;
+            Collections.emptyMap(),&lt;br/&gt;
             changelogReader,&lt;br/&gt;
             false,&lt;br/&gt;
             logContext);&lt;br/&gt;
@@ -551,7 +550,7 @@ public void close() {&lt;br/&gt;
         stateManager.register(stateStore, stateStore.stateRestoreCallback);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         try &lt;/p&gt;
{
-            stateManager.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());
+            stateManager.close(Collections.emptyMap());
             fail(&quot;Should throw ProcessorStateException if store close throws exception&quot;);
         }
&lt;p&gt; catch (final ProcessorStateException e) {&lt;br/&gt;
             // pass&lt;br/&gt;
@@ -623,7 +622,7 @@ public void close() {&lt;br/&gt;
         stateManager.register(stateStore2, stateStore2.stateRestoreCallback);&lt;/p&gt;

&lt;p&gt;         try &lt;/p&gt;
{
-            stateManager.close(Collections.&amp;lt;TopicPartition, Long&amp;gt;emptyMap());
+            stateManager.close(Collections.emptyMap());
         }
&lt;p&gt; catch (final ProcessorStateException expected) &lt;/p&gt;
{ /* ignode */ }
&lt;p&gt;         Assert.assertTrue(closedStore.get());&lt;br/&gt;
     }&lt;br/&gt;
@@ -640,7 +639,7 @@ public void shouldDeleteCheckpointFileOnCreationIfEosEnabled() throws IOExceptio&lt;br/&gt;
                 noPartitions,&lt;br/&gt;
                 false,&lt;br/&gt;
                 stateDirectory,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Collections.&amp;lt;String, String&amp;gt;emptyMap(),&lt;br/&gt;
+                Collections.emptyMap(),&lt;br/&gt;
                 changelogReader,&lt;br/&gt;
                 true,&lt;br/&gt;
                 logContext);&lt;br/&gt;
@@ -653,28 +652,36 @@ public void shouldDeleteCheckpointFileOnCreationIfEosEnabled() throws IOExceptio&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
     @Test&lt;/li&gt;
	&lt;li&gt;public void shouldSuccessfullyReInitializeStateStores() throws IOException {&lt;br/&gt;
+    public void shouldSuccessfullyReInitializeStateStoresWithEosDisable() throws Exception 
{
+        shouldSuccessfullyReInitializeStateStores(false);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldSuccessfullyReInitializeStateStoresWithEosEnable() throws Exception &lt;/p&gt;
{
+        shouldSuccessfullyReInitializeStateStores(true);
+    }
&lt;p&gt;+&lt;br/&gt;
+    private void shouldSuccessfullyReInitializeStateStores(final boolean eosEnabled) throws Exception {&lt;br/&gt;
         final String store2Name = &quot;store2&quot;;&lt;br/&gt;
         final String store2Changelog = &quot;store2-changelog&quot;;&lt;br/&gt;
         final TopicPartition store2Partition = new TopicPartition(store2Changelog, 0);&lt;br/&gt;
         final List&amp;lt;TopicPartition&amp;gt; changelogPartitions = Arrays.asList(changelogTopicPartition, store2Partition);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;Map&amp;lt;String, String&amp;gt; storeToChangelog = new HashMap() {&lt;br/&gt;
+        final Map&amp;lt;String, String&amp;gt; storeToChangelog = new HashMap&amp;lt;String, String&amp;gt;() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {             {
                 put(storeName, changelogTopic);
                 put(store2Name, store2Changelog);
             }         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
         final ProcessorStateManager stateManager = new ProcessorStateManager(&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;taskId,&lt;/li&gt;
	&lt;li&gt;changelogPartitions,&lt;/li&gt;
	&lt;li&gt;false,&lt;/li&gt;
	&lt;li&gt;stateDirectory,&lt;/li&gt;
	&lt;li&gt;storeToChangelog,&lt;/li&gt;
	&lt;li&gt;changelogReader,&lt;/li&gt;
	&lt;li&gt;false,&lt;/li&gt;
	&lt;li&gt;logContext);&lt;br/&gt;
+            taskId,&lt;br/&gt;
+            changelogPartitions,&lt;br/&gt;
+            false,&lt;br/&gt;
+            stateDirectory,&lt;br/&gt;
+            storeToChangelog,&lt;br/&gt;
+            changelogReader,&lt;br/&gt;
+            eosEnabled,&lt;br/&gt;
+            logContext);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final MockStateStore stateStore = new MockStateStore(storeName, true);&lt;br/&gt;
         final MockStateStore stateStore2 = new MockStateStore(store2Name, true);&lt;br/&gt;
@@ -696,7 +703,7 @@ public void register(final StateStore store, final StateRestoreCallback stateRes&lt;br/&gt;
         assertTrue(stateStore2.initialized);&lt;br/&gt;
     }&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private ProcessorStateManager getStandByStateManager(TaskId taskId) throws IOException {&lt;br/&gt;
+    private ProcessorStateManager getStandByStateManager(final TaskId taskId) throws IOException {&lt;br/&gt;
         return new ProcessorStateManager(&lt;br/&gt;
             taskId,&lt;br/&gt;
             noPartitions,&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 22 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3tbwv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>