<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:13:02 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-7168] Broker shutdown during SSL handshake may be handled as handshake failure</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-7168</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;If broker is shutdown while SSL handshake of a client connection is in progress, the client may process the resulting SSLException as a non-retriable handshake failure rather than a retriable I/O exception. This can cause streams applications to fail during rolling restarts.&lt;/p&gt;

&lt;p&gt;Exception stack trace:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;org.apache.kafka.common.errors.SslAuthenticationException: SSL handshake failed&lt;br/&gt;
Caused by: javax.net.ssl.SSLException: Received close_notify during handshake&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.security.ssl.Alerts.getSSLException(Alerts.java:208)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1639)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1607)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.security.ssl.SSLEngineImpl.recvAlert(SSLEngineImpl.java:1752)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.security.ssl.SSLEngineImpl.readRecord(SSLEngineImpl.java:1068)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.security.ssl.SSLEngineImpl.readNetRecord(SSLEngineImpl.java:890)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at sun.security.ssl.SSLEngineImpl.unwrap(SSLEngineImpl.java:764)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at javax.net.ssl.SSLEngine.unwrap(SSLEngine.java:624)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.common.network.SslTransportLayer.handshakeUnwrap(SslTransportLayer.java:465)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.common.network.SslTransportLayer.handshake(SslTransportLayer.java:266)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.common.network.KafkaChannel.prepare(KafkaChannel.java:88)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.common.network.Selector.pollSelectionKeys(Selector.java:474)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.common.network.Selector.poll(Selector.java:412)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:460)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:258)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:230)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient.poll(ConsumerNetworkClient.java:206)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureCoordinatorReady(AbstractCoordinator.java:219)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureCoordinatorReady(AbstractCoordinator.java:205)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(ConsumerCoordinator.java:284)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.KafkaConsumer.pollOnce(KafkaConsumer.java:1146)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.clients.consumer.KafkaConsumer.poll(KafkaConsumer.java:1111)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.streams.processor.internals.StreamThread.pollRequests(StreamThread.java:848)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.streams.processor.internals.StreamThread.runOnce(StreamThread.java:805)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.streams.processor.internals.StreamThread.runLoop(StreamThread.java:771)&lt;br/&gt;
&#160;&#160;&#160;&#160;&#160;&#160;&#160; at org.apache.kafka.streams.processor.internals.StreamThread.run(StreamThread.java:741)&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&#160;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13172405">KAFKA-7168</key>
            <summary>Broker shutdown during SSL handshake may be handled as handshake failure</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="rsivaram">Rajini Sivaram</assignee>
                                    <reporter username="rsivaram">Rajini Sivaram</reporter>
                        <labels>
                    </labels>
                <created>Mon, 16 Jul 2018 13:54:05 +0000</created>
                <updated>Fri, 11 Oct 2019 00:50:21 +0000</updated>
                            <resolved>Wed, 18 Jul 2018 11:33:06 +0000</resolved>
                                    <version>1.0.2</version>
                    <version>1.1.1</version>
                    <version>2.0.0</version>
                                    <fixVersion>2.0.0</fixVersion>
                                    <component>security</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16545438" author="githubbot" created="Mon, 16 Jul 2018 16:23:48 +0000"  >&lt;p&gt;rajinisivaram opened a new pull request #5371: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7168&quot; title=&quot;Broker shutdown during SSL handshake may be handled as handshake failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7168&quot;&gt;&lt;del&gt;KAFKA-7168&lt;/del&gt;&lt;/a&gt;: Treat connection close during SSL handshake as retriable&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5371&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5371&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   SSL `close_notify` from broker connection close is processed as an `SSLException` while unwrapping the final message when the I/O exception due to remote close is processed. This should be handled as a retriable `IOException` rather than a non-retriable `SslAuthenticationException`.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16547706" author="githubbot" created="Wed, 18 Jul 2018 11:27:24 +0000"  >&lt;p&gt;rajinisivaram closed pull request #5371: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-7168&quot; title=&quot;Broker shutdown during SSL handshake may be handled as handshake failure&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-7168&quot;&gt;&lt;del&gt;KAFKA-7168&lt;/del&gt;&lt;/a&gt;: Treat connection close during SSL handshake as retriable&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5371&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5371&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java b/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java&lt;br/&gt;
index 06e7e937886..838a6a75af3 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/network/SslTransportLayer.java&lt;br/&gt;
@@ -31,8 +31,10 @@&lt;br/&gt;
 import javax.net.ssl.SSLEngineResult.Status;&lt;br/&gt;
 import javax.net.ssl.SSLException;&lt;br/&gt;
 import javax.net.ssl.SSLHandshakeException;&lt;br/&gt;
-import javax.net.ssl.SSLSession;&lt;br/&gt;
+import javax.net.ssl.SSLKeyException;&lt;br/&gt;
 import javax.net.ssl.SSLPeerUnverifiedException;&lt;br/&gt;
+import javax.net.ssl.SSLProtocolException;&lt;br/&gt;
+import javax.net.ssl.SSLSession;&lt;/p&gt;

&lt;p&gt; import org.apache.kafka.common.errors.SslAuthenticationException;&lt;br/&gt;
 import org.apache.kafka.common.security.auth.KafkaPrincipal;&lt;br/&gt;
@@ -255,17 +257,17 @@ public void handshake() throws IOException &lt;/p&gt;
{
 
             doHandshake();
         }
&lt;p&gt; catch (SSLException e) &lt;/p&gt;
{
-            handshakeFailure(e, true);
+            maybeProcessHandshakeFailure(e, true, null);
         }
&lt;p&gt; catch (IOException e) {&lt;br/&gt;
             maybeThrowSslAuthenticationException();&lt;/p&gt;

&lt;p&gt;             // this exception could be due to a write. If there is data available to unwrap,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// process the data so that any SSLExceptions are reported&lt;br/&gt;
+            // process the data so that any SSL handshake exceptions are reported&lt;br/&gt;
             if (handshakeStatus == HandshakeStatus.NEED_UNWRAP &amp;amp;&amp;amp; netReadBuffer.position() &amp;gt; 0) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {                 try {
                     handshakeUnwrap(false);
                 } catch (SSLException e1) {
-                    handshakeFailure(e1, false);
+                    maybeProcessHandshakeFailure(e1, false, e);
                 }             }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;             // If we get here, this is not a handshake failure, throw the original IOException&lt;br/&gt;
@@ -824,6 +826,32 @@ private void handshakeFailure(SSLException sslException, boolean flush) throws I&lt;br/&gt;
             throw handshakeException;&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    // SSL handshake failures are typically thrown as SSLHandshakeException, SSLProtocolException,&lt;br/&gt;
+    // SSLPeerUnverifiedException or SSLKeyException if the cause is known. These exceptions indicate&lt;br/&gt;
+    // authentication failures (e.g. configuration errors) which should not be retried. But the SSL engine&lt;br/&gt;
+    // may also throw exceptions using the base class SSLException in a few cases:&lt;br/&gt;
+    //   a) If there are no matching ciphers or TLS version or the private key is invalid, client will be&lt;br/&gt;
+    //      unable to process the server message and an SSLException is thrown:&lt;br/&gt;
+    //      javax.net.ssl.SSLException: Unrecognized SSL message, plaintext connection?&lt;br/&gt;
+    //   b) If server closes the connection gracefully during handshake, client may receive close_notify&lt;br/&gt;
+    //      and and an SSLException is thrown:&lt;br/&gt;
+    //      javax.net.ssl.SSLException: Received close_notify during handshake&lt;br/&gt;
+    // We want to handle a) as a non-retriable SslAuthenticationException and b) as a retriable IOException.&lt;br/&gt;
+    // To do this we need to rely on the exception string. Since it is safer to throw a retriable exception&lt;br/&gt;
+    // when we are not sure, we will treat only the first exception string as a handshake exception.&lt;br/&gt;
+    private void maybeProcessHandshakeFailure(SSLException sslException, boolean flush, IOException ioException) throws IOException {&lt;br/&gt;
+        if (sslException instanceof SSLHandshakeException || sslException instanceof SSLProtocolException ||&lt;br/&gt;
+                sslException instanceof SSLPeerUnverifiedException || sslException instanceof SSLKeyException ||&lt;br/&gt;
+                sslException.getMessage().contains(&quot;Unrecognized SSL message&quot;))&lt;br/&gt;
+            handshakeFailure(sslException, flush);&lt;br/&gt;
+        else if (ioException == null)&lt;br/&gt;
+            throw sslException;&lt;br/&gt;
+        else &lt;/p&gt;
{
+            log.debug(&quot;SSLException while unwrapping data after IOException, original IOException will be propagated&quot;, sslException);
+            throw ioException;
+        }
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
     // If handshake has already failed, throw the authentication exception.&lt;br/&gt;
     private void maybeThrowSslAuthenticationException() {&lt;br/&gt;
         if (handshakeException != null)&lt;br/&gt;
diff --git a/clients/src/test/java/org/apache/kafka/common/network/NioEchoServer.java b/clients/src/test/java/org/apache/kafka/common/network/NioEchoServer.java&lt;br/&gt;
index 2ce9671736e..0c81b53742d 100644&lt;br/&gt;
&amp;#8212; a/clients/src/test/java/org/apache/kafka/common/network/NioEchoServer.java&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/common/network/NioEchoServer.java&lt;br/&gt;
@@ -64,7 +64,8 @@&lt;br/&gt;
     private volatile WritableByteChannel outputChannel;&lt;br/&gt;
     private final CredentialCache credentialCache;&lt;br/&gt;
     private final Metrics metrics;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private int numSent = 0;&lt;br/&gt;
+    private volatile int numSent = 0;&lt;br/&gt;
+    private volatile boolean closeKafkaChannels;&lt;br/&gt;
     private final DelegationTokenCache tokenCache;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     public NioEchoServer(ListenerName listenerName, SecurityProtocol securityProtocol, AbstractConfig config,&lt;br/&gt;
@@ -155,6 +156,11 @@ public void run() {&lt;br/&gt;
                     }&lt;br/&gt;
                     newChannels.clear();&lt;br/&gt;
                 }&lt;br/&gt;
+                if (closeKafkaChannels) &lt;/p&gt;
{
+                    for (KafkaChannel channel : selector.channels())
+                        selector.close(channel.id());
+                    closeKafkaChannels = false;
+                }

&lt;p&gt;                 List&amp;lt;NetworkReceive&amp;gt; completedReceives = selector.completedReceives();&lt;br/&gt;
                 for (NetworkReceive rcv : completedReceives) {&lt;br/&gt;
@@ -174,7 +180,6 @@ public void run() &lt;/p&gt;
{
                     selector.unmute(send.destination());
                     numSent += 1;
                 }
&lt;p&gt;-&lt;br/&gt;
             }&lt;br/&gt;
         } catch (IOException e) {&lt;br/&gt;
             // ignore&lt;br/&gt;
@@ -208,15 +213,26 @@ public Selector selector() &lt;/p&gt;
{
         return selector;
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void closeConnections() throws IOException {&lt;/li&gt;
	&lt;li&gt;for (SocketChannel channel : socketChannels)&lt;br/&gt;
+    public void closeKafkaChannels() throws IOException 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        closeKafkaChannels = true;+        selector.wakeup();+        try {
+            TestUtils.waitForCondition(() -&amp;gt; selector.channels().isEmpty(), &quot;Channels not closed&quot;);
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }+    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+    public void closeSocketChannels() throws IOException &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        for (SocketChannel channel }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     public void close() throws IOException, InterruptedException {&lt;br/&gt;
         this.serverSocketChannel.close();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;closeConnections();&lt;br/&gt;
+        closeSocketChannels();&lt;br/&gt;
         acceptorThread.interrupt();&lt;br/&gt;
         acceptorThread.join();&lt;br/&gt;
         interrupt();&lt;br/&gt;
diff --git a/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java b/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java&lt;br/&gt;
index 1f62c10bd51..6aef2f7eda6 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java&lt;br/&gt;
+++ b/clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java&lt;br/&gt;
@@ -699,7 +699,8 @@ public boolean conditionMet() {&lt;br/&gt;
      */&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testIOExceptionsDuringHandshakeRead() throws Exception 
{
-        testIOExceptionsDuringHandshake(true, false);
+        server = createEchoServer(SecurityProtocol.SSL);
+        testIOExceptionsDuringHandshake(FailureAction.THROW_IO_EXCEPTION, FailureAction.NO_OP);
     }&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /**&lt;br/&gt;
@@ -707,20 +708,60 @@ public void testIOExceptionsDuringHandshakeRead() throws Exception {&lt;br/&gt;
      */&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testIOExceptionsDuringHandshakeWrite() throws Exception &lt;/p&gt;
{
-        testIOExceptionsDuringHandshake(false, true);
+        server = createEchoServer(SecurityProtocol.SSL);
+        testIOExceptionsDuringHandshake(FailureAction.NO_OP, FailureAction.THROW_IO_EXCEPTION);
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Tests that if the remote end closes connection ungracefully  during SSL handshake while reading data,&lt;br/&gt;
+     * the disconnection is not treated as an authentication failure.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testUngracefulRemoteCloseDuringHandshakeRead() throws Exception &lt;/p&gt;
{
+        server = createEchoServer(SecurityProtocol.SSL);
+        testIOExceptionsDuringHandshake(server::closeSocketChannels, FailureAction.NO_OP);
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Tests that if the remote end closes connection ungracefully during SSL handshake while writing data,&lt;br/&gt;
+     * the disconnection is not treated as an authentication failure.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testUngracefulRemoteCloseDuringHandshakeWrite() throws Exception &lt;/p&gt;
{
+        server = createEchoServer(SecurityProtocol.SSL);
+        testIOExceptionsDuringHandshake(FailureAction.NO_OP, server::closeSocketChannels);
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private void testIOExceptionsDuringHandshake(boolean failRead, boolean failWrite) throws Exception {&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Tests that if the remote end closes the connection during SSL handshake while reading data,&lt;br/&gt;
+     * the disconnection is not treated as an authentication failure.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testGracefulRemoteCloseDuringHandshakeRead() throws Exception 
{
+        server = createEchoServer(SecurityProtocol.SSL);
+        testIOExceptionsDuringHandshake(FailureAction.NO_OP, server::closeKafkaChannels);
+    }
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Tests that if the remote end closes the connection during SSL handshake while writing data,&lt;br/&gt;
+     * the disconnection is not treated as an authentication failure.&lt;br/&gt;
+     */&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testGracefulRemoteCloseDuringHandshakeWrite() throws Exception &lt;/p&gt;
{
         server = createEchoServer(SecurityProtocol.SSL);
+        testIOExceptionsDuringHandshake(server::closeKafkaChannels, FailureAction.NO_OP);
+    }
&lt;p&gt;+&lt;br/&gt;
+    private void testIOExceptionsDuringHandshake(FailureAction readFailureAction,&lt;br/&gt;
+                                                 FailureAction flushFailureAction) throws Exception &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {         TestSslChannelBuilder channelBuilder = new TestSslChannelBuilder(Mode.CLIENT);         boolean done = false;         for (int i = 1; i &amp;lt;= 100; i++) {
-            int readFailureIndex = failRead ? i : Integer.MAX_VALUE;
-            int flushFailureIndex = failWrite ? i : Integer.MAX_VALUE;
             String node = String.valueOf(i);
 
-            channelBuilder.readFailureIndex = readFailureIndex;
-            channelBuilder.flushFailureIndex = flushFailureIndex;
+            channelBuilder.readFailureAction = readFailureAction;
+            channelBuilder.flushFailureAction = flushFailureAction;
+            channelBuilder.failureIndex = i;
             channelBuilder.configure(sslClientConfigs);
             this.selector = new Selector(5000, new Metrics(), new MockTime(), &quot;MetricGroup&quot;, channelBuilder, new LogContext());
 
@@ -734,7 +775,9 @@ private void testIOExceptionsDuringHandshake(boolean failRead, boolean failWrite
                     break;
                 }                 if (selector.disconnected().containsKey(node)) {
-                    assertEquals(ChannelState.State.AUTHENTICATE, selector.disconnected().get(node).state());
+                    ChannelState.State state = selector.disconnected().get(node).state();
+                    assertTrue(&quot;Unexpected channel state &quot; + state,
+                            state == ChannelState.State.AUTHENTICATE || state == ChannelState.State.READY);
                     break;
                 }             }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;@@ -973,13 +1016,23 @@ private NioEchoServer createEchoServer(SecurityProtocol securityProtocol) throws&lt;br/&gt;
         return createEchoServer(ListenerName.forSecurityProtocol(securityProtocol), securityProtocol);&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    @FunctionalInterface&lt;br/&gt;
+    private interface FailureAction {&lt;br/&gt;
+        FailureAction NO_OP = () -&amp;gt; { };&lt;br/&gt;
+        FailureAction THROW_IO_EXCEPTION = () -&amp;gt; &lt;/p&gt;
{
+            throw new IOException(&quot;Test IO exception&quot;);
+        }
&lt;p&gt;;&lt;br/&gt;
+        void run() throws IOException;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
     private static class TestSslChannelBuilder extends SslChannelBuilder {&lt;/p&gt;

&lt;p&gt;         private Integer netReadBufSizeOverride;&lt;br/&gt;
         private Integer netWriteBufSizeOverride;&lt;br/&gt;
         private Integer appBufSizeOverride;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;long readFailureIndex = Long.MAX_VALUE;&lt;/li&gt;
	&lt;li&gt;long flushFailureIndex = Long.MAX_VALUE;&lt;br/&gt;
+        private long failureIndex = Long.MAX_VALUE;&lt;br/&gt;
+        FailureAction readFailureAction = FailureAction.NO_OP;&lt;br/&gt;
+        FailureAction flushFailureAction = FailureAction.NO_OP;&lt;br/&gt;
         int flushDelayCount = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         public TestSslChannelBuilder(Mode mode) &lt;/p&gt;
{
@@ -1029,8 +1082,8 @@ public TestSslTransportLayer(String channelId, SelectionKey key, SSLEngine sslEn
                 this.netReadBufSize = new ResizeableBufferSize(netReadBufSizeOverride);
                 this.netWriteBufSize = new ResizeableBufferSize(netWriteBufSizeOverride);
                 this.appBufSize = new ResizeableBufferSize(appBufSizeOverride);
-                numReadsRemaining = new AtomicLong(readFailureIndex);
-                numFlushesRemaining = new AtomicLong(flushFailureIndex);
+                numReadsRemaining = new AtomicLong(failureIndex);
+                numFlushesRemaining = new AtomicLong(failureIndex);
                 numDelayedFlushesRemaining = new AtomicInteger(flushDelayCount);
             }

&lt;p&gt;@@ -1058,14 +1111,14 @@ protected int applicationBufferSize() {&lt;br/&gt;
             @Override&lt;br/&gt;
             protected int readFromSocketChannel() throws IOException &lt;/p&gt;
{
                 if (numReadsRemaining.decrementAndGet() == 0 &amp;amp;&amp;amp; !ready())
-                    throw new IOException(&quot;Test exception during read&quot;);
+                    readFailureAction.run();
                 return super.readFromSocketChannel();
             }

&lt;p&gt;             @Override&lt;br/&gt;
             protected boolean flush(ByteBuffer buf) throws IOException {&lt;br/&gt;
                 if (numFlushesRemaining.decrementAndGet() == 0 &amp;amp;&amp;amp; !ready())&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;throw new IOException(&quot;Test exception during write&quot;);&lt;br/&gt;
+                    flushFailureAction.run();&lt;br/&gt;
                 else if (numDelayedFlushesRemaining.getAndDecrement() != 0)&lt;br/&gt;
                     return false;&lt;br/&gt;
                 resetDelayedFlush();&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13261670">KAFKA-9021</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 17 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3vxnb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>