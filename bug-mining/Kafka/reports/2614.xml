<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:23:41 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-9921] Caching is not working properly with WindowStateStore when retaining duplicates</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-9921</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;I&apos;m using the current latest version 2.5.0 but this is not something new.&lt;/p&gt;

&lt;p&gt;I have &lt;em&gt;WindowStateStore&lt;/em&gt; configured as following (where &lt;em&gt;true&lt;/em&gt; stands for the &lt;em&gt;retainDuplicates&lt;/em&gt; paramter):&lt;br/&gt;
 &lt;em&gt;builder.addStateStore(windowStoreBuilder(persistentWindowStore(name, retentionPeriod, windowSize, &lt;b&gt;true&lt;/b&gt;), keySerde, valueSerde)&lt;b&gt;.withCachingEnabled()&lt;/b&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If I put 4 key-value pairs with the same key and values &lt;b&gt;1, 2, 3, 4&lt;/b&gt;&#160;in that order when reading them through the iterator I&apos;ll get the values &lt;b&gt;4, 2, 3, 4&lt;/b&gt;.&lt;br/&gt;
 I&apos;ve done a bit of investigation myself and the problem is that&#160;&lt;b&gt;the whole caching feature is written without consideration of the case where duplicates are retained&lt;/b&gt;.&lt;/p&gt;

&lt;p&gt;The observed behavior is due to having the last value in the cache (and it can have only one since it&apos;s not aware of the retain duplicates option) and it is read first (while skipping the first from the RocksDB iterator even though the values are different). This can be observed (for version 2.5.0) in&#160;&lt;em&gt;AbstractMergedSortedCacheStoreIterator#next()&lt;/em&gt; lines 95-97.&#160;Then the next 3 values are read from the RocksDB iterator so they are as expected.&lt;/p&gt;

&lt;p&gt;As I said, the whole feature is not considering the &lt;em&gt;retainDuplicates&lt;/em&gt; option so there are other examples of incorrect behavior like in &lt;em&gt;AbstractMergedSortedCacheStoreIterator&lt;/em&gt;&lt;em&gt;#peekNextKey()&lt;/em&gt;&#160;- for each call, you would skip one duplicate entry in the RocksDB iterator&#160;for the given key.&lt;/p&gt;

&lt;p&gt;In my use case, I want to persist a list of values for a given key without increasing the complexity to linear for a single event (which would be the case if I was always reading the current list appending one value and writing it back). So I go for &lt;em&gt;List&amp;lt;KeyValuePair&amp;lt;K, V&amp;gt;&amp;gt;&lt;/em&gt; instead of &lt;em&gt;KeyValuePair&amp;lt;K, List&amp;lt;V&amp;gt;&amp;gt;&lt;/em&gt;. The whole use case is more complex than that so I use &lt;em&gt;#transformValues&lt;/em&gt; and state stores.&lt;/p&gt;

&lt;p&gt;So as an impact I can&apos;t use caching on my state stores. For others - they&apos;ll have incorrect behavior that may take a lot of time to be discovered and even more time to fix the results.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13301051">KAFKA-9921</key>
            <summary>Caching is not working properly with WindowStateStore when retaining duplicates</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ableegoldman">A. Sophie Blee-Goldman</assignee>
                                    <reporter username="georgi.petkov">Georgi Petkov</reporter>
                        <labels>
                    </labels>
                <created>Sun, 26 Apr 2020 07:15:47 +0000</created>
                <updated>Mon, 30 Nov 2020 16:45:52 +0000</updated>
                            <resolved>Tue, 28 Apr 2020 20:06:44 +0000</resolved>
                                    <version>2.5.0</version>
                                    <fixVersion>2.5.1</fixVersion>
                    <fixVersion>2.6.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="17093773" author="bchen225242" created="Mon, 27 Apr 2020 17:49:15 +0000"  >&lt;p&gt;Hey &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=georgi.petkov&quot; class=&quot;user-hover&quot; rel=&quot;georgi.petkov&quot;&gt;georgi.petkov&lt;/a&gt;, would you mind explaining why you want to turn on caching while still retains duplicates?&lt;/p&gt;</comment>
                            <comment id="17093855" author="georgi.petkov" created="Mon, 27 Apr 2020 19:10:57 +0000"  >&lt;p&gt;The same reason you would ever want caching - for the expected performance improvement. I already explained why I need to retain the duplicates in the pre-last paragraph.&lt;/p&gt;

&lt;p&gt;Now that I think about it, maybe none of the operations can be optimized as much unless I&apos;ve already performed read operation on a key and I repeat that later on before flush (with or without changes in between). That is due to the fact that you never know if there are other values for the key you operate on unless you call the underlying store first.&lt;/p&gt;

&lt;p&gt;But all that is because I&apos;ve familiarized myself with the actual implementation. Nobody would ever consider any of this when reading the documentation or looking at the API. Even if you decide that no significant performance gain can be obtained at least you should disable this combination of caching and retaining duplicates since the results are incorrect even in a straightforward scenario like the one provided in the description.&lt;/p&gt;</comment>
                            <comment id="17093902" author="ableegoldman" created="Mon, 27 Apr 2020 20:18:06 +0000"  >&lt;p&gt;Hey &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=georgi.petkov&quot; class=&quot;user-hover&quot; rel=&quot;georgi.petkov&quot;&gt;georgi.petkov&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You&apos;re right that there seems to be a bug in the store hierarchy that makes duplicates incompatible with caching (and, unfortunately, also with changelogging &#8211; see &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-9923&quot; title=&quot;Join window store duplicates can be compacted in changelog &quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-9923&quot;&gt;&lt;del&gt;KAFKA-9923&lt;/del&gt;&lt;/a&gt;). Clearly they were never meant to be used in combination; note that duplicates in the DSL are only used for stream-stream joins, for which you can&apos;t enabled caching. Of course this unfortunately left PAPI users vulnerable.&lt;/p&gt;

&lt;p&gt;That said, I guess I&apos;m wondering what the expected semantics are? Note that &quot;duplicates&quot; in this context doesn&apos;t mean &quot;doubles&quot;, it stores any number of records with the same key. The only thing caching could really be expected to help with is reduce the number of idempotent updates, where the entire record is identical vs just the key. But that&apos;s kind of a separate matter. If you&apos;re interested you should check out&#160;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/KIP-557%3A+Add+emit+on+change+support+for+Kafka+Streams&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;KIP-557&lt;/a&gt;&#160;which is currently in progress. But there&apos;s really no reason to use caching with duplicates, so yes we should explicitly disallow this combination.&lt;/p&gt;</comment>
                            <comment id="17094176" author="georgi.petkov" created="Tue, 28 Apr 2020 05:50:40 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ableegoldman&quot; class=&quot;user-hover&quot; rel=&quot;ableegoldman&quot;&gt;ableegoldman&lt;/a&gt; WindowStateStores don&apos;t really offer updates (or deletes in that matter) at least when using &lt;em&gt;retainDuplicates&lt;/em&gt; so `idempotent updates` sounds inappropriate to me. For 2 puts I would expect 2 entries regardless if they accidentally match.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;I was unable to determine the expected bahavior when putting &lt;em&gt;null&lt;/em&gt; values in &lt;em&gt;WindowStateStore&lt;/em&gt; (from documentation).&lt;/b&gt; It turns out behaving like the &lt;em&gt;KeyValueStore&lt;/em&gt; - just delete the existing entry unless using&#160;&lt;em&gt;retainDuplicates&lt;/em&gt; - then&#160;&lt;b&gt;nothing happens, neither null is persisted nor any entries are deleted&lt;/b&gt;. I&apos;ve debugged the code and it reaches all the way to calling delete in RocksDB, so I&apos;m not sure this is intended (or at least could be skipped in this case). What do you think? Should I create a separate bug for that? What should be the expected behavior?&lt;/p&gt;

&lt;p&gt;Is there some other efficient approach for keeping a list by key? In my case, the store key is not the partition key but a relation between events and I would like to avoid repartitioning. To be honest I had a really hard time finding the appropriate tools for the job.&#160;The API is very limited in operations or at least no matter how I turn this around it feels that this is not the most efficient way to do things.&#160;&lt;b&gt;I have already partitioned data by a key that serves as a correlation ID (so data within a partition is self-contained).&lt;/b&gt; The problem could be summarized to &quot;&lt;b&gt;I need stream-stream join while avoiding repartitioning&lt;/b&gt;&quot;.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;If I go with PAPI then I need an efficient retention policy - go with &lt;em&gt;WindowStateStore&lt;/em&gt; (and its not that pleasant API when all you need is the retention policy). Then I need an efficient persisting of values by key - retain duplicates (so you only append new values),&#160; but it turns out no optimizations in terms of caching are possible. So far this seems like the best approach and this is what I&apos;m doing but it seems like I&apos;m reimplementing stream-stream join without repartitioning.&lt;/li&gt;
	&lt;li&gt;If I go for stream-stream join this means to repartition both streams first since I have different keys to join by. This means 2 extra topics that won&apos;t be reused for the internally used &lt;em&gt;WindowStateStores&lt;/em&gt;&#160;(and I know that my data is partitioned well enough already). It would have been nice if I had the option to avoid repartitioning with a &quot;my data is already properly partitioned / I know what I&apos;m doing&quot; option.&lt;/li&gt;
	&lt;li&gt;If I go with Clients API then I&apos;m basically starting from scratch with API that is hard to use right and there are no state stores available.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;b&gt;Any advice?&lt;/b&gt; Am I missing something?&lt;/p&gt;</comment>
                            <comment id="17094835" author="ableegoldman" created="Tue, 28 Apr 2020 19:53:04 +0000"  >&lt;p&gt;&amp;gt;&#160;For 2 puts I would expect 2 entries regardless if they accidentally match&lt;/p&gt;

&lt;p&gt;Fair enough. I guess for that reason&#160;then caching and inherently incompatible, right?&lt;/p&gt;

&lt;p&gt;Regarding putting&#160;&lt;em&gt;null&lt;/em&gt; values, I think the behavior with&#160;&lt;em&gt;retainDuplicates&lt;/em&gt; is as expected. The Streams library uses window stores with duplicates for stream-stream joins, for which a null value produces no output and isn&apos;t considered a tombstone (see &lt;a href=&quot;https://docs.confluent.io/current/streams/developer-guide/dsl-api.html#kstream-kstream-join&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;semantics of stream-stream joins&lt;/a&gt;&#160;section).&lt;/p&gt;

&lt;p&gt;I&apos;m starting to get a better sense of what you&apos;re trying to do here, but it sounds like the semantics you want might differ slightly from what Streams would consider a stream-stream join. Do you explicitly want a windowed join, or are you just using the window store because the retention policy will keep state from growing without bound? Does your use case require&#160;&lt;em&gt;null&lt;/em&gt; values to be treated as deletes?&lt;/p&gt;

&lt;p&gt;By the way, if the built-in stores don&apos;t match your requirements exactly you can always plug in a custom store. You could even just wrap one of the built-in stores to reuse the pieces that work for you, and skip the ones that don&apos;t. The rocksdb WindowStore is actually just built out of segments of the rocksdb KeyValueStore, for example.&lt;/p&gt;</comment>
                            <comment id="17094839" author="ableegoldman" created="Tue, 28 Apr 2020 19:58:23 +0000"  >&lt;p&gt;I take it you&apos;re using rocksdb, by the way? If you are (or can) use the in-memory stores then storing a list and appending should be pretty fast. On that note, I&apos;m actually not sure storing the entire list would be slower than storing individual duplicate records even with rocskdb. I actually have a suspicious that it might even be faster to store as a list, assuming the number and size of duplicates isn&apos;t incredibly large (relative to the memtable and block size scale)&lt;/p&gt;</comment>
                            <comment id="17094844" author="ableegoldman" created="Tue, 28 Apr 2020 20:05:10 +0000"  >&lt;p&gt;I&apos;m resolving the ticket because the PR to disable caching + duplicates and note this in the javadocs was just merged. If you have the chance to take a quick look and let me know if there&apos;s anything I missed clarifying in the docs, I can submit a quick followup PR or review one from you if you have something specific in mind&lt;/p&gt;</comment>
                            <comment id="17094900" author="georgi.petkov" created="Tue, 28 Apr 2020 22:19:19 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ableegoldman&quot; class=&quot;user-hover&quot; rel=&quot;ableegoldman&quot;&gt;ableegoldman&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Yeah, I agree that probably not much can be done in terms of caching (compared to the options without &lt;em&gt;retainDuplicates&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;I totally agree that many of the features like the null value behavior are correct and make perfect sense from point of view of the features implemented with it. Still, it&apos;s strange from the perspective where you use it standalone. &lt;b&gt;1-2 sentences clarifying the behavior with null values in the&#160;&lt;em&gt;WindowStateStore&lt;/em&gt;&#160;documentation could definitely help.&lt;/b&gt; In addition, as I said if this is the desired behavior &lt;b&gt;you can easily skip calling RocksDB for null values (when using&#160;&lt;em&gt;retainDuplicates)&lt;/em&gt;. This would both make the intention clearer and obviously avoid unnecessary calls.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;I do need exactly stream-stream join but without the repartition part. I want to get matches when there are new events in whichever stream, support duplicate keys in the stream and I also use &lt;em&gt;WindowStateStore&lt;/em&gt; only for the retention policy. In fact, due to the lack of many examples, I was looking at the stream-stream join implementation to find out how to correctly use the &lt;em&gt;WindowStateStores&lt;/em&gt;. I&apos;m building a library for some common yet not trivial at all operations on streams that you may need like topological sorting. Therefore I don&apos;t know if the user will provide null values or not. I was curious about the behavior with null values so I know what I&apos;m providing to the user. I&apos;ve tested it and that&apos;s how I found out what is the exact behavior.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;I&apos;m not sure that an in-memory or any custom state store will make it.&lt;/b&gt; Yes, in-memory will help with the efficient append because it avoids any expensive call and serializations/deserializations. Nevertheless, &lt;b&gt;you will always have the&#160;serializations/deserializations somewhere and this is the changelog topic and there you have also bandwidth&lt;/b&gt; (not just precious processing time). Even if the list is fixed to let&apos;s say only 5 items you will still have 15 (1 + 2 + 3 + 4 + 5) events recorded instead of 5. Obviously the size grows pretty fast - O(n^2). Combined with the fact that I want to provide a library to many different users (and duplicates count may vary a lot between usages) &lt;b&gt;to me it&apos;s best to implement just&#160;as in the stream-stream join - with duplicates&lt;/b&gt;. Still, it was a great discussion and made me more confident in my decisions. Thank you for your assistance.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Regarding the PR - it adds the same code to both&#160;&lt;em&gt;WindowStoreBuilder.java&lt;/em&gt;&#160;and &lt;em&gt;TimestampedWindowStoreBuilder.java&lt;/em&gt; but adds a test for only one of them.&lt;/b&gt;&lt;/p&gt;</comment>
                            <comment id="17101111" author="georgi.petkov" created="Wed, 6 May 2020 19:28:00 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ableegoldman&quot; class=&quot;user-hover&quot; rel=&quot;ableegoldman&quot;&gt;ableegoldman&lt;/a&gt;&#160;Did you get to read my last comment? At least the bolded text?&lt;/p&gt;</comment>
                            <comment id="17101130" author="ableegoldman" created="Wed, 6 May 2020 19:53:57 +0000"  >&lt;p&gt;Thanks for the reminder, just opened &lt;a href=&quot;https://github.com/apache/kafka/pull/8626&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;this small PR&lt;/a&gt; to add back in the test and hopefully clear up the handling of null values. Please take a look when you get the chance.&lt;/p&gt;</comment>
                            <comment id="17101215" author="georgi.petkov" created="Wed, 6 May 2020 21:50:51 +0000"  >&lt;p&gt;Maybe we can add the same information on the WindowStore#put method as well.&lt;/p&gt;

&lt;p&gt;It&apos;s a personal style preference but if there are short circuit checks in which cases you have trivial or no implementation I would put it at the beginning of the method instead of adding more branching in the rest of the logic. So I would write:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (some corner &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;) {
    doSomething();
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;instead of:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (some corner &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;) {
    doSomething();
} &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;code-comment&quot;&gt;// nested code
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (...) {
        ...
    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
        ...
    }
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It&apos;s kind of hard to explain. See &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/18454/should-i-return-from-a-function-early-or-use-an-if-statement&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;this&lt;/a&gt; question and InMemoryWindowStore#put.&lt;/p&gt;

&lt;p&gt;I haven&apos;t checked but I would guess that the behavior with null values and retainDuplicates has no explicit tests. If that it the case you could add some.&lt;/p&gt;</comment>
                            <comment id="17102168" author="ableegoldman" created="Fri, 8 May 2020 02:00:14 +0000"  >&lt;p&gt;No need to explain, I actually agree with you in general when it comes to returning early vs if/else. But the general consensus seems to be against returning early, speaking from experience (I&apos;ve been &quot;asked&quot; to switch to if/else in Streams code review before &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;)&#160;Anyways the current code base follows the if/else pattern, and consistency is more important than anything particular style issue imho.&#160;&lt;/p&gt;

&lt;p&gt;I&apos;m a bit hesitant to add this to the WindowStore#put API, because technically the WindowStore is and should be completely agnostic to the presence of duplicates. Put just guarantees that, for the given key, it will insert the value or delete that key&apos;s entry if null. The &quot;trick&quot; is that this key gets wrapped up with a unique id in the case of retainDuplicates, so the final #put call is not on the same key. In the case of retainDuplicates and null values we know this will be a no-op so we can just skip the delete, but it&apos;s really more of an optimization than a specific or special behavior.&lt;/p&gt;

&lt;p&gt;It&apos;s not very (or at all) straightforward, and ideally we would not even have this option but a separate store implementation entirely for the duplicates case. That&apos;s a much bigger scope of work, but maybe there are some small steps in the right direction we can take now. For example, instead of just hacking the duplicates in as a boolean switch, we could split that out into another store wrapper just like the cache, logging, metrics, etc. Then the DuplicatesWindowStore (any better name suggestions?) could do the key wrapping before delegating to the underlying store, which can then remove the hacky `retainDuplicates` flag. That seems like it would make the duplicate handling logic more explicit, and we can describe it further in the javadocs if necessary. WDYT?&lt;/p&gt;

&lt;p&gt;Feel free to comment on the PR directly btw. Thanks for the feedback!&lt;/p&gt;</comment>
                            <comment id="17102320" author="georgi.petkov" created="Fri, 8 May 2020 07:03:20 +0000"  >&lt;p&gt;I will do further comments regarding the code in the PR.&lt;/p&gt;

&lt;p&gt;Indeed usually boolean flags are a code smell indicating that perhaps another approach should be taken. The idea of adding another decorator sounds good. Still, things will be more explicit in the code but not in the API. Therefore your main concern regarding the fact that #put&#160;&lt;cite&gt;should be completely agnostic to the presence of duplicates&lt;/cite&gt;&#160;still remains. IMO it&apos;s better to mention it there than not. Since the library is providing it as a feature I guess it&apos;s not that much of an implementation detail than clarifying behavior. I can see how a user of the API may be confused that putting null will remove all entries with that key. If it&apos;s not written, personally I would either do a google search, check the implementation or test it and then add a test in my own code as a regression test since when not documented and guaranteed by the library this could change and I depend on it.&lt;/p&gt;

&lt;p&gt;Regarding the name -&#160;&lt;em&gt;DuplicatesWindowStore&lt;/em&gt; sounds more like it&apos;s storing only the duplicates or at least can be confusing. I would suggest &lt;em&gt;MultiValueWindowStore&lt;/em&gt; or something similar as it appears to be the general term for collections like Mutilset and Multimap.&lt;/p&gt;</comment>
                            <comment id="17102908" author="ableegoldman" created="Fri, 8 May 2020 20:16:56 +0000"  >&lt;p&gt;Fair enough. I added the clarification to WindowStore#put for now &#8211; I was thinking that ultimately it might make sense for the window store with duplicates to use an entirely different interface, in which case the comment on WindowStore#put would not really make sense, but we can always move things around later.&#160;&lt;/p&gt;

&lt;p&gt;I think refactoring out the retainDuplicates flag into a separate interface might make sense to do as part of the fix for&#160;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-9923&quot; title=&quot;Join window store duplicates can be compacted in changelog &quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-9923&quot;&gt;&lt;del&gt;KAFKA-9923&lt;/del&gt;&lt;/a&gt;&#160;although it&apos;ll require a KIP if we change or add to any of the supplier methods in Stores. It should be fairly straightforward though. If you have any strong opinions on what the duplicates API should look like we&apos;d welcome a KIP/PR.&lt;/p&gt;</comment>
                            <comment id="17102932" author="georgi.petkov" created="Fri, 8 May 2020 21:07:31 +0000"  >&lt;p&gt;If this will be handled in a more general and better way (as part of &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-9923&quot; title=&quot;Join window store duplicates can be compacted in changelog &quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-9923&quot;&gt;&lt;del&gt;KAFKA-9923&lt;/del&gt;&lt;/a&gt;) then perhaps you can skip the second commit that applies the optimization. The optimization is not really urgent and would only increase the complexity of the code to be refactored later (and has no explicit test for the handled case). Still - up to you, I&apos;m not strongly opinionated.&lt;/p&gt;

&lt;p&gt;I&apos;m not sure that we need any change to the current API. The use of an additional decorator in case of duplicates retention should remain hidden from the user&apos;s point of view. Can you be more concrete on the changes in the API that you&apos;re thinking of?&lt;/p&gt;</comment>
                            <comment id="17102953" author="ableegoldman" created="Fri, 8 May 2020 21:31:17 +0000"  >&lt;p&gt;I just meant deprecating the Stores#xxxWindowStore variants and creating new ones without the `retainDuplicates` flag, ie Stores#xxxwindowStore and Stores#xxxMultiValueWindowStore. It&apos;s not really necessary but I think it would be nice. Another unnecessary but potentially nice KIP-requiring change would be to create a separate interface for the retainDuplicates window stores &#8211; for example, the normal WindowStore#fetch(key, time) returns just a single value and doesn&apos;t really make sense for window stores with duplicates.&lt;/p&gt;</comment>
                            <comment id="17102959" author="georgi.petkov" created="Fri, 8 May 2020 21:41:41 +0000"  >&lt;p&gt;+1 for the new methods in Stores.&lt;/p&gt;

&lt;p&gt;Currently, fetches are only for a range and since the range can contain more than one window it can return more than one value even when not retaining duplicates. I don&apos;t see any fetch by a key and a single timestamp or do you mean to have one in the future?&lt;/p&gt;</comment>
                            <comment id="17102963" author="ableegoldman" created="Fri, 8 May 2020 21:48:08 +0000"  >&lt;p&gt;Ah, it&apos;s a bit hidden but there actually is a point-lookup fetch method. It&apos;s declared on&#160;ReadOnlyWindowStore instead of WindowStore. I guess because it&apos;s not used in the &quot;normal&quot; Streams code anywhere but is still allowed for IQ?&#160;&lt;/p&gt;</comment>
                            <comment id="17102974" author="georgi.petkov" created="Fri, 8 May 2020 22:14:26 +0000"  >&lt;p&gt;Oh yeah, my bad.&lt;/p&gt;

&lt;p&gt;Well, you can definitely start without new interfaces for the time being (preserving the current behavior even for the case with &lt;em&gt;WindowStore#fetch(key, time)&lt;/em&gt;). Then you won&apos;t need different return types and therefore different methods in &lt;em&gt;Stores&lt;/em&gt; - those can be added later (potentially when more information or opinions are present).&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310660">
                    <name>Completes</name>
                                            <outwardlinks description="fixes">
                                        <issuelink>
            <issuekey id="13050283">KAFKA-4887</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13301353">KAFKA-9923</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            5 years, 27 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0e2xs:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>