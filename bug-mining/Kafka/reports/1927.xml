<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:11:11 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6936] Scala API Wrapper for Streams uses default serializer for table aggregate</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6936</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;On of the goals of the Scala API is to not fall back on the configured default serializer, but let the compiler provide them through implicits.&lt;/p&gt;

&lt;p&gt;The aggregate method on KGroupedStream misses to achieve this goal.&lt;/p&gt;

&lt;p&gt;Compared to the Java API is this behavior very supprising, because no other stream operation falls back to the default serializer and a developer assums, that the compiler checks for the correct serializer type.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13161580">KAFKA-6936</key>
            <summary>Scala API Wrapper for Streams uses default serializer for table aggregate</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="DannyNullZwo">Daniel Heinrich</reporter>
                        <labels>
                    </labels>
                <created>Wed, 23 May 2018 20:38:46 +0000</created>
                <updated>Fri, 1 Jun 2018 14:12:31 +0000</updated>
                            <resolved>Fri, 1 Jun 2018 14:12:31 +0000</resolved>
                                    <version>2.0.0</version>
                                    <fixVersion>2.0.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16488381" author="guozhang" created="Thu, 24 May 2018 03:54:44 +0000"  >&lt;p&gt;Is this PR going to resolve your issue? &lt;a href=&quot;https://github.com/apache/kafka/pull/5066&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5066&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16488550" author="dannynullzwo" created="Thu, 24 May 2018 07:07:41 +0000"  >&lt;p&gt;ah, didn&apos;t see that PR. Yes this will fix this issue.&lt;/p&gt;</comment>
                            <comment id="16497374" author="githubbot" created="Fri, 1 Jun 2018 00:19:40 +0000"  >&lt;p&gt;guozhangwang closed pull request #5066: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6936&quot; title=&quot;Scala API Wrapper for Streams uses default serializer for table aggregate&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6936&quot;&gt;&lt;del&gt;KAFKA-6936&lt;/del&gt;&lt;/a&gt;: Implicit Materialized for aggregates&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/5066&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/5066&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/ImplicitConversions.scala b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/ImplicitConversions.scala&lt;br/&gt;
index c32563f563a..0c384a1bad0 100644&lt;br/&gt;
&amp;#8212; a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/ImplicitConversions.scala&lt;br/&gt;
+++ b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/ImplicitConversions.scala&lt;br/&gt;
@@ -19,19 +19,22 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.scala&lt;/p&gt;

&lt;p&gt;-import org.apache.kafka.streams.kstream.{KStream =&amp;gt; KStreamJ,&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;KTable =&amp;gt; KTableJ,&lt;br/&gt;
+import org.apache.kafka.streams.kstream.
{
   KGroupedStream =&amp;gt; KGroupedStreamJ,
+  KGroupedTable =&amp;gt; KGroupedTableJ,
+  KStream =&amp;gt; KStreamJ,
+  KTable =&amp;gt; KTableJ,
   SessionWindowedKStream =&amp;gt; SessionWindowedKStreamJ,
   TimeWindowedKStream =&amp;gt; TimeWindowedKStreamJ,
-  KGroupedTable =&amp;gt; KGroupedTableJ, _}
&lt;p&gt;-&lt;br/&gt;
+  _&lt;br/&gt;
+}&lt;br/&gt;
 import org.apache.kafka.streams.scala.kstream._&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue&lt;br/&gt;
 import org.apache.kafka.common.serialization.Serde&lt;br/&gt;
-&lt;br/&gt;
 import scala.language.implicitConversions&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+import org.apache.kafka.streams.processor.StateStore&lt;br/&gt;
+&lt;br/&gt;
 /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Implicit conversions between the Scala wrapper objects and the underlying Java&lt;/li&gt;
	&lt;li&gt;objects.&lt;br/&gt;
@@ -70,6 +73,10 @@ object ImplicitConversions {&lt;br/&gt;
   implicit def producedFromSerde&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(implicit keySerde: Serde&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, valueSerde: Serde&lt;span class=&quot;error&quot;&gt;&amp;#91;V&amp;#93;&lt;/span&gt;): Produced&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt; =&lt;br/&gt;
     Produced.`with`(keySerde, valueSerde)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+  implicit def materializedFromSerde&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, S &amp;lt;: StateStore&amp;#93;&lt;/span&gt;(implicit keySerde: Serde&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;,&lt;br/&gt;
+                                                            valueSerde: Serde&lt;span class=&quot;error&quot;&gt;&amp;#91;V&amp;#93;&lt;/span&gt;): Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, S&amp;#93;&lt;/span&gt; =&lt;br/&gt;
+    Materialized.`with`&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, S&amp;#93;&lt;/span&gt;(keySerde, valueSerde)&lt;br/&gt;
+&lt;br/&gt;
   implicit def joinedFromKeyValueOtherSerde&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, VO&amp;#93;&lt;/span&gt;&lt;br/&gt;
     (implicit keySerde: Serde&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, valueSerde: Serde&lt;span class=&quot;error&quot;&gt;&amp;#91;V&amp;#93;&lt;/span&gt;, otherValueSerde: Serde&lt;span class=&quot;error&quot;&gt;&amp;#91;VO&amp;#93;&lt;/span&gt;): Joined&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, VO&amp;#93;&lt;/span&gt; =&lt;br/&gt;
     Joined.`with`(keySerde, valueSerde, otherValueSerde)&lt;br/&gt;
diff --git a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedStream.scala b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedStream.scala&lt;br/&gt;
index 2e85bce91d1..0e5abfdd11b 100644&lt;br/&gt;
&amp;#8212; a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedStream.scala&lt;br/&gt;
+++ b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedStream.scala&lt;br/&gt;
@@ -36,18 +36,6 @@ import org.apache.kafka.streams.scala.FunctionConversions._&lt;br/&gt;
  */&lt;br/&gt;
 class KGroupedStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: KGroupedStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Count the number of records in this stream by the grouped key.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys and `Long` values that&lt;/li&gt;
	&lt;li&gt;* represent the latest (rolling) count (i.e., number of records) for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.KGroupedStream#count`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def count(): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long&amp;#93;&lt;/span&gt; = 
{
-    val c: KTable[K, java.lang.Long] = inner.count()
-    c.mapValues[Long](Long2long _)
-  }
&lt;p&gt;-&lt;br/&gt;
   /**&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Count the number of records in this stream by the grouped key.&lt;/li&gt;
	&lt;li&gt;The result is written into a local `KeyValueStore` (which is basically an ever-updating materialized view)&lt;br/&gt;
@@ -57,24 +45,13 @@ class KGroupedStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: KGroupedStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;/li&gt;
	&lt;li&gt;@return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys and `Long` values that&lt;/li&gt;
	&lt;li&gt;represent the latest (rolling) count (i.e., number of records) for each key&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.KGroupedStream#count`&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def count(materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
+   */&lt;br/&gt;
+  def count()(implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long&amp;#93;&lt;/span&gt; = 
{
     val c: KTable[K, java.lang.Long] =
       inner.count(materialized.asInstanceOf[Materialized[K, java.lang.Long, ByteArrayKeyValueStore]])
     c.mapValues[Long](Long2long _)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Combine the values of records in this stream by the grouped key.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param reducer   a function `(V, V) =&amp;gt; V` that computes a new aggregate result.&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;* latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.KGroupedStream#reduce`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def reduce(reducer: (V, V) =&amp;gt; V): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt; =&lt;/li&gt;
	&lt;li&gt;inner.reduce(reducer.asReducer)&lt;br/&gt;
-&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Combine the values of records in this stream by the grouped key.&lt;br/&gt;
    *&lt;br/&gt;
@@ -83,38 +60,25 @@ class KGroupedStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: KGroupedStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;/li&gt;
	&lt;li&gt;@return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.KGroupedStream#reduce`&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def reduce(reducer: (V, V) =&amp;gt; V, materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt; = 
{
-
+   */
+  def reduce(reducer: (V, V) =&amp;gt; V)(implicit materialized: Materialized[K, V, ByteArrayKeyValueStore]): KTable[K, V] =
     // need this explicit asReducer for Scala 2.11 or else the SAM conversion doesn&apos;t take place
     // works perfectly with Scala 2.12 though
-    inner.reduce(((v1: V, v2: V) =&amp;gt; reducer(v1, v2)).asReducer, materialized)
-  }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Aggregate the values of records in this stream by the grouped key.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param initializer   an `Initializer` that computes an initial intermediate aggregation result&lt;/li&gt;
	&lt;li&gt;* @param aggregator    an `Aggregator` that computes a new aggregate result&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;* latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.KGroupedStream#aggregate`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(aggregator: (K, V, VR) =&amp;gt; VR): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR&amp;#93;&lt;/span&gt; =&lt;/li&gt;
	&lt;li&gt;inner.aggregate((() =&amp;gt; initializer).asInitializer, aggregator.asAggregator)&lt;br/&gt;
+    inner.reduce(reducer.asReducer, materialized)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Aggregate the values of records in this stream by the grouped key.&lt;br/&gt;
    *&lt;/li&gt;
	&lt;li&gt;@param initializer   an `Initializer` that computes an initial intermediate aggregation result&lt;/li&gt;
	&lt;li&gt;@param aggregator    an `Aggregator` that computes a new aggregate result&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param materialized  an instance of `Materialized` used to materialize a state store.&lt;br/&gt;
+   * @param materialized  an instance of `Materialized` used to materialize a state store.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.KGroupedStream#aggregate`&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(aggregator: (K, V, VR) =&amp;gt; VR,&lt;/li&gt;
	&lt;li&gt;materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR&amp;#93;&lt;/span&gt; =&lt;br/&gt;
+   */&lt;br/&gt;
+  def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(aggregator: (K, V, VR) =&amp;gt; VR)(&lt;br/&gt;
+    implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;&lt;br/&gt;
+  ): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR&amp;#93;&lt;/span&gt; =&lt;br/&gt;
     inner.aggregate((() =&amp;gt; initializer).asInitializer, aggregator.asAggregator, materialized)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   /**&lt;br/&gt;
diff --git a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedTable.scala b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedTable.scala&lt;br/&gt;
index 87a11c5b835..99bc83e1ba0 100644&lt;br/&gt;
&amp;#8212; a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedTable.scala&lt;br/&gt;
+++ b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/KGroupedTable.scala&lt;br/&gt;
@@ -35,19 +35,6 @@ import org.apache.kafka.streams.scala.FunctionConversions._&lt;br/&gt;
  */&lt;br/&gt;
 class KGroupedTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(inner: KGroupedTableJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Count number of records of the original [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that got &lt;a href=&quot;#groupBy]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[KTable#groupBy]&lt;/a&gt; to&lt;/li&gt;
	&lt;li&gt;* the same key into a new instance of [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;].&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys and `Long` values that&lt;/li&gt;
	&lt;li&gt;* represent the latest (rolling) count (i.e., number of records) for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.KGroupedTable#count`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def count(): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long&amp;#93;&lt;/span&gt; = 
{
-    val c: KTable[K, java.lang.Long] = inner.count()
-    c.mapValues[Long](Long2long _)
-  }
&lt;p&gt;-&lt;br/&gt;
   /**&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Count number of records of the original [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that got &lt;a href=&quot;#groupBy]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[KTable#groupBy]&lt;/a&gt; to&lt;/li&gt;
	&lt;li&gt;the same key into a new instance of [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;].&lt;br/&gt;
@@ -57,7 +44,7 @@ class KGroupedTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(inner: KGroupedTableJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;/li&gt;
	&lt;li&gt;represent the latest (rolling) count (i.e., number of records) for each key&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.KGroupedTable#count`&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def count(materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
+  def count()(implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long&amp;#93;&lt;/span&gt; = {&lt;br/&gt;
     val c: KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, java.lang.Long&amp;#93;&lt;/span&gt; =&lt;br/&gt;
       inner.count(materialized.asInstanceOf[Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, java.lang.Long, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;])&lt;br/&gt;
     c.mapValues&lt;span class=&quot;error&quot;&gt;&amp;#91;Long&amp;#93;&lt;/span&gt;(Long2long _)&lt;br/&gt;
@@ -69,30 +56,13 @@ class KGroupedTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(inner: KGroupedTableJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;br/&gt;
    *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param adder      a function that adds a new value to the aggregate result&lt;/li&gt;
	&lt;li&gt;@param subtractor a function that removed an old value from the aggregate result&lt;br/&gt;
+   * @param materialized  an instance of `Materialized` used to materialize a state store.&lt;/li&gt;
	&lt;li&gt;@return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.KGroupedTable#reduce`&lt;br/&gt;
    */&lt;br/&gt;
   def reduce(adder: (V, V) =&amp;gt; V,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;subtractor: (V, V) =&amp;gt; V): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt; =&lt;/li&gt;
	&lt;li&gt;// need this explicit asReducer for Scala 2.11 or else the SAM conversion doesn&apos;t take place&lt;/li&gt;
	&lt;li&gt;// works perfectly with Scala 2.12 though&lt;/li&gt;
	&lt;li&gt;inner.reduce(adder.asReducer, subtractor.asReducer)&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Combine the value of records of the original [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that got &lt;a href=&quot;#groupBy]&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[KTable#groupBy]&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;* to the same key into a new instance of [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;].&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param adder      a function that adds a new value to the aggregate result&lt;/li&gt;
	&lt;li&gt;* @param subtractor a function that removed an old value from the aggregate result&lt;/li&gt;
	&lt;li&gt;* @param materialized  an instance of `Materialized` used to materialize a state store.&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;* latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.KGroupedTable#reduce`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def reduce(adder: (V, V) =&amp;gt; V,&lt;/li&gt;
	&lt;li&gt;subtractor: (V, V) =&amp;gt; V,&lt;/li&gt;
	&lt;li&gt;materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt; =&lt;br/&gt;
+             subtractor: (V, V) =&amp;gt; V)(implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V, ByteArrayKeyValueStore&amp;#93;&lt;/span&gt;): KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt; =&lt;br/&gt;
     // need this explicit asReducer for Scala 2.11 or else the SAM conversion doesn&apos;t take place&lt;br/&gt;
     // works perfectly with Scala 2.12 though&lt;br/&gt;
     inner.reduce(adder.asReducer, subtractor.asReducer, materialized)&lt;br/&gt;
@@ -104,27 +74,13 @@ class KGroupedTable&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(inner: KGroupedTableJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) 
{
    * @param initializer a function that provides an initial aggregate result value
    * @param adder       a function that adds a new record to the aggregate result
    * @param subtractor  an aggregator function that removed an old record from the aggregate result
+   * @param materialized  an instance of `Materialized` used to materialize a state store.
    * @return a [[KTable]] that contains &quot;update&quot; records with unmodified keys, and values that represent the
    * latest (rolling) aggregate for each key
    * @see `org.apache.kafka.streams.kstream.KGroupedTable#aggregate`
    */
-  def aggregate[VR](initializer: =&amp;gt; VR)(adder: (K, V, VR) =&amp;gt; VR, subtractor: (K, V, VR) =&amp;gt; VR): KTable[K, VR] =
-    inner.aggregate((() =&amp;gt; initializer).asInitializer, adder.asAggregator, subtractor.asAggregator)
-
-  /**
-   * Aggregate the value of records of the original [[KTable]] that got [[KTable#groupBy]]
-   * to the same key into a new instance of [[KTable]] using default serializers and deserializers.
-   *
-   * @param initializer a function that provides an initial aggregate result value
-   * @param adder       a function that adds a new record to the aggregate result
-   * @param subtractor  an aggregator function that removed an old record from the aggregate result
-   * @param materialized  an instance of `Materialized` used to materialize a state store. 
-   * @return a [[KTable]] that contains &quot;update&quot; records with unmodified keys, and values that represent the
-   * latest (rolling) aggregate for each key
-   * @see `org.apache.kafka.streams.kstream.KGroupedTable#aggregate`
-   */
-  def aggregate[VR](initializer: =&amp;gt; VR)(adder: (K, V, VR) =&amp;gt; VR,
-                                        subtractor: (K, V, VR) =&amp;gt; VR,
-                                        materialized: Materialized[K, VR, ByteArrayKeyValueStore]): KTable[K, VR] =
+  def aggregate[VR](initializer: =&amp;gt; VR)(adder: (K, V, VR) =&amp;gt; VR, subtractor: (K, V, VR) =&amp;gt; VR)(
+    implicit materialized: Materialized[K, VR, ByteArrayKeyValueStore]
+  ): KTable[K, VR] =
     inner.aggregate((() =&amp;gt; initializer).asInitializer, adder.asAggregator, subtractor.asAggregator, materialized)
 }
&lt;p&gt;diff --git a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/SessionWindowedKStream.scala b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/SessionWindowedKStream.scala&lt;br/&gt;
index fd2a56564b8..ed41973c090 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/SessionWindowedKStream.scala&lt;br/&gt;
+++ b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/SessionWindowedKStream.scala&lt;br/&gt;
@@ -40,45 +40,18 @@ class SessionWindowedKStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: SessionWindowedKStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;br/&gt;
    *&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param initializer    the initializer function&lt;/li&gt;
	&lt;li&gt;@param aggregator     the aggregator function&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* @param sessionMerger  the merger function&lt;br/&gt;
+   * @param merger         the merger function&lt;br/&gt;
+   * @param materialized  an instance of `Materialized` used to materialize a state store.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@return a windowed [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent&lt;/li&gt;
	&lt;li&gt;the latest (rolling) aggregate for each key within a window&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.SessionWindowedKStream#aggregate`&lt;br/&gt;
    */&lt;br/&gt;
   def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(aggregator: (K, V, VR) =&amp;gt; VR,&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;merger: (K, VR, VR) =&amp;gt; VR): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, VR] =&lt;/li&gt;
	&lt;li&gt;inner.aggregate((() =&amp;gt; initializer).asInitializer, aggregator.asAggregator, merger.asMerger)&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Aggregate the values of records in this stream by the grouped key and defined `SessionWindows`.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param initializer    the initializer function&lt;/li&gt;
	&lt;li&gt;* @param aggregator     the aggregator function&lt;/li&gt;
	&lt;li&gt;* @param sessionMerger  the merger function&lt;/li&gt;
	&lt;li&gt;* @param materialized  an instance of `Materialized` used to materialize a state store.&lt;/li&gt;
	&lt;li&gt;* @return a windowed [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent&lt;/li&gt;
	&lt;li&gt;* the latest (rolling) aggregate for each key within a window&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.SessionWindowedKStream#aggregate`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(&lt;/li&gt;
	&lt;li&gt;aggregator: (K, V, VR) =&amp;gt; VR,&lt;/li&gt;
	&lt;li&gt;merger: (K, VR, VR) =&amp;gt; VR,&lt;/li&gt;
	&lt;li&gt;materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR, ByteArraySessionStore&amp;#93;&lt;/span&gt;&lt;br/&gt;
+                                        merger: (K, VR, VR) =&amp;gt; VR)(&lt;br/&gt;
+    implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR, ByteArraySessionStore&amp;#93;&lt;/span&gt;&lt;br/&gt;
   ): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, VR] =&lt;br/&gt;
     inner.aggregate((() =&amp;gt; initializer).asInitializer, aggregator.asAggregator, merger.asMerger, materialized)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Count the number of records in this stream by the grouped key into `SessionWindows`.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return a windowed [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys and `Long` values&lt;/li&gt;
	&lt;li&gt;* that represent the latest (rolling) count (i.e., number of records) for each key within a window&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.SessionWindowedKStream#count`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def count(): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, Long] = 
{
-    val c: KTable[Windowed[K], java.lang.Long] = inner.count()
-    c.mapValues[Long](Long2long _)
-  }
&lt;p&gt;-&lt;br/&gt;
   /**&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Count the number of records in this stream by the grouped key into `SessionWindows`.&lt;br/&gt;
    *&lt;br/&gt;
@@ -87,23 +60,12 @@ class SessionWindowedKStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: SessionWindowedKStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;/li&gt;
	&lt;li&gt;that represent the latest (rolling) count (i.e., number of records) for each key within a window&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.SessionWindowedKStream#count`&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def count(materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArraySessionStore&amp;#93;&lt;/span&gt;): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, Long] = {&lt;br/&gt;
+  def count()(implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArraySessionStore&amp;#93;&lt;/span&gt;): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, Long] = 
{
     val c: KTable[Windowed[K], java.lang.Long] =
       inner.count(materialized.asInstanceOf[Materialized[K, java.lang.Long, ByteArraySessionStore]])
     c.mapValues[Long](Long2long _)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Combine values of this stream by the grouped key into 
{@link SessionWindows}.&lt;br/&gt;
-   *&lt;br/&gt;
-   * @param reducer           a reducer function that computes a new aggregate result. &lt;br/&gt;
-   * @return a windowed [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent&lt;br/&gt;
-   * the latest (rolling) aggregate for each key within a window&lt;br/&gt;
-   * @see `org.apache.kafka.streams.kstream.SessionWindowedKStream#reduce`&lt;br/&gt;
-   */&lt;br/&gt;
-  def reduce(reducer: (V, V) =&amp;gt; V): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, V] =&lt;br/&gt;
-    inner.reduce((v1, v2) =&amp;gt; reducer(v1, v2))&lt;br/&gt;
-&lt;br/&gt;
   /**&lt;br/&gt;
    * Combine values of this stream by the grouped key into {@link SessionWindows}
&lt;p&gt;.&lt;br/&gt;
    *&lt;br/&gt;
@@ -113,7 +75,8 @@ class SessionWindowedKStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: SessionWindowedKStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) &lt;/p&gt;
{
    * the latest (rolling) aggregate for each key within a window
    * @see `org.apache.kafka.streams.kstream.SessionWindowedKStream#reduce`
    */
-  def reduce(reducer: (V, V) =&amp;gt; V,
-    materialized: Materialized[K, V, ByteArraySessionStore]): KTable[Windowed[K], V] =
+  def reduce(reducer: (V, V) =&amp;gt; V)(
+    implicit materialized: Materialized[K, V, ByteArraySessionStore]
+  ): KTable[Windowed[K], V] =
     inner.reduce(reducer.asReducer, materialized)
 }
&lt;p&gt;diff --git a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/TimeWindowedKStream.scala b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/TimeWindowedKStream.scala&lt;br/&gt;
index a16c72b948e..9e31ab9a80a 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/TimeWindowedKStream.scala&lt;br/&gt;
+++ b/streams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/kstream/TimeWindowedKStream.scala&lt;br/&gt;
@@ -40,41 +40,16 @@ class TimeWindowedKStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: TimeWindowedKStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;br/&gt;
    *&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param initializer   an initializer function that computes an initial intermediate aggregation result&lt;/li&gt;
	&lt;li&gt;@param aggregator    an aggregator function that computes a new aggregate result&lt;br/&gt;
+   * @param materialized  an instance of `Materialized` used to materialize a state store.&lt;/li&gt;
	&lt;li&gt;@return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.TimeWindowedKStream#aggregate`&lt;br/&gt;
    */&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(aggregator: (K, V, VR) =&amp;gt; VR): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, VR] =&lt;/li&gt;
	&lt;li&gt;inner.aggregate((() =&amp;gt; initializer).asInitializer, aggregator.asAggregator)&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Aggregate the values of records in this stream by the grouped key.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param initializer   an initializer function that computes an initial intermediate aggregation result&lt;/li&gt;
	&lt;li&gt;* @param aggregator    an aggregator function that computes a new aggregate result&lt;/li&gt;
	&lt;li&gt;* @param materialized  an instance of `Materialized` used to materialize a state store.&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;* latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.TimeWindowedKStream#aggregate`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(&lt;/li&gt;
	&lt;li&gt;aggregator: (K, V, VR) =&amp;gt; VR,&lt;/li&gt;
	&lt;li&gt;materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR, ByteArrayWindowStore&amp;#93;&lt;/span&gt;&lt;br/&gt;
+  def aggregate&lt;span class=&quot;error&quot;&gt;&amp;#91;VR&amp;#93;&lt;/span&gt;(initializer: =&amp;gt; VR)(aggregator: (K, V, VR) =&amp;gt; VR)(&lt;br/&gt;
+    implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, VR, ByteArrayWindowStore&amp;#93;&lt;/span&gt;&lt;br/&gt;
   ): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, VR] =&lt;br/&gt;
     inner.aggregate((() =&amp;gt; initializer).asInitializer, aggregator.asAggregator, materialized)&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Count the number of records in this stream by the grouped key and the defined windows.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys and `Long` values that&lt;/li&gt;
	&lt;li&gt;* represent the latest (rolling) count (i.e., number of records) for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.TimeWindowedKStream#count`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def count(): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, Long] = 
{
-    val c: KTable[Windowed[K], java.lang.Long] = inner.count()
-    c.mapValues[Long](Long2long _)
-  }
&lt;p&gt;-&lt;br/&gt;
   /**&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Count the number of records in this stream by the grouped key and the defined windows.&lt;br/&gt;
    *&lt;br/&gt;
@@ -83,23 +58,12 @@ class TimeWindowedKStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: TimeWindowedKStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) {&lt;/li&gt;
	&lt;li&gt;represent the latest (rolling) count (i.e., number of records) for each key&lt;/li&gt;
	&lt;li&gt;@see `org.apache.kafka.streams.kstream.TimeWindowedKStream#count`&lt;br/&gt;
    */ &lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;def count(materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArrayWindowStore&amp;#93;&lt;/span&gt;): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, Long] = {&lt;br/&gt;
+  def count()(implicit materialized: Materialized&lt;span class=&quot;error&quot;&gt;&amp;#91;K, Long, ByteArrayWindowStore&amp;#93;&lt;/span&gt;): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, Long] = 
{
     val c: KTable[Windowed[K], java.lang.Long] =
       inner.count(materialized.asInstanceOf[Materialized[K, java.lang.Long, ByteArrayWindowStore]])
     c.mapValues[Long](Long2long _)
   }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Combine the values of records in this stream by the grouped key.&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param reducer   a function that computes a new aggregate result&lt;/li&gt;
	&lt;li&gt;* @return a [&lt;span class=&quot;error&quot;&gt;&amp;#91;KTable&amp;#93;&lt;/span&gt;] that contains &quot;update&quot; records with unmodified keys, and values that represent the&lt;/li&gt;
	&lt;li&gt;* latest (rolling) aggregate for each key&lt;/li&gt;
	&lt;li&gt;* @see `org.apache.kafka.streams.kstream.TimeWindowedKStream#reduce`&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;def reduce(reducer: (V, V) =&amp;gt; V): KTable[Windowed&lt;span class=&quot;error&quot;&gt;&amp;#91;K&amp;#93;&lt;/span&gt;, V] =&lt;/li&gt;
	&lt;li&gt;inner.reduce(reducer.asReducer)&lt;br/&gt;
-&lt;br/&gt;
   /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;Combine the values of records in this stream by the grouped key.&lt;br/&gt;
    *&lt;br/&gt;
@@ -109,7 +73,8 @@ class TimeWindowedKStream&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;(val inner: TimeWindowedKStreamJ&lt;span class=&quot;error&quot;&gt;&amp;#91;K, V&amp;#93;&lt;/span&gt;) 
{
    * latest (rolling) aggregate for each key
    * @see `org.apache.kafka.streams.kstream.TimeWindowedKStream#reduce`
    */
-  def reduce(reducer: (V, V) =&amp;gt; V,
-    materialized: Materialized[K, V, ByteArrayWindowStore]): KTable[Windowed[K], V] =
+  def reduce(reducer: (V, V) =&amp;gt; V)(
+    implicit materialized: Materialized[K, V, ByteArrayWindowStore]
+  ): KTable[Windowed[K], V] =
     inner.reduce(reducer.asReducer, materialized)
 }
&lt;p&gt;diff --git a/streams/streams-scala/src/test/scala/org/apache/kafka/streams/scala/WordCountTest.scala b/streams/streams-scala/src/test/scala/org/apache/kafka/streams/scala/WordCountTest.scala&lt;br/&gt;
index 12b8c8cb7b3..5abc1bcf6ff 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/streams-scala/src/test/scala/org/apache/kafka/streams/scala/WordCountTest.scala&lt;br/&gt;
+++ b/streams/streams-scala/src/test/scala/org/apache/kafka/streams/scala/WordCountTest.scala&lt;br/&gt;
@@ -87,7 +87,7 @@ class WordCountTest extends JUnitSuite with WordCountTestData {&lt;br/&gt;
     // generate word counts&lt;br/&gt;
     val wordCounts: KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;String, Long&amp;#93;&lt;/span&gt; =&lt;br/&gt;
       textLines.flatMapValues(v =&amp;gt; pattern.split(v.toLowerCase))&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;.groupBy((k, v) =&amp;gt; v)&lt;br/&gt;
+        .groupBy((_, v) =&amp;gt; v)&lt;br/&gt;
         .count()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     // write to output topic&lt;br/&gt;
@@ -119,7 +119,7 @@ class WordCountTest extends JUnitSuite with WordCountTestData {&lt;br/&gt;
     val wordCounts: KTable&lt;span class=&quot;error&quot;&gt;&amp;#91;String, Long&amp;#93;&lt;/span&gt; =&lt;br/&gt;
       textLines.flatMapValues(v =&amp;gt; pattern.split(v.toLowerCase))&lt;br/&gt;
         .groupBy((k, v) =&amp;gt; v)&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;.count(Materialized.as(&quot;word-count&quot;))&lt;br/&gt;
+        .count()(Materialized.as(&quot;word-count&quot;))&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     // write to output topic&lt;br/&gt;
     wordCounts.toStream.to(outputTopic)&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16497375" author="guozhang" created="Fri, 1 Jun 2018 00:20:07 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=DannyNullZwo&quot; class=&quot;user-hover&quot; rel=&quot;DannyNullZwo&quot;&gt;DannyNullZwo&lt;/a&gt; The PR has been merged to trunk, could you try it out and see if it resolved your needs?&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 24 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3u36v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>