<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 16:42:18 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-1642] [Java New Producer Kafka Trunk] CPU Usage Spike to 100% when network connection is lost</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-1642</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;I see my CPU spike to 100% when network connection is lost for while.  It seems network  IO thread are very busy logging following error message.  Is this expected behavior ?&lt;br/&gt;
2014-09-17 14:06:16.830 &lt;span class=&quot;error&quot;&gt;&amp;#91;kafka-producer-network-thread&amp;#93;&lt;/span&gt; ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: &lt;/p&gt;

&lt;p&gt;java.lang.IllegalStateException: No entry found for node -2&lt;/p&gt;

&lt;p&gt;at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:110)&lt;/p&gt;

&lt;p&gt;at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:99)&lt;/p&gt;

&lt;p&gt;at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:394)&lt;/p&gt;

&lt;p&gt;at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:380)&lt;/p&gt;

&lt;p&gt;at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:174)&lt;/p&gt;

&lt;p&gt;at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:175)&lt;/p&gt;

&lt;p&gt;at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)&lt;/p&gt;

&lt;p&gt;at java.lang.Thread.run(Thread.java:744)&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh&lt;/p&gt;</description>
                <environment></environment>
        <key id="12742642">KAFKA-1642</key>
            <summary>[Java New Producer Kafka Trunk] CPU Usage Spike to 100% when network connection is lost</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="ewencp">Ewen Cheslack-Postava</assignee>
                                    <reporter username="Bmis13">Bhavesh Mistry</reporter>
                        <labels>
                    </labels>
                <created>Fri, 19 Sep 2014 04:26:11 +0000</created>
                <updated>Tue, 6 Jan 2015 18:57:19 +0000</updated>
                            <resolved>Tue, 6 Jan 2015 18:57:19 +0000</resolved>
                                    <version>0.8.2.0</version>
                                    <fixVersion>0.8.2.0</fixVersion>
                                    <component>producer </component>
                        <due></due>
                            <votes>2</votes>
                                    <watches>11</watches>
                                                                                                                <comments>
                            <comment id="14140868" author="jkreps" created="Fri, 19 Sep 2014 16:55:30 +0000"  >&lt;p&gt;The intended behavior is that the client will periodically attempt to reconnect and update metadata until either it can reconnect or it discovers that a new node has taken over leadership for the given partition.&lt;/p&gt;

&lt;p&gt;There are two things that could be going on here: (1) our default backoffs could be too low or (2) the network selector could be busy waiting. The backoffs are controlled by reconnect.backoff.ms and retry.backoff.ms. reconnect.backoff.ms controls the amount of time to wait after the last connection attempt (whether successful or unsuccessful) before trying to make another connection attempt--this avoids trying to connect over and over again. This seems to default to only 10ms. The retry.backoff.ms controls the amount of time we wait before attempting to update the metadata. This defaults to 100ms.&lt;/p&gt;

&lt;p&gt;Alternatively, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; found and fixed a bug in the network selector that lead to busy waiting previously. Maybe there is another bug like that.&lt;/p&gt;

&lt;p&gt;Would you be willing to try setting the two backoffs to something high and see if you can reproduce the problem. The ideal would be a short piece of code that reproduces this that we could use for testing.&lt;/p&gt;</comment>
                            <comment id="14148121" author="bmis13" created="Thu, 25 Sep 2014 18:42:08 +0000"  >&lt;p&gt;HI &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jkreps&quot; class=&quot;user-hover&quot; rel=&quot;jkreps&quot;&gt;jkreps&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;I will work on the sample program. We are not setting reconnect.backoff.ms and retry.backoff.ms configuration so it would be default configuration.  Only thing I can tell you is that I have 4 Producer instances per JVM.  So this might amplify issue. &lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh &lt;/p&gt;</comment>
                            <comment id="14149875" author="jkreps" created="Fri, 26 Sep 2014 19:49:06 +0000"  >&lt;p&gt;Yeah a sample program that reproduces the issue would be excellent. That will help us take a look.&lt;/p&gt;</comment>
                            <comment id="14169415" author="bmis13" created="Mon, 13 Oct 2014 15:44:08 +0000"  >&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.io.IOException;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.io.InputStream;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.Properties;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.CountDownLatch;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ExecutorService;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.LinkedBlockingQueue;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.ThreadPoolExecutor;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.concurrent.TimeUnit;

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.kafka.clients.producer.Callback;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.kafka.clients.producer.KafkaProducer;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.kafka.clients.producer.Producer;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.kafka.clients.producer.ProducerRecord;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.apache.kafka.clients.producer.RecordMetadata;

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;TestNetworkDownProducer {
	
	&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numberTh = 200;
	&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; CountDownLatch latch = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; CountDownLatch(200);
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; IOException, InterruptedException {

		Properties prop = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Properties();
		InputStream propFile = &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.currentThread().getContextClassLoader()
				.getResourceAsStream(&lt;span class=&quot;code-quote&quot;&gt;&quot;kafkaproducer.properties&quot;&lt;/span&gt;);

		&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; topic = &lt;span class=&quot;code-quote&quot;&gt;&quot;test&quot;&lt;/span&gt;;
		prop.load(propFile);
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;Property: &quot;&lt;/span&gt; + prop.toString());
		StringBuilder builder = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; StringBuilder(1024);
		&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; msgLenth = 256;
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; msgLenth; i++)
			builder.append(&lt;span class=&quot;code-quote&quot;&gt;&quot;a&quot;&lt;/span&gt;);

		&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; numberOfProducer = 4;
		Producer[] producer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Producer[numberOfProducer];

		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; producer.length; i++) {
			producer[i] = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KafkaProducer(prop);
		}
		ExecutorService service =   &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(numberTh, numberTh,
                0L, TimeUnit.MILLISECONDS,
                &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Runnable&lt;/span&gt;&amp;gt;(numberTh *2));
		
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0 ; i &amp;lt; numberTh;i++){
			service.execute(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; MyProducer(producer,100000,builder.toString(), topic));
		}		
		latch.await();
		
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;All Producers done...!&quot;&lt;/span&gt;);
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; producer.length; i++) {
			producer[i].close();
		}		
		service.shutdownNow();
		&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;All done...!&quot;&lt;/span&gt;);

	}


	
	&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MyProducer &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Runnable&lt;/span&gt; {
		
		Producer[] producer;
		&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; maxloops;
		&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; msg ;
		&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; topic;
		
		MyProducer(Producer[] list, &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; maxloops,&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; msg,&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; topic){
			&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.producer = list;
			&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.maxloops = maxloops;
			&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.msg = msg;
			&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.topic = topic;
		}
		&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run() {
			ProducerRecord record = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ProducerRecord(topic, msg.toString().getBytes());
			Callback  callBack = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt;  MyCallback();
			&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt;{
				&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; j=0 ; j &amp;lt; maxloops ; j++){
					&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
						&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; producer.length; i++) {
							producer[i].send(record, callBack);
						}
						&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.sleep(10);
					} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Throwable th) {
						&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;FATAL &quot;&lt;/span&gt;);
						th.printStackTrace();
					}
				}

			}&lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
				latch.countDown();
			}			
		}
	}	

	&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MyCallback &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Callback {
		&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void onCompletion(RecordMetadata metadata, Exception exception) {
			&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(exception != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;){
				&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;Msg dropped..!&quot;&lt;/span&gt;);
				exception.printStackTrace();
			}
			
		}
	}
	
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is property file used:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;# THIS IS FOR NEW PRODUCERS API TRUNK Please see the configuration at https:&lt;span class=&quot;code-comment&quot;&gt;//kafka.apache.org/documentation.html#newproducerconfigs
&lt;/span&gt;# Broker List
bootstrap.servers= BROKERS HERE...
#Data Acks
acks=1
# 64MB of Buffer &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; log lines (including all messages).
buffer.memory=134217728
compression.type=snappy
retries=3
# DEFAULT FROM THE KAFKA...
# batch size =  ((buffer.memory) / (number of partitions)) (so we can have in progress batch size created &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; each partition.).
batch.size=1048576
#2MiB
max.request.size=1048576
send.buffer.bytes=2097152
# We &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; not want to block the buffer Full so application thread will not be blocked but logs lines will be dropped...
block.on.buffer.full=&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;
#2MiB
send.buffer.bytes=2097152
#wait...
linger.ms=5000
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14169453" author="bmis13" created="Mon, 13 Oct 2014 16:12:13 +0000"  >&lt;p&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jkreps&quot; class=&quot;user-hover&quot; rel=&quot;jkreps&quot;&gt;jkreps&lt;/a&gt;  Let me know if you need any other help !!&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Bhavesh &lt;/p&gt;</comment>
                            <comment id="14174462" author="bmis13" created="Thu, 16 Oct 2014 23:36:35 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jkreps&quot; class=&quot;user-hover&quot; rel=&quot;jkreps&quot;&gt;jkreps&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Did you get chance to re-produce the problem ?  Has someone else reported this issues or similar issue ?&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh &lt;/p&gt;</comment>
                            <comment id="14175360" author="ewencp" created="Fri, 17 Oct 2014 18:37:01 +0000"  >&lt;p&gt;Created reviewboard &lt;a href=&quot;https://reviews.apache.org/r/26885/diff/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://reviews.apache.org/r/26885/diff/&lt;/a&gt;&lt;br/&gt;
 against branch origin/trunk&lt;/p&gt;</comment>
                            <comment id="14177714" author="ewencp" created="Tue, 21 Oct 2014 00:34:02 +0000"  >&lt;p&gt;Updated reviewboard &lt;a href=&quot;https://reviews.apache.org/r/26885/diff/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://reviews.apache.org/r/26885/diff/&lt;/a&gt;&lt;br/&gt;
 against branch origin/trunk&lt;/p&gt;</comment>
                            <comment id="14177723" author="ewencp" created="Tue, 21 Oct 2014 00:42:01 +0000"  >&lt;p&gt;To summarize the issues fixed now:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Fix logic issue with &quot;expired&quot; in RecordAccumulator.ready&lt;/li&gt;
	&lt;li&gt;Don&apos;t include nodes that can send data when computing the delay until the next check for ready data. Including these doesn&apos;t make sense since their delays will change when we send data.&lt;/li&gt;
	&lt;li&gt;To correctly account for nodes with sendable data, use a timeout of 0 if we send any. This guarantees any necessary delay is computed immediately in the next round after some current data has been removed.&lt;/li&gt;
	&lt;li&gt;Properly account for nodes with sendable data under connection retry backoff. Since they weren&apos;t included in computing the next check delay when looking up ready nodes, we need to account for it later, but only if we conclude the node isn&apos;t ready. We need to incorporate the amount of backoff time still required before a retry will be performed (nothing else would wakeup at the right time, unlike other conditions like a full buffer which only change if data is received).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;It might be possible to break this into smaller commits for each one, but the ordering of applying them needs to be careful because some by themselves result in bad behavior &amp;#8211; the existing client worked because it often ended up with poll timeouts that were much more aggressive (i.e., often 0).&lt;/p&gt;</comment>
                            <comment id="14182165" author="ewencp" created="Thu, 23 Oct 2014 23:19:57 +0000"  >&lt;p&gt;Updated reviewboard &lt;a href=&quot;https://reviews.apache.org/r/26885/diff/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://reviews.apache.org/r/26885/diff/&lt;/a&gt;&lt;br/&gt;
 against branch origin/trunk&lt;/p&gt;</comment>
                            <comment id="14212635" author="ewencp" created="Fri, 14 Nov 2014 18:59:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=junrao&quot; class=&quot;user-hover&quot; rel=&quot;junrao&quot;&gt;junrao&lt;/a&gt; I think you reviewed most of this already since we discussed it offline, so I reassigned to you. I think this should be in good shape for committing.&lt;/p&gt;</comment>
                            <comment id="14212971" author="junrao" created="Fri, 14 Nov 2014 22:30:32 +0000"  >&lt;p&gt;Thanks for the patch. Committed to trunk.&lt;/p&gt;</comment>
                            <comment id="14213013" author="junrao" created="Fri, 14 Nov 2014 22:55:11 +0000"  >&lt;p&gt;Since this is relatively critical and the changes are only in the new java producer, double committed to 0.8.2 as well.&lt;/p&gt;</comment>
                            <comment id="14222571" author="bmis13" created="Mon, 24 Nov 2014 01:29:56 +0000"  >&lt;p&gt;The patch provided does not solve the problem.  When you have more than one or more producer instance,  the effect amplifies. &lt;/p&gt;

&lt;p&gt;org.apache.kafka.clients.producer.internals.Send.run() takes 100% CPU due to infinite  loop when there is no brokers (no work to be done to dump data).&lt;/p&gt;


&lt;p&gt;Thanks,&lt;br/&gt;
Bhavesh &lt;/p&gt;</comment>
                            <comment id="14222579" author="bmis13" created="Mon, 24 Nov 2014 01:52:38 +0000"  >&lt;p&gt;Please take look at experimental patch that solve this problem by capturing the correct Node state and also not so elegant by exponential backoff run() method by sleeping (many of the value is hard coded but it is just experimental).&lt;/p&gt;

&lt;p&gt;Also, there is another problem close() method on producer does not exit and JVM does not gracefully  shutdown because io thread is spinning in  while loop during network outage.  This is also another edge case. &lt;/p&gt;

&lt;p&gt;I hope this will be very helpful and solve problem.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh &lt;/p&gt;</comment>
                            <comment id="14222684" author="ewencp" created="Mon, 24 Nov 2014 05:31:48 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Bmis13&quot; class=&quot;user-hover&quot; rel=&quot;Bmis13&quot;&gt;Bmis13&lt;/a&gt; I&apos;ve only taken a quick look at the patch, but Sender.run() is intentionally a tight loop. The body of the loop calls Sender.run(time), which in turn calls Client.poll() with a timeout that &lt;b&gt;should&lt;/b&gt; keep it from actually being a tight loop. The previous patch fixed some issues in those other methods that were causing the timeout to incorrectly be 0, leading to the high CPU usage. If you&apos;re still seeing this problem, the right fix will almost definitely involve tracking down how a 0 (or very small) timeout is consistently being computed.&lt;/p&gt;

&lt;p&gt;The way I verified the previous patch was simple &amp;#8211; I ran the producer against a local cluster and then just disabled the network connection. Can you describe how you produce the error now? Things like whether there are already active connections to the brokers, if it&apos;s time sensitive (e.g. takes a certain amount of time to start using CPU), exactly how you simulate the network failure, and whether the issue is consistent or only happens intermittently would all be helpful details to know.&lt;/p&gt;

&lt;p&gt;The issue with it not shutting down is probably because the producer doesn&apos;t timeout messages when the leader it needs to send them to isn&apos;t available, but it waits to send any outstanding messages before shutting down. &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-1788&quot; title=&quot;producer record can stay in RecordAccumulator forever if leader is no available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-1788&quot;&gt;&lt;del&gt;KAFKA-1788&lt;/del&gt;&lt;/a&gt; is probably really the same issue since it&apos;s also caused by messages that never get sent and don&apos;t time out, although since that issue is specifically about the RecordAccumulator/buffer pool accounting, a fix for that issue may or may not fix the shutdown issue you&apos;re describing here.&lt;/p&gt;</comment>
                            <comment id="14223161" author="bmis13" created="Mon, 24 Nov 2014 17:25:33 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;The way to reproduce this is to simulate network instability by turning on and off network service (or turn on/off physical cable).   The connect and see if recover and disconnect and connect again etc.. you will see the behavior again and again. &lt;/p&gt;

&lt;p&gt;The issue is also with connection state management :&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void initiateConnect(Node node, &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; now) {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Initiating connection to node {} at {}:{}.&quot;&lt;/span&gt;, node.id(), node.host(), node.port());
            &lt;span class=&quot;code-comment&quot;&gt;// TODO FIX java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -3 (We need put before remove it..)..
&lt;/span&gt;            &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connectionStates.connecting(node.id(), now);  (This line has problem because it will loose previous last attempt made get above exception and it will &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; to connect to that node &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; ever and ever with exception )
            selector.connect(node.id(), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; InetSocketAddress(node.host(), node.port()), &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.socketSendBuffer, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.socketReceiveBuffer);
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {
            &lt;span class=&quot;code-comment&quot;&gt;/* attempt failed, we&apos;ll &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; again after the backoff */&lt;/span&gt;
            connectionStates.disconnectedWhenConnectting(node.id());
            &lt;span class=&quot;code-comment&quot;&gt;/* maybe the problem is our metadata, update it */&lt;/span&gt;
            metadata.requestUpdate();
            log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Error connecting to node {} at {}:{}:&quot;&lt;/span&gt;, node.id(), node.host(), node.port(), e);
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In my opinion, regardless of what node status is in run() method needs to be safe-guarded from still CPU Cycle when there is no state for Node.  (Hence I have added exponential sleep as temp solution to not to stealing CPU cycle , I think must protect it some how and must check the execution time...)&lt;/p&gt;

&lt;p&gt;Please let me know if you need more info  and i will be more than happy to reproduce bug and we can have conference call, and I can show you the problem.&lt;/p&gt;

&lt;p&gt;Based on code diff I have done from 0.8.1.1 tag and this.  This issue also occur in  0.8.1.1 as well I think.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Bhavesh &lt;/p&gt;
</comment>
                            <comment id="14223532" author="bmis13" created="Mon, 24 Nov 2014 21:20:55 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Also Regarding KafkaProder.close() method hangs for ever because of following loop, and &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;Sender.java

 &lt;span class=&quot;code-comment&quot;&gt;// okay we stopped accepting requests but there may still be
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// requests in the accumulator or waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; acknowledgment,
&lt;/span&gt;&lt;span class=&quot;code-comment&quot;&gt;// wait until these are completed.
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.accumulator.hasUnsent() || &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.client.inFlightRequestCount() &amp;gt; 0) {
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
run(time.milliseconds());
} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;Uncaught error in kafka producer I/O thread: &quot;&lt;/span&gt;, e);
}
}

KafkaProducer.java

 /**
* Close &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; producer. This method blocks until all in-flight requests complete.
*/
@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void close() {
log.trace(&lt;span class=&quot;code-quote&quot;&gt;&quot;Closing the Kafka producer.&quot;&lt;/span&gt;);
&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.sender.initiateClose();
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.ioThread.join();  &lt;span class=&quot;code-comment&quot;&gt;// THIS IS BLOCKED since ioThread does not give up so it is all related in my opinion.
&lt;/span&gt;} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
&lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; KafkaException(e);
}
&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.metrics.close();
log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;The Kafka producer has closed.&quot;&lt;/span&gt;);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The issue describe in &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-1788&quot; title=&quot;producer record can stay in RecordAccumulator forever if leader is no available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-1788&quot;&gt;&lt;del&gt;KAFKA-1788&lt;/del&gt;&lt;/a&gt;  is likelihood, but if you look the close call stack then calling thread that initiated the close() will hang till io thread dies (which it never dies when data is there and network is down).  &lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh&lt;/p&gt;</comment>
                            <comment id="14223571" author="bmis13" created="Mon, 24 Nov 2014 21:43:22 +0000"  >&lt;p&gt;Here is exact steps how to reproducer it bug: (Must have demon program continuously running).&lt;/p&gt;

&lt;p&gt;1)  Start with happy Situation where all borkers are up everything is running fine.  And verify all top -pid JAVA_PID and your kit (kafka network threads  are taking less than 4% CPU).&lt;br/&gt;
2)  Shutdown network (turn off network or pull the eth0 cable)  wait for while and you will see that CPU spike to 325% under top  (if you have 4 producer) and verify your kit is showing 25% CPU consumption for for each Kafka io thread.&lt;br/&gt;
3) Connect back the network ( Spike will still be there but CPU after while come down to 100% or so ) and remain connected for while.  &lt;br/&gt;
4) again simulate network failure (to simulate network instability) repeat steps again 1 to 4 but wait for 10 or so minutes in between and you will see the trends of CPU spike along with above exception. java.lang.IllegalStateException: No entry found for node -2&lt;/p&gt;

&lt;p&gt;Also, I see that Kafka is logging excessively when network is down (your kit shows it is taking more CPU Cycle  as compare  to normal)&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Bhavesh &lt;/p&gt;</comment>
                            <comment id="14223626" author="bmis13" created="Mon, 24 Nov 2014 22:15:42 +0000"  >&lt;p&gt;Also, there is issue in my experimental patch.  I did not update the lastConnectAttemptMs...in connecting state method to solve the issue with illegal sate exp:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; /**
     * Enter the connecting state &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the given node.
     * @param node The id of the node we are connecting to
     * @param now The current time.
     */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void connecting(&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; node, &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; now) {
    	NodeConnectionState nodeConn = nodeState.get(node); 
    	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(nodeConn == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;){
    		nodeState.put(node, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; NodeConnectionState(ConnectionState.CONNECTING, now));
    	}&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;{
    		nodeConn.state = ConnectionState.CONNECTING;
    		nodeConn.lastConnectAttemptMs = now;  (This will capture and update last connection attempt) 
    		
    	}
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14223755" author="ewencp" created="Mon, 24 Nov 2014 23:25:15 +0000"  >&lt;p&gt;Ok, so as I suspected, you need to wait awhile before the issue shows up. It looks to me like this is due to a metadata refresh. This causes metadataTimeout in Client.poll() to be 0, but then maybeUpdateMetadata is unable to make any progress since it can&apos;t connect to any nodes. The previous patch fixed issues that caused the timeout parameter to that method to be 0, so this is a similar issue. However, under normal testing it won&apos;t always show up immediately &amp;#8211; you need to wait until the next metadata refresh, which is currently every 5 minutes.&lt;/p&gt;

&lt;p&gt;I need to think more about the details of the fix. That timeout shouldn&apos;t consistently be 0 if we&apos;re just trying to refresh metadata, but we need to make sure we select an appropriate timeout for each case. Looking through maybeUpdateMetadata there are a few different possibilities:&lt;/p&gt;

&lt;p&gt;1. leastLoadedNode returns null, leaving no nodes available and we don&apos;t even try to refresh&lt;br/&gt;
2. The selected node is connected and we can send more data - we mark metadataFetchInProgress to avoid resending requests, but should probably also use that to determine the timeout on poll()&lt;br/&gt;
3. The selected node is connected but we can&apos;t send more data yet&lt;br/&gt;
4. The selected node is not connected, but we are allowed to try to initiate a connection based on the reconnection backoff.&lt;br/&gt;
4a. Trying to initiate the connection may return an immediate error&lt;br/&gt;
4b. Or we&apos;ll need to wait for the connection event.&lt;br/&gt;
5. The selected node is not connected and we aren&apos;t allowed to initiate a new connection yet.&lt;/p&gt;

&lt;p&gt;Given that all these conditions are based on the code in maybeUpdateMetadata (and initiateConnect, which it calls), it probably makes sense to have that code return an appropriate timeout to be used in poll(). But we need to make sure the selected values are also combined correctly with the timeout passed into poll() and that any wakeups before that time also subsequently produce correct values.&lt;/p&gt;

&lt;p&gt;The logic in the Sender.run() and NetworkClient.poll() are complex and need to handle a lot of different cases, but it should be possible to fix this problem only by adjusting that code without adding retries/backoff further up the stack. The core of this problem is just that that loop is selecting too small a timeout.&lt;/p&gt;</comment>
                            <comment id="14223779" author="bmis13" created="Mon, 24 Nov 2014 23:47:11 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Thanks for looking into this really appreciate your response. &lt;/p&gt;

&lt;p&gt;Also, do you think rapid connect and disconnect is also due to incorrect Node state management ?  connecting method and initiateConnection also ?&lt;/p&gt;

&lt;p&gt;Also, Can we also take the defensive coding and have protection in this tight infinite loop to throttle CPU cycle if it ends up with start-end duration is below some xx ms.  This will actually prevent this issues.    We had this issue on Prod so I just wanted to highlight the impact of 325% CPU and excessive logging. &lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh &lt;/p&gt;</comment>
                            <comment id="14224039" author="bmis13" created="Tue, 25 Nov 2014 04:23:09 +0000"  >&lt;p&gt;Here are some more cases to reproduce this simulating network connection issue with one of brokers only and still problem persist:&lt;/p&gt;

&lt;p&gt;Case 1:  brokers connection is down (note according to ZK leader for partition still with b1 ) &lt;br/&gt;
Have tree brokers: b1, b2, b3&lt;br/&gt;
1)  Start your daemon program and keep sending data to all the brokers and continue sending some data &lt;br/&gt;
2)  Observed that you have data  netstat -a | grep b1|b2|b3   (keep pumping data for 5 minutes and observed normal behavior using top -pid or top -p java_pid )&lt;br/&gt;
3) Simulate a network connection or problem establishing new TCP connection via following as java program still continues to pump data aggressively (please note TCP connection to B1 still active and connected)&lt;br/&gt;
a)  sudo vi /etc/hosts 2) add entry &quot;b1 127.0.0.1&quot; &lt;br/&gt;
b) /etc/init.d/network restart  after while (5 to 7 minutes you will see the issue but keep pumping data, and also repeat this for b2 it will be more CPU consumption) &lt;/p&gt;

&lt;p&gt;4) Under a heavy dumping data, now producer will try to establish new TCP connection to B1 and it will get connection refused (Note that CPU spikes up again and remain in state) just because could not establish.&lt;/p&gt;

&lt;p&gt;Case 2) Simulate Firewall rule such as you are only allowed (4 TCP connection to each brokers) &lt;/p&gt;

&lt;p&gt;Do step 1,2 and 3 above.&lt;br/&gt;
4) use Iptable rule to reject &lt;br/&gt;
To start an &quot;enforcing fire wall&quot;:&lt;br/&gt;
iptables -A OUTPUT -p tcp -m tcp -d b1 --dport 9092 -j REJECT&lt;br/&gt;
5) Still pump data will while iptable rejects ( you will see CPU spike to to 200% more depending on # of producer)&lt;br/&gt;
To &quot;recover&quot; :&lt;br/&gt;
iptables -D OUTPUT -p tcp -m tcp -d b1 --dport 9092 -j REJECT&lt;/p&gt;</comment>
                            <comment id="14224041" author="bmis13" created="Tue, 25 Nov 2014 04:28:44 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;I hope above steps will give you comprehensive steps to reproduce problems with run() method.  It would be really great if we can make the client more resilient and  robust so network and brokers instability does not cause CPU spikes and degrade application performance. Hence, I would strongly at least detect the time run(time) is taking and do some stats based on some configuration, we can do CPU Throttling (if need) just to be more defensive or at lest detect that io thread is taking CPU cycle.&lt;/p&gt;

&lt;p&gt;By the way the experimental patch still works for steps describe above as well due to hard coded back-off. &lt;/p&gt;

&lt;p&gt;Any time you have patch or any thing, please let me know I will test it out ( you have my email id) .  Once again thanks for your detail analysis and looking at this at short notice.  &lt;/p&gt;

&lt;p&gt;Please look into to ClusterConnectionStates and how it manage the state of node when disconnecting immediately . &lt;/p&gt;

&lt;p&gt;please look into  connecting(int node, long now) and this (I feel connecting needs to come before not after).&lt;br/&gt;
selector.connect(node.id(), new InetSocketAddress(node.host(), node.port()), this.socketSendBuffer, this.socketReceiveBuffer);&lt;br/&gt;
this.connectionStates.connecting(node.id(), now);&lt;/p&gt;

&lt;p&gt;Also, I still feel that produce.close() is also needs to be looked at (join() method with some configuration time out so thread does not hang)&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh  &lt;/p&gt;</comment>
                            <comment id="14224046" author="bmis13" created="Tue, 25 Nov 2014 04:43:05 +0000"  >&lt;p&gt;Also, Are you going to port back the patch to 0.8.1.1 version as well ?  Please let me know also.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Bhavesh &lt;/p&gt;</comment>
                            <comment id="14226751" author="bmis13" created="Wed, 26 Nov 2014 20:08:14 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Even setting long following parameter, states of system does get impacted does not matter what reconnect.backoff.ms and retry.backoff.ms is set to.  Once Node state is removed, the time out is set to 0.  Please see the following logs.  &lt;/p&gt;

&lt;p&gt;#15 minutes&lt;br/&gt;
reconnect.backoff.ms=900000&lt;br/&gt;
retry.backoff.ms=900000&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;2014-11-26 11:01:27.898 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:02:27.903 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:03:27.903 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:04:27.903 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:05:27.904 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:06:27.905 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:07:27.906 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:08:27.908 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:09:27.908 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:10:27.909 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:11:27.909 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:12:27.910 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:13:27.911 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:14:27.912 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:15:27.914 Kafka Drop message topic=.rawlog
org.apache.kafka.common.errors.TimeoutException: Failed to update metadata after 60000 ms.
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | heartbeat] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | rawlog] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -1
	at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:131)
	at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:120)
	at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:407)
	at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:393)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:187)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -3
	at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:131)
	at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:120)
	at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:407)
	at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:393)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:187)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | heartbeat] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | error] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | event] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -1
	at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:131)
	at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:120)
	at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:407)
	at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:393)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:187)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -1
	at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:131)
	at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:120)
	at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:407)
	at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:393)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:187)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | error] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -1
	at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:131)
	at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:120)
	at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:407)
	at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:393)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:187)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | rawlog] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -1
	at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:131)
	at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:120)
	at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:407)
	at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:393)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:187)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
 2014-11-26 11:00:27.613 [kafka-producer-network-thread | error] ERROR org.apache.kafka.clients.producer.internals.Sender - Uncaught error in kafka producer I/O thread: 
java.lang.IllegalStateException: No entry found &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; node -3
	at org.apache.kafka.clients.ClusterConnectionStates.nodeState(ClusterConnectionStates.java:131)
	at org.apache.kafka.clients.ClusterConnectionStates.disconnected(ClusterConnectionStates.java:120)
	at org.apache.kafka.clients.NetworkClient.initiateConnect(NetworkClient.java:407)
	at org.apache.kafka.clients.NetworkClient.maybeUpdateMetadata(NetworkClient.java:393)
	at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:187)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
	at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:115)
	at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14227286" author="soumen.sarkar" created="Thu, 27 Nov 2014 05:37:44 +0000"  >&lt;p&gt;Is it reasonable to expect that timeout should have a lower bound (say &lt;b&gt;100 ms&lt;/b&gt;) instead of being 0?&lt;/p&gt;</comment>
                            <comment id="14228040" author="bmis13" created="Fri, 28 Nov 2014 01:55:11 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=soumen.sarkar&quot; class=&quot;user-hover&quot; rel=&quot;soumen.sarkar&quot;&gt;soumen.sarkar&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Time out is one thing, but also IO Thread needs to be safe guarded to see how aggressive it is based on network and data to be send.  So it does not consume so much CPU cycle.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Bhavesh &lt;/p&gt;</comment>
                            <comment id="14229233" author="bmis13" created="Sun, 30 Nov 2014 20:24:18 +0000"  >&lt;p&gt;I just discovered yesterday that 0.8.1.1 release does not have new producer code base jar officially released jar (kafka-clients) although code is there in 0.8.1.1 branch.   That created confusion about porting to  0.8.1.1.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh &lt;/p&gt;</comment>
                            <comment id="14230709" author="ewencp" created="Mon, 1 Dec 2014 23:49:50 +0000"  >&lt;p&gt;Created reviewboard &lt;a href=&quot;https://reviews.apache.org/r/28582/diff/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://reviews.apache.org/r/28582/diff/&lt;/a&gt;&lt;br/&gt;
 against branch origin/trunk&lt;/p&gt;</comment>
                            <comment id="14230715" author="ewencp" created="Mon, 1 Dec 2014 23:54:37 +0000"  >&lt;p&gt;Attached a new patch that fixes all the timeout issues I&apos;m aware of. Here&apos;s how it addresses each of the situations I listed earlier:&lt;/p&gt;

&lt;p&gt;1. lastNoNodeAvailableMs is updated, which forces metadata timeout for each poll to be  use a backoff period&lt;/p&gt;

&lt;p&gt;2. Added another backoff value based on metadataFetchInProgress. Since the request actually made it out, this can be arbitrarily large &amp;#8211; we just need to see some sort of response or failure for the request.&lt;/p&gt;

&lt;p&gt;3. Requires some response to arrive to clear out space, so we can wait arbitrarily long. Updating lastNoNodeAvailableMs works even though it may wake up sooner than necessary. But making all cases that didn&apos;t send the data use a single approach keeps the code simpler.&lt;/p&gt;

&lt;p&gt;4a. This can happen if, e.g., the network interface has been taken down entirely. After fixing the ordering of marking the node as connecting and issuing the request, this cleans up after that error cleanly. lastNoNodeAvailableMs is updated since there &lt;b&gt;weren&apos;t&lt;/b&gt; any nodes available. This triggers a backoff period where the connection won&apos;t be retried.&lt;/p&gt;

&lt;p&gt;4b. This can be handled in the same way - we set lastNoNodeAvailableMs whether or not we immediately saw an error from the connection request. This causes it to sleep while waiting for the connection request. This may wake up before we get connected. However, if the node is still in the connecting state, it&apos;ll be ignored during the next round and we&apos;ll either start trying to connect to another node or we&apos;ll end up in state 1 with no nodes available. Either way, we still only wake up periodically based on the this timeout.&lt;/p&gt;

&lt;p&gt;5. Looking more carefully at how leastLoadedNode works, this case isn&apos;t actually possible.&lt;/p&gt;

&lt;p&gt;One additional note &amp;#8211; apparently you can&apos;t use Long.MAX_VALUE as a timeout, it throws an exception. That&apos;s why Integer.MAX_VALUE is there instead. We could also detect the large value and convert it to a negative value instead, which the underlying API treats as having no timeout.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Bmis13&quot; class=&quot;user-hover&quot; rel=&quot;Bmis13&quot;&gt;Bmis13&lt;/a&gt; can you test this out for the failure modes you found?&lt;/p&gt;</comment>
                            <comment id="14231830" author="stevenz3wu" created="Tue, 2 Dec 2014 17:59:42 +0000"  >&lt;p&gt;this sounds like a serious blocker issue. once this fix is confirmed and merged, is there any chance for a patch release of 0.8.2.1? &lt;/p&gt;</comment>
                            <comment id="14231837" author="ewencp" created="Tue, 2 Dec 2014 18:02:12 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stevenz3wu&quot; class=&quot;user-hover&quot; rel=&quot;stevenz3wu&quot;&gt;stevenz3wu&lt;/a&gt; this is already a blocker on 0.8.2. 0.8.2 hasn&apos;t been released yet, only a beta.&lt;/p&gt;</comment>
                            <comment id="14231867" author="stevenz3wu" created="Tue, 2 Dec 2014 18:18:38 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt; forgot 0.8.2 is still beta, because we are already using 0.8.2-beta now. thanks for the clarification.&lt;/p&gt;</comment>
                            <comment id="14232061" author="bmis13" created="Tue, 2 Dec 2014 20:00:45 +0000"  >&lt;p&gt;Hi  &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;I will not have time to validate this patch till next week.  &lt;/p&gt;

&lt;p&gt;Here is my comments:&lt;/p&gt;

&lt;p&gt;1) Producer.close() method issue is not address with patch. In event of network connection lost or other events happens, IO thread will not be killed and close method hangs. In patch that I have provided, I had timeout for join method and interrupted IO thread.  I think we need similar solution.&lt;/p&gt;

&lt;p&gt;2) Also, can we please add JMX monitoring for IO tread to know how quick it is running.  It will great to add this and run() method will report duration to metric in nano sec.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt;{
            	ThreadMXBean bean = ManagementFactory.getThreadMXBean( );
            	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(bean.isThreadCpuTimeSupported() &amp;amp;&amp;amp; bean.isThreadCpuTimeEnabled()){
            		&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.ioTheadCPUTime = metrics.sensor(&lt;span class=&quot;code-quote&quot;&gt;&quot;iothread-cpu&quot;&lt;/span&gt;);
                    &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.ioTheadCPUTime.add(&lt;span class=&quot;code-quote&quot;&gt;&quot;iothread-cpu-ms&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;The Rate Of CPU Cycle used by iothead in NANOSECONDS&quot;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Rate(TimeUnit.NANOSECONDS) {
                        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; measure(MetricConfig config, &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; now) {
                            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (now - metadata.lastUpdate()) / 1000.0;
                        }
                    });	            		
            	}
            }&lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt;(Throwable th){
            	log.warn(&lt;span class=&quot;code-quote&quot;&gt;&quot;Not able to set the CPU time... etc&quot;&lt;/span&gt;);
            }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3)  Please check the timeout final value in &lt;b&gt;pollTimeout&lt;/b&gt; if it is zero for constantly then we need to slow IO thread down.&lt;/p&gt;

&lt;p&gt;4)  Defensive check is need for back off  in run() method when IO thread is aggressive.  &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (running) {
        	&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; start = time.milliseconds();
            &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
                run(time.milliseconds());        
            } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
                log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;Uncaught error in kafka producer I/O thread: &quot;&lt;/span&gt;, e);
            }&lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt;{
            	&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; durationInMs = time.milliseconds() - start;
            	&lt;span class=&quot;code-comment&quot;&gt;// TODO Fix ME HERE GET DO exponential back-off sleep etc to prevent still CPU CYCLE HERE ?????? How Much ...&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the edge &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;...
&lt;/span&gt;            	&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(durationInMs &amp;lt; 200){
            		&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(client.isAllRegistredNodesAreDown()){
            			countinuousRetry++;
            			 &lt;span class=&quot;code-comment&quot;&gt;/// TODO MAKE THIS CONSTANT CONFIGURATION..... when &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; we &lt;span class=&quot;code-keyword&quot;&gt;rest&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; interval ????? so we can &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; aggressive again...
&lt;/span&gt;            			sleepInMs = ((&lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt;) &lt;span class=&quot;code-object&quot;&gt;Math&lt;/span&gt;.pow(2, countinuousRetry) * 500);
            		}&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt;{
            			sleepInMs =  500 ; 
            			countinuousRetry = 0;
            		}
            		
            		&lt;span class=&quot;code-comment&quot;&gt;// Wait until the desired next time arrives using nanosecond
&lt;/span&gt;            		&lt;span class=&quot;code-comment&quot;&gt;// accuracy timer (wait(time) isn&apos;t accurate enough on most platforms) 
&lt;/span&gt;            		&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            			&lt;span class=&quot;code-comment&quot;&gt;// TODO SLEEP IS NOT GOOD SOLUTON..
&lt;/span&gt;						&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.sleep(sleepInMs);
					} &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
						log.error(&lt;span class=&quot;code-quote&quot;&gt;&quot;While sleeping some one interupted &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; tread probally close method on prodcuer close () &quot;&lt;/span&gt;);
					}  
            	}
            }
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5)  When all nodes are disconnected, do you still want to spin the IO Thread ?&lt;/p&gt;

&lt;p&gt;6)  When you have a firewall rule that says &quot;you can only have 2 concurrent TCP connections from Client to Brokers&quot; and client still have live TCP connection to same node (Broker), but new TCP connections are rejected. Node State will be marked as Disconnected in initiateConnect ?  Is this case handled gracefully  ?&lt;/p&gt;

&lt;p&gt;By the way, thank you very much for quick reply and with new patch.  I appreciate your help.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh &lt;/p&gt;</comment>
                            <comment id="14232407" author="ewencp" created="Wed, 3 Dec 2014 00:57:06 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=Bmis13&quot; class=&quot;user-hover&quot; rel=&quot;Bmis13&quot;&gt;Bmis13&lt;/a&gt;, responses to each item:&lt;/p&gt;

&lt;p&gt;1. I&apos;m specifically trying to address the CPU usage here. I realize from your perspective they are closely related since they&apos;re both can be triggered by a loss of network connectivity, but internally they&apos;re really separate issues &amp;#8211; the CPU usage has to do with incorrect timeouts and the join() issues is due to the lack of timeouts on produce operations. That&apos;s why I pointed you toward &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-1788&quot; title=&quot;producer record can stay in RecordAccumulator forever if leader is no available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-1788&quot;&gt;&lt;del&gt;KAFKA-1788&lt;/del&gt;&lt;/a&gt;. If a timeout is added for data in the producer, that would resolve the close issue as well since any data waiting in the producer would eventually timeout and the IO thread could exit. I think that&apos;s the cleanest solution since it solves both problems with a single setting (the amount of time your willing to wait before discarding data). If you think a separate timeout specifically for Producer.close() is worthwhile I&apos;d suggest filing a separate JIRA for that.&lt;/p&gt;

&lt;p&gt;2. I think the measure() implementation you have is incorrect, it looks like the amount of time since the last metadata update. In any case, I think you&apos;d want a sensor there so it would take care of computing the rate for you. Is the use case for this just detecting the CPU spike? I suppose providing the average iteration rate can at least tell you the source of CPU usage compared to just monitoring CPU at the system level. But (as described below) it&apos;s not necessarily bad for the rate to be quite high. And an average also doesn&apos;t tell you much except maybe in the extreme case that we&apos;re fixing with this patch. Before just adding another metric, maybe we should think through exactly what you&apos;re trying to measure/monitor and how best to reveal that information?&lt;/p&gt;

&lt;p&gt;3. I probably should have given a better explanation earlier for why that approach is problematic. In a lot of cases, you &lt;b&gt;want&lt;/b&gt; run() to use small timeouts. If you&apos;re pumping a lot of data through, saturating your network connection, then you&apos;re likely to going to need to poll very fast and end up with consistently small timeouts (e.g. if you produce to many topics and consistently have data flowing through them, you&apos;ll end up using the linger period and your timeout will generally be a fraction of that period). In other words, if we&apos;ve actually given the producer a lot of work to do, then we should expect that it will use short timeouts and eat up CPU. You found that you could work around your particular issue by backing off, but it breaks another very important use case &amp;#8211; high throughput to the producer. I bet if you ran performance tests with it enabled you would find diminished performance. Fundamentally the bug wasn&apos;t that we were sometimes computing small timeouts consistently, it was that we were computing &lt;b&gt;incorrect&lt;/b&gt; timeouts. If we get the timeouts computed correctly, then we&apos;ll properly support both cases.&lt;/p&gt;

&lt;p&gt;4. See explanation in 3. The rate of this loop is controlled by correct computation of timeouts. I think the only case this code could be an issue is if we compute correct timeouts, but then consistently see exceptions that are only caught by this block. That shouldn&apos;t be happening consistenly, and if you find an example where it is then we should catch that exception deeper in the call stack and handle it more gracefully.&lt;/p&gt;

&lt;p&gt;5. The thread still has to be available so that when send() is called again it can initiate a connection. What should happen now (after my patch) if there is no work to do is that we&apos;ll still run the loop, but the timeout will be very large so it basically won&apos;t be using any CPU. If we get a request to send data, a wakeup() call wakes it back up before the timeout so it can start sending data immediately.&lt;/p&gt;

&lt;p&gt;6. It should be handled gracefully, and should have been fixed by the original patch (although maybe the fix to the ordering in initiateConnect in the second patch was also necessary). The logic in Sender.run() adjusts timeouts when it finds nodes that aren&apos;t ready to send data (i.e. are disconnected) and makes sure we backoff when connection attempts fail. This is a fixed backoff (reconnect.backoff.ms, default 10ms), but is enough to avoid high CPU usage.&lt;/p&gt;</comment>
                            <comment id="14234297" author="bmis13" created="Thu, 4 Dec 2014 16:01:53 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;1) I will posted toward &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-1788&quot; title=&quot;producer record can stay in RecordAccumulator forever if leader is no available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-1788&quot;&gt;&lt;del&gt;KAFKA-1788&lt;/del&gt;&lt;/a&gt; and perhaps link the issue.&lt;br/&gt;
2) True , some sort of measure would be great 5,10...25 50, 95 and 99 percentile would be great of execution time.  The point is just measure the duration report the rate of execution. &lt;br/&gt;
3) Agree with what you are saying and I have observed same behavior.  But only recommendation is to add some intelligence to &lt;b&gt;timeouts&lt;/b&gt; to detect if for long period and consecutive timeout is zero then there is problem. (Little more defensive) &lt;br/&gt;
4) Again I agree with you point, but based in your previous comments you had mentioned that you may consider having back-off logic further up the chain. So I was just checking run() is best place to do that check.  Again, may be add intelligence here if you get consecutive &#8220;Exception&#8221; then likelihood of high CPU is high.  &lt;/p&gt;

&lt;p&gt;5) Ok.  I agree what you are saying is data needs to be de-queue so more data can be en-queue even in event of network lost.  Is my understanding correct ?&lt;/p&gt;

&lt;p&gt;6) All I am saying is network firewall rule (such as only 2 TCP connections per source host) or Brokers running out of File Descriptor so new connection to broker is not established but Client have live and active TCP connection to same broker.  But based on what I see in the method * initiateConnect* will mark the entire Broker or Node status as disconnected.  Is this expected behavior?  So question is: will client continue to send data ?&lt;/p&gt;

&lt;p&gt;Thank you very much for entertaining my questions so far and I will test out the patch next week.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh &lt;/p&gt;</comment>
                            <comment id="14239063" author="bmis13" created="Tue, 9 Dec 2014 06:52:42 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=stevenz3wu&quot; class=&quot;user-hover&quot; rel=&quot;stevenz3wu&quot;&gt;stevenz3wu&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;0.8.2 is very well tested and worked well under heavy load.  This bug is rare only happen when broker or network has issue.  We have been producing about 7 to 10 TB per day using this new producer, so 0.8.2 is very safe to use in production.  It has survived  pick traffic of the year on large e-commerce site.  So I am fairly confident that  New Java API is indeed does true round-robin and much faster than Scala Based API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,  I will verify the patch by end of this Friday, but do let me know your understanding based on my last comment. The goal is to rest this issue and cover all the use case.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh&lt;/p&gt;</comment>
                            <comment id="14257686" author="bmis13" created="Tue, 23 Dec 2014 23:35:36 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Patch indeed solve the high CPU Problem reported by this bug.  I have tested all brokers down, one broker down and two broker down (except for last use cases where one of the brokers runs out of Socket File Descriptor a rear case) :  I am sorry for last response, I got busy with other stuff so testing got delayed.&lt;/p&gt;

&lt;p&gt;Here are some interesting Observations from YourKit:&lt;/p&gt;

&lt;p&gt;0)  Overall, patch has also brought down  overall consumption in Normal Healthy or Happy case where every thing is up and running.  In old code (without patch), I used to see about 10% of overall CPU used by  io threads (4 in my case), it has reduce to 5% or less now with patch.   &lt;/p&gt;

&lt;p&gt;1)	When two brokers are down, then occasionally I see IO thread blocked. ( I did not see this when one brokers is down) &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;kafka-producer-network-thread | rawlog [BLOCKED] [DAEMON]
org.apache.kafka.clients.producer.internals.Metadata.fetch() Metadata.java:70
java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run() &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2)	record-error-rate metric remain zero despite following firewall rule.  In my opinion, it should have called  org.apache.kafka.clients.producer.Callback  but I did not see that happening either in either one or two brokers down.  Should I file another issue for this ? Please confirm.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
sudo ipfw add reject tcp from me to b1.ip dst-port 9092
sudo ipfw add reject tcp from me to b2.ip dst-port 9092

00100 reject tcp from me to b1.ip dst-port 9092
00200 reject tcp from me to b2.ip dst-port 9092
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;	&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;LoggingCallBaHandler &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Callback {

		/**
		 * A callback method the user can implement to provide asynchronous
		 * handling of request completion. This method will be called when the
		 * record sent to the server has been acknowledged. Exactly one of the
		 * arguments will be non-&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;.
		 * 
		 * @param metadata
		 *            The metadata &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; the record that was sent (i.e. the
		 *            partition and offset). Null &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; an error occurred.
		 * @param exception
		 *            The exception thrown during processing of &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; record.
		 *            Null &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; no error occurred.
		 */
		@Override
		&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void onCompletion(RecordMetadata metadata, Exception exception) {
			&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(exception != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;){
				exception.printStackTrace();
			}
		}
	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I do not see any exception at all on console....not sure why ?&lt;/p&gt;

&lt;p&gt;3)	Application does NOT gracefully shutdown when there one or more brokers are down. (io Thread never exits this is know issue ) &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot;SIGTERM handler&quot;&lt;/span&gt; daemon prio=5 tid=0x00007f8bd79e4000 nid=0x17907 waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; monitor entry [0x000000011e906000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: BLOCKED (on object monitor)
        at java.lang.Shutdown.exit(Shutdown.java:212)
        - waiting to lock &amp;lt;0x000000070008f7c0&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; java.lang.Shutdown)
        at java.lang.Terminator$1.handle(Terminator.java:52)
        at sun.misc.Signal$1.run(Signal.java:212)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)

&lt;span class=&quot;code-quote&quot;&gt;&quot;SIGTERM handler&quot;&lt;/span&gt; daemon prio=5 tid=0x00007f8bd5159000 nid=0x1cb0b waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; monitor entry [0x000000011e803000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: BLOCKED (on object monitor)
        at java.lang.Shutdown.exit(Shutdown.java:212)
        - waiting to lock &amp;lt;0x000000070008f7c0&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; java.lang.Shutdown)
        at java.lang.Terminator$1.handle(Terminator.java:52)
        at sun.misc.Signal$1.run(Signal.java:212)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)

&lt;span class=&quot;code-quote&quot;&gt;&quot;SIGTERM handler&quot;&lt;/span&gt; daemon prio=5 tid=0x00007f8bdd147800 nid=0x15d0b waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; monitor entry [0x000000011e30a000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: BLOCKED (on object monitor)
        at java.lang.Shutdown.exit(Shutdown.java:212)
        - waiting to lock &amp;lt;0x000000070008f7c0&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; java.lang.Shutdown)
        at java.lang.Terminator$1.handle(Terminator.java:52)
        at sun.misc.Signal$1.run(Signal.java:212)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)

&lt;span class=&quot;code-quote&quot;&gt;&quot;SIGTERM handler&quot;&lt;/span&gt; daemon prio=5 tid=0x00007f8bdf820000 nid=0x770b waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; monitor entry [0x000000011e207000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: BLOCKED (on object monitor)
        at java.lang.Shutdown.exit(Shutdown.java:212)
        - waiting to lock &amp;lt;0x000000070008f7c0&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; java.lang.Shutdown)
        at java.lang.Terminator$1.handle(Terminator.java:52)
        at sun.misc.Signal$1.run(Signal.java:212)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)

&lt;span class=&quot;code-quote&quot;&gt;&quot;SIGTERM handler&quot;&lt;/span&gt; daemon prio=5 tid=0x00007f8bdc393800 nid=0x1c30f waiting &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; monitor entry [0x000000011e104000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: BLOCKED (on object monitor)
        at java.lang.Shutdown.exit(Shutdown.java:212)
        - waiting to lock &amp;lt;0x000000070008f7c0&amp;gt; (a java.lang.&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; java.lang.Shutdown)
        at java.lang.Terminator$1.handle(Terminator.java:52)
        at sun.misc.Signal$1.run(Signal.java:212)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)

&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;-4&quot;&lt;/span&gt; prio=5 tid=0x00007f8bdb39f000 nid=0xa107 in &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;.wait() [0x000000011ea89000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: WAITING (on object monitor)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;.$$YJP$$wait(Native Method)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;.wait(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;.java)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.join(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:1280)
        - locked &amp;lt;0x0000000705c2f650&amp;gt; (a org.apache.kafka.common.utils.KafkaThread)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.join(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:1354)
        at org.apache.kafka.clients.producer.KafkaProducer.close(KafkaProducer.java:322)
        at 

&lt;span class=&quot;code-quote&quot;&gt;&quot;kafka-producer-network-thread | error&quot;&lt;/span&gt; daemon prio=5 tid=0x00007f8bd814e000 nid=0x7403 runnable [0x000000011e6c0000]
   java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.State: RUNNABLE
        at sun.nio.ch.KQueueArrayWrapper.$$YJP$$kevent0(Native Method)
        at sun.nio.ch.KQueueArrayWrapper.kevent0(KQueueArrayWrapper.java)
        at sun.nio.ch.KQueueArrayWrapper.poll(KQueueArrayWrapper.java:200)
        at sun.nio.ch.KQueueSelectorImpl.doSelect(KQueueSelectorImpl.java:103)
        at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:87)
        - locked &amp;lt;0x0000000705c109f8&amp;gt; (a sun.nio.ch.Util$2)
        - locked &amp;lt;0x0000000705c109e8&amp;gt; (a java.util.Collections$UnmodifiableSet)
        - locked &amp;lt;0x0000000705c105c8&amp;gt; (a sun.nio.ch.KQueueSelectorImpl)
        at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:98)
        at org.apache.kafka.common.network.Selector.select(Selector.java:322)
        at org.apache.kafka.common.network.Selector.poll(Selector.java:212)
        at org.apache.kafka.clients.NetworkClient.poll(NetworkClient.java:192)
        at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:184)
        at org.apache.kafka.clients.producer.internals.Sender.run(Sender.java:128)
        at java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.run(&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.java:744)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thank you for the patch fix.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Bhavesh&lt;/p&gt;</comment>
                            <comment id="14257788" author="ewencp" created="Wed, 24 Dec 2014 01:27:32 +0000"  >&lt;p&gt;1) Since this method just returns data, it probably just happens to have had to wait for the lock. Not a big deal, we would expect to see that occasionally.&lt;/p&gt;

&lt;p&gt;2) Right now this is expected, as explained in &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-1788&quot; title=&quot;producer record can stay in RecordAccumulator forever if leader is no available&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-1788&quot;&gt;&lt;del&gt;KAFKA-1788&lt;/del&gt;&lt;/a&gt;. I saw there&apos;s patch for that one now, might help if you tested that out and see if gives the behavior you were expecting.&lt;/p&gt;

&lt;p&gt;3) As you said, known issue so we can leave that for other JIRAs to resolve.&lt;/p&gt;</comment>
                            <comment id="14257805" author="bmis13" created="Wed, 24 Dec 2014 01:40:18 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;Thanks for patch.  You may close this issue.   The only thing,  I have not tested the rare case where a single broker is out of File Descriptor and under heavy load on producer will request more connections to same broker.  According to code, it will mark the Node State to disconnect and I am not sure if data will be sent via already live connection.  &lt;/p&gt;

&lt;p&gt;Another comment is that there is no WARN or ERROR message logged when connection fails. Can we please change the log level for following code to WAR, because in production environment people set LOG LEVEL to WARN or ERROR.  So there will no visibility if there is connection issue.  &lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;   /**
     * Initiate a connection to the given node
     */
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void initiateConnect(Node node, &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; now) {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Initiating connection to node {} at {}:{}.&quot;&lt;/span&gt;, node.id(), node.host(), node.port());
            &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.connectionStates.connecting(node.id(), now);
            selector.connect(node.id(), &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; InetSocketAddress(node.host(), node.port()), &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.socketSendBuffer, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.socketReceiveBuffer);
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {
            &lt;span class=&quot;code-comment&quot;&gt;/* attempt failed, we&apos;ll &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; again after the backoff */&lt;/span&gt;
            connectionStates.disconnected(node.id());
            &lt;span class=&quot;code-comment&quot;&gt;/* maybe the problem is our metadata, update it */&lt;/span&gt;
            metadata.requestUpdate();
            log.debug(&lt;span class=&quot;code-quote&quot;&gt;&quot;Error connecting to node {} at {}:{}:&quot;&lt;/span&gt;, node.id(), node.host(), node.port(), e);
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thanks for all your help !&lt;/p&gt;

&lt;p&gt;Thanks,&lt;/p&gt;

&lt;p&gt;Bhavesh  &lt;/p&gt;</comment>
                            <comment id="14260508" author="nehanarkhede" created="Mon, 29 Dec 2014 22:49:40 +0000"  >&lt;p&gt;Thanks for following through on this, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=ewencp&quot; class=&quot;user-hover&quot; rel=&quot;ewencp&quot;&gt;ewencp&lt;/a&gt;! &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=junrao&quot; class=&quot;user-hover&quot; rel=&quot;junrao&quot;&gt;junrao&lt;/a&gt;, since you probably have most context on this, would you mind reviewing the follow up patch (&lt;a href=&quot;https://reviews.apache.org/r/28582/diff/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://reviews.apache.org/r/28582/diff/&lt;/a&gt;) so we can close this out?&lt;/p&gt;</comment>
                            <comment id="14265602" author="ewencp" created="Tue, 6 Jan 2015 02:56:58 +0000"  >&lt;p&gt;Updated reviewboard &lt;a href=&quot;https://reviews.apache.org/r/28582/diff/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://reviews.apache.org/r/28582/diff/&lt;/a&gt;&lt;br/&gt;
 against branch origin/trunk&lt;/p&gt;</comment>
                            <comment id="14266560" author="junrao" created="Tue, 6 Jan 2015 18:57:19 +0000"  >&lt;p&gt;Thanks for the latest followup patch. +1 and committed to both 0.8.2 and trunk.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12683253" name="0001-Initial-CPU-Hish-Usage-by-Kafka-FIX-and-Also-fix-CLO.patch" size="20213" author="Bmis13" created="Mon, 24 Nov 2014 01:52:38 +0000"/>
                            <attachment id="12684506" name="KAFKA-1642.patch" size="5386" author="ewencp" created="Mon, 1 Dec 2014 23:49:45 +0000"/>
                            <attachment id="12675537" name="KAFKA-1642.patch" size="13570" author="ewencp" created="Fri, 17 Oct 2014 18:37:00 +0000"/>
                            <attachment id="12675989" name="KAFKA-1642_2014-10-20_17:33:57.patch" size="22683" author="ewencp" created="Tue, 21 Oct 2014 00:34:02 +0000"/>
                            <attachment id="12676774" name="KAFKA-1642_2014-10-23_16:19:41.patch" size="26108" author="ewencp" created="Thu, 23 Oct 2014 23:19:56 +0000"/>
                            <attachment id="12690231" name="KAFKA-1642_2015-01-05_18:56:55.patch" size="7773" author="ewencp" created="Tue, 6 Jan 2015 02:56:57 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>6.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            10 years, 45 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i208p3:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>junrao</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>