<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:07:11 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6534] Consumer.poll may not trigger rebalance in time when there is a task migration</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6534</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;When Streams detect a task migration event in one of its thread, today it will always let its trigger to call &lt;tt&gt;consumer.poll&lt;/tt&gt; hoping it could trigger the rebalance and hence clean up the records buffered from the partitions that on longer owned. However, because the rebalance is based on&#160;heartbeat responses which has a window of race, the rebalance is not always guaranteed to be triggered when task migration happens. As a result it could cause the records buffered in consumer to not be cleaned up and later be processed by Streams, realizing it no longer belongs to the thread, causing:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
java.lang.IllegalStateException: Record&apos;s partition does not belong to &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; partition-group.
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note this issue is only relevant when EOS is turned on, and based the default heartbeat.interval.ms value (3 sec), the race likelihood should not be high.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13136364">KAFKA-6534</key>
            <summary>Consumer.poll may not trigger rebalance in time when there is a task migration</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="guozhang">Guozhang Wang</assignee>
                                    <reporter username="guozhang">Guozhang Wang</reporter>
                        <labels>
                    </labels>
                <created>Mon, 5 Feb 2018 19:51:02 +0000</created>
                <updated>Wed, 25 Apr 2018 09:41:33 +0000</updated>
                            <resolved>Tue, 27 Feb 2018 08:34:48 +0000</resolved>
                                                    <fixVersion>2.0.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16375184" author="guozhang" created="Sat, 24 Feb 2018 01:11:41 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/kafka/pull/4544&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4544&lt;/a&gt; ready for review.&lt;/p&gt;</comment>
                            <comment id="16378231" author="githubbot" created="Tue, 27 Feb 2018 08:29:28 +0000"  >&lt;p&gt;guozhangwang closed pull request #4544: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6534&quot; title=&quot;Consumer.poll may not trigger rebalance in time when there is a task migration&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6534&quot;&gt;&lt;del&gt;KAFKA-6534&lt;/del&gt;&lt;/a&gt;: Enforce a rebalance in the next poll call when encounter task migration&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4544&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4544&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java&lt;br/&gt;
index 6884ff0dff7..b39f52c0552 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java&lt;br/&gt;
@@ -767,20 +767,20 @@ public void handle(HeartbeatResponse heartbeatResponse, RequestFuture&amp;lt;Void&amp;gt; futu&lt;br/&gt;
                 future.complete(null);&lt;br/&gt;
             } else if (error == Errors.COORDINATOR_NOT_AVAILABLE&lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; error == Errors.NOT_COORDINATOR) {
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;log.debug(&quot;Attempt to heartbeat since coordinator {} is either not started or not valid.&quot;,&lt;br/&gt;
+                log.info(&quot;Attempt to heartbeat failed since coordinator {} is either not started or not valid.&quot;,&lt;br/&gt;
                         coordinator());&lt;br/&gt;
                 coordinatorDead();&lt;br/&gt;
                 future.raise(error);&lt;br/&gt;
             } else if (error == Errors.REBALANCE_IN_PROGRESS) 
{
-                log.debug(&quot;Attempt to heartbeat failed since group is rebalancing&quot;);
+                log.info(&quot;Attempt to heartbeat failed since group is rebalancing&quot;);
                 requestRejoin();
                 future.raise(Errors.REBALANCE_IN_PROGRESS);
             }
&lt;p&gt; else if (error == Errors.ILLEGAL_GENERATION) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Attempt to heartbeat failed since generation {} is not current&quot;, generation.generationId);&lt;br/&gt;
+                log.info(&quot;Attempt to heartbeat failed since generation {} is not current&quot;, generation.generationId);&lt;br/&gt;
                 resetGeneration();&lt;br/&gt;
                 future.raise(Errors.ILLEGAL_GENERATION);&lt;br/&gt;
             } else if (error == Errors.UNKNOWN_MEMBER_ID) {&lt;/li&gt;
	&lt;li&gt;log.debug(&quot;Attempt to heartbeat failed for since member id {} is not valid.&quot;, generation.memberId);&lt;br/&gt;
+                log.info(&quot;Attempt to heartbeat failed for since member id {} is not valid.&quot;, generation.memberId);&lt;br/&gt;
                 resetGeneration();&lt;br/&gt;
                 future.raise(Errors.UNKNOWN_MEMBER_ID);&lt;br/&gt;
             } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) 
{
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java
index d9c827fff52..a8f7e652da9 100644
--- a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java
@@ -52,6 +52,7 @@
     final Logger log;
     final LogContext logContext;
     boolean taskInitialized;
+    boolean taskClosed;
     final StateDirectory stateDirectory;
 
     InternalProcessorContext processorContext;
@@ -256,6 +257,9 @@ void closeStateManager(final boolean writeCheckpoint) throws ProcessorStateExcep
         }
&lt;p&gt;     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;+    public boolean isClosed() &lt;/p&gt;
{
+        return taskClosed;
+    }

&lt;p&gt;     public boolean hasStateStores() {&lt;br/&gt;
         return !topology.stateStores().isEmpty();&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedStreamsTasks.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedStreamsTasks.java&lt;br/&gt;
index 7b05f6488e7..f98e6356a22 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedStreamsTasks.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedStreamsTasks.java&lt;br/&gt;
@@ -95,6 +95,8 @@ int process() &lt;/p&gt;
{
                     processed++;
                 }
&lt;p&gt;             } catch (final TaskMigratedException e) {&lt;br/&gt;
+                log.info(&quot;Failed to process stream task {} since it got migrated to another thread already. &quot; +&lt;br/&gt;
+                        &quot;Closing it as zombie before triggering a new rebalance.&quot;, task.id());&lt;br/&gt;
                 final RuntimeException fatalException = closeZombieTask(task);&lt;br/&gt;
                 if (fatalException != null) {&lt;br/&gt;
                     throw fatalException;&lt;br/&gt;
@@ -125,6 +127,8 @@ int punctuate() &lt;/p&gt;
{
                     punctuated++;
                 }
&lt;p&gt;             } catch (final TaskMigratedException e) {&lt;br/&gt;
+                log.info(&quot;Failed to punctuate stream task {} since it got migrated to another thread already. &quot; +&lt;br/&gt;
+                        &quot;Closing it as zombie before triggering a new rebalance.&quot;, task.id());&lt;br/&gt;
                 final RuntimeException fatalException = closeZombieTask(task);&lt;br/&gt;
                 if (fatalException != null) {&lt;br/&gt;
                     throw fatalException;&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedTasks.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedTasks.java&lt;br/&gt;
index 2cd82f461dd..8529c9eca88 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedTasks.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/AssignedTasks.java&lt;br/&gt;
@@ -200,6 +200,8 @@ private RuntimeException suspendTasks(final Collection&amp;lt;T&amp;gt; tasks) &lt;/p&gt;
{
                 suspended.put(task.id(), task);
             }
&lt;p&gt; catch (final TaskMigratedException closeAsZombieAndSwallow) {&lt;br/&gt;
                 // as we suspend a task, we are either shutting down or rebalancing, thus, we swallow and move on&lt;br/&gt;
+                log.info(&quot;Failed to suspend {} {} since it got migrated to another thread already. &quot; +&lt;br/&gt;
+                        &quot;Closing it as zombie and move on.&quot;, taskTypeName, task.id());&lt;br/&gt;
                 firstException.compareAndSet(null, closeZombieTask(task));&lt;br/&gt;
                 it.remove();&lt;br/&gt;
             } catch (final RuntimeException e) {&lt;br/&gt;
@@ -216,7 +218,6 @@ private RuntimeException suspendTasks(final Collection&amp;lt;T&amp;gt; tasks) {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     RuntimeException closeZombieTask(final T task) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;log.warn(&quot;{} {} got migrated to another thread already. Closing it as zombie.&quot;, taskTypeName, task.id());&lt;br/&gt;
         try 
{
             task.close(false, true);
         }
&lt;p&gt; catch (final RuntimeException e) {&lt;br/&gt;
@@ -242,11 +243,12 @@ boolean maybeResumeSuspendedTask(final TaskId taskId, final Set&amp;lt;TopicPartition&amp;gt;&lt;br/&gt;
                 try &lt;/p&gt;
{
                     task.resume();
                 }
&lt;p&gt; catch (final TaskMigratedException e) {&lt;br/&gt;
+                    log.info(&quot;Failed to resume {} {} since it got migrated to another thread already. &quot; +&lt;br/&gt;
+                            &quot;Closing it as zombie before triggering a new rebalance.&quot;, taskTypeName, task.id());&lt;br/&gt;
                     final RuntimeException fatalException = closeZombieTask(task);&lt;br/&gt;
                     if (fatalException != null) &lt;/p&gt;
{
                         throw fatalException;
                     }&lt;/li&gt;
	&lt;li&gt;suspended.remove(taskId);&lt;br/&gt;
                     throw e;&lt;br/&gt;
                 }&lt;br/&gt;
                 transitionToRunning(task, new HashSet&amp;lt;TopicPartition&amp;gt;());&lt;br/&gt;
@@ -368,14 +370,14 @@ void applyToRunningTasks(final TaskAction&amp;lt;T&amp;gt; action) {&lt;br/&gt;
             try 
{
                 action.apply(task);
             }
&lt;p&gt; catch (final TaskMigratedException e) {&lt;br/&gt;
+                log.info(&quot;Failed to commit {} {} since it got migrated to another thread already. &quot; +&lt;br/&gt;
+                        &quot;Closing it as zombie before triggering a new rebalance.&quot;, taskTypeName, task.id());&lt;br/&gt;
                 final RuntimeException fatalException = closeZombieTask(task);&lt;br/&gt;
                 if (fatalException != null) &lt;/p&gt;
{
                     throw fatalException;
                 }
&lt;p&gt;                 it.remove();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;if (firstException == null) 
{
-                    firstException = e;
-                }
&lt;p&gt;+                throw e;&lt;br/&gt;
             } catch (final RuntimeException t) {&lt;br/&gt;
                 log.error(&quot;Failed to {} {} {} due to the following error:&quot;,&lt;br/&gt;
                           action.name(),&lt;br/&gt;
@@ -416,6 +418,8 @@ void close(final boolean clean) {&lt;br/&gt;
             try &lt;/p&gt;
{
                 task.close(clean, false);
             }
&lt;p&gt; catch (final TaskMigratedException e) {&lt;br/&gt;
+                log.info(&quot;Failed to close {} {} since it got migrated to another thread already. &quot; +&lt;br/&gt;
+                        &quot;Closing it as zombie and move on.&quot;, taskTypeName, task.id());&lt;br/&gt;
                 firstException.compareAndSet(null, closeZombieTask(task));&lt;br/&gt;
             } catch (final RuntimeException t) {&lt;br/&gt;
                 log.error(&quot;Failed while closing {} {} due to the following error:&quot;,&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java&lt;br/&gt;
index 39d34d799d2..861556cded3 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java&lt;br/&gt;
@@ -144,6 +144,8 @@ public void close(final boolean clean,&lt;br/&gt;
         } finally 
{
             closeStateManager(committedSuccessfully);
         }
&lt;p&gt;+&lt;br/&gt;
+        taskClosed = true;&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java&lt;br/&gt;
index 6bca02ad9bc..b8777ad5521 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java&lt;br/&gt;
@@ -541,6 +541,8 @@ public void close(boolean clean,&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;         closeSuspended(clean, isZombie, firstException);&lt;br/&gt;
+&lt;br/&gt;
+        taskClosed = true;&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     /**&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
index 61a22be5a15..cda04e9efc0 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java&lt;br/&gt;
@@ -757,7 +757,12 @@ private void runLoop() {&lt;br/&gt;
             } catch (final TaskMigratedException ignoreAndRejoinGroup) {&lt;br/&gt;
                 log.warn(&quot;Detected task {} that got migrated to another thread. &quot; +&lt;br/&gt;
                     &quot;This implies that this thread missed a rebalance and dropped out of the consumer group. &quot; +&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&quot;Trying to rejoin the consumer group now. Below is the detailed description of the task:\n{}&quot;, ignoreAndRejoinGroup.migratedTask().id(), ignoreAndRejoinGroup.migratedTask().toString(&quot;&amp;gt;&quot;));&lt;br/&gt;
+                    &quot;Will try to rejoin the consumer group. Below is the detailed description of the task:\n{}&quot;,&lt;br/&gt;
+                        ignoreAndRejoinGroup.migratedTask().id(), ignoreAndRejoinGroup.migratedTask().toString(&quot;&amp;gt;&quot;));&lt;br/&gt;
+&lt;br/&gt;
+                // re-subscribe to enforce a rebalance in the next poll call&lt;br/&gt;
+                consumer.unsubscribe();&lt;br/&gt;
+                consumer.subscribe(builder.sourceTopicPattern(), rebalanceListener);&lt;br/&gt;
             }&lt;br/&gt;
         }&lt;br/&gt;
     }&lt;br/&gt;
@@ -898,6 +903,13 @@ private void addRecordsToTasks(final ConsumerRecords&amp;lt;byte[], byte[]&amp;gt; records) {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         for (final TopicPartition partition : records.partitions()) {&lt;br/&gt;
             final StreamTask task = taskManager.activeTask(partition);&lt;br/&gt;
+&lt;br/&gt;
+            if (task.isClosed()) {&lt;br/&gt;
+                log.warn(&quot;Stream task {} is already closed, probably because it got unexpectly migrated to another thread already. &quot; +&lt;br/&gt;
+                        &quot;Notifying the thread to trigger a new rebalance immediately.&quot;, task.id());&lt;br/&gt;
+                throw new TaskMigratedException(task);&lt;br/&gt;
+            }&lt;br/&gt;
+&lt;br/&gt;
             numAddedRecords += task.addRecords(partition, records.records(partition));&lt;br/&gt;
         }&lt;br/&gt;
         streamsMetrics.skippedRecordsSensor.record(records.count() - numAddedRecords, timerStartedMs);&lt;br/&gt;
@@ -1024,6 +1036,13 @@ private void maybeUpdateStandbyTasks(final long now) {&lt;br/&gt;
                         List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; remaining = entry.getValue();&lt;br/&gt;
                         if (remaining != null) {&lt;br/&gt;
                             final StandbyTask task = taskManager.standbyTask(partition);&lt;br/&gt;
+&lt;br/&gt;
+                            if (task.isClosed()) {&lt;br/&gt;
+                                log.warn(&quot;Standby task {} is already closed, probably because it got unexpectly migrated to another thread already. &quot; +&lt;br/&gt;
+                                        &quot;Notifying the thread to trigger a new rebalance immediately.&quot;, task.id());&lt;br/&gt;
+                                throw new TaskMigratedException(task);&lt;br/&gt;
+                            }&lt;br/&gt;
+&lt;br/&gt;
                             remaining = task.update(partition, remaining);&lt;br/&gt;
                             if (remaining != null) {&lt;br/&gt;
                                 remainingStandbyRecords.put(partition, remaining);&lt;br/&gt;
@@ -1051,6 +1070,12 @@ private void maybeUpdateStandbyTasks(final long now) &lt;/p&gt;
{
                             throw new StreamsException(logPrefix + &quot;Missing standby task for partition &quot; + partition);
                         }

&lt;p&gt;+                        if (task.isClosed()) {&lt;br/&gt;
+                            log.warn(&quot;Standby task {} is already closed, probably because it got unexpectly migrated to another thread already. &quot; +&lt;br/&gt;
+                                    &quot;Notifying the thread to trigger a new rebalance immediately.&quot;, task.id());&lt;br/&gt;
+                            throw new TaskMigratedException(task);&lt;br/&gt;
+                        }&lt;br/&gt;
+&lt;br/&gt;
                         final List&amp;lt;ConsumerRecord&amp;lt;byte[], byte[]&amp;gt;&amp;gt; remaining = task.update(partition, records.records(partition));&lt;br/&gt;
                         if (remaining != null) {&lt;br/&gt;
                             restoreConsumer.pause(singleton(partition));&lt;br/&gt;
@@ -1063,6 +1088,13 @@ private void maybeUpdateStandbyTasks(final long now) {&lt;br/&gt;
                 final Set&amp;lt;TopicPartition&amp;gt; partitions = recoverableException.partitions();&lt;br/&gt;
                 for (final TopicPartition partition : partitions) {&lt;br/&gt;
                     final StandbyTask task = taskManager.standbyTask(partition);&lt;br/&gt;
+&lt;br/&gt;
+                    if (task.isClosed()) {&lt;br/&gt;
+                        log.warn(&quot;Standby task {} is already closed, probably because it got unexpectly migrated to another thread already. &quot; +&lt;br/&gt;
+                                &quot;Notifying the thread to trigger a new rebalance immediately.&quot;, task.id());&lt;br/&gt;
+                        throw new TaskMigratedException(task);&lt;br/&gt;
+                    }&lt;br/&gt;
+&lt;br/&gt;
                     log.info(&quot;Reinitializing StandbyTask {}&quot;, task);&lt;br/&gt;
                     task.reinitializeStateStoresForPartitions(recoverableException.partitions());&lt;br/&gt;
                 }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
index 62ddacfb33c..9f02834dd75 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java&lt;br/&gt;
@@ -300,7 +300,6 @@ StreamTask activeTask(final TopicPartition partition) &lt;/p&gt;
{
         return active.runningTaskFor(partition);
     }

&lt;p&gt;-&lt;br/&gt;
     StandbyTask standbyTask(final TopicPartition partition) &lt;/p&gt;
{
         return standby.runningTaskFor(partition);
     }
&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java b/streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java&lt;br/&gt;
index 6c7b2b43c9d..c4ea9647a8d 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/integration/EosIntegrationTest.java&lt;br/&gt;
@@ -61,6 +61,7 @@&lt;/p&gt;

&lt;p&gt; import static org.hamcrest.CoreMatchers.equalTo;&lt;br/&gt;
 import static org.hamcrest.MatcherAssert.assertThat;&lt;br/&gt;
+import static org.junit.Assert.assertNotNull;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;br/&gt;
 import static org.junit.Assert.fail;&lt;/p&gt;

&lt;p&gt;@@ -78,18 +79,18 @@&lt;br/&gt;
     });&lt;/p&gt;

&lt;p&gt;     private static String applicationId;&lt;br/&gt;
+    private final static int NUM_TOPIC_PARTITIONS = 2;&lt;br/&gt;
     private final static String CONSUMER_GROUP_ID = &quot;readCommitted&quot;;&lt;br/&gt;
     private final static String SINGLE_PARTITION_INPUT_TOPIC = &quot;singlePartitionInputTopic&quot;;&lt;br/&gt;
     private final static String SINGLE_PARTITION_THROUGH_TOPIC = &quot;singlePartitionThroughTopic&quot;;&lt;br/&gt;
     private final static String SINGLE_PARTITION_OUTPUT_TOPIC = &quot;singlePartitionOutputTopic&quot;;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final static int NUM_TOPIC_PARTITIONS = 2;&lt;br/&gt;
     private final static String MULTI_PARTITION_INPUT_TOPIC = &quot;multiPartitionInputTopic&quot;;&lt;br/&gt;
     private final static String MULTI_PARTITION_THROUGH_TOPIC = &quot;multiPartitionThroughTopic&quot;;&lt;br/&gt;
     private final static String MULTI_PARTITION_OUTPUT_TOPIC = &quot;multiPartitionOutputTopic&quot;;&lt;br/&gt;
     private final String storeName = &quot;store&quot;;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private AtomicBoolean errorInjected;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private AtomicBoolean injectGC;&lt;br/&gt;
+    private AtomicBoolean gcInjected;&lt;br/&gt;
     private volatile boolean doGC = true;&lt;br/&gt;
     private AtomicInteger commitRequested;&lt;br/&gt;
     private Throwable uncaughtException;&lt;br/&gt;
@@ -153,7 +154,6 @@ private void runSimpleCopyTest(final int numberOfRestarts,&lt;br/&gt;
         output.to(outputTopic);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         for (int i = 0; i &amp;lt; numberOfRestarts; ++i) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final long factor = i;&lt;br/&gt;
             final KafkaStreams streams = new KafkaStreams(&lt;br/&gt;
                 builder.build(),&lt;br/&gt;
                 StreamsTestUtils.getStreamsConfig(&lt;br/&gt;
@@ -171,7 +171,7 @@ private void runSimpleCopyTest(final int numberOfRestarts,&lt;br/&gt;
             try {&lt;br/&gt;
                 streams.start();&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final List&amp;lt;KeyValue&amp;lt;Long, Long&amp;gt;&amp;gt; inputData = prepareData(factor * 100, factor * 100 + 10L, 0L, 1L);&lt;br/&gt;
+                final List&amp;lt;KeyValue&amp;lt;Long, Long&amp;gt;&amp;gt; inputData = prepareData(i * 100, i * 100 + 10L, 0L, 1L);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;                 IntegrationTestUtils.produceKeyValuesSynchronously(&lt;br/&gt;
                     inputTopic,&lt;br/&gt;
@@ -510,7 +510,7 @@ public boolean conditionMet() {&lt;br/&gt;
             checkResultPerKey(committedRecords, committedDataBeforeGC);&lt;br/&gt;
             checkResultPerKey(uncommittedRecords, dataBeforeGC);&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;injectGC.set(true);&lt;br/&gt;
+            gcInjected.set(true);&lt;br/&gt;
             writeInputData(dataToTriggerFirstRebalance);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             TestUtils.waitForCondition(new TestCondition() {&lt;br/&gt;
@@ -577,7 +577,7 @@ public boolean conditionMet() {&lt;br/&gt;
     private KafkaStreams getKafkaStreams(final boolean withState, final String appDir, final int numberOfStreamsThreads) {&lt;br/&gt;
         commitRequested = new AtomicInteger(0);&lt;br/&gt;
         errorInjected = new AtomicBoolean(false);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;injectGC = new AtomicBoolean(false);&lt;br/&gt;
+        gcInjected = new AtomicBoolean(false);&lt;br/&gt;
         final StreamsBuilder builder = new StreamsBuilder();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         String[] storeNames = null;&lt;br/&gt;
@@ -614,7 +614,7 @@ public void init(final ProcessorContext context) &lt;/p&gt;
{
                             // only tries to fail once on one of the task
                             throw new RuntimeException(&quot;Injected test exception.&quot;);
                         }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (injectGC.compareAndSet(true, false)) {&lt;br/&gt;
+                        if (gcInjected.compareAndSet(true, false)) {&lt;br/&gt;
                             while (doGC) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {                                 try {
                                     Thread.sleep(100);
@@ -779,6 +779,8 @@ private void verifyStateStore(final KafkaStreams streams, final Set&amp;lt;KeyValue&amp;lt;Lon
             }         }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+        assertNotNull(store);&lt;br/&gt;
+&lt;br/&gt;
         final KeyValueIterator&amp;lt;Long, Long&amp;gt; it = store.all();&lt;br/&gt;
         while (it.hasNext()) {&lt;br/&gt;
             assertTrue(expectedStoreContent.remove(it.next()));&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 38 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3ptcf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>