<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:39:22 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-15302] Stale value returned when using store.all() with key deletion in punctuation function.</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-15302</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;When using the store.all() function within the Punctuation function of this.context.schedule, the previous value is returned. In other words, even though the value has been stored from 1 to 2, it doesn&apos;t return 2; instead, it returns 1.&lt;/p&gt;

&lt;p&gt;In the provided test code, you can see the output &apos;BROKEN !!!&apos;, and while this doesn&apos;t occur 100% of the time, by adding logs, it&apos;s evident that during the while loop after all() is called, the cache is flushed. As a result, the named cache holds a null value, causing the return of a value from RocksDB. This is observed as the value after the .get() call is different from the expected value. This is possibly due to the consistent read functionality of RocksDB, although the exact cause is not certain.&lt;/p&gt;

&lt;p&gt;Of course, if you perform &lt;tt&gt;store.flush()&lt;/tt&gt; before &lt;tt&gt;all()&lt;/tt&gt; there won&apos;t be any errors.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;test code (forked from balajirrao and modified for this)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/jinyongchoi/kafka-streams-multi-runner/tree/main&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jinyongchoi/kafka-streams-multi-runner/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void forwardAll(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; timestamp) {
    &lt;span class=&quot;code-comment&quot;&gt;//
&lt;/span&gt;&#160; &#160; &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;forwardAll Start&quot;&lt;/span&gt;);&#160; &#160; KeyValueIterator&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; kvList = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvStore.all();
&#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (kvList.hasNext()) {
&#160; &#160; &#160; &#160; KeyValue&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; entry = kvList.next();
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Record&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; msg = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Record&amp;lt;&amp;gt;(entry.key, entry.value, context.currentSystemTimeMs());
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; storeValue = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvStore.get(entry.key);&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (entry.value != storeValue) {
&#160; &#160; &#160; &#160; &#160; &#160; &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;[&quot;&lt;/span&gt; + instanceId + &lt;span class=&quot;code-quote&quot;&gt;&quot;]&quot;&lt;/span&gt; + &lt;span class=&quot;code-quote&quot;&gt;&quot;!!! BROKEN !!! Key: &quot;&lt;/span&gt; + entry.key + &lt;span class=&quot;code-quote&quot;&gt;&quot; Expected in stored(Cache or Store) value: &quot;&lt;/span&gt; + storeValue + &lt;span class=&quot;code-quote&quot;&gt;&quot; but KeyValueIterator value: &quot;&lt;/span&gt; + entry.value);
&#160; &#160; &#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Broken!&quot;&lt;/span&gt;);
&#160; &#160; &#160; &#160; }&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.context.forward(msg);
&#160; &#160; }
&#160; &#160; kvList.close();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
	&lt;li&gt;log file (add log in stream source)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
# console log
sbt clean &lt;span class=&quot;code-quote&quot;&gt;&quot;worker/assembly&quot;&lt;/span&gt;; sbt &lt;span class=&quot;code-quote&quot;&gt;&quot;worker/assembly&quot;&lt;/span&gt;; sbt &lt;span class=&quot;code-quote&quot;&gt;&quot;coordinator / run 1&quot;&lt;/span&gt;
[info] welcome to sbt 1.8.2 (Ubuntu Java 11.0.20)
...
[info] running Coordinator 1
appid: 95108c48-7c69-4eeb-adbd-9d091bd84933
[0] starting instance +1
forwardAll Start
[0]!!! BROKEN !!! Key: 636398 Expected in stored(Cache or Store) value: 2 but KeyValueIterator value: 1


# log file
...
01:05:00.382 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.NamedCache -- Named cache 0_0-Counts stats on flush: #hits=5628524, #misses=5636397, #overwrites=636397, #flushes=401
01:05:00.388 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.NamedCache -- Named Cache flush dirtyKeys.size():7873 entries:7873
01:05:00.434 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.p.i.ProcessorStateManager -- stream-thread [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] stream-task [0_0] Flushed cache or buffer Counts
...
01:05:00.587 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.s.i.CachingKeyValueStore -- &#160;KeyValueIterator&amp;lt;Bytes, &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[]&amp;gt; all()
01:05:00.588 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.RocksDBStore -- &#160;RocksDB KeyValueIterator all
01:05:00.590 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.ThreadCache -- stream-thread [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] &#160;MemoryLRUCacheBytesIterator cache all()
01:05:00.591 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.NamedCache -- &#160; NamedCache allKeys() size():325771
01:05:00.637 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.NamedCache -- &#160; NamedCache keySetIterator() TreeSet size():325771
...
01:05:07.052 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.NamedCache -- 0_0-Counts evict() isDirty() eldest.size():103
01:05:07.052 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.NamedCache -- Named cache 0_0-Counts stats on flush: #hits=5636398, #misses=6233857, #overwrites=639857, #flushes=402
01:05:07.053 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] INFO  o.a.k.s.state.internals.NamedCache -- Named Cache flush dirtyKeys.size():3459 entries:3460 &amp;lt;= NamedCache.flush()

...

ThreadCache set nextEntry is &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; key:636398  &amp;lt;= MemoryLRUCacheBytesIterator.internalNext()

...

01:06:31.382 [95108c48-7c69-4eeb-adbd-9d091bd84933-67de276e-fce4-4621-99c1-aea7849262d2-StreamThread-1] WARN &#160;o.a.k.s.s.i.AbstractMergedSortedCacheStoreIterator -- -AbstractMergedSortedCacheStoreIterator- -&amp;gt; store nextCacheKey: [&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;], nextStoreKey: [636398] nextStoreValue: [1]
[0]!!! BROKEN !!! Key: 636398 Expected in stored(Cache or Store) value: 2 but KeyValueIterator value: 1 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13546030">KAFKA-15302</key>
            <summary>Stale value returned when using store.all() with key deletion in punctuation function.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="jinyong.choi">Jinyong Choi</reporter>
                        <labels>
                    </labels>
                <created>Thu, 3 Aug 2023 16:34:23 +0000</created>
                <updated>Fri, 21 Jun 2024 14:23:41 +0000</updated>
                                            <version>3.5.1</version>
                                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="17751236" author="mjsax" created="Fri, 4 Aug 2023 23:35:50 +0000"  >&lt;p&gt;Thanks for reporting this issue. &#8211; When you call `store.all()` you get a iterator back that is build over the cache as well as RocksDB. For the underlying RocksDB iterator, it provides an immutable snapshot, thus any later writes into RocksDB are not visible to the iterator. Thus, if the cache is flushed, and we try to read the key from the cache and cannot find it, we go to the underlying RocksDB iterator which cannot see the write. This should explain it.&lt;/p&gt;

&lt;p&gt;What I am wondering though right now is, why the cache would get flushed to begin with? &#8211; There should not be an explicit `store.flush()` call because we only flush before a `commit()` what happens on the same thread; we might also `evict()` during a `put()` if the cache overflows, but there is no `put()` call in between; the third case I could find is, when a new `StreamThread` is added and we need to resize the cache (this would indeed be an concurrent operation; could adding/removing a thread explain what you observe?&lt;/p&gt;

&lt;p&gt;Otherwise we would need to do more digging while the cache is flushed begin with? If we flush incorrectly and can avoid the flush we should be able to fix it. If we flush correctly, we might need to have a guard inside the caching layer itself and suppress the flush if there is an open iterator (what does actually not sound like a great solution, but maybe it would be the correct way forward.)&lt;/p&gt;</comment>
                            <comment id="17751323" author="JIRAUSER301376" created="Sat, 5 Aug 2023 16:30:33 +0000"  >&lt;p&gt;Hi Matthias J. Sax,&lt;/p&gt;

&lt;p&gt;Reading your comment helped me to be more specific about this bug.&lt;/p&gt;

&lt;p&gt;For instance, when using this.context.forward(msg) to forward a message, to optimize storage efficiency,&lt;br/&gt;
the key of the forwarded message can also be deleted from the store.&lt;br/&gt;
So, If we call store.delete(key);, the delete() function of CachingKeyValueStore could invoke the getInternal() and putInternal() functions, and following these function calls could lead to the execution of maybeEvict().&lt;/p&gt;

&lt;p&gt;Deleting by entering a null value is actually a valid approach to removing items from RocksDB.&lt;br/&gt;
Therefore, the observed behavior is normal.&lt;/p&gt;

&lt;p&gt;So, I&apos;m currently writing code to suppress the MaybeEvict() operation.&lt;br/&gt;
When the test is complete, i will share the results.&lt;/p&gt;

&lt;p&gt;Let me know if you have any additional comments!&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
# CachingKeyValueStore
@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] delete(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bytes key) {
&#160; &#160; Objects.requireNonNull(key, &lt;span class=&quot;code-quote&quot;&gt;&quot;key cannot be &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;&quot;&lt;/span&gt;);
&#160; &#160; validateStoreOpen();
&#160; &#160; lock.writeLock().lock();
&#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
&#160; &#160; &#160; &#160; validateStoreOpen();
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; deleteInternal(key);
&#160; &#160; } &lt;span class=&quot;code-keyword&quot;&gt;finally&lt;/span&gt; {
&#160; &#160; &#160; &#160; lock.writeLock().unlock();
&#160; &#160; }
}

&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] deleteInternal(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bytes key) {
&#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] v = getInternal(key);
&#160; &#160; putInternal(key, &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
&#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; v;
}

&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void putInternal(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bytes key,
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] value) {
&#160; &#160; context.cache().put(
&#160; &#160; &#160; &#160; cacheName,
&#160; &#160; &#160; &#160; key,
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LRUCacheEntry(
&#160; &#160; &#160; &#160; &#160; &#160; value,
&#160; &#160; &#160; &#160; &#160; &#160; context.headers(),
&#160; &#160; &#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,
&#160; &#160; &#160; &#160; &#160; &#160; context.offset(),
&#160; &#160; &#160; &#160; &#160; &#160; context.timestamp(),
&#160; &#160; &#160; &#160; &#160; &#160; context.partition(),
&#160; &#160; &#160; &#160; &#160; &#160; context.topic()));&#160; &#160; 
    StoreQueryUtils.updatePosition(position, context);
}

# NamedCache
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void put(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; namespace, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bytes key, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; LRUCacheEntry value, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; needToEvict) {
&#160; &#160; numPuts++;&#160; &#160; 
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; NamedCache cache = getOrCreateCache(namespace);&#160; &#160; 
    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (cache) {
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; oldSize = cache.sizeInBytes();
&#160; &#160; &#160; &#160; cache.put(key, value);
&#160; &#160; &#160; &#160; sizeInBytes.getAndAdd(cache.sizeInBytes() - oldSize);
&#160; &#160; &#160; &#160; maybeEvict(namespace, cache);
&#160; &#160; }
} &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17751403" author="guozhang" created="Sun, 6 Aug 2023 17:29:14 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=jinyong.choi&quot; class=&quot;user-hover&quot; rel=&quot;jinyong.choi&quot;&gt;jinyong.choi&lt;/a&gt; to help us better understand your issue, could you share the whole testing code here? More specifically, I&apos;m wondering if you have a concurrent thread calling `store.delete` or `store.put(k, null)` (hence causing a flush) at the same time while you are looping via `store.all()`?&lt;/p&gt;</comment>
                            <comment id="17751422" author="JIRAUSER301376" created="Mon, 7 Aug 2023 01:21:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; Hi.&lt;/p&gt;

&lt;p&gt;Sure. It is my test code.&lt;/p&gt;

&lt;p&gt;As you mentioned, &lt;tt&gt;this.kvStore.delete(entry.key);&lt;/tt&gt; is called within the context of put() and evict() being invoked.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jinyongchoi/kafka-streams-multi-runner/blob/main/worker/src/main/java/Worker.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jinyongchoi/kafka-streams-multi-runner/blob/main/worker/src/main/java/Worker.java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;WordCountProcessor &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Processor&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; {
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; KeyValueStore&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; kvStore;
    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; ProcessorContext&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; context;
    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; instanceId = &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.getenv(&lt;span class=&quot;code-quote&quot;&gt;&quot;INSTANCE_ID&quot;&lt;/span&gt;);

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void init(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ProcessorContext&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; context) {
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.context = context;
        kvStore = context.getStateStore(&lt;span class=&quot;code-quote&quot;&gt;&quot;Counts&quot;&lt;/span&gt;);
        &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.context.schedule(
                Duration.ofSeconds(60),
                PunctuationType.WALL_CLOCK_TIME, &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;::forwardAll);
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void process(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Record&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; record) {
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; recordValue = record.value();
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; oldInt = kvStore.get(record.key());
        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; old = Objects.requireNonNullElse(oldInt, recordValue - 1);
        kvStore.put(record.key(), old + 1);
    }

    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void forwardAll(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; timestamp) {
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;forwardAll Start&quot;&lt;/span&gt;);
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;forwardAll Start&quot;&lt;/span&gt;);

        KeyValueIterator&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; kvList = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvStore.all();
        &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (kvList.hasNext()) {
            KeyValue&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; entry = kvList.next();
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Record&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; msg = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Record&amp;lt;&amp;gt;(entry.key, entry.value, context.currentSystemTimeMs());
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; storeValue = &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvStore.get(entry.key);

            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (entry.value != storeValue) {
                &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;[&quot;&lt;/span&gt; + instanceId + &lt;span class=&quot;code-quote&quot;&gt;&quot;]&quot;&lt;/span&gt; + &lt;span class=&quot;code-quote&quot;&gt;&quot;!!! BROKEN !!! Key: &quot;&lt;/span&gt; + entry.key + &lt;span class=&quot;code-quote&quot;&gt;&quot; Expected in stored(Cache or Store) value: &quot;&lt;/span&gt; + storeValue + &lt;span class=&quot;code-quote&quot;&gt;&quot; but KeyValueIterator value: &quot;&lt;/span&gt; + entry.value);
                &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;[&quot;&lt;/span&gt; + instanceId + &lt;span class=&quot;code-quote&quot;&gt;&quot;]&quot;&lt;/span&gt; + &lt;span class=&quot;code-quote&quot;&gt;&quot;!!! BROKEN !!! Key: &quot;&lt;/span&gt; + entry.key + &lt;span class=&quot;code-quote&quot;&gt;&quot; Expected in stored(Cache or Store) value: &quot;&lt;/span&gt; + storeValue + &lt;span class=&quot;code-quote&quot;&gt;&quot; but KeyValueIterator value: &quot;&lt;/span&gt; + entry.value);
                &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-quote&quot;&gt;&quot;Broken!&quot;&lt;/span&gt;);
            }

            &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.context.forward(msg);

            &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;delete key start: &quot;&lt;/span&gt; + entry.key);
            &lt;span class=&quot;code-comment&quot;&gt;// delete() method call the maybeEvict() function.
&lt;/span&gt;            &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.kvStore.delete(entry.key);
            &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;delete key end : &quot;&lt;/span&gt; + entry.key);
        }
        kvList.close();
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.err.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;forwardAll end&quot;&lt;/span&gt;);
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;forwardAll end&quot;&lt;/span&gt;);
    }

    @Override
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void close() {
        &lt;span class=&quot;code-comment&quot;&gt;// close any resources managed by &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; processor
&lt;/span&gt;        &lt;span class=&quot;code-comment&quot;&gt;// Note: Do not close any StateStores as these are managed by the library
&lt;/span&gt;    }
}

 &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17751761" author="mjsax" created="Mon, 7 Aug 2023 17:36:15 +0000"  >&lt;p&gt;Thanks for providing more details; the `delete()` call that interleaved with calls to the all-iterator should be the root cause; the delete call was missing in the original description. So we now know where the flush/evict is coming from. Thanks for confirming!&lt;/p&gt;

&lt;p&gt;Still not sure how to fix it though right now. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt; any ideas?&lt;/p&gt;</comment>
                            <comment id="17751830" author="guozhang" created="Mon, 7 Aug 2023 23:43:22 +0000"  >&lt;p&gt;I think case I&apos;m not sure if this is defined as a bug that should be fixed in KS: the semantics of `store.all()` is to return a snapshot (behind the scene, it&apos;s a combo of a cache snapshot and the underlying RocksDB&apos;s snapshot) at the time of the call, and if the store gets modified after the `all()` call, we do not guarantee the entries from the `all()` iterator would return consistent results as the `get()` which is meant to return the latest value.&lt;/p&gt;

&lt;p&gt;What&apos;s confusing though is that the users may not think that modifying the store for `keyA` might change the content of `KeyB` compared with the snapshot &amp;#8212; as what&apos;s happened here due to evictions &amp;#8212; but I think unless we change how we execute the caching layer&apos;s put/delete calls and how they can trigger eviction (of other keys), this would always be the case. For now the only thing we can do probably is to clarify it in the docs.&lt;/p&gt;

&lt;p&gt;In the long run, if we feel such a confusion is really un-intuitive, we could consider 1) decouple flushing with forwarding, and then 2) letting any range queries to flush cache first, and then only return from the underlying store.&lt;/p&gt;</comment>
                            <comment id="17751836" author="mjsax" created="Tue, 8 Aug 2023 00:14:50 +0000"  >&lt;blockquote&gt;&lt;p&gt;it&apos;s a combo of a cache snapshot and the underlying RocksDB&apos;s&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I think this is actually the bug: we actually don&apos;t return a snapshot over the cache. If it would be a snapshot, flushing the cache would not modify it, but it does as you pointed out:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;hat modifying the store for `keyA` might change the content of `KeyB` compared with the snapshot&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I am totally in favor of &quot;decouple flushing with forwarding&quot; thought, independent of this ticket. But that&apos;s a larger piece of work anyway, and I am also not sure if we would want to make such a change in-place, or via DSL 2.0?&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;letting any range queries to flush cache first, and then only return from the underlying store.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;That&apos;s an interesting idea. &#8211; A naive fix would be, to actually make a &quot;shallow copy (with copy on write)&quot; of the named cached when opening an iterator, to guard the shallow copy for evection. But this is also hard to get right and could be very memory intensive...&lt;/p&gt;

&lt;p&gt;In case we cannot provide a fix easily, updating the docs is for sure something we should do.&lt;/p&gt;</comment>
                            <comment id="17752451" author="JIRAUSER301376" created="Wed, 9 Aug 2023 15:43:51 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt; , &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;&#160;&lt;br/&gt;
&#160;&lt;br/&gt;
If you perform a delete() within a while() loop, it seems that due to the interactions of maybeEvict()-&amp;gt;flush(), the value of a key that hasn&apos;t been traversed yet might return as stale data. Therefore, I consider this to be a bug.&lt;br/&gt;
&#160;&lt;br/&gt;
The main changes are as follows: I&apos;ve made modifications to give a hint to the cache, determining whether to call maybeEvict(), by checking the current state of the RocksDB KeyValueStore, particularly when it&apos;s in a snapshot state.&lt;br/&gt;
&#160;&lt;br/&gt;
Please refer to the code snippet below for a complete view of the changes.(I haven&apos;t modified the test code.)&lt;/p&gt;

&lt;p&gt;&#160;&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/kafka/compare/trunk...jinyongchoi:kafka:KAFKA-15302-testing&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/compare/trunk...jinyongchoi:kafka:KAFKA-15302-testing&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBStore.java
...
&#160; &#160; @Override
&#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isEvictionInvocationViable() {
&#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; openIterators.isEmpty();
&#160; &#160; }

streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java
...
&lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void putInternal(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bytes key, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;byte&lt;/span&gt;[] value) {
&#160; &#160; &#160; &#160; context.cache().put(
&#160; &#160; &#160; &#160; &#160; &#160; cacheName,
&#160; &#160; &#160; &#160; &#160; &#160; key,
&#160; &#160; &#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LRUCacheEntry(
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; value,
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; context.headers(),
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;,
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; context.offset(),
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; context.timestamp(),
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; context.partition(),
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; context.topic()),
&#160; &#160; &#160; &#160; &#160; &#160; wrapped().isEvictionInvocationViable());


&#160; &#160; &#160; &#160; StoreQueryUtils.updatePosition(position, context);
&#160; &#160; }

streams/src/main/java/org/apache/kafka/streams/state/internals/ThreadCache.java
...
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void put(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; namespace, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Bytes key, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; LRUCacheEntry value, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isEvictionViable) {
        numPuts++;

        &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; NamedCache cache = getOrCreateCache(namespace);

        &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt; (cache) {
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;long&lt;/span&gt; oldSize = cache.sizeInBytes();
            cache.put(key, value);
            sizeInBytes.getAndAdd(cache.sizeInBytes() - oldSize);
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isEvictionViable) {
                maybeEvict(namespace, cache);
            }
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;&lt;br/&gt;
After the modifications, the following thoughts arise:&lt;br/&gt;
&#160;&lt;br/&gt;
1. It seems unnecessary to perform delete operations during traversal for SessionStore or TimestampedKeyValueStore, but this aspect needs documentation.&lt;br/&gt;
&#160;&lt;br/&gt;
2. It functions as expected, but the code doesn&apos;t seem to be very clean.&lt;br/&gt;
&#160;&lt;br/&gt;
3. Since flush() is suppressed during the while() loop, many keys are stored in the Cache. However, as their values are null, it appears there isn&apos;t a significant memory burden. Still, caution is warranted.&lt;br/&gt;
&#160;&lt;br/&gt;
4. Due to the inhibition of flush() during the while() loop, a subsequent flush operation, as shown below, took 10 seconds.&lt;br/&gt;
While cases requiring the processing of 5,000,000 items at once are unlikely, this aspect also demands attention.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
21:26:17.509 [...-StreamThread-1] INFO &#160;o.a.k.s.state.internals.NamedCache -- Named Cache flush start dirtyKeys.size():5000000 entries:5000000
21:26:26.874 [...-StreamThread-1] INFO &#160;o.a.k.s.state.internals.NamedCache -- Named Cache flush end dirtyKeys.size():0 entries:5000000&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;5. If it takes time to correct it in the right direction, it might be a good idea to document this in advance to aid developers&apos; understanding.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;I&apos;m not coming up with any better ideas.&lt;br/&gt;
If it takes time to make the correct modifications, I agree that we should update the documentation first.&lt;/p&gt;</comment>
                            <comment id="17753490" author="JIRAUSER301376" created="Sat, 12 Aug 2023 09:17:21 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;&#160;&lt;br/&gt;
I had a new idea.&lt;/p&gt;

&lt;p&gt;The essence of this issue is that when iterating through store.all(), a problem arises with the delete() operation, where the fresh value of the Cache is deleted.&lt;/p&gt;

&lt;p&gt;As we begin iterating through store.all(), let&apos;s assume that it initially returns (Key: 1, Value: 2).&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
(max caches: 3)
Cache &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; Store.all() (Snaped)  &#160; &#160; &#160; &#160;Store
LRU Head
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;(Key : 1, Value: 2)
(Key : 2, Value: 2) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;(Key : 2, Value: 1)
(Key : 3, Value: 2) &#160; &#160; (Key : 3, Value 1) &#160; &#160; &#160; &#160; (Key : 3, Value: 1)
(Key : 4, Value: 2) &#160; &#160; (Key : 4, Value 1) &#160; &#160; &#160; &#160; (Key : 4, Value: 1)
LRU Tail
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Following the previous test code, when store.delete() is performed to delete Key 1, the following changes occur.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Cache &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; Store.all() (Snaped)  &#160; &#160; &#160; &#160;Store
LRU Head
(Key : 1, Value: &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (Key : 1, Value: 2)
(Key : 2, Value: 2) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;(Key : 2, Value: 1)
(Key : 3, Value: 2) &#160; &#160; (Key : 3, Value 1) &#160; &#160; &#160; &#160; (Key : 3, Value: 1)
(Key : 4, Value: 2) &#160; &#160; (Key : 4, Value 1) &#160; &#160; &#160; &#160; (Key : 4, Value: 1)
LRU Tail
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Inside the delete() function, the evict() is executed, which checks the cache size and removes the tail due to LRU as shown below. (Key:4 deleted)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
Cache &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; Store.all() (Snaped)  &#160; &#160; &#160; &#160;Store
LRU Head
(Key : 1, Value: &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (Key : 1, Value: 2)
(Key : 2, Value: 2) &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;(Key : 2, Value: 1)
(Key : 3, Value: 2) &#160; &#160; (Key : 3, Value 1) &#160; &#160; &#160; &#160; (Key : 3, Value: 1)
&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; (Key : 4, Value 1) &#160; &#160; &#160; &#160; (Key : 4, Value: 1)
LRU Tail
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;With the aforementioned process, when next() eventually reaches Key 4&apos;s position, the Cache doesn&apos;t have that key. As a result, the value 1 from the Snaped Store is returned, causing an error situation.&lt;/p&gt;

&lt;p&gt;Therefore, here are the following suggestions: &lt;br/&gt;
(It doesn&apos;t seem to use the cache competitively in situations where delete() is executed.)&lt;/p&gt;

&lt;p&gt;So.&lt;br/&gt;
1. What if we add the deleted item to the Tail of LRUCache, rather than the Head, when performing delete()?&lt;br/&gt;
2. Alternatively, a combination of the first suggestion: during RocksDB Iteration, add the item only to the Tail when delete() is executed.&lt;/p&gt;

&lt;p&gt;I think this fix is good because it has fewer side effects. (memory.. flush....)&lt;/p&gt;

&lt;p&gt;Could you please provide your opinion on this idea? (1 or 2 or ?)&lt;/p&gt;

&lt;p&gt;If the idea sounds good, once you confirm, I&apos;ll proceed to show you the modified code for streams for PR.&lt;/p&gt;</comment>
                            <comment id="17755298" author="mjsax" created="Wed, 16 Aug 2023 23:01:59 +0000"  >&lt;p&gt;I would need to think more about this. Overall, it seems a little bit hacky, and I am not sure if there is a clean fix.&lt;/p&gt;

&lt;p&gt;For the time being, it might be best to just document the issue &#8211; the workaround seems to be, to call `flush()` expliclity before creating the iterator. Because there is an existing workaround, I would rather not rush into a hacky fix.&lt;/p&gt;</comment>
                            <comment id="17756245" author="JIRAUSER301376" created="Sat, 19 Aug 2023 07:35:42 +0000"  >&lt;p&gt;I got it.&lt;/p&gt;</comment>
                            <comment id="17818755" author="JIRAUSER300569" created="Tue, 20 Feb 2024 10:47:23 +0000"  >&lt;p&gt;Hello,&lt;/p&gt;

&lt;p&gt;Deleting from a state store while iterating it with KeyValueStore#all or KeyValue#range is a pattern which I sometimes use too. Actually, it may be quite common approach for this forward-delete scenario.&lt;/p&gt;

&lt;p&gt;In case there won&apos;t be a fix, updating documentation would be helpful.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;Are these all valid workarounds? Note that some are quite limiting.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;1. Flush before iterate&lt;/p&gt;

&lt;p&gt;2. Delete (modify) after iteration is finished (store keys for deletion is temporary set)&lt;/p&gt;

&lt;p&gt;3. Use in-memory stores instead of Rocks DB&lt;/p&gt;

&lt;p&gt;4. Disable Streams (heap) cache (or set statestore.cache.max.bytes to 0)&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17820083" author="JIRAUSER301376" created="Fri, 23 Feb 2024 15:22:39 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=cervinka&quot; class=&quot;user-hover&quot; rel=&quot;cervinka&quot;&gt;cervinka&lt;/a&gt;&#160; Hi.&lt;/p&gt;

&lt;p&gt;It seems like the patch for this issue will take a while, so I will try updating the document.&lt;/p&gt;

&lt;p&gt;and Yes,&lt;/p&gt;

&lt;p&gt;But this issue pertains to the use of caching and storage.&lt;/p&gt;

&lt;p&gt;Even if we switch to an in-memory store, the same situation may arise when utilizing caching functionality.&lt;/p&gt;

&lt;p&gt;Conversely, if we opt not to use caching, we lose the ability to leverage one of its key features, the record compact functionality.&lt;/p&gt;

&lt;p&gt;I think this needs to be taken into consideration.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;I&apos;ve applied some modifications of NamedCache based on a few of the approaches mentioned earlier and am currently using them for performance.&lt;/p&gt;

&lt;p&gt;Thank you for your attention to this issue.&lt;/p&gt;</comment>
                            <comment id="17825529" author="JIRAUSER301376" created="Tue, 12 Mar 2024 06:09:25 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/kafka/pull/15495&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/15495&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We have updated the document for users who use it similarly.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            1 year, 35 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z1jkmg:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>