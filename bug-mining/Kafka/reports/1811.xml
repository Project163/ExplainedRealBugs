<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:06:30 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6487] ChangeLoggingKeyValueBytesStore.all() returns null</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6487</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;The&#160; &lt;tt&gt;ChangeLoggingKeyValueBytesStore&lt;/tt&gt; implements the &lt;tt&gt;KeyValueStore&lt;/tt&gt; interface which extends the &lt;tt&gt;ReadOnlyKeyValueStore&lt;/tt&gt; interface.&#160; The Javadoc&#160;for&#160;&lt;tt&gt;ReadOnlyKeyValueStore#all&lt;/tt&gt;&#160;states the method should never return a&#160;&lt;tt&gt;null&lt;/tt&gt;&#160;value.&lt;/p&gt;

&lt;p&gt;But when deleting a record from the &lt;tt&gt;ChangeLoggingKeyValueBytesStore&lt;/tt&gt; and subsequently calling the &lt;tt&gt;all&lt;/tt&gt; method, a null value is returned.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4750&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-4750&lt;/a&gt;&#160;is a related issue&lt;/p&gt;</description>
                <environment></environment>
        <key id="13133814">KAFKA-6487</key>
            <summary>ChangeLoggingKeyValueBytesStore.all() returns null</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="bdevylde">Bart De Vylder</assignee>
                                    <reporter username="bbejeck">Bill Bejeck</reporter>
                        <labels>
                    </labels>
                <created>Thu, 25 Jan 2018 19:52:22 +0000</created>
                <updated>Fri, 2 Feb 2018 00:24:32 +0000</updated>
                            <resolved>Fri, 2 Feb 2018 00:24:32 +0000</resolved>
                                    <version>1.0.0</version>
                                    <fixVersion>1.1.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="16341404" author="wushujames" created="Fri, 26 Jan 2018 18:34:09 +0000"  >&lt;p&gt;While waiting for a fix, a workaround would be to skip any entries that come back from the iterator, that have null as a value.&lt;/p&gt;

&lt;p&gt;This would only work, though, if you never expected that null would be a valid value in your use case&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; (KeyValueIterator&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; iter = stateStore.all()) { 
    &lt;span class=&quot;code-keyword&quot;&gt;while&lt;/span&gt; (iter.hasNext()) { 
        KeyValue&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&amp;gt; keyValue = iter.next(); 
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (keyValue.value == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) { 
            &lt;span class=&quot;code-comment&quot;&gt;// skip 
&lt;/span&gt;        } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; { 
            &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; something 
&lt;/span&gt;        } 
    } 
}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16346824" author="githubbot" created="Wed, 31 Jan 2018 13:29:21 +0000"  >&lt;p&gt;bartdevylder opened a new pull request #4495: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6487&quot; title=&quot;ChangeLoggingKeyValueBytesStore.all() returns null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6487&quot;&gt;&lt;del&gt;KAFKA-6487&lt;/del&gt;&lt;/a&gt;: ChangeLoggingKeyValueBytesStore does not propagate delete&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4495&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4495&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   The `ChangeLoggingKeyValueBytesStore` used to write null to its underlying store instead of propagating the delete, which has two drawbacks:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;an iterator will see null values&lt;/li&gt;
	&lt;li&gt;unbounded memory growth of the underlying in-memory keyvalue store&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   The fix will just propagate the delete instead of performing put(key, null). &lt;/p&gt;

&lt;p&gt;   The changes to the tests:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;extra test whether the key is really gone after delete by calling the `approximateEntries` on the underlying store. This number is exact because we know the underlying store in the test is of type `InMemoryKeyValueStore`&lt;/li&gt;
	&lt;li&gt;extra test to check a delete is logged as &amp;lt;key, null&amp;gt;  (the existing test would also succeed if the key is just absent)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;   While also updating the corresponding tests of the `ChangeLoggingKeyValueStore` I noticed the class is nowhere used anymore so I removed it from the source code for clarity.&lt;/p&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16346831" author="bdevylde" created="Wed, 31 Jan 2018 13:33:10 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bbejeck&quot; class=&quot;user-hover&quot; rel=&quot;bbejeck&quot;&gt;bbejeck&lt;/a&gt; i started working on this issue before I saw this ticket. I made a PR for it here: &lt;a href=&quot;https://github.com/apache/kafka/pull/4495&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4495&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16347165" author="bbejeck" created="Wed, 31 Jan 2018 16:53:43 +0000"  >&lt;p&gt;No worries &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bdevylde&quot; class=&quot;user-hover&quot; rel=&quot;bdevylde&quot;&gt;bdevylde&lt;/a&gt; I&apos;ll re-assign the ticket to you&lt;/p&gt;</comment>
                            <comment id="16347199" author="mjsax" created="Wed, 31 Jan 2018 17:11:22 +0000"  >&lt;p&gt;@bdevylde I added you to the list of contributors. You can assign tickets to yourself now.&lt;/p&gt;

&lt;p&gt;Please, assign tickets to yourself before you start working on it. Also update the ticket to &quot;work in progress&quot; and &quot;patch available&quot; if possible. If you are interested in a ticket that is assigned but does not show any activity, feel free to leave a comment and ask if you can take if over. Thanks for contributing!&lt;/p&gt;</comment>
                            <comment id="16347269" author="bdevylde" created="Wed, 31 Jan 2018 17:53:54 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/kafka/pull/4495&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4495&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16349560" author="githubbot" created="Fri, 2 Feb 2018 00:14:25 +0000"  >&lt;p&gt;guozhangwang closed pull request #4495: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6487&quot; title=&quot;ChangeLoggingKeyValueBytesStore.all() returns null&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6487&quot;&gt;&lt;del&gt;KAFKA-6487&lt;/del&gt;&lt;/a&gt;: ChangeLoggingKeyValueBytesStore does not propagate delete&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4495&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4495&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java&lt;br/&gt;
index 8dc457a9949..94ee275a3bf 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java&lt;br/&gt;
@@ -77,8 +77,8 @@ public void putAll(final List&amp;lt;KeyValue&amp;lt;Bytes, byte[]&amp;gt;&amp;gt; entries) {&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     public byte[] delete(final Bytes key) &lt;/p&gt;
{
-        final byte[] oldValue = inner.get(key);
-        put(key, null);
+        final byte[] oldValue = inner.delete(key);
+        changeLogger.logChange(key, null);
         return oldValue;
     }

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueStore.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index ea9f7aa8713..00000000000&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueStore.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,123 +0,0 @@&lt;br/&gt;
-/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements. See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to You under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License. You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.kafka.streams.state.internals;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
-import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
-import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
-import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
-import org.apache.kafka.streams.processor.StateStore;&lt;br/&gt;
-import org.apache.kafka.streams.processor.internals.ProcessorStateManager;&lt;br/&gt;
-import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
-import org.apache.kafka.streams.state.KeyValueStore;&lt;br/&gt;
-import org.apache.kafka.streams.state.StateSerdes;&lt;br/&gt;
-&lt;br/&gt;
-import java.util.ArrayList;&lt;br/&gt;
-import java.util.List;&lt;br/&gt;
-&lt;br/&gt;
-class ChangeLoggingKeyValueStore&amp;lt;K, V&amp;gt; extends WrappedStateStore.AbstractStateStore implements KeyValueStore&amp;lt;K, V&amp;gt; {&lt;/li&gt;
	&lt;li&gt;private final ChangeLoggingKeyValueBytesStore innerBytes;&lt;/li&gt;
	&lt;li&gt;private final Serde keySerde;&lt;/li&gt;
	&lt;li&gt;private final Serde valueSerde;&lt;/li&gt;
	&lt;li&gt;private StateSerdes&amp;lt;K, V&amp;gt; serdes;&lt;br/&gt;
-&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;ChangeLoggingKeyValueStore(final KeyValueStore&amp;lt;Bytes, byte[]&amp;gt; bytesStore,&lt;/li&gt;
	&lt;li&gt;final Serde keySerde,&lt;/li&gt;
	&lt;li&gt;final Serde valueSerde) 
{
-        this(new ChangeLoggingKeyValueBytesStore(bytesStore), keySerde, valueSerde);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private ChangeLoggingKeyValueStore(final ChangeLoggingKeyValueBytesStore bytesStore,&lt;/li&gt;
	&lt;li&gt;final Serde keySerde,&lt;/li&gt;
	&lt;li&gt;final Serde valueSerde) 
{
-        super(bytesStore);
-        this.innerBytes = bytesStore;
-        this.keySerde = keySerde;
-        this.valueSerde = valueSerde;
-    }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void init(final ProcessorContext context, final StateStore root) 
{
-        innerBytes.init(context, root);
-
-        serdes = new StateSerdes&amp;lt;&amp;gt;(ProcessorStateManager.storeChangelogTopic(context.applicationId(), innerBytes.name()),
-                                   keySerde == null ? (Serde&amp;lt;K&amp;gt;) context.keySerde() : keySerde,
-                                   valueSerde == null ? (Serde&amp;lt;V&amp;gt;) context.valueSerde() : valueSerde);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public long approximateNumEntries() 
{
-        return innerBytes.approximateNumEntries();
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void put(final K key, final V value) 
{
-        final Bytes bytesKey = Bytes.wrap(serdes.rawKey(key));
-        final byte[] bytesValue = serdes.rawValue(value);
-        innerBytes.put(bytesKey, bytesValue);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public V putIfAbsent(final K key, final V value) {&lt;/li&gt;
	&lt;li&gt;final V v = get(key);&lt;/li&gt;
	&lt;li&gt;if (v == null) 
{
-            put(key, value);
-        }&lt;/li&gt;
	&lt;li&gt;return v;&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void putAll(final List&amp;lt;KeyValue&amp;lt;K, V&amp;gt;&amp;gt; entries) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;KeyValue&amp;lt;Bytes, byte[]&amp;gt;&amp;gt; keyValues = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;for (final KeyValue&amp;lt;K, V&amp;gt; entry : entries) 
{
-            keyValues.add(KeyValue.pair(Bytes.wrap(serdes.rawKey(entry.key)), serdes.rawValue(entry.value)));
-        }&lt;/li&gt;
	&lt;li&gt;innerBytes.putAll(keyValues);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public V delete(final K key) {&lt;/li&gt;
	&lt;li&gt;final byte[] oldValue = innerBytes.delete(Bytes.wrap(serdes.rawKey(key)));&lt;/li&gt;
	&lt;li&gt;if (oldValue == null) 
{
-            return null;
-        }&lt;br/&gt;
-        return serdes.valueFrom(oldValue);&lt;br/&gt;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    @Override&lt;br/&gt;
-    public V get(final K key) {&lt;br/&gt;
-        final byte[] rawValue = innerBytes.get(Bytes.wrap(serdes.rawKey(key)));&lt;br/&gt;
-        if (rawValue == null) {-            return null;-        }&lt;/li&gt;
	&lt;li&gt;return serdes.valueFrom(rawValue);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public KeyValueIterator&amp;lt;K, V&amp;gt; range(final K from, final K to) 
{
-        return new SerializedKeyValueIterator&amp;lt;&amp;gt;(innerBytes.range(Bytes.wrap(serdes.rawKey(from)),
-                                                                 Bytes.wrap(serdes.rawKey(to))),
-                                                                 serdes);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public KeyValueIterator&amp;lt;K, V&amp;gt; all() 
{
-        return new SerializedKeyValueIterator&amp;lt;&amp;gt;(innerBytes.all(), serdes);
-    }
&lt;p&gt;-}&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java&lt;br/&gt;
index 65a9dec892b..398c4c5062c 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java&lt;br/&gt;
@@ -27,14 +27,14 @@&lt;br/&gt;
 import org.junit.Test;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import java.util.Collections;&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.Map;&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;br/&gt;
 import static org.junit.Assert.assertNull;&lt;br/&gt;
-import static org.junit.Assert.fail;&lt;/p&gt;

&lt;p&gt; public abstract class AbstractKeyValueStoreTest {&lt;/p&gt;

&lt;p&gt;-&lt;br/&gt;
     protected abstract &amp;lt;K, V&amp;gt; KeyValueStore&amp;lt;K, V&amp;gt; createKeyValueStore(ProcessorContext context,&lt;br/&gt;
                                                                       Class&amp;lt;K&amp;gt; keyClass, Class&amp;lt;V&amp;gt; valueClass,&lt;br/&gt;
                                                                       boolean useContextSerdes);&lt;br/&gt;
@@ -58,6 +58,15 @@ public void after() &lt;/p&gt;
{
         driver.clear();
     }

&lt;p&gt;+    private static Map&amp;lt;Integer, String&amp;gt; getContents(final KeyValueIterator&amp;lt;Integer, String&amp;gt; iter) {&lt;br/&gt;
+        final HashMap&amp;lt;Integer, String&amp;gt; result = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+        while (iter.hasNext()) &lt;/p&gt;
{
+            KeyValue&amp;lt;Integer, String&amp;gt; entry = iter.next();
+            result.put(entry.key, entry.value);
+        }
&lt;p&gt;+        return result;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testPutGetRange() {&lt;br/&gt;
         // Verify that the store reads and writes correctly ...&lt;br/&gt;
@@ -74,6 +83,7 @@ public void testPutGetRange() {&lt;br/&gt;
         assertEquals(&quot;four&quot;, store.get(4));&lt;br/&gt;
         assertEquals(&quot;five&quot;, store.get(5));&lt;br/&gt;
         store.delete(5);&lt;br/&gt;
+        assertEquals(4, driver.sizeOf(store));&lt;/p&gt;

&lt;p&gt;         // Flush the store and verify all current entries were properly flushed ...&lt;br/&gt;
         store.flush();&lt;br/&gt;
@@ -89,31 +99,18 @@ public void testPutGetRange() {&lt;br/&gt;
         assertEquals(false, driver.flushedEntryRemoved(4));&lt;br/&gt;
         assertEquals(true, driver.flushedEntryRemoved(5));&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// Check range iteration ...&lt;/li&gt;
	&lt;li&gt;try (KeyValueIterator&amp;lt;Integer, String&amp;gt; iter = store.range(2, 4)) {&lt;/li&gt;
	&lt;li&gt;while (iter.hasNext()) 
{
-                KeyValue&amp;lt;Integer, String&amp;gt; entry = iter.next();
-                if (entry.key.equals(2))
-                    assertEquals(&quot;two&quot;, entry.value);
-                else if (entry.key.equals(4))
-                    assertEquals(&quot;four&quot;, entry.value);
-                else
-                    fail(&quot;Unexpected entry: &quot; + entry);
-            }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+        final HashMap&amp;lt;Integer, String&amp;gt; expectedContents = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+        expectedContents.put(2, &quot;two&quot;);&lt;br/&gt;
+        expectedContents.put(4, &quot;four&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // Check range iteration ...&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try (KeyValueIterator&amp;lt;Integer, String&amp;gt; iter = store.range(2, 6)) {&lt;/li&gt;
	&lt;li&gt;while (iter.hasNext()) 
{
-                KeyValue&amp;lt;Integer, String&amp;gt; entry = iter.next();
-                if (entry.key.equals(2))
-                    assertEquals(&quot;two&quot;, entry.value);
-                else if (entry.key.equals(4))
-                    assertEquals(&quot;four&quot;, entry.value);
-                else
-                    fail(&quot;Unexpected entry: &quot; + entry);
-            }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
+        assertEquals(expectedContents, getContents(store.range(2, 4)));&lt;br/&gt;
+        assertEquals(expectedContents, getContents(store.range(2, 6)));&lt;br/&gt;
+&lt;br/&gt;
+        // Check all iteration ...&lt;br/&gt;
+        expectedContents.put(0, &quot;zero&quot;);&lt;br/&gt;
+        expectedContents.put(1, &quot;one&quot;);&lt;br/&gt;
+        assertEquals(expectedContents, getContents(store.all()));&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStoreTest.java&lt;br/&gt;
index cf0792712f6..9360daef272 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStoreTest.java&lt;br/&gt;
@@ -109,9 +109,10 @@ public void shouldLogChangesOnPutAll() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldPutNullOnDelete() {&lt;br/&gt;
+    public void shouldPropagateDelete() 
{
         store.put(hi, there);
         store.delete(hi);
+        assertThat(inner.approximateNumEntries(), equalTo(0L));
         assertThat(inner.get(hi), nullValue());
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -125,6 +126,7 @@ public void shouldReturnOldValueOnDelete() {&lt;br/&gt;
     public void shouldLogKeyNullOnDelete() &lt;/p&gt;
{
         store.put(hi, there);
         store.delete(hi);
+        assertThat(sent.containsKey(hi), is(true));
         assertThat(sent.get(hi), nullValue());
     }

&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueStoreTest.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 8190fd241f3..00000000000&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueStoreTest.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,225 +0,0 @@&lt;br/&gt;
-/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements. See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to You under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License. You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.kafka.streams.state.internals;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.kafka.common.metrics.Metrics;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
-import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
-import org.apache.kafka.common.utils.LogContext;&lt;br/&gt;
-import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
-import org.apache.kafka.streams.processor.internals.MockStreamsMetrics;&lt;br/&gt;
-import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
-import org.apache.kafka.test.MockProcessorContext;&lt;br/&gt;
-import org.apache.kafka.test.NoOpRecordCollector;&lt;br/&gt;
-import org.apache.kafka.test.TestUtils;&lt;br/&gt;
-import org.junit.After;&lt;br/&gt;
-import org.junit.Before;&lt;br/&gt;
-import org.junit.Test;&lt;br/&gt;
-&lt;br/&gt;
-import java.util.Arrays;&lt;br/&gt;
-import java.util.HashMap;&lt;br/&gt;
-import java.util.Map;&lt;br/&gt;
-&lt;br/&gt;
-import static org.hamcrest.CoreMatchers.equalTo;&lt;br/&gt;
-import static org.hamcrest.CoreMatchers.is;&lt;br/&gt;
-import static org.hamcrest.CoreMatchers.nullValue;&lt;br/&gt;
-import static org.hamcrest.MatcherAssert.assertThat;&lt;br/&gt;
-import static org.junit.Assert.assertFalse;&lt;br/&gt;
-&lt;br/&gt;
-public class ChangeLoggingKeyValueStoreTest {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private MockProcessorContext context;&lt;/li&gt;
	&lt;li&gt;private final InMemoryKeyValueStore&amp;lt;Bytes, byte[]&amp;gt; inner = new InMemoryKeyValueStore&amp;lt;&amp;gt;(&quot;kv&quot;, Serdes.Bytes(), Serdes.ByteArray());&lt;/li&gt;
	&lt;li&gt;private final Serde&amp;lt;String&amp;gt; keySerde = Serdes.String();&lt;/li&gt;
	&lt;li&gt;private final Serde&amp;lt;String&amp;gt; valueSerde = Serdes.String();&lt;/li&gt;
	&lt;li&gt;private final ChangeLoggingKeyValueStore&amp;lt;String, String&amp;gt; store&lt;/li&gt;
	&lt;li&gt;= new ChangeLoggingKeyValueStore&amp;lt;&amp;gt;(inner, keySerde, valueSerde);&lt;/li&gt;
	&lt;li&gt;private final Map sent = new HashMap&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;private final String hi = &quot;hi&quot;;&lt;/li&gt;
	&lt;li&gt;private final Bytes hiBytes = Bytes.wrap(hi.getBytes());&lt;/li&gt;
	&lt;li&gt;private final String there = &quot;there&quot;;&lt;/li&gt;
	&lt;li&gt;private final byte[] thereBytes = &quot;there&quot;.getBytes();&lt;/li&gt;
	&lt;li&gt;private final String hello = &quot;hello&quot;;&lt;/li&gt;
	&lt;li&gt;private final String world = &quot;world&quot;;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Before&lt;/li&gt;
	&lt;li&gt;public void before() {&lt;/li&gt;
	&lt;li&gt;final NoOpRecordCollector collector = new NoOpRecordCollector() {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public &amp;lt;K, V&amp;gt; void send(final String topic,&lt;/li&gt;
	&lt;li&gt;K key,&lt;/li&gt;
	&lt;li&gt;V value,&lt;/li&gt;
	&lt;li&gt;Integer partition,&lt;/li&gt;
	&lt;li&gt;Long timestamp,&lt;/li&gt;
	&lt;li&gt;Serializer&amp;lt;K&amp;gt; keySerializer,&lt;/li&gt;
	&lt;li&gt;Serializer&amp;lt;V&amp;gt; valueSerializer) 
{
-                sent.put(key, value);
-            }&lt;/li&gt;
	&lt;li&gt;};&lt;/li&gt;
	&lt;li&gt;context = new MockProcessorContext(&lt;/li&gt;
	&lt;li&gt;TestUtils.tempDirectory(),&lt;/li&gt;
	&lt;li&gt;Serdes.String(),&lt;/li&gt;
	&lt;li&gt;Serdes.Long(),&lt;/li&gt;
	&lt;li&gt;collector,&lt;/li&gt;
	&lt;li&gt;new ThreadCache(new LogContext(&quot;testCache &quot;), 0, new MockStreamsMetrics(new Metrics())));&lt;/li&gt;
	&lt;li&gt;context.setTime(0);&lt;/li&gt;
	&lt;li&gt;store.init(context, store);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@After&lt;/li&gt;
	&lt;li&gt;public void after() 
{
-        context.close();
-        store.close();
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldWriteKeyValueBytesToInnerStoreOnPut() 
{
-        store.put(hi, there);
-        assertThat(deserializedValueFromInner(hi), equalTo(there));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldLogChangeOnPut() 
{
-        store.put(hi, there);
-        assertThat((byte[]) sent.get(hiBytes), equalTo(thereBytes));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldWriteAllKeyValueToInnerStoreOnPutAll() 
{
-        store.putAll(Arrays.asList(KeyValue.pair(hello, world),
-                                   KeyValue.pair(hi, there)));
-        assertThat(deserializedValueFromInner(hello), equalTo(world));
-        assertThat(deserializedValueFromInner(hi), equalTo(there));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldLogChangesOnPutAll() 
{
-        store.putAll(Arrays.asList(KeyValue.pair(hi, there),
-                                   KeyValue.pair(hello, world)));
-        assertThat((byte[]) sent.get(hiBytes), equalTo(thereBytes));
-        assertThat((byte[]) sent.get(Bytes.wrap(hello.getBytes())), equalTo(world.getBytes()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldPutNullOnDelete() 
{
-        store.put(hi, there);
-        store.delete(hi);
-        assertThat(inner.get(hiBytes), nullValue());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnOldValueOnDelete() 
{
-        store.put(hi, there);
-        assertThat(store.delete(hi), equalTo(there));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnNullOnDeleteIfNoOldValue() 
{
-        assertThat(store.delete(hi), is(nullValue()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldLogKeyNullOnDelete() 
{
-        store.put(hi, there);
-        store.delete(hi);
-        assertThat(sent.get(hi), nullValue());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldWriteToInnerOnPutIfAbsentNoPreviousValue() 
{
-        store.putIfAbsent(hi, there);
-        assertThat(inner.get(hiBytes), equalTo(thereBytes));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldNotWriteToInnerOnPutIfAbsentWhenValueForKeyExists() 
{
-        store.put(hi, there);
-        store.putIfAbsent(hi, world);
-        assertThat(inner.get(hiBytes), equalTo(thereBytes));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldWriteToChangelogOnPutIfAbsentWhenNoPreviousValue() 
{
-        store.putIfAbsent(hi, there);
-        assertThat((byte[]) sent.get(hiBytes), equalTo(thereBytes));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldNotWriteToChangeLogOnPutIfAbsentWhenValueForKeyExists() 
{
-        store.put(hi, there);
-        store.putIfAbsent(hi, world);
-        assertThat((byte[]) sent.get(hiBytes), equalTo(thereBytes));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnCurrentValueOnPutIfAbsent() 
{
-        store.put(hi, there);
-        assertThat(store.putIfAbsent(hi, world), equalTo(there));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnNullOnPutIfAbsentWhenNoPreviousValue() 
{
-        assertThat(store.putIfAbsent(hi, there), is(nullValue()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldQueryRange() 
{
-        store.put(hello, world);
-        store.put(hi, there);
-        store.put(&quot;zooom&quot;, &quot;home&quot;);
-        final KeyValueIterator&amp;lt;String, String&amp;gt; range = store.range(hello, hi);
-        assertThat(range.next(), equalTo(KeyValue.pair(hello, world)));
-        assertThat(range.next(), equalTo(KeyValue.pair(hi, there)));
-        assertFalse(range.hasNext());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnAllKeyValues() 
{
-        store.put(hello, world);
-        store.put(hi, there);
-        final String zooom = &quot;zooom&quot;;
-        final String home = &quot;home&quot;;
-        store.put(zooom, home);
-        final KeyValueIterator&amp;lt;String, String&amp;gt; all = store.all();
-        assertThat(all.next(), equalTo(KeyValue.pair(hello, world)));
-        assertThat(all.next(), equalTo(KeyValue.pair(hi, there)));
-        assertThat(all.next(), equalTo(KeyValue.pair(zooom, home)));
-        assertFalse(all.hasNext());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnValueOnGetWhenExists() 
{
-        store.put(hello, world);
-        assertThat(store.get(hello), equalTo(world));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnNullOnGetWhenDoesntExist() 
{
-        assertThat(store.get(hello), is(nullValue()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldReturnInnerStoreName() 
{
-        assertThat(store.name(), equalTo(&quot;kv&quot;));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private String deserializedValueFromInner(final String key) 
{
-        return valueSerde.deserializer().deserialize(&quot;blah&quot;, inner.get(Bytes.wrap(key.getBytes())));
-    }
&lt;p&gt;-}&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueLoggedStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueLoggedStoreTest.java&lt;br/&gt;
index 3607c9e1107..d24a90fd857 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueLoggedStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueLoggedStoreTest.java&lt;br/&gt;
@@ -16,10 +16,13 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
-import org.apache.kafka.streams.processor.StateStoreSupplier;&lt;br/&gt;
+import org.apache.kafka.streams.processor.StateStore;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueStore;&lt;br/&gt;
+import org.apache.kafka.streams.state.StoreBuilder;&lt;br/&gt;
 import org.apache.kafka.streams.state.Stores;&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt;@@ -39,18 +42,27 @@&lt;br/&gt;
             Class&amp;lt;V&amp;gt; valueClass,&lt;br/&gt;
             boolean useContextSerdes) {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;StateStoreSupplier supplier;&lt;br/&gt;
+        final Serde&amp;lt;K&amp;gt; keySerde;&lt;br/&gt;
+        final Serde&amp;lt;V&amp;gt; valueSerde;&lt;br/&gt;
+&lt;br/&gt;
         if (useContextSerdes) 
{
-            supplier = Stores.create(&quot;my-store&quot;).withKeys(context.keySerde()).withValues(context.valueSerde())
-                .inMemory().enableLogging(Collections.singletonMap(&quot;retention.ms&quot;, &quot;1000&quot;)).build();
+            keySerde = (Serde&amp;lt;K&amp;gt;) context.keySerde();
+            valueSerde = (Serde&amp;lt;V&amp;gt;) context.valueSerde();
         }
&lt;p&gt; else &lt;/p&gt;
{
-            supplier = Stores.create(&quot;my-store&quot;).withKeys(keyClass).withValues(valueClass)
-                .inMemory().enableLogging(Collections.singletonMap(&quot;retention.ms&quot;, &quot;1000&quot;)).build();
+            keySerde = Serdes.serdeFrom(keyClass);
+            valueSerde = Serdes.serdeFrom(valueClass);
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;KeyValueStore&amp;lt;K, V&amp;gt; store = (KeyValueStore&amp;lt;K, V&amp;gt;) supplier.get();&lt;br/&gt;
+        final StoreBuilder storeBuilder = Stores.keyValueStoreBuilder(&lt;br/&gt;
+                Stores.inMemoryKeyValueStore(&quot;my-store&quot;),&lt;br/&gt;
+                keySerde,&lt;br/&gt;
+                valueSerde)&lt;br/&gt;
+                .withLoggingEnabled(Collections.singletonMap(&quot;retention.ms&quot;, &quot;1000&quot;));&lt;br/&gt;
+&lt;br/&gt;
+        final StateStore store = storeBuilder.build();&lt;br/&gt;
         store.init(context, store);&lt;/li&gt;
	&lt;li&gt;return store;&lt;br/&gt;
+&lt;br/&gt;
+        return (KeyValueStore&amp;lt;K, V&amp;gt;) store;&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;




&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 41 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3pdnb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>