<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:07:33 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-4831] Extract WindowedSerde to public APIs</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-4831</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Now that we have augmented WindowSerde with non-arg parameters, the next step is to extract it out as part of the public APIs so that users who wants to I/O windowed streams can use it.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13047439">KAFKA-4831</key>
            <summary>Extract WindowedSerde to public APIs</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="guozhang">Guozhang Wang</assignee>
                                    <reporter username="guozhang">Guozhang Wang</reporter>
                        <labels>
                            <label>needs-kip</label>
                            <label>newbie</label>
                            <label>user-experience</label>
                    </labels>
                <created>Wed, 1 Mar 2017 20:04:40 +0000</created>
                <updated>Fri, 1 Mar 2019 21:53:24 +0000</updated>
                            <resolved>Mon, 12 Mar 2018 22:44:56 +0000</resolved>
                                                    <fixVersion>2.0.0</fixVersion>
                                    <component>streams</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>5</watches>
                                                                                                                <comments>
                            <comment id="15959568" author="pshk4r" created="Thu, 6 Apr 2017 19:20:58 +0000"  >&lt;p&gt;Hello &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=guozhang&quot; class=&quot;user-hover&quot; rel=&quot;guozhang&quot;&gt;guozhang&lt;/a&gt;,&lt;/p&gt;

&lt;p&gt;could you elaborate on this one, please?&lt;/p&gt;

&lt;p&gt;What exactly do you mean should be extracted?&lt;/p&gt;

&lt;p&gt;Thank you.&lt;/p&gt;</comment>
                            <comment id="15959761" author="mjsax" created="Thu, 6 Apr 2017 21:13:59 +0000"  >&lt;p&gt;The classes `WindowSerializer` and `WindowDeserializer` are in package `internals` and should be added to public API. We might also want to have a `Serde` class for windows.&lt;/p&gt;</comment>
                            <comment id="15960362" author="pshk4r" created="Fri, 7 Apr 2017 06:43:06 +0000"  >&lt;p&gt;I see! Thank you &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=mjsax&quot; class=&quot;user-hover&quot; rel=&quot;mjsax&quot;&gt;mjsax&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16047003" author="githubbot" created="Mon, 12 Jun 2017 20:05:16 +0000"  >&lt;p&gt;GitHub user vitaly-pushkar opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/3307&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/3307&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4831&quot; title=&quot;Extract WindowedSerde to public APIs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4831&quot;&gt;&lt;del&gt;KAFKA-4831&lt;/del&gt;&lt;/a&gt;: Extract WindowedSerde to public APIs&lt;/p&gt;

&lt;p&gt;    Now that we have augmented WindowSerde with non-arg parameters, extract it out as part of the public APIs so that users who want to I/O windowed streams can use it.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/vitaly-pushkar/kafka&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/vitaly-pushkar/kafka&lt;/a&gt; public-windowed-serde&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/kafka/pull/3307.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/3307.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #3307&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 1ca0b72b7e119979b4bfe9d05b00295ac9f30ab3&lt;br/&gt;
Author: Vitaly Pushkar &amp;lt;vitaly.pushkar@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-06-04T22:34:40Z&lt;/p&gt;

&lt;p&gt;    Extract Windowed Serde into the public package API&lt;/p&gt;

&lt;p&gt;commit 131b273675a773faa1f79eadd1715a1239e7aa6f&lt;br/&gt;
Author: Vitaly Pushkar &amp;lt;vitaly.pushkar@gmail.com&amp;gt;&lt;br/&gt;
Date:   2017-06-12T19:54:08Z&lt;/p&gt;

&lt;p&gt;    Extract Windowed Serde tests into public package&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16393388" author="githubbot" created="Fri, 9 Mar 2018 19:08:11 +0000"  >&lt;p&gt;guozhangwang closed pull request #3307: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4831&quot; title=&quot;Extract WindowedSerde to public APIs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4831&quot;&gt;&lt;del&gt;KAFKA-4831&lt;/del&gt;&lt;/a&gt;: Extract WindowedSerde to public APIs&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/3307&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/3307&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/clients/src/main/java/org/apache/kafka/common/serialization/Serdes.java b/clients/src/main/java/org/apache/kafka/common/serialization/Serdes.java&lt;br/&gt;
index d6b4d2da611..7825ad4e9c3 100644&lt;br/&gt;
&amp;#8212; a/clients/src/main/java/org/apache/kafka/common/serialization/Serdes.java&lt;br/&gt;
+++ b/clients/src/main/java/org/apache/kafka/common/serialization/Serdes.java&lt;br/&gt;
@@ -26,7 +26,7 @@&lt;br/&gt;
  */&lt;br/&gt;
 public class Serdes {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;static protected class WrapperSerde&amp;lt;T&amp;gt; implements Serde&amp;lt;T&amp;gt; {&lt;br/&gt;
+    static public class WrapperSerde&amp;lt;T&amp;gt; implements Serde&amp;lt;T&amp;gt; {&lt;br/&gt;
         final private Serializer&amp;lt;T&amp;gt; serializer;&lt;br/&gt;
         final private Deserializer&amp;lt;T&amp;gt; deserializer;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/examples/src/main/java/org/apache/kafka/streams/examples/temperature/TemperatureDemo.java b/streams/examples/src/main/java/org/apache/kafka/streams/examples/temperature/TemperatureDemo.java&lt;br/&gt;
index ea81dd66268..c5eb5f9ec7d 100644&lt;br/&gt;
&amp;#8212; a/streams/examples/src/main/java/org/apache/kafka/streams/examples/temperature/TemperatureDemo.java&lt;br/&gt;
+++ b/streams/examples/src/main/java/org/apache/kafka/streams/examples/temperature/TemperatureDemo.java&lt;br/&gt;
@@ -29,8 +29,7 @@&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Reducer;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.TimeWindows;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.WindowedDeserializer;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.WindowedSerializer;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.WindowedSerdes;&lt;/p&gt;

&lt;p&gt; import java.util.Properties;&lt;br/&gt;
 import java.util.concurrent.CountDownLatch;&lt;br/&gt;
@@ -115,9 +114,7 @@ public boolean test(Windowed&amp;lt;String&amp;gt; key, String value) {&lt;br/&gt;
                 }&lt;br/&gt;
             });&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;WindowedSerializer&amp;lt;String&amp;gt; windowedSerializer = new WindowedSerializer&amp;lt;&amp;gt;(Serdes.String().serializer());&lt;/li&gt;
	&lt;li&gt;WindowedDeserializer&amp;lt;String&amp;gt; windowedDeserializer = new WindowedDeserializer&amp;lt;&amp;gt;(Serdes.String().deserializer(), TEMPERATURE_WINDOW_SIZE);&lt;/li&gt;
	&lt;li&gt;Serde&amp;lt;Windowed&amp;lt;String&amp;gt;&amp;gt; windowedSerde = Serdes.serdeFrom(windowedSerializer, windowedDeserializer);&lt;br/&gt;
+        Serde&amp;lt;Windowed&amp;lt;String&amp;gt;&amp;gt; windowedSerde = WindowedSerdes.timeWindowedSerdeFrom(String.class);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // need to override key serde to Windowed&amp;lt;String&amp;gt; type&lt;br/&gt;
         max.to(&quot;iot-temperature-max&quot;, Produced.with(windowedSerde, Serdes.String()));&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/StreamsConfig.java b/streams/src/main/java/org/apache/kafka/streams/StreamsConfig.java&lt;br/&gt;
index 47becfc239b..ecfcad80e81 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/StreamsConfig.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/StreamsConfig.java&lt;br/&gt;
@@ -222,18 +222,32 @@&lt;br/&gt;
     private static final String DEFAULT_PRODUCTION_EXCEPTION_HANDLER_CLASS_CONFIG = &quot;default.production.exception.handler&quot;;&lt;br/&gt;
     private static final String DEFAULT_PRODUCTION_EXCEPTION_HANDLER_CLASS_DOC = &quot;Exception handling class that implements the &amp;lt;code&amp;gt;org.apache.kafka.streams.errors.ProductionExceptionHandler&amp;lt;/code&amp;gt; interface.&quot;;&lt;/p&gt;

&lt;p&gt;+    /**&lt;br/&gt;
+     * &lt;/p&gt;
{@code default.windowed.key.serde.inner}
&lt;p&gt;+     */&lt;br/&gt;
+    public static final String DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS = &quot;default.windowed.key.serde.inner&quot;;&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * &lt;/p&gt;
{@code default.windowed.value.serde.inner}
&lt;p&gt;+     */&lt;br/&gt;
+    public static final String DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS = &quot;default.windowed.value.serde.inner&quot;;&lt;br/&gt;
+&lt;br/&gt;
     /** &lt;/p&gt;
{@code default key.serde}
&lt;p&gt; */&lt;br/&gt;
     public static final String DEFAULT_KEY_SERDE_CLASS_CONFIG = &quot;default.key.serde&quot;;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final String DEFAULT_KEY_SERDE_CLASS_DOC = &quot; Default serializer / deserializer class for key that implements the &amp;lt;code&amp;gt;org.apache.kafka.common.serialization.Serde&amp;lt;/code&amp;gt; interface.&quot;;&lt;br/&gt;
+    private static final String DEFAULT_KEY_SERDE_CLASS_DOC = &quot; Default serializer / deserializer class for key that implements the &amp;lt;code&amp;gt;org.apache.kafka.common.serialization.Serde&amp;lt;/code&amp;gt; interface. &quot;&lt;br/&gt;
+            + &quot;Note when windowed serde class is used, one needs to set the inner serde class that implements the &amp;lt;code&amp;gt;org.apache.kafka.common.serialization.Serde&amp;lt;/code&amp;gt; interface via &apos;&quot;&lt;br/&gt;
+            + DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS + &quot;&apos; or &apos;&quot; + DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS + &quot;&apos; as well&quot;;&lt;br/&gt;
+&lt;br/&gt;
+    /** 
{@code default value.serde}
&lt;p&gt; */&lt;br/&gt;
+    public static final String DEFAULT_VALUE_SERDE_CLASS_CONFIG = &quot;default.value.serde&quot;;&lt;br/&gt;
+    private static final String DEFAULT_VALUE_SERDE_CLASS_DOC = &quot;Default serializer / deserializer class for value that implements the &amp;lt;code&amp;gt;org.apache.kafka.common.serialization.Serde&amp;lt;/code&amp;gt; interface. &quot;&lt;br/&gt;
+            + &quot;Note when windowed serde class is used, one needs to set the inner serde class that implements the &amp;lt;code&amp;gt;org.apache.kafka.common.serialization.Serde&amp;lt;/code&amp;gt; interface via &apos;&quot;&lt;br/&gt;
+            + DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS + &quot;&apos; or &apos;&quot; + DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS + &quot;&apos; as well&quot;;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     /** &lt;/p&gt;
{@code default.timestamp.extractor}
&lt;p&gt; */&lt;br/&gt;
     public static final String DEFAULT_TIMESTAMP_EXTRACTOR_CLASS_CONFIG = &quot;default.timestamp.extractor&quot;;&lt;br/&gt;
     private static final String DEFAULT_TIMESTAMP_EXTRACTOR_CLASS_DOC = &quot;Default timestamp extractor class that implements the &amp;lt;code&amp;gt;org.apache.kafka.streams.processor.TimestampExtractor&amp;lt;/code&amp;gt; interface.&quot;;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;/** 
{@code default.value.serde}
&lt;p&gt; */&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static final String DEFAULT_VALUE_SERDE_CLASS_CONFIG = &quot;default.value.serde&quot;;&lt;/li&gt;
	&lt;li&gt;private static final String DEFAULT_VALUE_SERDE_CLASS_DOC = &quot;Default serializer / deserializer class for value that implements the &amp;lt;code&amp;gt;org.apache.kafka.common.serialization.Serde&amp;lt;/code&amp;gt; interface.&quot;;&lt;br/&gt;
-&lt;br/&gt;
     /**&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;{@code key.serde}&lt;/li&gt;
	&lt;li&gt;@deprecated Use 
{@link #DEFAULT_KEY_SERDE_CLASS_CONFIG}
&lt;p&gt; instead.&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java b/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java&lt;br/&gt;
index 6a68f0c793f..1436e250aa1 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java&lt;br/&gt;
@@ -25,7 +25,6 @@&lt;br/&gt;
 import org.apache.kafka.streams.StreamsBuilder;&lt;br/&gt;
 import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
 import org.apache.kafka.streams.Topology;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.WindowedSerializer;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.WindowedStreamPartitioner;&lt;br/&gt;
 import org.apache.kafka.streams.processor.Processor;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/KTable.java b/streams/src/main/java/org/apache/kafka/streams/kstream/KTable.java&lt;br/&gt;
index c1288f17054..55555a51592 100644&lt;/li&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/kstream/KTable.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/KTable.java&lt;br/&gt;
@@ -24,7 +24,6 @@&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.StreamsBuilder;&lt;br/&gt;
 import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.WindowedSerializer;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.WindowedStreamPartitioner;&lt;br/&gt;
 import org.apache.kafka.streams.processor.StateStore;&lt;br/&gt;
 import org.apache.kafka.streams.processor.StreamPartitioner;&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/SessionWindowedDeserializer.java b/streams/src/main/java/org/apache/kafka/streams/kstream/SessionWindowedDeserializer.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..e2e0400b110&lt;/li&gt;
			&lt;li&gt;/dev/null&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/SessionWindowedDeserializer.java&lt;br/&gt;
@@ -0,0 +1,79 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.config.ConfigException;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
+import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
+import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.apache.kafka.streams.state.internals.SessionKeySchema;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ *  The inner serde class can be specified by setting the property&lt;br/&gt;
+ *  
{@link StreamsConfig#DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS} or&lt;br/&gt;
+ *  {@link StreamsConfig#DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS}&lt;br/&gt;
+ *  if the no-arg constructor is called and hence it is not passed during initialization.&lt;br/&gt;
+ */&lt;br/&gt;
+public class SessionWindowedDeserializer&amp;lt;T&amp;gt; implements Deserializer&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+    private Deserializer&amp;lt;T&amp;gt; inner;&lt;br/&gt;
+&lt;br/&gt;
+    // Default constructor needed by Kafka&lt;br/&gt;
+    public SessionWindowedDeserializer() {}&lt;br/&gt;
+&lt;br/&gt;
+    public SessionWindowedDeserializer(final Deserializer&amp;lt;T&amp;gt; inner) {
+        this.inner = inner;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void configure(final Map&amp;lt;String, ?&amp;gt; configs, final boolean isKey) {&lt;br/&gt;
+        if (inner == null) {&lt;br/&gt;
+            final String propertyName = isKey ? StreamsConfig.DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS : StreamsConfig.DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS;&lt;br/&gt;
+            final String value = (String) configs.get(propertyName);&lt;br/&gt;
+            try {
+                inner = Serde.class.cast(Utils.newInstance(value, Serde.class)).deserializer();
+                inner.configure(configs, isKey);
+            } catch (final ClassNotFoundException e) {
+                throw new ConfigException(propertyName, value, &quot;Serde class &quot; + value + &quot; could not be found.&quot;);
+            }&lt;br/&gt;
+        }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public Windowed&amp;lt;T&amp;gt; deserialize(final String topic, final byte[] data) {&lt;br/&gt;
+        if (data == null || data.length == 0) {
+            return null;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        // for either key or value, their schema is the same hence we will just use session key schema&lt;br/&gt;
+        return SessionKeySchema.from(data, inner, topic);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void close() {
+        inner.close();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    // Only for testing&lt;br/&gt;
+    Deserializer&amp;lt;T&amp;gt; innerDeserializer() {
+        return inner;
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/SessionWindowedSerializer.java b/streams/src/main/java/org/apache/kafka/streams/kstream/SessionWindowedSerializer.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..484b3afde75&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/SessionWindowedSerializer.java&lt;br/&gt;
@@ -0,0 +1,85 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.config.ConfigException;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
+import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
+import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.internals.WindowedSerializer;&lt;br/&gt;
+import org.apache.kafka.streams.state.internals.SessionKeySchema;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ *  The inner serde class can be specified by setting the property&lt;br/&gt;
+ *  {@link StreamsConfig#DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS}
&lt;p&gt; or&lt;br/&gt;
+ *  &lt;/p&gt;
{@link StreamsConfig#DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS}&lt;br/&gt;
+ *  if the no-arg constructor is called and hence it is not passed during initialization.&lt;br/&gt;
+ */&lt;br/&gt;
+public class SessionWindowedSerializer&amp;lt;T&amp;gt; implements WindowedSerializer&amp;lt;T&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+    private Serializer&amp;lt;T&amp;gt; inner;&lt;br/&gt;
+&lt;br/&gt;
+    // Default constructor needed by Kafka&lt;br/&gt;
+    public SessionWindowedSerializer() {}&lt;br/&gt;
+&lt;br/&gt;
+    public SessionWindowedSerializer(final Serializer&amp;lt;T&amp;gt; inner) {
+        this.inner = inner;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void configure(final Map&amp;lt;String, ?&amp;gt; configs, final boolean isKey) {&lt;br/&gt;
+        if (inner == null) {&lt;br/&gt;
+            String propertyName = isKey ? StreamsConfig.DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS : StreamsConfig.DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS;&lt;br/&gt;
+            String value = (String) configs.get(propertyName);&lt;br/&gt;
+            try {
+                inner = Serde.class.cast(Utils.newInstance(value, Serde.class)).serializer();
+                inner.configure(configs, isKey);
+            } catch (final ClassNotFoundException e) {
+                throw new ConfigException(propertyName, value, &quot;Serde class &quot; + value + &quot; could not be found.&quot;);
+            }&lt;br/&gt;
+        }&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public byte[] serialize(final String topic, final Windowed&amp;lt;T&amp;gt; data) {&lt;br/&gt;
+        if (data == null) {
+            return null;
+        }&lt;br/&gt;
+&lt;br/&gt;
+        // for either key or value, their schema is the same hence we will just use session key schema&lt;br/&gt;
+        return SessionKeySchema.toBinary(data, inner, topic);&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void close() {
+        inner.close();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public byte[] serializeBaseKey(final String topic, final Windowed&amp;lt;T&amp;gt; data) {
+        return inner.serialize(topic, data.key());
+    }&lt;br/&gt;
+&lt;br/&gt;
+    // Only for testing&lt;br/&gt;
+    Serializer&amp;lt;T&amp;gt; innerSerializer() {
+        return inner;
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/TimeWindowedDeserializer.java b/streams/src/main/java/org/apache/kafka/streams/kstream/TimeWindowedDeserializer.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..cb9c506912c&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/TimeWindowedDeserializer.java&lt;br/&gt;
@@ -0,0 +1,92 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.config.ConfigException;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
+import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
+import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.apache.kafka.streams.state.internals.WindowKeySchema;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ *  The inner serde class can be specified by setting the property&lt;br/&gt;
+ *  {@link StreamsConfig#DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS} or&lt;br/&gt;
+ *  {@link StreamsConfig#DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS}
&lt;p&gt;+ *  if the no-arg constructor is called and hence it is not passed during initialization.&lt;br/&gt;
+ */&lt;br/&gt;
+public class TimeWindowedDeserializer&amp;lt;T&amp;gt; implements Deserializer&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; {&lt;br/&gt;
+&lt;br/&gt;
+    private final Long windowSize;&lt;br/&gt;
+    &lt;br/&gt;
+    private Deserializer&amp;lt;T&amp;gt; inner;&lt;br/&gt;
+    &lt;br/&gt;
+    // Default constructor needed by Kafka&lt;br/&gt;
+    public TimeWindowedDeserializer() &lt;/p&gt;
{
+        this(null, Long.MAX_VALUE);
+    }
&lt;p&gt;+&lt;br/&gt;
+    // TODO: fix this part as last bits of &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4468&quot; title=&quot;Correctly calculate the window end timestamp after read from state stores&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4468&quot;&gt;&lt;del&gt;KAFKA-4468&lt;/del&gt;&lt;/a&gt;&lt;br/&gt;
+    public TimeWindowedDeserializer(final Deserializer&amp;lt;T&amp;gt; inner) &lt;/p&gt;
{
+        this(inner, Long.MAX_VALUE);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public TimeWindowedDeserializer(final Deserializer&amp;lt;T&amp;gt; inner, final long windowSize) &lt;/p&gt;
{
+        this.inner = inner;
+        this.windowSize = windowSize;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public Long getWindowSize() &lt;/p&gt;
{
+        return this.windowSize;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void configure(final Map&amp;lt;String, ?&amp;gt; configs, final boolean isKey) {&lt;br/&gt;
+        if (inner == null) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            final String propertyName = isKey ? StreamsConfig.DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public byte[] serialize(final String topic, final Windowed&amp;lt;T&amp;gt; data) &lt;/p&gt;
{
+        if (data == null)
+            return null;
+
+        return WindowKeySchema.toBinary(data, inner, topic);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void close() &lt;/p&gt;
{
+        inner.close();
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public byte[] serializeBaseKey(final String topic, final Windowed&amp;lt;T&amp;gt; data) &lt;/p&gt;
{
+        return inner.serialize(topic, data.key());
+    }
&lt;p&gt;+&lt;br/&gt;
+    // Only for testing&lt;br/&gt;
+    Serializer&amp;lt;T&amp;gt; innerSerializer() &lt;/p&gt;
{
+        return inner;
+    }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/WindowedSerdes.java b/streams/src/main/java/org/apache/kafka/streams/kstream/WindowedSerdes.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..d0381c787c0&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;/dev/null&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/WindowedSerdes.java&lt;br/&gt;
@@ -0,0 +1,59 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
+&lt;br/&gt;
+public class WindowedSerdes {&lt;br/&gt;
+&lt;br/&gt;
+    static public class TimeWindowedSerde&amp;lt;T&amp;gt; extends Serdes.WrapperSerde&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        // Default constructor needed for reflection object creation+        public TimeWindowedSerde() {
+            super(new TimeWindowedSerializer&amp;lt;T&amp;gt;(), new TimeWindowedDeserializer&amp;lt;T&amp;gt;());
+        }++        public TimeWindowedSerde(final Serde&amp;lt;T&amp;gt; inner) {
+            super(new TimeWindowedSerializer&amp;lt;&amp;gt;(inner.serializer()), new TimeWindowedDeserializer&amp;lt;&amp;gt;(inner.deserializer()));
+        }+    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+    static public class SessionWindowedSerde&amp;lt;T&amp;gt; extends Serdes.WrapperSerde&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        // Default constructor needed for reflection object creation+        public SessionWindowedSerde() {
+            super(new SessionWindowedSerializer&amp;lt;T&amp;gt;(), new SessionWindowedDeserializer&amp;lt;T&amp;gt;());
+        }++        public SessionWindowedSerde(final Serde&amp;lt;T&amp;gt; inner) {
+            super(new SessionWindowedSerializer&amp;lt;&amp;gt;(inner.serializer()), new SessionWindowedDeserializer&amp;lt;&amp;gt;(inner.deserializer()));
+        }+    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Construct a &lt;/p&gt;
{@code TimeWindowedSerde}
&lt;p&gt; object for the specified inner class type.&lt;br/&gt;
+     */&lt;br/&gt;
+    static public &amp;lt;T&amp;gt; Serde&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; timeWindowedSerdeFrom(final Class&amp;lt;T&amp;gt; type) &lt;/p&gt;
{
+        return new TimeWindowedSerde&amp;lt;&amp;gt;(Serdes.serdeFrom(type));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    /**&lt;br/&gt;
+     * Construct a {@code SessionWindowedSerde} object for the specified inner class type.&lt;br/&gt;
+     */&lt;br/&gt;
+    static public &amp;lt;T&amp;gt; Serde&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; sessionWindowedSerdeFrom(final Class&amp;lt;T&amp;gt; type) {+        return new TimeWindowedSerde&amp;lt;&amp;gt;(Serdes.serdeFrom(type));+    }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java&lt;br/&gt;
index 141bbbb6c55..07bc67d952c 100644&lt;/p&gt;&lt;/li&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java&lt;br/&gt;
@@ -500,8 +500,7 @@ private void to(final String topic, final ProducedInternal&amp;lt;K, V&amp;gt; produced) {&lt;br/&gt;
         final StreamPartitioner&amp;lt;? super K, ? super V&amp;gt; partitioner = produced.streamPartitioner();&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         if (partitioner == null &amp;amp;&amp;amp; keySerializer != null &amp;amp;&amp;amp; keySerializer instanceof WindowedSerializer) &lt;/p&gt;
{
-            final WindowedSerializer&amp;lt;Object&amp;gt; windowedSerializer = (WindowedSerializer&amp;lt;Object&amp;gt;) keySerializer;
-            final StreamPartitioner&amp;lt;K, V&amp;gt; windowedPartitioner = (StreamPartitioner&amp;lt;K, V&amp;gt;) new WindowedStreamPartitioner&amp;lt;Object, V&amp;gt;(topic, windowedSerializer);
+            final StreamPartitioner&amp;lt;K, V&amp;gt; windowedPartitioner = (StreamPartitioner&amp;lt;K, V&amp;gt;) new WindowedStreamPartitioner&amp;lt;Object, V&amp;gt;(topic, (WindowedSerializer) keySerializer);
             builder.internalTopologyBuilder.addSink(name, topic, keySerializer, valSerializer, windowedPartitioner, this.name);
         }
&lt;p&gt; else {&lt;br/&gt;
             builder.internalTopologyBuilder.addSink(name, topic, keySerializer, valSerializer, partitioner, this.name);&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionKeySerde.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionKeySerde.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 2910561eead..00000000000&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/SessionKeySerde.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,170 +0,0 @@&lt;br/&gt;
-/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements. See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to You under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License. You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.kafka.streams.kstream.internals;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
-import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-&lt;br/&gt;
-import java.nio.ByteBuffer;&lt;br/&gt;
-import java.util.Map;&lt;br/&gt;
-&lt;br/&gt;
-/**&lt;/li&gt;
	&lt;li&gt;* Serde for a 
{@link Windowed}
&lt;p&gt; key when working with &lt;/p&gt;
{@link org.apache.kafka.streams.kstream.SessionWindows}&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* @param &amp;lt;K&amp;gt; sessionId type&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-public class SessionKeySerde&amp;lt;K&amp;gt; implements Serde&amp;lt;Windowed&amp;lt;K&amp;gt;&amp;gt; {&lt;/li&gt;
	&lt;li&gt;private static final int TIMESTAMP_SIZE = 8;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private final Serde&amp;lt;K&amp;gt; keySerde;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public SessionKeySerde(final Serde&amp;lt;K&amp;gt; keySerde) 
{
-        this.keySerde = keySerde;
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void configure(final Map&amp;lt;String, ?&amp;gt; configs, final boolean isKey) 
{
-    }&lt;br/&gt;
-&lt;br/&gt;
-    @Override&lt;br/&gt;
-    public void close() {-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Serializer&amp;lt;Windowed&amp;lt;K&amp;gt;&amp;gt; serializer() 
{
-        return new SessionKeySerializer(keySerde.serializer());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Deserializer&amp;lt;Windowed&amp;lt;K&amp;gt;&amp;gt; deserializer() 
{
-        return new SessionKeyDeserializer(keySerde.deserializer());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private class SessionKeySerializer implements Serializer&amp;lt;Windowed&amp;lt;K&amp;gt;&amp;gt; {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private final Serializer&amp;lt;K&amp;gt; keySerializer;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;SessionKeySerializer(final Serializer&amp;lt;K&amp;gt; keySerializer) 
{
-            this.keySerializer = keySerializer;
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void configure(final Map&amp;lt;String, ?&amp;gt; configs, final boolean isKey) 
{
-
-        }&lt;br/&gt;
-&lt;br/&gt;
-        @Override&lt;br/&gt;
-        public byte[] serialize(final String topic, final Windowed&amp;lt;K&amp;gt; data) {&lt;br/&gt;
-            if (data == null) {
-                return null;
-            }&lt;br/&gt;
-            return toBinary(data, keySerializer, topic).get();&lt;br/&gt;
-        }&lt;br/&gt;
-&lt;br/&gt;
-        @Override&lt;br/&gt;
-        public void close() {--        }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private class SessionKeyDeserializer implements Deserializer&amp;lt;Windowed&amp;lt;K&amp;gt;&amp;gt; {&lt;/li&gt;
	&lt;li&gt;private final Deserializer&amp;lt;K&amp;gt; deserializer;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;SessionKeyDeserializer(final Deserializer&amp;lt;K&amp;gt; deserializer) 
{
-            this.deserializer = deserializer;
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void configure(final Map&amp;lt;String, ?&amp;gt; configs, final boolean isKey) 
{
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Windowed&amp;lt;K&amp;gt; deserialize(final String topic, final byte[] data) {&lt;/li&gt;
	&lt;li&gt;if (data == null || data.length == 0) 
{
-                return null;
-            }&lt;/li&gt;
	&lt;li&gt;return from(data, deserializer, topic);&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void close() 
{
-
-        }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;public static long extractEnd(final byte[] binaryKey) 
{
-        return ByteBuffer.wrap(binaryKey).getLong(binaryKey.length - 2 * TIMESTAMP_SIZE);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static long extractStart(final byte[] binaryKey) 
{
-        return ByteBuffer.wrap(binaryKey).getLong(binaryKey.length - TIMESTAMP_SIZE);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static Window extractWindow(final byte[] binaryKey) 
{
-        final ByteBuffer buffer = ByteBuffer.wrap(binaryKey);
-        final long start = buffer.getLong(binaryKey.length - TIMESTAMP_SIZE);
-        final long end = buffer.getLong(binaryKey.length - 2 * TIMESTAMP_SIZE);
-        return new SessionWindow(start, end);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static byte[] extractKeyBytes(final byte[] binaryKey) 
{
-        final byte[] bytes = new byte[binaryKey.length - 2 * TIMESTAMP_SIZE];
-        System.arraycopy(binaryKey, 0, bytes, 0, bytes.length);
-        return bytes;
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static &amp;lt;K&amp;gt; Windowed&amp;lt;K&amp;gt; from(final byte[] binaryKey, final Deserializer&amp;lt;K&amp;gt; keyDeserializer, final String topic) 
{
-        final K key = extractKey(binaryKey, keyDeserializer, topic);
-        final Window window = extractWindow(binaryKey);
-        return new Windowed&amp;lt;&amp;gt;(key, window);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static Windowed&amp;lt;Bytes&amp;gt; fromBytes(Bytes bytesKey) 
{
-        final byte[] binaryKey = bytesKey.get();
-        final ByteBuffer buffer = ByteBuffer.wrap(binaryKey);
-        final long start = buffer.getLong(binaryKey.length - TIMESTAMP_SIZE);
-        final long end = buffer.getLong(binaryKey.length - 2 * TIMESTAMP_SIZE);
-        return new Windowed&amp;lt;&amp;gt;(Bytes.wrap(extractKeyBytes(binaryKey)), new SessionWindow(start, end));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;private static &amp;lt;K&amp;gt; K extractKey(final byte[] binaryKey, final Deserializer&amp;lt;K&amp;gt; deserializer, final String topic) 
{
-        return deserializer.deserialize(topic, extractKeyBytes(binaryKey));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static &amp;lt;K&amp;gt; Bytes toBinary(final Windowed&amp;lt;K&amp;gt; sessionKey, final Serializer&amp;lt;K&amp;gt; serializer, final String topic) 
{
-        final byte[] bytes = serializer.serialize(topic, sessionKey.key());
-        ByteBuffer buf = ByteBuffer.allocate(bytes.length + 2 * TIMESTAMP_SIZE);
-        buf.put(bytes);
-        buf.putLong(sessionKey.window().end());
-        buf.putLong(sessionKey.window().start());
-        return new Bytes(buf.array());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public static Bytes bytesToBinary(final Windowed&amp;lt;Bytes&amp;gt; sessionKey) 
{
-        final byte[] bytes = sessionKey.key().get();
-        ByteBuffer buf = ByteBuffer.allocate(bytes.length + 2 * TIMESTAMP_SIZE);
-        buf.put(bytes);
-        buf.putLong(sessionKey.window().end());
-        buf.putLong(sessionKey.window().start());
-        return new Bytes(buf.array());
-    }
&lt;p&gt;-}&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedDeserializer.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedDeserializer.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 67fee49bd37..00000000000&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedDeserializer.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,106 +0,0 @@&lt;br/&gt;
-/*&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements. See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to You under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License. You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.kafka.streams.kstream.internals;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.kafka.common.config.ConfigException;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
-import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.state.internals.WindowStoreUtils;&lt;br/&gt;
-&lt;br/&gt;
-import java.nio.ByteBuffer;&lt;br/&gt;
-import java.util.Map;&lt;br/&gt;
-&lt;br/&gt;
-/**&lt;/li&gt;
	&lt;li&gt;*  The inner deserializer class can be specified by setting the property key.deserializer.inner.class,&lt;/li&gt;
	&lt;li&gt;*  value.deserializer.inner.class or deserializer.inner.class,&lt;/li&gt;
	&lt;li&gt;*  if the no-arg constructor is called and hence it is not passed during initialization.&lt;/li&gt;
	&lt;li&gt;*  Note that the first two take precedence over the last.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-public class WindowedDeserializer&amp;lt;T&amp;gt; implements Deserializer&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;private static final int TIMESTAMP_SIZE = 8;&lt;/li&gt;
	&lt;li&gt;private final Long windowSize;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;private Deserializer&amp;lt;T&amp;gt; inner;&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;// Default constructor needed by Kafka&lt;/li&gt;
	&lt;li&gt;public WindowedDeserializer() 
{
-        this(null, Long.MAX_VALUE);
-    }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;public WindowedDeserializer(final Long windowSize) 
{
-       this(null, windowSize);
-    }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;public WindowedDeserializer(final Deserializer&amp;lt;T&amp;gt; inner) 
{
-        this(inner, Long.MAX_VALUE);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;public WindowedDeserializer(final Deserializer&amp;lt;T&amp;gt; inner,&lt;/li&gt;
	&lt;li&gt;final long windowSize) 
{
-        this.inner = inner;
-        this.windowSize = windowSize;
-    }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@SuppressWarnings(&quot;unchecked&quot;)&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void configure(Map&amp;lt;String, ?&amp;gt; configs, boolean isKey) {&lt;/li&gt;
	&lt;li&gt;if (inner == null) {&lt;/li&gt;
	&lt;li&gt;String propertyName = isKey ? &quot;key.deserializer.inner.class&quot; : &quot;value.deserializer.inner.class&quot;;&lt;/li&gt;
	&lt;li&gt;Object innerDeserializerClass = configs.get(propertyName);&lt;/li&gt;
	&lt;li&gt;propertyName = (innerDeserializerClass == null) ? &quot;deserializer.inner.class&quot; : propertyName;&lt;/li&gt;
	&lt;li&gt;String value = null;&lt;/li&gt;
	&lt;li&gt;try 
{
-                value = (String) configs.get(propertyName);
-                inner = Deserializer.class.cast(Utils.newInstance(value, Deserializer.class));
-                inner.configure(configs, isKey);
-            }
&lt;p&gt; catch (ClassNotFoundException e) &lt;/p&gt;
{
-                throw new ConfigException(propertyName, value, &quot;Class &quot; + value + &quot; could not be found.&quot;);
-            }&lt;br/&gt;
-        }&lt;br/&gt;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    @Override&lt;br/&gt;
-    public Windowed&amp;lt;T&amp;gt; deserialize(String topic, byte[] data) {
-
-        byte[] bytes = new byte[data.length - TIMESTAMP_SIZE];
-
-        System.arraycopy(data, 0, bytes, 0, bytes.length);
-        
-        long start = ByteBuffer.wrap(data).getLong(data.length - TIMESTAMP_SIZE);
-        
-        Window timeWindow = windowSize != Long.MAX_VALUE ? WindowStoreUtils.timeWindowForSize(start, windowSize) : new UnlimitedWindow(start);
-        return new Windowed&amp;lt;T&amp;gt;(inner.deserialize(topic, bytes), timeWindow);
-    }&lt;br/&gt;
-&lt;br/&gt;
-&lt;br/&gt;
-    @Override&lt;br/&gt;
-    public void close() {
-        inner.close();
-    }&lt;br/&gt;
-    &lt;br/&gt;
-    // Only for testing&lt;br/&gt;
-    public Deserializer&amp;lt;T&amp;gt; innerDeserializer() {
-        return inner;
-    }&lt;br/&gt;
-    &lt;br/&gt;
-    public Long getWindowSize() {
-        return this.windowSize;
-    }&lt;br/&gt;
-}&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedSerializer.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedSerializer.java&lt;br/&gt;
index b4e5d442aee..09185b2ab2f 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedSerializer.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedSerializer.java&lt;br/&gt;
@@ -16,73 +16,10 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.kstream.internals;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.kafka.common.config.ConfigException;&lt;br/&gt;
 import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
-import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
 &lt;br/&gt;
-import java.nio.ByteBuffer;&lt;br/&gt;
-import java.util.Map;&lt;br/&gt;
+public interface WindowedSerializer&amp;lt;T&amp;gt; extends Serializer&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; {&lt;br/&gt;
 &lt;br/&gt;
-/**&lt;br/&gt;
- *  The inner serializer class can be specified by setting the property key.serializer.inner.class,&lt;br/&gt;
- *  value.serializer.inner.class or serializer.inner.class,&lt;br/&gt;
- *  if the no-arg constructor is called and hence it is not passed during initialization.&lt;br/&gt;
- *  Note that the first two take precedence over the last.&lt;br/&gt;
- */&lt;br/&gt;
-public class WindowedSerializer&amp;lt;T&amp;gt; implements Serializer&amp;lt;Windowed&amp;lt;T&amp;gt;&amp;gt; {&lt;br/&gt;
-&lt;br/&gt;
-    private static final int TIMESTAMP_SIZE = 8;&lt;br/&gt;
-&lt;br/&gt;
-    private Serializer&amp;lt;T&amp;gt; inner;&lt;br/&gt;
-&lt;br/&gt;
-    public WindowedSerializer(Serializer&amp;lt;T&amp;gt; inner) {
-        this.inner = inner;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    // Default constructor needed by Kafka&lt;br/&gt;
-    public WindowedSerializer() {}&lt;br/&gt;
-&lt;br/&gt;
-    @SuppressWarnings(&quot;unchecked&quot;)&lt;br/&gt;
-    @Override&lt;br/&gt;
-    public void configure(Map&amp;lt;String, ?&amp;gt; configs, boolean isKey) {&lt;br/&gt;
-        if (inner == null) {&lt;br/&gt;
-            String propertyName = isKey ? &quot;key.serializer.inner.class&quot; : &quot;value.serializer.inner.class&quot;;&lt;br/&gt;
-            Object innerSerializerClass = configs.get(propertyName);&lt;br/&gt;
-            propertyName = (innerSerializerClass == null) ? &quot;serializer.inner.class&quot; : propertyName;&lt;br/&gt;
-            String value = null;&lt;br/&gt;
-            try {
-                value = (String) configs.get(propertyName);
-                inner = Serializer.class.cast(Utils.newInstance(value, Serializer.class));
-                inner.configure(configs, isKey);
-            } catch (ClassNotFoundException e) {-                throw new ConfigException(propertyName, value, &quot;Class &quot; + value + &quot; could not be found.&quot;);-            }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public byte[] serialize(String topic, Windowed&amp;lt;T&amp;gt; data) 
{
-        byte[] serializedKey = inner.serialize(topic, data.key());
-
-        ByteBuffer buf = ByteBuffer.allocate(serializedKey.length + TIMESTAMP_SIZE);
-        buf.put(serializedKey);
-        buf.putLong(data.window().start());
-
-        return buf.array();
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void close() 
{
-        inner.close();
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;byte[] serializeBaseKey(String topic, Windowed&amp;lt;T&amp;gt; data) 
{
-        return inner.serialize(topic, data.key());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;// Only for testing&lt;/li&gt;
	&lt;li&gt;Serializer&amp;lt;T&amp;gt; innerSerializer() 
{
-        return inner;
-    }
&lt;p&gt;+    byte[] serializeBaseKey(String topic, Windowed&amp;lt;T&amp;gt; data);&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitioner.java b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitioner.java&lt;br/&gt;
index fa1ceae39ec..7b04f6a3ff6 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitioner.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitioner.java&lt;br/&gt;
@@ -48,6 +48,4 @@ public Integer partition(final Windowed&amp;lt;K&amp;gt; windowedKey, final V value, final int&lt;br/&gt;
         // hash the keyBytes to choose a partition&lt;br/&gt;
         return toPositive(Utils.murmur2(keyBytes)) % numPartitions;&lt;br/&gt;
     }&lt;br/&gt;
-&lt;br/&gt;
-&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java&lt;br/&gt;
index 31b9d75ef8d..068ac88ffba 100644&lt;/li&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java&lt;br/&gt;
@@ -21,7 +21,6 @@&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.CacheFlushListener;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
 import org.apache.kafka.streams.processor.StateStore;&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.InternalProcessorContext;&lt;br/&gt;
@@ -141,7 +140,7 @@ public void remove(final Windowed&amp;lt;Bytes&amp;gt; sessionKey) {&lt;br/&gt;
     @Override&lt;br/&gt;
     public void put(final Windowed&amp;lt;Bytes&amp;gt; key, byte[] value) {&lt;br/&gt;
         validateStoreOpen();&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;final Bytes binaryKey = SessionKeySerde.bytesToBinary(key);&lt;br/&gt;
+        final Bytes binaryKey = Bytes.wrap(SessionKeySchema.toBinary(key));&lt;br/&gt;
         final LRUCacheEntry entry = new LRUCacheEntry(value, true, context.offset(),&lt;br/&gt;
                                                       key.window().end(), context.partition(), context.topic());&lt;br/&gt;
         cache.put(cacheName, cacheFunction.cacheKey(binaryKey), entry);&lt;br/&gt;
@@ -165,7 +164,7 @@ private void putAndMaybeForward(final ThreadCache.DirtyEntry entry, final Intern&lt;br/&gt;
         final RecordContext current = context.recordContext();&lt;br/&gt;
         context.setRecordContext(entry.recordContext());&lt;br/&gt;
         try {&lt;/li&gt;
	&lt;li&gt;final Windowed&amp;lt;K&amp;gt; key = SessionKeySerde.from(binaryKey.get(), serdes.keyDeserializer(), topic);&lt;br/&gt;
+            final Windowed&amp;lt;K&amp;gt; key = SessionKeySchema.from(binaryKey.get(), serdes.keyDeserializer(), topic);&lt;br/&gt;
             final Bytes rawKey = Bytes.wrap(serdes.rawKey(key.key()));&lt;br/&gt;
             if (flushListener != null) {&lt;br/&gt;
                 final AGG newValue = serdes.valueFrom(entry.newValue());&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java&lt;br/&gt;
index e3d0f629306..9ef41ce20c7 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java&lt;br/&gt;
@@ -35,7 +35,6 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; class CachingWindowStore&amp;lt;K, V&amp;gt; extends WrappedStateStore.AbstractStateStore implements WindowStore&amp;lt;Bytes, byte[]&amp;gt;, CachedStateStore&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; {&lt;/p&gt;

&lt;p&gt;-&lt;br/&gt;
     private final WindowStore&amp;lt;Bytes, byte[]&amp;gt; underlying;&lt;br/&gt;
     private final Serde&amp;lt;K&amp;gt; keySerde;&lt;br/&gt;
     private final Serde&amp;lt;V&amp;gt; valueSerde;&lt;br/&gt;
@@ -92,11 +91,10 @@ private void initInternal(final ProcessorContext context) {&lt;br/&gt;
             public void apply(final List&amp;lt;ThreadCache.DirtyEntry&amp;gt; entries) {&lt;br/&gt;
                 for (ThreadCache.DirtyEntry entry : entries) &lt;/p&gt;
{
                     final byte[] binaryWindowKey = cacheFunction.key(entry.key()).get();
-                    final long timestamp = WindowStoreUtils.timestampFromBinaryKey(binaryWindowKey);
+                    final long timestamp = WindowKeySchema.extractStoreTimestamp(binaryWindowKey);
 
-                    final Windowed&amp;lt;K&amp;gt; windowedKey = new Windowed&amp;lt;&amp;gt;(WindowStoreUtils.keyFromBinaryKey(binaryWindowKey, serdes),
-                            WindowStoreUtils.timeWindowForSize(timestamp, windowSize));
-                    final Bytes key = WindowStoreUtils.bytesKeyFromBinaryKey(binaryWindowKey);
+                    final Windowed&amp;lt;K&amp;gt; windowedKey = WindowKeySchema.fromStoreKey(binaryWindowKey, windowSize, serdes);
+                    final Bytes key = Bytes.wrap(WindowKeySchema.extractStoreKeyBytes(binaryWindowKey));
                     maybeForward(entry, key, windowedKey, (InternalProcessorContext) context);
                     underlying.put(key, entry.newValue(), timestamp);
                 }
&lt;p&gt;@@ -151,7 +149,7 @@ public synchronized void put(final Bytes key, final byte[] value, final long tim&lt;br/&gt;
         // if store is open outside as well.&lt;br/&gt;
         validateStoreOpen();&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Bytes keyBytes = WindowStoreUtils.toBinaryKey(key.get(), timestamp, 0);&lt;br/&gt;
+        final Bytes keyBytes = WindowKeySchema.toStoreKeyBinary(key, timestamp, 0);&lt;br/&gt;
         final LRUCacheEntry entry = new LRUCacheEntry(value, true, context.offset(),&lt;br/&gt;
                                                       timestamp, context.partition(), context.topic());&lt;br/&gt;
         cache.put(name, cacheFunction.cacheKey(keyBytes), entry);&lt;br/&gt;
@@ -160,7 +158,7 @@ public synchronized void put(final Bytes key, final byte[] value, final long tim&lt;br/&gt;
     @Override&lt;br/&gt;
     public byte[] fetch(final Bytes key, final long timestamp) {&lt;br/&gt;
         validateStoreOpen();&lt;/li&gt;
	&lt;li&gt;final Bytes bytesKey = WindowStoreUtils.toBinaryKey(key.get(), timestamp, 0);&lt;br/&gt;
+        final Bytes bytesKey = WindowKeySchema.toStoreKeyBinary(key, timestamp, 0);&lt;br/&gt;
         final Bytes cacheKey = cacheFunction.cacheKey(bytesKey);&lt;br/&gt;
         final LRUCacheEntry entry = cache.get(name, cacheKey);&lt;br/&gt;
         if (entry == null) {&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java&lt;br/&gt;
index 0fdd3e0e658..1fcf60e35e5 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingKeyValueBytesStore.java&lt;br/&gt;
@@ -16,6 +16,7 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
@@ -23,6 +24,7 @@&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.ProcessorStateManager;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueStore;&lt;br/&gt;
+import org.apache.kafka.streams.state.StateSerdes;&lt;/p&gt;

&lt;p&gt; import java.util.List;&lt;/p&gt;

&lt;p&gt;@@ -38,13 +40,8 @@&lt;br/&gt;
     @Override&lt;br/&gt;
     public void init(final ProcessorContext context, final StateStore root) {&lt;br/&gt;
         inner.init(context, root);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;this.changeLogger = new StoreChangeLogger&amp;lt;&amp;gt;(&lt;/li&gt;
	&lt;li&gt;inner.name(),&lt;/li&gt;
	&lt;li&gt;context,&lt;/li&gt;
	&lt;li&gt;WindowStoreUtils.getInnerStateSerde(&lt;/li&gt;
	&lt;li&gt;ProcessorStateManager.storeChangelogTopic(&lt;/li&gt;
	&lt;li&gt;context.applicationId(),&lt;/li&gt;
	&lt;li&gt;inner.name())));&lt;br/&gt;
+        final String topic = ProcessorStateManager.storeChangelogTopic(context.applicationId(), inner.name());&lt;br/&gt;
+        this.changeLogger = new StoreChangeLogger&amp;lt;&amp;gt;(inner.name(), context, new StateSerdes&amp;lt;&amp;gt;(topic, Serdes.Bytes(), Serdes.ByteArray()));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         // if the inner store is an LRU cache, add the eviction listener to log removed record&lt;br/&gt;
         if (inner instanceof MemoryLRUCache) {&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStore.java&lt;br/&gt;
index 12c0bc95ab5..57401aece0a 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStore.java&lt;br/&gt;
@@ -16,12 +16,12 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
+import org.apache.kafka.streams.processor.internals.ProcessorStateManager;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
 import org.apache.kafka.streams.processor.StateStore;&lt;br/&gt;
-import org.apache.kafka.streams.processor.internals.ProcessorStateManager;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
 import org.apache.kafka.streams.state.SessionStore;&lt;br/&gt;
 import org.apache.kafka.streams.state.StateSerdes;&lt;br/&gt;
@@ -34,8 +34,6 @@&lt;/p&gt;

&lt;p&gt;     private final SessionStore&amp;lt;Bytes, byte[]&amp;gt; bytesStore;&lt;br/&gt;
     private StoreChangeLogger&amp;lt;Bytes, byte[]&amp;gt; changeLogger;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private StateSerdes&amp;lt;Bytes, byte[]&amp;gt; innerStateSerde;&lt;/li&gt;
	&lt;li&gt;private String topic;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     ChangeLoggingSessionBytesStore(final SessionStore&amp;lt;Bytes, byte[]&amp;gt; bytesStore) {&lt;br/&gt;
         super(bytesStore);&lt;br/&gt;
@@ -45,15 +43,13 @@&lt;br/&gt;
     @Override&lt;br/&gt;
     public void init(final ProcessorContext context, final StateStore root) &lt;/p&gt;
{
         bytesStore.init(context, root);
-        topic = ProcessorStateManager.storeChangelogTopic(
+        final String topic = ProcessorStateManager.storeChangelogTopic(
                 context.applicationId(),
                 bytesStore.name());
-        innerStateSerde = WindowStoreUtils.getInnerStateSerde(
-                topic);
         changeLogger = new StoreChangeLogger&amp;lt;&amp;gt;(
-            name(),
-            context,
-            innerStateSerde);
+                name(),
+                context,
+                new StateSerdes&amp;lt;&amp;gt;(topic, Serdes.Bytes(), Serdes.ByteArray()));
     }


&lt;p&gt;@@ -70,13 +66,13 @@ public void init(final ProcessorContext context, final StateStore root) {&lt;br/&gt;
     @Override&lt;br/&gt;
     public void remove(final Windowed&amp;lt;Bytes&amp;gt; sessionKey) &lt;/p&gt;
{
         bytesStore.remove(sessionKey);
-        changeLogger.logChange(SessionKeySerde.toBinary(sessionKey, innerStateSerde.keySerializer(), topic), null);
+        changeLogger.logChange(Bytes.wrap(SessionKeySchema.toBinary(sessionKey)), null);
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public void put(final Windowed&amp;lt;Bytes&amp;gt; sessionKey, final byte[] aggregate) &lt;/p&gt;
{
         bytesStore.put(sessionKey, aggregate);
-        changeLogger.logChange(SessionKeySerde.bytesToBinary(sessionKey), aggregate);
+        changeLogger.logChange(Bytes.wrap(SessionKeySchema.toBinary(sessionKey)), aggregate);
 
     }

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStore.java&lt;br/&gt;
index e69a320e510..89d7260fb4f 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStore.java&lt;br/&gt;
@@ -16,6 +16,7 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
@@ -78,19 +79,18 @@ public void put(final Bytes key, final byte[] value) {&lt;br/&gt;
     @Override&lt;br/&gt;
     public void put(final Bytes key, final byte[] value, final long timestamp) &lt;/p&gt;
{
         bytesStore.put(key, value, timestamp);
-        changeLogger.logChange(WindowStoreUtils.toBinaryKey(key.get(), timestamp, maybeUpdateSeqnumForDups()), value);
+        changeLogger.logChange(WindowKeySchema.toStoreKeyBinary(key, timestamp, maybeUpdateSeqnumForDups()), value);
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public void init(final ProcessorContext context, final StateStore root) &lt;/p&gt;
{
         this.context = context;
         bytesStore.init(context, root);
-
-        final StateSerdes&amp;lt;Bytes, byte[]&amp;gt; bytesSerde = WindowStoreUtils.getInnerStateSerde(ProcessorStateManager.storeChangelogTopic(context.applicationId(), bytesStore.name()));
+        final String topic = ProcessorStateManager.storeChangelogTopic(context.applicationId(), bytesStore.name());
         changeLogger = new StoreChangeLogger&amp;lt;&amp;gt;(
             name(),
             context,
-            bytesSerde);
+            new StateSerdes&amp;lt;&amp;gt;(topic, Serdes.Bytes(), Serdes.ByteArray()));
     }

&lt;p&gt;     private int maybeUpdateSeqnumForDups() {&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheSessionStoreIterator.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheSessionStoreIterator.java&lt;br/&gt;
index ce894bc41cc..01b577cf95f 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheSessionStoreIterator.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheSessionStoreIterator.java&lt;br/&gt;
@@ -20,7 +20,6 @@&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;/p&gt;

&lt;p&gt; /**&lt;br/&gt;
@@ -46,8 +45,8 @@&lt;br/&gt;
     @Override&lt;br/&gt;
     Windowed&amp;lt;Bytes&amp;gt; deserializeCacheKey(final Bytes cacheKey) &lt;/p&gt;
{
         final byte[] binaryKey = cacheFunction.key(cacheKey).get();
-        final byte[] keyBytes = SessionKeySerde.extractKeyBytes(binaryKey);
-        final Window window = SessionKeySerde.extractWindow(binaryKey);
+        final byte[] keyBytes = SessionKeySchema.extractKeyBytes(binaryKey);
+        final Window window = SessionKeySchema.extractWindow(binaryKey);
         return new Windowed&amp;lt;&amp;gt;(Bytes.wrap(keyBytes), window);
     }

&lt;p&gt;@@ -64,7 +63,7 @@&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     public int compare(final Bytes cacheKey, final Windowed&amp;lt;Bytes&amp;gt; storeKey) &lt;/p&gt;
{
-        Bytes storeKeyBytes = SessionKeySerde.bytesToBinary(storeKey);
+        final Bytes storeKeyBytes = Bytes.wrap(SessionKeySchema.toBinary(storeKey));
         return cacheFunction.compareSegmentedKeys(cacheKey, storeKeyBytes);
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreIterator.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreIterator.java&lt;br/&gt;
index 6eadded899b..b08cf851e1a 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreIterator.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreIterator.java&lt;br/&gt;
@@ -43,7 +43,7 @@&lt;br/&gt;
     @Override&lt;br/&gt;
     Long deserializeCacheKey(final Bytes cacheKey) &lt;/p&gt;
{
         byte[] binaryKey = bytesFromCacheKey(cacheKey);
-        return WindowStoreUtils.timestampFromBinaryKey(binaryKey);
+        return WindowKeySchema.extractStoreTimestamp(binaryKey);
     }

&lt;p&gt;     @Override&lt;br/&gt;
@@ -60,7 +60,7 @@ public Long deserializeStoreKey(final Long key) {&lt;br/&gt;
     public int compare(final Bytes cacheKey, final Long storeKey) &lt;/p&gt;
{
         byte[] binaryKey = bytesFromCacheKey(cacheKey);
 
-        final Long cacheTimestamp = WindowStoreUtils.timestampFromBinaryKey(binaryKey);
+        final Long cacheTimestamp = WindowKeySchema.extractStoreTimestamp(binaryKey);
         return cacheTimestamp.compareTo(storeKey);
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreKeyValueIterator.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreKeyValueIterator.java&lt;br/&gt;
index 7b1fe17020e..ef0a44e3128 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreKeyValueIterator.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWindowStoreKeyValueIterator.java&lt;br/&gt;
@@ -55,11 +55,8 @@&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     Windowed&amp;lt;Bytes&amp;gt; deserializeCacheKey(final Bytes cacheKey) &lt;/p&gt;
{
-        byte[] binaryKey = cacheFunction.key(cacheKey).get();
-
-        final long timestamp = WindowStoreUtils.timestampFromBinaryKey(binaryKey);
-        final Bytes key = WindowStoreUtils.keyFromBinaryKey(binaryKey, serdes);
-        return new Windowed&amp;lt;&amp;gt;(key, WindowStoreUtils.timeWindowForSize(timestamp, windowSize));
+        final byte[] binaryKey = cacheFunction.key(cacheKey).get();
+        return WindowKeySchema.fromStoreKey(binaryKey, windowSize, serdes);
     }

&lt;p&gt;     @Override&lt;br/&gt;
@@ -69,7 +66,7 @@&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     int compare(final Bytes cacheKey, final Windowed&amp;lt;Bytes&amp;gt; storeKey) &lt;/p&gt;
{
-        Bytes storeKeyBytes = WindowStoreUtils.toBinaryKey(storeKey.key().get(), storeKey.window().start(), 0);
+        final Bytes storeKeyBytes = WindowKeySchema.toStoreKeyBinary(storeKey.key(), storeKey.window().start(), 0);
         return cacheFunction.compareSegmentedKeys(cacheKey, storeKeyBytes);
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/OrderedBytes.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/OrderedBytes.java&lt;br/&gt;
index ace24872533..c0d1c3b02b8 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/OrderedBytes.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/OrderedBytes.java&lt;br/&gt;
@@ -57,7 +57,7 @@ static Bytes lowerRange(Bytes key, byte[] minSuffix) {&lt;/p&gt;

&lt;p&gt;         // unless there is a maximum key length, you can keep appending more zero bytes&lt;br/&gt;
         // to keyFrom to create a key that will match the range, yet that would precede&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// WindowStoreUtils.toBinaryKey(keyFrom, from, 0) in byte order&lt;br/&gt;
+        // KeySchema.toBinaryKey(keyFrom, from, 0) in byte order&lt;br/&gt;
         return Bytes.wrap(&lt;br/&gt;
             rangeStart&lt;br/&gt;
                 .put(bytes)&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBSessionStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBSessionStore.java&lt;br/&gt;
index c9267dc8fda..f902cba35fe 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBSessionStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBSessionStore.java&lt;br/&gt;
@@ -19,7 +19,6 @@&lt;br/&gt;
 import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
 import org.apache.kafka.streams.processor.StateStore;&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.ProcessorStateManager;&lt;br/&gt;
@@ -32,10 +31,10 @@&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private final Serde&amp;lt;K&amp;gt; keySerde;&lt;br/&gt;
     private final Serde&amp;lt;AGG&amp;gt; aggSerde;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected final SegmentedBytesStore bytesStore;&lt;br/&gt;
+    private final SegmentedBytesStore bytesStore;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected StateSerdes&amp;lt;K, AGG&amp;gt; serdes;&lt;/li&gt;
	&lt;li&gt;protected String topic;&lt;br/&gt;
+    private StateSerdes&amp;lt;K, AGG&amp;gt; serdes;&lt;br/&gt;
+    private String topic;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     RocksDBSessionStore(final SegmentedBytesStore bytesStore,&lt;br/&gt;
                         final Serde&amp;lt;K&amp;gt; keySerde,&lt;br/&gt;
@@ -86,11 +85,11 @@ public void init(final ProcessorContext context, final StateStore root) {&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     public void remove(final Windowed&amp;lt;K&amp;gt; key) &lt;/p&gt;
{
-        bytesStore.remove(SessionKeySerde.toBinary(key, serdes.keySerializer(), topic));
+        bytesStore.remove(Bytes.wrap(SessionKeySchema.toBinary(key, serdes.keySerializer(), topic)));
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public void put(final Windowed&amp;lt;K&amp;gt; sessionKey, final AGG aggregate) &lt;/p&gt;
{
-        bytesStore.put(SessionKeySerde.toBinary(sessionKey, serdes.keySerializer(), topic), serdes.rawValue(aggregate));
+        bytesStore.put(Bytes.wrap(SessionKeySchema.toBinary(sessionKey, serdes.keySerializer(), topic)), serdes.rawValue(aggregate));
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBWindowStore.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBWindowStore.java&lt;br/&gt;
index 732f3d62a42..a9af36d3679 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBWindowStore.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBWindowStore.java&lt;br/&gt;
@@ -17,7 +17,6 @@&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/p&gt;

&lt;p&gt; import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
 import org.apache.kafka.streams.processor.ProcessorContext;&lt;br/&gt;
@@ -30,45 +29,15 @@&lt;/p&gt;

&lt;p&gt; public class RocksDBWindowStore&amp;lt;K, V&amp;gt; extends WrappedStateStore.AbstractStateStore implements WindowStore&amp;lt;K, V&amp;gt; {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// this is optimizing the case when this store is already a bytes store, in which we can avoid Bytes.wrap() costs&lt;/li&gt;
	&lt;li&gt;private static class RocksDBWindowBytesStore extends RocksDBWindowStore&amp;lt;Bytes, byte[]&amp;gt; {&lt;/li&gt;
	&lt;li&gt;RocksDBWindowBytesStore(final SegmentedBytesStore inner, final boolean retainDuplicates, final long windowSize) 
{
-            super(inner, Serdes.Bytes(), Serdes.ByteArray(), retainDuplicates, windowSize);
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public void put(Bytes key, byte[] value, long timestamp) 
{
-            maybeUpdateSeqnumForDups();
-
-            bytesStore.put(WindowStoreUtils.toBinaryKey(key.get(), timestamp, seqnum), value);
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public WindowStoreIterator&amp;lt;byte[]&amp;gt; fetch(Bytes key, long timeFrom, long timeTo) 
{
-            final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator = bytesStore.fetch(key, timeFrom, timeTo);
-            return WindowStoreIteratorWrapper.bytesIterator(bytesIterator, serdes, windowSize).valuesIterator();
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public KeyValueIterator&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt; fetch(Bytes from, Bytes to, long timeFrom, long timeTo) 
{
-            final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator = bytesStore.fetch(from, to, timeFrom, timeTo);
-            return WindowStoreIteratorWrapper.bytesIterator(bytesIterator, serdes, windowSize).keyValueIterator();
-        }&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;static RocksDBWindowStore&amp;lt;Bytes, byte[]&amp;gt; bytesStore(final SegmentedBytesStore inner, final boolean retainDuplicates, final long windowSize) 
{
-        return new RocksDBWindowBytesStore(inner, retainDuplicates, windowSize);
-    }
&lt;p&gt;-&lt;br/&gt;
     private final Serde&amp;lt;K&amp;gt; keySerde;&lt;br/&gt;
     private final Serde&amp;lt;V&amp;gt; valueSerde;&lt;br/&gt;
     private final boolean retainDuplicates;&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected final long windowSize;&lt;/li&gt;
	&lt;li&gt;protected final SegmentedBytesStore bytesStore;&lt;br/&gt;
+    private final long windowSize;&lt;br/&gt;
+    private final SegmentedBytesStore bytesStore;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private ProcessorContext context;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;protected StateSerdes&amp;lt;K, V&amp;gt; serdes;&lt;/li&gt;
	&lt;li&gt;protected int seqnum = 0;&lt;br/&gt;
+    private StateSerdes&amp;lt;K, V&amp;gt; serdes;&lt;br/&gt;
+    private int seqnum = 0;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     RocksDBWindowStore(final SegmentedBytesStore bytesStore,&lt;br/&gt;
                        final Serde&amp;lt;K&amp;gt; keySerde,&lt;br/&gt;
@@ -104,12 +73,12 @@ public void put(final K key, final V value) {&lt;br/&gt;
     public void put(final K key, final V value, final long timestamp) &lt;/p&gt;
{
         maybeUpdateSeqnumForDups();
 
-        bytesStore.put(WindowStoreUtils.toBinaryKey(key, timestamp, seqnum, serdes), serdes.rawValue(value));
+        bytesStore.put(WindowKeySchema.toStoreKeyBinary(key, timestamp, seqnum, serdes), serdes.rawValue(value));
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public V fetch(final K key, final long timestamp) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final byte[] bytesValue = bytesStore.get(WindowStoreUtils.toBinaryKey(key, timestamp, seqnum, serdes));&lt;br/&gt;
+        final byte[] bytesValue = bytesStore.get(WindowKeySchema.toStoreKeyBinary(key, timestamp, seqnum, serdes));&lt;br/&gt;
         if (bytesValue == null) 
{
             return null;
         }
&lt;p&gt;@@ -127,7 +96,7 @@ public V fetch(final K key, final long timestamp) &lt;/p&gt;
{
         final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator = bytesStore.fetch(Bytes.wrap(serdes.rawKey(from)), Bytes.wrap(serdes.rawKey(to)), timeFrom, timeTo);
         return new WindowStoreIteratorWrapper&amp;lt;&amp;gt;(bytesIterator, serdes, windowSize).keyValueIterator();
     }&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
     @Override&lt;br/&gt;
     public KeyValueIterator&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; all() {&lt;br/&gt;
         final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator = bytesStore.all();&lt;br/&gt;
@@ -140,7 +109,7 @@ public V fetch(final K key, final long timestamp) &lt;/p&gt;
{
         return new WindowStoreIteratorWrapper&amp;lt;&amp;gt;(bytesIterator, serdes, windowSize).keyValueIterator();
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;void maybeUpdateSeqnumForDups() {&lt;br/&gt;
+    private void maybeUpdateSeqnumForDups() {&lt;br/&gt;
         if (retainDuplicates) 
{
             seqnum = (seqnum + 1) &amp;amp; 0x7FFFFFFF;
         }
&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbWindowBytesStoreSupplier.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbWindowBytesStoreSupplier.java&lt;br/&gt;
index e873435f1ca..e1521f8438c 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbWindowBytesStoreSupplier.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbWindowBytesStoreSupplier.java&lt;br/&gt;
@@ -16,6 +16,7 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.state.WindowBytesStoreSupplier;&lt;br/&gt;
 import org.apache.kafka.streams.state.WindowStore;&lt;br/&gt;
@@ -56,9 +57,11 @@ public String name() &lt;/p&gt;
{
                 segments,
                 new WindowKeySchema()
         );
-        return RocksDBWindowStore.bytesStore(segmentedBytesStore,
-                                             retainDuplicates,
-                                             windowSize);
+        return new RocksDBWindowStore&amp;lt;&amp;gt;(segmentedBytesStore,
+                Serdes.Bytes(),
+                Serdes.ByteArray(),
+                retainDuplicates,
+                windowSize);
 
     }

&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/SessionKeySchema.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/SessionKeySchema.java&lt;br/&gt;
index e3dd5530999..181d409f9b5 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/SessionKeySchema.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/SessionKeySchema.java&lt;br/&gt;
@@ -16,10 +16,13 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
 import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.SessionWindow;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;/p&gt;

&lt;p&gt;@@ -27,12 +30,14 @@&lt;br/&gt;
 import java.util.List;&lt;/p&gt;


&lt;p&gt;-class SessionKeySchema implements SegmentedBytesStore.KeySchema {&lt;br/&gt;
+public class SessionKeySchema implements SegmentedBytesStore.KeySchema {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int SUFFIX_SIZE = 2 * WindowStoreUtils.TIMESTAMP_SIZE;&lt;br/&gt;
+    private static final int TIMESTAMP_SIZE = 8;&lt;br/&gt;
+    private static final int SUFFIX_SIZE = 2 * TIMESTAMP_SIZE;&lt;br/&gt;
     private static final byte[] MIN_SUFFIX = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;SUFFIX_SIZE&amp;#93;&lt;/span&gt;;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private String topic;&lt;br/&gt;
+    private final Serde&amp;lt;Bytes&amp;gt; bytesSerdes = Serdes.Bytes();&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     public void init(final String topic) {&lt;br/&gt;
@@ -42,13 +47,13 @@ public void init(final String topic) {&lt;br/&gt;
     @Override&lt;br/&gt;
     public Bytes upperRangeFixedSize(final Bytes key, final long to) &lt;/p&gt;
{
         final Windowed&amp;lt;Bytes&amp;gt; sessionKey = new Windowed&amp;lt;&amp;gt;(key, new SessionWindow(to, Long.MAX_VALUE));
-        return SessionKeySerde.toBinary(sessionKey, Serdes.Bytes().serializer(), topic);
+        return Bytes.wrap(SessionKeySchema.toBinary(sessionKey, bytesSerdes.serializer(), topic));
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public Bytes lowerRangeFixedSize(final Bytes key, final long from) &lt;/p&gt;
{
         final Windowed&amp;lt;Bytes&amp;gt; sessionKey = new Windowed&amp;lt;&amp;gt;(key, new SessionWindow(0, Math.max(0, from)));
-        return SessionKeySerde.toBinary(sessionKey, Serdes.Bytes().serializer(), topic);
+        return Bytes.wrap(SessionKeySchema.toBinary(sessionKey, bytesSerdes.serializer(), topic));
     }

&lt;p&gt;     @Override&lt;br/&gt;
@@ -68,7 +73,7 @@ public Bytes lowerRange(Bytes key, long from) {&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     public long segmentTimestamp(final Bytes key) &lt;/p&gt;
{
-        return SessionKeySerde.extractEnd(key.get());
+        return SessionKeySchema.extractEndTimestamp(key.get());
     }

&lt;p&gt;     @Override&lt;br/&gt;
@@ -78,7 +83,7 @@ public HasNextCondition hasNextCondition(final Bytes binaryKeyFrom, final Bytes&lt;br/&gt;
             public boolean hasNext(final KeyValueIterator&amp;lt;Bytes, ?&amp;gt; iterator) {&lt;br/&gt;
                 while (iterator.hasNext()) {&lt;br/&gt;
                     final Bytes bytes = iterator.peekNextKey();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Windowed&amp;lt;Bytes&amp;gt; windowedKey = SessionKeySerde.fromBytes(bytes);&lt;br/&gt;
+                    final Windowed&amp;lt;Bytes&amp;gt; windowedKey = SessionKeySchema.from(bytes);&lt;br/&gt;
                     if ((binaryKeyFrom == null || windowedKey.key().compareTo(binaryKeyFrom) &amp;gt;= 0)&lt;br/&gt;
                         &amp;amp;&amp;amp; (binaryKeyTo == null || windowedKey.key().compareTo(binaryKeyTo) &amp;lt;= 0)&lt;br/&gt;
                         &amp;amp;&amp;amp; windowedKey.window().end() &amp;gt;= from&lt;br/&gt;
@@ -93,7 +98,70 @@ public boolean hasNext(final KeyValueIterator&amp;lt;Bytes, ?&amp;gt; iterator) {&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public List&amp;lt;Segment&amp;gt; segmentsToSearch(final Segments segments, final long from, final long to) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+    public List&amp;lt;Segment&amp;gt; segmentsToSearch(final Segments segments,+                                          final long from,+                                          final long to) {
         return segments.segments(from, Long.MAX_VALUE);
     }++    private static &amp;lt;K&amp;gt; K extractKey(final byte[] binaryKey,+                                    final Deserializer&amp;lt;K&amp;gt; deserializer,+                                    final String topic) {
+        return deserializer.deserialize(topic, extractKeyBytes(binaryKey));
+    }++    public static byte[] extractKeyBytes(final byte[] binaryKey) {
+        final byte[] bytes = new byte[binaryKey.length - 2 * TIMESTAMP_SIZE];
+        System.arraycopy(binaryKey, 0, bytes, 0, bytes.length);
+        return bytes;
+    }++    public static long extractEndTimestamp(final byte[] binaryKey) {
+        return ByteBuffer.wrap(binaryKey).getLong(binaryKey.length - 2 * TIMESTAMP_SIZE);
+    }++    public static long extractStartTimestamp(final byte[] binaryKey) {
+        return ByteBuffer.wrap(binaryKey).getLong(binaryKey.length - TIMESTAMP_SIZE);
+    }++    public static Window extractWindow(final byte[] binaryKey) {
+        final ByteBuffer buffer = ByteBuffer.wrap(binaryKey);
+        final long start = buffer.getLong(binaryKey.length - TIMESTAMP_SIZE);
+        final long end = buffer.getLong(binaryKey.length - 2 * TIMESTAMP_SIZE);
+        return new SessionWindow(start, end);
+    }++    public static &amp;lt;K&amp;gt; Windowed&amp;lt;K&amp;gt; from(final byte[] binaryKey,+                                       final Deserializer&amp;lt;K&amp;gt; keyDeserializer,+                                       final String topic) {
+        final K key = extractKey(binaryKey, keyDeserializer, topic);
+        final Window window = extractWindow(binaryKey);
+        return new Windowed&amp;lt;&amp;gt;(key, window);
+    }++    public static Windowed&amp;lt;Bytes&amp;gt; from(final Bytes bytesKey) {
+        final byte[] binaryKey = bytesKey.get();
+        final Window window = extractWindow(binaryKey);
+        return new Windowed&amp;lt;&amp;gt;(Bytes.wrap(extractKeyBytes(binaryKey)), window);
+    }++    public static &amp;lt;K&amp;gt; byte[] toBinary(final Windowed&amp;lt;K&amp;gt; sessionKey,+                                      final Serializer&amp;lt;K&amp;gt; serializer,+                                      final String topic) {
+        final byte[] bytes = serializer.serialize(topic, sessionKey.key());
+        final ByteBuffer buf = ByteBuffer.allocate(bytes.length + 2 * TIMESTAMP_SIZE);
+        buf.put(bytes);
+        buf.putLong(sessionKey.window().end());
+        buf.putLong(sessionKey.window().start());
+        return buf.array();
+    }++    public static byte[] toBinary(final Windowed&amp;lt;Bytes&amp;gt; sessionKey) {
+        final byte[] bytes = sessionKey.key().get();
+        final ByteBuffer buf = ByteBuffer.allocate(bytes.length + 2 * TIMESTAMP_SIZE);
+        buf.put(bytes);
+        buf.putLong(sessionKey.window().end());
+        buf.putLong(sessionKey.window().start());
+        return buf.array();
+    } }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/StoreChangeLogger.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/StoreChangeLogger.java&lt;br/&gt;
index 1e217fa4370..1055df56534 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/state/internals/StoreChangeLogger.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/StoreChangeLogger.java&lt;br/&gt;
@@ -39,7 +39,6 @@&lt;br/&gt;
     private final ProcessorContext context;&lt;br/&gt;
     private final RecordCollector collector;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;-&lt;br/&gt;
     StoreChangeLogger(String storeName, ProcessorContext context, StateSerdes&amp;lt;K, V&amp;gt; serialization) &lt;/p&gt;
{
         this(storeName, context, context.taskId().partition, serialization);
     }
&lt;p&gt;@@ -59,5 +58,4 @@ void logChange(final K key, final V value) &lt;/p&gt;
{
             collector.send(this.topic, key, value, this.partition, context.timestamp(), keySerializer, valueSerializer);
         }
&lt;p&gt;     }&lt;br/&gt;
-&lt;br/&gt;
 }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowKeySchema.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowKeySchema.java&lt;br/&gt;
index e432baad691..3c59cd6863f 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowKeySchema.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowKeySchema.java&lt;br/&gt;
@@ -16,15 +16,23 @@&lt;br/&gt;
  */&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.internals.TimeWindow;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
+import org.apache.kafka.streams.state.StateSerdes;&lt;/p&gt;

&lt;p&gt; import java.nio.ByteBuffer;&lt;br/&gt;
 import java.util.List;&lt;/p&gt;

&lt;p&gt;-class WindowKeySchema implements RocksDBSegmentedBytesStore.KeySchema {&lt;br/&gt;
+public class WindowKeySchema implements RocksDBSegmentedBytesStore.KeySchema {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final int SUFFIX_SIZE = WindowStoreUtils.TIMESTAMP_SIZE + WindowStoreUtils.SEQNUM_SIZE;&lt;br/&gt;
+    private static final int SEQNUM_SIZE = 4;&lt;br/&gt;
+    private static final int TIMESTAMP_SIZE = 8;&lt;br/&gt;
+    private static final int SUFFIX_SIZE = TIMESTAMP_SIZE + SEQNUM_SIZE;&lt;br/&gt;
     private static final byte[] MIN_SUFFIX = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;SUFFIX_SIZE&amp;#93;&lt;/span&gt;;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Override&lt;br/&gt;
@@ -49,17 +57,17 @@ public Bytes lowerRange(final Bytes key, final long from) {&lt;/p&gt;

&lt;p&gt;     @Override&lt;br/&gt;
     public Bytes lowerRangeFixedSize(final Bytes key, final long from) &lt;/p&gt;
{
-        return WindowStoreUtils.toBinaryKey(key.get(), Math.max(0, from), 0);
+        return WindowKeySchema.toStoreKeyBinary(key, Math.max(0, from), 0);
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public Bytes upperRangeFixedSize(final Bytes key, final long to) &lt;/p&gt;
{
-        return WindowStoreUtils.toBinaryKey(key.get(), to, Integer.MAX_VALUE);
+        return WindowKeySchema.toStoreKeyBinary(key, to, Integer.MAX_VALUE);
     }

&lt;p&gt;     @Override&lt;br/&gt;
     public long segmentTimestamp(final Bytes key) &lt;/p&gt;
{
-        return WindowStoreUtils.timestampFromBinaryKey(key.get());
+        return WindowKeySchema.extractStoreTimestamp(key.get());
     }

&lt;p&gt;     @Override&lt;br/&gt;
@@ -69,8 +77,8 @@ public HasNextCondition hasNextCondition(final Bytes binaryKeyFrom, final Bytes&lt;br/&gt;
             public boolean hasNext(final KeyValueIterator&amp;lt;Bytes, ?&amp;gt; iterator) {&lt;br/&gt;
                 while (iterator.hasNext()) {&lt;br/&gt;
                     final Bytes bytes = iterator.peekNextKey();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Bytes keyBytes = WindowStoreUtils.bytesKeyFromBinaryKey(bytes.get());&lt;/li&gt;
	&lt;li&gt;final long time = WindowStoreUtils.timestampFromBinaryKey(bytes.get());&lt;br/&gt;
+                    final Bytes keyBytes = Bytes.wrap(WindowKeySchema.extractStoreKeyBytes(bytes.get()));&lt;br/&gt;
+                    final long time = WindowKeySchema.extractStoreTimestamp(bytes.get());&lt;br/&gt;
                     if ((binaryKeyFrom == null || keyBytes.compareTo(binaryKeyFrom) &amp;gt;= 0)&lt;br/&gt;
                         &amp;amp;&amp;amp; (binaryKeyTo == null || keyBytes.compareTo(binaryKeyTo) &amp;lt;= 0)&lt;br/&gt;
                         &amp;amp;&amp;amp; time &amp;gt;= from&lt;br/&gt;
@@ -89,4 +97,129 @@ public boolean hasNext(final KeyValueIterator&amp;lt;Bytes, ?&amp;gt; iterator) 
{
         return segments.segments(from, to);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+    /**&lt;br/&gt;
+     * Safely construct a time window of the given size,&lt;br/&gt;
+     * taking care of bounding endMs to Long.MAX_VALUE if necessary&lt;br/&gt;
+     */&lt;br/&gt;
+    public static TimeWindow timeWindowForSize(final long startMs,&lt;br/&gt;
+                                               final long windowSize) &lt;/p&gt;
{
+        final long endMs = startMs + windowSize;
+        return new TimeWindow(startMs, endMs &amp;lt; 0 ? Long.MAX_VALUE : endMs);
+    }
&lt;p&gt;+&lt;br/&gt;
+    // for pipe serdes&lt;br/&gt;
+&lt;br/&gt;
+    public static &amp;lt;K&amp;gt; byte[] toBinary(final Windowed&amp;lt;K&amp;gt; timeKey,&lt;br/&gt;
+                                      final Serializer&amp;lt;K&amp;gt; serializer,&lt;br/&gt;
+                                      final String topic) &lt;/p&gt;
{
+        final byte[] bytes = serializer.serialize(topic, timeKey.key());
+        final ByteBuffer buf = ByteBuffer.allocate(bytes.length + TIMESTAMP_SIZE);
+        buf.put(bytes);
+        buf.putLong(timeKey.window().start());
+
+        return buf.array();
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static &amp;lt;K&amp;gt; Windowed&amp;lt;K&amp;gt; from(final byte[] binaryKey,&lt;br/&gt;
+                                       final long windowSize,&lt;br/&gt;
+                                       final Deserializer&amp;lt;K&amp;gt; deserializer,&lt;br/&gt;
+                                       final String topic) &lt;/p&gt;
{
+        final byte[] bytes = new byte[binaryKey.length - TIMESTAMP_SIZE];
+        System.arraycopy(binaryKey, 0, bytes, 0, bytes.length);
+        final K key = deserializer.deserialize(topic, bytes);
+        final Window window = extractWindow(binaryKey, windowSize);
+        return new Windowed&amp;lt;&amp;gt;(key, window);
+    }
&lt;p&gt;+&lt;br/&gt;
+    private static Window extractWindow(final byte[] binaryKey,&lt;br/&gt;
+                                        final long windowSize) &lt;/p&gt;
{
+        final ByteBuffer buffer = ByteBuffer.wrap(binaryKey);
+        final long start = buffer.getLong(binaryKey.length - TIMESTAMP_SIZE);
+        return timeWindowForSize(start, windowSize);
+    }
&lt;p&gt;+&lt;br/&gt;
+    // for store serdes&lt;br/&gt;
+&lt;br/&gt;
+    public static Bytes toStoreKeyBinary(final Bytes key,&lt;br/&gt;
+                                         final long timestamp,&lt;br/&gt;
+                                         final int seqnum) &lt;/p&gt;
{
+        final byte[] serializedKey = key.get();
+        return toStoreKeyBinary(serializedKey, timestamp, seqnum);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static &amp;lt;K&amp;gt; Bytes toStoreKeyBinary(final K key,&lt;br/&gt;
+                                             final long timestamp,&lt;br/&gt;
+                                             final int seqnum,&lt;br/&gt;
+                                             final StateSerdes&amp;lt;K, ?&amp;gt; serdes) &lt;/p&gt;
{
+        final byte[] serializedKey = serdes.rawKey(key);
+        return toStoreKeyBinary(serializedKey, timestamp, seqnum);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static Bytes toStoreKeyBinary(final Windowed&amp;lt;Bytes&amp;gt; timeKey,&lt;br/&gt;
+                                         final int seqnum) &lt;/p&gt;
{
+        final byte[] bytes = timeKey.key().get();
+        return toStoreKeyBinary(bytes, timeKey.window().start(), seqnum);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static &amp;lt;K&amp;gt; Bytes toStoreKeyBinary(final Windowed&amp;lt;K&amp;gt; timeKey,&lt;br/&gt;
+                                             final int seqnum,&lt;br/&gt;
+                                             final StateSerdes&amp;lt;K, ?&amp;gt; serdes) &lt;/p&gt;
{
+        final byte[] serializedKey = serdes.rawKey(timeKey.key());
+        return toStoreKeyBinary(serializedKey, timeKey.window().start(), seqnum);
+    }
&lt;p&gt;+&lt;br/&gt;
+    // package private for testing&lt;br/&gt;
+    static Bytes toStoreKeyBinary(final byte[] serializedKey,&lt;br/&gt;
+                                  final long timestamp,&lt;br/&gt;
+                                  final int seqnum) &lt;/p&gt;
{
+        final ByteBuffer buf = ByteBuffer.allocate(serializedKey.length + TIMESTAMP_SIZE + SEQNUM_SIZE);
+        buf.put(serializedKey);
+        buf.putLong(timestamp);
+        buf.putInt(seqnum);
+
+        return Bytes.wrap(buf.array());
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static byte[] extractStoreKeyBytes(final byte[] binaryKey) &lt;/p&gt;
{
+        final byte[] bytes = new byte[binaryKey.length - TIMESTAMP_SIZE - SEQNUM_SIZE];
+        System.arraycopy(binaryKey, 0, bytes, 0, bytes.length);
+        return bytes;
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static &amp;lt;K&amp;gt; K extractStoreKey(final byte[] binaryKey,&lt;br/&gt;
+                                        final StateSerdes&amp;lt;K, ?&amp;gt; serdes) &lt;/p&gt;
{
+        final byte[] bytes = new byte[binaryKey.length - TIMESTAMP_SIZE - SEQNUM_SIZE];
+        System.arraycopy(binaryKey, 0, bytes, 0, bytes.length);
+        return serdes.keyFrom(bytes);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static long extractStoreTimestamp(final byte[] binaryKey) &lt;/p&gt;
{
+        return ByteBuffer.wrap(binaryKey).getLong(binaryKey.length - TIMESTAMP_SIZE - SEQNUM_SIZE);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static int extractStoreSequence(final byte[] binaryKey) &lt;/p&gt;
{
+        return ByteBuffer.wrap(binaryKey).getInt(binaryKey.length - SEQNUM_SIZE);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static &amp;lt;K&amp;gt; Windowed&amp;lt;K&amp;gt; fromStoreKey(final byte[] binaryKey,&lt;br/&gt;
+                                               final long windowSize,&lt;br/&gt;
+                                               final StateSerdes&amp;lt;K, ?&amp;gt; serdes) &lt;/p&gt;
{
+        final K key = serdes.keyDeserializer().deserialize(serdes.topic(), extractStoreKeyBytes(binaryKey));
+        final Window window = extractStoreWindow(binaryKey, windowSize);
+        return new Windowed&amp;lt;&amp;gt;(key, window);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static Windowed&amp;lt;Bytes&amp;gt; fromStoreKey(final byte[] binaryKey,&lt;br/&gt;
+                                               final long windowSize) &lt;/p&gt;
{
+        final Bytes key = Bytes.wrap(extractStoreKeyBytes(binaryKey));
+        final Window window = extractStoreWindow(binaryKey, windowSize);
+        return new Windowed&amp;lt;&amp;gt;(key, window);
+    }
&lt;p&gt;+&lt;br/&gt;
+    public static Window extractStoreWindow(final byte[] binaryKey,&lt;br/&gt;
+                                            final long windowSize) &lt;/p&gt;
{
+        final ByteBuffer buffer = ByteBuffer.wrap(binaryKey);
+        final long start = buffer.getLong(binaryKey.length - TIMESTAMP_SIZE - SEQNUM_SIZE);
+        return timeWindowForSize(start, windowSize);
+    }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowStoreIteratorWrapper.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowStoreIteratorWrapper.java&lt;br/&gt;
index 4cb85d6d760..e83e6e61ae7 100644&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowStoreIteratorWrapper.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowStoreIteratorWrapper.java&lt;br/&gt;
@@ -23,75 +23,15 @@&lt;br/&gt;
 import org.apache.kafka.streams.state.StateSerdes;&lt;br/&gt;
 import org.apache.kafka.streams.state.WindowStoreIterator;&lt;/p&gt;

&lt;p&gt;-import java.util.NoSuchElementException;&lt;br/&gt;
-&lt;br/&gt;
 class WindowStoreIteratorWrapper&amp;lt;K, V&amp;gt; {&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// this is optimizing the case when underlying is already a bytes store iterator, in which we can avoid Bytes.wrap() costs&lt;/li&gt;
	&lt;li&gt;private static class WrappedWindowStoreBytesIterator extends WindowStoreIteratorWrapper&amp;lt;Bytes, byte[]&amp;gt; {&lt;/li&gt;
	&lt;li&gt;WrappedWindowStoreBytesIterator(final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; underlying,&lt;/li&gt;
	&lt;li&gt;final StateSerdes&amp;lt;Bytes, byte[]&amp;gt; serdes,&lt;/li&gt;
	&lt;li&gt;final long windowSize) 
{
-            super(underlying, serdes, windowSize);
-        }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public WindowStoreIterator&amp;lt;byte[]&amp;gt; valuesIterator() {&lt;/li&gt;
	&lt;li&gt;return new WrappedWindowStoreIterator&amp;lt;byte[]&amp;gt;(bytesIterator, serdes) {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public KeyValue&amp;lt;Long, byte[]&amp;gt; next() 
{
-                    final KeyValue&amp;lt;Bytes, byte[]&amp;gt; next = bytesIterator.next();
-                    final long timestamp = WindowStoreUtils.timestampFromBinaryKey(next.key.get());
-                    return KeyValue.pair(timestamp, next.value);
-                }&lt;/li&gt;
	&lt;li&gt;};&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public KeyValueIterator&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt; keyValueIterator() {&lt;/li&gt;
	&lt;li&gt;return new WrappedKeyValueIterator&amp;lt;Bytes, byte[]&amp;gt;(bytesIterator, serdes, windowSize) {&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public Windowed&amp;lt;Bytes&amp;gt; peekNextKey() 
{
-                    final Bytes next = bytesIterator.peekNextKey();
-                    final long timestamp = WindowStoreUtils.timestampFromBinaryKey(next.get());
-                    final Bytes key = WindowStoreUtils.bytesKeyFromBinaryKey(next.get());
-                    return new Windowed&amp;lt;&amp;gt;(key, WindowStoreUtils.timeWindowForSize(timestamp, windowSize));
-                }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Override&lt;/li&gt;
	&lt;li&gt;public KeyValue&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt; next() {&lt;/li&gt;
	&lt;li&gt;if (!bytesIterator.hasNext()) 
{
-                        throw new NoSuchElementException();
-                    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final KeyValue&amp;lt;Bytes, byte[]&amp;gt; next = bytesIterator.next();&lt;/li&gt;
	&lt;li&gt;final long timestamp = WindowStoreUtils.timestampFromBinaryKey(next.key.get());&lt;/li&gt;
	&lt;li&gt;final Bytes key = WindowStoreUtils.bytesKeyFromBinaryKey(next.key.get());&lt;/li&gt;
	&lt;li&gt;return KeyValue.pair(&lt;/li&gt;
	&lt;li&gt;new Windowed&amp;lt;&amp;gt;(key, WindowStoreUtils.timeWindowForSize(timestamp, windowSize)),&lt;/li&gt;
	&lt;li&gt;next.value&lt;/li&gt;
	&lt;li&gt;);&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;};&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;}&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;static WindowStoreIteratorWrapper&amp;lt;Bytes, byte[]&amp;gt; bytesIterator(final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; underlying,&lt;/li&gt;
	&lt;li&gt;final StateSerdes&amp;lt;Bytes, byte[]&amp;gt; serdes,&lt;/li&gt;
	&lt;li&gt;final long windowSize) 
{
-        return new WrappedWindowStoreBytesIterator(underlying, serdes, windowSize);
-    }
&lt;p&gt;-&lt;br/&gt;
-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;protected final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator;&lt;/li&gt;
	&lt;li&gt;protected final StateSerdes&amp;lt;K, V&amp;gt; serdes;&lt;/li&gt;
	&lt;li&gt;protected final long windowSize;&lt;br/&gt;
+    private final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator;&lt;br/&gt;
+    private final StateSerdes&amp;lt;K, V&amp;gt; serdes;&lt;br/&gt;
+    private final long windowSize;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;WindowStoreIteratorWrapper(&lt;/li&gt;
	&lt;li&gt;final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator,&lt;/li&gt;
	&lt;li&gt;final StateSerdes&amp;lt;K, V&amp;gt; serdes,&lt;/li&gt;
	&lt;li&gt;final long windowSize&lt;/li&gt;
	&lt;li&gt;) {&lt;br/&gt;
+    WindowStoreIteratorWrapper(final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; bytesIterator,&lt;br/&gt;
+                               final StateSerdes&amp;lt;K, V&amp;gt; serdes,&lt;br/&gt;
+                               final long windowSize) {&lt;br/&gt;
         this.bytesIterator = bytesIterator;&lt;br/&gt;
         this.serdes = serdes;&lt;br/&gt;
         this.windowSize = windowSize;&lt;br/&gt;
@@ -117,7 +57,7 @@&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         @Override&lt;br/&gt;
         public Long peekNextKey() &lt;/p&gt;
{
-            return WindowStoreUtils.timestampFromBinaryKey(bytesIterator.peekNextKey().get());
+            return WindowKeySchema.extractStoreTimestamp(bytesIterator.peekNextKey().get());
         }

&lt;p&gt;         @Override&lt;br/&gt;
@@ -128,7 +68,7 @@ public boolean hasNext() {&lt;br/&gt;
         @Override&lt;br/&gt;
         public KeyValue&amp;lt;Long, V&amp;gt; next() &lt;/p&gt;
{
             final KeyValue&amp;lt;Bytes, byte[]&amp;gt; next = bytesIterator.next();
-            final long timestamp = WindowStoreUtils.timestampFromBinaryKey(next.key.get());
+            final long timestamp = WindowKeySchema.extractStoreTimestamp(next.key.get());
             final V value = serdes.valueFrom(next.value);
             return KeyValue.pair(timestamp, value);
         }
&lt;p&gt;@@ -160,9 +100,9 @@ public void close() {&lt;br/&gt;
         @Override&lt;br/&gt;
         public Windowed&amp;lt;K&amp;gt; peekNextKey() &lt;/p&gt;
{
             final byte[] nextKey = bytesIterator.peekNextKey().get();
-            final long timestamp = WindowStoreUtils.timestampFromBinaryKey(nextKey);
-            final K key = WindowStoreUtils.keyFromBinaryKey(nextKey, serdes);
-            return new Windowed&amp;lt;&amp;gt;(key, WindowStoreUtils.timeWindowForSize(timestamp, windowSize));
+            final long timestamp = WindowKeySchema.extractStoreTimestamp(nextKey);
+            final K key = WindowKeySchema.extractStoreKey(nextKey, serdes);
+            return new Windowed&amp;lt;&amp;gt;(key, WindowKeySchema.timeWindowForSize(timestamp, windowSize));
         }

&lt;p&gt;         @Override&lt;br/&gt;
@@ -173,11 +113,11 @@ public boolean hasNext() {&lt;br/&gt;
         @Override&lt;br/&gt;
         public KeyValue&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; next() {&lt;br/&gt;
             final KeyValue&amp;lt;Bytes, byte[]&amp;gt; next = bytesIterator.next();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final long timestamp = WindowStoreUtils.timestampFromBinaryKey(next.key.get());&lt;/li&gt;
	&lt;li&gt;final K key = WindowStoreUtils.keyFromBinaryKey(next.key.get(), serdes);&lt;br/&gt;
+            final long timestamp = WindowKeySchema.extractStoreTimestamp(next.key.get());&lt;br/&gt;
+            final K key = WindowKeySchema.extractStoreKey(next.key.get(), serdes);&lt;br/&gt;
             final V value = serdes.valueFrom(next.value);&lt;br/&gt;
             return KeyValue.pair(&lt;/li&gt;
	&lt;li&gt;new Windowed&amp;lt;&amp;gt;(key, WindowStoreUtils.timeWindowForSize(timestamp, windowSize)),&lt;br/&gt;
+                new Windowed&amp;lt;&amp;gt;(key, WindowKeySchema.timeWindowForSize(timestamp, windowSize)),&lt;br/&gt;
                 value&lt;br/&gt;
             );&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowStoreUtils.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowStoreUtils.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 317ce227105..00000000000&lt;br/&gt;
&amp;#8212; a/streams/src/main/java/org/apache/kafka/streams/state/internals/WindowStoreUtils.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,86 +0,0 @@&lt;br/&gt;
-/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements. See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to You under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License. You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.kafka.streams.state.internals;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
-import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.TimeWindow;&lt;br/&gt;
-import org.apache.kafka.streams.state.StateSerdes;&lt;br/&gt;
-&lt;br/&gt;
-import java.nio.ByteBuffer;&lt;br/&gt;
-&lt;br/&gt;
-public class WindowStoreUtils {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;static final int SEQNUM_SIZE = 4;&lt;/li&gt;
	&lt;li&gt;static final int TIMESTAMP_SIZE = 8;&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;/** Inner byte array serde used for segments */&lt;/li&gt;
	&lt;li&gt;static final Serde&amp;lt;Bytes&amp;gt; INNER_KEY_SERDE = Serdes.Bytes();&lt;/li&gt;
	&lt;li&gt;static final Serde&amp;lt;byte[]&amp;gt; INNER_VALUE_SERDE = Serdes.ByteArray();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;static StateSerdes&amp;lt;Bytes, byte[]&amp;gt; getInnerStateSerde(final String topic) 
{
-        return new StateSerdes&amp;lt;&amp;gt;(topic, INNER_KEY_SERDE, INNER_VALUE_SERDE);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;static &amp;lt;K&amp;gt; Bytes toBinaryKey(K key, final long timestamp, final int seqnum, StateSerdes&amp;lt;K, ?&amp;gt; serdes) 
{
-        byte[] serializedKey = serdes.rawKey(key);
-        return toBinaryKey(serializedKey, timestamp, seqnum);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;static Bytes toBinaryKey(byte[] serializedKey, final long timestamp, final int seqnum) 
{
-        ByteBuffer buf = ByteBuffer.allocate(serializedKey.length + TIMESTAMP_SIZE + SEQNUM_SIZE);
-        buf.put(serializedKey);
-        buf.putLong(timestamp);
-        buf.putInt(seqnum);
-
-        return Bytes.wrap(buf.array());
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;static &amp;lt;K&amp;gt; K keyFromBinaryKey(byte[] binaryKey, StateSerdes&amp;lt;K, ?&amp;gt; serdes) 
{
-        byte[] bytes = new byte[binaryKey.length - TIMESTAMP_SIZE - SEQNUM_SIZE];
-
-        System.arraycopy(binaryKey, 0, bytes, 0, bytes.length);
-
-        return serdes.keyFrom(bytes);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;static Bytes bytesKeyFromBinaryKey(byte[] binaryKey) 
{
-        byte[] bytes = new byte[binaryKey.length - TIMESTAMP_SIZE - SEQNUM_SIZE];
-
-        System.arraycopy(binaryKey, 0, bytes, 0, bytes.length);
-
-        return Bytes.wrap(bytes);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;static long timestampFromBinaryKey(byte[] binaryKey) 
{
-        return ByteBuffer.wrap(binaryKey).getLong(binaryKey.length - TIMESTAMP_SIZE - SEQNUM_SIZE);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;static int sequenceNumberFromBinaryKey(byte[] binaryKey) 
{
-        return ByteBuffer.wrap(binaryKey).getInt(binaryKey.length - SEQNUM_SIZE);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;/**&lt;/li&gt;
	&lt;li&gt;* Safely construct a time window of the given size,&lt;/li&gt;
	&lt;li&gt;* taking care of bounding endMs to Long.MAX_VALUE if necessary&lt;/li&gt;
	&lt;li&gt;*/&lt;/li&gt;
	&lt;li&gt;public static TimeWindow timeWindowForSize(final long startMs, final long windowSize) 
{
-        final long endMs = startMs + windowSize;
-        return new TimeWindow(startMs, endMs &amp;lt; 0 ? Long.MAX_VALUE : endMs);
-    }
&lt;p&gt;-}&lt;br/&gt;
diff --git a/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedSessionStoreIterator.java b/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedSessionStoreIterator.java&lt;br/&gt;
index c5ea70bac80..47496a4b766 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedSessionStoreIterator.java&lt;br/&gt;
+++ b/streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedSessionStoreIterator.java&lt;br/&gt;
@@ -19,7 +19,6 @@&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
 import org.apache.kafka.streams.state.StateSerdes;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -37,14 +36,13 @@&lt;br/&gt;
         @Override&lt;br/&gt;
         public Windowed&amp;lt;Bytes&amp;gt; peekNextKey() &lt;/p&gt;
{
             final Bytes key = bytesIterator.peekNextKey();
-
-            return SessionKeySerde.fromBytes(key);
+            return SessionKeySchema.from(key);
         }

&lt;p&gt;         @Override&lt;br/&gt;
         public KeyValue&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt; next() &lt;/p&gt;
{
             final KeyValue&amp;lt;Bytes, byte[]&amp;gt; next = bytesIterator.next();
-            return KeyValue.pair(SessionKeySerde.fromBytes(next.key), next.value);
+            return KeyValue.pair(SessionKeySchema.from(next.key), next.value);
         }
&lt;p&gt;     }&lt;/p&gt;

&lt;p&gt;@@ -66,7 +64,7 @@ public void close() {&lt;br/&gt;
     @Override&lt;br/&gt;
     public Windowed&amp;lt;K&amp;gt; peekNextKey() &lt;/p&gt;
{
         final Bytes bytes = bytesIterator.peekNextKey();
-        return SessionKeySerde.from(bytes.get(), serdes.keyDeserializer(), serdes.topic());
+        return SessionKeySchema.from(bytes.get(), serdes.keyDeserializer(), serdes.topic());
     }

&lt;p&gt;     @Override&lt;br/&gt;
@@ -77,8 +75,7 @@ public boolean hasNext() {&lt;br/&gt;
     @Override&lt;br/&gt;
     public KeyValue&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; next() &lt;/p&gt;
{
         final KeyValue&amp;lt;Bytes, byte[]&amp;gt; next = bytesIterator.next();
-        return KeyValue.pair(SessionKeySerde.from(next.key.get(), serdes.keyDeserializer(), serdes.topic()),
-                             serdes.valueFrom(next.value));
+        return KeyValue.pair(SessionKeySchema.from(next.key.get(), serdes.keyDeserializer(), serdes.topic()), serdes.valueFrom(next.value));
     }

&lt;p&gt;     @Override&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/SessionWindowedDeserializerTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/SessionWindowedDeserializerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..ec3cc833953&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/kstream/SessionWindowedDeserializerTest.java&lt;br/&gt;
@@ -0,0 +1,58 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.serialization.ByteArrayDeserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
+import org.apache.kafka.common.serialization.StringDeserializer;&lt;br/&gt;
+import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertNotNull;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+public class SessionWindowedDeserializerTest {&lt;br/&gt;
+    private final SessionWindowedDeserializer&amp;lt;?&amp;gt; sessionWindowedDeserializer = new SessionWindowedDeserializer&amp;lt;&amp;gt;();&lt;br/&gt;
+    private final Map&amp;lt;String, String&amp;gt; props = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+    @Before&lt;br/&gt;
+    public void setUp() &lt;/p&gt;
{
+        props.put(StreamsConfig.DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS, Serdes.StringSerde.class.getName());
+        props.put(StreamsConfig.DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS, Serdes.ByteArraySerde.class.getName());
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedKeyDeserializerNoArgConstructors() {
+        sessionWindowedDeserializer.configure(props, true);
+        Deserializer&amp;lt;?&amp;gt; inner = sessionWindowedDeserializer.innerDeserializer();
+        assertNotNull(&quot;Inner deserializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner deserializer type should be StringDeserializer&quot;, inner instanceof StringDeserializer);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedValueDeserializerNoArgConstructors() {
+        sessionWindowedDeserializer.configure(props, false);
+        Deserializer&amp;lt;?&amp;gt; inner = sessionWindowedDeserializer.innerDeserializer();
+        assertNotNull(&quot;Inner deserializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner deserializer type should be ByteArrayDeserializer&quot;, inner instanceof ByteArrayDeserializer);
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/SessionWindowedSerializerTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/SessionWindowedSerializerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..e7266dba9c9&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/kstream/SessionWindowedSerializerTest.java&lt;br/&gt;
@@ -0,0 +1,58 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.serialization.ByteArraySerializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.StringSerializer;&lt;br/&gt;
+import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertNotNull;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+public class SessionWindowedSerializerTest {&lt;br/&gt;
+    private final SessionWindowedSerializer&amp;lt;?&amp;gt; sessionWindowedSerializer = new SessionWindowedSerializer&amp;lt;&amp;gt;();&lt;br/&gt;
+    private final Map&amp;lt;String, String&amp;gt; props = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+    @Before&lt;br/&gt;
+    public void setUp() {+        props.put(StreamsConfig.DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS, Serdes.StringSerde.class.getName());+        props.put(StreamsConfig.DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS, Serdes.ByteArraySerde.class.getName());+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedKeySerializerNoArgConstructors() &lt;/p&gt;
{
+        sessionWindowedSerializer.configure(props, true);
+        Serializer&amp;lt;?&amp;gt; inner = sessionWindowedSerializer.innerSerializer();
+        assertNotNull(&quot;Inner serializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner serializer type should be StringSerializer&quot;, inner instanceof StringSerializer);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedValueSerializerNoArgConstructors() &lt;/p&gt;
{
+        sessionWindowedSerializer.configure(props, false);
+        Serializer&amp;lt;?&amp;gt; inner = sessionWindowedSerializer.innerSerializer();
+        assertNotNull(&quot;Inner serializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner serializer type should be ByteArraySerializer&quot;, inner instanceof ByteArraySerializer);
+    }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/TimeWindowedDeserializerTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/TimeWindowedDeserializerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..660a530fed6&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/kstream/TimeWindowedDeserializerTest.java&lt;br/&gt;
@@ -0,0 +1,59 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.serialization.ByteArrayDeserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
+import org.apache.kafka.common.serialization.StringDeserializer;&lt;br/&gt;
+import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertNotNull;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+public class TimeWindowedDeserializerTest {&lt;br/&gt;
+    private final long windowSize = 5000000;&lt;br/&gt;
+    private final TimeWindowedDeserializer&amp;lt;?&amp;gt; timeWindowedDeserializer = new TimeWindowedDeserializer&amp;lt;&amp;gt;(null, windowSize);&lt;br/&gt;
+    private final Map&amp;lt;String, String&amp;gt; props = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+    @Before&lt;br/&gt;
+    public void setUp() &lt;/p&gt;
{
+        props.put(StreamsConfig.DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS, Serdes.StringSerde.class.getName());
+        props.put(StreamsConfig.DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS, Serdes.ByteArraySerde.class.getName());
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedKeyDeserializerNoArgConstructors() {
+        timeWindowedDeserializer.configure(props, true);
+        Deserializer&amp;lt;?&amp;gt; inner = timeWindowedDeserializer.innerDeserializer();
+        assertNotNull(&quot;Inner deserializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner deserializer type should be StringDeserializer&quot;, inner instanceof StringDeserializer);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedValueDeserializerNoArgConstructors() {
+        timeWindowedDeserializer.configure(props, false);
+        Deserializer&amp;lt;?&amp;gt; inner = timeWindowedDeserializer.innerDeserializer();
+        assertNotNull(&quot;Inner deserializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner deserializer type should be ByteArrayDeserializer&quot;, inner instanceof ByteArrayDeserializer);
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/TimeWindowedSerializerTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/TimeWindowedSerializerTest.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..cd019c80cd1&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/kstream/TimeWindowedSerializerTest.java&lt;br/&gt;
@@ -0,0 +1,58 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.streams.kstream;&lt;br/&gt;
+&lt;br/&gt;
+import org.apache.kafka.common.serialization.ByteArraySerializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
+import org.apache.kafka.common.serialization.StringSerializer;&lt;br/&gt;
+import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.junit.Before;&lt;br/&gt;
+import org.junit.Test;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.HashMap;&lt;br/&gt;
+import java.util.Map;&lt;br/&gt;
+&lt;br/&gt;
+import static org.junit.Assert.assertNotNull;&lt;br/&gt;
+import static org.junit.Assert.assertTrue;&lt;br/&gt;
+&lt;br/&gt;
+public class TimeWindowedSerializerTest {&lt;br/&gt;
+    private final TimeWindowedSerializer&amp;lt;?&amp;gt; timeWindowedSerializer = new TimeWindowedSerializer&amp;lt;&amp;gt;();&lt;br/&gt;
+    private final Map&amp;lt;String, String&amp;gt; props = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+&lt;br/&gt;
+    @Before&lt;br/&gt;
+    public void setUp() {+        props.put(StreamsConfig.DEFAULT_WINDOWED_KEY_SERDE_INNER_CLASS, Serdes.StringSerde.class.getName());+        props.put(StreamsConfig.DEFAULT_WINDOWED_VALUE_SERDE_INNER_CLASS, Serdes.ByteArraySerde.class.getName());+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedKeySerializerNoArgConstructors() &lt;/p&gt;
{
+        timeWindowedSerializer.configure(props, true);
+        Serializer&amp;lt;?&amp;gt; inner = timeWindowedSerializer.innerSerializer();
+        assertNotNull(&quot;Inner serializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner serializer type should be StringSerializer&quot;, inner instanceof StringSerializer);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testWindowedValueSerializerNoArgConstructors() &lt;/p&gt;
{
+        timeWindowedSerializer.configure(props, false);
+        Serializer&amp;lt;?&amp;gt; inner = timeWindowedSerializer.innerSerializer();
+        assertNotNull(&quot;Inner serializer should be not null&quot;, inner);
+        assertTrue(&quot;Inner serializer type should be ByteArraySerializer&quot;, inner instanceof ByteArraySerializer);
+    }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/SessionKeySerdeTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/internals/SessionKeySerdeTest.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 59371d5325b..00000000000&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/SessionKeySerdeTest.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,107 +0,0 @@&lt;br/&gt;
-/*&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements. See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to You under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License. You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.kafka.streams.kstream.internals;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
-import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.junit.Test;&lt;br/&gt;
-&lt;br/&gt;
-import static org.junit.Assert.assertArrayEquals;&lt;br/&gt;
-import static org.junit.Assert.assertEquals;&lt;br/&gt;
-import static org.junit.Assert.assertNull;&lt;br/&gt;
-&lt;br/&gt;
-public class SessionKeySerdeTest {&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;final private String topic = &quot;topic&quot;;&lt;/li&gt;
	&lt;li&gt;final private String key = &quot;key&quot;;&lt;/li&gt;
	&lt;li&gt;final private long startTime = 50L;&lt;/li&gt;
	&lt;li&gt;final private long endTime = 100L;&lt;/li&gt;
	&lt;li&gt;final private Window window = new SessionWindow(startTime, endTime);&lt;/li&gt;
	&lt;li&gt;final private Windowed&amp;lt;String&amp;gt; windowedKey = new Windowed&amp;lt;&amp;gt;(key, window);&lt;/li&gt;
	&lt;li&gt;final private Serde&amp;lt;String&amp;gt; serde = Serdes.String();&lt;/li&gt;
	&lt;li&gt;final private SessionKeySerde&amp;lt;String&amp;gt; sessionKeySerde = new SessionKeySerde&amp;lt;&amp;gt;(serde);&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldSerializeDeserialize() 
{
-        final byte[] bytes = sessionKeySerde.serializer().serialize(topic, windowedKey);
-        final Windowed&amp;lt;String&amp;gt; result = sessionKeySerde.deserializer().deserialize(topic, bytes);
-        assertEquals(windowedKey, result);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldSerializeNullToNull() 
{
-        assertNull(sessionKeySerde.serializer().serialize(topic, null));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldDeSerializeEmtpyByteArrayToNull() 
{
-        assertNull(sessionKeySerde.deserializer().deserialize(topic, new byte[0]));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldDeSerializeNullToNull() 
{
-        assertNull(sessionKeySerde.deserializer().deserialize(topic, null));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldConvertToBinaryAndBack() 
{
-        final Bytes serialized = SessionKeySerde.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
-        final Windowed&amp;lt;String&amp;gt; result = SessionKeySerde.from(serialized.get(), Serdes.String().deserializer(), &quot;dummy&quot;);
-        assertEquals(windowedKey, result);
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldExtractEndTimeFromBinary() 
{
-        final Bytes serialized = SessionKeySerde.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
-        assertEquals(endTime, SessionKeySerde.extractEnd(serialized.get()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldExtractStartTimeFromBinary() 
{
-        final Bytes serialized = SessionKeySerde.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
-        assertEquals(startTime, SessionKeySerde.extractStart(serialized.get()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldExtractWindowFromBindary() 
{
-        final Bytes serialized = SessionKeySerde.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
-        assertEquals(window, SessionKeySerde.extractWindow(serialized.get()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldExtractKeyBytesFromBinary() 
{
-        final Bytes serialized = SessionKeySerde.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
-        assertArrayEquals(key.getBytes(), SessionKeySerde.extractKeyBytes(serialized.get()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldExtractKeyFromBinary() 
{
-        final Bytes serialized = SessionKeySerde.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
-        assertEquals(windowedKey, SessionKeySerde.from(serialized.get(), serde.deserializer(), &quot;dummy&quot;));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void shouldExtractBytesKeyFromBinary() 
{
-        final Bytes bytesKey = Bytes.wrap(key.getBytes());
-        final Windowed&amp;lt;Bytes&amp;gt; windowedBytesKey = new Windowed&amp;lt;&amp;gt;(bytesKey, window);
-        final Bytes serialized = SessionKeySerde.bytesToBinary(windowedBytesKey);
-        assertEquals(windowedBytesKey, SessionKeySerde.fromBytes(serialized));
-    }
&lt;p&gt;-}&lt;br/&gt;
\ No newline at end of file&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitionerTest.java b/streams/src/test/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitionerTest.java&lt;br/&gt;
index d3510a0897b..3aafa33e2e4 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitionerTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/kstream/internals/WindowedStreamPartitionerTest.java&lt;br/&gt;
@@ -20,14 +20,9 @@&lt;br/&gt;
 import org.apache.kafka.common.Cluster;&lt;br/&gt;
 import org.apache.kafka.common.Node;&lt;br/&gt;
 import org.apache.kafka.common.PartitionInfo;&lt;br/&gt;
-import org.apache.kafka.common.serialization.ByteArrayDeserializer;&lt;br/&gt;
-import org.apache.kafka.common.serialization.ByteArraySerializer;&lt;br/&gt;
 import org.apache.kafka.common.serialization.IntegerSerializer;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
 import org.apache.kafka.common.serialization.StringSerializer;&lt;br/&gt;
-import org.apache.kafka.common.serialization.StringDeserializer;&lt;br/&gt;
-import org.apache.kafka.common.serialization.Deserializer;&lt;br/&gt;
-import org.apache.kafka.streams.StreamsConfig;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.TimeWindowedSerializer;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
 import org.junit.Test;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -35,12 +30,8 @@&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
 import java.util.List;&lt;br/&gt;
 import java.util.Random;&lt;br/&gt;
-import java.util.Map;&lt;br/&gt;
-import java.util.HashMap;&lt;/p&gt;

&lt;p&gt; import static org.junit.Assert.assertEquals;&lt;br/&gt;
-import static org.junit.Assert.assertNotNull;&lt;br/&gt;
-import static org.junit.Assert.assertTrue;&lt;/p&gt;

&lt;p&gt; public class WindowedStreamPartitionerTest {&lt;/p&gt;

&lt;p&gt;@@ -63,13 +54,10 @@&lt;/p&gt;

&lt;p&gt;     @Test&lt;br/&gt;
     public void testCopartitioning() {&lt;br/&gt;
-&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Random rand = new Random();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;DefaultPartitioner defaultPartitioner = new DefaultPartitioner();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;WindowedSerializer&amp;lt;Integer&amp;gt; windowedSerializer = new WindowedSerializer&amp;lt;&amp;gt;(intSerializer);&lt;/li&gt;
	&lt;li&gt;WindowedStreamPartitioner&amp;lt;Integer, String&amp;gt; streamPartitioner = new WindowedStreamPartitioner&amp;lt;&amp;gt;(topicName, windowedSerializer);&lt;br/&gt;
+        final Random rand = new Random();&lt;br/&gt;
+        final DefaultPartitioner defaultPartitioner = new DefaultPartitioner();&lt;br/&gt;
+        final WindowedSerializer&amp;lt;Integer&amp;gt; timeWindowedSerializer = new TimeWindowedSerializer&amp;lt;&amp;gt;(intSerializer);&lt;br/&gt;
+        final WindowedStreamPartitioner&amp;lt;Integer, String&amp;gt; streamPartitioner = new WindowedStreamPartitioner&amp;lt;&amp;gt;(topicName, timeWindowedSerializer);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         for (int k = 0; k &amp;lt; 10; k++) {&lt;br/&gt;
             Integer key = rand.nextInt();&lt;br/&gt;
@@ -92,70 +80,4 @@ public void testCopartitioning() &lt;/p&gt;
{
 
         defaultPartitioner.close();
     }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testWindowedSerializerNoArgConstructors() 
{
-        Map&amp;lt;String, String&amp;gt; props = new HashMap&amp;lt;&amp;gt;();
-        // test key[value].serializer.inner.class takes precedence over serializer.inner.class
-        WindowedSerializer&amp;lt;StringSerializer&amp;gt; windowedSerializer = new WindowedSerializer&amp;lt;&amp;gt;();
-        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;host:1&quot;);
-        props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;appId&quot;);
-        props.put(&quot;key.serializer.inner.class&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
-        props.put(&quot;serializer.inner.class&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
-        windowedSerializer.configure(props, true);
-        Serializer&amp;lt;?&amp;gt; inner = windowedSerializer.innerSerializer();
-        assertNotNull(&quot;Inner serializer should be not null&quot;, inner);
-        assertTrue(&quot;Inner serializer type should be StringSerializer&quot;, inner instanceof StringSerializer);
-        // test serializer.inner.class
-        props.put(&quot;serializer.inner.class&quot;, &quot;org.apache.kafka.common.serialization.ByteArraySerializer&quot;);
-        props.remove(&quot;key.serializer.inner.class&quot;);
-        props.remove(&quot;value.serializer.inner.class&quot;);
-        WindowedSerializer&amp;lt;?&amp;gt; windowedSerializer1 = new WindowedSerializer&amp;lt;&amp;gt;();
-        windowedSerializer1.configure(props, false);
-        Serializer&amp;lt;?&amp;gt; inner1 = windowedSerializer1.innerSerializer();
-        assertNotNull(&quot;Inner serializer should be not null&quot;, inner1);
-        assertTrue(&quot;Inner serializer type should be ByteArraySerializer&quot;, inner1 instanceof ByteArraySerializer);
-        windowedSerializer.close();
-        windowedSerializer1.close();
-    }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testWindowedDeserializerNoArgConstructors() 
{
-        Map&amp;lt;String, String&amp;gt; props = new HashMap&amp;lt;&amp;gt;();
-        WindowedDeserializer&amp;lt;StringSerializer&amp;gt; windowedDeserializer = new WindowedDeserializer&amp;lt;&amp;gt;();
-        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;host:1&quot;);
-        props.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;appId&quot;);
-        props.put(&quot;key.deserializer.inner.class&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
-        props.put(&quot;deserializer.inner.class&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
-        windowedDeserializer.configure(props, true);
-        Deserializer&amp;lt;?&amp;gt; inner = windowedDeserializer.innerDeserializer();
-        assertNotNull(&quot;Inner deserializer should be not null&quot;, inner);
-        assertTrue(&quot;Inner deserializer type should be StringDeserializer&quot;, inner instanceof StringDeserializer);
-        // test deserializer.inner.class
-        props.put(&quot;deserializer.inner.class&quot;, &quot;org.apache.kafka.common.serialization.ByteArrayDeserializer&quot;);
-        props.remove(&quot;key.deserializer.inner.class&quot;);
-        props.remove(&quot;value.deserializer.inner.class&quot;);
-        WindowedDeserializer&amp;lt;?&amp;gt; windowedDeserializer1 = new WindowedDeserializer&amp;lt;&amp;gt;();
-        windowedDeserializer1.configure(props, false);
-        final Deserializer&amp;lt;?&amp;gt; inner1 = windowedDeserializer1.innerDeserializer();
-        assertNotNull(&quot;Inner deserializer should be not null&quot;, inner1);
-        assertTrue(&quot;Inner deserializer type should be ByteArrayDeserializer&quot;, inner1 instanceof ByteArrayDeserializer);
-        windowedDeserializer.close();
-        windowedDeserializer1.close();
-    }&lt;/li&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testWindowDeserializeExpectedWindowSize() 
{
-        final long randomLong = 5000000;
-        final Map&amp;lt;String, String&amp;gt; props = new HashMap&amp;lt;&amp;gt;();
-        final WindowedDeserializer&amp;lt;StringSerializer&amp;gt; windowedDeserializer = new WindowedDeserializer&amp;lt;&amp;gt;(randomLong);
-        props.put(&quot;key.deserializer.inner.class&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
-        windowedDeserializer.configure(props, true);
-        //test for deserializer expected window end time
-        final byte[] byteValues = stringSerializer.serialize(topicName, &quot;dummy string&quot;); //dummy string, serves no real purpose
-        final Windowed&amp;lt;?&amp;gt; windowed = windowedDeserializer.deserialize(topicName, byteValues);
-        final long actualSize = windowed.window().end() - windowed.window().start(); //find actual window time
-        assertEquals(randomLong, actualSize); //testing if window size matches up with expected one
-        windowedDeserializer.close();
-    }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/CachingWindowStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/CachingWindowStoreTest.java&lt;br/&gt;
index 5f934b83454..bbf9bef03f3 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/CachingWindowStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/CachingWindowStoreTest.java&lt;br/&gt;
@@ -259,7 +259,7 @@ public void shouldIterateAcrossWindows() {&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldIterateCacheAndStore() {&lt;br/&gt;
         final Bytes key = Bytes.wrap(&quot;1&quot; .getBytes());&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;underlying.put(WindowStoreUtils.toBinaryKey(key, DEFAULT_TIMESTAMP, 0, WindowStoreUtils.getInnerStateSerde(&quot;app-id&quot;)), &quot;a&quot;.getBytes());&lt;br/&gt;
+        underlying.put(WindowKeySchema.toStoreKeyBinary(key, DEFAULT_TIMESTAMP, 0), &quot;a&quot;.getBytes());&lt;br/&gt;
         cachingStore.put(key, bytesValue(&quot;b&quot;), DEFAULT_TIMESTAMP + WINDOW_SIZE);&lt;br/&gt;
         final WindowStoreIterator&amp;lt;byte[]&amp;gt; fetch = cachingStore.fetch(bytesKey(&quot;1&quot;), DEFAULT_TIMESTAMP, DEFAULT_TIMESTAMP + WINDOW_SIZE);&lt;br/&gt;
         verifyKeyValue(fetch.next(), DEFAULT_TIMESTAMP, &quot;a&quot;);&lt;br/&gt;
@@ -270,7 +270,7 @@ public void shouldIterateCacheAndStore() {&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldIterateCacheAndStoreKeyRange() {&lt;br/&gt;
         final Bytes key = Bytes.wrap(&quot;1&quot; .getBytes());&lt;/li&gt;
	&lt;li&gt;underlying.put(WindowStoreUtils.toBinaryKey(key, DEFAULT_TIMESTAMP, 0, WindowStoreUtils.getInnerStateSerde(&quot;app-id&quot;)), &quot;a&quot;.getBytes());&lt;br/&gt;
+        underlying.put(WindowKeySchema.toStoreKeyBinary(key, DEFAULT_TIMESTAMP, 0), &quot;a&quot;.getBytes());&lt;br/&gt;
         cachingStore.put(key, bytesValue(&quot;b&quot;), DEFAULT_TIMESTAMP + WINDOW_SIZE);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final KeyValueIterator&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt; fetchRange =&lt;br/&gt;
@@ -366,7 +366,7 @@ public void shouldThrowNullPointerExceptionOnRangeNullToKey() &lt;/p&gt;
{
         return KeyValue.pair(new Windowed&amp;lt;&amp;gt;(bytesKey(key), new TimeWindow(timestamp, timestamp + WINDOW_SIZE)), bytesValue(value));
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private int addItemsToCache() throws IOException {&lt;br/&gt;
+    private int addItemsToCache() {&lt;br/&gt;
         int cachedSize = 0;&lt;br/&gt;
         int i = 0;&lt;br/&gt;
         while (cachedSize &amp;lt; MAX_CACHE_SIZE_BYTES) {&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStoreTest.java&lt;br/&gt;
index 98224e9c611..a658186931f 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingSessionBytesStoreTest.java&lt;br/&gt;
@@ -19,7 +19,6 @@&lt;br/&gt;
 import org.apache.kafka.common.serialization.Serializer;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.SessionWindow;&lt;br/&gt;
 import org.apache.kafka.streams.processor.TaskId;&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.ProcessorContextImpl;&lt;br/&gt;
@@ -44,7 +43,7 @@&lt;br/&gt;
 public class ChangeLoggingSessionBytesStoreTest {&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     private final TaskId taskId = new TaskId(0, 0);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final Map sent = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
+    private final Map&amp;lt;Object, Object&amp;gt; sent = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;
     private final NoOpRecordCollector collector = new NoOpRecordCollector() {&lt;br/&gt;
         @Override&lt;br/&gt;
         public &amp;lt;K, V&amp;gt; void send(final String topic,&lt;br/&gt;
@@ -84,7 +83,7 @@ private void init() {&lt;br/&gt;
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldLogPuts() throws Exception {&lt;br/&gt;
+    public void shouldLogPuts() {&lt;br/&gt;
         inner.put(key1, value1);&lt;br/&gt;
         EasyMock.expectLastCall();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -92,26 +91,26 @@ public void shouldLogPuts() throws Exception &lt;/p&gt;
{
 
         store.put(key1, value1);
 
-        assertArrayEquals(value1, (byte[]) sent.get(SessionKeySerde.bytesToBinary(key1)));
+        assertArrayEquals(value1, (byte[]) sent.get(Bytes.wrap(SessionKeySchema.toBinary(key1))));
         EasyMock.verify(inner);
     }

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldLogRemoves() throws Exception {&lt;br/&gt;
+    public void shouldLogRemoves() 
{
         inner.remove(key1);
         EasyMock.expectLastCall();
 
         init();
         store.remove(key1);
 
-        final Bytes binaryKey = SessionKeySerde.bytesToBinary(key1);
+        final Bytes binaryKey = Bytes.wrap(SessionKeySchema.toBinary(key1));
         assertTrue(sent.containsKey(binaryKey));
         assertNull(sent.get(binaryKey));
         EasyMock.verify(inner);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldDelegateToUnderlyingStoreWhenFetching() throws Exception {&lt;br/&gt;
+    public void shouldDelegateToUnderlyingStoreWhenFetching() {&lt;br/&gt;
         EasyMock.expect(inner.findSessions(bytesKey, 0, Long.MAX_VALUE)).andReturn(KeyValueIterators.&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt;emptyIterator());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         init();&lt;br/&gt;
@@ -121,7 +120,7 @@ public void shouldDelegateToUnderlyingStoreWhenFetching() throws Exception {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldDelegateToUnderlyingStoreWhenFetchingRange() throws Exception {&lt;br/&gt;
+    public void shouldDelegateToUnderlyingStoreWhenFetchingRange() 
{
         EasyMock.expect(inner.findSessions(bytesKey, bytesKey, 0, Long.MAX_VALUE)).andReturn(KeyValueIterators.&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt;emptyIterator());
 
         init();
@@ -131,7 +130,7 @@ public void shouldDelegateToUnderlyingStoreWhenFetchingRange() throws Exception
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldDelegateToUnderlyingStoreWhenFindingSessions() throws Exception {&lt;br/&gt;
+    public void shouldDelegateToUnderlyingStoreWhenFindingSessions() 
{
         EasyMock.expect(inner.findSessions(bytesKey, 0, 1)).andReturn(KeyValueIterators.&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt;emptyIterator());
 
         init();
@@ -141,7 +140,7 @@ public void shouldDelegateToUnderlyingStoreWhenFindingSessions() throws Exceptio
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldDelegateToUnderlyingStoreWhenFindingSessionRange() throws Exception {&lt;br/&gt;
+    public void shouldDelegateToUnderlyingStoreWhenFindingSessionRange() 
{
         EasyMock.expect(inner.findSessions(bytesKey, bytesKey, 0, 1)).andReturn(KeyValueIterators.&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt;emptyIterator());
 
         init();
@@ -151,7 +150,7 @@ public void shouldDelegateToUnderlyingStoreWhenFindingSessionRange() throws Exce
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldFlushUnderlyingStore() throws Exception {&lt;br/&gt;
+    public void shouldFlushUnderlyingStore() {&lt;br/&gt;
         inner.flush();&lt;br/&gt;
         EasyMock.expectLastCall();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -162,7 +161,7 @@ public void shouldFlushUnderlyingStore() throws Exception {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldCloseUnderlyingStore() throws Exception {&lt;br/&gt;
+    public void shouldCloseUnderlyingStore() {&lt;br/&gt;
         inner.close();&lt;br/&gt;
         EasyMock.expectLastCall();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java&lt;br/&gt;
index cd859a31e02..956172ebd46 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/ChangeLoggingWindowBytesStoreTest.java&lt;br/&gt;
@@ -66,7 +66,7 @@&lt;/p&gt;


&lt;p&gt;     @Before&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void setUp() throws Exception {&lt;br/&gt;
+    public void setUp() 
{
         store = new ChangeLoggingWindowBytesStore(inner, false);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -81,7 +81,7 @@ private void init() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldLogPuts() throws Exception {&lt;br/&gt;
+    public void shouldLogPuts() {&lt;br/&gt;
         inner.put(bytesKey, value1, 0);&lt;br/&gt;
         EasyMock.expectLastCall();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -89,12 +89,12 @@ public void shouldLogPuts() throws Exception &lt;/p&gt;
{
 
         store.put(bytesKey, value1);
 
-        assertArrayEquals(value1, (byte[]) sent.get(WindowStoreUtils.toBinaryKey(bytesKey.get(), 0, 0)));
+        assertArrayEquals(value1, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 0)));
         EasyMock.verify(inner);
     }

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldDelegateToUnderlyingStoreWhenFetching() throws Exception {&lt;br/&gt;
+    public void shouldDelegateToUnderlyingStoreWhenFetching() {&lt;br/&gt;
         EasyMock.expect(inner.fetch(bytesKey, 0, 10)).andReturn(KeyValueIterators.&amp;lt;byte[]&amp;gt;emptyWindowStoreIterator());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         init();&lt;br/&gt;
@@ -104,7 +104,7 @@ public void shouldDelegateToUnderlyingStoreWhenFetching() throws Exception {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void shouldDelegateToUnderlyingStoreWhenFetchingRange() throws Exception {&lt;br/&gt;
+    public void shouldDelegateToUnderlyingStoreWhenFetchingRange() {&lt;br/&gt;
         EasyMock.expect(inner.fetch(bytesKey, bytesKey, 0, 1)).andReturn(KeyValueIterators.&amp;lt;Windowed&amp;lt;Bytes&amp;gt;, byte[]&amp;gt;emptyIterator());&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         init();&lt;br/&gt;
@@ -123,8 +123,8 @@ public void shouldRetainDuplicatesWhenSet() &lt;/p&gt;
{
         store.put(bytesKey, value1);
         store.put(bytesKey, value1);
 
-        assertArrayEquals(value1, (byte[]) sent.get(WindowStoreUtils.toBinaryKey(bytesKey.get(), 0, 1)));
-        assertArrayEquals(value1, (byte[]) sent.get(WindowStoreUtils.toBinaryKey(bytesKey.get(), 0, 2)));
+        assertArrayEquals(value1, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 1)));
+        assertArrayEquals(value1, (byte[]) sent.get(WindowKeySchema.toStoreKeyBinary(bytesKey, 0, 2)));
 
         EasyMock.verify(inner);
     }
&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedSessionStoreIteratorTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedSessionStoreIteratorTest.java&lt;br/&gt;
index 13e88eba9f6..ea31a041bb3 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedSessionStoreIteratorTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedSessionStoreIteratorTest.java&lt;br/&gt;
@@ -19,7 +19,6 @@&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.SessionWindow;&lt;br/&gt;
 import org.apache.kafka.test.KeyValueIteratorStub;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
@@ -50,9 +49,9 @@ public long segmentId(Bytes key) {&lt;br/&gt;
     private final SessionWindow cacheWindow = new SessionWindow(10, 20);&lt;br/&gt;
     private final Iterator&amp;lt;KeyValue&amp;lt;Bytes, LRUCacheEntry&amp;gt;&amp;gt; cacheKvs = Collections.singleton(&lt;br/&gt;
         KeyValue.pair(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(&lt;/li&gt;
	&lt;li&gt;SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(cacheKey, cacheWindow))&lt;/li&gt;
	&lt;li&gt;),&lt;br/&gt;
+            SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(Bytes.wrap(&lt;br/&gt;
+                    SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(cacheKey, cacheWindow))&lt;br/&gt;
+            )),&lt;br/&gt;
             new LRUCacheEntry(cacheKey.get())&lt;br/&gt;
         )).iterator();&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreIteratorTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreIteratorTest.java&lt;br/&gt;
index a32094c60f1..91351365c12 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreIteratorTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreIteratorTest.java&lt;br/&gt;
@@ -57,14 +57,14 @@ public void shouldIterateOverValueFromBothIterators() &lt;/p&gt;
{
             final KeyValue&amp;lt;Long, byte[]&amp;gt; v1 = KeyValue.pair(t, v1Bytes);
             windowStoreKvPairs.add(v1);
             expectedKvPairs.add(KeyValue.pair(t, v1Bytes));
-            final Bytes keyBytes = WindowStoreUtils.toBinaryKey(&quot;a&quot;, t + 10, 0, stateSerdes);
+            final Bytes keyBytes = WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, t + 10, 0, stateSerdes);
             final byte[] valBytes = String.valueOf(t + 10).getBytes();
             expectedKvPairs.add(KeyValue.pair(t + 10, valBytes));
             cache.put(namespace, SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(keyBytes), new LRUCacheEntry(valBytes));
         }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Bytes fromBytes = WindowStoreUtils.toBinaryKey(&quot;a&quot;, 0, 0, stateSerdes);&lt;/li&gt;
	&lt;li&gt;Bytes toBytes = WindowStoreUtils.toBinaryKey(&quot;a&quot;, 100, 0, stateSerdes);&lt;br/&gt;
+        final Bytes fromBytes = WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 0, 0, stateSerdes);&lt;br/&gt;
+        final Bytes toBytes = WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 100, 0, stateSerdes);&lt;br/&gt;
         final KeyValueIterator&amp;lt;Long, byte[]&amp;gt; storeIterator = new DelegatingPeekingKeyValueIterator&amp;lt;&amp;gt;(&quot;store&quot;, new KeyValueIteratorStub&amp;lt;&amp;gt;(windowStoreKvPairs.iterator()));&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = cache.range(&lt;br/&gt;
@@ -87,9 +87,9 @@ public void shouldIterateOverValueFromBothIterators() {&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldPeekNextStoreKey() {&lt;br/&gt;
         windowStoreKvPairs.add(KeyValue.pair(10L, &quot;a&quot;.getBytes()));&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;cache.put(namespace, SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowStoreUtils.toBinaryKey(&quot;a&quot;, 0, 0, stateSerdes)), new LRUCacheEntry(&quot;b&quot;.getBytes()));&lt;/li&gt;
	&lt;li&gt;Bytes fromBytes = WindowStoreUtils.toBinaryKey(&quot;a&quot;, 0, 0, stateSerdes);&lt;/li&gt;
	&lt;li&gt;Bytes toBytes = WindowStoreUtils.toBinaryKey(&quot;a&quot;, 100, 0, stateSerdes);&lt;br/&gt;
+        cache.put(namespace, SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 0, 0, stateSerdes)), new LRUCacheEntry(&quot;b&quot;.getBytes()));&lt;br/&gt;
+        final Bytes fromBytes = WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 0, 0, stateSerdes);&lt;br/&gt;
+        final Bytes toBytes = WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 100, 0, stateSerdes);&lt;br/&gt;
         final KeyValueIterator&amp;lt;Long, byte[]&amp;gt; storeIterator = new DelegatingPeekingKeyValueIterator&amp;lt;&amp;gt;(&quot;store&quot;, new KeyValueIteratorStub&amp;lt;&amp;gt;(windowStoreKvPairs.iterator()));&lt;br/&gt;
         final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = cache.range(&lt;br/&gt;
             namespace, SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(fromBytes), SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(toBytes)&lt;br/&gt;
@@ -106,9 +106,9 @@ public void shouldPeekNextStoreKey() {&lt;br/&gt;
     @Test&lt;br/&gt;
     public void shouldPeekNextCacheKey() {&lt;br/&gt;
         windowStoreKvPairs.add(KeyValue.pair(0L, &quot;a&quot;.getBytes()));&lt;/li&gt;
	&lt;li&gt;cache.put(namespace, SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowStoreUtils.toBinaryKey(&quot;a&quot;, 10L, 0, stateSerdes)), new LRUCacheEntry(&quot;b&quot;.getBytes()));&lt;/li&gt;
	&lt;li&gt;Bytes fromBytes = WindowStoreUtils.toBinaryKey(&quot;a&quot;, 0, 0, stateSerdes);&lt;/li&gt;
	&lt;li&gt;Bytes toBytes = WindowStoreUtils.toBinaryKey(&quot;a&quot;, 100, 0, stateSerdes);&lt;br/&gt;
+        cache.put(namespace, SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 10L, 0, stateSerdes)), new LRUCacheEntry(&quot;b&quot;.getBytes()));&lt;br/&gt;
+        final Bytes fromBytes = WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 0, 0, stateSerdes);&lt;br/&gt;
+        final Bytes toBytes = WindowKeySchema.toStoreKeyBinary(&quot;a&quot;, 100, 0, stateSerdes);&lt;br/&gt;
         final KeyValueIterator&amp;lt;Long, byte[]&amp;gt; storeIterator = new DelegatingPeekingKeyValueIterator&amp;lt;&amp;gt;(&quot;store&quot;, new KeyValueIteratorStub&amp;lt;&amp;gt;(windowStoreKvPairs.iterator()));&lt;br/&gt;
         final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = cache.range(namespace, SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(fromBytes), SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(toBytes));&lt;br/&gt;
         final MergedSortedCacheWindowStoreIterator iterator = new MergedSortedCacheWindowStoreIterator(cacheIterator, storeIterator);&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreKeyValueIteratorTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreKeyValueIteratorTest.java&lt;br/&gt;
index f1c46fb8e91..1e5f62c9ce7 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreKeyValueIteratorTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreKeyValueIteratorTest.java&lt;br/&gt;
@@ -53,11 +53,8 @@ public long segmentId(Bytes key) {&lt;br/&gt;
     private final TimeWindow cacheWindow = new TimeWindow(10, 20);&lt;br/&gt;
     private final Iterator&amp;lt;KeyValue&amp;lt;Bytes, LRUCacheEntry&amp;gt;&amp;gt; cacheKvs = Collections.singleton(&lt;br/&gt;
         KeyValue.pair(&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(&lt;/li&gt;
	&lt;li&gt;WindowStoreUtils.toBinaryKey(&lt;/li&gt;
	&lt;li&gt;cacheKey, cacheWindow.start(), 0,&lt;/li&gt;
	&lt;li&gt;new StateSerdes&amp;lt;&amp;gt;(&quot;dummy&quot;, Serdes.String(), Serdes.String())&lt;/li&gt;
	&lt;li&gt;)&lt;br/&gt;
+            SINGLE_SEGMENT_CACHE_FUNCTION.cacheKey(WindowKeySchema.toStoreKeyBinary(&lt;br/&gt;
+                    new Windowed&amp;lt;&amp;gt;(cacheKey, cacheWindow), 0, new StateSerdes&amp;lt;&amp;gt;(&quot;dummy&quot;, Serdes.String(), Serdes.ByteArray()))&lt;br/&gt;
             ),&lt;br/&gt;
             new LRUCacheEntry(cacheKey.getBytes())&lt;br/&gt;
         )).iterator();&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBSegmentedBytesStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBSegmentedBytesStoreTest.java&lt;br/&gt;
index df50b2c14a1..e34d3cccc67 100644
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBSegmentedBytesStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBSegmentedBytesStoreTest.java&lt;br/&gt;
@@ -23,7 +23,6 @@&lt;br/&gt;
 import org.apache.kafka.common.utils.Utils;&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.SessionWindow;&lt;br/&gt;
 import org.apache.kafka.streams.processor.internals.MockStreamsMetrics;&lt;br/&gt;
 import org.apache.kafka.streams.state.KeyValueIterator;&lt;br/&gt;
@@ -52,6 +51,7 @@&lt;br/&gt;
 import static org.junit.Assert.assertFalse;&lt;br/&gt;
 import static org.junit.Assert.assertTrue;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;+// TODO: this test does not cover time window serdes&lt;br/&gt;
 public class RocksDBSegmentedBytesStoreTest {&lt;/p&gt;

&lt;p&gt;     private final long retention = 60000L;&lt;br/&gt;
@@ -279,15 +279,17 @@ public void shouldBeAbleToWriteToReInitializedStore() {&lt;br/&gt;
     }&lt;/p&gt;

&lt;p&gt;     private Bytes serializeKey(final Windowed&amp;lt;String&amp;gt; key) &lt;/p&gt;
{
-        return SessionKeySerde.toBinary(key, Serdes.String().serializer(), &quot;dummy&quot;);
+        return Bytes.wrap(SessionKeySchema.toBinary(key, Serdes.String().serializer(), &quot;dummy&quot;));
     }

&lt;p&gt;     private List&amp;lt;KeyValue&amp;lt;Windowed&amp;lt;String&amp;gt;, Long&amp;gt;&amp;gt; toList(final KeyValueIterator&amp;lt;Bytes, byte[]&amp;gt; iterator) {&lt;br/&gt;
         final List&amp;lt;KeyValue&amp;lt;Windowed&amp;lt;String&amp;gt;, Long&amp;gt;&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
         while (iterator.hasNext()) &lt;/p&gt;
{
             final KeyValue&amp;lt;Bytes, byte[]&amp;gt; next = iterator.next();
-            final KeyValue&amp;lt;Windowed&amp;lt;String&amp;gt;, Long&amp;gt; deserialized
-                    = KeyValue.pair(SessionKeySerde.from(next.key.get(), Serdes.String().deserializer(), &quot;dummy&quot;), Serdes.Long().deserializer().deserialize(&quot;&quot;, next.value));
+            final KeyValue&amp;lt;Windowed&amp;lt;String&amp;gt;, Long&amp;gt; deserialized = KeyValue.pair(
+                    SessionKeySchema.from(next.key.get(), Serdes.String().deserializer(), &quot;dummy&quot;),
+                    Serdes.Long().deserializer().deserialize(&quot;dummy&quot;, next.value)
+            );
             results.add(deserialized);
         }
&lt;p&gt;         return results;&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBWindowStoreTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBWindowStoreTest.java&lt;br/&gt;
index a7a978a8d75..c745e702b09 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBWindowStoreTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/RocksDBWindowStoreTest.java&lt;br/&gt;
@@ -888,9 +888,10 @@ private void putSecondBatch(final WindowStore&amp;lt;Integer, String&amp;gt; store, final long&lt;br/&gt;
         HashMap&amp;lt;Integer, Set&amp;lt;String&amp;gt;&amp;gt; entriesByKey = new HashMap&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;         for (KeyValue&amp;lt;byte[], byte[]&amp;gt; entry : changeLog) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;long timestamp = WindowStoreUtils.timestampFromBinaryKey(entry.key);&lt;/li&gt;
	&lt;li&gt;Integer key = WindowStoreUtils.keyFromBinaryKey(entry.key, serdes);&lt;/li&gt;
	&lt;li&gt;String value = entry.value == null ? null : serdes.valueFrom(entry.value);&lt;br/&gt;
+            final long timestamp = WindowKeySchema.extractStoreTimestamp(entry.key);&lt;br/&gt;
+&lt;br/&gt;
+            final Integer key = WindowKeySchema.extractStoreKey(entry.key, serdes);&lt;br/&gt;
+            final String value = entry.value == null ? null : serdes.valueFrom(entry.value);&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;             Set&amp;lt;String&amp;gt; entries = entriesByKey.get(key);&lt;br/&gt;
             if (entries == null) &lt;/p&gt;
{
@@ -907,7 +908,7 @@ private void putSecondBatch(final WindowStore&amp;lt;Integer, String&amp;gt; store, final long
         return windowedPair(key, value, timestamp, windowSize);
     }

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private &amp;lt;K, V&amp;gt; KeyValue&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; windowedPair(K key, V value, long timestamp, long windowSize) {&lt;/li&gt;
	&lt;li&gt;return KeyValue.pair(new Windowed&amp;lt;&amp;gt;(key, WindowStoreUtils.timeWindowForSize(timestamp, windowSize)), value);&lt;br/&gt;
+    private static &amp;lt;K, V&amp;gt; KeyValue&amp;lt;Windowed&amp;lt;K&amp;gt;, V&amp;gt; windowedPair(K key, V value, long timestamp, long windowSize) 
{
+        return KeyValue.pair(new Windowed&amp;lt;&amp;gt;(key, WindowKeySchema.timeWindowForSize(timestamp, windowSize)), value);
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/SegmentedCacheFunctionTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/SegmentedCacheFunctionTest.java&lt;br/&gt;
index 2b6d0577871..29cdf11c862 100644&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/SegmentedCacheFunctionTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/SegmentedCacheFunctionTest.java&lt;br/&gt;
@@ -18,6 +18,7 @@&lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
+&lt;br/&gt;
 import org.junit.Test;&lt;/p&gt;

&lt;p&gt; import java.nio.ByteBuffer;&lt;br/&gt;
@@ -25,12 +26,13 @@&lt;br/&gt;
 import static org.hamcrest.MatcherAssert.assertThat;&lt;br/&gt;
 import static org.hamcrest.core.IsEqual.equalTo;&lt;/p&gt;

&lt;p&gt;+// TODO: this test coverage does not consider session serde yet&lt;br/&gt;
 public class SegmentedCacheFunctionTest {&lt;/p&gt;

&lt;p&gt;     private static final int SEGMENT_INTERVAL = 17;&lt;br/&gt;
     private static final int TIMESTAMP = 736213517;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private static final Bytes THE_KEY = WindowStoreUtils.toBinaryKey(new byte[]
{0xA, 0xB, 0xC}, TIMESTAMP, 42);&lt;br/&gt;
+    private static final Bytes THE_KEY = WindowKeySchema.toStoreKeyBinary(new byte[]{0xA, 0xB, 0xC}
&lt;p&gt;, TIMESTAMP, 42);&lt;br/&gt;
     private final static Bytes THE_CACHE_KEY = Bytes.wrap(&lt;br/&gt;
         ByteBuffer.allocate(8 + THE_KEY.get().length)&lt;br/&gt;
             .putLong(TIMESTAMP / SEGMENT_INTERVAL)&lt;br/&gt;
@@ -84,7 +86,7 @@ public void compareSegmentedKeys() {&lt;br/&gt;
             ) == 0&lt;br/&gt;
         );&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Bytes sameKeyInPriorSegment = WindowStoreUtils.toBinaryKey(new byte[]
{0xA, 0xB, 0xC}, 1234, 42);&lt;br/&gt;
+        final Bytes sameKeyInPriorSegment = WindowKeySchema.toStoreKeyBinary(new byte[]{0xA, 0xB, 0xC}
&lt;p&gt;, 1234, 42);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         assertThat(&lt;br/&gt;
             &quot;same keys in different segments should be ordered according to segment&quot;,&lt;br/&gt;
@@ -102,7 +104,7 @@ public void compareSegmentedKeys() {&lt;br/&gt;
             ) &amp;gt; 0&lt;br/&gt;
         );&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final Bytes lowerKeyInSameSegment = WindowStoreUtils.toBinaryKey(new byte[]
{0xA, 0xB, 0xB}, TIMESTAMP - 1, 0);&lt;br/&gt;
+        final Bytes lowerKeyInSameSegment = WindowKeySchema.toStoreKeyBinary(new byte[]{0xA, 0xB, 0xB}
&lt;p&gt;, TIMESTAMP - 1, 0);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         assertThat(&lt;br/&gt;
             &quot;different keys in same segments should be ordered according to key&quot;,&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/SessionKeySchemaTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/SessionKeySchemaTest.java&lt;br/&gt;
index 3b731f93449..68527218796 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/SessionKeySchemaTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/SessionKeySchemaTest.java&lt;br/&gt;
@@ -17,10 +17,13 @@&lt;/p&gt;

&lt;p&gt; package org.apache.kafka.streams.state.internals;&lt;/p&gt;

&lt;p&gt;+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.WindowedSerdes;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.internals.SessionWindow;&lt;br/&gt;
 import org.apache.kafka.test.KeyValueIteratorStub;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
@@ -32,21 +35,34 @@&lt;/p&gt;

&lt;p&gt; import static org.hamcrest.MatcherAssert.assertThat;&lt;br/&gt;
 import static org.hamcrest.core.IsEqual.equalTo;&lt;br/&gt;
+import static org.junit.Assert.assertArrayEquals;&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertNull;&lt;/p&gt;

&lt;p&gt; public class SessionKeySchemaTest {&lt;/p&gt;

&lt;p&gt;+    private final String key = &quot;key&quot;;&lt;br/&gt;
+    private final String topic = &quot;topic&quot;;&lt;br/&gt;
+    private final long startTime = 50L;&lt;br/&gt;
+    private final long endTime = 100L;&lt;br/&gt;
+    private final Serde&amp;lt;String&amp;gt; serde = Serdes.String();&lt;br/&gt;
+&lt;br/&gt;
+    private final Window window = new SessionWindow(startTime, endTime);&lt;br/&gt;
+    private final Windowed&amp;lt;String&amp;gt; windowedKey = new Windowed&amp;lt;&amp;gt;(key, window);&lt;br/&gt;
+    private final Serde&amp;lt;Windowed&amp;lt;String&amp;gt;&amp;gt; keySerde = new WindowedSerdes.SessionWindowedSerde&amp;lt;&amp;gt;(serde);&lt;br/&gt;
+&lt;br/&gt;
     private final SessionKeySchema sessionKeySchema = new SessionKeySchema();&lt;br/&gt;
     private DelegatingPeekingKeyValueIterator&amp;lt;Bytes, Integer&amp;gt; iterator;&lt;/p&gt;

&lt;p&gt;     @Before&lt;br/&gt;
     public void before() {&lt;br/&gt;
         sessionKeySchema.init(&quot;topic&quot;);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;final List&amp;lt;KeyValue&amp;lt;Bytes, Integer&amp;gt;&amp;gt; keys = Arrays.asList(KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]
{0, 0}), new SessionWindow(0, 0))), 1),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0}), new SessionWindow(0, 0))), 2),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0, 0}), new SessionWindow(0, 0))), 3),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0}), new SessionWindow(10, 20))), 4),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0}
&lt;p&gt;), new SessionWindow(10, 20))), 5),&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]
{0, 0, 0}), new SessionWindow(10, 20))), 6));&lt;br/&gt;
+        final List&amp;lt;KeyValue&amp;lt;Bytes, Integer&amp;gt;&amp;gt; keys = Arrays.asList(KeyValue.pair(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0}), new SessionWindow(0, 0)))), 1),&lt;br/&gt;
+                                                                  KeyValue.pair(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0}), new SessionWindow(0, 0)))), 2),&lt;br/&gt;
+                                                                  KeyValue.pair(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0, 0}
&lt;p&gt;), new SessionWindow(0, 0)))), 3),&lt;br/&gt;
+                                                                  KeyValue.pair(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]&lt;/p&gt;
{0}), new SessionWindow(10, 20)))), 4),&lt;br/&gt;
+                                                                  KeyValue.pair(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0}), new SessionWindow(10, 20)))), 5),&lt;br/&gt;
+                                                                  KeyValue.pair(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0, 0}), new SessionWindow(10, 20)))), 6));&lt;br/&gt;
         iterator = new DelegatingPeekingKeyValueIterator&amp;lt;&amp;gt;(&quot;foo&quot;, new KeyValueIteratorStub&amp;lt;&amp;gt;(keys.iterator()));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
@@ -78,29 +94,29 @@ public void testUpperBoundWithLargeTimestamps() {&lt;br/&gt;
 &lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;shorter key with max timestamp should be in range&quot;,&lt;br/&gt;
-            upper.compareTo(&lt;br/&gt;
-                SessionKeySerde.bytesToBinary(&lt;br/&gt;
+            upper.compareTo(Bytes.wrap(&lt;br/&gt;
+                    SessionKeySchema.toBinary(&lt;br/&gt;
                     new Windowed&amp;lt;&amp;gt;(&lt;br/&gt;
                         Bytes.wrap(new byte[]{0xA}),&lt;br/&gt;
                         new SessionWindow(Long.MAX_VALUE, Long.MAX_VALUE))&lt;br/&gt;
                 )&lt;br/&gt;
-            ) &amp;gt;= 0&lt;br/&gt;
+            )) &amp;gt;= 0&lt;br/&gt;
         );&lt;br/&gt;
 &lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;shorter key with max timestamp should be in range&quot;,&lt;br/&gt;
-            upper.compareTo(&lt;br/&gt;
-                SessionKeySerde.bytesToBinary(&lt;br/&gt;
+            upper.compareTo(Bytes.wrap(&lt;br/&gt;
+                    SessionKeySchema.toBinary(&lt;br/&gt;
                     new Windowed&amp;lt;&amp;gt;(&lt;br/&gt;
                         Bytes.wrap(new byte[]{0xA, 0xB}),&lt;br/&gt;
                         new SessionWindow(Long.MAX_VALUE, Long.MAX_VALUE))&lt;br/&gt;
                 )&lt;br/&gt;
-            ) &amp;gt;= 0&lt;br/&gt;
+            )) &amp;gt;= 0&lt;br/&gt;
         );&lt;br/&gt;
 &lt;br/&gt;
-        assertThat(upper, equalTo(SessionKeySerde.bytesToBinary(&lt;br/&gt;
+        assertThat(upper, equalTo(Bytes.wrap(SessionKeySchema.toBinary(&lt;br/&gt;
             new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0xA}), new SessionWindow(Long.MAX_VALUE, Long.MAX_VALUE))))&lt;br/&gt;
-        );&lt;br/&gt;
+        ));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     @Test&lt;br/&gt;
@@ -109,33 +125,33 @@ public void testUpperBoundWithKeyBytesLargerThanFirstTimestampByte() {&lt;br/&gt;
 &lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;shorter key with max timestamp should be in range&quot;,&lt;br/&gt;
-            upper.compareTo(&lt;br/&gt;
-                SessionKeySerde.bytesToBinary(&lt;br/&gt;
+            upper.compareTo(Bytes.wrap(&lt;br/&gt;
+                    SessionKeySchema.toBinary(&lt;br/&gt;
                     new Windowed&amp;lt;&amp;gt;(&lt;br/&gt;
                         Bytes.wrap(new byte[]{0xA, (byte) 0x8F}),&lt;br/&gt;
                         new SessionWindow(Long.MAX_VALUE, Long.MAX_VALUE))&lt;br/&gt;
                 )&lt;br/&gt;
-            ) &amp;gt;= 0&lt;br/&gt;
+            )) &amp;gt;= 0&lt;br/&gt;
         );&lt;br/&gt;
 &lt;br/&gt;
-        assertThat(upper, equalTo(SessionKeySerde.bytesToBinary(&lt;br/&gt;
+        assertThat(upper, equalTo(Bytes.wrap(SessionKeySchema.toBinary(&lt;br/&gt;
             new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0xA, (byte) 0x8F, (byte) 0x9F}), new SessionWindow(Long.MAX_VALUE, Long.MAX_VALUE))))&lt;br/&gt;
-        );&lt;br/&gt;
+        ));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     @Test&lt;br/&gt;
     public void testUpperBoundWithZeroTimestamp() {&lt;br/&gt;
         Bytes upper = sessionKeySchema.upperRange(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}), 0);&lt;br/&gt;
 &lt;br/&gt;
-        assertThat(upper, equalTo(SessionKeySerde.bytesToBinary(&lt;br/&gt;
+        assertThat(upper, equalTo(Bytes.wrap(SessionKeySchema.toBinary(&lt;br/&gt;
             new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}), new SessionWindow(0, 0))))&lt;br/&gt;
-        );&lt;br/&gt;
+        ));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     @Test&lt;br/&gt;
     public void testLowerBoundWithZeroTimestamp() {&lt;br/&gt;
         Bytes lower = sessionKeySchema.lowerRange(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}), 0);&lt;br/&gt;
-        assertThat(lower, equalTo(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}), new SessionWindow(0, 0)))));&lt;br/&gt;
+        assertThat(lower, equalTo(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}), new SessionWindow(0, 0))))));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     @Test&lt;br/&gt;
@@ -144,18 +160,84 @@ public void testLowerBoundMatchesTrailingZeros() {&lt;br/&gt;
 &lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;appending zeros to key should still be in range&quot;,&lt;br/&gt;
-            lower.compareTo(&lt;br/&gt;
-                SessionKeySerde.bytesToBinary(&lt;br/&gt;
+            lower.compareTo(Bytes.wrap(&lt;br/&gt;
+                    SessionKeySchema.toBinary(&lt;br/&gt;
                     new Windowed&amp;lt;&amp;gt;(&lt;br/&gt;
                         Bytes.wrap(new byte[]{0xA, 0xB, 0xC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}),&lt;br/&gt;
                         new SessionWindow(Long.MAX_VALUE, Long.MAX_VALUE))&lt;br/&gt;
                 )&lt;br/&gt;
-            ) &amp;lt; 0&lt;br/&gt;
+            )) &amp;lt; 0&lt;br/&gt;
         );&lt;br/&gt;
 &lt;br/&gt;
-        assertThat(lower, equalTo(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}), new SessionWindow(0, 0)))));&lt;br/&gt;
+        assertThat(lower, equalTo(Bytes.wrap(SessionKeySchema.toBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}), new SessionWindow(0, 0))))));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldSerializeDeserialize() {
+        final byte[] bytes = keySerde.serializer().serialize(topic, windowedKey);
+        final Windowed&amp;lt;String&amp;gt; result = keySerde.deserializer().deserialize(topic, bytes);
+        assertEquals(windowedKey, result);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldSerializeNullToNull() {
+        assertNull(keySerde.serializer().serialize(topic, null));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldDeSerializeEmtpyByteArrayToNull() {
+        assertNull(keySerde.deserializer().deserialize(topic, new byte[0]));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldDeSerializeNullToNull() {
+        assertNull(keySerde.deserializer().deserialize(topic, null));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldConvertToBinaryAndBack() {
+        final byte[] serialized = SessionKeySchema.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
+        final Windowed&amp;lt;String&amp;gt; result = SessionKeySchema.from(serialized, Serdes.String().deserializer(), &quot;dummy&quot;);
+        assertEquals(windowedKey, result);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractEndTimeFromBinary() {
+        final byte[] serialized = SessionKeySchema.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
+        assertEquals(endTime, SessionKeySchema.extractEndTimestamp(serialized));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractStartTimeFromBinary() {
+        final byte[] serialized = SessionKeySchema.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
+        assertEquals(startTime, SessionKeySchema.extractStartTimestamp(serialized));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractWindowFromBindary() {
+        final byte[] serialized = SessionKeySchema.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
+        assertEquals(window, SessionKeySchema.extractWindow(serialized));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractKeyBytesFromBinary() {
+        final byte[] serialized = SessionKeySchema.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
+        assertArrayEquals(key.getBytes(), SessionKeySchema.extractKeyBytes(serialized));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractKeyFromBinary() {
+        final byte[] serialized = SessionKeySchema.toBinary(windowedKey, serde.serializer(), &quot;dummy&quot;);
+        assertEquals(windowedKey, SessionKeySchema.from(serialized, serde.deserializer(), &quot;dummy&quot;));
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractBytesKeyFromBinary() {
+        final Bytes bytesKey = Bytes.wrap(key.getBytes());
+        final Windowed&amp;lt;Bytes&amp;gt; windowedBytesKey = new Windowed&amp;lt;&amp;gt;(bytesKey, window);
+        final Bytes serialized = Bytes.wrap(SessionKeySchema.toBinary(windowedBytesKey));
+        assertEquals(windowedBytesKey, SessionKeySchema.from(serialized));
+    }&lt;br/&gt;
 &lt;br/&gt;
     private List&amp;lt;Integer&amp;gt; getValues(final HasNextCondition hasNextCondition) {&lt;br/&gt;
         final List&amp;lt;Integer&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/WindowKeySchemaTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/WindowKeySchemaTest.java&lt;br/&gt;
index d75cca0b94a..63214a17ad6 100644&lt;br/&gt;
&amp;#8212; a/streams/src/test/java/org/apache/kafka/streams/state/internals/WindowKeySchemaTest.java&lt;br/&gt;
+++ b/streams/src/test/java/org/apache/kafka/streams/state/internals/WindowKeySchemaTest.java&lt;br/&gt;
@@ -17,17 +17,25 @@&lt;br/&gt;
 &lt;br/&gt;
 package org.apache.kafka.streams.state.internals;&lt;br/&gt;
 &lt;br/&gt;
+import org.apache.kafka.common.serialization.Serde;&lt;br/&gt;
+import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
 import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
 import org.apache.kafka.streams.KeyValue;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.TimeWindowedDeserializer;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.Window;&lt;br/&gt;
 import org.apache.kafka.streams.kstream.Windowed;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionKeySerde;&lt;br/&gt;
-import org.apache.kafka.streams.kstream.internals.SessionWindow;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.WindowedSerdes;&lt;br/&gt;
+import org.apache.kafka.streams.kstream.internals.TimeWindow;&lt;br/&gt;
+import org.apache.kafka.streams.state.StateSerdes;&lt;br/&gt;
 import org.apache.kafka.test.KeyValueIteratorStub;&lt;br/&gt;
 import org.junit.Before;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
 &lt;br/&gt;
 import static org.hamcrest.MatcherAssert.assertThat;&lt;br/&gt;
 import static org.hamcrest.core.IsEqual.equalTo;&lt;br/&gt;
+import static org.junit.Assert.assertArrayEquals;&lt;br/&gt;
+import static org.junit.Assert.assertEquals;&lt;br/&gt;
+import static org.junit.Assert.assertNull;&lt;br/&gt;
 &lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
 import java.util.Arrays;&lt;br/&gt;
@@ -35,25 +43,39 @@&lt;br/&gt;
 &lt;br/&gt;
 public class WindowKeySchemaTest {&lt;br/&gt;
 &lt;br/&gt;
-    private final WindowKeySchema windowKeySchema = new WindowKeySchema();&lt;br/&gt;
-    private DelegatingPeekingKeyValueIterator&amp;lt;Bytes, Integer&amp;gt; iterator;&lt;br/&gt;
+    final private String key = &quot;key&quot;;&lt;br/&gt;
+    final private String topic = &quot;topic&quot;;&lt;br/&gt;
+    final private long startTime = 50L;&lt;br/&gt;
+    final private long endTime = 100L;&lt;br/&gt;
+    final private Serde&amp;lt;String&amp;gt; serde = Serdes.String();&lt;br/&gt;
+&lt;br/&gt;
+    final private Window window = new TimeWindow(startTime, endTime);&lt;br/&gt;
+    final private Windowed&amp;lt;String&amp;gt; windowedKey = new Windowed&amp;lt;&amp;gt;(key, window);&lt;br/&gt;
+    final private WindowKeySchema windowKeySchema = new WindowKeySchema();&lt;br/&gt;
+    final private Serde&amp;lt;Windowed&amp;lt;String&amp;gt;&amp;gt; keySerde = new WindowedSerdes.TimeWindowedSerde&amp;lt;&amp;gt;(serde);&lt;br/&gt;
+    final private StateSerdes&amp;lt;String, byte[]&amp;gt; stateSerdes = new StateSerdes&amp;lt;&amp;gt;(&quot;dummy&quot;, serde, Serdes.ByteArray());&lt;br/&gt;
 &lt;br/&gt;
     @Before&lt;br/&gt;
     public void before() {&lt;br/&gt;
         windowKeySchema.init(&quot;topic&quot;);&lt;br/&gt;
-        final List&amp;lt;KeyValue&amp;lt;Bytes, Integer&amp;gt;&amp;gt; keys = Arrays.asList(KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0}), new SessionWindow(0, 0))), 1),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0}
&lt;p&gt;), new SessionWindow(0, 0))), 2),&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]
{0, 0, 0}), new SessionWindow(0, 0))), 3),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0}), new SessionWindow(10, 20))), 4),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0}), new SessionWindow(10, 20))), 5),&lt;br/&gt;
-                                                                  KeyValue.pair(SessionKeySerde.bytesToBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0, 0}
&lt;p&gt;), new SessionWindow(10, 20))), 6));&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;iterator = new DelegatingPeekingKeyValueIterator&amp;lt;&amp;gt;(&quot;foo&quot;, new KeyValueIteratorStub&amp;lt;&amp;gt;(keys.iterator()));&lt;br/&gt;
     }&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
     @Test&lt;br/&gt;
     public void testHasNextConditionUsingNullKeys() {&lt;br/&gt;
+        final List&amp;lt;KeyValue&amp;lt;Bytes, Integer&amp;gt;&amp;gt; keys = Arrays.asList(&lt;br/&gt;
+                KeyValue.pair(WindowKeySchema.toStoreKeyBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]&lt;/p&gt;
{0, 0}), new TimeWindow(0, 1)), 0), 1),&lt;br/&gt;
+                KeyValue.pair(WindowKeySchema.toStoreKeyBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0}), new TimeWindow(0, 1)), 0), 2),&lt;br/&gt;
+                KeyValue.pair(WindowKeySchema.toStoreKeyBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0, 0}), new TimeWindow(0, 1)), 0), 3),&lt;br/&gt;
+                KeyValue.pair(WindowKeySchema.toStoreKeyBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0}), new TimeWindow(10, 20)), 4), 4),&lt;br/&gt;
+                KeyValue.pair(WindowKeySchema.toStoreKeyBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]{0, 0}
&lt;p&gt;), new TimeWindow(10, 20)), 5), 5),&lt;br/&gt;
+                KeyValue.pair(WindowKeySchema.toStoreKeyBinary(new Windowed&amp;lt;&amp;gt;(Bytes.wrap(new byte[]&lt;/p&gt;
{0, 0, 0}
&lt;p&gt;), new TimeWindow(10, 20)), 6), 6));&lt;br/&gt;
+        final DelegatingPeekingKeyValueIterator&amp;lt;Bytes, Integer&amp;gt; iterator = new DelegatingPeekingKeyValueIterator&amp;lt;&amp;gt;(&quot;foo&quot;, new KeyValueIteratorStub&amp;lt;&amp;gt;(keys.iterator()));&lt;br/&gt;
+&lt;br/&gt;
         final HasNextCondition hasNextCondition = windowKeySchema.hasNextCondition(null, null, 0, Long.MAX_VALUE);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Integer&amp;gt; results = getValues(hasNextCondition);&lt;br/&gt;
+        final List&amp;lt;Integer&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
+        while (hasNextCondition.hasNext(iterator)) 
{
+            results.add(iterator.next().value);
+        }
&lt;p&gt;         assertThat(results, equalTo(Arrays.asList(1, 2, 3, 4, 5, 6)));&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;@@ -64,7 +86,7 @@ public void testUpperBoundWithLargeTimestamps() {&lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;shorter key with max timestamp should be in range&quot;,&lt;br/&gt;
             upper.compareTo(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;WindowStoreUtils.toBinaryKey(&lt;br/&gt;
+                WindowKeySchema.toStoreKeyBinary(&lt;br/&gt;
                     new byte[]
{0xA},&lt;br/&gt;
                     Long.MAX_VALUE,&lt;br/&gt;
                     Integer.MAX_VALUE&lt;br/&gt;
@@ -75,7 +97,7 @@ public void testUpperBoundWithLargeTimestamps() {&lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;shorter key with max timestamp should be in range&quot;,&lt;br/&gt;
             upper.compareTo(&lt;br/&gt;
-                WindowStoreUtils.toBinaryKey(&lt;br/&gt;
+                WindowKeySchema.toStoreKeyBinary(&lt;br/&gt;
                     new byte[]{0xA, 0xB},&lt;br/&gt;
                     Long.MAX_VALUE,&lt;br/&gt;
                     Integer.MAX_VALUE&lt;br/&gt;
@@ -83,7 +105,7 @@ public void testUpperBoundWithLargeTimestamps() {&lt;br/&gt;
             ) &amp;gt;= 0&lt;br/&gt;
         );&lt;br/&gt;
 &lt;br/&gt;
-        assertThat(upper, equalTo(WindowStoreUtils.toBinaryKey(new byte[]{0xA}
&lt;p&gt;, Long.MAX_VALUE, Integer.MAX_VALUE)));&lt;br/&gt;
+        assertThat(upper, equalTo(WindowKeySchema.toStoreKeyBinary(new byte[]&lt;/p&gt;
{0xA}
&lt;p&gt;, Long.MAX_VALUE, Integer.MAX_VALUE)));&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;br/&gt;
@@ -93,7 +115,7 @@ public void testUpperBoundWithKeyBytesLargerThanFirstTimestampByte() {&lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;shorter key with max timestamp should be in range&quot;,&lt;br/&gt;
             upper.compareTo(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;WindowStoreUtils.toBinaryKey(&lt;br/&gt;
+                WindowKeySchema.toStoreKeyBinary(&lt;br/&gt;
                     new byte[]
{0xA, (byte) 0x8F}
&lt;p&gt;,&lt;br/&gt;
                     Long.MAX_VALUE,&lt;br/&gt;
                     Integer.MAX_VALUE&lt;br/&gt;
@@ -101,7 +123,7 @@ public void testUpperBoundWithKeyBytesLargerThanFirstTimestampByte() {&lt;br/&gt;
             ) &amp;gt;= 0&lt;br/&gt;
         );&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertThat(upper, equalTo(WindowStoreUtils.toBinaryKey(new byte[]
{0xA, (byte) 0x8F, (byte) 0x9F}, Long.MAX_VALUE, Integer.MAX_VALUE)));&lt;br/&gt;
+        assertThat(upper, equalTo(WindowKeySchema.toStoreKeyBinary(new byte[]{0xA, (byte) 0x8F, (byte) 0x9F}
&lt;p&gt;, Long.MAX_VALUE, Integer.MAX_VALUE)));&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;@@ -112,7 +134,7 @@ public void testUpperBoundWithKeyBytesLargerAndSmallerThanFirstTimestampByte() {&lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;shorter key with max timestamp should be in range&quot;,&lt;br/&gt;
             upper.compareTo(&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;WindowStoreUtils.toBinaryKey(&lt;br/&gt;
+                WindowKeySchema.toStoreKeyBinary(&lt;br/&gt;
                     new byte[]
{0xC, 0xC},&lt;br/&gt;
                     0x0AffffffffffffffL,&lt;br/&gt;
                     Integer.MAX_VALUE&lt;br/&gt;
@@ -120,25 +142,25 @@ public void testUpperBoundWithKeyBytesLargerAndSmallerThanFirstTimestampByte() {&lt;br/&gt;
             ) &amp;gt;= 0&lt;br/&gt;
         );&lt;br/&gt;
 &lt;br/&gt;
-        assertThat(upper, equalTo(WindowStoreUtils.toBinaryKey(new byte[]{0xC, 0xC}
&lt;p&gt;, 0x0AffffffffffffffL, Integer.MAX_VALUE)));&lt;br/&gt;
+        assertThat(upper, equalTo(WindowKeySchema.toStoreKeyBinary(new byte[]&lt;/p&gt;
{0xC, 0xC}
&lt;p&gt;, 0x0AffffffffffffffL, Integer.MAX_VALUE)));&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;br/&gt;
     public void testUpperBoundWithZeroTimestamp() {&lt;br/&gt;
         Bytes upper = windowKeySchema.upperRange(Bytes.wrap(new byte[]&lt;/p&gt;
{0xA, 0xB, 0xC}), 0);&lt;br/&gt;
-        assertThat(upper, equalTo(WindowStoreUtils.toBinaryKey(new byte[]{0xA, 0xB, 0xC}
&lt;p&gt;, 0, Integer.MAX_VALUE)));&lt;br/&gt;
+        assertThat(upper, equalTo(WindowKeySchema.toStoreKeyBinary(new byte[]&lt;/p&gt;
{0xA, 0xB, 0xC}, 0, Integer.MAX_VALUE)));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     @Test&lt;br/&gt;
     public void testLowerBoundWithZeroTimestamp() {&lt;br/&gt;
         Bytes lower = windowKeySchema.lowerRange(Bytes.wrap(new byte[]{0xA, 0xB, 0xC}
&lt;p&gt;), 0);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;assertThat(lower, equalTo(WindowStoreUtils.toBinaryKey(new byte[]
{0xA, 0xB, 0xC}, 0, 0)));&lt;br/&gt;
+        assertThat(lower, equalTo(WindowKeySchema.toStoreKeyBinary(new byte[]{0xA, 0xB, 0xC}
&lt;p&gt;, 0, 0)));&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;br/&gt;
     public void testLowerBoundWithMonZeroTimestamp() {&lt;br/&gt;
         Bytes lower = windowKeySchema.lowerRange(Bytes.wrap(new byte[]&lt;/p&gt;
{0xA, 0xB, 0xC}), 42);&lt;br/&gt;
-        assertThat(lower, equalTo(WindowStoreUtils.toBinaryKey(new byte[]{0xA, 0xB, 0xC}
&lt;p&gt;, 0, 0)));&lt;br/&gt;
+        assertThat(lower, equalTo(WindowKeySchema.toStoreKeyBinary(new byte[]&lt;/p&gt;
{0xA, 0xB, 0xC}, 0, 0)));&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     @Test&lt;br/&gt;
@@ -148,7 +170,7 @@ public void testLowerBoundMatchesTrailingZeros() {&lt;br/&gt;
         assertThat(&lt;br/&gt;
             &quot;appending zeros to key should still be in range&quot;,&lt;br/&gt;
             lower.compareTo(&lt;br/&gt;
-                WindowStoreUtils.toBinaryKey(&lt;br/&gt;
+                    WindowKeySchema.toStoreKeyBinary(&lt;br/&gt;
                         new byte[]{0xA, 0xB, 0xC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},&lt;br/&gt;
                         Long.MAX_VALUE - 1,&lt;br/&gt;
                         0&lt;br/&gt;
@@ -156,14 +178,89 @@ public void testLowerBoundMatchesTrailingZeros() {&lt;br/&gt;
             ) &amp;lt; 0&lt;br/&gt;
         );&lt;br/&gt;
 &lt;br/&gt;
-        assertThat(lower, equalTo(WindowStoreUtils.toBinaryKey(new byte[]{0xA, 0xB, 0xC}
&lt;p&gt;, 0, 0)));&lt;br/&gt;
+        assertThat(lower, equalTo(WindowKeySchema.toStoreKeyBinary(new byte[]&lt;/p&gt;
{0xA, 0xB, 0xC}
&lt;p&gt;, 0, 0)));&lt;br/&gt;
     }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;/li&gt;
	&lt;li&gt;private List&amp;lt;Integer&amp;gt; getValues(final HasNextCondition hasNextCondition) {&lt;/li&gt;
	&lt;li&gt;final List&amp;lt;Integer&amp;gt; results = new ArrayList&amp;lt;&amp;gt;();&lt;/li&gt;
	&lt;li&gt;while (hasNextCondition.hasNext(iterator)) 
{
-            results.add(iterator.next().value);
-        }&lt;/li&gt;
	&lt;li&gt;return results;&lt;br/&gt;
+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldSerializeDeserialize() 
{
+        final byte[] bytes = keySerde.serializer().serialize(topic, windowedKey);
+        final Windowed&amp;lt;String&amp;gt; result = keySerde.deserializer().deserialize(topic, bytes);
+        // TODO: fix this part as last bits of KAFKA-4468
+        assertEquals(new Windowed&amp;lt;&amp;gt;(key, new TimeWindow(startTime, Long.MAX_VALUE)), result);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void testSerializeDeserializeOverflowWindowSize() &lt;/p&gt;
{
+        final byte[] bytes = keySerde.serializer().serialize(topic, windowedKey);
+        final Windowed&amp;lt;String&amp;gt; result = new TimeWindowedDeserializer&amp;lt;&amp;gt;(serde.deserializer(), Long.MAX_VALUE - 1)
+                .deserialize(topic, bytes);
+        assertEquals(new Windowed&amp;lt;&amp;gt;(key, new TimeWindow(startTime, Long.MAX_VALUE)), result);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldSerializeDeserializeExpectedWindowSize() &lt;/p&gt;
{
+        final byte[] bytes = keySerde.serializer().serialize(topic, windowedKey);
+        final Windowed&amp;lt;String&amp;gt; result = new TimeWindowedDeserializer&amp;lt;&amp;gt;(serde.deserializer(), endTime - startTime)
+                .deserialize(topic, bytes);
+        assertEquals(windowedKey, result);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldSerializeNullToNull() &lt;/p&gt;
{
+        assertNull(keySerde.serializer().serialize(topic, null));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldDeSerializeEmtpyByteArrayToNull() &lt;/p&gt;
{
+        assertNull(keySerde.deserializer().deserialize(topic, new byte[0]));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldDeSerializeNullToNull() &lt;/p&gt;
{
+        assertNull(keySerde.deserializer().deserialize(topic, null));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldConvertToBinaryAndBack() &lt;/p&gt;
{
+        final Bytes serialized = WindowKeySchema.toStoreKeyBinary(windowedKey, 0, stateSerdes);
+        final Windowed&amp;lt;String&amp;gt; result = WindowKeySchema.fromStoreKey(serialized.get(), endTime - startTime, stateSerdes);
+        assertEquals(windowedKey, result);
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractEndTimeFromBinary() &lt;/p&gt;
{
+        final Bytes serialized = WindowKeySchema.toStoreKeyBinary(windowedKey, 0, stateSerdes);
+        assertEquals(0, WindowKeySchema.extractStoreSequence(serialized.get()));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractStartTimeFromBinary() &lt;/p&gt;
{
+        final Bytes serialized = WindowKeySchema.toStoreKeyBinary(windowedKey, 0, stateSerdes);
+        assertEquals(startTime, WindowKeySchema.extractStoreTimestamp(serialized.get()));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractWindowFromBindary() &lt;/p&gt;
{
+        final Bytes serialized = WindowKeySchema.toStoreKeyBinary(windowedKey, 0, stateSerdes);
+        assertEquals(window, WindowKeySchema.extractStoreWindow(serialized.get(), endTime - startTime));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractKeyBytesFromBinary() &lt;/p&gt;
{
+        final Bytes serialized = WindowKeySchema.toStoreKeyBinary(windowedKey, 0, stateSerdes);
+        assertArrayEquals(key.getBytes(), WindowKeySchema.extractStoreKeyBytes(serialized.get()));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractKeyFromBinary() &lt;/p&gt;
{
+        final Bytes serialized = WindowKeySchema.toStoreKeyBinary(windowedKey, 0, stateSerdes);
+        assertEquals(windowedKey, WindowKeySchema.fromStoreKey(serialized.get(), endTime - startTime, stateSerdes));
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Test&lt;br/&gt;
+    public void shouldExtractBytesKeyFromBinary() &lt;/p&gt;
{
+        final Windowed&amp;lt;Bytes&amp;gt; windowedBytesKey = new Windowed&amp;lt;&amp;gt;(Bytes.wrap(key.getBytes()), window);
+        final Bytes serialized = WindowKeySchema.toStoreKeyBinary(windowedBytesKey, 0);
+        assertEquals(windowedBytesKey, WindowKeySchema.fromStoreKey(serialized.get(), endTime - startTime));
     }
&lt;p&gt; }&lt;br/&gt;
diff --git a/streams/src/test/java/org/apache/kafka/streams/state/internals/WindowStoreUtilsTest.java b/streams/src/test/java/org/apache/kafka/streams/state/internals/WindowStoreUtilsTest.java&lt;br/&gt;
deleted file mode 100644&lt;br/&gt;
index 91c89ec9540..00000000000&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;a/streams/src/test/java/org/apache/kafka/streams/state/internals/WindowStoreUtilsTest.java&lt;br/&gt;
+++ /dev/null&lt;br/&gt;
@@ -1,42 +0,0 @@&lt;br/&gt;
-/*&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;* Licensed to the Apache Software Foundation (ASF) under one or more&lt;/li&gt;
	&lt;li&gt;* contributor license agreements. See the NOTICE file distributed with&lt;/li&gt;
	&lt;li&gt;* this work for additional information regarding copyright ownership.&lt;/li&gt;
	&lt;li&gt;* The ASF licenses this file to You under the Apache License, Version 2.0&lt;/li&gt;
	&lt;li&gt;* (the &quot;License&quot;); you may not use this file except in compliance with&lt;/li&gt;
	&lt;li&gt;* the License. You may obtain a copy of the License at&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;* Unless required by applicable law or agreed to in writing, software&lt;/li&gt;
	&lt;li&gt;* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;/li&gt;
	&lt;li&gt;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;/li&gt;
	&lt;li&gt;* See the License for the specific language governing permissions and&lt;/li&gt;
	&lt;li&gt;* limitations under the License.&lt;/li&gt;
	&lt;li&gt;*/&lt;br/&gt;
-package org.apache.kafka.streams.state.internals;&lt;br/&gt;
-&lt;br/&gt;
-import org.apache.kafka.common.serialization.Serdes;&lt;br/&gt;
-import org.apache.kafka.common.utils.Bytes;&lt;br/&gt;
-import org.apache.kafka.streams.state.StateSerdes;&lt;br/&gt;
-import org.junit.Test;&lt;br/&gt;
-&lt;br/&gt;
-import static org.junit.Assert.assertEquals;&lt;br/&gt;
-&lt;br/&gt;
-public class WindowStoreUtilsTest {&lt;/li&gt;
	&lt;li&gt;protected StateSerdes&amp;lt;String, String&amp;gt; serdes = new StateSerdes&amp;lt;&amp;gt;(&quot;dummy&quot;, new Serdes.StringSerde(), new Serdes.StringSerde());&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testSerialization() 
{
-        final String key = &quot;key1&quot;;
-        final long timestamp = 99L;
-        final int seqNum = 3;
-        Bytes bytes = WindowStoreUtils.toBinaryKey(key, timestamp, seqNum, serdes);
-        final String parsedKey = WindowStoreUtils.keyFromBinaryKey(bytes.get(), serdes);
-        final long parsedTs = WindowStoreUtils.timestampFromBinaryKey(bytes.get());
-        final int parsedSeqNum = WindowStoreUtils.sequenceNumberFromBinaryKey(bytes.get());
-        assertEquals(key, parsedKey);
-        assertEquals(timestamp, parsedTs);
-        assertEquals(seqNum, parsedSeqNum);
-    }
&lt;p&gt;-}&lt;br/&gt;
\ No newline at end of file&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16394630" author="githubbot" created="Sun, 11 Mar 2018 20:22:37 +0000"  >&lt;p&gt;guozhangwang opened a new pull request #4686: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4831&quot; title=&quot;Extract WindowedSerde to public APIs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4831&quot;&gt;&lt;del&gt;KAFKA-4831&lt;/del&gt;&lt;/a&gt;: add documentation for KIP-265 &lt;span class=&quot;error&quot;&gt;&amp;#91;WIP&amp;#93;&lt;/span&gt;&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4686&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4686&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;   This is based on top of &lt;a href=&quot;https://github.com/apache/kafka/pull/4685&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4685&lt;/a&gt; so should only be merged after that one.&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;
	&lt;ol&gt;
		&lt;li&gt;
		&lt;ol&gt;
			&lt;li&gt;Committer Checklist (excluded from commit message)&lt;/li&gt;
		&lt;/ol&gt;
		&lt;/li&gt;
	&lt;/ol&gt;
	&lt;/li&gt;
&lt;/ol&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;[ ] Verify design and implementation&lt;/li&gt;
	&lt;li&gt;[ ] Verify test coverage and CI build status&lt;/li&gt;
	&lt;li&gt;[ ] Verify documentation (including upgrade notes)&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                            <comment id="16399672" author="githubbot" created="Thu, 15 Mar 2018 00:33:57 +0000"  >&lt;p&gt;guozhangwang closed pull request #4686: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-4831&quot; title=&quot;Extract WindowedSerde to public APIs&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-4831&quot;&gt;&lt;del&gt;KAFKA-4831&lt;/del&gt;&lt;/a&gt;: add documentation for KIP-265&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4686&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4686&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/docs/streams/upgrade-guide.html b/docs/streams/upgrade-guide.html&lt;br/&gt;
index f5c16c08cd2..46be969815a 100644&lt;br/&gt;
&amp;#8212; a/docs/streams/upgrade-guide.html&lt;br/&gt;
+++ b/docs/streams/upgrade-guide.html&lt;br/&gt;
@@ -79,7 +79,14 @@ &amp;lt;h3&amp;gt;&amp;lt;a id=&quot;streams_api_changes_120&quot; href=&quot;#streams_api_changes_120&quot;&amp;gt;Streams API&lt;br/&gt;
         For users who have customized window store implementations on the above interface, they&apos;d need to update their code to implement the newly added method as well.&lt;br/&gt;
         For more details, see &amp;lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/KIP-261%3A+Add+Single+Value+Fetch+in+Window+Stores&quot;&amp;gt;KIP-261&amp;lt;/a&amp;gt;.&lt;br/&gt;
     &amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;&lt;p&gt;+&lt;br/&gt;
+    &amp;lt;p&amp;gt;&lt;br/&gt;
+        We have added public &amp;lt;code&amp;gt;WindowedSerdes&amp;lt;/code&amp;gt; to allow users to read from / write to a topic storing windowed table changelogs directly.&lt;br/&gt;
+        In addition, in &amp;lt;code&amp;gt;StreamsConfig&amp;lt;/code&amp;gt; we have also added &amp;lt;code&amp;gt;default.windowed.key.serde.inner&amp;lt;/code&amp;gt; and &amp;lt;code&amp;gt;default.windowed.value.serde.inner&amp;lt;/code&amp;gt;&lt;br/&gt;
+        to let users specify inner serdes if the default serde classes are windowed serdes.&lt;br/&gt;
+        For more details, see &amp;lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/KIP-265%3A+Make+Windowed+Serde+to+public+APIs&quot;&amp;gt;KIP-265&amp;lt;/a&amp;gt;.&lt;br/&gt;
+    &amp;lt;/p&amp;gt;&lt;br/&gt;
+&lt;br/&gt;
     &amp;lt;h3&amp;gt;&amp;lt;a id=&quot;streams_api_changes_110&quot; href=&quot;#streams_api_changes_110&quot;&amp;gt;Streams API changes in 1.1.0&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;&lt;br/&gt;
     &amp;lt;p&amp;gt;&lt;br/&gt;
         We have added support for methods in &amp;lt;code&amp;gt;ReadOnlyWindowStore&amp;lt;/code&amp;gt; which allows for querying &amp;lt;code&amp;gt;WindowStore&amp;lt;/code&amp;gt;s without the necessity of providing keys.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310060">
                    <name>Container</name>
                                            <outwardlinks description="contains">
                                        <issuelink>
            <issuekey id="13140847">KAFKA-6592</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 35 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3at8v:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                            <customfield id="customfield_10022" key="com.atlassian.jira.plugin.system.customfieldtypes:userpicker">
                        <customfieldname>Reviewer</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>guozhang</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </customfields>
    </item>
</channel>
</rss>