<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Tue Nov 11 17:08:19 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[KAFKA-6658] Fix RoundTripWorkload and make k/v generation configurable</title>
                <link>https://issues.apache.org/jira/browse/KAFKA-6658</link>
                <project id="12311720" key="KAFKA">Kafka</project>
                    <description>&lt;p&gt;Fixes RoundTripWorkload. Currently RoundTripWorkload is unable to get the sequence number of the keys that it produced.&lt;/p&gt;

&lt;p&gt;Also, make PayloadGenerator an interface which can have multiple implementations: constant, uniform random, sequential, and allow different payload generators to be used for keys and values.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13145136">KAFKA-6658</key>
            <summary>Fix RoundTripWorkload and make k/v generation configurable</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="5" iconUrl="https://issues.apache.org/jira/images/icons/statuses/resolved.png" description="A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.">Resolved</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="cmccabe">Colin McCabe</assignee>
                                    <reporter username="cmccabe">Colin McCabe</reporter>
                        <labels>
                    </labels>
                <created>Wed, 14 Mar 2018 18:50:48 +0000</created>
                <updated>Wed, 25 Apr 2018 09:43:11 +0000</updated>
                            <resolved>Fri, 16 Mar 2018 23:16:11 +0000</resolved>
                                                    <fixVersion>2.0.0</fixVersion>
                                    <component>system tests</component>
                    <component>unit tests</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16399101" author="cmccabe" created="Wed, 14 Mar 2018 18:51:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/kafka/pull/4710/files&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4710/files&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16403106" author="githubbot" created="Fri, 16 Mar 2018 23:15:52 +0000"  >&lt;p&gt;hachikuji closed pull request #4710: &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-6658&quot; title=&quot;Fix RoundTripWorkload and make k/v generation configurable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;KAFKA-6658&quot;&gt;&lt;del&gt;KAFKA-6658&lt;/del&gt;&lt;/a&gt;: Fix RoundTripWorkload and make k/v generation configurable&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/kafka/pull/4710&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/kafka/pull/4710&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;This is a PR merged from a forked repository.&lt;br/&gt;
As GitHub hides the original diff on merge, it is displayed below for&lt;br/&gt;
the sake of provenance:&lt;/p&gt;

&lt;p&gt;As this is a foreign pull request (from a fork), the diff is supplied&lt;br/&gt;
below (as it won&apos;t show otherwise due to GitHub magic):&lt;/p&gt;

&lt;p&gt;diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/ConstantPayloadGenerator.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/ConstantPayloadGenerator.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..d0c1c4862de&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/ConstantPayloadGenerator.java&lt;br/&gt;
@@ -0,0 +1,54 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.trogdor.workload;&lt;br/&gt;
+&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonCreator;&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonProperty;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * A PayloadGenerator which always generates a constant payload.&lt;br/&gt;
+ */&lt;br/&gt;
+public class ConstantPayloadGenerator implements PayloadGenerator {&lt;br/&gt;
+    private final int size;&lt;br/&gt;
+    private final byte[] value;&lt;br/&gt;
+&lt;br/&gt;
+    @JsonCreator&lt;br/&gt;
+    public ConstantPayloadGenerator(@JsonProperty(&quot;size&quot;) int size,&lt;br/&gt;
+                                    @JsonProperty(&quot;value&quot;) byte[] value) &lt;/p&gt;
{
+        this.size = size;
+        this.value = (value == null || value.length == 0) ? new byte[size] : value;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public int size() &lt;/p&gt;
{
+        return size;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public byte[] value() {
+        return value;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public byte[] generate(long position) {&lt;br/&gt;
+        byte[] next = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+        for (int i = 0; i &amp;lt; next.length; i += value.length) {
+            System.arraycopy(value, 0, next, i, Math.min(next.length - i, value.length));
+        }&lt;br/&gt;
+        return next;&lt;br/&gt;
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/PayloadGenerator.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/PayloadGenerator.java&lt;br/&gt;
index 9acd5fad2d7..4895f217672 100644&lt;br/&gt;
&amp;#8212; a/tools/src/main/java/org/apache/kafka/trogdor/workload/PayloadGenerator.java&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/PayloadGenerator.java&lt;br/&gt;
@@ -14,133 +14,34 @@&lt;br/&gt;
  * See the License for the specific language governing permissions and&lt;br/&gt;
  * limitations under the License.&lt;br/&gt;
  */&lt;br/&gt;
-package org.apache.kafka.trogdor.workload;&lt;br/&gt;
 &lt;br/&gt;
-import org.apache.kafka.clients.producer.ProducerRecord;&lt;br/&gt;
+package org.apache.kafka.trogdor.workload;&lt;br/&gt;
 &lt;br/&gt;
-import java.nio.ByteBuffer;&lt;br/&gt;
-import java.util.Arrays;&lt;br/&gt;
-import java.util.Random;&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonSubTypes;&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonTypeInfo;&lt;br/&gt;
 &lt;br/&gt;
 /**&lt;br/&gt;
- * Describes the payload for the producer record. Currently, it generates constant size values&lt;br/&gt;
- * and either null keys or constant size key (depending on requested key type). The generator&lt;br/&gt;
- * is deterministic &amp;#8211; two generator objects created with the same key type, message size, and&lt;br/&gt;
- * value divergence ratio (see `valueDivergenceRatio` description) will generate the same sequence&lt;br/&gt;
- * of key/value pairs.&lt;br/&gt;
+ * Generates byte arrays based on a position argument.&lt;br/&gt;
+ *&lt;br/&gt;
+ * The array generated at a given position should be the same no matter how many&lt;br/&gt;
+ * times generate() is invoked.  PayloadGenerator instances should be immutable&lt;br/&gt;
+ * and thread-safe.&lt;br/&gt;
  */&lt;br/&gt;
-public class PayloadGenerator {&lt;br/&gt;
-&lt;br/&gt;
-    public static final double DEFAULT_VALUE_DIVERGENCE_RATIO = 0.3;&lt;br/&gt;
-    public static final int DEFAULT_MESSAGE_SIZE = 512;&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * This is the ratio of how much each next value is different from the previous value. This&lt;br/&gt;
-     * is directly related to compression rate we will get. Example: 0.3 divergence ratio gets us&lt;br/&gt;
-     * about 0.3 - 0.45 compression rate with lz4.&lt;br/&gt;
-     */&lt;br/&gt;
-    private final double valueDivergenceRatio;&lt;br/&gt;
-    private final long baseSeed;&lt;br/&gt;
-    private long currentPosition;&lt;br/&gt;
-    private byte[] baseRecordValue;&lt;br/&gt;
-    private PayloadKeyType recordKeyType;&lt;br/&gt;
-    private Random random;&lt;br/&gt;
-&lt;br/&gt;
-    public PayloadGenerator() {
-        this(DEFAULT_MESSAGE_SIZE, PayloadKeyType.KEY_NULL, DEFAULT_VALUE_DIVERGENCE_RATIO);
-    }&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * Generator will generate null keys and values of size `messageSize`&lt;br/&gt;
-     * @param messageSize number of bytes used for key + value&lt;br/&gt;
-     */&lt;br/&gt;
-    public PayloadGenerator(int messageSize) {
-        this(messageSize, PayloadKeyType.KEY_NULL, DEFAULT_VALUE_DIVERGENCE_RATIO);
-    }&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * Generator will generate keys of given type and values of size &apos;messageSize&apos; - (key size).&lt;br/&gt;
-     * If the given key type requires more bytes than messageSize, then the resulting payload&lt;br/&gt;
-     * will be keys of size required for the given key type and 0-length values.&lt;br/&gt;
-     * @param messageSize number of bytes used for key + value&lt;br/&gt;
-     * @param keyType type of keys generated&lt;br/&gt;
-     */&lt;br/&gt;
-    public PayloadGenerator(int messageSize, PayloadKeyType keyType) {
-        this(messageSize, keyType, DEFAULT_VALUE_DIVERGENCE_RATIO);
-    }&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * Generator will generate keys of given type and values of size &apos;messageSize&apos; - (key size).&lt;br/&gt;
-     * If the given key type requires more bytes than messageSize, then the resulting payload&lt;br/&gt;
-     * will be keys of size required for the given key type and 0-length values.&lt;br/&gt;
-     * @param messageSize key + value size&lt;br/&gt;
-     * @param valueDivergenceRatio ratio of how much each next value is different from the previous&lt;br/&gt;
-     *                             value. Used to approximately control target compression rate (if&lt;br/&gt;
-     *                             compression is used).&lt;br/&gt;
-     */&lt;br/&gt;
-    public PayloadGenerator(int messageSize, PayloadKeyType keyType,&lt;br/&gt;
-                            double valueDivergenceRatio) {&lt;br/&gt;
-        this.baseSeed = 856;  // some random number, may later let pass seed to constructor&lt;br/&gt;
-        this.currentPosition = 0;&lt;br/&gt;
-        this.valueDivergenceRatio = valueDivergenceRatio;&lt;br/&gt;
-        this.random = new Random(this.baseSeed);&lt;br/&gt;
-&lt;br/&gt;
-        final int valueSize = (messageSize &amp;gt; keyType.maxSizeInBytes())&lt;br/&gt;
-                              ? messageSize - keyType.maxSizeInBytes() : 0;&lt;br/&gt;
-        this.baseRecordValue = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;valueSize&amp;#93;&lt;/span&gt;;&lt;br/&gt;
-        // initialize value with random bytes&lt;br/&gt;
-        for (int i = 0; i &amp;lt; baseRecordValue.length; ++i) {
-            baseRecordValue[i] = (byte) (random.nextInt(26) + 65);
-        }&lt;br/&gt;
-        this.recordKeyType = keyType;&lt;br/&gt;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * Returns current position of the payload generator.&lt;br/&gt;
-     */&lt;br/&gt;
-    public long position() {
-        return currentPosition;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * Creates record based on the current position, and increments current position.&lt;br/&gt;
-     */&lt;br/&gt;
-    public ProducerRecord&amp;lt;byte[], byte[]&amp;gt; nextRecord(String topicName) {
-        return nextRecord(topicName, currentPosition++);
-    }&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * Creates record based on the given position. Does not change the current position.&lt;br/&gt;
-     */&lt;br/&gt;
-    public ProducerRecord&amp;lt;byte[], byte[]&amp;gt; nextRecord(String topicName, long position) {&lt;br/&gt;
-        byte[] keyBytes = null;&lt;br/&gt;
-        if (recordKeyType == PayloadKeyType.KEY_MESSAGE_INDEX) {
-            keyBytes = ByteBuffer.allocate(recordKeyType.maxSizeInBytes()).putLong(position).array();
-        } else if (recordKeyType != PayloadKeyType.KEY_NULL) {
-            throw new UnsupportedOperationException(
-                &quot;PayloadGenerator does not know how to generate key for key type &quot; + recordKeyType);
-        }&lt;br/&gt;
-        return new ProducerRecord&amp;lt;&amp;gt;(topicName, keyBytes, nextValue(position));&lt;br/&gt;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    @Override&lt;br/&gt;
-    public String toString() {
-        return &quot;PayloadGenerator(recordKeySize=&quot; + recordKeyType.maxSizeInBytes()
-               + &quot;, recordValueSize=&quot; + baseRecordValue.length
-               + &quot;, valueDivergenceRatio=&quot; + valueDivergenceRatio + &quot;)&quot;;
-    }&lt;br/&gt;
-&lt;br/&gt;
-    /**&lt;br/&gt;
-     * Returns producer record value&lt;br/&gt;
-     */&lt;br/&gt;
-    private byte[] nextValue(long position) {
-        // set the seed based on the given position to make sure that the same value is generated
-        // for the same position.
-        random.setSeed(baseSeed + 31 * position + 1);
-        // randomize some of the payload to achieve expected compression rate
-        byte[] recordValue = Arrays.copyOf(baseRecordValue, baseRecordValue.length);
-        for (int i = 0; i &amp;lt; recordValue.length * valueDivergenceRatio; ++i)
-            recordValue[i] = (byte) (random.nextInt(26) + 65);
-        return recordValue;
-    }&lt;br/&gt;
+@JsonTypeInfo(use = JsonTypeInfo.Id.NAME,&lt;br/&gt;
+    include = JsonTypeInfo.As.PROPERTY,&lt;br/&gt;
+    property = &quot;type&quot;)&lt;br/&gt;
+@JsonSubTypes(value = {
+    @JsonSubTypes.Type(value = ConstantPayloadGenerator.class, name = &quot;constant&quot;),
+    @JsonSubTypes.Type(value = SequentialPayloadGenerator.class, name = &quot;sequential&quot;),
+    @JsonSubTypes.Type(value = UniformRandomPayloadGenerator.class, name = &quot;uniformRandom&quot;)
+    })&lt;br/&gt;
+public interface PayloadGenerator {
+    /**
+     * Generate a payload.
+     *
+     * @param position  The position to use to generate the payload
+     *
+     * @return          A new array object containing the payload.
+     */
+    byte[] generate(long position);
 }&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/PayloadIterator.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/PayloadIterator.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..a5f3baebcfc&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/PayloadIterator.java&lt;br/&gt;
@@ -0,0 +1,55 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.kafka.trogdor.workload;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Iterator;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * An iterator which wraps a PayloadGenerator.&lt;br/&gt;
+ */&lt;br/&gt;
+public final class PayloadIterator implements Iterator&amp;lt;byte[]&amp;gt; {&lt;br/&gt;
+    private final PayloadGenerator generator;&lt;br/&gt;
+    private long position = 0;&lt;br/&gt;
+&lt;br/&gt;
+    public PayloadIterator(PayloadGenerator generator) {
+        this.generator = generator;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public boolean hasNext() {
+        return true;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public synchronized byte[] next() {
+        return generator.generate(position++);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public void remove() {
+        throw new UnsupportedOperationException();
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public synchronized void seek(long position) {
+        this.position = position;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    public synchronized long position() {
+        return this.position;
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchSpec.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchSpec.java&lt;br/&gt;
index 3e05a53b764..a798e73a754 100644&lt;br/&gt;
&amp;#8212; a/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchSpec.java&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchSpec.java&lt;br/&gt;
@@ -37,7 +37,8 @@&lt;br/&gt;
     private final String bootstrapServers;&lt;br/&gt;
     private final int targetMessagesPerSec;&lt;br/&gt;
     private final int maxMessages;&lt;br/&gt;
-    private final int messageSize;&lt;br/&gt;
+    private final PayloadGenerator keyGenerator;&lt;br/&gt;
+    private final PayloadGenerator valueGenerator;&lt;br/&gt;
     private final Map&amp;lt;String, String&amp;gt; producerConf;&lt;br/&gt;
     private final int totalTopics;&lt;br/&gt;
     private final int activeTopics;&lt;br/&gt;
@@ -49,7 +50,8 @@ public ProduceBenchSpec(@JsonProperty(&quot;startMs&quot;) long startMs,&lt;br/&gt;
                          @JsonProperty(&quot;bootstrapServers&quot;) String bootstrapServers,&lt;br/&gt;
                          @JsonProperty(&quot;targetMessagesPerSec&quot;) int targetMessagesPerSec,&lt;br/&gt;
                          @JsonProperty(&quot;maxMessages&quot;) int maxMessages,&lt;br/&gt;
-                         @JsonProperty(&quot;messageSize&quot;) int messageSize,&lt;br/&gt;
+                         @JsonProperty(&quot;keyGenerator&quot;) PayloadGenerator keyGenerator,&lt;br/&gt;
+                         @JsonProperty(&quot;valueGenerator&quot;) PayloadGenerator valueGenerator,&lt;br/&gt;
                          @JsonProperty(&quot;producerConf&quot;) Map&amp;lt;String, String&amp;gt; producerConf,&lt;br/&gt;
                          @JsonProperty(&quot;totalTopics&quot;) int totalTopics,&lt;br/&gt;
                          @JsonProperty(&quot;activeTopics&quot;) int activeTopics) {&lt;br/&gt;
@@ -58,7 +60,10 @@ public ProduceBenchSpec(@JsonProperty(&quot;startMs&quot;) long startMs,&lt;br/&gt;
         this.bootstrapServers = (bootstrapServers == null) ? &quot;&quot; : bootstrapServers;&lt;br/&gt;
         this.targetMessagesPerSec = targetMessagesPerSec;&lt;br/&gt;
         this.maxMessages = maxMessages;&lt;br/&gt;
-        this.messageSize = (messageSize == 0) ? PayloadGenerator.DEFAULT_MESSAGE_SIZE : messageSize;&lt;br/&gt;
+        this.keyGenerator = keyGenerator == null ?&lt;br/&gt;
+            new SequentialPayloadGenerator(4, 0) : keyGenerator;&lt;br/&gt;
+        this.valueGenerator = valueGenerator == null ?&lt;br/&gt;
+            new ConstantPayloadGenerator(512, new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;) : valueGenerator;&lt;br/&gt;
         this.producerConf = (producerConf == null) ? new TreeMap&amp;lt;String, String&amp;gt;() : producerConf;&lt;br/&gt;
         this.totalTopics = totalTopics;&lt;br/&gt;
         this.activeTopics = activeTopics;&lt;br/&gt;
@@ -85,8 +90,13 @@ public int maxMessages() {&lt;br/&gt;
     }&lt;br/&gt;
 &lt;br/&gt;
     @JsonProperty&lt;br/&gt;
-    public int messageSize() {&lt;br/&gt;
-        return messageSize;&lt;br/&gt;
+    public PayloadGenerator keyGenerator() {
+        return keyGenerator;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public PayloadGenerator valueGenerator() {
+        return valueGenerator;
     }&lt;br/&gt;
 &lt;br/&gt;
     @JsonProperty&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchWorker.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchWorker.java&lt;br/&gt;
index 1bd386d1e3f..51f52d30aae 100644&lt;br/&gt;
&amp;#8212; a/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchWorker.java&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/ProduceBenchWorker.java&lt;br/&gt;
@@ -91,7 +91,7 @@ public void start(Platform platform, AtomicReference&amp;lt;String&amp;gt; status,&lt;br/&gt;
         if (!running.compareAndSet(false, true)) {
             throw new IllegalStateException(&quot;ProducerBenchWorker is already running.&quot;);
         }&lt;br/&gt;
-        log.info(&quot;{}: Activating ProduceBenchWorker.&quot;, id);&lt;br/&gt;
+        log.info(&quot;{}: Activating ProduceBenchWorker with {}&quot;, id, spec);&lt;br/&gt;
         this.executor = Executors.newScheduledThreadPool(1,&lt;br/&gt;
             ThreadUtils.createThreadFactory(&quot;ProduceBenchWorkerThread%d&quot;, false));&lt;br/&gt;
         this.status = status;&lt;br/&gt;
@@ -172,7 +172,9 @@ protected synchronized void delay(long amount) throws InterruptedException {&lt;br/&gt;
 &lt;br/&gt;
         private final KafkaProducer&amp;lt;byte[], byte[]&amp;gt; producer;&lt;br/&gt;
 &lt;br/&gt;
-        private final PayloadGenerator payloadGenerator;&lt;br/&gt;
+        private final PayloadIterator keys;&lt;br/&gt;
+&lt;br/&gt;
+        private final PayloadIterator values;&lt;br/&gt;
 &lt;br/&gt;
         private final Throttle throttle;&lt;br/&gt;
 &lt;br/&gt;
@@ -187,7 +189,8 @@ protected synchronized void delay(long amount) throws InterruptedException {
                 props.setProperty(entry.getKey(), entry.getValue());
             }&lt;br/&gt;
             this.producer = new KafkaProducer&amp;lt;&amp;gt;(props, new ByteArraySerializer(), new ByteArraySerializer());&lt;br/&gt;
-            this.payloadGenerator = new PayloadGenerator(spec.messageSize());&lt;br/&gt;
+            this.keys = new PayloadIterator(spec.keyGenerator());&lt;br/&gt;
+            this.values = new PayloadIterator(spec.valueGenerator());&lt;br/&gt;
             this.throttle = new SendRecordsThrottle(perPeriod, producer);&lt;br/&gt;
         }&lt;br/&gt;
 &lt;br/&gt;
@@ -199,8 +202,10 @@ public Void call() throws Exception {&lt;br/&gt;
                 try {&lt;br/&gt;
                     for (int m = 0; m &amp;lt; spec.maxMessages(); m++) {&lt;br/&gt;
                         for (int i = 0; i &amp;lt; spec.activeTopics(); i++) {
-                            ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = payloadGenerator.nextRecord(topicIndexToName(i));
-                            future = producer.send(record, new SendRecordsCallback(this, Time.SYSTEM.milliseconds()));
+                            ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = new ProducerRecord&amp;lt;byte[], byte[]&amp;gt;(
+                                topicIndexToName(i), 0, keys.next(), values.next());
+                            future = producer.send(record,
+                                new SendRecordsCallback(this, Time.SYSTEM.milliseconds()));
                         }&lt;br/&gt;
                         throttle.increment();&lt;br/&gt;
                     }&lt;br/&gt;
@@ -216,7 +221,6 @@ public Void call() throws Exception {&lt;br/&gt;
                 statusUpdaterFuture.cancel(false);&lt;br/&gt;
                 new StatusUpdater(histogram).run();&lt;br/&gt;
                 long curTimeMs = Time.SYSTEM.milliseconds();&lt;br/&gt;
-                log.info(&quot;Produced {}&quot;, payloadGenerator);&lt;br/&gt;
                 log.info(&quot;Sent {} total record(s) in {} ms.  status: {}&quot;,&lt;br/&gt;
                     histogram.summarize().numSamples(), curTimeMs - startTimeMs, status.get());&lt;br/&gt;
             }&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorker.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorker.java&lt;br/&gt;
index 5dfac1f6c72..1b9cb8f1af0 100644&lt;br/&gt;
&amp;#8212; a/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorker.java&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorker.java&lt;br/&gt;
@@ -43,6 +43,7 @@&lt;br/&gt;
 import org.slf4j.LoggerFactory;&lt;br/&gt;
 &lt;br/&gt;
 import java.nio.ByteBuffer;&lt;br/&gt;
+import java.nio.ByteOrder;&lt;br/&gt;
 import java.util.ArrayList;&lt;br/&gt;
 import java.util.Collections;&lt;br/&gt;
 import java.util.Iterator;&lt;br/&gt;
@@ -69,6 +70,8 @@&lt;br/&gt;
 &lt;br/&gt;
     private static final Logger log = LoggerFactory.getLogger(RoundTripWorker.class);&lt;br/&gt;
 &lt;br/&gt;
+    private static final PayloadGenerator KEY_GENERATOR = new SequentialPayloadGenerator(4, 0);&lt;br/&gt;
+&lt;br/&gt;
     private final ToReceiveTracker toReceiveTracker = new ToReceiveTracker();&lt;br/&gt;
 &lt;br/&gt;
     private final String id;&lt;br/&gt;
@@ -183,7 +186,6 @@ synchronized ToSendTrackerResult next() {
             int perPeriod = WorkerUtils.
                 perSecToPerPeriod(spec.targetMessagesPerSec(), THROTTLE_PERIOD_MS);
             this.throttle = new Throttle(perPeriod, THROTTLE_PERIOD_MS);
-            payloadGenerator = new PayloadGenerator(MESSAGE_SIZE, PayloadKeyType.KEY_MESSAGE_INDEX);
         }&lt;br/&gt;
 &lt;br/&gt;
         @Override&lt;br/&gt;
@@ -206,7 +208,9 @@ public void run() {&lt;br/&gt;
                     }&lt;br/&gt;
                     messagesSent++;&lt;br/&gt;
                     // we explicitly specify generator position based on message index&lt;br/&gt;
-                    ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = payloadGenerator.nextRecord(TOPIC_NAME, messageIndex);&lt;br/&gt;
+                    ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = new ProducerRecord(TOPIC_NAME, 0,&lt;br/&gt;
+                        KEY_GENERATOR.generate(messageIndex),&lt;br/&gt;
+                        spec.valueGenerator().generate(messageIndex));&lt;br/&gt;
                     producer.send(record, new Callback() {&lt;br/&gt;
                         @Override&lt;br/&gt;
                         public void onCompletion(RecordMetadata metadata, Exception exception) {&lt;br/&gt;
@@ -286,7 +290,7 @@ public void run() {&lt;br/&gt;
                         pollInvoked++;&lt;br/&gt;
                         ConsumerRecords&amp;lt;byte[], byte[]&amp;gt; records = consumer.poll(50);&lt;br/&gt;
                         for (ConsumerRecord&amp;lt;byte[], byte[]&amp;gt; record : records.records(TOPIC_NAME)) {&lt;br/&gt;
-                            int messageIndex = ByteBuffer.wrap(record.key()).getInt();&lt;br/&gt;
+                            int messageIndex = ByteBuffer.wrap(record.key()).order(ByteOrder.LITTLE_ENDIAN).getInt();&lt;br/&gt;
                             messagesReceived++;&lt;br/&gt;
                             if (toReceiveTracker.removePending(messageIndex)) {&lt;br/&gt;
                                 uniqueMessagesReceived++;&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorkloadSpec.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorkloadSpec.java&lt;br/&gt;
index 618c709dde0..00bd833c052 100644&lt;br/&gt;
&amp;#8212; a/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorkloadSpec.java&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/RoundTripWorkloadSpec.java&lt;br/&gt;
@@ -39,6 +39,7 @@&lt;br/&gt;
     private final String bootstrapServers;&lt;br/&gt;
     private final int targetMessagesPerSec;&lt;br/&gt;
     private final NavigableMap&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; partitionAssignments;&lt;br/&gt;
+    private final PayloadGenerator valueGenerator;&lt;br/&gt;
     private final int maxMessages;&lt;br/&gt;
 &lt;br/&gt;
     @JsonCreator&lt;br/&gt;
@@ -48,6 +49,7 @@ public RoundTripWorkloadSpec(@JsonProperty(&quot;startMs&quot;) long startMs,&lt;br/&gt;
              @JsonProperty(&quot;bootstrapServers&quot;) String bootstrapServers,&lt;br/&gt;
              @JsonProperty(&quot;targetMessagesPerSec&quot;) int targetMessagesPerSec,&lt;br/&gt;
              @JsonProperty(&quot;partitionAssignments&quot;) NavigableMap&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; partitionAssignments,&lt;br/&gt;
+             @JsonProperty(&quot;valueGenerator&quot;) PayloadGenerator valueGenerator,&lt;br/&gt;
              @JsonProperty(&quot;maxMessages&quot;) int maxMessages) {
         super(startMs, durationMs);
         this.clientNode = clientNode == null ? &quot;&quot; : clientNode;
@@ -55,6 +57,8 @@ public RoundTripWorkloadSpec(@JsonProperty(&quot;startMs&quot;) long startMs,
         this.targetMessagesPerSec = targetMessagesPerSec;
         this.partitionAssignments = partitionAssignments == null ?
             new TreeMap&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt;() : partitionAssignments;
+        this.valueGenerator = valueGenerator == null ?
+            new UniformRandomPayloadGenerator(32, 123, 10) : valueGenerator;
         this.maxMessages = maxMessages;
     }&lt;br/&gt;
 &lt;br/&gt;
@@ -78,6 +82,11 @@ public int targetMessagesPerSec() {
         return partitionAssignments;
     }&lt;br/&gt;
 &lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public PayloadGenerator valueGenerator() {
+        return valueGenerator;
+    }&lt;br/&gt;
+&lt;br/&gt;
     @JsonProperty&lt;br/&gt;
     public int maxMessages() {&lt;br/&gt;
         return maxMessages;&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/SequentialPayloadGenerator.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/SequentialPayloadGenerator.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..e0b785ade36&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/SequentialPayloadGenerator.java&lt;br/&gt;
@@ -0,0 +1,65 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+package org.apache.kafka.trogdor.workload;&lt;br/&gt;
+&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonCreator;&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonProperty;&lt;br/&gt;
+&lt;br/&gt;
+import java.nio.ByteBuffer;&lt;br/&gt;
+import java.nio.ByteOrder;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * A PayloadGenerator which generates a sequentially increasing payload.&lt;br/&gt;
+ *&lt;br/&gt;
+ * The generated number will wrap around to 0 after the maximum value is reached.&lt;br/&gt;
+ * Payloads bigger than 8 bytes will always just be padded with zeros after byte 8.&lt;br/&gt;
+ */&lt;br/&gt;
+public class SequentialPayloadGenerator implements PayloadGenerator {&lt;br/&gt;
+    private final int size;&lt;br/&gt;
+    private final long startOffset;&lt;br/&gt;
+    private final ByteBuffer buf;&lt;br/&gt;
+&lt;br/&gt;
+    @JsonCreator&lt;br/&gt;
+    public SequentialPayloadGenerator(@JsonProperty(&quot;size&quot;) int size,&lt;br/&gt;
+                                      @JsonProperty(&quot;offset&quot;) long startOffset) {
+        this.size = size;
+        this.startOffset = startOffset;
+        this.buf = ByteBuffer.allocate(8);
+        // Little-endian byte order allows us to support arbitrary lengths more easily,
+        // since the first byte is always the lowest-order byte.
+        this.buf.order(ByteOrder.LITTLE_ENDIAN);
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public int size() {+        return size;+    }
&lt;p&gt;+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public long startOffset() &lt;/p&gt;
{
+        return startOffset;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public synchronized byte[] generate(long position) &lt;/p&gt;
{
+        buf.clear();
+        buf.putLong(position + startOffset);
+        byte[] result = new byte[size];
+        System.arraycopy(buf.array(), 0, result, 0, Math.min(buf.array().length, result.length));
+        return result;
+    }
&lt;p&gt;+}&lt;br/&gt;
diff --git a/tools/src/main/java/org/apache/kafka/trogdor/workload/UniformRandomPayloadGenerator.java b/tools/src/main/java/org/apache/kafka/trogdor/workload/UniformRandomPayloadGenerator.java&lt;br/&gt;
new file mode 100644&lt;br/&gt;
index 00000000000..4642dcf18ae&lt;br/&gt;
&amp;#8212; /dev/null&lt;br/&gt;
+++ b/tools/src/main/java/org/apache/kafka/trogdor/workload/UniformRandomPayloadGenerator.java&lt;br/&gt;
@@ -0,0 +1,89 @@&lt;br/&gt;
+/*&lt;br/&gt;
+ * Licensed to the Apache Software Foundation (ASF) under one or more&lt;br/&gt;
+ * contributor license agreements. See the NOTICE file distributed with&lt;br/&gt;
+ * this work for additional information regarding copyright ownership.&lt;br/&gt;
+ * The ASF licenses this file to You under the Apache License, Version 2.0&lt;br/&gt;
+ * (the &quot;License&quot;); you may not use this file except in compliance with&lt;br/&gt;
+ * the License. You may obtain a copy of the License at&lt;br/&gt;
+ *&lt;br/&gt;
+ *    &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;br/&gt;
+ *&lt;br/&gt;
+ * Unless required by applicable law or agreed to in writing, software&lt;br/&gt;
+ * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,&lt;br/&gt;
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&lt;br/&gt;
+ * See the License for the specific language governing permissions and&lt;br/&gt;
+ * limitations under the License.&lt;br/&gt;
+ */&lt;br/&gt;
+&lt;br/&gt;
+package org.apache.kafka.trogdor.workload;&lt;br/&gt;
+&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonCreator;&lt;br/&gt;
+import com.fasterxml.jackson.annotation.JsonProperty;&lt;br/&gt;
+&lt;br/&gt;
+import java.util.Random;&lt;br/&gt;
+&lt;br/&gt;
+/**&lt;br/&gt;
+ * A PayloadGenerator which generates a uniform random payload.&lt;br/&gt;
+ *&lt;br/&gt;
+ * This generator generates pseudo-random payloads that can be reproduced from run to run.&lt;br/&gt;
+ * The guarantees are the same as those of java.util.Random.&lt;br/&gt;
+ *&lt;br/&gt;
+ * This payload generator also has the option to append padding bytes at the end of the payload.&lt;br/&gt;
+ * The padding bytes are always the same, no matter what the position is.  This is useful when&lt;br/&gt;
+ * simulating a partly-compressible stream of user data.&lt;br/&gt;
+ */&lt;br/&gt;
+public class UniformRandomPayloadGenerator implements PayloadGenerator {&lt;br/&gt;
+    private final int size;&lt;br/&gt;
+    private final long seed;&lt;br/&gt;
+    private final int padding;&lt;br/&gt;
+    private final Random random = new Random();&lt;br/&gt;
+    private final byte[] padBytes;&lt;br/&gt;
+    private final byte[] randomBytes;&lt;br/&gt;
+&lt;br/&gt;
+    @JsonCreator&lt;br/&gt;
+    public UniformRandomPayloadGenerator(@JsonProperty(&quot;size&quot;) int size,&lt;br/&gt;
+                                         @JsonProperty(&quot;seed&quot;) long seed,&lt;br/&gt;
+                                         @JsonProperty(&quot;padding&quot;) int padding) {&lt;br/&gt;
+        this.size = size;&lt;br/&gt;
+        this.seed = seed;&lt;br/&gt;
+        this.padding = padding;&lt;br/&gt;
+        if (padding &amp;lt; 0 || padding &amp;gt; size) &lt;/p&gt;
{
+            throw new RuntimeException(&quot;Invalid value &quot; + padding + &quot; for &quot; +
+                &quot;padding: the number of padding bytes must not be smaller than &quot; +
+                &quot;0 or greater than the total payload size.&quot;);
+        }
&lt;p&gt;+        this.padBytes = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;padding&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+        random.setSeed(seed);&lt;br/&gt;
+        random.nextBytes(padBytes);&lt;br/&gt;
+        this.randomBytes = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;size - padding&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+    }&lt;br/&gt;
+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public int size() &lt;/p&gt;
{
+        return size;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public long seed() &lt;/p&gt;
{
+        return seed;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @JsonProperty&lt;br/&gt;
+    public int padding() &lt;/p&gt;
{
+        return padding;
+    }
&lt;p&gt;+&lt;br/&gt;
+    @Override&lt;br/&gt;
+    public synchronized byte[] generate(long position) {&lt;br/&gt;
+        byte[] result = new byte&lt;span class=&quot;error&quot;&gt;&amp;#91;size&amp;#93;&lt;/span&gt;;&lt;br/&gt;
+        if (randomBytes.length &amp;gt; 0) &lt;/p&gt;
{
+            random.setSeed(seed + position);
+            random.nextBytes(randomBytes);
+            System.arraycopy(randomBytes, 0, result, 0, Math.min(randomBytes.length, result.length));
+        }
&lt;p&gt;+        if (padBytes.length &amp;gt; 0) &lt;/p&gt;
{
+            System.arraycopy(padBytes, 0, result, randomBytes.length, result.length - randomBytes.length);
+        }
&lt;p&gt;+        return result;&lt;br/&gt;
+    }&lt;br/&gt;
+}&lt;br/&gt;
diff --git a/tools/src/test/java/org/apache/kafka/trogdor/common/JsonSerializationTest.java b/tools/src/test/java/org/apache/kafka/trogdor/common/JsonSerializationTest.java&lt;br/&gt;
index 4e65d994da7..77a793236ea 100644&lt;br/&gt;
&amp;#8212; a/tools/src/test/java/org/apache/kafka/trogdor/common/JsonSerializationTest.java&lt;br/&gt;
+++ b/tools/src/test/java/org/apache/kafka/trogdor/common/JsonSerializationTest.java&lt;br/&gt;
@@ -49,9 +49,9 @@ public void testDeserializationDoesNotProduceNulls() throws Exception &lt;/p&gt;
{
         verify(new WorkerRunning(null, 0, null));
         verify(new WorkerStopping(null, 0, null));
         verify(new ProduceBenchSpec(0, 0, null, null,
-            0, 0, 0, null, 0, 0));
+            0, 0, null, null, null, 0, 0));
         verify(new RoundTripWorkloadSpec(0, 0, null, null,
-            0, null, 0));
+            0, null, null, 0));
         verify(new SampleTaskSpec(0, 0, 0, null));
     }

&lt;p&gt;diff --git a/tools/src/test/java/org/apache/kafka/trogdor/workload/PayloadGeneratorTest.java b/tools/src/test/java/org/apache/kafka/trogdor/workload/PayloadGeneratorTest.java&lt;br/&gt;
index d2954a5d4cc..25ef2e326b6 100644&lt;br/&gt;
&amp;#8212; a/tools/src/test/java/org/apache/kafka/trogdor/workload/PayloadGeneratorTest.java&lt;br/&gt;
+++ b/tools/src/test/java/org/apache/kafka/trogdor/workload/PayloadGeneratorTest.java&lt;br/&gt;
@@ -17,128 +17,126 @@&lt;/p&gt;

&lt;p&gt; package org.apache.kafka.trogdor.workload;&lt;/p&gt;

&lt;p&gt;-import org.apache.kafka.clients.producer.ProducerRecord;&lt;br/&gt;
+import org.junit.Rule;&lt;br/&gt;
 import org.junit.Test;&lt;br/&gt;
+import org.junit.rules.Timeout;&lt;/p&gt;

&lt;p&gt; import java.nio.ByteBuffer;&lt;br/&gt;
+import java.nio.ByteOrder;&lt;br/&gt;
 import java.util.Arrays;&lt;/p&gt;

&lt;p&gt;+import static org.junit.Assert.assertArrayEquals;&lt;br/&gt;
 import static org.junit.Assert.assertEquals;&lt;br/&gt;
-import static org.junit.Assert.assertNotEquals;&lt;br/&gt;
-import static org.junit.Assert.assertNull;&lt;br/&gt;
-import static org.junit.Assert.assertFalse;&lt;br/&gt;
-import static org.junit.Assert.assertTrue;&lt;/p&gt;


&lt;p&gt; public class PayloadGeneratorTest {&lt;br/&gt;
+    @Rule&lt;br/&gt;
+    final public Timeout globalTimeout = Timeout.millis(120000);&lt;/p&gt;

&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testGeneratorStartsAtPositionZero() {&lt;/li&gt;
	&lt;li&gt;PayloadGenerator payloadGenerator = new PayloadGenerator();&lt;/li&gt;
	&lt;li&gt;assertEquals(0, payloadGenerator.position());&lt;br/&gt;
+    public void testConstantPayloadGenerator() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+        byte[] alphabet = new byte[26];+        for (int i = 0; i &amp;lt; alphabet.length; i++) {
+            alphabet[i] = (byte) (&apos;a&apos; + i);
+        }+        byte[] expectedSuperset = new byte[512];+        for (int i = 0; i &amp;lt; expectedSuperset.length; i++) {
+            expectedSuperset[i] = (byte) (&apos;a&apos; + (i % 26));
+        }+        for (int i }&lt;/span&gt; &lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testDefaultPayload() {&lt;/li&gt;
	&lt;li&gt;final long numRecords = 262;&lt;/li&gt;
	&lt;li&gt;PayloadGenerator payloadGenerator = new PayloadGenerator();&lt;br/&gt;
-&lt;/li&gt;
	&lt;li&gt;// make sure that each time we produce a different value (except if compression rate is 0)&lt;/li&gt;
	&lt;li&gt;byte[] prevValue = null;&lt;/li&gt;
	&lt;li&gt;long expectedPosition = 0;&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; numRecords; i++) 
{
-            ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = payloadGenerator.nextRecord(&quot;test-topic&quot;);
-            assertNull(record.key());
-            assertEquals(PayloadGenerator.DEFAULT_MESSAGE_SIZE, record.value().length);
-            assertEquals(++expectedPosition, payloadGenerator.position());
-            assertFalse(&quot;Position &quot; + payloadGenerator.position(),
-                        Arrays.equals(prevValue, record.value()));
-            prevValue = record.value().clone();
-        }
&lt;p&gt;+    private static void assertArrayContains(byte[] expectedSuperset, byte[] actual) &lt;/p&gt;
{
+        byte[] expected = new byte[actual.length];
+        System.arraycopy(expectedSuperset, 0, expected, 0, expected.length);
+        assertArrayEquals(expected, actual);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testNullKeyTypeValueSizeIsMessageSize() {&lt;/li&gt;
	&lt;li&gt;final int size = 200;&lt;/li&gt;
	&lt;li&gt;PayloadGenerator payloadGenerator = new PayloadGenerator(size);&lt;/li&gt;
	&lt;li&gt;ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = payloadGenerator.nextRecord(&quot;test-topic&quot;);&lt;/li&gt;
	&lt;li&gt;assertNull(record.key());&lt;/li&gt;
	&lt;li&gt;assertEquals(size, record.value().length);&lt;br/&gt;
+    public void testSequentialPayloadGenerator() 
{
+        SequentialPayloadGenerator g4 = new SequentialPayloadGenerator(4, 1);
+        assertLittleEndianArrayEquals(1, g4.generate(0));
+        assertLittleEndianArrayEquals(2, g4.generate(1));
+
+        SequentialPayloadGenerator g8 = new SequentialPayloadGenerator(8, 0);
+        assertLittleEndianArrayEquals(0, g8.generate(0));
+        assertLittleEndianArrayEquals(1, g8.generate(1));
+        assertLittleEndianArrayEquals(123123123123L, g8.generate(123123123123L));
+
+        SequentialPayloadGenerator g2 = new SequentialPayloadGenerator(2, 0);
+        assertLittleEndianArrayEquals(0, g2.generate(0));
+        assertLittleEndianArrayEquals(1, g2.generate(1));
+        assertLittleEndianArrayEquals(1, g2.generate(1));
+        assertLittleEndianArrayEquals(1, g2.generate(131073));
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testKeyContainsGeneratorPosition() {&lt;/li&gt;
	&lt;li&gt;final long numRecords = 10;&lt;/li&gt;
	&lt;li&gt;final int size = 200;&lt;/li&gt;
	&lt;li&gt;PayloadGenerator generator = new PayloadGenerator(size, PayloadKeyType.KEY_MESSAGE_INDEX);&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; numRecords; i++) 
{
-            assertEquals(i, generator.position());
-            ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = generator.nextRecord(&quot;test-topic&quot;);
-            assertEquals(8, record.key().length);
-            assertEquals(size - 8, record.value().length);
-            assertEquals(&quot;i=&quot; + i, i, ByteBuffer.wrap(record.key()).getLong());
-        }
&lt;p&gt;+    private static void assertLittleEndianArrayEquals(long expected, byte[] actual) &lt;/p&gt;
{
+        byte[] longActual = new byte[8];
+        System.arraycopy(actual, 0, longActual, 0, Math.min(actual.length, longActual.length));
+        ByteBuffer buf = ByteBuffer.wrap(longActual).order(ByteOrder.LITTLE_ENDIAN);
+        assertEquals(expected, buf.getLong());
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testGeneratePayloadWithExplicitPosition() {&lt;/li&gt;
	&lt;li&gt;final int size = 200;&lt;/li&gt;
	&lt;li&gt;PayloadGenerator generator = new PayloadGenerator(size, PayloadKeyType.KEY_MESSAGE_INDEX);&lt;/li&gt;
	&lt;li&gt;int position = 2;&lt;/li&gt;
	&lt;li&gt;while (position &amp;lt; 5000000) {&lt;/li&gt;
	&lt;li&gt;ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = generator.nextRecord(&quot;test-topic&quot;, position);&lt;/li&gt;
	&lt;li&gt;assertEquals(8, record.key().length);&lt;/li&gt;
	&lt;li&gt;assertEquals(size - 8, record.value().length);&lt;/li&gt;
	&lt;li&gt;assertEquals(position, ByteBuffer.wrap(record.key()).getLong());&lt;/li&gt;
	&lt;li&gt;position = position * 64;&lt;br/&gt;
+    public void testUniformRandomPayloadGenerator() {&lt;br/&gt;
+        PayloadIterator iter = new PayloadIterator(&lt;br/&gt;
+            new UniformRandomPayloadGenerator(1234, 456, 0));&lt;br/&gt;
+        byte[] prev = iter.next();&lt;br/&gt;
+        for (int uniques = 0; uniques &amp;lt; 1000; ) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {+            byte[] cur = iter.next();+            assertEquals(prev.length, cur.length);+            if (!Arrays.equals(prev, cur)) {
+                uniques++;
+            }         }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;+        testReproducible(new UniformRandomPayloadGenerator(1234, 456, 0));&lt;br/&gt;
+        testReproducible(new UniformRandomPayloadGenerator(1, 0, 0));&lt;br/&gt;
+        testReproducible(new UniformRandomPayloadGenerator(10, 6, 5));&lt;br/&gt;
+        testReproducible(new UniformRandomPayloadGenerator(512, 123, 100));&lt;br/&gt;
     }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testSamePositionGeneratesSameKeyAndValue() 
{
-        final int size = 100;
-        PayloadGenerator generator = new PayloadGenerator(size, PayloadKeyType.KEY_MESSAGE_INDEX);
-        ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record1 = generator.nextRecord(&quot;test-topic&quot;);
-        assertEquals(1, generator.position());
-        ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record2 = generator.nextRecord(&quot;test-topic&quot;);
-        assertEquals(2, generator.position());
-        ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record3 = generator.nextRecord(&quot;test-topic&quot;, 0);
-        // position should not change if we generated record with specific position
-        assertEquals(2, generator.position());
-        assertFalse(&quot;Values at different positions should not match.&quot;,
-                    Arrays.equals(record1.value(), record2.value()));
-        assertFalse(&quot;Values at different positions should not match.&quot;,
-                    Arrays.equals(record3.value(), record2.value()));
-        assertTrue(&quot;Values at the same position should match.&quot;,
-                   Arrays.equals(record1.value(), record3.value()));
-    }
&lt;p&gt;-&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;@Test&lt;/li&gt;
	&lt;li&gt;public void testGeneratesDeterministicKeyValues() {&lt;/li&gt;
	&lt;li&gt;final long numRecords = 194;&lt;/li&gt;
	&lt;li&gt;final int size = 100;&lt;/li&gt;
	&lt;li&gt;PayloadGenerator generator1 = new PayloadGenerator(size, PayloadKeyType.KEY_MESSAGE_INDEX);&lt;/li&gt;
	&lt;li&gt;PayloadGenerator generator2 = new PayloadGenerator(size, PayloadKeyType.KEY_MESSAGE_INDEX);&lt;/li&gt;
	&lt;li&gt;for (int i = 0; i &amp;lt; numRecords; ++i) 
{
-            ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record1 = generator1.nextRecord(&quot;test-topic&quot;);
-            ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record2 = generator2.nextRecord(&quot;test-topic&quot;);
-            assertTrue(Arrays.equals(record1.value(), record2.value()));
-            assertTrue(Arrays.equals(record1.key(), record2.key()));
-        }
&lt;p&gt;+    private static void testReproducible(PayloadGenerator generator) &lt;/p&gt;
{
+        byte[] val = generator.generate(123);
+        generator.generate(456);
+        byte[] val2 = generator.generate(123);
+        assertArrayEquals(val, val2);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testTooSmallMessageSizeCreatesPayloadWithOneByteValues() {&lt;/li&gt;
	&lt;li&gt;PayloadGenerator payloadGenerator = new PayloadGenerator(2, PayloadKeyType.KEY_MESSAGE_INDEX);&lt;/li&gt;
	&lt;li&gt;ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record = payloadGenerator.nextRecord(&quot;test-topic&quot;, 877);&lt;/li&gt;
	&lt;li&gt;assertEquals(8, record.key().length);&lt;/li&gt;
	&lt;li&gt;assertEquals(0, record.value().length);&lt;br/&gt;
+    public void testUniformRandomPayloadGeneratorPaddingBytes() 
{
+        UniformRandomPayloadGenerator generator =
+            new UniformRandomPayloadGenerator(1000, 456, 100);
+        byte[] val1 = generator.generate(0);
+        byte[] val1End = new byte[100];
+        System.arraycopy(val1, 900, val1End, 0, 100);
+        byte[] val2 = generator.generate(100);
+        byte[] val2End = new byte[100];
+        System.arraycopy(val2, 900, val2End, 0, 100);
+        byte[] val3 = generator.generate(200);
+        byte[] val3End = new byte[100];
+        System.arraycopy(val3, 900, val3End, 0, 100);
+        assertArrayEquals(val1End, val2End);
+        assertArrayEquals(val1End, val3End);
     }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;     @Test&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public void testNextRecordGeneratesNewByteArrayForValue() {&lt;/li&gt;
	&lt;li&gt;PayloadGenerator payloadGenerator = new PayloadGenerator(2, PayloadKeyType.KEY_MESSAGE_INDEX);&lt;/li&gt;
	&lt;li&gt;ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record1 = payloadGenerator.nextRecord(&quot;test-topic&quot;, 877);&lt;/li&gt;
	&lt;li&gt;ProducerRecord&amp;lt;byte[], byte[]&amp;gt; record2 = payloadGenerator.nextRecord(&quot;test-topic&quot;, 877);&lt;/li&gt;
	&lt;li&gt;assertNotEquals(record1.value(), record2.value());&lt;br/&gt;
+    public void testPayloadIterator() 
{
+        final int expectedSize = 50;
+        PayloadIterator iter = new PayloadIterator(
+            new ConstantPayloadGenerator(expectedSize, new byte[0]));
+        final byte[] expected = new byte[expectedSize];
+        assertEquals(0, iter.position());
+        assertArrayEquals(expected, iter.next());
+        assertEquals(1, iter.position());
+        assertArrayEquals(expected, iter.next());
+        assertArrayEquals(expected, iter.next());
+        assertEquals(3, iter.position());
+        iter.seek(0);
+        assertEquals(0, iter.position());
     }
&lt;p&gt; }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;





&lt;p&gt;----------------------------------------------------------------&lt;br/&gt;
This is an automated message from the Apache Git Service.&lt;br/&gt;
To respond to the message, please log on GitHub and use the&lt;br/&gt;
URL above to go to the specific comment.&lt;/p&gt;

&lt;p&gt;For queries about this service, please contact Infrastructure at:&lt;br/&gt;
users@infra.apache.org&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 35 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3rayf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </customfields>
    </item>
</channel>
</rss>