{"url":"https://api.github.com/repos/square/dagger/issues/261","repository_url":"https://api.github.com/repos/square/dagger","labels_url":"https://api.github.com/repos/square/dagger/issues/261/labels{/name}","comments_url":"https://api.github.com/repos/square/dagger/issues/261/comments","events_url":"https://api.github.com/repos/square/dagger/issues/261/events","html_url":"https://github.com/square/dagger/issues/261","id":14949684,"node_id":"MDU6SXNzdWUxNDk0OTY4NA==","number":261,"title":"Multibinders don't have a way to bind a default empty set","user":{"login":"cgruber","id":331234,"node_id":"MDQ6VXNlcjMzMTIzNA==","avatar_url":"https://avatars.githubusercontent.com/u/331234?v=4","gravatar_id":"","url":"https://api.github.com/users/cgruber","html_url":"https://github.com/cgruber","followers_url":"https://api.github.com/users/cgruber/followers","following_url":"https://api.github.com/users/cgruber/following{/other_user}","gists_url":"https://api.github.com/users/cgruber/gists{/gist_id}","starred_url":"https://api.github.com/users/cgruber/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cgruber/subscriptions","organizations_url":"https://api.github.com/users/cgruber/orgs","repos_url":"https://api.github.com/users/cgruber/repos","events_url":"https://api.github.com/users/cgruber/events{/privacy}","received_events_url":"https://api.github.com/users/cgruber/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":true,"assignee":null,"assignees":[],"milestone":null,"comments":7,"created_at":"2013-05-30T16:32:09Z","updated_at":"2013-08-07T14:47:38Z","closed_at":"2013-08-07T14:47:38Z","author_association":"COLLABORATOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"### Problem\n\nIf someone makes a contribution to a set via\n\n``` java\n  @Provides(type=SET) Foo provideAFoo() {...}\n```\n\nthen someone can do this\n\n``` java\n  @Inject Set<Foo> foos;\n```\n\n... and all is well.  But what if someone wants to inject a set of Foos, where it is not clear whether or not someone will actually bind any Foos. An example would be ServiceManager from Guava.  It takes a `Set<Service>`, and this will fail if it is not present, but there is no way to guarantee that the empty set is to be made available even if nothing is bound. \n#### Guice approach\n\n``` java\n  class MyModule extends Module {\n    @Override void configure(Binder b) {\n      Multibinder.newSetBinder(b, Foo.class); // do nothing else.\n    }\n  }\n```\n\nGuice allows the declaration of the binding, with no contents because the way bindings are registered requires the creation of the set binding first, before additional contributions are made.  Dagger simply declares the contributions and implicitly creates the Set. \n### Possible Solutions\n#### Default Bindings\n\nThis is something @swankjesse and I talked about a long time ago - a sort of \"default binding.\"  That is, if there is nothing else bound in its place, use this.  This would work similarly to how overrides= works in a way, except that it's at the binding level, and the default is a normal binding.  But it's a way of providing a precedence order for a select number of duplicate bindings.  The precedence woudl naturally be bindings in overrides= modules beats other bindings, and normal bindings beat default bindings. \n\nNote, with this, multiple unique bindings at a given level (two defaults, or two normals, etc.) would be prohibited.  This would need to be rationalized with the multibinder infrastructure to ensure that an `@Provides(useByDefault=true, type=UNIQUE) Set<Foo> ...` could be properly unseated by one or more `@Provides(type=SET) Foo ...` bindings.\n\nIf we did this, we'd also want to make sure we have a decent visual representation for this in the .dot writer. \n##### Advantage: Multibinder declaration is still type-rich (Set<Foo<Bar<Baz>>>)\n#### Multiple value muiltibinders.\n\nThis would provide some way to contribute zero or more values to the set of a multibinder, but one would contribute zero values.  Some (possibly quite horrible) example might be\n\n``` java\n  @Provides(type=SET_VALUES) Set<Foo> provideFoos() { ... }\n```\n\nThis would contribute all values of Set<Foo> to the SetBinder for Set<Foo>.  However, one could return an empty Set<Foo>.  The SetBinding for Set<Foo> would then be bound, and just happen to have no elements if nothing else was bound.\n##### Advantage: Allows multiple values to be provided by a single module, computed late.\n#### Signal for the presence of a multibinder (possibly useful for other declarations)\n\nA signal would be made for noting the presence of a multibinder.  This could be an annotation on the module\n\n``` java\n  // Limitations... can't do complex types here.\n  @SetBinders(for = {Type1.class, Type2.class})\n```\n\n``` java\n  @Declares(type=SET) Set<Foo> declareSetBinderOfFoo() { throw new AssertionError(); }\n```\n\nHere, this mirrors a binding, but simply declares the binding, with no contents.\n### Conclusion\n\nOne way or another, we need to address the default binding problem, at least for multibinders.   THe three options above are actually not mutually exclusive, as they have other possible reasons for existing than declaring a multibinder for graph completeness, but they each could solve this particular problem.\n\nMy own preference is a default bindings approach.  It deals with a case where people in Guice have used Optional-Injection, is a healthy (I think) way to address the use of Dagger in the context of plugin infrastructures, and lets the graph be managed flexibly.  \n","closed_by":{"login":"cgruber","id":331234,"node_id":"MDQ6VXNlcjMzMTIzNA==","avatar_url":"https://avatars.githubusercontent.com/u/331234?v=4","gravatar_id":"","url":"https://api.github.com/users/cgruber","html_url":"https://github.com/cgruber","followers_url":"https://api.github.com/users/cgruber/followers","following_url":"https://api.github.com/users/cgruber/following{/other_user}","gists_url":"https://api.github.com/users/cgruber/gists{/gist_id}","starred_url":"https://api.github.com/users/cgruber/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/cgruber/subscriptions","organizations_url":"https://api.github.com/users/cgruber/orgs","repos_url":"https://api.github.com/users/cgruber/repos","events_url":"https://api.github.com/users/cgruber/events{/privacy}","received_events_url":"https://api.github.com/users/cgruber/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/square/dagger/issues/261/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/square/dagger/issues/261/timeline","performed_via_github_app":null,"state_reason":"completed"}