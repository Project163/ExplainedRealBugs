diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index f9f66ac7..d7990025 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -46,7 +46,14 @@ public @interface Provides {
      * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
      * immutable.
      */
-    SET
+    SET,
+
+    /**
+     * Like {@link #SET}, except the method's return type is {@code Set<T>}, where any values are
+     * contributed to the set. An example use is to provide a default empty set binding, which is
+     * otherwise not possible using {@link #SET}.
+     */
+    SET_VALUES;
   }
 
   Type type() default Type.UNIQUE;
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index efd821ff..9b94c78f 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -55,11 +55,16 @@ public final class SetBinding<T> extends Binding<Set<T>> {
     }
   }
 
-  @SuppressWarnings("unchecked") // Bindings<T> are the only thing added to contributors.
+  @SuppressWarnings("unchecked") // Only Binding<T> and Set<T> are added to contributors.
   @Override public Set<T> get() {
     Set<T> result = new LinkedHashSet<T>(contributors.size());
     for (Binding<?> contributor : contributors) {
-      result.add((T) contributor.get()); // Let runtime exceptions through.
+      Object contribution = contributor.get(); // Let runtime exceptions through.
+      if (contributor.provideKey.equals(provideKey)) {
+        result.addAll((Set<T>) contribution);
+      } else {
+        result.add((T) contribution);
+      }
     }
     return Collections.unmodifiableSet(result);
   }
diff --git a/core/src/test/java/dagger/InjectionTest.java b/core/src/test/java/dagger/InjectionTest.java
index 7fdb6093..09a5e58b 100644
--- a/core/src/test/java/dagger/InjectionTest.java
+++ b/core/src/test/java/dagger/InjectionTest.java
@@ -20,6 +20,7 @@ import dagger.internal.TestingLoader;
 import java.util.AbstractList;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.RandomAccess;
 import java.util.Set;
@@ -338,6 +339,50 @@ public final class InjectionTest {
     }
   }
 
+  @Test public void providesSet() {
+    final Set<A> set = Collections.emptySet();
+
+    class TestEntryPoint {
+      @Inject Set<A> set;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides Set<A> provideSet() {
+        return set;
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
+
+    assertThat(entryPoint.set).isSameAs(set);
+  }
+
+  @Test public void providesSetValues() {
+    final Set<A> set = Collections.emptySet();
+
+    class TestEntryPoint {
+      @Inject Set<A> set;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSet() {
+        return set;
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
+
+    // copies into immutable collection
+    assertThat(entryPoint.set).isNotSameAs(set);
+    assertThat(entryPoint.set).isEqualTo(set);
+  }
+
   @Test public void providerMethodsConflict() {
     @Module
     class TestModule {
@@ -356,7 +401,7 @@ public final class InjectionTest {
     }
   }
 
-  @Test public void providerMethodsConflictWithSet() {
+  @Test public void providesSetConflictsWithProvidesTypeSet() {
     @Module
     class TestModule {
       @Provides(type = Provides.Type.SET) A provideSetElement() {
@@ -374,6 +419,53 @@ public final class InjectionTest {
     }
   }
 
+  @Test public void providesSetConflictsWithProvidesTypeSetValues() {
+    @Module
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSetContribution() {
+        throw new AssertionError();
+      }
+      @Provides Set<A> provideSet() {
+        throw new AssertionError();
+      }
+    }
+
+    try {
+      ObjectGraph.createWith(new TestingLoader(), new TestModule());
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void providesSetOfProvidersIsDifferentThanProvidesTypeSetValues() {
+    final Set<A> set = Collections.emptySet();
+    final Set<Provider<A>> providers = Collections.emptySet();
+
+    class TestEntryPoint {
+      @Inject Set<A> set;
+      @Inject Set<Provider<A>> providers;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<A> provideSetContribution() {
+        return set;
+      }
+      @Provides Set<Provider<A>> provideProviders() {
+        return providers;
+      }
+    }
+
+    TestEntryPoint entryPoint = new TestEntryPoint();
+    TestModule module = new TestModule();
+    ObjectGraph.createWith(new TestingLoader(), module).inject(entryPoint);
+
+    // copies into immutable collection
+    assertThat(entryPoint.set).isNotSameAs(set);
+    assertThat(entryPoint.set).isEqualTo(set);
+    assertThat(entryPoint.providers).isSameAs(providers);
+  }
+
   @Test public void singletonsInjectedOnlyIntoProviders() {
     class TestEntryPoint {
       @Inject Provider<A> aProvider;
diff --git a/core/src/test/java/dagger/SetBindingTest.java b/core/src/test/java/dagger/SetBindingTest.java
index 1393ecc0..3960157a 100644
--- a/core/src/test/java/dagger/SetBindingTest.java
+++ b/core/src/test/java/dagger/SetBindingTest.java
@@ -32,6 +32,8 @@ import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
 import static dagger.Provides.Type.SET;
+import static dagger.Provides.Type.SET_VALUES;
+import static java.util.Collections.emptySet;
 import static org.fest.assertions.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
@@ -67,6 +69,10 @@ public final class SetBindingTest {
     @Module(injects = TestEntryPoint.class, includes = TestIncludesModule.class)
     class TestModule {
       @Provides(type=SET) String provideFirstString() { return "string1"; }
+
+      @Provides(type=SET_VALUES) Set<String> provideDefaultStrings() {
+        return emptySet();
+      }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
@@ -74,6 +80,30 @@ public final class SetBindingTest {
     assertEquals(set("string1", "string2"), ep.strings);
   }
 
+  @Test public void multiValueBindings_MultiModule_NestedSet() {
+    class TestEntryPoint {
+      @Inject Set<Set<String>> stringses;
+    }
+
+    @Module
+    class TestIncludesModule {
+      @Provides(type=SET) Set<String> provideSecondStrings() { return set("string2"); }
+    }
+
+    @Module(injects = TestEntryPoint.class, includes = TestIncludesModule.class)
+    class TestModule {
+      @Provides(type=SET) Set<String> provideFirstStrings() { return set("string1"); }
+
+      @Provides(type=SET_VALUES) Set<Set<String>> provideDefaultStringeses() {
+        return set(set("string3"));
+      }
+    }
+
+    TestEntryPoint ep = injectWithModule(new TestEntryPoint(),
+        new TestModule(), new TestIncludesModule());
+    assertEquals(set(set("string1"),set("string2"), set("string3")), ep.stringses);
+  }
+
   @Test public void multiValueBindings_WithSingletonAndDefaultValues() {
     final AtomicInteger singletonCounter = new AtomicInteger(100);
     final AtomicInteger defaultCounter = new AtomicInteger(200);
@@ -125,10 +155,14 @@ public final class SetBindingTest {
 
     @Module(injects = TestEntryPoint.class)
     class TestModule {
-      @Provides(type=SET) String provideString1() { return "string1"; }
+      @Provides(type=SET_VALUES) Set<String> provideString1() {
+        return set("string1");
+      }
       @Provides(type=SET) String provideString2() { return "string2"; }
       @Provides(type=SET) @Named("foo") String provideString3() { return "string3"; }
-      @Provides(type=SET) @Named("foo") String provideString4() { return "string4"; }
+      @Provides(type=SET_VALUES) @Named("foo") Set<String> provideString4() {
+        return set("string4");
+      }
     }
 
     TestEntryPoint ep = injectWithModule(new TestEntryPoint(), new TestModule());
@@ -189,6 +223,22 @@ public final class SetBindingTest {
     graph.validate();
   }
 
+  @Test public void validateEmptySetBinding() {
+    class TestEntryPoint {
+      @Inject Set<String> strings;
+    }
+
+    @Module(injects = TestEntryPoint.class)
+    class TestModule {
+      @Provides(type=SET_VALUES) Set<String> provideDefault() {
+        return emptySet();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    graph.validate();
+  }
+
   static class Logger {
     @Inject Set<LogSink> loggers;
     public void log(String text, Throwable error) {
diff --git a/core/src/test/java/dagger/UnusedProviderTest.java b/core/src/test/java/dagger/UnusedProviderTest.java
index 683c6dcd..7fa59d9f 100644
--- a/core/src/test/java/dagger/UnusedProviderTest.java
+++ b/core/src/test/java/dagger/UnusedProviderTest.java
@@ -20,6 +20,8 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
 
+import java.util.Set;
+
 import static org.junit.Assert.fail;
 
 @RunWith(JUnit4.class)
@@ -96,4 +98,20 @@ public class UnusedProviderTest {
     } catch (IllegalStateException expected) {
     }
   }
+
+  @Test public void unusedSetValuesBinding() throws Exception {
+    @Module
+    class TestModule {
+      @Provides(type = Provides.Type.SET_VALUES) Set<String> provideA() {
+        throw new AssertionError();
+      }
+    }
+
+    ObjectGraph graph = ObjectGraph.createWith(new TestingLoader(), new TestModule());
+    try {
+      graph.validate();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+  }
 }
diff --git a/core/src/test/java/dagger/internal/TestingModuleAdapter.java b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
index d1cf36d4..2819a5e5 100644
--- a/core/src/test/java/dagger/internal/TestingModuleAdapter.java
+++ b/core/src/test/java/dagger/internal/TestingModuleAdapter.java
@@ -85,7 +85,12 @@ public class TestingModuleAdapter<M> extends ModuleAdapter<M> {
               handleBindings(bindings, method, key, library);
               break;
             case SET:
-              handleSetBindings(bindings, method, key, library);
+              String setKey = Keys.getSetKey(method.getGenericReturnType(),
+                  method.getAnnotations(), method);
+              handleSetBindings(bindings, method, setKey, key, library);
+              break;
+            case SET_VALUES:
+              handleSetBindings(bindings, method, key, key, library);
               break;
             default:
               throw new AssertionError("Unknown @Provides type " + provides.type());
@@ -100,11 +105,9 @@ public class TestingModuleAdapter<M> extends ModuleAdapter<M> {
     bindings.put(key, new ProviderMethodBinding<M>(method, key, module, library));
   }
 
-  private void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String key,
-      boolean library) {
-    String setKey = Keys.getSetKey(method.getGenericReturnType(), method.getAnnotations(), method);
-    SetBinding.<M>add(bindings, setKey, new ProviderMethodBinding<M>(method, key, module,
-        library));
+  private void handleSetBindings(Map<String, Binding<?>> bindings, Method method, String setKey,
+      String providerKey, boolean library) {
+    SetBinding.<M>add(bindings, setKey, new ProviderMethodBinding<M>(method, providerKey, module, library));
   }
 
   @Override public M newModule() {
