diff --git a/src/main/java/com/squareup/javapoet/MethodSpec.java b/src/main/java/com/squareup/javapoet/MethodSpec.java
index fb95243..77a23d6 100644
--- a/src/main/java/com/squareup/javapoet/MethodSpec.java
+++ b/src/main/java/com/squareup/javapoet/MethodSpec.java
@@ -51,6 +51,7 @@ public final class MethodSpec {
   public final boolean varargs;
   public final List<TypeName> exceptions;
   public final CodeBlock code;
+  public final CodeBlock defaultValue;
 
   private MethodSpec(Builder builder) {
     CodeBlock code = builder.code.build();
@@ -68,6 +69,7 @@ public final class MethodSpec {
     this.parameters = Util.immutableList(builder.parameters);
     this.varargs = builder.varargs;
     this.exceptions = Util.immutableList(builder.exceptions);
+    this.defaultValue = builder.defaultValue;
     this.code = code;
   }
 
@@ -102,6 +104,12 @@ public final class MethodSpec {
     }
 
     codeWriter.emit(")");
+
+    if (defaultValue != null && !defaultValue.isEmpty()) {
+      codeWriter.emit(" default ");
+      codeWriter.emit(defaultValue);
+    }
+
     if (!exceptions.isEmpty()) {
       codeWriter.emit(" throws");
       boolean firstException = true;
@@ -214,6 +222,7 @@ public final class MethodSpec {
     private final List<TypeName> exceptions = new ArrayList<>();
     private final CodeBlock.Builder code = CodeBlock.builder();
     private boolean varargs;
+    private CodeBlock defaultValue;
 
     private Builder(String name) {
       checkArgument(name.equals(CONSTRUCTOR) || SourceVersion.isName(name),
@@ -328,6 +337,16 @@ public final class MethodSpec {
       return this;
     }
 
+    public Builder defaultValue(String format, Object... args) {
+      return defaultValue(CodeBlock.builder().add(format, args).build());
+    }
+
+    public Builder defaultValue(CodeBlock codeBlock) {
+      checkState(this.defaultValue == null, "defaultValue was already set");
+      this.defaultValue = checkNotNull(codeBlock, "codeBlock == null");
+      return this;
+    }
+
     /**
      * @param controlFlow the control flow construct and its code, such as "if (foo == 5)".
      * Shouldn't contain braces or newline characters.
diff --git a/src/main/java/com/squareup/javapoet/TypeSpec.java b/src/main/java/com/squareup/javapoet/TypeSpec.java
index d4faa4c..911c8b3 100644
--- a/src/main/java/com/squareup/javapoet/TypeSpec.java
+++ b/src/main/java/com/squareup/javapoet/TypeSpec.java
@@ -98,6 +98,10 @@ public final class TypeSpec {
         .build());
   }
 
+  public static Builder annotationBuilder(String name) {
+    return new Builder(Kind.ANNOTATION, checkNotNull(name, "name == null"), null);
+  }
+
   void emit(CodeWriter codeWriter, String enumName, Set<Modifier> implicitModifiers)
       throws IOException {
     // Nested classes interrupt wrapped line indentation. Stash the current wrapping state and put
@@ -126,7 +130,11 @@ public final class TypeSpec {
         codeWriter.emitJavadoc(javadoc);
         codeWriter.emitAnnotations(annotations, false);
         codeWriter.emitModifiers(modifiers, Util.union(implicitModifiers, kind.asMemberModifiers));
-        codeWriter.emit("$L $L", kind.name().toLowerCase(Locale.US), name);
+        if (kind == Kind.ANNOTATION) {
+          codeWriter.emit("$L $L", "@interface", name);
+        } else {
+          codeWriter.emit("$L $L", kind.name().toLowerCase(Locale.US), name);
+        }
         codeWriter.emitTypeVariables(typeVariables);
 
         List<TypeName> extendsTypes;
@@ -262,7 +270,13 @@ public final class TypeSpec {
         Collections.<Modifier>emptySet(),
         Collections.<Modifier>emptySet(),
         Collections.<Modifier>emptySet(),
-        Collections.singleton(Modifier.STATIC));
+        Collections.singleton(Modifier.STATIC)),
+
+    ANNOTATION(
+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)),
+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.ABSTRACT)),
+        Util.immutableSet(Arrays.asList(Modifier.PUBLIC, Modifier.STATIC)),
+        Util.immutableSet(Arrays.asList(Modifier.STATIC)));
 
     private final Set<Modifier> implicitFieldModifiers;
     private final Set<Modifier> implicitMethodModifiers;
@@ -424,6 +438,9 @@ public final class TypeSpec {
       checkArgument(methodSpec.modifiers.containsAll(kind.implicitMethodModifiers),
           "%s %s.%s requires modifiers %s", kind, name, methodSpec.name,
           kind.implicitMethodModifiers);
+      if (kind != Kind.ANNOTATION) {
+        checkState(methodSpec.defaultValue == null, "default method != null");
+      }
       methodSpecs.add(methodSpec);
       return this;
     }
diff --git a/src/test/java/com/squareup/javapoet/TypeSpecTest.java b/src/test/java/com/squareup/javapoet/TypeSpecTest.java
index 0b69215..c3d9508 100644
--- a/src/test/java/com/squareup/javapoet/TypeSpecTest.java
+++ b/src/test/java/com/squareup/javapoet/TypeSpecTest.java
@@ -650,6 +650,59 @@ public final class TypeSpecTest {
         + "}\n");
   }
 
+  @Test public void annotation() throws Exception {
+    TypeSpec annotation = TypeSpec.annotationBuilder("MyAnnotation")
+        .addModifiers(Modifier.PUBLIC)
+        .addMethod(MethodSpec.methodBuilder("test")
+                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+                .defaultValue("$L", 0)
+                .returns(int.class)
+                .build())
+        .build();
+
+    assertThat(toString(annotation)).isEqualTo(""
+        + "package com.squareup.tacos;\n"
+        + "\n"
+        + "public @interface MyAnnotation {\n"
+        + "  int test() default 0;\n"
+        + "}\n"
+    );
+  }
+
+  @Test public void innerAnnotationInAnnotationDeclaration() throws Exception {
+    TypeSpec bar = TypeSpec.annotationBuilder("Bar")
+        .addMethod(MethodSpec.methodBuilder("value")
+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+            .defaultValue("@$T", Deprecated.class)
+            .returns(Deprecated.class)
+            .build())
+        .build();
+
+    assertThat(toString(bar)).isEqualTo(""
+        + "package com.squareup.tacos;\n"
+        + "\n"
+        + "import java.lang.Deprecated;\n"
+        + "\n"
+        + "@interface Bar {\n"
+        + "  Deprecated value() default @Deprecated;\n"
+        + "}\n"
+    );
+  }
+
+  @Test
+  public void classCannotHaveDefaultValueForMethod() throws Exception {
+    try {
+      TypeSpec.classBuilder("Tacos")
+          .addMethod(MethodSpec.methodBuilder("test")
+              .addModifiers(Modifier.PUBLIC)
+              .defaultValue("0")
+              .returns(int.class)
+              .build())
+          .build();
+      fail();
+    } catch (IllegalStateException expected) {}
+  }
+
   @Test public void referencedAndDeclaredSimpleNamesConflict() throws Exception {
     FieldSpec internalTop = FieldSpec.builder(
         ClassName.get(tacosPackage, "Top"), "internalTop").build();
@@ -1242,6 +1295,14 @@ public final class TypeSpecTest {
         + "}\n");
   }
 
+  @Test public void annotationDeclarationToString() throws Exception {
+    TypeSpec type = TypeSpec.annotationBuilder("Taco")
+        .build();
+    assertThat(type.toString()).isEqualTo(""
+        + "@interface Taco {\n"
+        + "}\n");
+  }
+
   private String toString(TypeSpec typeSpec) {
     return JavaFile.builder(tacosPackage, typeSpec).build().toString();
   }
