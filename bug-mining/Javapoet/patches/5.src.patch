diff --git a/src/main/java/com/squareup/javapoet/CodeBlock.java b/src/main/java/com/squareup/javapoet/CodeBlock.java
index e0ace07..aa5053a 100644
--- a/src/main/java/com/squareup/javapoet/CodeBlock.java
+++ b/src/main/java/com/squareup/javapoet/CodeBlock.java
@@ -22,6 +22,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
 
@@ -106,41 +107,73 @@ public final class CodeBlock {
         if (format.charAt(p) != '$') {
           nextP = format.indexOf('$', p + 1);
           if (nextP == -1) nextP = format.length();
+          formatParts.add(format.substring(p, nextP));
         } else {
           checkState(p + 1 < format.length(), "dangling $ in format string %s", format);
-          switch (format.charAt(p + 1)) {
+          /* Rules:
+           * Format must be in the form $[Numeric Index]{N, L, S, T}
+           * OR
+           * in the form ${$, >, <, [, ]}
+           * Numeric index is ONE BASED (for consistency with java formatting)
+           * Numeric indexing must refer to a format argument within the args array
+           * Only progress iteration over the argument iterator if we do not hit an indexed entry
+           */
+          int countOfIndexCharacters = 0;
+          while (isSimpleDigit(format.charAt(p + countOfIndexCharacters + 1))) {
+            countOfIndexCharacters++;
+            checkArgument(format.length() > p + countOfIndexCharacters + 1,
+                "Dangling format characters '%s' in format string '%s'",
+                format.substring(p), format);
+          }
+
+          int argsIndex = -1;
+          if (countOfIndexCharacters != 0) {
+            argsIndex = Integer.parseInt(format.substring(p + 1, p + 1 + countOfIndexCharacters));
+            checkArgument(argsIndex <= args.length,
+                "Argument index %s in '%s' is larger than number of parameters",
+                argsIndex, format);
+            checkArgument(argsIndex > 0,
+                "Argument index %s in '%s' is less than one, the minimum format index",
+                argsIndex, format);
+          }
+          switch (format.charAt(p + countOfIndexCharacters + 1)) {
             case 'N':
-              this.args.add(argToName(i.next()));
+              this.args.add(argToName((argsIndex == -1) ? i.next() : args[argsIndex - 1]));
               break;
             case 'L':
-              this.args.add(argToLiteral(i.next()));
+              this.args.add(argToLiteral((argsIndex == -1) ? i.next() : args[argsIndex - 1]));
               break;
             case 'S':
-              this.args.add(argToString(i.next()));
+              this.args.add(argToString((argsIndex == -1) ? i.next() : args[argsIndex - 1]));
               break;
             case 'T':
-              this.args.add(argToType(i.next()));
+              this.args.add(argToType((argsIndex == -1) ? i.next() : args[argsIndex - 1]));
               break;
             case '$':
             case '>':
             case '<':
             case '[':
             case ']':
+              checkState(argsIndex == -1, "$$, $>, $<, $[ and $] may not have an index");
               break;
             default:
               throw new IllegalArgumentException("invalid format string: " + format);
           }
 
-          nextP = p + 2;
+          nextP = p + countOfIndexCharacters + 2;
+          formatParts.add(String.format("%c%c", format.charAt(p), format.charAt(nextP - 1)));
         }
-
-        formatParts.add(format.substring(p, nextP));
       }
-
-      checkArgument(!i.hasNext(), "unexpected args for %s: %s", format, Arrays.asList(args));
       return this;
     }
 
+    /**
+     * A version of {@link Character#isDigit(char)} that only accepts '0'-'9'.
+     */
+    private boolean isSimpleDigit(char toCheck) {
+      return toCheck >= '0' && toCheck <= '9';
+    }
+
     private String argToName(Object o) {
       if (o instanceof CharSequence) return o.toString();
       if (o instanceof ParameterSpec) return ((ParameterSpec) o).name;
diff --git a/src/test/java/com/squareup/javapoet/CodeBlockTest.java b/src/test/java/com/squareup/javapoet/CodeBlockTest.java
new file mode 100644
index 0000000..b4980de
--- /dev/null
+++ b/src/test/java/com/squareup/javapoet/CodeBlockTest.java
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.javapoet;
+
+import org.junit.Test;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+public class CodeBlockTest {
+  
+  @Test
+  public void indentCannotBeIndexed() {
+    try {
+      CodeBlock.builder().add("$1>", "taco").build();
+      fail();
+    } catch (IllegalStateException exp) {
+      assertThat(exp).hasMessage("$$, $>, $<, $[ and $] may not have an index");
+    }
+  }
+  
+  @Test
+  public void deindentCannotBeIndexed() {
+    try {
+      CodeBlock.builder().add("$1<", "taco").build();
+      fail();
+    } catch (IllegalStateException exp) {
+      assertThat(exp).hasMessage("$$, $>, $<, $[ and $] may not have an index");
+    }
+  }
+  
+  @Test
+  public void dollarSignEscapeCannotBeIndexed() {
+    try {
+      CodeBlock.builder().add("$1$", "taco").build();
+      fail();
+    } catch (IllegalStateException exp) {
+      assertThat(exp).hasMessage("$$, $>, $<, $[ and $] may not have an index");
+    }
+  }
+ 
+  @Test
+  public void statementBeginningCannotBeIndexed() {
+    try {
+      CodeBlock.builder().add("$1[", "taco").build();
+      fail();
+    } catch (IllegalStateException exp) {
+      assertThat(exp).hasMessage("$$, $>, $<, $[ and $] may not have an index");
+    }
+  }
+  
+  @Test
+  public void statementEndingCannotBeIndexed() {
+    try {
+      CodeBlock.builder().add("$1]", "taco").build();
+      fail();
+    } catch (IllegalStateException exp) {
+      assertThat(exp).hasMessage("$$, $>, $<, $[ and $] may not have an index");
+    }
+  }
+  
+  @Test
+  public void nameFormatCanBeIndexed() {
+    CodeBlock block = CodeBlock.builder().add("$N $1N", "taco").build();
+    assertThat(block.toString()).isEqualTo("taco taco");
+  }
+  
+  @Test
+  public void literalFormatCanBeIndexed() {
+    CodeBlock block = CodeBlock.builder().add("$L $1L", "taco").build();
+    assertThat(block.toString()).isEqualTo("taco taco");
+  }
+  
+  @Test
+  public void stringFormatCanBeIndexed() {
+    CodeBlock block = CodeBlock.builder().add("$S $1S", "taco").build();
+    assertThat(block.toString()).isEqualTo("\"taco\" \"taco\"");
+  }
+  
+  @Test
+  public void typeFormatCanBeIndexed() {
+    CodeBlock block = CodeBlock.builder().add("$T $1T", String.class).build();
+    assertThat(block.toString()).isEqualTo("java.lang.String java.lang.String");
+  }
+  
+  @Test
+  public void indexTooHigh() {
+    try {
+      CodeBlock.builder().add("$T $2T", String.class).build();
+      fail();
+    } catch (IllegalArgumentException exp) {
+      assertThat(exp).hasMessage("Argument index 2 in '$T $2T' is larger than number of parameters");
+    }
+  }
+  
+  @Test
+  public void indexIsZero() {
+    try {
+    CodeBlock.builder().add("$T $0T", String.class).build();
+    fail();
+    } catch(IllegalArgumentException exp) {
+      assertThat(exp).hasMessage("Argument index 0 in '$T $0T' is less than one, the minimum format index");
+    }
+  }
+  
+  @Test
+  public void indexIsNegative() {
+    try {
+      CodeBlock.builder().add("$T $-1T", String.class).build();
+      fail();
+    } catch (IllegalArgumentException exp) {
+      assertThat(exp).hasMessage("invalid format string: $T $-1T");
+    }
+  }
+  
+  @Test
+  public void indexWithoutFormatType() {
+    try {
+      CodeBlock.builder().add("$1", String.class).build();
+      fail();
+    } catch (IllegalArgumentException exp) {
+      assertThat(exp).hasMessage("Dangling format characters '$1' in format string '$1'");
+    }
+  }
+  
+  @Test
+  public void indexWithoutFormatTypeNotAtStringEnd() {
+    try {
+      CodeBlock.builder().add("$1 taco", String.class).build();
+      fail();
+    } catch (IllegalArgumentException exp) {
+      assertThat(exp).hasMessage("invalid format string: $1 taco");
+    }
+  }
+  
+  @Test
+  public void formatIndicatorAlone() {
+    try {
+      CodeBlock.builder().add("$", String.class).build();
+      fail();
+    } catch (IllegalStateException exp) {
+      assertThat(exp).hasMessage("dangling $ in format string $");
+    }
+  }
+  
+  @Test
+  public void formatIndicatorWithoutIndexOrFormatType() {
+    try {
+      CodeBlock.builder().add("$ tacoString", String.class).build();
+      fail();
+    } catch (IllegalArgumentException exp) {
+      assertThat(exp).hasMessage("invalid format string: $ tacoString");
+    }
+  }
+  
+  @Test
+  public void indexingDoesNotIncreaseNaturalIndex() {
+    CodeBlock block = CodeBlock.builder().add("$L $L $2L $L", 1, 2, 3).build();
+    assertThat(block.toString()).isEqualTo("1 2 2 3");
+  }
+  
+  @Test
+  public void indexingSelectsProperPosition() {
+    CodeBlock block = CodeBlock.builder().add("$L $L $L $3L $2L $1L", 1, 2, 3).build();
+    assertThat(block.toString()).isEqualTo("1 2 3 3 2 1");
+  }
+  
+  @Test
+  public void indexingCanBeInterleved() {
+    CodeBlock block = CodeBlock.builder().add("$L $3L $L $2L $L $1L", 1, 2, 3).build();
+    assertThat(block.toString()).isEqualTo("1 3 2 2 3 1");
+  }
+  
+  @Test
+  public void sameIndexCanBeUsedWithDifferentFormats() {
+    CodeBlock block = CodeBlock.builder().add("$1T.out.println($1S)", ClassName.get(System.class)).build();
+    assertThat(block.toString()).isEqualTo("java.lang.System.out.println(\"java.lang.System\")");
+  }
+  
+}
diff --git a/src/test/java/com/squareup/javapoet/TypeSpecTest.java b/src/test/java/com/squareup/javapoet/TypeSpecTest.java
index 228bfab..c6c883f 100644
--- a/src/test/java/com/squareup/javapoet/TypeSpecTest.java
+++ b/src/test/java/com/squareup/javapoet/TypeSpecTest.java
@@ -1043,6 +1043,32 @@ public final class TypeSpecTest {
         + "  }\n"
         + "}\n");
   }
+  
+  @Test public void indexedElseIf() throws Exception {
+    TypeSpec taco = TypeSpec.classBuilder("Taco")
+        .addMethod(MethodSpec.methodBuilder("choices")
+            .beginControlFlow("if ($1L != null || $1L == $2L)", "taco", "otherTaco")
+            .addStatement("$T.out.println($S)", System.class, "only one taco? NOO!")
+            .nextControlFlow("else if ($1L.$3L && $2L.$3L)", "taco", "otherTaco", "isSupreme()")
+            .addStatement("$T.out.println($S)", System.class, "taco heaven")
+            .endControlFlow()
+            .build())
+        .build();
+    assertThat(toString(taco)).isEqualTo(""
+        + "package com.squareup.tacos;\n"
+        + "\n"
+        + "import java.lang.System;\n"
+        + "\n"
+        + "class Taco {\n"
+        + "  void choices() {\n"
+        + "    if (taco != null || taco == otherTaco) {\n"
+        + "      System.out.println(\"only one taco? NOO!\");\n"
+        + "    } else if (taco.isSupreme() && otherTaco.isSupreme()) {\n"
+        + "      System.out.println(\"taco heaven\");\n"
+        + "    }\n"
+        + "  }\n"
+        + "}\n");
+  }
 
   @Test public void elseIf() throws Exception {
     TypeSpec taco = TypeSpec.classBuilder("Taco")
@@ -1818,15 +1844,6 @@ public final class TypeSpecTest {
     }
   }
 
-  @Test public void tooManyArguments() {
-    try {
-      CodeBlock.builder().add("$$", "foo");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("unexpected args for $$: [foo]");
-    }
-  }
-
   @Test public void tooFewArguments() {
     try {
       CodeBlock.builder().add("$S");
