diff --git a/src/main/java/com/squareup/javapoet/ParameterizedTypeName.java b/src/main/java/com/squareup/javapoet/ParameterizedTypeName.java
index 75b8c49..aadb9ae 100644
--- a/src/main/java/com/squareup/javapoet/ParameterizedTypeName.java
+++ b/src/main/java/com/squareup/javapoet/ParameterizedTypeName.java
@@ -16,6 +16,7 @@
 package com.squareup.javapoet;
 
 import java.io.IOException;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -28,20 +29,24 @@ import static com.squareup.javapoet.Util.checkArgument;
 import static com.squareup.javapoet.Util.checkNotNull;
 
 public final class ParameterizedTypeName extends TypeName {
+  private final ParameterizedTypeName enclosingType;
   public final ClassName rawType;
   public final List<TypeName> typeArguments;
 
-  ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments) {
-    this(rawType, typeArguments, new ArrayList<AnnotationSpec>());
+  ParameterizedTypeName(ParameterizedTypeName enclosingType, ClassName rawType,
+      List<TypeName> typeArguments) {
+    this(enclosingType, rawType, typeArguments, new ArrayList<AnnotationSpec>());
   }
 
-  ParameterizedTypeName(ClassName rawType, List<TypeName> typeArguments,
-      List<AnnotationSpec> annotations) {
+  private ParameterizedTypeName(ParameterizedTypeName enclosingType, ClassName rawType,
+      List<TypeName> typeArguments, List<AnnotationSpec> annotations) {
     super(annotations);
     this.rawType = checkNotNull(rawType, "rawType == null");
+    this.enclosingType = enclosingType;
     this.typeArguments = Util.immutableList(typeArguments);
 
-    checkArgument(!this.typeArguments.isEmpty(), "no type arguments: %s", rawType);
+    checkArgument(!this.typeArguments.isEmpty() || enclosingType != null,
+        "no type arguments: %s", rawType);
     for (TypeName typeArgument : this.typeArguments) {
       checkArgument(!typeArgument.isPrimitive() && typeArgument != VOID,
           "invalid type parameter: %s", typeArgument);
@@ -49,35 +54,66 @@ public final class ParameterizedTypeName extends TypeName {
   }
 
   @Override public ParameterizedTypeName annotated(List<AnnotationSpec> annotations) {
-    return new ParameterizedTypeName(rawType, typeArguments, concatAnnotations(annotations));
+    return new ParameterizedTypeName(
+        enclosingType, rawType, typeArguments, concatAnnotations(annotations));
   }
 
   @Override public TypeName withoutAnnotations() {
-    return new ParameterizedTypeName(rawType, typeArguments);
+    return new ParameterizedTypeName(
+        enclosingType, rawType, typeArguments, new ArrayList<AnnotationSpec>());
   }
 
   @Override CodeWriter emit(CodeWriter out) throws IOException {
-    rawType.emitAnnotations(out);
-    rawType.emit(out);
-    out.emitAndIndent("<");
-    boolean firstParameter = true;
-    for (TypeName parameter : typeArguments) {
-      if (!firstParameter) out.emitAndIndent(", ");
-      parameter.emitAnnotations(out);
-      parameter.emit(out);
-      firstParameter = false;
+    if (enclosingType != null) {
+      enclosingType.emitAnnotations(out);
+      enclosingType.emit(out);
+      out.emit("." + rawType.simpleName());
+    } else {
+      rawType.emitAnnotations(out);
+      rawType.emit(out);
     }
-    return out.emitAndIndent(">");
+    if (!typeArguments.isEmpty()) {
+      out.emitAndIndent("<");
+      boolean firstParameter = true;
+      for (TypeName parameter : typeArguments) {
+        if (!firstParameter) out.emitAndIndent(", ");
+        parameter.emitAnnotations(out);
+        parameter.emit(out);
+        firstParameter = false;
+      }
+      out.emitAndIndent(">");
+    }
+    return out;
+  }
+
+  /**
+   * Returns a new {@link ParameterizedTypeName} instance for the specified {@code name} as nested
+   * inside this class.
+   */
+  public ParameterizedTypeName nestedClass(String name) {
+    checkNotNull(name, "name == null");
+    return new ParameterizedTypeName(this, rawType.nestedClass(name), new ArrayList<TypeName>(),
+        new ArrayList<AnnotationSpec>());
+  }
+
+  /**
+   * Returns a new {@link ParameterizedTypeName} instance for the specified {@code name} as nested
+   * inside this class, with the specified {@code typeArguments}.
+   */
+  public ParameterizedTypeName nestedClass(String name, List<TypeName> typeArguments) {
+    checkNotNull(name, "name == null");
+    return new ParameterizedTypeName(this, rawType.nestedClass(name), typeArguments,
+        new ArrayList<AnnotationSpec>());
   }
 
   /** Returns a parameterized type, applying {@code typeArguments} to {@code rawType}. */
   public static ParameterizedTypeName get(ClassName rawType, TypeName... typeArguments) {
-    return new ParameterizedTypeName(rawType, Arrays.asList(typeArguments));
+    return new ParameterizedTypeName(null, rawType, Arrays.asList(typeArguments));
   }
 
   /** Returns a parameterized type, applying {@code typeArguments} to {@code rawType}. */
   public static ParameterizedTypeName get(Class<?> rawType, Type... typeArguments) {
-    return new ParameterizedTypeName(ClassName.get(rawType), list(typeArguments));
+    return new ParameterizedTypeName(null, ClassName.get(rawType), list(typeArguments));
   }
 
   /** Returns a parameterized type equivalent to {@code type}. */
@@ -87,7 +123,13 @@ public final class ParameterizedTypeName extends TypeName {
 
   /** Returns a parameterized type equivalent to {@code type}. */
   static ParameterizedTypeName get(ParameterizedType type, Map<Type, TypeVariableName> map) {
-    return new ParameterizedTypeName(ClassName.get((Class<?>) type.getRawType()),
-        TypeName.list(type.getActualTypeArguments(), map));
+    ClassName rawType = ClassName.get((Class<?>) type.getRawType());
+    ParameterizedType ownerType = (type.getOwnerType() instanceof ParameterizedType)
+        && !Modifier.isStatic(((Class<?>) type.getRawType()).getModifiers())
+        ? (ParameterizedType) type.getOwnerType() : null;
+    List<TypeName> typeArguments = TypeName.list(type.getActualTypeArguments(), map);
+    return (ownerType != null)
+        ? get(ownerType, map).nestedClass(rawType.simpleName(), typeArguments)
+        : new ParameterizedTypeName(null, rawType, typeArguments);
   }
 }
diff --git a/src/main/java/com/squareup/javapoet/TypeName.java b/src/main/java/com/squareup/javapoet/TypeName.java
index fa6f4c4..401887d 100644
--- a/src/main/java/com/squareup/javapoet/TypeName.java
+++ b/src/main/java/com/squareup/javapoet/TypeName.java
@@ -26,6 +26,7 @@ import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.type.ArrayType;
@@ -265,13 +266,24 @@ public class TypeName {
 
       @Override public TypeName visitDeclared(DeclaredType t, Void p) {
         ClassName rawType = ClassName.get((TypeElement) t.asElement());
-        if (t.getTypeArguments().isEmpty()) return rawType;
+        TypeMirror enclosingType = t.getEnclosingType();
+        TypeName enclosing =
+            (enclosingType.getKind() != TypeKind.NONE)
+                    && !t.asElement().getModifiers().contains(Modifier.STATIC)
+                ? enclosingType.accept(this, null)
+                : null;
+        if (t.getTypeArguments().isEmpty() && !(enclosing instanceof ParameterizedTypeName)) {
+          return rawType;
+        }
 
         List<TypeName> typeArgumentNames = new ArrayList<>();
         for (TypeMirror mirror : t.getTypeArguments()) {
           typeArgumentNames.add(get(mirror, typeVariables));
         }
-        return new ParameterizedTypeName(rawType, typeArgumentNames);
+        return enclosing instanceof ParameterizedTypeName
+            ? ((ParameterizedTypeName) enclosing).nestedClass(
+            rawType.simpleName(), typeArgumentNames)
+            : new ParameterizedTypeName(null, rawType, typeArgumentNames);
       }
 
       @Override public TypeName visitError(ErrorType t, Void p) {
diff --git a/src/test/java/com/squareup/javapoet/TypeNameTest.java b/src/test/java/com/squareup/javapoet/TypeNameTest.java
index 60540b9..008751d 100644
--- a/src/test/java/com/squareup/javapoet/TypeNameTest.java
+++ b/src/test/java/com/squareup/javapoet/TypeNameTest.java
@@ -33,12 +33,77 @@ public class TypeNameTest {
     return values[0];
   }
 
+  protected static class TestGeneric<T> {
+    class Inner {}
+
+    class InnerGeneric<T2> {}
+
+    static class NestedNonGeneric {}
+  }
+
+  protected static TestGeneric<String>.Inner testGenericStringInner() {
+    return null;
+  }
+
+  protected static TestGeneric<Integer>.Inner testGenericIntInner() {
+    return null;
+  }
+
+  protected static TestGeneric<Short>.InnerGeneric<Long> testGenericInnerLong() {
+    return null;
+  }
+
+  protected static TestGeneric<Short>.InnerGeneric<Integer> testGenericInnerInt() {
+    return null;
+  }
+
+  protected static TestGeneric.NestedNonGeneric testNestedNonGeneric() {
+    return null;
+  }
+
   @Test public void genericType() throws Exception {
     Method recursiveEnum = getClass().getDeclaredMethod("generic", Enum[].class);
     TypeName.get(recursiveEnum.getReturnType());
     TypeName.get(recursiveEnum.getGenericReturnType());
-    TypeName.get(recursiveEnum.getParameterTypes()[0]);
+    TypeName genericTypeName = TypeName.get(recursiveEnum.getParameterTypes()[0]);
     TypeName.get(recursiveEnum.getGenericParameterTypes()[0]);
+
+    // Make sure the generic argument is present
+    assertThat(genericTypeName.toString()).contains("Enum");
+  }
+
+  @Test public void innerClassInGenericType() throws Exception {
+    Method genericStringInner = getClass().getDeclaredMethod("testGenericStringInner");
+    TypeName.get(genericStringInner.getReturnType());
+    TypeName genericTypeName = TypeName.get(genericStringInner.getGenericReturnType());
+    assertNotEquals(TypeName.get(genericStringInner.getGenericReturnType()),
+        TypeName.get(getClass().getDeclaredMethod("testGenericIntInner").getGenericReturnType()));
+
+    // Make sure the generic argument is present
+    assertThat(genericTypeName.toString()).isEqualTo(
+        TestGeneric.class.getCanonicalName() + "<java.lang.String>.Inner");
+  }
+
+  @Test public void innerGenericInGenericType() throws Exception {
+    Method genericStringInner = getClass().getDeclaredMethod("testGenericInnerLong");
+    TypeName.get(genericStringInner.getReturnType());
+    TypeName genericTypeName = TypeName.get(genericStringInner.getGenericReturnType());
+    assertNotEquals(TypeName.get(genericStringInner.getGenericReturnType()),
+        TypeName.get(getClass().getDeclaredMethod("testGenericInnerInt").getGenericReturnType()));
+
+    // Make sure the generic argument is present
+    assertThat(genericTypeName.toString()).isEqualTo(
+        TestGeneric.class.getCanonicalName() + "<java.lang.Short>.InnerGeneric<java.lang.Long>");
+  }
+
+  @Test public void innerStaticInGenericType() throws Exception {
+    Method staticInGeneric = getClass().getDeclaredMethod("testNestedNonGeneric");
+    TypeName.get(staticInGeneric.getReturnType());
+    TypeName typeName = TypeName.get(staticInGeneric.getGenericReturnType());
+
+    // Make sure there are no generic arguments
+    assertThat(typeName.toString()).isEqualTo(
+        TestGeneric.class.getCanonicalName() + ".NestedNonGeneric");
   }
 
   @Test public void equalsAndHashCodePrimitive() {
