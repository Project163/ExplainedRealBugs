{"url":"https://api.github.com/repos/rust-random/rand/issues/907","repository_url":"https://api.github.com/repos/rust-random/rand","labels_url":"https://api.github.com/repos/rust-random/rand/issues/907/labels{/name}","comments_url":"https://api.github.com/repos/rust-random/rand/issues/907/comments","events_url":"https://api.github.com/repos/rust-random/rand/issues/907/events","html_url":"https://github.com/rust-random/rand/issues/907","id":522561054,"node_id":"MDU6SXNzdWU1MjI1NjEwNTQ=","number":907,"title":"Document dependency between streams in PCG64","user":{"login":"vigna","id":1464942,"node_id":"MDQ6VXNlcjE0NjQ5NDI=","avatar_url":"https://avatars.githubusercontent.com/u/1464942?v=4","gravatar_id":"","url":"https://api.github.com/users/vigna","html_url":"https://github.com/vigna","followers_url":"https://api.github.com/users/vigna/followers","following_url":"https://api.github.com/users/vigna/following{/other_user}","gists_url":"https://api.github.com/users/vigna/gists{/gist_id}","starred_url":"https://api.github.com/users/vigna/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/vigna/subscriptions","organizations_url":"https://api.github.com/users/vigna/orgs","repos_url":"https://api.github.com/users/vigna/repos","events_url":"https://api.github.com/users/vigna/events{/privacy}","received_events_url":"https://api.github.com/users/vigna/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2019-11-14T01:02:41Z","updated_at":"2021-05-08T07:31:37Z","closed_at":"2021-05-08T07:31:37Z","author_association":"NONE","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"The documentation of the PCG generators with a \"stream\" parameter does not state explicit that different streams generate independent sequences, but the existence of a parameter named \"stream\" implies somehow the idea.\r\n\r\nThe user should be made aware that the stream parameter is almost useless from a mathematical and statistical viewpoint.\r\n\r\nChanging constant (stream) to an LCG with power-of-two modulus and a constant like the one used in PCG simply adds a constant to the sequence (more precisely, there are two equivalence classes of constants, and in each equivalence class the sequences are identical, except for an additive constant).\r\n\r\nThe minimal scrambling done by the generator cannot cancel this fact, and as a result changing the constant is basically equivalent to changing the initial state. You can try to run this program:\r\n\r\n    extern crate rand_pcg;\r\n    use rand::{Rng};\r\n\r\n    fn main() {\r\n        let state : u128  = 0x596d84dfefec2fc76b79f81ab9f3e37b; // Original state\r\n        let c : u128 = 0x702bdbf7bb3c0a7ac28fa16a64abf95; // Original increment parameter (must be odd)\r\n        let c_ : u128 = c << 1 | 1; // Actual increment\r\n        let d_ : u128 = 0xba6724c0f47893162ee214efcc33da13; // Any other actual increment (must be congruent to 3 mod 8)\r\n\r\n        let mut r : u128 = 68263968060690495638840298501726217073;\r\n        r = r.wrapping_mul((d_ - c_) / 4);\r\n\r\n        let mut r0 = rand_pcg::Pcg64::new(state.wrapping_sub(c_), c);\r\n        let mut r1 = rand_pcg::Pcg64::new(state.wrapping_sub(d_).wrapping_sub(r), d_ >> 1);\r\n\r\n        loop {\r\n            let x: u64 = r0.gen();\r\n            let y: u64 = r1.gen();\r\n            println!(\"0x{:x}\", x);\r\n            println!(\"0x{:x}\", y);\r\n        }\r\n    }\r\n\r\nYou can change state as you like, and the two constants c and d_ as you like. The program will set up two initial states so that the sequences generated by the two PRNGs are based on almost identical underlying LCG sequences, in spite of having arbitrary constants (stream parameters). I don't know how to write in binary in Rust, but I passed the output through this simple C program\r\n\r\n     #include <stdio.h>\r\n     #include <stdlib.h>\r\n     #include <stdint.h>\r\n\r\n     int main() {\r\n             char s[100];\r\n\r\n             for(;;) {\r\n                     gets(s);\r\n                     const uint64_t x = strtoull(s, NULL, 0);\r\n                     fwrite(&x, sizeof x, 1, stdout);\r\n            }\r\n    }\r\n\r\nand then through PractRand. If you comment one of the `println!`, everything is fine. If you interleave the two generators:\r\n\r\n    rng=RNG_stdin64, seed=unknown\r\n    length= 16 megabytes (2^24 bytes), time= 3.3 seconds\r\n      Test Name                         Raw       Processed     Evaluation\r\n      BCFN(0+0,13-4,T)                  R=+472.4  p =  2.4e-206   FAIL !!!!!!\r\n      BCFN(0+1,13-4,T)                  R=+663.5  p =  8.2e-290   FAIL !!!!!!\r\n      BCFN(0+2,13-5,T)                  R=+367.3  p =  6.0e-144   FAIL !!!!!\r\n      BCFN(0+3,13-5,T)                  R=+564.4  p =  4.1e-221   FAIL !!!!!!\r\n      DC6-9x1Bytes-1                    R= +64.4  p =  5.7e-37    FAIL !!!\r\n      DC6-6x2Bytes-1                    R= +98.4  p =  1.8e-56    FAIL !!!!\r\n      DC6-5x4Bytes-1                    R= +45.4  p =  1.3e-27    FAIL !!\r\n      [Low4/16]BCFN(0+0,13-5,T)         R= +81.3  p =  5.3e-32    FAIL !!!\r\n      [Low4/16]BCFN(0+1,13-5,T)         R=+144.4  p =  1.0e-56    FAIL !!!!\r\n      [Low4/16]BCFN(0+2,13-6,T)         R= +14.8  p =  1.7e-5   mildly suspicious\r\n      [Low4/16]DC6-9x1Bytes-1           R= +16.0  p =  8.1e-9    VERY SUSPICIOUS\r\n      [Low4/16]DC6-6x2Bytes-1           R= +32.7  p =  5.2e-18    FAIL !\r\n      [Low4/16]DC6-5x4Bytes-1           R= +45.6  p =  1.7e-22    FAIL !!\r\n      [Low4/16]FPF-14+6/4:(0,14-1)      R=+128.3  p =  1.9e-113   FAIL !!!!!\r\n      [Low4/16]FPF-14+6/4:(1,14-2)      R=+126.7  p =  1.4e-110   FAIL !!!!!\r\n      [Low4/16]FPF-14+6/4:(2,14-2)      R= +79.0  p =  7.3e-69    FAIL !!!!\r\n      [Low4/16]FPF-14+6/4:(3,14-3)      R= +17.5  p =  4.2e-15    FAIL\r\n      [Low4/16]FPF-14+6/4:(4,14-4)      R=  +9.3  p =  1.4e-7   mildly suspicious\r\n      [Low4/16]FPF-14+6/4:all           R=+179.8  p =  3.3e-168   FAIL !!!!!\r\n      ...and 849 test result(s) without anomalies\r\n\r\nYou can also offset one of generator by hundred of iterations, but the sequences are so correlated that the result won't change.\r\n\r\nI think the reader should be made aware of the danger. If you start several generators of this kind the state is too small to guarantee that there will be no overlap. Once you get overlap, since there are in practice just two sequences, you will get a lot of unwanted correlation.","closed_by":{"login":"dhardy","id":134893,"node_id":"MDQ6VXNlcjEzNDg5Mw==","avatar_url":"https://avatars.githubusercontent.com/u/134893?v=4","gravatar_id":"","url":"https://api.github.com/users/dhardy","html_url":"https://github.com/dhardy","followers_url":"https://api.github.com/users/dhardy/followers","following_url":"https://api.github.com/users/dhardy/following{/other_user}","gists_url":"https://api.github.com/users/dhardy/gists{/gist_id}","starred_url":"https://api.github.com/users/dhardy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dhardy/subscriptions","organizations_url":"https://api.github.com/users/dhardy/orgs","repos_url":"https://api.github.com/users/dhardy/repos","events_url":"https://api.github.com/users/dhardy/events{/privacy}","received_events_url":"https://api.github.com/users/dhardy/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rust-random/rand/issues/907/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rust-random/rand/issues/907/timeline","performed_via_github_app":null,"state_reason":"completed"}