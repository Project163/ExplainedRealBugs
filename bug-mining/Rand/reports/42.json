{"url":"https://api.github.com/repos/rust-random/rand/issues/1051","repository_url":"https://api.github.com/repos/rust-random/rand","labels_url":"https://api.github.com/repos/rust-random/rand/issues/1051/labels{/name}","comments_url":"https://api.github.com/repos/rust-random/rand/issues/1051/comments","events_url":"https://api.github.com/repos/rust-random/rand/issues/1051/events","html_url":"https://github.com/rust-random/rand/issues/1051","id":709846568,"node_id":"MDU6SXNzdWU3MDk4NDY1Njg=","number":1051,"title":"Stable version of rand::seq::IteratorRandom::choose","user":{"login":"kevincox","id":494012,"node_id":"MDQ6VXNlcjQ5NDAxMg==","avatar_url":"https://avatars.githubusercontent.com/u/494012?v=4","gravatar_id":"","url":"https://api.github.com/users/kevincox","html_url":"https://github.com/kevincox","followers_url":"https://api.github.com/users/kevincox/followers","following_url":"https://api.github.com/users/kevincox/following{/other_user}","gists_url":"https://api.github.com/users/kevincox/gists{/gist_id}","starred_url":"https://api.github.com/users/kevincox/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/kevincox/subscriptions","organizations_url":"https://api.github.com/users/kevincox/orgs","repos_url":"https://api.github.com/users/kevincox/repos","events_url":"https://api.github.com/users/kevincox/events{/privacy}","received_events_url":"https://api.github.com/users/kevincox/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":10,"created_at":"2020-09-28T00:09:17Z","updated_at":"2020-10-17T13:49:34Z","closed_at":"2020-10-17T13:49:34Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"## Background\r\n\r\n**What is your motivation?**\r\n\r\nProvide a way to produce predictable results for (a function similar to) `rand::seq::IteratorRandom::choose` no matter what type of iterator it is.\r\n\r\nRight now the behaviour of  `rand::seq::IteratorRandom::choose` depends on the type of Iterator that is passed in. This is mentioned in the docs as an \"optimization\" however it isn't clear that this is a behaviour affecting \"optimization\". Furthermore there is no good alternative function which doesn't have this \"optimization\".\r\n\r\nExample: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a62f77f38f4a0b66df57106d0cf6a4a4\r\n\r\n```rust\r\nextern crate rand; // 0.7.3\r\nextern crate rand_pcg; // 0.2.1\r\n\r\nfn choose(i: &mut dyn Iterator<Item=u32>) -> u32 {\r\n    let mut rng = rand_pcg::Pcg32::new(0xcafef00dd15ea5e5, 0xa02bdbf7bb3c0a7);\r\n    rand::seq::IteratorRandom::choose(i, &mut rng).unwrap()\r\n}\r\n\r\nfn main() {\r\n    dbg!(choose(&mut (0..32))); // 5\r\n    dbg!(choose(&mut (0..32).filter(|_| true))); // 3\r\n}\r\n```\r\n\r\n**What type of application is this?** numerical simulation\r\n\r\n## Feature request\r\n\r\n1. Clarify the documentation to emphasize that `rand::seq::IteratorRandom::choose` has different behaviour depending on the return value of the `size_hint` method.\r\n2. Provide an alternative function that will select the same element (including `Rng` state) for any iterator of the same length.\r\n\r\n## Workarounds\r\n\r\n### Unify type:\r\n\r\nOne option to get a consistent result is ensure that you are always working with the same type. For example the following always collects to a `Vec`.\r\n\r\n```rust\r\nfn stable_choose_collect<T>(i: impl Iterator<Item=T>, mut rng: impl rand::Rng) -> Option<T> {\r\n    rand::seq::IteratorRandom::choose(i.collect::<Vec<_>>().into_iter(), &mut rng)\r\n}\r\n```\r\n\r\n### Get rid of size_hint.\r\n\r\nIt would be more \"proper\" to make a wrapper type but since `rand::seq::IteratorRandom::choose` only performs its \"optimization\" if `lower == upper` we just need to make those not equal. The easiest way to do this is is call `.filter(|_| true)` on the iterator. Because it can't tell how many elements you will filter it will set the lower bound to `0`.\r\n\r\n```rust\r\nfn stable_choose_no_hint<T>(i: impl Iterator<Item=T>, mut rng: impl rand::Rng) -> Option<T> {\r\n    rand::seq::IteratorRandom::choose(i.filter(|_| true), &mut rng)\r\n}\r\n```","closed_by":{"login":"dhardy","id":134893,"node_id":"MDQ6VXNlcjEzNDg5Mw==","avatar_url":"https://avatars.githubusercontent.com/u/134893?v=4","gravatar_id":"","url":"https://api.github.com/users/dhardy","html_url":"https://github.com/dhardy","followers_url":"https://api.github.com/users/dhardy/followers","following_url":"https://api.github.com/users/dhardy/following{/other_user}","gists_url":"https://api.github.com/users/dhardy/gists{/gist_id}","starred_url":"https://api.github.com/users/dhardy/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/dhardy/subscriptions","organizations_url":"https://api.github.com/users/dhardy/orgs","repos_url":"https://api.github.com/users/dhardy/repos","events_url":"https://api.github.com/users/dhardy/events{/privacy}","received_events_url":"https://api.github.com/users/dhardy/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/rust-random/rand/issues/1051/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/rust-random/rand/issues/1051/timeline","performed_via_github_app":null,"state_reason":"completed"}