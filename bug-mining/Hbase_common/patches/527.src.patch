diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/ByteBuffAllocator.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/ByteBuffAllocator.java
index ecef63662f..60b89223c1 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/ByteBuffAllocator.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/ByteBuffAllocator.java
@@ -319,11 +319,20 @@ public class ByteBuffAllocator {
       // just allocate the ByteBuffer from on-heap.
       bbs.add(allocateOnHeap(remain));
     }
-    ByteBuff bb = ByteBuff.wrap(bbs, () -> {
-      for (int i = 0; i < lenFromReservoir; i++) {
-        this.putbackBuffer(bbs.get(i));
-      }
-    });
+
+    ByteBuff bb;
+    // we only need a recycler if we successfully pulled from the pool
+    // this matters for determining whether to add leak detection in RefCnt
+    if (lenFromReservoir == 0) {
+      bb = ByteBuff.wrap(bbs);
+    } else {
+      bb = ByteBuff.wrap(bbs, () -> {
+        for (int i = 0; i < lenFromReservoir; i++) {
+          this.putbackBuffer(bbs.get(i));
+        }
+      });
+    }
+
     bb.limit(size);
     return bb;
   }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/ByteBuff.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/ByteBuff.java
index 9e2ccc3313..2925fab161 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/ByteBuff.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/ByteBuff.java
@@ -17,6 +17,7 @@
  */
 package org.apache.hadoop.hbase.nio;
 
+import com.google.errorprone.annotations.RestrictedApi;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
@@ -547,6 +548,28 @@ public abstract class ByteBuff implements HBaseReferenceCounted {
     return wrap(buffer, RefCnt.create());
   }
 
+  /**
+   * Calling this method in strategic locations where ByteBuffs are referenced may help diagnose
+   * potential buffer leaks. We pass the buffer itself as a default hint, but one can use
+   * {@link #touch(Object)} to pass their own hint as well.
+   */
+  @Override
+  public ByteBuff touch() {
+    return touch(this);
+  }
+
+  @Override
+  public ByteBuff touch(Object hint) {
+    refCnt.touch(hint);
+    return this;
+  }
+
+  @RestrictedApi(explanation = "Should only be called in tests", link = "",
+      allowedOnPath = ".*/src/test/.*")
+  public RefCnt getRefCnt() {
+    return refCnt;
+  }
+
   /**
    * Make this private because we don't want to expose the refCnt related wrap method to upstream.
    */
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/RefCnt.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/RefCnt.java
index c7b6dbf708..7c1f23383d 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/RefCnt.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/nio/RefCnt.java
@@ -17,12 +17,16 @@
  */
 package org.apache.hadoop.hbase.nio;
 
+import com.google.errorprone.annotations.RestrictedApi;
 import org.apache.hadoop.hbase.io.ByteBuffAllocator;
 import org.apache.hadoop.hbase.io.ByteBuffAllocator.Recycler;
 import org.apache.yetus.audience.InterfaceAudience;
 
 import org.apache.hbase.thirdparty.io.netty.util.AbstractReferenceCounted;
 import org.apache.hbase.thirdparty.io.netty.util.ReferenceCounted;
+import org.apache.hbase.thirdparty.io.netty.util.ResourceLeakDetector;
+import org.apache.hbase.thirdparty.io.netty.util.ResourceLeakDetectorFactory;
+import org.apache.hbase.thirdparty.io.netty.util.ResourceLeakTracker;
 
 /**
  * Maintain an reference count integer inside to track life cycle of {@link ByteBuff}, if the
@@ -31,7 +35,10 @@ import org.apache.hbase.thirdparty.io.netty.util.ReferenceCounted;
 @InterfaceAudience.Private
 public class RefCnt extends AbstractReferenceCounted {
 
-  private Recycler recycler = ByteBuffAllocator.NONE;
+  private static final ResourceLeakDetector<RefCnt> detector =
+    ResourceLeakDetectorFactory.instance().newResourceLeakDetector(RefCnt.class);
+  private final Recycler recycler;
+  private final ResourceLeakTracker<RefCnt> leak;
 
   /**
    * Create an {@link RefCnt} with an initial reference count = 1. If the reference count become
@@ -49,15 +56,66 @@ public class RefCnt extends AbstractReferenceCounted {
 
   public RefCnt(Recycler recycler) {
     this.recycler = recycler;
+    this.leak = recycler == ByteBuffAllocator.NONE ? null : detector.track(this);
+  }
+
+  @Override
+  public ReferenceCounted retain() {
+    maybeRecord();
+    return super.retain();
+  }
+
+  @Override
+  public ReferenceCounted retain(int increment) {
+    maybeRecord();
+    return super.retain(increment);
+  }
+
+  @Override
+  public boolean release() {
+    maybeRecord();
+    return super.release();
+  }
+
+  @Override
+  public boolean release(int decrement) {
+    maybeRecord();
+    return super.release(decrement);
   }
 
   @Override
   protected final void deallocate() {
     this.recycler.free();
+    if (leak != null) {
+      this.leak.close(this);
+    }
+  }
+
+  @Override
+  public RefCnt touch() {
+    maybeRecord();
+    return this;
   }
 
   @Override
   public final ReferenceCounted touch(Object hint) {
-    throw new UnsupportedOperationException();
+    maybeRecord(hint);
+    return this;
+  }
+
+  @RestrictedApi(explanation = "Should only be called in tests", link = "",
+      allowedOnPath = ".*/src/test/.*")
+  public Recycler getRecycler() {
+    return recycler;
+  }
+
+  private void maybeRecord() {
+    maybeRecord(null);
+  }
+
+  private void maybeRecord(Object hint) {
+    if (leak != null) {
+      leak.record(hint);
+    }
   }
 }
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/io/TestByteBuffAllocator.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/io/TestByteBuffAllocator.java
index 7cfdcd659d..d77dc6604b 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/io/TestByteBuffAllocator.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/io/TestByteBuffAllocator.java
@@ -21,6 +21,7 @@ import static org.apache.hadoop.hbase.io.ByteBuffAllocator.HEAP;
 import static org.apache.hadoop.hbase.io.ByteBuffAllocator.getHeapAllocationRatio;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -45,6 +46,21 @@ public class TestByteBuffAllocator {
   public static final HBaseClassTestRule CLASS_RULE =
     HBaseClassTestRule.forClass(TestByteBuffAllocator.class);
 
+  @Test
+  public void testRecycleOnlyPooledBuffers() {
+    int maxBuffersInPool = 10;
+    int bufSize = 1024;
+    int minSize = bufSize / 8;
+    ByteBuffAllocator alloc = new ByteBuffAllocator(true, maxBuffersInPool, bufSize, minSize);
+
+    ByteBuff buff = alloc.allocate(minSize - 1);
+    assertSame(ByteBuffAllocator.NONE, buff.getRefCnt().getRecycler());
+
+    alloc = new ByteBuffAllocator(true, 0, bufSize, minSize);
+    buff = alloc.allocate(minSize * 2);
+    assertSame(ByteBuffAllocator.NONE, buff.getRefCnt().getRecycler());
+  }
+
   @Test
   public void testAllocateByteBuffToReadInto() {
     int maxBuffersInPool = 10;
@@ -329,8 +345,6 @@ public class TestByteBuffAllocator {
     ByteBuff buf = alloc.allocate(bufSize);
     assertException(() -> buf.retain(2));
     assertException(() -> buf.release(2));
-    assertException(() -> buf.touch());
-    assertException(() -> buf.touch(new Object()));
   }
 
   private void assertException(Runnable r) {
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/io/TestByteBuffAllocatorLeakDetection.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/io/TestByteBuffAllocatorLeakDetection.java
new file mode 100644
index 0000000000..ffc0292902
--- /dev/null
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/io/TestByteBuffAllocatorLeakDetection.java
@@ -0,0 +1,341 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.io;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.hadoop.hbase.HBaseClassTestRule;
+import org.apache.hadoop.hbase.nio.ByteBuff;
+import org.apache.hadoop.hbase.testclassification.RPCTests;
+import org.apache.hadoop.hbase.testclassification.SmallTests;
+import org.junit.ClassRule;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import org.apache.hbase.thirdparty.io.netty.util.ResourceLeakDetector;
+import org.apache.hbase.thirdparty.io.netty.util.internal.logging.InternalLogLevel;
+import org.apache.hbase.thirdparty.io.netty.util.internal.logging.InternalLogger;
+import org.apache.hbase.thirdparty.io.netty.util.internal.logging.InternalLoggerFactory;
+import org.apache.hbase.thirdparty.io.netty.util.internal.logging.Slf4JLoggerFactory;
+
+@Category({ RPCTests.class, SmallTests.class })
+public class TestByteBuffAllocatorLeakDetection {
+
+  @ClassRule
+  public static final HBaseClassTestRule CLASS_RULE =
+    HBaseClassTestRule.forClass(TestByteBuffAllocatorLeakDetection.class);
+
+  @SuppressWarnings("unused")
+  @Test
+  public void testLeakDetection() throws InterruptedException {
+    InternalLoggerFactory original = InternalLoggerFactory.getDefaultFactory();
+    AtomicInteger leaksDetected = new AtomicInteger();
+    InternalLoggerFactory.setDefaultFactory(new MockedLoggerFactory(leaksDetected));
+
+    ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);
+    assertTrue(ResourceLeakDetector.isEnabled());
+
+    try {
+      int maxBuffersInPool = 10;
+      int bufSize = 1024;
+      int minSize = bufSize / 8;
+      ByteBuffAllocator alloc = new ByteBuffAllocator(true, maxBuffersInPool, bufSize, minSize);
+
+      // tracking leaks happens on creation of a RefCnt, through a call to detector.track().
+      // If a leak occurs, but detector.track() is never called again, the leak will not be
+      // realized. Further, causing a leak requires a GC event. So below we do some allocations,
+      // cause some GC's, do more allocations, and then expect a leak to show up.
+
+      // first allocate on-heap. we expect to not see a leak from this, because we
+      // dont count on-heap references
+      alloc.allocate(minSize - 1);
+      System.gc();
+      Thread.sleep(1000);
+
+      // cause an allocation to trigger a leak detection, if there were one.
+      // keep a reference so we don't trigger a leak right away from this.
+      ByteBuff reference = alloc.allocate(minSize * 2);
+      assertEquals(0, leaksDetected.get());
+
+      // allocate, but don't keep a reference. this should cause a leak
+      alloc.allocate(minSize * 2);
+      System.gc();
+      Thread.sleep(1000);
+
+      // allocate again, this should cause the above leak to be detected
+      alloc.allocate(minSize * 2);
+      assertEquals(1, leaksDetected.get());
+    } finally {
+      InternalLoggerFactory.setDefaultFactory(original);
+    }
+  }
+
+  private static class MockedLoggerFactory extends Slf4JLoggerFactory {
+
+    private AtomicInteger leaksDetected;
+
+    public MockedLoggerFactory(AtomicInteger leaksDetected) {
+      this.leaksDetected = leaksDetected;
+    }
+
+    @Override
+    public InternalLogger newInstance(String name) {
+      InternalLogger delegate = super.newInstance(name);
+      return new MockedLogger(leaksDetected, delegate);
+    }
+  }
+
+  private static class MockedLogger implements InternalLogger {
+
+    private AtomicInteger leaksDetected;
+    private InternalLogger delegate;
+
+    public MockedLogger(AtomicInteger leaksDetected, InternalLogger delegate) {
+      this.leaksDetected = leaksDetected;
+      this.delegate = delegate;
+    }
+
+    private void maybeCountLeak(String msgOrFormat) {
+      if (msgOrFormat.startsWith("LEAK")) {
+        leaksDetected.incrementAndGet();
+      }
+    }
+
+    @Override
+    public void error(String msg) {
+      maybeCountLeak(msg);
+      delegate.error(msg);
+    }
+
+    @Override
+    public void error(String format, Object arg) {
+      maybeCountLeak(format);
+      delegate.error(format, arg);
+    }
+
+    @Override
+    public void error(String format, Object argA, Object argB) {
+      maybeCountLeak(format);
+      delegate.error(format, argA, argB);
+    }
+
+    @Override
+    public void error(String format, Object... arguments) {
+      maybeCountLeak(format);
+      delegate.error(format, arguments);
+    }
+
+    @Override
+    public void error(String msg, Throwable t) {
+      maybeCountLeak(msg);
+      delegate.error(msg, t);
+    }
+
+    @Override
+    public void error(Throwable t) {
+      delegate.error(t);
+    }
+
+    @Override
+    public String name() {
+      return delegate.name();
+    }
+
+    @Override
+    public boolean isTraceEnabled() {
+      return delegate.isTraceEnabled();
+    }
+
+    @Override
+    public void trace(String msg) {
+      delegate.trace(msg);
+    }
+
+    @Override
+    public void trace(String format, Object arg) {
+      delegate.trace(format, arg);
+    }
+
+    @Override
+    public void trace(String format, Object argA, Object argB) {
+      delegate.trace(format, argA, argB);
+    }
+
+    @Override
+    public void trace(String format, Object... arguments) {
+      delegate.trace(format, arguments);
+    }
+
+    @Override
+    public void trace(String msg, Throwable t) {
+      delegate.trace(msg, t);
+    }
+
+    @Override
+    public void trace(Throwable t) {
+      delegate.trace(t);
+    }
+
+    @Override
+    public boolean isDebugEnabled() {
+      return delegate.isDebugEnabled();
+    }
+
+    @Override
+    public void debug(String msg) {
+      delegate.debug(msg);
+    }
+
+    @Override
+    public void debug(String format, Object arg) {
+      delegate.debug(format, arg);
+    }
+
+    @Override
+    public void debug(String format, Object argA, Object argB) {
+      delegate.debug(format, argA, argB);
+    }
+
+    @Override
+    public void debug(String format, Object... arguments) {
+      delegate.debug(format, arguments);
+    }
+
+    @Override
+    public void debug(String msg, Throwable t) {
+      delegate.debug(msg, t);
+    }
+
+    @Override
+    public void debug(Throwable t) {
+      delegate.debug(t);
+    }
+
+    @Override
+    public boolean isInfoEnabled() {
+      return delegate.isInfoEnabled();
+    }
+
+    @Override
+    public void info(String msg) {
+      delegate.info(msg);
+    }
+
+    @Override
+    public void info(String format, Object arg) {
+      delegate.info(format, arg);
+    }
+
+    @Override
+    public void info(String format, Object argA, Object argB) {
+      delegate.info(format, argA, argB);
+    }
+
+    @Override
+    public void info(String format, Object... arguments) {
+      delegate.info(format, arguments);
+    }
+
+    @Override
+    public void info(String msg, Throwable t) {
+      delegate.info(msg, t);
+    }
+
+    @Override
+    public void info(Throwable t) {
+      delegate.info(t);
+    }
+
+    @Override
+    public boolean isWarnEnabled() {
+      return delegate.isWarnEnabled();
+    }
+
+    @Override
+    public void warn(String msg) {
+      delegate.warn(msg);
+    }
+
+    @Override
+    public void warn(String format, Object arg) {
+      delegate.warn(format, arg);
+    }
+
+    @Override
+    public void warn(String format, Object... arguments) {
+      delegate.warn(format, arguments);
+    }
+
+    @Override
+    public void warn(String format, Object argA, Object argB) {
+      delegate.warn(format, argA, argB);
+    }
+
+    @Override
+    public void warn(String msg, Throwable t) {
+      delegate.warn(msg, t);
+    }
+
+    @Override
+    public void warn(Throwable t) {
+      delegate.warn(t);
+    }
+
+    @Override
+    public boolean isErrorEnabled() {
+      return delegate.isErrorEnabled();
+    }
+
+    @Override
+    public boolean isEnabled(InternalLogLevel level) {
+      return delegate.isEnabled(level);
+    }
+
+    @Override
+    public void log(InternalLogLevel level, String msg) {
+      delegate.log(level, msg);
+    }
+
+    @Override
+    public void log(InternalLogLevel level, String format, Object arg) {
+      delegate.log(level, format, arg);
+    }
+
+    @Override
+    public void log(InternalLogLevel level, String format, Object argA, Object argB) {
+      delegate.log(level, format, argA, argB);
+    }
+
+    @Override
+    public void log(InternalLogLevel level, String format, Object... arguments) {
+      delegate.log(level, format, arguments);
+    }
+
+    @Override
+    public void log(InternalLogLevel level, String msg, Throwable t) {
+      delegate.log(level, msg, t);
+    }
+
+    @Override
+    public void log(InternalLogLevel level, Throwable t) {
+      delegate.log(level, t);
+    }
+  }
+}
