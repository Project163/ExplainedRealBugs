diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestThreads.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestThreads.java
index 67ea4aa33f..24837afe20 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestThreads.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestThreads.java
@@ -26,16 +26,18 @@ import org.apache.hadoop.hbase.SmallTests;
 import org.junit.Test;
 import org.junit.experimental.categories.Category;
 
+import java.util.concurrent.atomic.AtomicBoolean;
+
 @Category(SmallTests.class)
 public class TestThreads {
   private static final Log LOG = LogFactory.getLog(TestThreads.class);
 
-  private static final int SLEEP_TIME_MS = 5000;
-  private static final int TOLERANCE_MS = (int) (0.05 * SLEEP_TIME_MS);
+  private static final int SLEEP_TIME_MS = 3000;
+  private static final int TOLERANCE_MS = (int) (0.10 * SLEEP_TIME_MS);
 
-  private volatile boolean wasInterrupted;
+  private final AtomicBoolean wasInterrupted = new AtomicBoolean(false);
 
-  @Test(timeout=6000)
+  @Test(timeout=60000)
   public void testSleepWithoutInterrupt() throws InterruptedException {
     Thread sleeper = new Thread(new Runnable() {
       @Override
@@ -43,34 +45,34 @@ public class TestThreads {
         LOG.debug("Sleeper thread: sleeping for " + SLEEP_TIME_MS);
         Threads.sleepWithoutInterrupt(SLEEP_TIME_MS);
         LOG.debug("Sleeper thread: finished sleeping");
-        wasInterrupted = Thread.currentThread().isInterrupted();
+        wasInterrupted.set(Thread.currentThread().isInterrupted());
       }
     });
     LOG.debug("Starting sleeper thread (" + SLEEP_TIME_MS + " ms)");
     sleeper.start();
     long startTime = System.currentTimeMillis();
-    LOG.debug("Main thread: sleeping for 500 ms");
-    Threads.sleep(500);
+    LOG.debug("Main thread: sleeping for 200 ms");
+    Threads.sleep(200);
 
-    LOG.debug("Interrupting the sleeper thread and sleeping for 2000 ms");
+    LOG.debug("Interrupting the sleeper thread and sleeping for 500 ms");
     sleeper.interrupt();
-    Threads.sleep(2000);
+    Threads.sleep(500);
 
-    LOG.debug("Interrupting the sleeper thread and sleeping for 1000 ms");
+    LOG.debug("Interrupting the sleeper thread and sleeping for 800 ms");
     sleeper.interrupt();
-    Threads.sleep(1000);
+    Threads.sleep(800);
 
     LOG.debug("Interrupting the sleeper thread again");
     sleeper.interrupt();
     sleeper.join();
 
     assertTrue("sleepWithoutInterrupt did not preserve the thread's " +
-        "interrupted status", wasInterrupted);
+        "interrupted status", wasInterrupted.get());
 
     long timeElapsed = System.currentTimeMillis() - startTime;
+    // We expect to wait at least SLEEP_TIME_MS, but we can wait more if there is a GC.
     assertTrue("Elapsed time " + timeElapsed + " ms is out of the expected " +
-        "range of the sleep time " + SLEEP_TIME_MS,
-        Math.abs(timeElapsed - SLEEP_TIME_MS) < TOLERANCE_MS);
+        " sleep time of " + SLEEP_TIME_MS, SLEEP_TIME_MS - timeElapsed < TOLERANCE_MS);
     LOG.debug("Target sleep time: " + SLEEP_TIME_MS + ", time elapsed: " +
         timeElapsed);
   }
