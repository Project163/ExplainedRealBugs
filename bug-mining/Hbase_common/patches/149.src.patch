diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java
index f1cb5e1c42..4bbbf5fab6 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java
@@ -973,6 +973,12 @@ public final class HConstants {
   /** Configuration key for enabling HLog encryption, a boolean */
   public static final String ENABLE_WAL_ENCRYPTION = "hbase.regionserver.wal.encryption";
 
+  /** Configuration key for setting RPC codec class name */
+  public static final String RPC_CODEC_CONF_KEY = "hbase.client.rpc.codec";
+
+  /** Configuration key for setting replication codec class name */
+  public static final String REPLICATION_CODEC_CONF_KEY = "hbase.replication.rpc.codec";
+
   private HConstants() {
     // Can't be instantiated with this ctor.
   }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
index aa71ec6785..d08897cc52 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
@@ -2840,8 +2840,34 @@ public class KeyValue implements Cell, HeapSize, Cloneable {
    * @see #create(DataInput) for the inverse function
    * @see #write(KeyValue, DataOutput)
    */
-  public static long oswrite(final KeyValue kv, final OutputStream out) throws IOException {
+  @Deprecated
+  public static long oswrite(final KeyValue kv, final OutputStream out)
+      throws IOException {
+    int length = kv.getLength();
+    // This does same as DataOuput#writeInt (big-endian, etc.)
+    out.write(Bytes.toBytes(length));
+    out.write(kv.getBuffer(), kv.getOffset(), length);
+    return length + Bytes.SIZEOF_INT;
+  }
+
+  /**
+   * Write out a KeyValue in the manner in which we used to when KeyValue was a Writable but do
+   * not require a {@link DataOutput}, just take plain {@link OutputStream}
+   * Named <code>oswrite</code> so does not clash with {@link #write(KeyValue, DataOutput)}
+   * @param kv
+   * @param out
+   * @param withTags
+   * @return Length written on stream
+   * @throws IOException
+   * @see #create(DataInput) for the inverse function
+   * @see #write(KeyValue, DataOutput)
+   */
+  public static long oswrite(final KeyValue kv, final OutputStream out, final boolean withTags)
+      throws IOException {
     int length = kv.getLength();
+    if (!withTags) {
+      length = kv.getKeyLength() + kv.getValueLength() + KEYVALUE_INFRASTRUCTURE_SIZE;
+    }
     // This does same as DataOuput#writeInt (big-endian, etc.)
     out.write(Bytes.toBytes(length));
     out.write(kv.getBuffer(), kv.getOffset(), length);
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/CellCodecV2.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/CellCodecWithTags.java
similarity index 97%
rename from hbase-common/src/main/java/org/apache/hadoop/hbase/codec/CellCodecV2.java
rename to hbase-common/src/main/java/org/apache/hadoop/hbase/codec/CellCodecWithTags.java
index 45c4de6523..809a65f87d 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/CellCodecV2.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/CellCodecWithTags.java
@@ -30,9 +30,10 @@ import org.apache.hadoop.hbase.util.Bytes;
 /**
  * Basic Cell codec that just writes out all the individual elements of a Cell including the tags.
  * Uses ints delimiting all lengths. Profligate. Needs tune up.
+ * <b>Use this Codec only at server side.</b>
  */
 @InterfaceAudience.Private
-public class CellCodecV2 implements Codec {
+public class CellCodecWithTags implements Codec {
   static class CellEncoder extends BaseEncoder {
     CellEncoder(final OutputStream out) {
       super(out);
@@ -61,7 +62,7 @@ public class CellCodecV2 implements Codec {
 
     /**
      * Write int length followed by array bytes.
-     * 
+     *
      * @param bytes
      * @param offset
      * @param length
@@ -118,4 +119,4 @@ public class CellCodecV2 implements Codec {
   public Encoder getEncoder(OutputStream os) {
     return new CellEncoder(os);
   }
-}
+}
\ No newline at end of file
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/KeyValueCodec.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/KeyValueCodec.java
index f1626c2e37..2e67297f9a 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/KeyValueCodec.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/KeyValueCodec.java
@@ -55,7 +55,8 @@ public class KeyValueCodec implements Codec {
       checkFlushed();
       // This is crass and will not work when KV changes. Also if passed a non-kv Cell, it will
       // make expensive copy.
-      KeyValue.oswrite((KeyValue)KeyValueUtil.ensureKeyValue(cell), this.out);
+      // Do not write tags over RPC
+      KeyValue.oswrite((KeyValue) KeyValueUtil.ensureKeyValue(cell), this.out, false);
     }
   }
 
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/KeyValueCodecWithTags.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/KeyValueCodecWithTags.java
new file mode 100644
index 0000000000..5b532e9a20
--- /dev/null
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/codec/KeyValueCodecWithTags.java
@@ -0,0 +1,91 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.codec;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValueUtil;
+
+/**
+ * Codec that does KeyValue version 1 serialization with serializing tags also.
+ *
+ * <p>
+ * Encodes by casting Cell to KeyValue and writing out the backing array with a length prefix. This
+ * is how KVs were serialized in Puts, Deletes and Results pre-0.96. Its what would happen if you
+ * called the Writable#write KeyValue implementation. This encoder will fail if the passed Cell is
+ * not an old-school pre-0.96 KeyValue. Does not copy bytes writing. It just writes them direct to
+ * the passed stream.
+ *
+ * <p>
+ * If you wrote two KeyValues to this encoder, it would look like this in the stream:
+ *
+ * <pre>
+ * length-of-KeyValue1 // A java int with the length of KeyValue1 backing array
+ * KeyValue1 backing array filled with a KeyValue serialized in its particular format
+ * length-of-KeyValue2
+ * KeyValue2 backing array
+ * </pre>
+ *
+ * Note: The only difference of this with KeyValueCodec is the latter ignores tags in KeyValues.
+ * <b>Use this Codec only at server side.</b>
+ */
+@InterfaceAudience.Private
+public class KeyValueCodecWithTags implements Codec {
+  public static class KeyValueEncoder extends BaseEncoder {
+    public KeyValueEncoder(final OutputStream out) {
+      super(out);
+    }
+
+    @Override
+    public void write(Cell cell) throws IOException {
+      checkFlushed();
+      // This is crass and will not work when KV changes. Also if passed a non-kv Cell, it will
+      // make expensive copy.
+      // Write tags
+      KeyValue.oswrite((KeyValue) KeyValueUtil.ensureKeyValue(cell), this.out, true);
+    }
+  }
+
+  public static class KeyValueDecoder extends BaseDecoder {
+    public KeyValueDecoder(final InputStream in) {
+      super(in);
+    }
+
+    protected Cell parseCell() throws IOException {
+      return KeyValue.iscreate(in);
+    }
+  }
+
+  /**
+   * Implementation depends on {@link InputStream#available()}
+   */
+  @Override
+  public Decoder getDecoder(final InputStream is) {
+    return new KeyValueDecoder(is);
+  }
+
+  @Override
+  public Encoder getEncoder(OutputStream os) {
+    return new KeyValueEncoder(os);
+  }
+}
\ No newline at end of file
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestCellCodecV2.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestCellCodecWithTags.java
similarity index 98%
rename from hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestCellCodecV2.java
rename to hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestCellCodecWithTags.java
index 98adf57699..1499a91dd5 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestCellCodecV2.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestCellCodecWithTags.java
@@ -42,14 +42,14 @@ import com.google.common.io.CountingInputStream;
 import com.google.common.io.CountingOutputStream;
 
 @Category(SmallTests.class)
-public class TestCellCodecV2 {
+public class TestCellCodecWithTags {
 
   @Test
   public void testCellWithTag() throws IOException {
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     CountingOutputStream cos = new CountingOutputStream(baos);
     DataOutputStream dos = new DataOutputStream(cos);
-    Codec codec = new CellCodecV2();
+    Codec codec = new CellCodecWithTags();
     Codec.Encoder encoder = codec.getEncoder(dos);
     final Cell cell1 = new KeyValue(Bytes.toBytes("r"), Bytes.toBytes("f"), Bytes.toBytes("1"),
         HConstants.LATEST_TIMESTAMP, Bytes.toBytes("1"), new Tag[] {
@@ -110,4 +110,4 @@ public class TestCellCodecV2 {
     dis.close();
     assertEquals(offset, cis.getCount());
   }
-}
+}
\ No newline at end of file
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestKeyValueCodecWithTags.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestKeyValueCodecWithTags.java
new file mode 100644
index 0000000000..d8dd7fe04d
--- /dev/null
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/codec/TestKeyValueCodecWithTags.java
@@ -0,0 +1,113 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.codec;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.CellComparator;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.Tag;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+
+import com.google.common.io.CountingInputStream;
+import com.google.common.io.CountingOutputStream;
+
+@Category(SmallTests.class)
+public class TestKeyValueCodecWithTags {
+
+  @Test
+  public void testKeyValueWithTag() throws IOException {
+    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+    CountingOutputStream cos = new CountingOutputStream(baos);
+    DataOutputStream dos = new DataOutputStream(cos);
+    Codec codec = new KeyValueCodecWithTags();
+    Codec.Encoder encoder = codec.getEncoder(dos);
+    final KeyValue kv1 = new KeyValue(Bytes.toBytes("r"), Bytes.toBytes("f"), Bytes.toBytes("1"),
+        HConstants.LATEST_TIMESTAMP, Bytes.toBytes("1"), new Tag[] {
+            new Tag((byte) 1, Bytes.toBytes("teststring1")),
+            new Tag((byte) 2, Bytes.toBytes("teststring2")) });
+    final KeyValue kv2 = new KeyValue(Bytes.toBytes("r"), Bytes.toBytes("f"), Bytes.toBytes("2"),
+        HConstants.LATEST_TIMESTAMP, Bytes.toBytes("2"), new Tag[] { new Tag((byte) 1,
+            Bytes.toBytes("teststring3")), });
+    final KeyValue kv3 = new KeyValue(Bytes.toBytes("r"), Bytes.toBytes("f"), Bytes.toBytes("3"),
+        HConstants.LATEST_TIMESTAMP, Bytes.toBytes("3"), new Tag[] {
+            new Tag((byte) 2, Bytes.toBytes("teststring4")),
+            new Tag((byte) 2, Bytes.toBytes("teststring5")),
+            new Tag((byte) 1, Bytes.toBytes("teststring6")) });
+
+    encoder.write(kv1);
+    encoder.write(kv2);
+    encoder.write(kv3);
+    encoder.flush();
+    dos.close();
+    long offset = cos.getCount();
+    CountingInputStream cis = new CountingInputStream(new ByteArrayInputStream(baos.toByteArray()));
+    DataInputStream dis = new DataInputStream(cis);
+    Codec.Decoder decoder = codec.getDecoder(dis);
+    assertTrue(decoder.advance());
+    Cell c = decoder.current();
+    assertTrue(CellComparator.equals(c, kv1));
+    List<Tag> tags = Tag.asList(c.getTagsArray(), c.getTagsOffset(), c.getTagsLength());
+    assertEquals(2, tags.size());
+    Tag tag = tags.get(0);
+    assertEquals(1, tag.getType());
+    assertTrue(Bytes.equals(Bytes.toBytes("teststring1"), tag.getValue()));
+    tag = tags.get(1);
+    assertEquals(2, tag.getType());
+    assertTrue(Bytes.equals(Bytes.toBytes("teststring2"), tag.getValue()));
+    assertTrue(decoder.advance());
+    c = decoder.current();
+    assertTrue(CellComparator.equals(c, kv2));
+    tags = Tag.asList(c.getTagsArray(), c.getTagsOffset(), c.getTagsLength());
+    assertEquals(1, tags.size());
+    tag = tags.get(0);
+    assertEquals(1, tag.getType());
+    assertTrue(Bytes.equals(Bytes.toBytes("teststring3"), tag.getValue()));
+    assertTrue(decoder.advance());
+    c = decoder.current();
+    assertTrue(CellComparator.equals(c, kv3));
+    tags = Tag.asList(c.getTagsArray(), c.getTagsOffset(), c.getTagsLength());
+    assertEquals(3, tags.size());
+    tag = tags.get(0);
+    assertEquals(2, tag.getType());
+    assertTrue(Bytes.equals(Bytes.toBytes("teststring4"), tag.getValue()));
+    tag = tags.get(1);
+    assertEquals(2, tag.getType());
+    assertTrue(Bytes.equals(Bytes.toBytes("teststring5"), tag.getValue()));
+    tag = tags.get(2);
+    assertEquals(1, tag.getType());
+    assertTrue(Bytes.equals(Bytes.toBytes("teststring6"), tag.getValue()));
+    assertFalse(decoder.advance());
+    dis.close();
+    assertEquals(offset, cis.getCount());
+  }
+}
\ No newline at end of file
