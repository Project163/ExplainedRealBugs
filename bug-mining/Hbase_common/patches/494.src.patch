diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java
index e6c8e3ded6..4af035a94f 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/CellComparatorImpl.java
@@ -17,16 +17,12 @@
  */
 package org.apache.hadoop.hbase;
 
-import java.nio.ByteBuffer;
 import java.util.Comparator;
 import org.apache.hadoop.hbase.KeyValue.Type;
 import org.apache.hadoop.hbase.util.ByteBufferUtils;
 import org.apache.hadoop.hbase.util.Bytes;
 import org.apache.yetus.audience.InterfaceAudience;
 import org.apache.yetus.audience.InterfaceStability;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import org.apache.hbase.thirdparty.com.google.common.primitives.Longs;
 
 /**
  * Compare two HBase cells.  Do not use this method comparing <code>-ROOT-</code> or
@@ -48,7 +44,6 @@ import org.apache.hbase.thirdparty.com.google.common.primitives.Longs;
 @InterfaceAudience.Private
 @InterfaceStability.Evolving
 public class CellComparatorImpl implements CellComparator {
-  static final Logger LOG = LoggerFactory.getLogger(CellComparatorImpl.class);
 
   /**
    * Comparator for plain key/values; i.e. non-catalog table key/values. Works on Key portion
@@ -56,12 +51,6 @@ public class CellComparatorImpl implements CellComparator {
    */
   public static final CellComparatorImpl COMPARATOR = new CellComparatorImpl();
 
-  /**
-   * A {@link CellComparatorImpl} for <code>hbase:meta</code> catalog table
-   * {@link KeyValue}s.
-   */
-  public static final CellComparatorImpl META_COMPARATOR = new MetaCellComparator();
-
   @Override
   public final int compare(final Cell a, final Cell b) {
     return compare(a, b, false);
@@ -213,7 +202,7 @@ public class CellComparatorImpl implements CellComparator {
   /**
    * Compares the row part of the cell with a simple plain byte[] like the
    * stopRow in Scan. This should be used with context where for hbase:meta
-   * cells the {{@link #META_COMPARATOR} should be used
+   * cells the {{@link MetaCellComparator#META_COMPARATOR} should be used
    *
    * @param left
    *          the cell to be compared
@@ -291,117 +280,6 @@ public class CellComparatorImpl implements CellComparator {
     return Long.compare(rtimestamp, ltimestamp);
   }
 
-  /**
-   * A {@link CellComparatorImpl} for <code>hbase:meta</code> catalog table
-   * {@link KeyValue}s.
-   */
-  public static class MetaCellComparator extends CellComparatorImpl {
-    // TODO: Do we need a ByteBufferKeyValue version of this?
-    @Override
-    public int compareRows(final Cell left, final Cell right) {
-      return compareRows(left.getRowArray(), left.getRowOffset(), left.getRowLength(),
-          right.getRowArray(), right.getRowOffset(), right.getRowLength());
-    }
-
-    @Override
-    public int compareRows(Cell left, byte[] right, int roffset, int rlength) {
-      return compareRows(left.getRowArray(), left.getRowOffset(), left.getRowLength(), right,
-          roffset, rlength);
-    }
-
-    @Override
-    public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {
-      int diff = compareRows(a, b);
-      if (diff != 0) {
-        return diff;
-      }
-
-      diff = compareWithoutRow(a, b);
-      if (diff != 0) {
-        return diff;
-      }
-
-      // Negate following comparisons so later edits show up first mvccVersion: later sorts first
-      return ignoreSequenceid? diff: Longs.compare(b.getSequenceId(), a.getSequenceId());
-    }
-
-    private static int compareRows(byte[] left, int loffset, int llength, byte[] right, int roffset,
-        int rlength) {
-      int leftDelimiter = Bytes.searchDelimiterIndex(left, loffset, llength, HConstants.DELIMITER);
-      int rightDelimiter = Bytes
-          .searchDelimiterIndex(right, roffset, rlength, HConstants.DELIMITER);
-      // Compare up to the delimiter
-      int lpart = (leftDelimiter < 0 ? llength : leftDelimiter - loffset);
-      int rpart = (rightDelimiter < 0 ? rlength : rightDelimiter - roffset);
-      int result = Bytes.compareTo(left, loffset, lpart, right, roffset, rpart);
-      if (result != 0) {
-        return result;
-      } else {
-        if (leftDelimiter < 0 && rightDelimiter >= 0) {
-          return -1;
-        } else if (rightDelimiter < 0 && leftDelimiter >= 0) {
-          return 1;
-        } else if (leftDelimiter < 0) {
-          return 0;
-        }
-      }
-      // Compare middle bit of the row.
-      // Move past delimiter
-      leftDelimiter++;
-      rightDelimiter++;
-      int leftFarDelimiter = Bytes.searchDelimiterIndexInReverse(left, leftDelimiter, llength
-          - (leftDelimiter - loffset), HConstants.DELIMITER);
-      int rightFarDelimiter = Bytes.searchDelimiterIndexInReverse(right, rightDelimiter, rlength
-          - (rightDelimiter - roffset), HConstants.DELIMITER);
-      // Now compare middlesection of row.
-      lpart = (leftFarDelimiter < 0 ? llength + loffset : leftFarDelimiter) - leftDelimiter;
-      rpart = (rightFarDelimiter < 0 ? rlength + roffset : rightFarDelimiter) - rightDelimiter;
-      result = Bytes.compareTo(left, leftDelimiter, lpart, right, rightDelimiter, rpart);
-      if (result != 0) {
-        return result;
-      } else {
-        if (leftDelimiter < 0 && rightDelimiter >= 0) {
-          return -1;
-        } else if (rightDelimiter < 0 && leftDelimiter >= 0) {
-          return 1;
-        } else if (leftDelimiter < 0) {
-          return 0;
-        }
-      }
-      // Compare last part of row, the rowid.
-      leftFarDelimiter++;
-      rightFarDelimiter++;
-      result = Bytes.compareTo(left, leftFarDelimiter, llength - (leftFarDelimiter - loffset),
-          right, rightFarDelimiter, rlength - (rightFarDelimiter - roffset));
-      return result;
-    }
-
-    @Override
-    public int compareRows(ByteBuffer row, Cell cell) {
-      byte [] array;
-      int offset;
-      int len = row.remaining();
-      if (row.hasArray()) {
-        array = row.array();
-        offset = row.position() + row.arrayOffset();
-      } else {
-        // We copy the row array if offheap just so we can do a compare. We do this elsewhere too
-        // in BBUtils when Cell is backed by an offheap ByteBuffer. Needs fixing so no copy. TODO.
-        array = new byte[len];
-        offset = 0;
-        ByteBufferUtils.copyFromBufferToArray(array, row, row.position(),
-          0, len);
-      }
-      // Reverse result since we swap the order of the params we pass below.
-      return -compareRows(cell, array, offset, len);
-    }
-
-    @Override
-    public Comparator getSimpleComparator() {
-      return this;
-    }
-  }
-
   @Override
   public Comparator getSimpleComparator() {
     return new BBKVComparator(this);
@@ -424,6 +302,6 @@ public class CellComparatorImpl implements CellComparator {
   public static CellComparator getCellComparator(byte [] tableName) {
     // FYI, TableName.toBytes does not create an array; just returns existing array pointer.
     return Bytes.equals(tableName, TableName.META_TABLE_NAME.toBytes())?
-      CellComparatorImpl.META_COMPARATOR: CellComparatorImpl.COMPARATOR;
+      MetaCellComparator.META_COMPARATOR: CellComparatorImpl.COMPARATOR;
   }
 }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
index ff09ea6c45..b7ddbab6c9 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
@@ -104,7 +104,8 @@ public class KeyValue implements ExtendedCell, Cloneable {
   /**
    * A {@link KVComparator} for <code>hbase:meta</code> catalog table
    * {@link KeyValue}s.
-   * @deprecated Use {@link CellComparatorImpl#META_COMPARATOR} instead. Deprecated for hbase 2.0, remove for hbase 3.0.
+   * @deprecated Use {@link MetaCellComparator#META_COMPARATOR} instead.
+   *   Deprecated for hbase 2.0, remove for hbase 3.0.
    */
   @Deprecated
   public static final KVComparator META_COMPARATOR = new MetaComparator();
@@ -1606,7 +1607,8 @@ public class KeyValue implements ExtendedCell, Cloneable {
   /**
    * A {@link KVComparator} for <code>hbase:meta</code> catalog table
    * {@link KeyValue}s.
-   * @deprecated : {@link CellComparatorImpl#META_COMPARATOR} to be used. Deprecated for hbase 2.0, remove for hbase 3.0.
+   * @deprecated : {@link MetaCellComparator#META_COMPARATOR} to be used.
+   *   Deprecated for hbase 2.0, remove for hbase 3.0.
    */
   @Deprecated
   public static class MetaComparator extends KVComparator {
@@ -1616,7 +1618,8 @@ public class KeyValue implements ExtendedCell, Cloneable {
      */
     @Override
     public int compare(final Cell left, final Cell right) {
-      return PrivateCellUtil.compareKeyIgnoresMvcc(CellComparatorImpl.META_COMPARATOR, left, right);
+      return PrivateCellUtil.compareKeyIgnoresMvcc(MetaCellComparator.META_COMPARATOR, left,
+        right);
     }
 
     @Override
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/MetaCellComparator.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/MetaCellComparator.java
new file mode 100644
index 0000000000..4c18cfe79d
--- /dev/null
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/MetaCellComparator.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.hadoop.hbase;
+
+import java.nio.ByteBuffer;
+import java.util.Comparator;
+
+import org.apache.hadoop.hbase.util.ByteBufferUtils;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.apache.yetus.audience.InterfaceAudience;
+import org.apache.yetus.audience.InterfaceStability;
+
+import org.apache.hbase.thirdparty.com.google.common.primitives.Longs;
+
+/**
+ * A {@link CellComparatorImpl} for <code>hbase:meta</code> catalog table
+ * {@link KeyValue}s.
+ */
+@InterfaceAudience.Private
+@InterfaceStability.Evolving
+public class MetaCellComparator extends CellComparatorImpl {
+
+  /**
+   * A {@link MetaCellComparator} for <code>hbase:meta</code> catalog table
+   * {@link KeyValue}s.
+   */
+  public static final MetaCellComparator META_COMPARATOR = new MetaCellComparator();
+
+  // TODO: Do we need a ByteBufferKeyValue version of this?
+  @Override
+  public int compareRows(final Cell left, final Cell right) {
+    return compareRows(left.getRowArray(), left.getRowOffset(), left.getRowLength(),
+      right.getRowArray(), right.getRowOffset(), right.getRowLength());
+  }
+
+  @Override
+  public int compareRows(Cell left, byte[] right, int roffset, int rlength) {
+    return compareRows(left.getRowArray(), left.getRowOffset(), left.getRowLength(), right, roffset,
+      rlength);
+  }
+
+  @Override
+  public int compare(final Cell a, final Cell b, boolean ignoreSequenceid) {
+    int diff = compareRows(a, b);
+    if (diff != 0) {
+      return diff;
+    }
+
+    diff = compareWithoutRow(a, b);
+    if (diff != 0) {
+      return diff;
+    }
+
+    // Negate following comparisons so later edits show up first mvccVersion: later sorts first
+    return ignoreSequenceid ? diff : Longs.compare(b.getSequenceId(), a.getSequenceId());
+  }
+
+  private static int compareRows(byte[] left, int loffset, int llength, byte[] right, int roffset,
+      int rlength) {
+    int leftDelimiter = Bytes.searchDelimiterIndex(left, loffset, llength, HConstants.DELIMITER);
+    int rightDelimiter = Bytes.searchDelimiterIndex(right, roffset, rlength, HConstants.DELIMITER);
+    // Compare up to the delimiter
+    int lpart = (leftDelimiter < 0 ? llength : leftDelimiter - loffset);
+    int rpart = (rightDelimiter < 0 ? rlength : rightDelimiter - roffset);
+    int result = Bytes.compareTo(left, loffset, lpart, right, roffset, rpart);
+    if (result != 0) {
+      return result;
+    } else {
+      if (leftDelimiter < 0 && rightDelimiter >= 0) {
+        return -1;
+      } else if (rightDelimiter < 0 && leftDelimiter >= 0) {
+        return 1;
+      } else if (leftDelimiter < 0) {
+        return 0;
+      }
+    }
+    // Compare middle bit of the row.
+    // Move past delimiter
+    leftDelimiter++;
+    rightDelimiter++;
+    int leftFarDelimiter = Bytes
+      .searchDelimiterIndexInReverse(left, leftDelimiter, llength - (leftDelimiter - loffset),
+        HConstants.DELIMITER);
+    int rightFarDelimiter = Bytes
+      .searchDelimiterIndexInReverse(right, rightDelimiter, rlength - (rightDelimiter - roffset),
+        HConstants.DELIMITER);
+    // Now compare middlesection of row.
+    lpart = (leftFarDelimiter < 0 ? llength + loffset : leftFarDelimiter) - leftDelimiter;
+    rpart = (rightFarDelimiter < 0 ? rlength + roffset : rightFarDelimiter) - rightDelimiter;
+    result = Bytes.compareTo(left, leftDelimiter, lpart, right, rightDelimiter, rpart);
+    if (result != 0) {
+      return result;
+    } else {
+      if (leftDelimiter < 0 && rightDelimiter >= 0) {
+        return -1;
+      } else if (rightDelimiter < 0 && leftDelimiter >= 0) {
+        return 1;
+      } else if (leftDelimiter < 0) {
+        return 0;
+      }
+    }
+    // Compare last part of row, the rowid.
+    leftFarDelimiter++;
+    rightFarDelimiter++;
+    result = Bytes.compareTo(left, leftFarDelimiter, llength - (leftFarDelimiter - loffset), right,
+      rightFarDelimiter, rlength - (rightFarDelimiter - roffset));
+    return result;
+  }
+
+  @Override
+  public int compareRows(ByteBuffer row, Cell cell) {
+    byte[] array;
+    int offset;
+    int len = row.remaining();
+    if (row.hasArray()) {
+      array = row.array();
+      offset = row.position() + row.arrayOffset();
+    } else {
+      // We copy the row array if offheap just so we can do a compare. We do this elsewhere too
+      // in BBUtils when Cell is backed by an offheap ByteBuffer. Needs fixing so no copy. TODO.
+      array = new byte[len];
+      offset = 0;
+      ByteBufferUtils.copyFromBufferToArray(array, row, row.position(), 0, len);
+    }
+    // Reverse result since we swap the order of the params we pass below.
+    return -compareRows(cell, array, offset, len);
+  }
+
+  @Override
+  public Comparator getSimpleComparator() {
+    return this;
+  }
+
+}
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
index a318515832..7762330a45 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestCellComparator.java
@@ -146,7 +146,7 @@ public class TestCellComparator {
         Bytes.toBytes("TestScanMultipleVersions,row_0500,1236020145502"), now));
     Cell bbb = createByteBufferKeyValueFromKeyValue(new KeyValue(
         Bytes.toBytes("TestScanMultipleVersions,,99999999999999"), now));
-    CellComparator c = CellComparatorImpl.META_COMPARATOR;
+    CellComparator c = MetaCellComparator.META_COMPARATOR;
     assertTrue(c.compare(bbb, aaa) < 0);
 
     Cell ccc = createByteBufferKeyValueFromKeyValue(
@@ -177,7 +177,7 @@ public class TestCellComparator {
   @Test
   public void testMetaComparisons2() {
     long now = System.currentTimeMillis();
-    CellComparator c = CellComparatorImpl.META_COMPARATOR;
+    CellComparator c = MetaCellComparator.META_COMPARATOR;
     assertTrue(c.compare(createByteBufferKeyValueFromKeyValue(new KeyValue(
             Bytes.toBytes(TableName.META_TABLE_NAME.getNameAsString()+",a,,0,1"), now)),
         createByteBufferKeyValueFromKeyValue(new KeyValue(
@@ -240,7 +240,7 @@ public class TestCellComparator {
     }
     assertTrue(assertion);
     // Make set with good comparator
-    set = new TreeSet<>(CellComparatorImpl.META_COMPARATOR);
+    set = new TreeSet<>(MetaCellComparator.META_COMPARATOR);
     Collections.addAll(set, keys);
     count = 0;
     for (Cell k: set) {
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
index 41bb0ec398..8b943be16b 100644
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
+++ b/hbase-common/src/test/java/org/apache/hadoop/hbase/TestKeyValue.java
@@ -151,7 +151,7 @@ public class TestKeyValue {
         Bytes.toBytes("TestScanMultipleVersions,row_0500,1236020145502"), now);
     KeyValue bbb = new KeyValue(
         Bytes.toBytes("TestScanMultipleVersions,,99999999999999"), now);
-    CellComparator c = CellComparatorImpl.META_COMPARATOR;
+    CellComparator c = MetaCellComparator.META_COMPARATOR;
     assertTrue(c.compare(bbb, aaa) < 0);
 
     KeyValue aaaa = new KeyValue(Bytes.toBytes("TestScanMultipleVersions,,1236023996656"),
@@ -166,14 +166,14 @@ public class TestKeyValue {
         Bytes.toBytes("info"), Bytes.toBytes("regioninfo"), 1236034574912L,
         (byte[])null);
     assertTrue(c.compare(x, y) < 0);
-    comparisons(CellComparatorImpl.META_COMPARATOR);
+    comparisons(MetaCellComparator.META_COMPARATOR);
     comparisons(CellComparatorImpl.COMPARATOR);
-    metacomparisons(CellComparatorImpl.META_COMPARATOR);
+    metacomparisons(MetaCellComparator.META_COMPARATOR);
   }
 
   @Test
   public void testMetaComparatorTableKeysWithCommaOk() {
-    CellComparator c = CellComparatorImpl.META_COMPARATOR;
+    CellComparator c = MetaCellComparator.META_COMPARATOR;
     long now = System.currentTimeMillis();
     // meta keys values are not quite right.  A users can enter illegal values
     // from shell when scanning meta.
@@ -194,13 +194,13 @@ public class TestKeyValue {
       Bytes.toBytes("fam"), Bytes.toBytes(""), Long.MAX_VALUE, (byte[])null);
     KeyValue rowB = new KeyValue(Bytes.toBytes("testtable,www.hbase.org/%20,99999"),
         Bytes.toBytes("fam"), Bytes.toBytes(""), Long.MAX_VALUE, (byte[])null);
-    assertTrue(CellComparatorImpl.META_COMPARATOR.compare(rowA, rowB) < 0);
+    assertTrue(MetaCellComparator.META_COMPARATOR.compare(rowA, rowB) < 0);
 
     rowA = new KeyValue(Bytes.toBytes("testtable,,1234"), Bytes.toBytes("fam"),
         Bytes.toBytes(""), Long.MAX_VALUE, (byte[])null);
     rowB = new KeyValue(Bytes.toBytes("testtable,$www.hbase.org/,99999"),
         Bytes.toBytes("fam"), Bytes.toBytes(""), Long.MAX_VALUE, (byte[])null);
-    assertTrue(CellComparatorImpl.META_COMPARATOR.compare(rowA, rowB) < 0);
+    assertTrue(MetaCellComparator.META_COMPARATOR.compare(rowA, rowB) < 0);
   }
 
   private void metacomparisons(final CellComparatorImpl c) {
@@ -264,7 +264,7 @@ public class TestKeyValue {
     }
     assertTrue(assertion);
     // Make set with good comparator
-    set = new TreeSet<>(CellComparatorImpl.META_COMPARATOR);
+    set = new TreeSet<>(MetaCellComparator.META_COMPARATOR);
     Collections.addAll(set, keys);
     count = 0;
     for (KeyValue k : set) {
@@ -519,7 +519,7 @@ public class TestKeyValue {
 
   @Test
   public void testMetaKeyComparator() {
-    CellComparator c = CellComparatorImpl.META_COMPARATOR;
+    CellComparator c = MetaCellComparator.META_COMPARATOR;
     long now = System.currentTimeMillis();
 
     KeyValue a = new KeyValue(Bytes.toBytes("table1"), now);
