diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
index f667cb6417..b93fd60350 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/KeyValue.java
@@ -737,7 +737,7 @@ public class KeyValue implements Cell, HeapSize, Cloneable {
         c.getTimestamp(), Type.codeToType(c.getTypeByte()), c.getValueArray(), c.getValueOffset(), 
         c.getValueLength(), c.getTagsArray(), c.getTagsOffset(), c.getTagsLength());
   }
-  
+
   /**
    * Create an empty byte[] representing a KeyValue
    * All lengths are preset and can be filled in later.
@@ -2053,10 +2053,38 @@ public class KeyValue implements Cell, HeapSize, Cloneable {
         return compare;
       }
 
+      // Negate following comparisons so later edits show up first
+
+      // compare log replay tag value if there is any
+      // when either keyvalue tagged with log replay sequence number, we need to compare them:
+      // 1) when both keyvalues have the tag, then use the tag values for comparison
+      // 2) when one has and the other doesn't have, the one without the log replay tag wins because
+      // it means the edit isn't from recovery but new one coming from clients during recovery
+      // 3) when both doesn't have, then skip to the next mvcc comparison
+      long leftChangeSeqNum = getReplaySeqNum(left);
+      long RightChangeSeqNum = getReplaySeqNum(right);
+      if (leftChangeSeqNum != Long.MAX_VALUE || RightChangeSeqNum != Long.MAX_VALUE) {
+        return Longs.compare(RightChangeSeqNum, leftChangeSeqNum);
+      }
+
       // compare Mvcc Version
-      // Negate this comparison so later edits show up first
       return Longs.compare(right.getMvccVersion(), left.getMvccVersion());
     }
+    
+    /**
+     * Return replay log sequence number for the cell
+     * @param c
+     * @return Long.MAX_VALUE if there is no LOG_REPLAY_TAG
+     */
+    private long getReplaySeqNum(final Cell c) {
+      Tag tag = Tag.getTag(c.getTagsArray(), c.getTagsOffset(), c.getTagsLength(), 
+        TagType.LOG_REPLAY_TAG_TYPE);
+
+      if(tag != null) {
+        return Bytes.toLong(tag.getBuffer(), tag.getTagOffset(), tag.getTagLength());
+      }
+      return Long.MAX_VALUE;
+    }
 
     public int compareTimestamps(final KeyValue left, final KeyValue right) {
       // Compare timestamps
@@ -2735,6 +2763,27 @@ public class KeyValue implements Cell, HeapSize, Cloneable {
     in.readFully(bytes);
     return new KeyValue(bytes, 0, length);
   }
+  
+  /**
+   * Create a new KeyValue by copying existing cell and adding new tags
+   * @param c
+   * @param newTags
+   * @return a new KeyValue instance with new tags
+   */
+  public static KeyValue cloneAndAddTags(Cell c, List<Tag> newTags) {
+    List<Tag> existingTags = null;
+    if(c.getTagsLength() > 0) {
+      existingTags = Tag.asList(c.getTagsArray(), c.getTagsOffset(), c.getTagsLength());
+      existingTags.addAll(newTags);
+    } else {
+      existingTags = newTags;
+    }
+    return new KeyValue(c.getRowArray(), c.getRowOffset(), (int)c.getRowLength(),
+      c.getFamilyArray(), c.getFamilyOffset(), (int)c.getFamilyLength(), 
+      c.getQualifierArray(), c.getQualifierOffset(), (int) c.getQualifierLength(), 
+      c.getTimestamp(), Type.codeToType(c.getTypeByte()), c.getValueArray(), c.getValueOffset(), 
+      c.getValueLength(), existingTags);
+  }
 
   /**
    * Create a KeyValue reading from the raw InputStream.
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java
index ad0c595a8d..225d6c2b9c 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/Tag.java
@@ -155,6 +155,26 @@ public class Tag {
     }
     return tags;
   }
+  
+  /**
+   * Retrieve the first tag from the tags byte array matching the passed in tag type
+   * @param b
+   * @param offset
+   * @param length
+   * @param type
+   * @return null if there is no tag of the passed in tag type
+   */
+  public static Tag getTag(byte[] b, int offset, int length, byte type) {
+    int pos = offset;
+    while (pos < offset + length) {
+      short tagLen = Bytes.toShort(b, pos);
+      if(b[pos + TAG_LENGTH_SIZE] == type) {
+        return new Tag(b, pos, (short) (tagLen + TAG_LENGTH_SIZE));
+      }
+      pos += TAG_LENGTH_SIZE + tagLen;
+    }
+    return null;
+  }
 
   /**
    * Returns the total length of the entire tag entity
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
new file mode 100644
index 0000000000..6c43c78026
--- /dev/null
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/TagType.java
@@ -0,0 +1,30 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase;
+
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.classification.InterfaceStability;
+
+@InterfaceAudience.Private
+@InterfaceStability.Evolving
+public final class TagType {
+  // Please declare new Tag Types here to avoid step on pre-existing tag types.
+  public static final byte ACL_TAG_TYPE = (byte) 1;
+  public static final byte VISIBILITY_TAG_TYPE = (byte) 2;
+  public static final byte LOG_REPLAY_TAG_TYPE = (byte) 3;
+}
