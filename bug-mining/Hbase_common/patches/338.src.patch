diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/TimeRange.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/TimeRange.java
index 212ad451cd..d5b250931f 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/TimeRange.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/TimeRange.java
@@ -36,11 +36,13 @@ import org.apache.hadoop.hbase.util.Bytes;
 @InterfaceAudience.Public
 @InterfaceStability.Stable
 public class TimeRange {
-  private static final long MIN_TIME = 0L;
-  private static final long MAX_TIME = Long.MAX_VALUE;
+  static final long INITIAL_MIN_TIMESTAMP = 0l;
+  private static final long MIN_TIME = INITIAL_MIN_TIMESTAMP;
+  static final long INITIAL_MAX_TIMESTAMP = Long.MAX_VALUE;
+  static final long MAX_TIME = INITIAL_MAX_TIMESTAMP;
   private long minStamp = MIN_TIME;
   private long maxStamp = MAX_TIME;
-  private boolean allTime = false;
+  private final boolean allTime;
 
   /**
    * Default constructor.
@@ -56,9 +58,7 @@ public class TimeRange {
    */
   public TimeRange(long minStamp) {
     this.minStamp = minStamp;
-    if (this.minStamp == MIN_TIME){
-      this.allTime = true;
-    }
+    this.allTime = this.minStamp == MIN_TIME;
   }
 
   /**
@@ -67,6 +67,7 @@ public class TimeRange {
    */
   public TimeRange(byte [] minStamp) {
     this.minStamp = Bytes.toLong(minStamp);
+    this.allTime = false;
   }
 
   /**
@@ -80,14 +81,12 @@ public class TimeRange {
       throw new IllegalArgumentException("Timestamp cannot be negative. minStamp:" + minStamp
         + ", maxStamp:" + maxStamp);
     }
-    if(maxStamp < minStamp) {
+    if (maxStamp < minStamp) {
       throw new IllegalArgumentException("maxStamp is smaller than minStamp");
     }
     this.minStamp = minStamp;
     this.maxStamp = maxStamp;
-    if (this.minStamp == MIN_TIME && this.maxStamp == MAX_TIME){
-      this.allTime = true;
-    }
+    this.allTime = this.minStamp == MIN_TIME && this.maxStamp == MAX_TIME;
   }
 
   /**
@@ -146,11 +145,27 @@ public class TimeRange {
    * @return true if within TimeRange, false if not
    */
   public boolean withinTimeRange(long timestamp) {
-    if(allTime) return true;
+    if (this.allTime) {
+      return true;
+    }
     // check if >= minStamp
     return (minStamp <= timestamp && timestamp < maxStamp);
   }
 
+  /**
+   * Check if the range has any overlap with TimeRange
+   * @param tr TimeRange
+   * @return True if there is overlap, false otherwise
+   */
+  // This method came from TimeRangeTracker. We used to go there for this function but better
+  // to come here to the immutable, unsynchronized datastructure at read time.
+  public boolean includesTimeRange(final TimeRange tr) {
+    if (this.allTime) {
+      return true;
+    }
+    return getMin() < tr.getMax() && getMax() >= tr.getMin();
+  }
+
   /**
    * Check if the specified timestamp is within this TimeRange.
    * <p>
