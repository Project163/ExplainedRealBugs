diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/HBaseConfiguration.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/HBaseConfiguration.java
index a8f9cf91da..9a0b38b610 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/HBaseConfiguration.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/HBaseConfiguration.java
@@ -24,6 +24,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.hadoop.classification.InterfaceAudience;
 import org.apache.hadoop.classification.InterfaceStability;
 import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.io.util.HeapMemorySizeUtil;
 import org.apache.hadoop.hbase.util.VersionInfo;
 
 /**
@@ -35,9 +36,6 @@ public class HBaseConfiguration extends Configuration {
 
   private static final Log LOG = LogFactory.getLog(HBaseConfiguration.class);
 
-  // a constant to convert a fraction to a percentage
-  private static final int CONVERT_TO_PERCENTAGE = 100;
-
   /**
    * Instantinating HBaseConfiguration() is deprecated. Please use
    * HBaseConfiguration#create() to construct a plain Configuration
@@ -73,39 +71,12 @@ public class HBaseConfiguration extends Configuration {
     }
   }
 
-  private static void checkForClusterFreeMemoryLimit(Configuration conf) {
-      if (conf.get("hbase.regionserver.global.memstore.upperLimit") != null) {
-        LOG.warn("hbase.regionserver.global.memstore.upperLimit is deprecated by "
-          + "hbase.regionserver.global.memstore.size");
-      }
-      float globalMemstoreSize = conf.getFloat("hbase.regionserver.global.memstore.size",
-        conf.getFloat("hbase.regionserver.global.memstore.upperLimit", 0.4f));
-      int gml = (int)(globalMemstoreSize * CONVERT_TO_PERCENTAGE);
-      float blockCacheUpperLimit =
-        conf.getFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY,
-          HConstants.HFILE_BLOCK_CACHE_SIZE_DEFAULT);
-      int bcul = (int)(blockCacheUpperLimit * CONVERT_TO_PERCENTAGE);
-      if (CONVERT_TO_PERCENTAGE - (gml + bcul)
-              < (int)(CONVERT_TO_PERCENTAGE *
-                      HConstants.HBASE_CLUSTER_MINIMUM_MEMORY_THRESHOLD)) {
-          throw new RuntimeException(
-            "Current heap configuration for MemStore and BlockCache exceeds " +
-            "the threshold required for successful cluster operation. " +
-            "The combined value cannot exceed 0.8. Please check " +
-            "the settings for hbase.regionserver.global.memstore.size and " +
-            "hfile.block.cache.size in your configuration. " +
-            "hbase.regionserver.global.memstore.size is " +
-            globalMemstoreSize +
-            " hfile.block.cache.size is " + blockCacheUpperLimit);
-      }
-  }
-
   public static Configuration addHbaseResources(Configuration conf) {
     conf.addResource("hbase-default.xml");
     conf.addResource("hbase-site.xml");
 
     checkDefaultsVersion(conf);
-    checkForClusterFreeMemoryLimit(conf);
+    HeapMemorySizeUtil.checkForClusterFreeMemoryLimit(conf);
     return conf;
   }
 
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java
index 93209fd325..24fa8e5df0 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/HConstants.java
@@ -1017,6 +1017,28 @@ public final class HConstants {
   public static final String HBASE_COORDINATED_STATE_MANAGER_CLASS =
     "hbase.coordinated.state.manager.class";
 
+  /**
+   * Configuration keys for Bucket cache
+   */
+  // TODO moving these bucket cache implementation specific configs to this level is violation of
+  // encapsulation. But as these has to be referred from hbase-common and bucket cache
+  // sits in hbase-server, there were no other go! Can we move the cache implementation to
+  // hbase-common?
+
+  /**
+   * Current ioengine options in include: heap, offheap and file:PATH (where PATH is the path
+   * to the file that will host the file-based cache.  See BucketCache#getIOEngineFromName() for
+   * list of supported ioengine options.
+   * <p>Set this option and a non-zero {@link #BUCKET_CACHE_SIZE_KEY} to enable bucket cache.
+   */
+  public static final String BUCKET_CACHE_IOENGINE_KEY = "hbase.bucketcache.ioengine";
+
+  /**
+   * When using bucket cache, this is a float that EITHER represents a percentage of total heap
+   * memory size to give to the cache (if < 1.0) OR, it is the capacity in megabytes of the cache.
+   */
+  public static final String BUCKET_CACHE_SIZE_KEY = "hbase.bucketcache.size";
+
   private HConstants() {
     // Can't be instantiated with this ctor.
   }
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/io/util/HeapMemorySizeUtil.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/util/HeapMemorySizeUtil.java
new file mode 100644
index 0000000000..ab7b715974
--- /dev/null
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/io/util/HeapMemorySizeUtil.java
@@ -0,0 +1,136 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.io.util;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.MemoryUsage;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.hadoop.classification.InterfaceAudience;
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.HConstants;
+
+@InterfaceAudience.Private
+public class HeapMemorySizeUtil {
+
+  public static final String MEMSTORE_SIZE_KEY = "hbase.regionserver.global.memstore.size";
+  public static final String MEMSTORE_SIZE_OLD_KEY =
+      "hbase.regionserver.global.memstore.upperLimit";
+  public static final String MEMSTORE_SIZE_LOWER_LIMIT_KEY =
+      "hbase.regionserver.global.memstore.size.lower.limit";
+  public static final String MEMSTORE_SIZE_LOWER_LIMIT_OLD_KEY =
+      "hbase.regionserver.global.memstore.lowerLimit";
+
+  public static final float DEFAULT_MEMSTORE_SIZE = 0.4f;
+  // Default lower water mark limit is 95% size of memstore size.
+  public static final float DEFAULT_MEMSTORE_SIZE_LOWER_LIMIT = 0.95f;
+
+  private static final Log LOG = LogFactory.getLog(HeapMemorySizeUtil.class);
+  // a constant to convert a fraction to a percentage
+  private static final int CONVERT_TO_PERCENTAGE = 100;
+
+  /**
+   * Checks whether we have enough heap memory left out after portion for Memstore and Block cache.
+   * We need atleast 20% of heap left out for other RS functions.
+   * @param conf
+   */
+  public static void checkForClusterFreeMemoryLimit(Configuration conf) {
+    if (conf.get(MEMSTORE_SIZE_OLD_KEY) != null) {
+      LOG.warn(MEMSTORE_SIZE_OLD_KEY + " is deprecated by " + MEMSTORE_SIZE_KEY);
+    }
+    float globalMemstoreSize = getGlobalMemStorePercent(conf, false);
+    int gml = (int)(globalMemstoreSize * CONVERT_TO_PERCENTAGE);
+    float blockCacheUpperLimit = getBlockCacheHeapPercent(conf);
+    int bcul = (int)(blockCacheUpperLimit * CONVERT_TO_PERCENTAGE);
+    if (CONVERT_TO_PERCENTAGE - (gml + bcul)
+            < (int)(CONVERT_TO_PERCENTAGE *
+                    HConstants.HBASE_CLUSTER_MINIMUM_MEMORY_THRESHOLD)) {
+      throw new RuntimeException("Current heap configuration for MemStore and BlockCache exceeds "
+          + "the threshold required for successful cluster operation. "
+          + "The combined value cannot exceed 0.8. Please check "
+          + "the settings for hbase.regionserver.global.memstore.size and "
+          + "hfile.block.cache.size in your configuration. "
+          + "hbase.regionserver.global.memstore.size is " + globalMemstoreSize
+          + " hfile.block.cache.size is " + blockCacheUpperLimit);
+    }
+  }
+
+  /**
+   * Retrieve global memstore configured size as percentage of total heap.
+   * @param conf
+   * @param logInvalid
+   */
+  public static float getGlobalMemStorePercent(final Configuration c, final boolean logInvalid) {
+    float limit = c.getFloat(MEMSTORE_SIZE_KEY,
+        c.getFloat(MEMSTORE_SIZE_OLD_KEY, DEFAULT_MEMSTORE_SIZE));
+    if (limit > 0.8f || limit < 0.05f) {
+      if (logInvalid) {
+        LOG.warn("Setting global memstore limit to default of " + DEFAULT_MEMSTORE_SIZE
+            + " because supplied value outside allowed range of 0.05 -> 0.8");
+      }
+      limit = DEFAULT_MEMSTORE_SIZE;
+    }
+    return limit;
+  }
+
+  /**
+   * Retrieve configured size for global memstore lower water mark as percentage of total heap.
+   * @param conf
+   * @param globalMemStorePercent
+   */
+  public static float getGlobalMemStoreLowerMark(final Configuration c, float globalMemStorePercent) {
+    String lowMarkPercentStr = c.get(MEMSTORE_SIZE_LOWER_LIMIT_KEY);
+    if (lowMarkPercentStr != null) {
+      return Float.parseFloat(lowMarkPercentStr);
+    }
+    String lowerWaterMarkOldValStr = c.get(MEMSTORE_SIZE_LOWER_LIMIT_OLD_KEY);
+    if (lowerWaterMarkOldValStr != null) {
+      LOG.warn(MEMSTORE_SIZE_LOWER_LIMIT_OLD_KEY + " is deprecated. Instead use "
+          + MEMSTORE_SIZE_LOWER_LIMIT_KEY);
+      float lowerWaterMarkOldVal = Float.parseFloat(lowerWaterMarkOldValStr);
+      if (lowerWaterMarkOldVal > globalMemStorePercent) {
+        lowerWaterMarkOldVal = globalMemStorePercent;
+        LOG.info("Setting globalMemStoreLimitLowMark == globalMemStoreLimit " + "because supplied "
+            + MEMSTORE_SIZE_LOWER_LIMIT_OLD_KEY + " was > " + MEMSTORE_SIZE_OLD_KEY);
+      }
+      return lowerWaterMarkOldVal / globalMemStorePercent;
+    }
+    return DEFAULT_MEMSTORE_SIZE_LOWER_LIMIT;
+  }
+
+  /**
+   * Retrieve configured size for on heap block cache as percentage of total heap.
+   * @param conf
+   */
+  public static float getBlockCacheHeapPercent(final Configuration conf) {
+    // L1 block cache is always on heap
+    float l1CachePercent = conf.getFloat(HConstants.HFILE_BLOCK_CACHE_SIZE_KEY,
+        HConstants.HFILE_BLOCK_CACHE_SIZE_DEFAULT);
+    float l2CachePercent = 0.0F;
+    String bucketCacheIOEngineName = conf.get(HConstants.BUCKET_CACHE_IOENGINE_KEY, null);
+    // L2 block cache can be on heap when IOEngine is "heap"
+    if (bucketCacheIOEngineName != null && bucketCacheIOEngineName.startsWith("heap")) {
+      float bucketCachePercentage = conf.getFloat(HConstants.BUCKET_CACHE_SIZE_KEY, 0F);
+      MemoryUsage mu = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
+      l2CachePercent = bucketCachePercentage < 1 ? bucketCachePercentage
+          : (bucketCachePercentage * 1024 * 1024) / mu.getMax();
+    }
+    return l1CachePercent + l2CachePercent;
+  }
+}
