diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/ServerName.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/ServerName.java
index 4ae500a2df..3166f6d9fd 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/ServerName.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/ServerName.java
@@ -29,13 +29,15 @@ import org.apache.hadoop.hbase.classification.InterfaceStability;
 import org.apache.hadoop.hbase.util.Addressing;
 import org.apache.hadoop.hbase.util.Bytes;
 
-import com.google.common.net.HostAndPort;
 import com.google.common.net.InetAddresses;
 
+import org.apache.hadoop.hbase.util.Address;
+
+
 /**
- * Instance of an HBase ServerName.
- * A server name is used uniquely identifying a server instance in a cluster and is made
- * of the combination of hostname, port, and startcode.  The startcode distingushes restarted
+ * Name of a particular incarnation of an HBase Server.
+ * A {@link ServerName} is used uniquely identifying a server instance in a cluster and is made
+ * of the combination of hostname, port, and startcode.  The startcode distinguishes restarted
  * servers on same hostname and port (startcode is usually timestamp of server startup). The
  * {@link #toString()} format of ServerName is safe to use in the  filesystem and as znode name
  * up in ZooKeeper.  Its format is:
@@ -44,15 +46,19 @@ import com.google.common.net.InetAddresses;
  * For example, if hostname is <code>www.example.org</code>, port is <code>1234</code>,
  * and the startcode for the regionserver is <code>1212121212</code>, then
  * the {@link #toString()} would be <code>www.example.org,1234,1212121212</code>.
- * 
+ *
  * <p>You can obtain a versioned serialized form of this class by calling
- * {@link #getVersionedBytes()}.  To deserialize, call {@link #parseVersionedServerName(byte[])}
- * 
+ * {@link #getVersionedBytes()}.  To deserialize, call
+ * {@link #parseVersionedServerName(byte[])}.
+ *
+ * <p>Use {@link #getAddress()} to obtain the Server hostname + port
+ * (Endpoint/Socket Address).
+ *
  * <p>Immutable.
  */
 @InterfaceAudience.Public
 @InterfaceStability.Evolving
-  public class ServerName implements Comparable<ServerName>, Serializable {
+public class ServerName implements Comparable<ServerName>, Serializable {
   private static final long serialVersionUID = 1367463982557264981L;
 
   /**
@@ -86,10 +92,8 @@ import com.google.common.net.InetAddresses;
   public static final String UNKNOWN_SERVERNAME = "#unknown#";
 
   private final String servername;
-  private final String hostnameOnly;
-  private final int port;
   private final long startcode;
-  private transient HostAndPort hostAndPort;
+  private transient Address address;
 
   /**
    * Cached versioned bytes of this ServerName instance.
@@ -99,18 +103,33 @@ import com.google.common.net.InetAddresses;
   public static final List<ServerName> EMPTY_SERVER_LIST = new ArrayList<ServerName>(0);
 
   protected ServerName(final String hostname, final int port, final long startcode) {
-    // Drop the domain is there is one; no need of it in a local cluster.  With it, we get long
-    // unwieldy names.
-    this.hostnameOnly = hostname;
-    this.port = port;
+    this(Address.fromParts(hostname, port), startcode);
+  }
+
+  private ServerName(final Address address, final long startcode) {
+    // Use HostAndPort to host port and hostname. Does validation and can do ipv6
+    this.address = address;
     this.startcode = startcode;
-    this.servername = getServerName(hostname, port, startcode);
+    this.servername = getServerName(this.address.getHostname(),
+        this.address.getPort(), startcode);
+  }
+
+  private ServerName(final String serverName) {
+    this(parseHostname(serverName), parsePort(serverName),
+      parseStartcode(serverName));
+  }
+
+  private ServerName(final String hostAndPort, final long startCode) {
+    this(Address.fromString(hostAndPort), startCode);
   }
 
   /**
    * @param hostname
    * @return hostname minus the domain, if there is one (will do pass-through on ip addresses)
+   * @deprecated Since 2.0. This is for internal use only.
    */
+  @Deprecated
+  // Make this private in hbase-3.0.
   static String getHostNameMinusDomain(final String hostname) {
     if (InetAddresses.isInetAddress(hostname)) return hostname;
     String [] parts = hostname.split("\\.");
@@ -118,16 +137,11 @@ import com.google.common.net.InetAddresses;
     return parts[0];
   }
 
-  private ServerName(final String serverName) {
-    this(parseHostname(serverName), parsePort(serverName),
-      parseStartcode(serverName));
-  }
-
-  private ServerName(final String hostAndPort, final long startCode) {
-    this(Addressing.parseHostname(hostAndPort),
-      Addressing.parsePort(hostAndPort), startCode);
-  }
-
+  /**
+   * @deprecated Since 2.0. Use {@link #valueOf(String)}
+   */
+  @Deprecated
+  // This is unused. Get rid of it.
   public static String parseHostname(final String serverName) {
     if (serverName == null || serverName.length() <= 0) {
       throw new IllegalArgumentException("Passed hostname is null or empty");
@@ -139,11 +153,21 @@ import com.google.common.net.InetAddresses;
     return serverName.substring(0, index);
   }
 
+  /**
+   * @deprecated Since 2.0. Use {@link #valueOf(String)}
+   */
+  @Deprecated
+  // This is unused. Get rid of it.
   public static int parsePort(final String serverName) {
     String [] split = serverName.split(SERVERNAME_SEPARATOR);
     return Integer.parseInt(split[1]);
   }
 
+  /**
+   * @deprecated Since 2.0. Use {@link #valueOf(String)}
+   */
+  @Deprecated
+  // This is unused. Get rid of it.
   public static long parseStartcode(final String serverName) {
     int index = serverName.lastIndexOf(SERVERNAME_SEPARATOR);
     return Long.parseLong(serverName.substring(index + 1));
@@ -189,7 +213,8 @@ import com.google.common.net.InetAddresses;
    */
   public String toShortString() {
     return Addressing.createHostAndPortStr(
-        getHostNameMinusDomain(hostnameOnly), port);
+        getHostNameMinusDomain(this.address.getHostname()),
+        this.address.getPort());
   }
 
   /**
@@ -208,11 +233,11 @@ import com.google.common.net.InetAddresses;
   }
 
   public String getHostname() {
-    return hostnameOnly;
+    return this.address.getHostname();
   }
 
   public int getPort() {
-    return port;
+    return this.address.getPort();
   }
 
   public long getStartcode() {
@@ -226,7 +251,10 @@ import com.google.common.net.InetAddresses;
    * @param startcode
    * @return Server name made of the concatenation of hostname, port and
    * startcode formatted as <code>&lt;hostname&gt; ',' &lt;port&gt; ',' &lt;startcode&gt;</code>
+   * @deprecated Since 2.0. Use {@link ServerName#valueOf(String, int, long)} instead.
    */
+  @Deprecated
+  // TODO: Make this private in hbase-3.0.
   static String getServerName(String hostName, int port, long startcode) {
     final StringBuilder name = new StringBuilder(hostName.length() + 1 + 5 + 1 + 13);
     name.append(hostName.toLowerCase(Locale.ROOT));
@@ -242,7 +270,9 @@ import com.google.common.net.InetAddresses;
    * @param startcode
    * @return Server name made of the concatenation of hostname, port and
    * startcode formatted as <code>&lt;hostname&gt; ',' &lt;port&gt; ',' &lt;startcode&gt;</code>
+   * @deprecated Since 2.0. Use {@link ServerName#valueOf(String, long)} instead.
    */
+  @Deprecated
   public static String getServerName(final String hostAndPort,
       final long startcode) {
     int index = hostAndPort.indexOf(":");
@@ -254,22 +284,23 @@ import com.google.common.net.InetAddresses;
   /**
    * @return Hostname and port formatted as described at
    * {@link Addressing#createHostAndPortStr(String, int)}
+   * @deprecated Since 2.0. Use {@link #getAddress()} instead.
    */
+  @Deprecated
   public String getHostAndPort() {
-    return Addressing.createHostAndPortStr(hostnameOnly, port);
+    return this.address.toString();
   }
 
-  public HostAndPort getHostPort() {
-    if (hostAndPort == null) {
-      hostAndPort = HostAndPort.fromParts(hostnameOnly, port);
-    }
-    return hostAndPort;
+  public Address getAddress() {
+    return this.address;
   }
 
   /**
    * @param serverName ServerName in form specified by {@link #getServerName()}
    * @return The server start code parsed from <code>servername</code>
+   * @deprecated Since 2.0. Use instance of ServerName to pull out start code.
    */
+  @Deprecated
   public static long getServerStartcodeFromServerName(final String serverName) {
     int index = serverName.lastIndexOf(SERVERNAME_SEPARATOR);
     return Long.parseLong(serverName.substring(index + 1));
@@ -279,7 +310,9 @@ import com.google.common.net.InetAddresses;
    * Utility method to excise the start code from a server name
    * @param inServerName full server name
    * @return server name less its start code
+   * @deprecated Since 2.0. Use {@link #getAddress()}
    */
+  @Deprecated
   public static String getServerNameLessStartCode(String inServerName) {
     if (inServerName != null && inServerName.length() > 0) {
       int index = inServerName.lastIndexOf(SERVERNAME_SEPARATOR);
@@ -296,7 +329,6 @@ import com.google.common.net.InetAddresses;
     if (compare != 0) return compare;
     compare = this.getPort() - other.getPort();
     if (compare != 0) return compare;
-
     return Long.compare(this.getStartcode(), other.getStartcode());
   }
 
@@ -320,6 +352,7 @@ import com.google.common.net.InetAddresses;
    */
   public static boolean isSameHostnameAndPort(final ServerName left,
       final ServerName right) {
+    // TODO: Make this left.getAddress().equals(right.getAddress())
     if (left == null) return false;
     if (right == null) return false;
     return left.getHostname().compareToIgnoreCase(right.getHostname()) == 0 &&
@@ -365,4 +398,4 @@ import com.google.common.net.InetAddresses;
     if (str == null ||str.isEmpty()) return false;
     return SERVERNAME_PATTERN.matcher(str).matches();
   }
-}
\ No newline at end of file
+}
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/rsgroup/RSGroupInfo.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/rsgroup/RSGroupInfo.java
index c4bb157c08..c1e9db7e5a 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/rsgroup/RSGroupInfo.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/rsgroup/RSGroupInfo.java
@@ -1,6 +1,4 @@
 /**
- * Copyright The Apache Software Foundation
- *
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -21,7 +19,6 @@
 package org.apache.hadoop.hbase.rsgroup;
 
 import java.util.Collection;
-import java.util.NavigableSet;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
@@ -29,10 +26,7 @@ import java.util.TreeSet;
 import org.apache.hadoop.hbase.TableName;
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
 import org.apache.hadoop.hbase.classification.InterfaceStability;
-import org.apache.hadoop.hbase.util.Addressing;
-
-import com.google.common.collect.Sets;
-import com.google.common.net.HostAndPort;
+import org.apache.hadoop.hbase.util.Address;
 
 /**
  * Stores the group information of region server groups.
@@ -45,18 +39,18 @@ public class RSGroupInfo {
   public static final String NAMESPACEDESC_PROP_GROUP = "hbase.rsgroup.name";
 
   private String name;
-  private SortedSet<HostAndPort> servers;
-  private NavigableSet<TableName> tables;
+  // Keep servers in a sorted set so has an expected ordering when displayed.
+  private SortedSet<Address> servers;
+  // Keep tables sorted too.
+  private SortedSet<TableName> tables;
 
   public RSGroupInfo(String name) {
-    this(name, Sets.<HostAndPort>newHashSet(), Sets.newTreeSet());
+    this(name, new TreeSet(), new TreeSet());
   }
 
-  RSGroupInfo(String name,
-              Set<HostAndPort> servers,
-              NavigableSet<TableName> tables) {
+  RSGroupInfo(String name, SortedSet<Address> servers, SortedSet<TableName> tables) {
     this.name = name;
-    this.servers = new TreeSet<>(new Addressing.HostAndPortComparable());
+    this.servers = servers == null? new TreeSet(): servers;
     this.servers.addAll(servers);
     this.tables = new TreeSet<>(tables);
   }
@@ -79,7 +73,7 @@ public class RSGroupInfo {
    *
    * @param hostPort the server
    */
-  public void addServer(HostAndPort hostPort){
+  public void addServer(Address hostPort){
     servers.add(hostPort);
   }
 
@@ -88,7 +82,7 @@ public class RSGroupInfo {
    *
    * @param hostPort the servers
    */
-  public void addAllServers(Collection<HostAndPort> hostPort){
+  public void addAllServers(Collection<Address> hostPort){
     servers.addAll(hostPort);
   }
 
@@ -96,7 +90,7 @@ public class RSGroupInfo {
    * @param hostPort hostPort of the server
    * @return true, if a server with hostPort is found
    */
-  public boolean containsServer(HostAndPort hostPort) {
+  public boolean containsServer(Address hostPort) {
     return servers.contains(hostPort);
   }
 
@@ -105,7 +99,7 @@ public class RSGroupInfo {
    *
    * @return set of servers
    */
-  public Set<HostAndPort> getServers() {
+  public Set<Address> getServers() {
     return servers;
   }
 
@@ -114,7 +108,7 @@ public class RSGroupInfo {
    *
    * @param hostPort HostPort of the server to remove
    */
-  public boolean removeServer(HostAndPort hostPort) {
+  public boolean removeServer(Address hostPort) {
     return servers.remove(hostPort);
   }
 
@@ -122,7 +116,7 @@ public class RSGroupInfo {
    * Set of tables that are members of this group
    * @return set of tables
    */
-  public NavigableSet<TableName> getTables() {
+  public SortedSet<TableName> getTables() {
     return tables;
   }
 
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Address.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Address.java
new file mode 100644
index 0000000000..5ea5fbf3b9
--- /dev/null
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Address.java
@@ -0,0 +1,89 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.util;
+
+import org.apache.hadoop.hbase.classification.InterfaceAudience;
+import org.apache.hadoop.hbase.classification.InterfaceStability;
+
+import com.google.common.net.HostAndPort;
+
+/**
+ * An immutable type to hold a hostname and port combo, like an Endpoint
+ * or java.net.InetSocketAddress (but without danger of our calling
+ * resolve -- we do NOT want a resolve happening every time we want
+ * to hold a hostname and port combo). This class is also <<Comparable>>.
+ * <p>In implementation this class is a facade over Guava's {@link HostAndPort}.
+ * We cannot have Guava classes in our API hence this Type.
+ */
+@InterfaceStability.Evolving
+@InterfaceAudience.Public
+public class Address implements Comparable<Address> {
+  private HostAndPort hostAndPort;
+
+  private Address(HostAndPort hostAndPort) {
+    this.hostAndPort = hostAndPort;
+  }
+
+  public static Address fromParts(String hostname, int port) {
+    return new Address(HostAndPort.fromParts(hostname, port));
+  }
+
+  public static Address fromString(String hostnameAndPort) {
+    return new Address(HostAndPort.fromString(hostnameAndPort));
+  }
+
+  public String getHostname() {
+    return this.hostAndPort.getHostText();
+  }
+
+  public int getPort() {
+    return this.hostAndPort.getPort();
+  }
+
+  @Override
+  public String toString() {
+    return this.hostAndPort.toString();
+  }
+
+  @Override
+  // Don't use HostAndPort equals... It is wonky including
+  // ipv6 brackets
+  public boolean equals(Object other) {
+    if (this == other) {
+      return true;
+    }
+    if (other instanceof Address) {
+      Address that = (Address)other;
+      return this.getHostname().equals(that.getHostname()) &&
+          this.getPort() == that.getPort();
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return this.getHostname().hashCode() ^ getPort();
+  }
+
+  @Override
+  public int compareTo(Address that) {
+    int compare = this.getHostname().compareTo(that.getHostname());
+    if (compare != 0) return compare;
+    return this.getPort() - that.getPort();
+  }
+}
diff --git a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Addressing.java b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Addressing.java
index 71f6127b8f..31fb1f557e 100644
--- a/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Addressing.java
+++ b/hbase-common/src/main/java/org/apache/hadoop/hbase/util/Addressing.java
@@ -24,13 +24,10 @@ import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.NetworkInterface;
 import java.net.SocketException;
-import java.util.Comparator;
 import java.util.Enumeration;
 
 import org.apache.hadoop.hbase.classification.InterfaceAudience;
 
-import com.google.common.net.HostAndPort;
-
 /**
  * Utility for network addresses, resolving and naming.
  */
@@ -39,25 +36,6 @@ public class Addressing {
   public static final String VALID_PORT_REGEX = "[\\d]+";
   public static final String HOSTNAME_PORT_SEPARATOR = ":";
 
-  /**
-   * HostAndPort Comparator.
-   * Does compare on HostAndPort instances. This comparator says that instances that have same
-   * host and port are the same. This is a little different than HostAndPort#equals. It does
-   * NOT consider two ipv6 HostAndPort instances the same if they have the same hostname
-   * and port and they differ only in the fact that one provided brackets around the ipv6
-   * hostname while the other did not: i.e. HostAndPort does NOT equate
-   * {@code HostAndPort.fromParts("[2001:db8::1]", 888);} and
-   * {@code HostAndPort.fromParts("2001:db8::1", 888);}.
-   */
-  public static class HostAndPortComparable implements Comparator<HostAndPort> {
-    @Override
-    public int compare(HostAndPort left, HostAndPort right) {
-      int compare = left.getHostText().compareTo(right.getHostText());
-      if (compare != 0) return compare;
-      return left.getPort() - right.getPort();
-    }
-  }
-
   /**
    * @param hostAndPort Formatted as <code>&lt;hostname&gt; ':' &lt;port&gt;</code>
    * @return An InetSocketInstance
diff --git a/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestAddressing.java b/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestAddressing.java
deleted file mode 100644
index 97aaa1bc53..0000000000
--- a/hbase-common/src/test/java/org/apache/hadoop/hbase/util/TestAddressing.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.hadoop.hbase.util;
-
-import static org.junit.Assert.*;
-
-import org.apache.hadoop.hbase.testclassification.MiscTests;
-import org.apache.hadoop.hbase.testclassification.SmallTests;
-import org.apache.hadoop.hbase.util.Addressing.HostAndPortComparable;
-import org.junit.Test;
-import org.junit.experimental.categories.Category;
-
-import com.google.common.net.HostAndPort;
-
-@Category({MiscTests.class, SmallTests.class})
-public class TestAddressing {
-
-  @Test
-  public void testHostAndPortComparable() {
-    HostAndPortComparable c = new HostAndPortComparable();
-    HostAndPort left = HostAndPort.fromParts("[2001:db8::1]", 888);
-    HostAndPort right = HostAndPort.fromParts("2001:db8::1", 888);
-    assertTrue(left.toString() + " " + right.toString(), c.compare(left, right) == 0);
-  }
-}
