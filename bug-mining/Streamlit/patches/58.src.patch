diff --git a/e2e/specs/hostframe.spec.js b/e2e/specs/hostframe.spec.js
index b0128b587..a563e1dec 100644
--- a/e2e/specs/hostframe.spec.js
+++ b/e2e/specs/hostframe.spec.js
@@ -123,6 +123,8 @@ describe("Host communication", () => {
         cy.get("#toolbar").contains("Sidebar Chevron Downshift").click();
         cy.get("iframe")
             .iframe(() => {
+                // Hover over sidebar to reveal the button
+                cy.get("[data-testid='stSidebarContent']").trigger("mouseover");
                 // Close sidebar
                 cy.get("[data-testid='stSidebar'] button").click()
                 // Check chevron positioning
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[chromium].png
index cda587678..036ece074 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[firefox].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[firefox].png
index 30e186e8d..994992f92 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[firefox].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[webkit].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[webkit].png
index 8a7328713..2a3a1bd74 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[webkit].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-animation_demo_page[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[chromium].png
index b72bc3933..bc09b83d2 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[firefox].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[firefox].png
index f311c0aa1..cd66e81dd 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[firefox].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[webkit].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[webkit].png
index 229105e40..3ffa88816 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[webkit].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-dataframe_demo_page[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[chromium].png
index 428fd0a56..70e7c8b4b 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[firefox].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[firefox].png
index 46bc5efa6..731344d47 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[firefox].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[webkit].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[webkit].png
index f7d06e5af..8bb80e2b9 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[webkit].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-home_page[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[chromium].png
index c6c8a2acc..8bb496147 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[firefox].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[firefox].png
index 6fc4c1ee6..eeda4cc04 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[firefox].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[webkit].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[webkit].png
index 1a6ab4844..a3cd30aaf 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[webkit].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-plotting_demo_page[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-chromium].png
index f49b05405..939b4837b 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-firefox].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-firefox].png
index 8d76cc6de..a26f8d453 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-firefox].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-webkit].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-webkit].png
index 7ee550cea..5148f6695 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-webkit].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[dark_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[light_theme-chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[light_theme-chromium].png
index 08ad81f5c..a898d7758 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[light_theme-chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-landscape-sidebar_open[light_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-chromium].png
index 97d800ee3..3e2c9acc1 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-firefox].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-firefox].png
index c9837de0f..82c22504c 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-firefox].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-webkit].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-webkit].png
index fe668affc..a3e0b1b03 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-webkit].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[dark_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[light_theme-chromium].png b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[light_theme-chromium].png
index a5a75f291..6449765c3 100644
Binary files a/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[light_theme-chromium].png and b/e2e_playwright/__snapshots__/linux/hello_app_test/hello_app-print_media-portrait-sidebar_open[light_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-chromium].png
index 3e0c5f142..0a9d837c2 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-chromium].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-firefox].png
index 721cf0c07..c0175a547 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-firefox].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-webkit].png
index 399c18dbf..1019b1bae 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-webkit].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[dark_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-chromium].png
index 1496f56ec..259ad539f 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-chromium].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-firefox].png
index b6b87c3c7..8192d0d52 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-firefox].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-webkit].png
index 78f84ed5d..ef616c556 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-webkit].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav[light_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[chromium].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[chromium].png
index d7c3aa0f0..a04aa2c72 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[chromium].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[firefox].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[firefox].png
index 626ef2c5f..ece127563 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[firefox].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[webkit].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[webkit].png
index bbc4025ed..902f86fda 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[webkit].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_collapsed[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[chromium].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[chromium].png
index 80fbad459..a8793ea6f 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[chromium].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[firefox].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[firefox].png
index ada2374f1..f1f86a0b0 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[firefox].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[webkit].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[webkit].png
index d90697d7e..6745836c0 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[webkit].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/mpa-sidebar_nav_expanded[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[chromium].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[chromium].png
index 5b30159c9..187e536a5 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[chromium].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[firefox].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[firefox].png
index 26dd36c30..ce071c42e 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[firefox].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[webkit].png b/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[webkit].png
index 5bf6b5a09..2389728c4 100644
Binary files a/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[webkit].png and b/e2e_playwright/__snapshots__/linux/mpa_basics_test/sidebar-logo[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[chromium].png
new file mode 100644
index 000000000..cca0a6592
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[firefox].png
new file mode 100644
index 000000000..542b2242b
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[webkit].png
new file mode 100644
index 000000000..4847016b1
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/collapsed-logo[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-chromium].png
new file mode 100644
index 000000000..fb613fc96
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-firefox].png
new file mode 100644
index 000000000..90328cb4f
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-webkit].png
new file mode 100644
index 000000000..d80d69de9
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[dark_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-chromium].png
new file mode 100644
index 000000000..1a5c24791
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-firefox].png
new file mode 100644
index 000000000..827fcecb6
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-webkit].png
new file mode 100644
index 000000000..840ef3ba3
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/dynamic-pages[light_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-chromium].png
new file mode 100644
index 000000000..0f836eb4a
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-firefox].png
new file mode 100644
index 000000000..9d4925982
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-webkit].png
new file mode 100644
index 000000000..84e5a99f1
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[dark_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-chromium].png
new file mode 100644
index 000000000..023474ae4
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-firefox].png
new file mode 100644
index 000000000..23fbc3e8c
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-webkit].png
new file mode 100644
index 000000000..76c879579
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav[light_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-chromium].png
new file mode 100644
index 000000000..30f84f108
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-firefox].png
new file mode 100644
index 000000000..f9bffb8ca
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-webkit].png
new file mode 100644
index 000000000..87de61e28
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[dark_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-chromium].png
new file mode 100644
index 000000000..c8c67ee08
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-firefox].png
new file mode 100644
index 000000000..35f43a40b
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-webkit].png
new file mode 100644
index 000000000..36f6ec3c2
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_collapsed[light_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-chromium].png
new file mode 100644
index 000000000..7890dc71b
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-firefox].png
new file mode 100644
index 000000000..10d8a98af
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-webkit].png
new file mode 100644
index 000000000..b964524f0
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[dark_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-chromium].png
new file mode 100644
index 000000000..f9b3d9b16
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-firefox].png
new file mode 100644
index 000000000..de5f95997
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-webkit].png
new file mode 100644
index 000000000..11e8f38d7
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/mpa-sidebar_nav_expanded[light_theme-webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[chromium].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[chromium].png
new file mode 100644
index 000000000..44c01dfd6
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[firefox].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[firefox].png
new file mode 100644
index 000000000..c18b72144
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[webkit].png b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[webkit].png
new file mode 100644
index 000000000..e33dd6726
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/mpa_v2_basics_test/sidebar-logo[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[chromium].png b/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[chromium].png
index a7420ddcf..db8492aa6 100644
Binary files a/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[chromium].png and b/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[firefox].png b/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[firefox].png
index ba8d72b5d..dd4aab973 100644
Binary files a/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[firefox].png and b/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[webkit].png b/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[webkit].png
index 46ce915ff..568564138 100644
Binary files a/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[webkit].png and b/e2e_playwright/__snapshots__/linux/st_markdown_test/st_markdown-headers_in_sidebar[webkit].png differ
diff --git a/e2e_playwright/hello_app.py b/e2e_playwright/hello_app.py
index e551015bc..2ae17d7ec 100644
--- a/e2e_playwright/hello_app.py
+++ b/e2e_playwright/hello_app.py
@@ -21,7 +21,6 @@ from streamlit.hello import Hello
 np.random.seed(0)
 
 # This is a trick to setup the MPA hello app programmatically
-
 source_util._cached_pages = None
 source_util._cached_pages = source_util.get_pages(Hello.__file__)
 source_util._on_pages_changed.send()
diff --git a/e2e_playwright/hello_app_test.py b/e2e_playwright/hello_app_test.py
index 843f2aa88..804d24515 100644
--- a/e2e_playwright/hello_app_test.py
+++ b/e2e_playwright/hello_app_test.py
@@ -146,8 +146,9 @@ def test_app_print_mode_portrait_with_sidebar_closed(
     app = themed_app
     _load_dataframe_demo_page(app)
     # close sidebar. Must be done before print-mode, because we hide the close button when printing
+    app.get_by_test_id("stSidebar").hover()
     sidebar_element = app.get_by_test_id("stSidebarContent")
-    sidebar_element.get_by_test_id("baseButton-header").click()
+    sidebar_element.get_by_test_id("baseButton-headerNoPadding").click()
     expect(sidebar_element).not_to_be_visible()
 
     app.emulate_media(media="print", forced_colors="active")
@@ -180,8 +181,9 @@ def test_app_print_mode_landscape_with_sidebar_closed(
     app = themed_app
     _load_dataframe_demo_page(app)
     # close sidebar. Must be done before print-mode, because we hide the close button when printing
+    app.get_by_test_id("stSidebar").hover()
     sidebar_element = app.get_by_test_id("stSidebarContent")
-    sidebar_element.get_by_test_id("baseButton-header").click()
+    sidebar_element.get_by_test_id("baseButton-headerNoPadding").click()
     expect(sidebar_element).not_to_be_visible()
 
     app.emulate_media(media="print", forced_colors="active")
diff --git a/e2e_playwright/multipage_apps/mpa_basics_test.py b/e2e_playwright/multipage_apps/mpa_basics_test.py
index 444741550..a96a6ac6c 100644
--- a/e2e_playwright/multipage_apps/mpa_basics_test.py
+++ b/e2e_playwright/multipage_apps/mpa_basics_test.py
@@ -108,13 +108,12 @@ def test_handles_expand_collapse_of_mpa_nav_correctly(
     page.goto(f"http://localhost:{app_port}/page_7")
     wait_for_app_loaded(page)
 
-    separator = page.get_by_test_id("stSidebarNavSeparator")
-    svg = separator.locator("svg")
+    view_button = page.get_by_test_id("stSidebarNavViewButton")
 
-    expect(svg).to_be_visible()
+    expect(view_button).to_be_visible()
 
     # Expand the nav
-    svg.click(force=True)
+    view_button.click(force=True)
     # We apply a quick timeout here so that the UI has some time to
     # adjust for the screenshot after the click
     page.wait_for_timeout(250)
@@ -123,14 +122,14 @@ def test_handles_expand_collapse_of_mpa_nav_correctly(
     )
 
     # Collapse the nav
-    svg.click(force=True)
+    view_button.click(force=True)
     page.wait_for_timeout(250)
     assert_snapshot(
         page.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_collapsed"
     )
 
     # Expand the nav again
-    svg.click(force=True)
+    view_button.click(force=True)
     page.wait_for_timeout(250)
     assert_snapshot(
         page.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_expanded"
@@ -259,6 +258,7 @@ def test_renders_logos(app: Page, assert_snapshot: ImageCompareFunction):
     assert_snapshot(app.get_by_test_id("stSidebar"), name="sidebar-logo")
 
     # Collapse the sidebar
+    app.get_by_test_id("stSidebarContent").hover()
     app.get_by_test_id("stSidebarCollapseButton").locator("button").click()
     app.wait_for_timeout(500)
 
diff --git a/e2e_playwright/multipage_apps/mpa_v2_transition.py b/e2e_playwright/multipage_apps/mpa_v2_transition.py
new file mode 100644
index 000000000..d35f2cd30
--- /dev/null
+++ b/e2e_playwright/multipage_apps/mpa_v2_transition.py
@@ -0,0 +1,29 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import streamlit as st
+
+st.header("Main Page")
+
+pg = st.navigation(
+    [
+        st.Page("pages/02_page2.py"),
+        st.Page("pages/03_page3.py", default=True),
+        st.Page("pages/09_logo_page.py"),
+    ]
+)
+
+pg.run()
+
+st.write("End of Main Page")
diff --git a/e2e_playwright/multipage_apps/mpa_v2_transition_test.py b/e2e_playwright/multipage_apps/mpa_v2_transition_test.py
new file mode 100644
index 000000000..6a53714da
--- /dev/null
+++ b/e2e_playwright/multipage_apps/mpa_v2_transition_test.py
@@ -0,0 +1,29 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from playwright.sync_api import Page, expect
+
+
+def test_v1_to_v2_transition(app: Page):
+    """Tests that Streamlit migrates from v1 to v2 progressively"""
+    headings = app.get_by_test_id("stHeading")
+    # expect the main page element to show in the beginning
+    expect(headings.nth(0)).to_contain_text("Main Page")
+    # expect the page 3 element to show
+    # this also shows a different default page is written
+    expect(headings.nth(1)).to_contain_text("Page 3")
+
+    # expect the main page to continue running once the page completes
+    markdowns = app.get_by_test_id("stMarkdown")
+    expect(markdowns.nth(1)).to_contain_text("End of Main Page")
diff --git a/e2e_playwright/multipage_apps_v2/__init__.py b/e2e_playwright/multipage_apps_v2/__init__.py
new file mode 100644
index 000000000..02b6b4014
--- /dev/null
+++ b/e2e_playwright/multipage_apps_v2/__init__.py
@@ -0,0 +1,13 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
diff --git a/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py b/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
new file mode 100644
index 000000000..47d1519e9
--- /dev/null
+++ b/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
@@ -0,0 +1,107 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import pathlib
+
+from PIL import Image
+
+import streamlit as st
+
+parent_directory = pathlib.Path(__file__).parent.parent / "multipage_apps"
+small_logo = Image.open(str(parent_directory / "small-streamlit.png"))
+
+logo = Image.open(str(parent_directory / "full-streamlit.png"))
+
+st.logo(logo, link="https://www.example.com", icon_image=small_logo)
+
+st.header("Main Page")
+x = st.slider("x")
+
+st.write(f"x is {x}")
+
+set_default = bool(st.query_params.get("default", False))
+
+page2 = st.Page("page_2.py")
+page3 = st.Page("page_3.py", title="Different Title")
+page4 = st.Page("ðŸ¦’_page_4.py")
+page5 = st.Page("page_5.py", icon=":material/settings:")
+page6 = st.Page("page_6.py", default=set_default)
+
+
+def page_7():
+    st.header("Page 7")
+    x = st.slider("y")
+    st.write(f"y is {x}")
+
+
+def page_8():
+    st.header("Page 8")
+
+
+def page_9():
+    st.header("Page 9")
+
+
+def page_10():
+    st.header("Page 10")
+
+    @st.experimental_fragment
+    def get_input():
+        st.text_input("Some input")
+        if st.button("Submit"):
+            st.rerun()
+
+    get_input()
+
+
+page7 = st.Page(page_7)
+page8 = st.Page(page_8, url_path="my_url_path")
+page9 = st.Page(page_9)
+page10 = st.Page(page_10)
+page11 = st.Page(page_8, title="page 11", url_path="page_11")
+page12 = st.Page(page_9, title="page 12", url_path="page_12")
+
+hide_sidebar = st.checkbox("Hide sidebar")
+dynamic_nav = st.checkbox("Change navigation dynamically")
+pg = st.navigation(
+    (
+        [page2, page3, page5, page9]
+        if dynamic_nav
+        else {
+            "Section 1": [page2, page3],
+            "Section 2": [page4, page5],
+            "Section 3": [page6],
+            "Section 4": [page7, page8, page9],
+            "Section 5": [page10, page11, page12],
+        }
+    ),
+    position="hidden" if hide_sidebar else "sidebar",
+)
+
+if st.button("page 5"):
+    st.switch_page("page_5.py")
+
+if st.button("page 9"):
+    st.switch_page(page9)
+
+if st.checkbox("Show sidebar elements"):
+    st.sidebar.write("Sidebar content")
+
+pg.run()
+
+st.page_link("page_5.py", label="page 5 page link")
+
+st.page_link(page9, label="page 9 page link")
+
+st.write("End of Script")
diff --git a/e2e_playwright/multipage_apps_v2/mpa_v2_basics_test.py b/e2e_playwright/multipage_apps_v2/mpa_v2_basics_test.py
new file mode 100644
index 000000000..e7f4e0053
--- /dev/null
+++ b/e2e_playwright/multipage_apps_v2/mpa_v2_basics_test.py
@@ -0,0 +1,361 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from playwright.sync_api import Page, expect
+
+from e2e_playwright.conftest import (
+    ImageCompareFunction,
+    wait_for_app_loaded,
+    wait_for_app_run,
+)
+
+
+def main_heading(app: Page):
+    return app.get_by_test_id("stHeading").nth(0)
+
+
+def page_heading(app: Page):
+    return app.get_by_test_id("stHeading").nth(1)
+
+
+def check_field(
+    app: Page, *, hide_sidebarnav=False, dynamic_pages=False, add_sidebar_elements=False
+):
+    checkboxes = app.get_by_test_id("stCheckbox")
+
+    if hide_sidebarnav:
+        checkboxes.nth(0).click(delay=50)
+
+    if dynamic_pages:
+        checkboxes.nth(1).click(delay=50)
+
+    if add_sidebar_elements:
+        checkboxes.nth(2).click(delay=50)
+
+
+expected_page_order = [
+    "page 2",
+    "Different Title",
+    "page 4",
+    "page 5",
+    "page 6",
+    "page 7",
+    "page 8",
+    "page 9",
+    "page 10",
+    "page 11",
+    "page 12",
+]
+
+
+def get_page_link(
+    app: Page, page_name: str, page_order: list[str] = expected_page_order
+):
+    return (
+        app.get_by_test_id("stSidebarNav").locator("a").nth(page_order.index(page_name))
+    )
+
+
+def expect_page_order(app: Page, page_order: list[str] = expected_page_order):
+    """Test that the page order is correct"""
+    nav = app.get_by_test_id("stSidebarNav")
+    for i, title in enumerate(page_order):
+        expect(nav.locator("a").nth(i)).to_contain_text(title)
+
+
+def test_loads_main_script_on_initial_page_load(app: Page):
+    """Test that the main script is loaded on initial page load."""
+    expect(main_heading(app)).to_contain_text("Main Page")
+
+
+def test_renders_sidebar_nav_correctly(
+    themed_app: Page, assert_snapshot: ImageCompareFunction
+):
+    """Test that the sidebar nav is rendered correctly."""
+    assert_snapshot(themed_app.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav")
+
+
+def test_can_switch_between_pages_by_clicking_on_sidebar_links(app: Page):
+    """Test that we can switch between pages by clicking on sidebar links."""
+    get_page_link(app, "Different Title").click()
+    wait_for_app_run(app)
+    expect(page_heading(app)).to_contain_text("Page 3")
+
+
+def test_main_script_persists_across_page_changes(app: Page):
+    """Test that we can switch between pages and content from main script persists."""
+    get_page_link(app, "Different Title").click()
+    wait_for_app_run(app)
+    expect(main_heading(app)).to_contain_text("Main Page")
+
+
+def test_main_script_widgets_persist_across_page_changes(app: Page):
+    """Test that we can switch between pages and widgets from main script persists."""
+    slider = app.locator('.stSlider [role="slider"]')
+    slider.click()
+    slider.press("ArrowRight")
+    wait_for_app_run(app, wait_delay=500)
+
+    get_page_link(app, "page 5").click()
+    wait_for_app_run(app)
+    expect(app.get_by_test_id("stMarkdown").nth(0)).to_contain_text("x is 1")
+
+
+def test_supports_navigating_to_page_directly_via_url(app: Page, app_port: int):
+    """Test that we can navigate to a page directly via URL."""
+    app.goto(f"http://localhost:{app_port}/page_5")
+    wait_for_app_loaded(app)
+
+    expect(page_heading(app)).to_contain_text("Page 5")
+
+
+def test_supports_navigating_to_page_directly_via_url_path(app: Page, app_port: int):
+    """Test that we can navigate to a page directly via URL. using the url_path."""
+    app.goto(f"http://localhost:{app_port}/my_url_path")
+    wait_for_app_loaded(app)
+    expect(app).to_have_url(f"http://localhost:{app_port}/my_url_path")
+    expect(page_heading(app)).to_contain_text("Page 8")
+
+
+def test_can_switch_between_pages_and_edit_widgets(app: Page):
+    """Test that we can switch between pages and page widgets do not persist."""
+    get_page_link(app, "Different Title").click()
+    wait_for_app_run(app, wait_delay=1000)
+
+    slider = app.locator('.stSlider [role="slider"]').nth(1)
+    slider.click()
+    slider.press("ArrowRight")
+    wait_for_app_run(app)
+    expect(app.get_by_test_id("stMarkdown").nth(1)).to_contain_text("x is 1")
+
+    get_page_link(app, "page 2").click()
+    wait_for_app_run(app, wait_delay=1000)
+
+    get_page_link(app, "Different Title").click()
+    wait_for_app_run(app, wait_delay=1000)
+
+    expect(app.get_by_test_id("stMarkdown").nth(1)).to_contain_text("x is 0")
+
+
+def test_titles_are_set_correctly(app: Page):
+    """Test that page titles work as expected"""
+    expect_page_order(app)
+
+
+def test_dynamic_pages(themed_app: Page, assert_snapshot: ImageCompareFunction):
+    """Test that dynamic pages are defined"""
+    check_field(themed_app, dynamic_pages=True)
+    wait_for_app_run(themed_app)
+
+    nav = themed_app.get_by_test_id("stSidebarNav")
+    expect_page_order(themed_app, ["page 2", "Different Title", "page 5", "page 9"])
+
+    assert_snapshot(nav, name="dynamic-pages")
+
+
+def test_show_not_found_dialog(app: Page, app_port: int):
+    """Test that we show a not found dialog if the page doesn't exist."""
+    app.goto(f"http://localhost:{app_port}/not_a_page")
+    wait_for_app_loaded(app)
+
+    expect(app.locator('[role="dialog"]')).to_contain_text("Page not found")
+
+
+def test_handles_expand_collapse_of_mpa_nav_correctly(
+    themed_app: Page, assert_snapshot: ImageCompareFunction
+):
+    """Test that we handle expand/collapse of MPA nav correctly."""
+
+    check_field(themed_app, add_sidebar_elements=True)
+    wait_for_app_run(themed_app)
+
+    view_button = themed_app.get_by_test_id("stSidebarNavViewButton")
+
+    expect(view_button).to_be_visible()
+
+    # Expand the nav
+    view_button.click(force=True)
+    expect(view_button).to_have_text("View less")
+    assert_snapshot(
+        themed_app.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_expanded"
+    )
+
+    # Collapse the nav
+    view_button.click(force=True)
+    expect(view_button).to_have_text("View more")
+    assert_snapshot(
+        themed_app.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_collapsed"
+    )
+
+    # Expand the nav again
+    view_button.click(force=True)
+    expect(view_button).to_have_text("View less")
+    assert_snapshot(
+        themed_app.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_expanded"
+    )
+
+
+def test_switch_page_by_path(app: Page):
+    """Test that we can switch between pages by triggering st.switch_page with a path."""
+
+    app.get_by_test_id("baseButton-secondary").filter(has_text="page 5").click()
+    wait_for_app_run(app)
+
+    expect(page_heading(app)).to_contain_text("Page 5")
+
+
+def test_switch_page_by_st_page(app: Page):
+    """Test that we can switch between pages by triggering st.switch_page with st.Page."""
+
+    app.get_by_test_id("baseButton-secondary").filter(has_text="page 9").click()
+    wait_for_app_run(app)
+
+    expect(page_heading(app)).to_contain_text("Page 9")
+
+
+def test_removes_query_params_with_st_switch_page(app: Page, app_port: int):
+    """Test that query params are removed when navigating via st.switch_page"""
+
+    # Start at main page with query params
+    app.goto(f"http://localhost:{app_port}/?foo=bar")
+    wait_for_app_loaded(app)
+    expect(app).to_have_url(f"http://localhost:{app_port}/?foo=bar")
+
+    # Trigger st.switch_page
+    app.get_by_test_id("baseButton-secondary").filter(has_text="page 5").click()
+    wait_for_app_loaded(app)
+    # Check that query params don't persist
+    expect(app).to_have_url(f"http://localhost:{app_port}/page_5")
+
+
+def test_removes_query_params_when_clicking_link(app: Page, app_port: int):
+    """Test that query params are removed when swapping pages by clicking on a link"""
+
+    app.goto(f"http://localhost:{app_port}/page_7?foo=bar")
+    wait_for_app_loaded(app)
+    expect(app).to_have_url(f"http://localhost:{app_port}/page_7?foo=bar")
+
+    get_page_link(app, "page 4").click()
+    wait_for_app_loaded(app)
+    expect(app).to_have_url(f"http://localhost:{app_port}/page_4")
+
+
+def test_removes_non_embed_query_params_when_swapping_pages(app: Page, app_port: int):
+    """Test that non-embed query params are removed when swapping pages"""
+
+    app.goto(
+        f"http://localhost:{app_port}/page_7?foo=bar&embed=True&embed_options=show_toolbar&embed_options=show_colored_line"
+    )
+    wait_for_app_loaded(app)
+    expect(app).to_have_url(
+        f"http://localhost:{app_port}/page_7?foo=bar&embed=True&embed_options=show_toolbar&embed_options=show_colored_line"
+    )
+
+    get_page_link(app, "page 4").click()
+    wait_for_app_loaded(app)
+
+    expect(app).to_have_url(
+        f"http://localhost:{app_port}/page_4?embed=true&embed_options=show_toolbar&embed_options=show_colored_line"
+    )
+
+
+def test_renders_logos(app: Page, assert_snapshot: ImageCompareFunction):
+    """Test that logos display properly in sidebar and main sections"""
+
+    # Go to logo page & wait short moment for logo to appear
+    get_page_link(app, "page 8").click()
+    wait_for_app_loaded(app)
+
+    # Sidebar logo
+    expect(app.get_by_test_id("stSidebarHeader").locator("a")).to_have_attribute(
+        "href", "https://www.example.com"
+    )
+    assert_snapshot(app.get_by_test_id("stSidebar"), name="sidebar-logo")
+
+    # Collapse the sidebar
+    app.get_by_test_id("stSidebarContent").hover()
+    app.get_by_test_id("stSidebarCollapseButton").locator("button").click()
+    app.wait_for_timeout(500)
+
+    # Collapsed logo
+    expect(app.get_by_test_id("collapsedControl").locator("a")).to_have_attribute(
+        "href", "https://www.example.com"
+    )
+    assert_snapshot(app.get_by_test_id("collapsedControl"), name="collapsed-logo")
+
+
+def test_page_link_with_path(app: Page):
+    """Test st.page_link works with a path"""
+
+    app.get_by_test_id("stPageLink-NavLink").filter(has_text="page 5 page link").click()
+    wait_for_app_loaded(app)
+
+    expect(page_heading(app)).to_contain_text("Page 5")
+
+
+def test_page_link_with_st_file(app: Page):
+    """Test st.page_link works with a st.Page"""
+
+    app.get_by_test_id("stPageLink-NavLink").filter(has_text="page 9 page link").click()
+    wait_for_app_loaded(app)
+
+    expect(page_heading(app)).to_contain_text("Page 9")
+
+
+def test_hidden_navigation(app: Page):
+    """Test position=hidden hides the navigation"""
+
+    expect(app.get_by_test_id("stSidebarNav")).to_be_visible()
+    check_field(app, add_sidebar_elements=True)
+    wait_for_app_run(app)
+
+    check_field(app, hide_sidebarnav=True)
+    wait_for_app_run(app)
+
+    nav_exists = app.get_by_test_id("stSidebarNav")
+    expect(nav_exists).not_to_be_attached()
+
+
+def test_set_default_navigation(app: Page, app_port: int):
+    """Test the default page set will be shown on initial load"""
+
+    expect(page_heading(app)).to_contain_text("Page 2")
+    wait_for_app_run(app)
+
+    app.goto(f"http://localhost:{app_port}/?default=True")
+    wait_for_app_loaded(app)
+
+    expect(page_heading(app)).to_contain_text("Page 6")
+
+
+def test_page_url_path_appears_in_url(app: Page, app_port: int):
+    """Test that st.Page's url_path is included in the URL"""
+    link = get_page_link(app, "page 8")
+
+    expect(link).to_have_attribute("href", f"http://localhost:{app_port}/my_url_path")
+    link.click()
+    wait_for_app_loaded(app)
+    expect(app).to_have_url(f"http://localhost:{app_port}/my_url_path")
+
+
+def test_widgets_maintain_state_in_fragment(app: Page):
+    """Test that widgets maintain state in a fragment"""
+    get_page_link(app, "page 10").click()
+
+    input = app.get_by_test_id("stTextInput").locator("input").first
+    input.fill("Hello")
+    input.blur()
+    wait_for_app_run(app)
+
+    expect(input).to_have_value("Hello")
diff --git a/e2e_playwright/multipage_apps_v2/page_2.py b/e2e_playwright/multipage_apps_v2/page_2.py
new file mode 100644
index 000000000..97ef59b43
--- /dev/null
+++ b/e2e_playwright/multipage_apps_v2/page_2.py
@@ -0,0 +1,24 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import streamlit as st
+
+st.subheader("Page 2")
+
+page_6 = st.button("page_6")
+if page_6:
+    st.switch_page("page_6.py")
+
+if st.button("Throw exception"):
+    raise Exception("This is a test exception")
diff --git a/e2e_playwright/multipage_apps_v2/page_3.py b/e2e_playwright/multipage_apps_v2/page_3.py
new file mode 100644
index 000000000..0e16bd6b0
--- /dev/null
+++ b/e2e_playwright/multipage_apps_v2/page_3.py
@@ -0,0 +1,19 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import streamlit as st
+
+st.subheader("Page 3")
+x = st.slider("x")
+st.markdown(f"x is {x}")
diff --git a/e2e_playwright/multipage_apps_v2/page_5.py b/e2e_playwright/multipage_apps_v2/page_5.py
new file mode 100644
index 000000000..d3b9e70d6
--- /dev/null
+++ b/e2e_playwright/multipage_apps_v2/page_5.py
@@ -0,0 +1,17 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import streamlit as st
+
+st.header("Page 5")
diff --git a/e2e_playwright/multipage_apps_v2/page_6.py b/e2e_playwright/multipage_apps_v2/page_6.py
new file mode 100644
index 000000000..b46aea21e
--- /dev/null
+++ b/e2e_playwright/multipage_apps_v2/page_6.py
@@ -0,0 +1,24 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import streamlit as st
+
+st.header("Page 6")
+
+with st.sidebar:
+    st.write("Sidebar")
+    color = st.color_picker("Pick a color")
+    st.write("You picked:", color)
+    st.divider()
+    st.text_area("Some random text:", height=500)
diff --git "a/e2e_playwright/multipage_apps_v2/\360\237\246\222_page_4.py" "b/e2e_playwright/multipage_apps_v2/\360\237\246\222_page_4.py"
new file mode 100644
index 000000000..52ca3cfdc
--- /dev/null
+++ "b/e2e_playwright/multipage_apps_v2/\360\237\246\222_page_4.py"
@@ -0,0 +1,21 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import streamlit as st
+
+st.header("Page 4")
+
+with st.sidebar:
+    st.page_link("page_2.py", label="Page 2", icon=":material/article:")
+    st.page_link("page_3.py", label="Page 3", icon="ðŸ“ˆ")
diff --git a/frontend/app/src/App.test.tsx b/frontend/app/src/App.test.tsx
index 1e0635192..d2c182c82 100644
--- a/frontend/app/src/App.test.tsx
+++ b/frontend/app/src/App.test.tsx
@@ -163,7 +163,9 @@ jest.mock("@streamlit/app/src/SegmentMetricsManager", () => {
   )
 
   const MockedClass = jest.fn().mockImplementation((...props) => {
-    return new actualModule.SegmentMetricsManager(...props)
+    const metricsMgr = new actualModule.SegmentMetricsManager(...props)
+    jest.spyOn(metricsMgr, "enqueue")
+    return metricsMgr
   })
 
   return {
@@ -399,6 +401,18 @@ describe("App", () => {
     expect(screen.getByTestId("stToolbarActions")).toBeInTheDocument()
   })
 
+  it("sends updateReport to our metrics manager", () => {
+    renderApp(getProps())
+
+    const metricsManager = getStoredValue<SegmentMetricsManager>(
+      SegmentMetricsManager
+    )
+
+    sendForwardMessage("newSession", NEW_SESSION_JSON)
+
+    expect(metricsManager.enqueue).toHaveBeenCalledWith("updateReport")
+  })
+
   describe("App.handleNewSession", () => {
     const makeAppWithElements = async (): Promise<void> => {
       renderApp(getProps())
@@ -2243,6 +2257,7 @@ describe("App", () => {
           pageName: "",
           pageScriptHash: "hash1",
           queryString: "",
+          widgetStates: {},
         },
       })
     })
diff --git a/frontend/app/src/App.tsx b/frontend/app/src/App.tsx
index e59427f6c..3b4502fd2 100644
--- a/frontend/app/src/App.tsx
+++ b/frontend/app/src/App.tsx
@@ -70,7 +70,6 @@ import {
   StreamlitEndpoints,
   ensureError,
   LibContext,
-  AppPage,
   AutoRerun,
   BackMsg,
   Config,
@@ -84,6 +83,7 @@ import {
   IGitInfo,
   Initialize,
   Logo,
+  Navigation,
   NewSession,
   PageConfig,
   PageInfo,
@@ -124,6 +124,7 @@ import withScreencast, {
 import "@streamlit/app/src/assets/css/theme.scss"
 import { preserveEmbedQueryParams } from "@streamlit/lib/src/util/utils"
 import { ThemeManager } from "./util/useThemeManager"
+import { AppNavigation, MaybeStateUpdate } from "./util/AppNavigation"
 
 export interface Props {
   screenCast: ScreenCastHOC
@@ -151,9 +152,15 @@ interface State {
   formsData: FormsData
   hideTopBar: boolean
   hideSidebarNav: boolean
-  appLogo: Logo | null
   appPages: IAppPage[]
+  navSections: string[]
+  // The hash of the current page executing
   currentPageScriptHash: string
+  // In MPAv2, the main page is executed before and after the current
+  // page. The main page is the script the app is started with, and the current
+  // page is the dynamically loaded page-script. In MPAv1, the main page holds
+  // no relevance as only one page loads at a time.
+  mainScriptHash: string
   latestRunTime: number
   fragmentIdsThisRun: Array<string>
   // host communication info
@@ -233,6 +240,8 @@ export class App extends PureComponent<Props, State> {
 
   private readonly embeddingId: string = generateUID()
 
+  private readonly appNavigation: AppNavigation
+
   public constructor(props: Props) {
     super(props)
 
@@ -241,7 +250,7 @@ export class App extends PureComponent<Props, State> {
 
     this.state = {
       connectionState: ConnectionState.INITIAL,
-      elements: AppRoot.empty(true),
+      elements: AppRoot.empty("", true), // Blank Main Script Hash for initial render
       isFullScreen: false,
       scriptName: "",
       scriptRunId: INITIAL_SCRIPT_RUN_ID,
@@ -259,9 +268,10 @@ export class App extends PureComponent<Props, State> {
       themeHash: this.createThemeHash(),
       gitInfo: null,
       formsData: createFormsData(),
-      appLogo: null,
       appPages: [],
+      navSections: [],
       currentPageScriptHash: "",
+      mainScriptHash: "",
       // We set hideTopBar to true by default because this information isn't
       // available on page load (we get it when the script begins to run), so
       // the user would see top bar elements for a few ms if this defaulted to
@@ -360,6 +370,12 @@ export class App extends PureComponent<Props, State> {
 
     this.pendingElementsTimerRunning = false
     this.pendingElementsBuffer = this.state.elements
+    this.appNavigation = new AppNavigation(
+      this.hostCommunicationMgr,
+      this.maybeUpdatePageUrl,
+      this.onPageNotFound,
+      this.onPageIconChanged
+    )
 
     window.streamlitDebug = {
       clearForwardMsgCache: this.debugClearForwardMsgCache,
@@ -645,7 +661,10 @@ export class App extends PureComponent<Props, State> {
           this.uploadClient.onFileURLsResponse(fileURLsResponse),
         parentMessage: (parentMessage: ParentMessage) =>
           this.handleCustomParentMessage(parentMessage),
-        logo: (logo: Logo) => this.setState({ appLogo: logo }),
+        logo: (logo: Logo) =>
+          this.handleLogo(logo, msgProto.metadata as ForwardMsgMetadata),
+        navigation: (navigation: Navigation) =>
+          this.handleNavigation(navigation),
       })
     } catch (e) {
       const err = ensureError(e)
@@ -654,10 +673,23 @@ export class App extends PureComponent<Props, State> {
     }
   }
 
+  handleLogo = (logo: Logo, metadata: ForwardMsgMetadata): void => {
+    this.setState(
+      {
+        elements: this.pendingElementsBuffer.appRootWithLogo(logo, metadata),
+      },
+      () => {
+        this.pendingElementsBuffer = this.state.elements
+      }
+    )
+  }
+
   handlePageConfigChanged = (pageConfig: PageConfig): void => {
     const { title, favicon, layout, initialSidebarState, menuItems } =
       pageConfig
 
+    this.appNavigation.handlePageConfigChanged(pageConfig)
+
     if (title) {
       this.hostCommunicationMgr.sendMessageToHost({
         type: "SET_PAGE_TITLE",
@@ -668,11 +700,7 @@ export class App extends PureComponent<Props, State> {
     }
 
     if (favicon) {
-      handleFavicon(
-        favicon,
-        this.hostCommunicationMgr.sendMessageToHost,
-        this.endpoints
-      )
+      this.onPageIconChanged(favicon)
     }
 
     // Only change layout/sidebar when the page config has changed.
@@ -715,28 +743,23 @@ export class App extends PureComponent<Props, State> {
   }
 
   handlePageNotFound = (pageNotFound: PageNotFound): void => {
-    const { pageName } = pageNotFound
-
-    this.onPageNotFound(pageName)
+    this.maybeSetState(this.appNavigation.handlePageNotFound(pageNotFound))
+  }
 
-    const currentPageScriptHash = this.state.appPages[0]?.pageScriptHash || ""
-    this.setState({ currentPageScriptHash }, () => {
-      this.hostCommunicationMgr.sendMessageToHost({
-        type: "SET_CURRENT_PAGE_NAME",
-        currentPageName: "",
-        currentPageScriptHash,
-      })
-    })
+  onPageIconChanged = (iconUrl: string): void => {
+    handleFavicon(
+      iconUrl,
+      this.hostCommunicationMgr.sendMessageToHost,
+      this.endpoints
+    )
   }
 
   handlePagesChanged = (pagesChangedMsg: PagesChanged): void => {
-    const { appPages } = pagesChangedMsg
-    this.setState({ appPages }, () => {
-      this.hostCommunicationMgr.sendMessageToHost({
-        type: "SET_APP_PAGES",
-        appPages,
-      })
-    })
+    this.maybeSetState(this.appNavigation.handlePagesChanged(pagesChangedMsg))
+  }
+
+  handleNavigation = (navigationMsg: Navigation): void => {
+    this.maybeSetState(this.appNavigation.handleNavigation(navigationMsg))
   }
 
   handlePageProfileMsg = (pageProfile: PageProfile): void => {
@@ -892,6 +915,14 @@ export class App extends PureComponent<Props, State> {
     }
   }
 
+  maybeSetState(stateUpdate: MaybeStateUpdate): void {
+    if (stateUpdate) {
+      const [newState, callback] = stateUpdate
+
+      this.setState(newState as State, callback)
+    }
+  }
+
   /**
    * Handler for ForwardMsg.newSession messages. This runs on each rerun
    * @param newSessionProto a NewSession protobuf
@@ -919,20 +950,9 @@ export class App extends PureComponent<Props, State> {
       mainScriptPath,
       fragmentIdsThisRun,
       pageScriptHash: newPageScriptHash,
+      mainScriptHash,
     } = newSessionProto
 
-    // mainPage must be a string as we're guaranteed at this point that
-    // newSessionProto.appPages is nonempty and has a truthy pageName.
-    // Otherwise, we'd either have no main script or a nameless main script,
-    // neither of which can happen.
-    const mainPage = newSessionProto.appPages[0] as AppPage
-    // We're similarly guaranteed that newPageName will be found / truthy
-    // here.
-    const newPageName = newSessionProto.appPages.find(
-      p => p.pageScriptHash === newPageScriptHash
-    )?.pageName as string
-    const viewingMainPage = newPageScriptHash === mainPage.pageScriptHash
-
     if (!fragmentIdsThisRun.length) {
       // This is a normal rerun, remove all the auto reruns intervals
       this.state.autoReruns.forEach((value: NodeJS.Timer) => {
@@ -943,49 +963,21 @@ export class App extends PureComponent<Props, State> {
       const config = newSessionProto.config as Config
       const themeInput = newSessionProto.customTheme as CustomThemeConfig
 
-      this.maybeUpdatePageUrl(mainPage.pageName, newPageName, viewingMainPage)
       this.processThemeInput(themeInput)
       this.setState({
         allowRunOnSave: config.allowRunOnSave,
         hideTopBar: config.hideTopBar,
         toolbarMode: config.toolbarMode,
         latestRunTime: performance.now(),
+        mainScriptHash,
         // If we're here, the fragmentIdsThisRun variable is always the
         // empty array.
         fragmentIdsThisRun,
       })
+      this.maybeSetState(this.appNavigation.handleNewSession(newSessionProto))
 
-      // We separate the state of the navigation as we intend to perform
-      // this work through an abstraction of multipage apps in advance
-      // of supporting v2.
-      this.setState(
-        {
-          hideSidebarNav: config.hideSidebarNav,
-          appPages: newSessionProto.appPages,
-          currentPageScriptHash: newPageScriptHash,
-        },
-        () => {
-          this.hostCommunicationMgr.sendMessageToHost({
-            type: "SET_APP_PAGES",
-            appPages: newSessionProto.appPages,
-          })
-
-          this.hostCommunicationMgr.sendMessageToHost({
-            type: "SET_CURRENT_PAGE_NAME",
-            currentPageName: viewingMainPage ? "" : newPageName,
-            currentPageScriptHash: newPageScriptHash,
-          })
-        }
-      )
-
-      // Set the title and favicon to their default values if we are not running
-      // a fragment.
-      document.title = `${newPageName} Â· Streamlit`
-      handleFavicon(
-        `${process.env.PUBLIC_URL}/favicon.png`,
-        this.hostCommunicationMgr.sendMessageToHost,
-        this.endpoints
-      )
+      // Set the favicon to its default values
+      this.onPageIconChanged(`${process.env.PUBLIC_URL}/favicon.png`)
     } else {
       this.setState({
         fragmentIdsThisRun,
@@ -1000,10 +992,7 @@ export class App extends PureComponent<Props, State> {
     this.metricsMgr.setMetadata(this.state.deployedAppMetadata)
     this.metricsMgr.setAppHash(newSessionHash)
 
-    this.metricsMgr.enqueue("updateReport", {
-      numPages: newSessionProto.appPages.length,
-      isMainPage: viewingMainPage,
-    })
+    this.metricsMgr.enqueue("updateReport")
 
     if (
       appHash === newSessionHash &&
@@ -1013,7 +1002,12 @@ export class App extends PureComponent<Props, State> {
         scriptRunId,
       })
     } else {
-      this.clearAppState(newSessionHash, scriptRunId, scriptName)
+      this.clearAppState(
+        newSessionHash,
+        scriptRunId,
+        scriptName,
+        mainScriptHash
+      )
     }
   }
 
@@ -1039,17 +1033,14 @@ export class App extends PureComponent<Props, State> {
    * Handler called when the history state changes, e.g. `popstate` event.
    */
   onHistoryChange = (): void => {
-    const targetAppPage =
-      this.state.appPages.find(appPage =>
-        // The page name is embedded at the end of the URL path, and if not, we are in the main page.
-        // See https://github.com/streamlit/streamlit/blob/1.19.0/frontend/src/App.tsx#L740
-        document.location.pathname.endsWith("/" + appPage.pageName)
-      ) ?? this.state.appPages[0]
+    const { currentPageScriptHash } = this.state
+    const targetAppPage = this.appNavigation.findPageByUrlPath(
+      document.location.pathname
+    )
 
     // do not cause a rerun when an anchor is clicked and we aren't changing pages
     const hasAnchor = document.location.toString().includes("#")
-    const isSamePage =
-      targetAppPage?.pageScriptHash === this.state.currentPageScriptHash
+    const isSamePage = targetAppPage?.pageScriptHash === currentPageScriptHash
 
     if (targetAppPage == null || (hasAnchor && isSamePage)) {
       return
@@ -1146,7 +1137,6 @@ export class App extends PureComponent<Props, State> {
           ),
         }),
         () => {
-          // We now have no pending elements.
           this.pendingElementsBuffer = this.state.elements
         }
       )
@@ -1190,7 +1180,8 @@ export class App extends PureComponent<Props, State> {
   clearAppState(
     appHash: string,
     scriptRunId: string,
-    scriptName: string
+    scriptName: string,
+    mainScriptHash: string
   ): void {
     const { hideSidebarNav, elements } = this.state
     // Handle hideSidebarNav = true -> retain sidebar elements to avoid flicker
@@ -1201,11 +1192,22 @@ export class App extends PureComponent<Props, State> {
         scriptRunId,
         scriptName,
         appHash,
-        elements: AppRoot.empty(false, sidebarElements),
+        elements: this.appNavigation.clearPageElements(
+          this.pendingElementsBuffer,
+          mainScriptHash,
+          sidebarElements
+        ),
       },
       () => {
         this.pendingElementsBuffer = this.state.elements
-        this.widgetMgr.removeInactive(new Set([]))
+        // Tell the WidgetManager which widgets still exist. It will remove
+        // widget state for widgets that have been removed.
+        const activeWidgetIds = new Set(
+          Array.from(this.state.elements.getElements())
+            .map(element => getElementWidgetID(element))
+            .filter(notUndefined)
+        )
+        this.widgetMgr.removeInactive(activeWidgetIds)
       }
     )
   }
@@ -1366,8 +1368,26 @@ export class App extends PureComponent<Props, State> {
   }
 
   onPageChange = (pageScriptHash: string): void => {
-    this.setState({ appLogo: null })
-    this.sendRerunBackMsg(undefined, undefined, pageScriptHash)
+    const { elements, mainScriptHash } = this.state
+
+    // We want to keep widget states for widgets that are still active
+    // from the common script
+    const nextPageElements = this.appNavigation.clearPageElements(
+      elements,
+      mainScriptHash,
+      undefined
+    )
+    const activeWidgetIds = new Set(
+      Array.from(nextPageElements.getElements())
+        .map(element => getElementWidgetID(element))
+        .filter(notUndefined)
+    )
+
+    this.sendRerunBackMsg(
+      this.widgetMgr.getActiveWidgetStates(activeWidgetIds),
+      undefined,
+      pageScriptHash
+    )
   }
 
   isAppInReadyState = (prevState: Readonly<State>): boolean => {
@@ -1743,6 +1763,8 @@ export class App extends PureComponent<Props, State> {
       libConfig,
       appConfig,
       inputsDisabled,
+      appPages,
+      navSections,
     } = this.state
     const developmentMode = showDevelopmentOptions(
       this.state.isOwner,
@@ -1878,8 +1900,9 @@ export class App extends PureComponent<Props, State> {
                 uploadClient={this.uploadClient}
                 componentRegistry={this.componentRegistry}
                 formsData={this.state.formsData}
-                appLogo={this.state.appLogo}
-                appPages={this.state.appPages}
+                appLogo={elements.logo}
+                appPages={appPages}
+                navSections={navSections}
                 onPageChange={this.onPageChange}
                 currentPageScriptHash={currentPageScriptHash}
                 hideSidebarNav={hideSidebarNav || hostHideSidebarNav}
diff --git a/frontend/app/src/StreamlitLib.test.tsx b/frontend/app/src/StreamlitLib.test.tsx
index 5c20b460f..4f362f145 100644
--- a/frontend/app/src/StreamlitLib.test.tsx
+++ b/frontend/app/src/StreamlitLib.test.tsx
@@ -142,7 +142,7 @@ class StreamlitLibExample extends PureComponent<Props, State> {
 
     // Initialize React state
     this.state = {
-      elements: AppRoot.empty(),
+      elements: AppRoot.empty(""),
       formsData: createFormsData(),
       scriptRunState: ScriptRunState.NOT_RUNNING,
       // ScriptRunID should get a new unique ID every time the
diff --git a/frontend/app/src/components/AppView/AppView.test.tsx b/frontend/app/src/components/AppView/AppView.test.tsx
index 30a80b1ef..114264320 100644
--- a/frontend/app/src/components/AppView/AppView.test.tsx
+++ b/frontend/app/src/components/AppView/AppView.test.tsx
@@ -52,6 +52,8 @@ class ResizeObserver {
 }
 window.ResizeObserver = ResizeObserver
 
+const FAKE_SCRIPT_HASH = "fake_script_hash"
+
 function getContextOutput(context: Partial<AppContextProps>): AppContextProps {
   return {
     wideMode: false,
@@ -76,7 +78,7 @@ function getProps(props: Partial<AppViewProps> = {}): AppViewProps {
 
   return {
     endpoints: mockEndpointProp,
-    elements: AppRoot.empty(true),
+    elements: AppRoot.empty(FAKE_SCRIPT_HASH, true),
     sendMessageToHost: jest.fn(),
     sessionInfo: sessionInfo,
     scriptRunId: "script run 123",
@@ -96,6 +98,7 @@ function getProps(props: Partial<AppViewProps> = {}): AppViewProps {
     formsData,
     appLogo: null,
     appPages: [{ pageName: "streamlit_app", pageScriptHash: "page_hash" }],
+    navSections: [],
     onPageChange: jest.fn(),
     currentPageScriptHash: "main_page_script_hash",
     hideSidebarNav: false,
@@ -125,20 +128,37 @@ describe("AppView element", () => {
     const sidebarElement = new ElementNode(
       makeElementWithInfoText("sidebar!"),
       ForwardMsgMetadata.create({}),
-      "no script run id"
+      "no script run id",
+      FAKE_SCRIPT_HASH
     )
 
     const sidebar = new BlockNode(
+      FAKE_SCRIPT_HASH,
       [sidebarElement],
       new BlockProto({ allowEmpty: true })
     )
 
-    const main = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const event = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const bottom = new BlockNode([], new BlockProto({ allowEmpty: true }))
+    const main = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const event = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const bottom = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
 
     const props = getProps({
-      elements: new AppRoot(new BlockNode([main, sidebar, event, bottom])),
+      elements: new AppRoot(
+        FAKE_SCRIPT_HASH,
+        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
+      ),
     })
     render(<AppView {...props} />)
 
@@ -172,24 +192,41 @@ describe("AppView element", () => {
     const sidebarElement = new ElementNode(
       makeElementWithInfoText("sidebar!"),
       ForwardMsgMetadata.create({}),
-      "no script run id"
+      "no script run id",
+      FAKE_SCRIPT_HASH
     )
 
     const sidebar = new BlockNode(
+      FAKE_SCRIPT_HASH,
       [sidebarElement],
       new BlockProto({ allowEmpty: true })
     )
 
-    const main = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const event = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const bottom = new BlockNode([], new BlockProto({ allowEmpty: true }))
+    const main = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const event = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const bottom = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
 
     const appPages = [
       { pageName: "streamlit_app", pageScriptHash: "page_hash" },
       { pageName: "streamlit_app2", pageScriptHash: "page_hash2" },
     ]
     const props = getProps({
-      elements: new AppRoot(new BlockNode([main, sidebar, event, bottom])),
+      elements: new AppRoot(
+        FAKE_SCRIPT_HASH,
+        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
+      ),
       appPages,
     })
     render(<AppView {...props} />)
@@ -223,13 +260,32 @@ describe("AppView element", () => {
       return realUseContext(input)
     })
 
-    const main = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const sidebar = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const event = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const bottom = new BlockNode([], new BlockProto({ allowEmpty: true }))
+    const main = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const sidebar = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const event = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const bottom = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
 
     const props = getProps({
-      elements: new AppRoot(new BlockNode([main, sidebar, event, bottom])),
+      elements: new AppRoot(
+        FAKE_SCRIPT_HASH,
+        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
+      ),
     })
     render(<AppView {...props} />)
 
@@ -354,19 +410,36 @@ describe("AppView element", () => {
         },
       }),
       ForwardMsgMetadata.create({}),
-      "no script run id"
+      "no script run id",
+      FAKE_SCRIPT_HASH
     )
 
-    const main = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const sidebar = new BlockNode([], new BlockProto({ allowEmpty: true }))
-    const event = new BlockNode([], new BlockProto({ allowEmpty: true }))
+    const main = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const sidebar = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
+    const event = new BlockNode(
+      FAKE_SCRIPT_HASH,
+      [],
+      new BlockProto({ allowEmpty: true })
+    )
     const bottom = new BlockNode(
+      FAKE_SCRIPT_HASH,
       [chatInputElement],
       new BlockProto({ allowEmpty: true })
     )
 
     const props = getProps({
-      elements: new AppRoot(new BlockNode([main, sidebar, event, bottom])),
+      elements: new AppRoot(
+        FAKE_SCRIPT_HASH,
+        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
+      ),
     })
 
     render(<AppView {...props} />)
diff --git a/frontend/app/src/components/AppView/AppView.tsx b/frontend/app/src/components/AppView/AppView.tsx
index 56c7f7f89..0f72166c3 100644
--- a/frontend/app/src/components/AppView/AppView.tsx
+++ b/frontend/app/src/components/AppView/AppView.tsx
@@ -86,6 +86,8 @@ export interface AppViewProps {
 
   appPages: IAppPage[]
 
+  navSections: string[]
+
   onPageChange: (pageName: string) => void
 
   currentPageScriptHash: string
@@ -109,6 +111,7 @@ function AppView(props: AppViewProps): ReactElement {
     formsData,
     appLogo,
     appPages,
+    navSections,
     onPageChange,
     currentPageScriptHash,
     hideSidebarNav,
@@ -147,6 +150,7 @@ function AppView(props: AppViewProps): ReactElement {
   const hasBottomElements = !elements.bottom.isEmpty
 
   const [showSidebarOverride, setShowSidebarOverride] = React.useState(false)
+
   const showSidebar =
     hasSidebarElements ||
     (!hideSidebarNav && appPages.length > 1) ||
@@ -229,6 +233,7 @@ function AppView(props: AppViewProps): ReactElement {
           initialSidebarState={initialSidebarState}
           appLogo={appLogo}
           appPages={appPages}
+          navSections={navSections}
           hasElements={hasSidebarElements}
           onPageChange={onPageChange}
           currentPageScriptHash={currentPageScriptHash}
diff --git a/frontend/app/src/components/Sidebar/NavSection.tsx b/frontend/app/src/components/Sidebar/NavSection.tsx
new file mode 100644
index 000000000..89519cc34
--- /dev/null
+++ b/frontend/app/src/components/Sidebar/NavSection.tsx
@@ -0,0 +1,40 @@
+/**
+ * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import React, { ReactElement } from "react"
+
+import { StyledSidebarNavSectionHeader } from "./styled-components"
+
+export interface NavSectionProps {
+  header?: string
+  children: ReactElement[]
+}
+
+const NavSection = ({
+  header = "",
+  children,
+}: NavSectionProps): ReactElement => {
+  return (
+    <>
+      {header && (
+        <StyledSidebarNavSectionHeader>{header}</StyledSidebarNavSectionHeader>
+      )}
+      {children}
+    </>
+  )
+}
+
+export default NavSection
diff --git a/frontend/app/src/components/Sidebar/Sidebar.test.tsx b/frontend/app/src/components/Sidebar/Sidebar.test.tsx
index 707070784..921000216 100644
--- a/frontend/app/src/components/Sidebar/Sidebar.test.tsx
+++ b/frontend/app/src/components/Sidebar/Sidebar.test.tsx
@@ -26,7 +26,6 @@ import {
 import {
   render,
   mockEndpoints,
-  useIsOverflowing,
   emotionLightTheme,
   PageConfig,
   Logo,
@@ -39,10 +38,6 @@ jest.mock("@streamlit/lib/src/util/Hooks", () => ({
   useIsOverflowing: jest.fn(),
 }))
 
-const mockUseIsOverflowing = useIsOverflowing as jest.MockedFunction<
-  typeof useIsOverflowing
->
-
 const mockEndpointProp = mockEndpoints()
 
 function renderSidebar(props: Partial<SidebarProps> = {}): RenderResult {
@@ -53,6 +48,7 @@ function renderSidebar(props: Partial<SidebarProps> = {}): RenderResult {
       theme={emotionLightTheme}
       appLogo={null}
       appPages={[]}
+      navSections={[]}
       onPageChange={jest.fn()}
       currentPageScriptHash={""}
       hasElements
@@ -101,7 +97,8 @@ describe("Sidebar Component", () => {
       "true"
     )
 
-    // Click the close sidebar X
+    // Click the close sidebar <
+    fireEvent.mouseOver(screen.getByTestId("stSidebarHeader"))
     fireEvent.click(screen.getByRole("button"))
 
     expect(screen.getByTestId("stSidebar")).toHaveAttribute(
@@ -140,37 +137,39 @@ describe("Sidebar Component", () => {
     expect(screen.queryByTestId("collapsedControl")).not.toBeInTheDocument()
   })
 
-  it("hides scrollbar when hideScrollbar is called", () => {
+  it("shows/hides the collapse arrow when hovering over top of sidebar", () => {
     const appPages = [
       { pageName: "first_page", pageScriptHash: "page_hash" },
       { pageName: "second_page", pageScriptHash: "page_hash2" },
     ]
-    // Need isOverflowing in SidebarNav to be true to test scrollbar behavior
-    mockUseIsOverflowing.mockReturnValueOnce(true)
+
     renderSidebar({ appPages })
 
-    expect(screen.getByTestId("stSidebarContent")).toHaveStyle(
-      "overflow: overlay"
+    // Hidden when not hovering near the top of sidebar
+    expect(screen.getByTestId("stSidebarCollapseButton")).toHaveStyle(
+      "display: none"
     )
 
-    fireEvent.mouseOver(screen.getByTestId("stSidebarNavItems"))
+    // Hover over the sidebar header
+    fireEvent.mouseOver(screen.getByTestId("stSidebarHeader"))
 
-    expect(screen.getByTestId("stSidebarContent")).toHaveStyle(
-      "overflow: hidden"
+    // Displays the collapse <
+    expect(screen.getByTestId("stSidebarCollapseButton")).toHaveStyle(
+      "display: inline"
     )
   })
 
-  it("has same top padding whether or not SidebarNav is displayed", () => {
-    const { unmount } = renderSidebar({
+  it("has no top padding if no SidebarNav is displayed", () => {
+    renderSidebar({
       appPages: [{ pageName: "streamlit_app", pageScriptHash: "page_hash" }],
     })
 
     expect(screen.getByTestId("stSidebarUserContent")).toHaveStyle(
-      "padding-top: 1rem"
+      "padding-top: 0"
     )
+  })
 
-    unmount()
-
+  it("has small padding if the SidebarNav is displayed", () => {
     renderSidebar({
       appPages: [
         { pageName: "streamlit_app", pageScriptHash: "page_hash" },
@@ -179,7 +178,7 @@ describe("Sidebar Component", () => {
     })
 
     expect(screen.getByTestId("stSidebarUserContent")).toHaveStyle(
-      "padding-top: 1rem"
+      "padding-top: 1.5rem"
     )
   })
 
diff --git a/frontend/app/src/components/Sidebar/Sidebar.tsx b/frontend/app/src/components/Sidebar/Sidebar.tsx
index bdfb37653..d271e50c8 100644
--- a/frontend/app/src/components/Sidebar/Sidebar.tsx
+++ b/frontend/app/src/components/Sidebar/Sidebar.tsx
@@ -15,7 +15,7 @@
  */
 
 import React, { PureComponent, ReactElement, ReactNode } from "react"
-import { ChevronRight, Close } from "@emotion-icons/material-outlined"
+import { ChevronRight, ChevronLeft } from "@emotion-icons/material-outlined"
 import { withTheme } from "@emotion/react"
 import { Resizable } from "re-resizable"
 
@@ -58,6 +58,7 @@ export interface SidebarProps {
   hasElements: boolean
   appLogo: Logo | null
   appPages: IAppPage[]
+  navSections: string[]
   onPageChange: (pageName: string) => void
   currentPageScriptHash: string
   hideSidebarNav: boolean
@@ -68,8 +69,8 @@ interface State {
   sidebarWidth: string
   lastInnerWidth: number
 
-  // When hovering the nav
-  hideScrollbar: boolean
+  // When hovering sidebar header
+  showSidebarCollapse: boolean
 }
 
 class Sidebar extends PureComponent<SidebarProps, State> {
@@ -98,7 +99,7 @@ class Sidebar extends PureComponent<SidebarProps, State> {
       collapsedSidebar: Sidebar.shouldCollapse(props, this.mediumBreakpointPx),
       sidebarWidth: cachedSidebarWidth || Sidebar.minWidth,
       lastInnerWidth: window ? window.innerWidth : Infinity,
-      hideScrollbar: false,
+      showSidebarCollapse: false,
     }
   }
 
@@ -206,8 +207,12 @@ class Sidebar extends PureComponent<SidebarProps, State> {
     this.setState({ collapsedSidebar: !collapsedSidebar })
   }
 
-  hideScrollbar = (newValue: boolean): void => {
-    this.setState({ hideScrollbar: newValue })
+  onMouseOver = (): void => {
+    this.setState({ showSidebarCollapse: true })
+  }
+
+  onMouseOut = (): void => {
+    this.setState({ showSidebarCollapse: false })
   }
 
   // Additional safeguard for sidebar height sizing
@@ -250,7 +255,7 @@ class Sidebar extends PureComponent<SidebarProps, State> {
   }
 
   public render(): ReactNode {
-    const { collapsedSidebar, sidebarWidth, hideScrollbar } = this.state
+    const { collapsedSidebar, sidebarWidth, showSidebarCollapse } = this.state
     const {
       appPages,
       chevronDownshift,
@@ -259,8 +264,11 @@ class Sidebar extends PureComponent<SidebarProps, State> {
       onPageChange,
       currentPageScriptHash,
       hideSidebarNav,
+      navSections,
     } = this.props
 
+    const hasPageNavAbove = appPages.length > 1 && !hideSidebarNav
+
     // Handles checking the URL params
     const isEmbedded = isEmbed() && !isColoredLineDisplayed()
     // If header decoration visible, move sidebar down so decoration doesn't go below it
@@ -301,8 +309,7 @@ class Sidebar extends PureComponent<SidebarProps, State> {
           }}
           size={{
             width: sidebarWidth,
-            // Addresses height glitch when anchor used - issue #6264
-            height: sidebarAdjust ? window.innerHeight - 2 : "100%",
+            height: "auto",
           }}
           as={StyledSidebar}
           onResizeStop={(e, direction, ref, d) => {
@@ -317,32 +324,39 @@ class Sidebar extends PureComponent<SidebarProps, State> {
         >
           <StyledSidebarContent
             data-testid="stSidebarContent"
-            hideScrollbar={hideScrollbar}
             ref={this.sidebarRef}
+            onMouseOver={this.onMouseOver}
+            onMouseOut={this.onMouseOut}
           >
             <StyledSidebarHeaderContainer data-testid="stSidebarHeader">
               {this.renderLogo(false)}
-              <StyledCollapseSidebarButton data-testid="stSidebarCollapseButton">
+              <StyledCollapseSidebarButton
+                showSidebarCollapse={showSidebarCollapse}
+                data-testid="stSidebarCollapseButton"
+              >
                 <BaseButton
-                  kind={BaseButtonKind.HEADER_BUTTON}
+                  kind={BaseButtonKind.HEADER_NO_PADDING}
                   onClick={this.toggleCollapse}
                 >
-                  <Icon content={Close} size="lg" />
+                  <Icon content={ChevronLeft} size="xl" />
                 </BaseButton>
               </StyledCollapseSidebarButton>
             </StyledSidebarHeaderContainer>
-            {!hideSidebarNav && (
+            {hasPageNavAbove && (
               <SidebarNav
                 endpoints={this.props.endpoints}
                 appPages={appPages}
                 collapseSidebar={this.toggleCollapse}
                 currentPageScriptHash={currentPageScriptHash}
+                navSections={navSections}
                 hasSidebarElements={hasElements}
-                hideParentScrollbar={this.hideScrollbar}
                 onPageChange={onPageChange}
               />
             )}
-            <StyledSidebarUserContent data-testid="stSidebarUserContent">
+            <StyledSidebarUserContent
+              hasPageNavAbove={hasPageNavAbove}
+              data-testid="stSidebarUserContent"
+            >
               {children}
             </StyledSidebarUserContent>
           </StyledSidebarContent>
diff --git a/frontend/app/src/components/Sidebar/SidebarNav.test.tsx b/frontend/app/src/components/Sidebar/SidebarNav.test.tsx
index 9cd1dbbb5..53ed03d2c 100644
--- a/frontend/app/src/components/Sidebar/SidebarNav.test.tsx
+++ b/frontend/app/src/components/Sidebar/SidebarNav.test.tsx
@@ -41,13 +41,17 @@ const mockUseIsOverflowing = useIsOverflowing as jest.MockedFunction<
 
 const getProps = (props: Partial<Props> = {}): Props => ({
   appPages: [
-    { pageScriptHash: "main_page_hash", pageName: "streamlit_app" },
+    {
+      pageScriptHash: "main_page_hash",
+      pageName: "streamlit_app",
+      isDefault: true,
+    },
     { pageScriptHash: "other_page_hash", pageName: "my_other_page" },
   ],
+  navSections: [],
   collapseSidebar: jest.fn(),
   currentPageScriptHash: "",
   hasSidebarElements: false,
-  hideParentScrollbar: jest.fn(),
   onPageChange: jest.fn(),
   endpoints: mockEndpoints(),
   ...props,
@@ -61,21 +65,6 @@ describe("SidebarNav", () => {
     reactDeviceDetect.isMobile = false
   })
 
-  it("returns null if 0 appPages (may be true before the first script run)", () => {
-    render(<SidebarNav {...getProps({ appPages: [] })} />)
-
-    expect(screen.queryByTestId("stSidebarNav")).not.toBeInTheDocument()
-  })
-
-  it("returns null if 1 appPage", () => {
-    render(
-      <SidebarNav
-        {...getProps({ appPages: [{ pageName: "streamlit_app" }] })}
-      />
-    )
-    expect(screen.queryByTestId("stSidebarNav")).not.toBeInTheDocument()
-  })
-
   it("replaces underscores with spaces in pageName", () => {
     render(<SidebarNav {...getProps()} />)
 
@@ -101,11 +90,9 @@ describe("SidebarNav", () => {
     it("are added to each link", () => {
       const buildAppPageURL = jest
         .fn()
-        .mockImplementation(
-          (pageLinkBaseURL: string, page: IAppPage, pageIndex: number) => {
-            return `http://mock/app/page/${page.pageName}.${pageIndex}`
-          }
-        )
+        .mockImplementation((pageLinkBaseURL: string, page: IAppPage) => {
+          return `http://mock/app/page/${page.pageName}`
+        })
       const props = getProps({ endpoints: mockEndpoints({ buildAppPageURL }) })
 
       render(<SidebarNav {...props} />)
@@ -115,11 +102,11 @@ describe("SidebarNav", () => {
 
       expect(links[0]).toHaveAttribute(
         "href",
-        "http://mock/app/page/streamlit_app.0"
+        "http://mock/app/page/streamlit_app"
       )
       expect(links[1]).toHaveAttribute(
         "href",
-        "http://mock/app/page/my_other_page.1"
+        "http://mock/app/page/my_other_page"
       )
     })
   })
@@ -142,61 +129,45 @@ describe("SidebarNav", () => {
     const separator = screen.getByTestId("stSidebarNavSeparator")
     expect(separator).toBeInTheDocument()
 
-    const expandIcon = screen.queryByTestId("stSidebarNavExpandIcon")
-    const collapseIcon = screen.queryByTestId("stSidebarNavCollapseIcon")
+    const viewButton = screen.queryByTestId("stSidebarNavViewButton")
 
-    expect(expandIcon).not.toBeInTheDocument()
-    expect(collapseIcon).not.toBeInTheDocument()
+    expect(viewButton).not.toBeInTheDocument()
   })
 
-  it("renders ExpandMore icon when not expanded and overflowing", () => {
+  it("renders View more button when not expanded and overflowing", () => {
     mockUseIsOverflowing.mockReturnValueOnce(true)
     render(<SidebarNav {...getProps({ hasSidebarElements: true })} />)
 
-    const separator = screen.getByTestId("stSidebarNavSeparator")
-    expect(separator).toBeInTheDocument()
-
-    const expandIcon = screen.getByTestId("stSidebarNavExpandIcon")
-    expect(expandIcon).toBeInTheDocument()
+    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
+    expect(screen.queryByTestId("stSidebarNavViewButton")).toHaveTextContent(
+      "View more"
+    )
   })
 
-  it("renders ExpandLess icon when expanded and not overflowing", async () => {
-    // We need to have useIsOverflowing return true once so that we can click
-    // on the separator to expand the nav component. After this click, it
-    // returns false.
+  it("renders View less button when expanded and not overflowing", async () => {
+    // We need to have useIsOverflowing return true once so the view more button renders.
+    // After this click, it returns false.
     mockUseIsOverflowing.mockReturnValueOnce(true)
     render(<SidebarNav {...getProps({ hasSidebarElements: true })} />)
 
     // Click on the separator to expand the nav component.
-    const separator = screen.getByTestId("stSidebarNavSeparator")
-    expect(separator).toBeInTheDocument()
-    fireEvent.click(separator)
+    fireEvent.click(screen.getByTestId("stSidebarNavViewButton"))
 
-    const collapseIcon = await screen.findByTestId("stSidebarNavCollapseIcon")
-    expect(collapseIcon).toBeInTheDocument()
+    const viewLessButton = await screen.findByText("View less")
+    expect(viewLessButton).toBeInTheDocument()
   })
 
-  it("renders ExpandLess icon when expanded and overflowing", async () => {
+  it("renders View less button when expanded and overflowing", async () => {
     // Have useIsOverflowing return true both before and after the nav is
     // expanded.
     mockUseIsOverflowing.mockReturnValueOnce(true).mockReturnValueOnce(true)
     render(<SidebarNav {...getProps({ hasSidebarElements: true })} />)
 
-    // Click on the separator to expand the nav component.
-    const separator = screen.getByTestId("stSidebarNavSeparator")
-    expect(separator).toBeInTheDocument()
-    fireEvent.click(separator)
+    // Click on the View more button to expand the nav component.
+    fireEvent.click(screen.getByTestId("stSidebarNavViewButton"))
 
-    const collapseIcon = await screen.findByTestId("stSidebarNavCollapseIcon")
-    expect(collapseIcon).toBeInTheDocument()
-  })
-
-  it("changes cursor to pointer above separator when overflowing", () => {
-    mockUseIsOverflowing.mockReturnValueOnce(true)
-    render(<SidebarNav {...getProps({ hasSidebarElements: true })} />)
-    const separator = screen.getByTestId("stSidebarNavSeparator")
-    expect(separator).toBeInTheDocument()
-    expect(separator).toHaveStyle("cursor: pointer")
+    const viewLessButton = await screen.findByText("View less")
+    expect(viewLessButton).toBeInTheDocument()
   })
 
   it("is unexpanded by default", () => {
@@ -204,7 +175,7 @@ describe("SidebarNav", () => {
 
     const sidebarNavItems = screen.getByTestId("stSidebarNavItems")
     expect(sidebarNavItems).toBeInTheDocument()
-    expect(sidebarNavItems).toHaveStyle("max-height: 33vh")
+    expect(sidebarNavItems).toHaveStyle("max-height: 30vh")
   })
 
   it("does not expand when you click on the separator if there is no overflow", async () => {
@@ -215,28 +186,28 @@ describe("SidebarNav", () => {
 
     const sidebarNavItems = await screen.findByTestId("stSidebarNavItems")
     expect(sidebarNavItems).toBeInTheDocument()
-    expect(sidebarNavItems).toHaveStyle("max-height: 33vh")
+    expect(sidebarNavItems).toHaveStyle("max-height: 30vh")
   })
 
-  it("toggles to expanded and back when the separator is clicked", async () => {
+  it("toggles to expanded and back when the View more/less buttons are clicked", async () => {
     mockUseIsOverflowing.mockReturnValueOnce(true)
 
     render(<SidebarNav {...getProps({ hasSidebarElements: true })} />)
 
-    const separator = screen.getByTestId("stSidebarNavSeparator")
-    expect(separator).toBeInTheDocument()
-    fireEvent.click(separator)
+    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
+    // Expand the pages menu
+    fireEvent.click(screen.getByTestId("stSidebarNavViewButton"))
 
     const sidebarNavItems = await screen.findByTestId("stSidebarNavItems")
     expect(sidebarNavItems).toBeInTheDocument()
-    expect(sidebarNavItems).toHaveStyle("max-height: 75vh")
+    expect(sidebarNavItems).toHaveStyle("max-height: none")
 
-    fireEvent.click(separator)
+    fireEvent.click(screen.getByTestId("stSidebarNavViewButton"))
 
     const sidebarNavItemsUpdate = await screen.findByTestId(
       "stSidebarNavItems"
     )
-    expect(sidebarNavItemsUpdate).toHaveStyle("max-height: 33vh")
+    expect(sidebarNavItemsUpdate).toHaveStyle("max-height: 30vh")
   })
 
   it("passes the pageScriptHash to onPageChange if a link is clicked", () => {
@@ -264,37 +235,6 @@ describe("SidebarNav", () => {
     expect(props.collapseSidebar).toHaveBeenCalled()
   })
 
-  it("calls hideParentScrollbar onMouseOut", () => {
-    const props = getProps()
-    render(<SidebarNav {...props} />)
-
-    const sidebarNavItems = screen.getByTestId("stSidebarNavItems")
-    fireEvent.mouseOut(sidebarNavItems)
-
-    expect(props.hideParentScrollbar).toHaveBeenCalledWith(false)
-  })
-
-  it("does not call hideParentScrollbar on mouseOver if not overflowing", () => {
-    const props = getProps()
-    render(<SidebarNav {...props} />)
-
-    const sidebarNavItems = screen.getByTestId("stSidebarNavItems")
-    fireEvent.mouseOver(sidebarNavItems)
-
-    expect(props.hideParentScrollbar).not.toHaveBeenCalled()
-  })
-
-  it("does call hideParentScrollbar on mouseOver if overflowing", () => {
-    mockUseIsOverflowing.mockReturnValueOnce(true)
-    const props = getProps()
-    render(<SidebarNav {...props} />)
-
-    const sidebarNavItems = screen.getByTestId("stSidebarNavItems")
-    fireEvent.mouseOver(sidebarNavItems)
-
-    expect(props.hideParentScrollbar).toHaveBeenCalledWith(true)
-  })
-
   it("handles default and custom page icons", () => {
     const props = getProps({
       appPages: [
@@ -326,6 +266,6 @@ describe("SidebarNav", () => {
     const props = getProps({ currentPageScriptHash: "other_page_hash" })
     render(<SidebarNav {...props} />)
 
-    expect(screen.getByText("my other page")).toHaveStyle("color: #31333F")
+    expect(screen.getByText("my other page")).toHaveStyle("color: #262730")
   })
 })
diff --git a/frontend/app/src/components/Sidebar/SidebarNav.tsx b/frontend/app/src/components/Sidebar/SidebarNav.tsx
index 6e678113b..e9593a4ff 100644
--- a/frontend/app/src/components/Sidebar/SidebarNav.tsx
+++ b/frontend/app/src/components/Sidebar/SidebarNav.tsx
@@ -14,37 +14,36 @@
  * limitations under the License.
  */
 
-import React, { ReactElement, useCallback, useRef, useState } from "react"
-import { AppContext } from "@streamlit/app/src/components/AppContext"
+import React, {
+  ReactElement,
+  useCallback,
+  useContext,
+  useRef,
+  useState,
+} from "react"
+import groupBy from "lodash/groupBy"
 // We import react-device-detect in this way so that tests can mock its
 // isMobile field sanely.
 import * as reactDeviceDetect from "react-device-detect"
-import { ExpandMore, ExpandLess } from "@emotion-icons/material-outlined"
-
-import {
-  Icon,
-  EmojiIcon,
-  useIsOverflowing,
-  StreamlitEndpoints,
-  IAppPage,
-} from "@streamlit/lib"
+import { AppContext } from "@streamlit/app/src/components/AppContext"
+import { useIsOverflowing, StreamlitEndpoints, IAppPage } from "@streamlit/lib"
 
+import NavSection from "./NavSection"
+import SidebarNavLink from "./SidebarNavLink"
 import {
   StyledSidebarNavContainer,
   StyledSidebarNavItems,
-  StyledSidebarNavLink,
-  StyledSidebarLinkText,
-  StyledSidebarNavLinkContainer,
-  StyledSidebarNavSeparatorContainer,
+  StyledViewButton,
+  StyledSidebarNavSeparator,
 } from "./styled-components"
 
 export interface Props {
   endpoints: StreamlitEndpoints
   appPages: IAppPage[]
+  navSections: string[]
   collapseSidebar: () => void
   currentPageScriptHash: string
   hasSidebarElements: boolean
-  hideParentScrollbar: (newValue: boolean) => void
   onPageChange: (pageName: string) => void
 }
 
@@ -55,109 +54,107 @@ const SidebarNav = ({
   collapseSidebar,
   currentPageScriptHash,
   hasSidebarElements,
-  hideParentScrollbar,
+  navSections,
   onPageChange,
 }: Props): ReactElement | null => {
-  const { pageLinkBaseUrl } = React.useContext(AppContext)
   const [expanded, setExpanded] = useState(false)
   const navItemsRef = useRef<HTMLUListElement>(null)
   const isOverflowing = useIsOverflowing(navItemsRef, expanded)
+  const { pageLinkBaseUrl } = useContext(AppContext)
 
-  const onMouseOver = useCallback(() => {
-    if (isOverflowing) {
-      hideParentScrollbar(true)
-    }
-  }, [isOverflowing, hideParentScrollbar])
+  const handleViewButtonClick = useCallback(() => {
+    setExpanded(!expanded)
+  }, [expanded])
 
-  const onMouseOut = useCallback(
-    () => hideParentScrollbar(false),
-    [hideParentScrollbar]
-  )
+  const generateNavLinks = useCallback(
+    (page: IAppPage) => {
+      const pageUrl = endpoints.buildAppPageURL(pageLinkBaseUrl, page)
+      const pageName = page.pageName as string
+      const tooltipContent = pageName.replace(/_/g, " ")
+      const isActive = page.pageScriptHash === currentPageScriptHash
 
-  const toggleExpanded = useCallback(() => {
-    if (!expanded && isOverflowing) {
-      setExpanded(true)
-    } else if (expanded) {
-      setExpanded(false)
-    }
-  }, [expanded, isOverflowing])
+      return (
+        <li key={pageName}>
+          <SidebarNavLink
+            isActive={isActive}
+            pageUrl={pageUrl}
+            icon={page.icon}
+            onClick={e => {
+              e.preventDefault()
+              onPageChange(page.pageScriptHash as string)
+              if (reactDeviceDetect.isMobile) {
+                collapseSidebar()
+              }
+            }}
+          >
+            {tooltipContent}
+          </SidebarNavLink>
+        </li>
+      )
+    },
+    [
+      collapseSidebar,
+      currentPageScriptHash,
+      endpoints,
+      onPageChange,
+      pageLinkBaseUrl,
+    ]
+  )
 
-  if (appPages.length < 2) {
-    return null
+  let contents = null
+  if (navSections.length > 0) {
+    const pagesBySectionHeader = groupBy(
+      appPages,
+      page => page.sectionHeader || ""
+    )
+    // For MPAv2: renders each NavSection with its respective header
+    contents = navSections.map(header => {
+      return (
+        <NavSection key={header} header={header}>
+          {(pagesBySectionHeader[header] ?? []).map(generateNavLinks)}
+        </NavSection>
+      )
+    })
+  } else {
+    // For MPAv1: single NavSection with all pages displayed
+    contents = appPages.map(generateNavLinks)
   }
 
+  // We should show the nav items as expanded if
+  // - there are no sidebar elements
+  // - the user has explicitly expanded the sidebar
+  const shouldShowNavItemsAsExpanded = !hasSidebarElements || expanded
+
+  // We should show the "View more" button if
+  // - there are sidebar elements and it produce an overflow
+  // - the user has explicitly expanded the sidebar indicating
+  //   the possibility to collapse it
+  const shouldShowViewButton =
+    (hasSidebarElements && isOverflowing) || expanded
+
   return (
     <StyledSidebarNavContainer data-testid="stSidebarNav">
       <StyledSidebarNavItems
         ref={navItemsRef}
-        isExpanded={expanded}
-        isOverflowing={isOverflowing}
+        isExpanded={shouldShowNavItemsAsExpanded}
         hasSidebarElements={hasSidebarElements}
-        onMouseOver={onMouseOver}
-        onMouseOut={onMouseOut}
         data-testid="stSidebarNavItems"
       >
-        {appPages.map((page: IAppPage, pageIndex: number) => {
-          const pageUrl = endpoints.buildAppPageURL(
-            pageLinkBaseUrl,
-            page,
-            pageIndex
-          )
-
-          const pageName = page.pageName as string
-          const tooltipContent = pageName.replace(/_/g, " ")
-          const isActive = page.pageScriptHash === currentPageScriptHash
-
-          return (
-            <li key={pageName}>
-              <StyledSidebarNavLinkContainer>
-                <StyledSidebarNavLink
-                  data-testid="stSidebarNavLink"
-                  isActive={isActive}
-                  href={pageUrl}
-                  onClick={e => {
-                    e.preventDefault()
-                    onPageChange(page.pageScriptHash as string)
-                    if (reactDeviceDetect.isMobile) {
-                      collapseSidebar()
-                    }
-                  }}
-                >
-                  {page.icon && page.icon.length && (
-                    <EmojiIcon size="lg">{page.icon}</EmojiIcon>
-                  )}
-                  <StyledSidebarLinkText isActive={isActive}>
-                    {tooltipContent}
-                  </StyledSidebarLinkText>
-                </StyledSidebarNavLink>
-              </StyledSidebarNavLinkContainer>
-            </li>
-          )
-        })}
+        {contents}
       </StyledSidebarNavItems>
 
       {hasSidebarElements && (
-        <StyledSidebarNavSeparatorContainer
-          data-testid="stSidebarNavSeparator"
-          isExpanded={expanded}
-          isOverflowing={isOverflowing}
-          onClick={toggleExpanded}
-        >
-          {isOverflowing && !expanded && (
-            <Icon
-              content={ExpandMore}
-              size="md"
-              testid="stSidebarNavExpandIcon"
-            />
-          )}
-          {expanded && (
-            <Icon
-              content={ExpandLess}
-              size="md"
-              testid="stSidebarNavCollapseIcon"
-            />
+        <>
+          {shouldShowViewButton && (
+            <StyledViewButton
+              onClick={handleViewButtonClick}
+              data-testid="stSidebarNavViewButton"
+            >
+              {expanded ? "View less" : "View more"}
+            </StyledViewButton>
           )}
-        </StyledSidebarNavSeparatorContainer>
+          <StyledSidebarNavSeparator data-testid="stSidebarNavSeparator" />
+        </>
       )}
     </StyledSidebarNavContainer>
   )
diff --git a/frontend/app/src/components/Sidebar/SidebarNavLink.tsx b/frontend/app/src/components/Sidebar/SidebarNavLink.tsx
new file mode 100644
index 000000000..ade1c4fa7
--- /dev/null
+++ b/frontend/app/src/components/Sidebar/SidebarNavLink.tsx
@@ -0,0 +1,58 @@
+/**
+ * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import React, { MouseEvent, ReactElement } from "react"
+import { DynamicIcon } from "@streamlit/lib/src/components/shared/Icon"
+
+import {
+  StyledSidebarNavLink,
+  StyledSidebarLinkText,
+  StyledSidebarNavLinkContainer,
+} from "./styled-components"
+
+export interface SidebarNavLinkProps {
+  isActive: boolean
+  pageUrl: string
+  icon: string | undefined | null
+  onClick: (e: MouseEvent) => void
+  children: string
+}
+
+const SidebarNavLink = ({
+  isActive,
+  pageUrl,
+  icon,
+  onClick,
+  children,
+}: SidebarNavLinkProps): ReactElement => {
+  return (
+    <StyledSidebarNavLinkContainer>
+      <StyledSidebarNavLink
+        data-testid="stSidebarNavLink"
+        isActive={isActive}
+        href={pageUrl}
+        onClick={onClick}
+      >
+        {icon && icon.length && <DynamicIcon size="md" iconValue={icon} />}
+        <StyledSidebarLinkText isActive={isActive}>
+          {children}
+        </StyledSidebarLinkText>
+      </StyledSidebarNavLink>
+    </StyledSidebarNavLinkContainer>
+  )
+}
+
+export default SidebarNavLink
diff --git a/frontend/app/src/components/Sidebar/ThemedSidebar.test.tsx b/frontend/app/src/components/Sidebar/ThemedSidebar.test.tsx
index f1e762837..25717a5d2 100644
--- a/frontend/app/src/components/Sidebar/ThemedSidebar.test.tsx
+++ b/frontend/app/src/components/Sidebar/ThemedSidebar.test.tsx
@@ -27,6 +27,7 @@ function getProps(
   return {
     endpoints: mockEndpoints(),
     appPages: [],
+    navSections: [],
     onPageChange: jest.fn(),
     currentPageScriptHash: "page_hash",
     hasElements: true,
diff --git a/frontend/app/src/components/Sidebar/styled-components.ts b/frontend/app/src/components/Sidebar/styled-components.ts
index 13f06c222..ff7a53051 100644
--- a/frontend/app/src/components/Sidebar/styled-components.ts
+++ b/frontend/app/src/components/Sidebar/styled-components.ts
@@ -14,12 +14,13 @@
  * limitations under the License.
  */
 
+import { transparentize } from "color2k"
 import styled from "@emotion/styled"
-import { keyframes } from "@emotion/react"
 import {
   getWrappedHeadersStyle,
   hasLightBackgroundColor,
 } from "@streamlit/lib/src/theme/utils"
+import { StyledMaterialIcon } from "@streamlit/lib/src/components/shared/Icon/Material/styled-components"
 export interface StyledSidebarProps {
   isCollapsed: boolean
   adjustTop: boolean
@@ -72,101 +73,22 @@ export const StyledSidebarNavContainer = styled.div(() => ({
 
 export interface StyledSidebarNavItemsProps {
   isExpanded: boolean
-  isOverflowing: boolean
   hasSidebarElements: boolean
 }
 
 export const StyledSidebarNavItems = styled.ul<StyledSidebarNavItemsProps>(
-  ({ isExpanded, isOverflowing, hasSidebarElements, theme }) => {
-    const isExpandedMaxHeight = isExpanded ? "75vh" : "33vh"
-    const maxHeight = hasSidebarElements ? isExpandedMaxHeight : "100vh"
-
+  ({ isExpanded, hasSidebarElements }) => {
     return {
-      maxHeight,
+      maxHeight: isExpanded ? "none" : "30vh",
       listStyle: "none",
-      overflow: ["auto", "overlay"],
+      overflow:
+        isExpanded && hasSidebarElements ? ["auto", "overlay"] : "hidden",
       margin: 0,
-      paddingTop: theme.spacing.lg,
-      paddingBottom: theme.spacing.lg,
-
-      "@media print": {
-        paddingTop: theme.spacing.threeXL,
-      },
-
-      "&::before": isOverflowing
-        ? {
-            content: '" "',
-            backgroundImage: `linear-gradient(0deg, transparent, ${theme.colors.bgColor})`,
-            width: "100%",
-            height: "2rem",
-            position: "absolute",
-            top: 0,
-            left: 0,
-            right: 0,
-            pointerEvents: "none",
-          }
-        : null,
-
-      "&::after": isOverflowing
-        ? {
-            content: '" "',
-            backgroundImage: `linear-gradient(0deg, ${theme.colors.bgColor}, transparent)`,
-            height: "2rem",
-            position: "absolute",
-            bottom: 0,
-            left: 0,
-            right: 0,
-            pointerEvents: "none",
-          }
-        : null,
+      paddingBottom: "0.125rem",
     }
   }
 )
 
-export interface StyledSidebarNavSeparatorContainerProps {
-  isExpanded: boolean
-  isOverflowing: boolean
-}
-
-const bounceAnimation = keyframes`
-  from, to {
-    transform: translateY(0);
-  }
-
-  50% {
-    transform: translateY(-0.25rem);
-  }
-`
-
-export const StyledSidebarNavSeparatorContainer =
-  styled.div<StyledSidebarNavSeparatorContainerProps>(
-    ({ isExpanded, isOverflowing, theme }) => ({
-      cursor: isExpanded || isOverflowing ? "pointer" : "default",
-      position: "absolute",
-      height: theme.spacing.lg,
-      left: 0,
-      right: 0,
-      bottom: 0,
-      display: "flex",
-      alignItems: "center",
-      justifyContent: "center",
-      color: theme.colors.fadedText60,
-      borderBottom: `1px solid ${theme.colors.fadedText10}`,
-      transition: "color 500ms",
-
-      ...((isExpanded || isOverflowing) && {
-        "&:hover": {
-          color: theme.colors.bodyText,
-          background: `linear-gradient(0deg, ${theme.colors.darkenedBgMix15}, transparent)`,
-
-          "& > *": {
-            animation: `${bounceAnimation} 0.5s ease infinite`,
-          },
-        },
-      }),
-    })
-  )
-
 export const StyledSidebarNavLinkContainer = styled.div(() => ({
   display: "flex",
   flexDirection: "column",
@@ -178,6 +100,15 @@ export interface StyledSidebarNavLinkProps {
 
 export const StyledSidebarNavLink = styled.a<StyledSidebarNavLinkProps>(
   ({ isActive, theme }) => {
+    const isLightTheme = hasLightBackgroundColor(theme)
+    const activeSvgColor = isLightTheme
+      ? theme.colors.gray90
+      : theme.colors.gray10
+    const svgColor = isLightTheme ? theme.colors.gray60 : theme.colors.gray70
+    const activeBgColor = isLightTheme
+      ? theme.colors.darkenedBgMix15
+      : transparentize(theme.colors.gray100, 0.6)
+
     const defaultPageLinkStyles = {
       textDecoration: "none",
       fontWeight: isActive ? 600 : 400,
@@ -193,18 +124,22 @@ export const StyledSidebarNavLink = styled.a<StyledSidebarNavLinkProps>(
 
       paddingLeft: theme.spacing.sm,
       paddingRight: theme.spacing.sm,
-      marginLeft: theme.spacing.lg,
-      marginRight: theme.spacing.lg,
+      marginLeft: theme.spacing.twoXL,
+      marginRight: theme.spacing.twoXL,
       marginTop: theme.spacing.threeXS,
       marginBottom: theme.spacing.threeXS,
       lineHeight: theme.lineHeights.menuItem,
 
-      backgroundColor: isActive ? theme.colors.darkenedBgMix15 : "transparent",
+      color: isLightTheme ? theme.colors.gray80 : theme.colors.gray40,
+      backgroundColor: isActive ? activeBgColor : "transparent",
+
+      [StyledMaterialIcon as any]: {
+        color: isActive ? activeSvgColor : svgColor,
+        fontWeight: isActive ? 600 : 400,
+      },
 
       "&:hover": {
-        backgroundColor: isActive
-          ? theme.colors.darkenedBgMix25
-          : theme.colors.darkenedBgMix15,
+        backgroundColor: activeBgColor,
       },
 
       "&:active,&:visited,&:hover": {
@@ -227,36 +162,45 @@ export const StyledSidebarNavLink = styled.a<StyledSidebarNavLinkProps>(
 )
 
 export const StyledSidebarLinkText = styled.span<StyledSidebarNavLinkProps>(
-  ({ isActive, theme }) => ({
-    color: isActive ? theme.colors.bodyText : theme.colors.fadedText60,
-    overflow: "hidden",
-    whiteSpace: "nowrap",
-    textOverflow: "ellipsis",
-    display: "table-cell",
-  })
+  ({ isActive, theme }) => {
+    const isLightTheme = hasLightBackgroundColor(theme)
+    const defaultColor = isLightTheme
+      ? theme.colors.gray80
+      : theme.colors.gray50
+    const activeColor = isLightTheme
+      ? theme.colors.gray90
+      : theme.colors.gray10
+
+    return {
+      color: isActive ? activeColor : defaultColor,
+      overflow: "hidden",
+      whiteSpace: "nowrap",
+      textOverflow: "ellipsis",
+      display: "table-cell",
+    }
+  }
 )
 
-export const StyledSidebarUserContent = styled.div(({ theme }) => ({
-  paddingTop: theme.spacing.lg,
-  paddingBottom: theme.sizes.sidebarTopSpace,
-  paddingLeft: theme.spacing.twoXL,
-  paddingRight: theme.spacing.twoXL,
+export interface StyledSidebarUserContentProps {
+  hasPageNavAbove: boolean
+}
 
-  ...getWrappedHeadersStyle(theme),
-}))
+export const StyledSidebarUserContent =
+  styled.div<StyledSidebarUserContentProps>(({ hasPageNavAbove, theme }) => ({
+    paddingTop: hasPageNavAbove ? theme.spacing.twoXL : 0,
+    paddingBottom: theme.sizes.sidebarTopSpace,
+    paddingLeft: theme.spacing.twoXL,
+    paddingRight: theme.spacing.twoXL,
 
-export interface StyledSidebarContentProps {
-  hideScrollbar: boolean
-}
+    ...getWrappedHeadersStyle(theme),
+  }))
 
-export const StyledSidebarContent = styled.div<StyledSidebarContentProps>(
-  ({ hideScrollbar }) => ({
-    position: "relative",
-    height: "100%",
-    width: "100%",
-    overflow: hideScrollbar ? "hidden" : ["auto", "overlay"],
-  })
-)
+export const StyledSidebarContent = styled.div(({}) => ({
+  position: "relative",
+  height: "100%",
+  width: "100%",
+  overflow: ["auto", "overlay"],
+}))
 
 export const StyledResizeHandle = styled.div(({ theme }) => ({
   position: "absolute",
@@ -338,25 +282,76 @@ export const StyledOpenSidebarButton = styled.div(({ theme }) => {
   }
 })
 
-export const StyledCollapseSidebarButton = styled.div(({ theme }) => {
+export interface StyledCollapseSidebarButtonProps {
+  showSidebarCollapse: boolean
+}
+
+export const StyledCollapseSidebarButton =
+  styled.div<StyledCollapseSidebarButtonProps>(
+    ({ showSidebarCollapse, theme }) => {
+      const isLightTheme = hasLightBackgroundColor(theme)
+
+      return {
+        display: showSidebarCollapse ? "inline" : "none",
+        transition: "left 300ms",
+        transitionDelay: "left 300ms",
+        color: isLightTheme ? theme.colors.gray70 : theme.colors.bodyText,
+        lineHeight: "0",
+
+        [`@media print`]: {
+          display: "none",
+        },
+
+        [`@media (max-width: ${theme.breakpoints.sm})`]: {
+          display: "inline",
+        },
+      }
+    }
+  )
+
+export const StyledSidebarNavSectionHeader = styled.header(({ theme }) => {
   const isLightTheme = hasLightBackgroundColor(theme)
 
   return {
-    display: "auto",
-    transition: "left 300ms",
-    transitionDelay: "left 300ms",
-    color: isLightTheme ? theme.colors.gray70 : theme.colors.bodyText,
-    lineHeight: "0",
+    fontSize: theme.fontSizes.sm,
+    fontWeight: theme.fontWeights.bold,
+    color: isLightTheme ? theme.colors.gray80 : theme.colors.gray60,
+    lineHeight: theme.lineHeights.table,
+    paddingRight: theme.spacing.sm,
+    marginLeft: theme.spacing.twoXL,
+    marginRight: theme.spacing.twoXL,
+    marginTop: theme.spacing.sm,
+    marginBottom: theme.spacing.twoXS,
+  }
+})
 
-    button: {
-      padding: "0.25rem",
-      "&:hover": {
-        backgroundColor: theme.colors.darkenedBgMix25,
-      },
-    },
+export const StyledViewButton = styled.button(({ theme }) => {
+  const isLightTheme = hasLightBackgroundColor(theme)
 
-    [`@media print`]: {
-      display: "none",
+  return {
+    fontSize: theme.fontSizes.sm,
+    lineHeight: "1.4rem",
+    color: isLightTheme ? theme.colors.gray90 : theme.colors.gray10,
+    backgroundColor: theme.colors.transparent,
+    border: "none",
+    borderRadius: theme.radii.lg,
+    marginTop: theme.spacing.twoXS,
+    marginLeft: theme.spacing.xl,
+    padding: `${theme.spacing.threeXS} ${theme.spacing.sm}`,
+    "&:hover, &:active, &:focus": {
+      border: "none",
+      outline: "none",
+      boxShadow: "none",
+    },
+    "&:hover": {
+      backgroundColor: isLightTheme
+        ? theme.colors.darkenedBgMix15
+        : transparentize(theme.colors.gray100, 0.6),
     },
   }
 })
+
+export const StyledSidebarNavSeparator = styled.div(({ theme }) => ({
+  paddingTop: theme.spacing.lg,
+  borderBottom: `1px solid ${theme.colors.fadedText10}`,
+}))
diff --git a/frontend/app/src/connection/DefaultStreamlitEndpoints.test.ts b/frontend/app/src/connection/DefaultStreamlitEndpoints.test.ts
index 46acf05c1..f6fdcac7e 100644
--- a/frontend/app/src/connection/DefaultStreamlitEndpoints.test.ts
+++ b/frontend/app/src/connection/DefaultStreamlitEndpoints.test.ts
@@ -125,16 +125,20 @@ describe("DefaultStreamlitEndpoints", () => {
     })
 
     const appPages = [
-      { pageScriptHash: "main_page_hash", pageName: "streamlit_app" },
+      {
+        pageScriptHash: "main_page_hash",
+        pageName: "streamlit_app",
+        isDefault: true,
+      },
       { pageScriptHash: "other_page_hash", pageName: "my_other_page" },
     ]
 
     it("uses window.location.port", () => {
       window.location.port = "3000"
-      expect(endpoints.buildAppPageURL("", appPages[0], 0)).toBe(
+      expect(endpoints.buildAppPageURL("", appPages[0])).toBe(
         "http://streamlit.mock:3000/mock/base/path/"
       )
-      expect(endpoints.buildAppPageURL("", appPages[1], 1)).toBe(
+      expect(endpoints.buildAppPageURL("", appPages[1])).toBe(
         "http://streamlit.mock:3000/mock/base/path/my_other_page"
       )
     })
@@ -142,10 +146,10 @@ describe("DefaultStreamlitEndpoints", () => {
     it("is built using pageLinkBaseURL if set", () => {
       window.location.port = "3000"
       const pageLinkBaseURL = "https://share.streamlit.io/vdonato/foo/bar"
-      expect(endpoints.buildAppPageURL(pageLinkBaseURL, appPages[0], 0)).toBe(
+      expect(endpoints.buildAppPageURL(pageLinkBaseURL, appPages[0])).toBe(
         "https://share.streamlit.io/vdonato/foo/bar/"
       )
-      expect(endpoints.buildAppPageURL(pageLinkBaseURL, appPages[1], 1)).toBe(
+      expect(endpoints.buildAppPageURL(pageLinkBaseURL, appPages[1])).toBe(
         "https://share.streamlit.io/vdonato/foo/bar/my_other_page"
       )
     })
diff --git a/frontend/app/src/connection/DefaultStreamlitEndpoints.ts b/frontend/app/src/connection/DefaultStreamlitEndpoints.ts
index 4bd06385a..06e846439 100644
--- a/frontend/app/src/connection/DefaultStreamlitEndpoints.ts
+++ b/frontend/app/src/connection/DefaultStreamlitEndpoints.ts
@@ -87,11 +87,11 @@ export class DefaultStreamlitEndpoints implements StreamlitEndpoints {
   /** Construct a URL for an app page in a multi-page app. */
   public buildAppPageURL(
     pageLinkBaseURL: string | undefined,
-    page: IAppPage,
-    pageIndex: number
+    page: IAppPage
   ): string {
     const pageName = page.pageName as string
-    const navigateTo = pageIndex === 0 ? "" : pageName
+    const urlPath = page.urlPathname || pageName
+    const navigateTo = page.isDefault ? "" : urlPath
 
     if (pageLinkBaseURL != null && pageLinkBaseURL.length > 0) {
       return `${pageLinkBaseURL}/${navigateTo}`
diff --git a/frontend/app/src/util/AppNavigation.test.ts b/frontend/app/src/util/AppNavigation.test.ts
new file mode 100644
index 000000000..848c3866b
--- /dev/null
+++ b/frontend/app/src/util/AppNavigation.test.ts
@@ -0,0 +1,566 @@
+/**
+ * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/* eslint-disable @typescript-eslint/no-non-null-assertion */
+
+import {
+  HostCommunicationManager,
+  NewSession,
+  PagesChanged,
+  PageNotFound,
+  Navigation,
+  AppPage,
+  PageConfig,
+} from "@streamlit/lib"
+import {
+  AppNavigation,
+  PageUrlUpdateCallback,
+  PageNotFoundCallback,
+  SetIconCallback,
+} from "./AppNavigation"
+
+jest.mock("@streamlit/lib/src/hostComm/HostCommunicationManager", () => {
+  const actualModule = jest.requireActual(
+    "@streamlit/lib/src/hostComm/HostCommunicationManager"
+  )
+
+  const MockedClass = jest.fn().mockImplementation((...props) => {
+    const hostCommunicationMgr = new actualModule.default(...props)
+    jest.spyOn(hostCommunicationMgr, "sendMessageToHost")
+    return hostCommunicationMgr
+  })
+
+  return {
+    __esModule: true,
+    ...actualModule,
+    default: MockedClass,
+  }
+})
+
+function generateNewSession(changes = {}): NewSession {
+  return new NewSession({
+    name: "scriptName",
+    config: {
+      gatherUsageStats: false,
+      maxCachedMessageAge: 0,
+      mapboxToken: "mapboxToken",
+      allowRunOnSave: false,
+      hideSidebarNav: false,
+      hideTopBar: false,
+    },
+    customTheme: {
+      primaryColor: "red",
+      fontFaces: [],
+    },
+    initialize: {
+      userInfo: {
+        installationId: "installationId",
+        installationIdV3: "installationIdV3",
+      },
+      environmentInfo: {
+        streamlitVersion: "streamlitVersion",
+        pythonVersion: "pythonVersion",
+      },
+      sessionStatus: {
+        runOnSave: false,
+        scriptIsRunning: false,
+      },
+      sessionId: "sessionId",
+      isHello: false,
+    },
+    appPages: [
+      { pageScriptHash: "page_script_hash", pageName: "streamlit_app" },
+    ],
+    pageScriptHash: "page_script_hash",
+    mainScriptHash: "main_script_hash",
+    mainScriptPath: "path/to/file.py",
+    scriptRunId: "script_run_id",
+    fragmentIdsThisRun: [],
+    ...changes,
+  })
+}
+
+describe("AppNavigation", () => {
+  let hostCommunicationMgr: HostCommunicationManager
+  let onUpdatePageUrl: PageUrlUpdateCallback
+  let onPageNotFound: PageNotFoundCallback
+  let onPageIconChange: SetIconCallback
+  let appNavigation: AppNavigation
+
+  beforeEach(() => {
+    hostCommunicationMgr = new HostCommunicationManager({
+      sendRerunBackMsg: () => {},
+      closeModal: () => {},
+      stopScript: () => {},
+      rerunScript: () => {},
+      clearCache: () => {},
+      sendAppHeartbeat: () => {},
+      setInputsDisabled: () => {},
+      themeChanged: () => {},
+      pageChanged: () => {},
+      isOwnerChanged: () => {},
+      jwtHeaderChanged: () => {},
+      hostMenuItemsChanged: () => {},
+      hostToolbarItemsChanged: () => {},
+      hostHideSidebarNavChanged: () => {},
+      sidebarChevronDownshiftChanged: () => {},
+      pageLinkBaseUrlChanged: () => {},
+      queryParamsChanged: () => {},
+      deployedAppMetadataChanged: () => {},
+    })
+    onUpdatePageUrl = jest.fn()
+    onPageNotFound = jest.fn()
+    onPageIconChange = jest.fn()
+    appNavigation = new AppNavigation(
+      hostCommunicationMgr,
+      onUpdatePageUrl,
+      onPageNotFound,
+      onPageIconChange
+    )
+  })
+
+  describe("MPA v1", () => {
+    it("sets appPages on new session", () => {
+      const maybeState = appNavigation.handleNewSession(generateNewSession())
+      expect(maybeState).not.toBeUndefined()
+
+      const [newState] = maybeState!
+      expect(newState.appPages).toEqual([
+        { pageScriptHash: "page_script_hash", pageName: "streamlit_app" },
+      ])
+    })
+
+    it("sets currentPageScriptHash on new session", () => {
+      const maybeState = appNavigation.handleNewSession(generateNewSession())
+      expect(maybeState).not.toBeUndefined()
+
+      const [newState] = maybeState!
+      expect(newState.currentPageScriptHash).toEqual("page_script_hash")
+    })
+
+    it("calls host communication on new session", () => {
+      const maybeState = appNavigation.handleNewSession(generateNewSession({}))
+      expect(maybeState).not.toBeUndefined()
+
+      const callback = maybeState![1]
+
+      callback()
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_APP_PAGES",
+        appPages: [
+          { pageScriptHash: "page_script_hash", pageName: "streamlit_app" },
+        ],
+      })
+
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_CURRENT_PAGE_NAME",
+        currentPageName: "",
+        currentPageScriptHash: "page_script_hash",
+      })
+    })
+
+    it("calls onUpdatePageUrl with the right information", () => {
+      appNavigation.handleNewSession(generateNewSession())
+      expect(onUpdatePageUrl).toHaveBeenCalledWith(
+        "streamlit_app",
+        "streamlit_app",
+        true
+      )
+    })
+
+    it("sets appPages on pages changed", () => {
+      const maybeState = appNavigation.handlePagesChanged(
+        new PagesChanged({
+          appPages: [
+            { pageScriptHash: "other_page_script_hash", pageName: "foo_bar" },
+          ],
+        })
+      )
+      expect(maybeState).not.toBeUndefined()
+
+      const [newState] = maybeState!
+      expect(newState.appPages).toEqual([
+        { pageScriptHash: "other_page_script_hash", pageName: "foo_bar" },
+      ])
+    })
+
+    it("calls host communication on pages changed", () => {
+      const maybeState = appNavigation.handlePagesChanged(
+        new PagesChanged({
+          appPages: [
+            { pageScriptHash: "other_page_script_hash", pageName: "foo_bar" },
+          ],
+        })
+      )
+      expect(maybeState).not.toBeUndefined()
+
+      const callback = maybeState![1]
+
+      callback()
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_APP_PAGES",
+        appPages: [
+          { pageScriptHash: "other_page_script_hash", pageName: "foo_bar" },
+        ],
+      })
+    })
+
+    it("sets currentPageScriptHash on page not found", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      const maybeState = appNavigation.handlePageNotFound(
+        new PageNotFound({ pageName: "foo" })
+      )
+      expect(maybeState).not.toBeUndefined()
+
+      const [newState] = maybeState!
+      expect(newState.currentPageScriptHash).toEqual("page_script_hash")
+    })
+
+    it("calls host communication on page not found", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      const maybeState = appNavigation.handlePageNotFound(
+        new PageNotFound({ pageName: "foo" })
+      )
+      expect(maybeState).not.toBeUndefined()
+
+      const callback = maybeState![1]
+
+      callback()
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_CURRENT_PAGE_NAME",
+        currentPageName: "",
+        currentPageScriptHash: "page_script_hash",
+      })
+    })
+
+    it("calls onPageNotFound when page not found", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      appNavigation.handlePageNotFound(new PageNotFound({ pageName: "foo" }))
+      expect(onPageNotFound).toHaveBeenCalledWith("foo")
+    })
+
+    it("finds url by path when path is valid", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      const page = appNavigation.findPageByUrlPath("/streamlit_app")
+
+      expect(page.pageScriptHash).toEqual("page_script_hash")
+      expect(page.pageName).toEqual("streamlit_app")
+    })
+
+    it("returns default url by path when path is invalid", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      const page = appNavigation.findPageByUrlPath("foo")
+
+      expect(page.pageScriptHash).toEqual("page_script_hash")
+      expect(page.pageName).toEqual("streamlit_app")
+    })
+  })
+
+  describe("MPA v2", () => {
+    beforeEach(() => {
+      // Switch to V2
+      const navigation = new Navigation({
+        sections: ["section1", "section2"],
+        appPages: [
+          new AppPage({
+            pageName: "streamlit_app",
+            pageScriptHash: "page_script_hash",
+            isDefault: true,
+            sectionHeader: "section1",
+          }),
+          new AppPage({
+            pageName: "streamlit_app2",
+            pageScriptHash: "page_script_hash2",
+            isDefault: false,
+            sectionHeader: "section2",
+          }),
+        ],
+        position: Navigation.Position.HIDDEN,
+        pageScriptHash: "page_script_hash",
+      })
+      appNavigation.handleNavigation(navigation)
+    })
+
+    it("continues to set hideSidebarNav on new session", () => {
+      const maybeState = appNavigation.handleNewSession(generateNewSession())
+      expect(maybeState).not.toBeUndefined()
+
+      const [newState] = maybeState!
+      expect(newState).toEqual({
+        hideSidebarNav: true,
+      })
+    })
+
+    it("does not set anything on on pages changed", () => {
+      const maybeState = appNavigation.handlePagesChanged(
+        new PagesChanged({
+          appPages: [
+            { pageScriptHash: "other_page_script_hash", pageName: "foo_bar" },
+          ],
+        })
+      )
+      expect(maybeState).toBeUndefined()
+    })
+
+    it("sets currentPageScriptHash on page not found", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      const maybeState = appNavigation.handlePageNotFound(
+        new PageNotFound({ pageName: "" })
+      )
+      expect(maybeState).not.toBeUndefined()
+
+      const [newState] = maybeState!
+      expect(newState.currentPageScriptHash).toEqual("main_script_hash")
+    })
+
+    it("calls host communication on page not found", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      const maybeState = appNavigation.handlePageNotFound(
+        new PageNotFound({ pageName: "" })
+      )
+      expect(maybeState).not.toBeUndefined()
+
+      const callback = maybeState![1]
+
+      callback()
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_CURRENT_PAGE_NAME",
+        currentPageName: "",
+        currentPageScriptHash: "main_script_hash",
+      })
+    })
+
+    it("calls onPageNotFound when page not found", () => {
+      // Initialize navigation from the new session proto
+      appNavigation.handleNewSession(generateNewSession())
+      appNavigation.handlePageNotFound(new PageNotFound({ pageName: "" }))
+      expect(onPageNotFound).toHaveBeenCalledWith("")
+    })
+
+    it("calls onUpdatePageUrl with the right information", () => {
+      const navigation = new Navigation({
+        sections: ["section1", "section2"],
+        appPages: [
+          new AppPage({
+            pageName: "streamlit app",
+            pageScriptHash: "page_script_hash",
+            isDefault: true,
+            urlPathname: "streamlit_app",
+          }),
+          new AppPage({
+            pageName: "streamlit app2",
+            pageScriptHash: "page_script_hash2",
+            isDefault: false,
+            urlPathname: "streamlit_app2",
+          }),
+        ],
+        position: "hidden",
+        pageScriptHash: "page_script_hash2",
+      })
+      appNavigation.handleNavigation(navigation)
+      expect(onUpdatePageUrl).toHaveBeenCalledWith(
+        "streamlit_app",
+        "streamlit_app2",
+        false
+      )
+    })
+
+    it("finds url by path when path is valid", () => {
+      const navigation = new Navigation({
+        sections: ["section1", "section2"],
+        appPages: [
+          new AppPage({
+            pageName: "streamlit app",
+            pageScriptHash: "page_script_hash",
+            isDefault: true,
+            urlPathname: "streamlit_app",
+          }),
+          new AppPage({
+            pageName: "streamlit app2",
+            pageScriptHash: "page_script_hash2",
+            isDefault: false,
+            urlPathname: "streamlit_app2",
+          }),
+        ],
+        position: "hidden",
+        pageScriptHash: "page_script_hash",
+      })
+      appNavigation.handleNavigation(navigation)
+      const page = appNavigation.findPageByUrlPath("/streamlit_app2")
+
+      expect(page.pageScriptHash).toEqual("page_script_hash2")
+      expect(page.pageName).toEqual("streamlit app2")
+    })
+
+    it("returns default url by path when path is invalid", () => {
+      const navigation = new Navigation({
+        sections: ["section1", "section2"],
+        appPages: [
+          new AppPage({
+            pageName: "streamlit app",
+            pageScriptHash: "page_script_hash",
+            isDefault: true,
+            sectionHeader: "section1",
+            urlPathname: "streamlit_app",
+          }),
+          new AppPage({
+            pageName: "streamlit app2",
+            pageScriptHash: "page_script_hash2",
+            isDefault: false,
+            sectionHeader: "section2",
+            urlPathname: "streamlit_app2",
+          }),
+        ],
+        position: "hidden",
+        pageScriptHash: "page_script_hash",
+      })
+      appNavigation.handleNavigation(navigation)
+      const page = appNavigation.findPageByUrlPath("foo")
+
+      expect(page.pageScriptHash).toEqual("page_script_hash")
+      expect(page.pageName).toEqual("streamlit app")
+    })
+
+    it("sets navigation state to hidden on navigation", () => {
+      const appPages = [
+        new AppPage({
+          pageName: "streamlit_app",
+          pageScriptHash: "page_script_hash",
+          isDefault: true,
+          sectionHeader: "section1",
+        }),
+        new AppPage({
+          pageName: "streamlit_app2",
+          pageScriptHash: "page_script_hash2",
+          isDefault: false,
+          sectionHeader: "section2",
+        }),
+      ]
+      const navigation = new Navigation({
+        sections: ["section1", "section2"],
+        appPages,
+        position: Navigation.Position.HIDDEN,
+        pageScriptHash: "page_script_hash",
+      })
+      const maybeState = appNavigation.handleNavigation(navigation)
+      expect(maybeState).not.toBeUndefined()
+
+      const [newState] = maybeState!
+      expect(newState).toEqual({
+        appPages,
+        hideSidebarNav: true,
+        currentPageScriptHash: "page_script_hash",
+        navSections: ["section1", "section2"],
+      })
+    })
+
+    it("calls host communication on navigation", () => {
+      const appPages = [
+        new AppPage({
+          pageName: "streamlit_app",
+          pageScriptHash: "page_script_hash",
+          isDefault: true,
+          sectionHeader: "section1",
+          icon: "icon1",
+        }),
+        new AppPage({
+          pageName: "streamlit_app2",
+          pageScriptHash: "page_script_hash2",
+          isDefault: false,
+          sectionHeader: "section2",
+          icon: "icon2",
+        }),
+      ]
+      const navigation = new Navigation({
+        sections: ["section1", "section2"],
+        appPages,
+        position: "hidden",
+        pageScriptHash: "page_script_hash",
+      })
+      const maybeState = appNavigation.handleNavigation(navigation)
+      expect(maybeState).not.toBeUndefined()
+
+      const callback = maybeState![1]
+      callback()
+
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_PAGE_TITLE",
+        title: "streamlit_app",
+      })
+
+      expect(onPageIconChange).toBeCalled()
+
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_APP_PAGES",
+        appPages,
+      })
+
+      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
+        type: "SET_CURRENT_PAGE_NAME",
+        currentPageName: "",
+        currentPageScriptHash: "page_script_hash",
+      })
+    })
+
+    it("does not set the icon if set page config sets title or icon", () => {
+      // Clear the mock calls to avoid any confusion from setup
+      hostCommunicationMgr.sendMessageToHost.mockClear()
+      appNavigation.handlePageConfigChanged(
+        new PageConfig({
+          title: "foo",
+          favicon: "bar",
+        })
+      )
+
+      const navigation = new Navigation({
+        sections: ["section1", "section2"],
+        appPages: [
+          new AppPage({
+            pageName: "streamlit app",
+            pageScriptHash: "page_script_hash",
+            isDefault: true,
+            sectionHeader: "section1",
+            urlPathname: "streamlit_app",
+            icon: "icon1",
+          }),
+          new AppPage({
+            pageName: "streamlit app2",
+            pageScriptHash: "page_script_hash2",
+            isDefault: false,
+            sectionHeader: "section2",
+            urlPathname: "streamlit_app2",
+            icon: "icon2",
+          }),
+        ],
+        position: "hidden",
+        pageScriptHash: "page_script_hash",
+      })
+      appNavigation.handleNavigation(navigation)
+      const hostCommCalls = hostCommunicationMgr.sendMessageToHost.mock.calls
+
+      expect(
+        hostCommCalls.some(call => call[0].type === "SET_PAGE_TITLE")
+      ).toBe(false)
+      expect(onPageIconChange).not.toBeCalled()
+    })
+  })
+})
diff --git a/frontend/app/src/util/AppNavigation.ts b/frontend/app/src/util/AppNavigation.ts
new file mode 100644
index 000000000..317545fa3
--- /dev/null
+++ b/frontend/app/src/util/AppNavigation.ts
@@ -0,0 +1,383 @@
+/**
+ * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import {
+  AppRoot,
+  BlockNode,
+  HostCommunicationManager,
+  IAppPage,
+  Navigation,
+  NewSession,
+  PageConfig,
+  PagesChanged,
+  PageNotFound,
+} from "@streamlit/lib"
+
+interface AppNavigationState {
+  hideSidebarNav: boolean
+  appPages: IAppPage[]
+  currentPageScriptHash: string
+  navSections: string[]
+}
+
+export type MaybeStateUpdate =
+  | [Partial<AppNavigationState>, () => void]
+  | undefined
+export type PageUrlUpdateCallback = (
+  mainPageName: string,
+  newPageName: string,
+  isViewingMainPage: boolean
+) => void
+export type PageNotFoundCallback = (pageName?: string) => void
+export type SetIconCallback = (icon: string) => void
+
+function getTitle(pageName: string): string {
+  if (!pageName) {
+    return "Streamlit"
+  }
+
+  return `${pageName} Â· Streamlit`
+}
+
+export class StrategyV1 {
+  private appPages: IAppPage[]
+
+  private currentPageScriptHash: string | null
+
+  private hideSidebarNav: boolean | null
+
+  private readonly appNav: AppNavigation
+
+  constructor(appNav: AppNavigation) {
+    this.appNav = appNav
+    this.appPages = []
+    this.currentPageScriptHash = null
+    this.hideSidebarNav = null
+  }
+
+  handleNewSession(newSession: NewSession): MaybeStateUpdate {
+    this.appPages = newSession.appPages
+    this.currentPageScriptHash = newSession.pageScriptHash
+    this.hideSidebarNav = newSession.config?.hideSidebarNav ?? false
+
+    // mainPage must be a string as we're guaranteed at this point that
+    // newSessionProto.appPages is nonempty and has a truthy pageName.
+    // Otherwise, we'd either have no main script or a nameless main script,
+    // neither of which can happen.
+    const mainPage = this.appPages[0] as IAppPage
+    const mainPageName = mainPage.pageName ?? ""
+    // We're similarly guaranteed that newPageName will be found / truthy
+    // here.
+    const newPageName =
+      this.appPages.find(
+        page => page.pageScriptHash === this.currentPageScriptHash
+      )?.pageName ?? ""
+
+    const isViewingMainPage =
+      mainPage.pageScriptHash === this.currentPageScriptHash
+    this.appNav.onUpdatePageUrl(mainPageName, newPageName, isViewingMainPage)
+
+    // Set the title to its default value
+    document.title = getTitle(newPageName ?? "")
+
+    return [
+      {
+        hideSidebarNav: this.hideSidebarNav,
+        appPages: this.appPages,
+        currentPageScriptHash: this.currentPageScriptHash,
+      },
+      () => {
+        this.appNav.hostCommunicationMgr.sendMessageToHost({
+          type: "SET_APP_PAGES",
+          appPages: this.appPages,
+        })
+
+        this.appNav.hostCommunicationMgr.sendMessageToHost({
+          type: "SET_CURRENT_PAGE_NAME",
+          currentPageName: isViewingMainPage ? "" : newPageName,
+          currentPageScriptHash: this.currentPageScriptHash as string,
+        })
+      },
+    ]
+  }
+
+  handlePagesChanged(pagesChangedMsg: PagesChanged): MaybeStateUpdate {
+    const { appPages } = pagesChangedMsg
+    return [
+      { appPages },
+      () => {
+        this.appNav.hostCommunicationMgr.sendMessageToHost({
+          type: "SET_APP_PAGES",
+          appPages,
+        })
+      },
+    ]
+  }
+
+  handlePageNotFound(pageNotFound: PageNotFound): MaybeStateUpdate {
+    const { pageName } = pageNotFound
+    this.appNav.onPageNotFound(pageName)
+    const currentPageScriptHash = this.appPages[0]?.pageScriptHash ?? ""
+    this.currentPageScriptHash = currentPageScriptHash
+
+    return [
+      { currentPageScriptHash },
+      () => {
+        this.appNav.hostCommunicationMgr.sendMessageToHost({
+          type: "SET_CURRENT_PAGE_NAME",
+          currentPageName: "",
+          currentPageScriptHash,
+        })
+      },
+    ]
+  }
+
+  handleNavigation(_navigationMsg: Navigation): MaybeStateUpdate {
+    // This message does not apply to V1
+    return undefined
+  }
+
+  findPageByUrlPath(pathname: string): IAppPage | null {
+    if (this.appPages.length === 0) {
+      return null
+    }
+
+    return (
+      this.appPages.find(appPage =>
+        // The page name is embedded at the end of the URL path, and if not, we are in the main page.
+        // See https://github.com/streamlit/streamlit/blob/1.19.0/frontend/src/App.tsx#L740
+        pathname.endsWith("/" + appPage.pageName)
+      ) ?? this.appPages[0]
+    )
+  }
+
+  clearPageElements(
+    _elements: AppRoot,
+    mainScriptHash: string,
+    sidebarElements: BlockNode | undefined
+  ): AppRoot {
+    return AppRoot.empty(mainScriptHash, false, sidebarElements)
+  }
+}
+
+export class StrategyV2 {
+  readonly appNav: AppNavigation
+
+  mainScriptHash: string | null
+
+  appPages: IAppPage[]
+
+  mainPage: IAppPage | null
+
+  hideSidebarNav: boolean | null
+
+  constructor(appNav: AppNavigation) {
+    this.appNav = appNav
+    this.mainScriptHash = null
+    this.appPages = []
+    this.mainPage = null
+    this.hideSidebarNav = null
+  }
+
+  handleNewSession(newSession: NewSession): MaybeStateUpdate {
+    this.mainScriptHash = newSession.mainScriptHash
+    // Initialize to the config value if provided
+    if (this.hideSidebarNav === null) {
+      this.hideSidebarNav = newSession.config?.hideSidebarNav ?? null
+    }
+
+    // We do not know the page name, so use an empty string version
+    document.title = getTitle("")
+
+    return [{ hideSidebarNav: this.hideSidebarNav ?? false }, () => {}]
+  }
+
+  handlePagesChanged(_pagesChangedMsg: PagesChanged): MaybeStateUpdate {
+    // This message does not apply to V2
+    return undefined
+  }
+
+  handlePageNotFound(pageNotFound: PageNotFound): MaybeStateUpdate {
+    const { pageName } = pageNotFound
+    this.appNav.onPageNotFound(pageName)
+
+    return [
+      { currentPageScriptHash: this.mainScriptHash ?? "" },
+      () => {
+        this.appNav.hostCommunicationMgr.sendMessageToHost({
+          type: "SET_CURRENT_PAGE_NAME",
+          currentPageName: "",
+          currentPageScriptHash: this.mainScriptHash ?? "",
+        })
+      },
+    ]
+  }
+
+  handleNavigation(navigationMsg: Navigation): MaybeStateUpdate {
+    const { sections, position, appPages } = navigationMsg
+
+    this.appPages = appPages
+    this.hideSidebarNav = position === Navigation.Position.HIDDEN
+
+    const currentPageScriptHash = navigationMsg.pageScriptHash
+    const currentPage = appPages.find(
+      p => p.pageScriptHash === currentPageScriptHash
+    ) as IAppPage
+    const mainPage = appPages.find(p => p.isDefault) as IAppPage
+    this.mainPage = mainPage
+    const currentPageName = currentPage.urlPathname as string
+
+    if (!this.appNav.isPageTitleSet) {
+      const title = getTitle(currentPage.pageName as string)
+      document.title = title
+      this.appNav.hostCommunicationMgr.sendMessageToHost({
+        type: "SET_PAGE_TITLE",
+        title: currentPage.pageName ?? "",
+      })
+    }
+
+    if (!this.appNav.isPageIconSet && currentPage.icon) {
+      this.appNav.onPageIconChange(currentPage.icon)
+    }
+
+    this.appNav.onUpdatePageUrl(
+      mainPage.urlPathname ?? "",
+      currentPageName,
+      currentPage.isDefault ?? false
+    )
+
+    return [
+      {
+        appPages,
+        navSections: sections,
+        hideSidebarNav: this.hideSidebarNav,
+        currentPageScriptHash,
+      },
+      () => {
+        this.appNav.hostCommunicationMgr.sendMessageToHost({
+          type: "SET_APP_PAGES",
+          appPages,
+        })
+
+        this.appNav.hostCommunicationMgr.sendMessageToHost({
+          type: "SET_CURRENT_PAGE_NAME",
+          // Make sure we don't send the official page name for the main page
+          // This command is used to update the URL in the url bar, so the main page
+          // should not have a page name in the URL.
+          currentPageName: currentPage.isDefault ? "" : currentPageName,
+          currentPageScriptHash,
+        })
+      },
+    ]
+  }
+
+  findPageByUrlPath(pathname: string): IAppPage | null {
+    return (
+      this.appPages.find(appPage =>
+        // The page name is embedded at the end of the URL path, and if not, we are in the main page.
+        // See https://github.com/streamlit/streamlit/blob/1.19.0/frontend/src/App.tsx#L740
+        pathname.endsWith("/" + appPage.urlPathname)
+      ) ?? this.mainPage
+    )
+  }
+
+  clearPageElements(
+    elements: AppRoot,
+    mainScriptHash: string,
+    _sidebarElements: BlockNode | undefined
+  ): AppRoot {
+    return elements.filterMainScriptElements(mainScriptHash)
+  }
+}
+
+export class AppNavigation {
+  readonly hostCommunicationMgr: HostCommunicationManager
+
+  readonly onUpdatePageUrl: PageUrlUpdateCallback
+
+  readonly onPageNotFound: PageNotFoundCallback
+
+  readonly onPageIconChange: SetIconCallback
+
+  isPageTitleSet: boolean
+
+  isPageIconSet: boolean
+
+  strategy: StrategyV1 | StrategyV2
+
+  constructor(
+    hostCommunicationMgr: HostCommunicationManager,
+    onUpdatePageUrl: PageUrlUpdateCallback,
+    onPageNotFound: PageNotFoundCallback,
+    onPageIconChange: SetIconCallback
+  ) {
+    this.hostCommunicationMgr = hostCommunicationMgr
+    this.onUpdatePageUrl = onUpdatePageUrl
+    this.onPageNotFound = onPageNotFound
+    this.onPageIconChange = onPageIconChange
+    this.isPageIconSet = false
+    this.isPageTitleSet = false
+
+    // Start with the V1 strategy as it will apply to V0 as well
+    this.strategy = new StrategyV1(this)
+  }
+
+  handleNewSession(newSession: NewSession): MaybeStateUpdate {
+    this.isPageTitleSet = false
+    this.isPageIconSet = false
+
+    return this.strategy.handleNewSession(newSession)
+  }
+
+  handleNavigation(navigationMsg: Navigation): MaybeStateUpdate {
+    // Navigation call (through st.navigation) indicates we are using
+    // MPA v2. We can change strategy here. It will set the state properly
+    if (this.strategy instanceof StrategyV1) {
+      this.strategy = new StrategyV2(this)
+    }
+
+    return this.strategy.handleNavigation(navigationMsg)
+  }
+
+  handlePagesChanged(pagesChangedMsg: PagesChanged): MaybeStateUpdate {
+    return this.strategy.handlePagesChanged(pagesChangedMsg)
+  }
+
+  handlePageNotFound(pageNotFound: PageNotFound): MaybeStateUpdate {
+    return this.strategy.handlePageNotFound(pageNotFound)
+  }
+
+  findPageByUrlPath(pathname: string): IAppPage | null {
+    return this.strategy.findPageByUrlPath(pathname)
+  }
+
+  handlePageConfigChanged(pageConfig: PageConfig): void {
+    this.isPageIconSet = Boolean(pageConfig.favicon)
+    this.isPageTitleSet = Boolean(pageConfig.title)
+  }
+
+  clearPageElements(
+    elements: AppRoot,
+    mainScriptHash: string,
+    sidebarElements: BlockNode | undefined
+  ): AppRoot {
+    return this.strategy.clearPageElements(
+      elements,
+      mainScriptHash,
+      sidebarElements
+    )
+  }
+}
diff --git a/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-after.snap.png b/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-after.snap.png
index 5428702e7..5f2921f3e 100644
Binary files a/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-after.snap.png and b/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-after.snap.png differ
diff --git a/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-before.snap.png b/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-before.snap.png
index 153201dab..30a75be90 100644
Binary files a/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-before.snap.png and b/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/theme-message-before.snap.png differ
diff --git a/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/toolbarActions.snap.png b/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/toolbarActions.snap.png
index 0af478248..922b4a9b0 100644
Binary files a/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/toolbarActions.snap.png and b/frontend/cypress/snapshots/linux/2x/hostframe.spec.js/toolbarActions.snap.png differ
diff --git a/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/date-popover-sidebar.snap.png b/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/date-popover-sidebar.snap.png
index 61d3a0c3d..0b1a99283 100644
Binary files a/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/date-popover-sidebar.snap.png and b/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/date-popover-sidebar.snap.png differ
diff --git a/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar-dark.snap.png b/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar-dark.snap.png
index b38fde294..02b67dbb3 100644
Binary files a/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar-dark.snap.png and b/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar-dark.snap.png differ
diff --git a/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar.snap.png b/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar.snap.png
index 48f04698f..51aa2c26b 100644
Binary files a/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar.snap.png and b/frontend/cypress/snapshots/linux/2x/st_sidebar.spec.js/sidebar.snap.png differ
diff --git a/frontend/lib/src/AppNode.test.ts b/frontend/lib/src/AppNode.test.ts
index 0030a3f9b..8490cfba3 100644
--- a/frontend/lib/src/AppNode.test.ts
+++ b/frontend/lib/src/AppNode.test.ts
@@ -29,7 +29,7 @@ import { Writer } from "protobufjs"
 import { vectorFromArray } from "apache-arrow"
 
 const NO_SCRIPT_RUN_ID = "NO_SCRIPT_RUN_ID"
-
+const FAKE_SCRIPT_HASH = "fake_script_hash"
 // prettier-ignore
 const BLOCK = block([
   text("1"),
@@ -40,7 +40,13 @@ const BLOCK = block([
 
 // Initialize new AppRoot with a main block node and three child block nodes - sidebar, events and bottom.
 const ROOT = new AppRoot(
-  new BlockNode([BLOCK, new BlockNode(), new BlockNode(), new BlockNode()])
+  FAKE_SCRIPT_HASH,
+  new BlockNode(FAKE_SCRIPT_HASH, [
+    BLOCK,
+    new BlockNode(FAKE_SCRIPT_HASH),
+    new BlockNode(FAKE_SCRIPT_HASH),
+    new BlockNode(FAKE_SCRIPT_HASH),
+  ])
 )
 
 describe("AppNode.getIn", () => {
@@ -804,7 +810,7 @@ describe("AppRoot.empty", () => {
   })
 
   it("creates empty tree except for a skeleton", async () => {
-    const empty = AppRoot.empty()
+    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)
 
     // The linter is misfiring here. We're not accessing a DOM node.
     // eslint-disable-next-line testing-library/no-node-access
@@ -815,6 +821,17 @@ describe("AppRoot.empty", () => {
     expect(empty.sidebar.isEmpty).toBe(true)
   })
 
+  it("sets the main script hash and active script hash", () => {
+    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)
+
+    expect(empty.mainScriptHash).toBe(FAKE_SCRIPT_HASH)
+    expect(empty.main.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
+    expect(empty.sidebar.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
+    expect(empty.event.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
+    expect(empty.bottom.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
+    expect(empty.root.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
+  })
+
   it("creates empty tree with no loading screen if query param is set", async () => {
     windowSpy.mockImplementation(() => ({
       location: {
@@ -822,7 +839,7 @@ describe("AppRoot.empty", () => {
       },
     }))
 
-    const empty = AppRoot.empty()
+    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)
 
     expect(empty.main.isEmpty).toBe(true)
     expect(empty.sidebar.isEmpty).toBe(true)
@@ -835,7 +852,7 @@ describe("AppRoot.empty", () => {
       },
     }))
 
-    const empty = AppRoot.empty()
+    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)
 
     // The linter is misfiring here. We're not accessing a DOM node.
     // eslint-disable-next-line testing-library/no-node-access
@@ -853,7 +870,7 @@ describe("AppRoot.empty", () => {
       },
     }))
 
-    const empty = AppRoot.empty()
+    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)
 
     // The linter is misfiring here. We're not accessing a DOM node.
     // eslint-disable-next-line testing-library/no-node-access
@@ -871,13 +888,47 @@ describe("AppRoot.empty", () => {
       },
     }))
 
-    const empty = AppRoot.empty(false)
+    const empty = AppRoot.empty(FAKE_SCRIPT_HASH, false)
 
     expect(empty.main.isEmpty).toBe(true)
     expect(empty.sidebar.isEmpty).toBe(true)
   })
 })
 
+describe("AppRoot.filterMainScriptElements", () => {
+  it("does not clear nodes associated with main script hash", () => {
+    // Add a new element and clear stale nodes
+    const delta = makeProto(DeltaProto, {
+      newElement: { text: { body: "newElement!" } },
+    })
+    const newRoot = ROOT.applyDelta(
+      "new_session_id",
+      delta,
+      forwardMsgMetadata([0, 1, 1])
+    ).filterMainScriptElements(FAKE_SCRIPT_HASH)
+
+    // We should now only have a single element, inside a single block
+    expect(newRoot.main.getIn([1, 1])).toBeTextNode("newElement!")
+    expect(newRoot.getElements().size).toBe(3)
+  })
+
+  it("clears nodes not associated with main script hash", () => {
+    // Add a new element and clear stale nodes
+    const delta = makeProto(DeltaProto, {
+      newElement: { text: { body: "newElement!" } },
+    })
+    const newRoot = ROOT.applyDelta(
+      "new_session_id",
+      delta,
+      forwardMsgMetadata([0, 1, 1], "DIFFERENT_HASH")
+    ).filterMainScriptElements(FAKE_SCRIPT_HASH)
+
+    // We should now only have a single element, inside a single block
+    expect(newRoot.main.getIn([1, 1])).toBeUndefined()
+    expect(newRoot.getElements().size).toBe(2)
+  })
+})
+
 describe("AppRoot.applyDelta", () => {
   it("handles 'newElement' deltas", () => {
     const delta = makeProto(DeltaProto, {
@@ -899,6 +950,7 @@ describe("AppRoot.applyDelta", () => {
     expect(newRoot.main.getIn([1])?.scriptRunId).toBe("new_session_id")
     expect(newRoot.main.getIn([1, 0])?.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
     expect(newRoot.main.getIn([1, 1])?.scriptRunId).toBe("new_session_id")
+    expect(newNode.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
     expect(newRoot.sidebar.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
   })
 
@@ -920,9 +972,46 @@ describe("AppRoot.applyDelta", () => {
     expect(newRoot.main.getIn([1])?.scriptRunId).toBe("new_session_id")
     expect(newRoot.main.getIn([1, 0])?.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
     expect(newRoot.main.getIn([1, 1])?.scriptRunId).toBe("new_session_id")
+    expect(newNode.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
     expect(newRoot.sidebar.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
   })
 
+  it("specifies active script hash on 'newElement' deltas", () => {
+    const delta = makeProto(DeltaProto, {
+      newElement: { text: { body: "newElement!" } },
+    })
+    const NEW_FAKE_SCRIPT_HASH = "new_fake_script_hash"
+    const newRoot = ROOT.applyDelta(
+      "new_session_id",
+      delta,
+      forwardMsgMetadata([0, 1, 1], NEW_FAKE_SCRIPT_HASH)
+    )
+
+    const newNode = newRoot.main.getIn([1, 1]) as ElementNode
+    expect(newNode).toBeDefined()
+
+    // Check that our new other nodes are not affected by the new script hash
+    expect(newRoot.main.getIn([1, 0])?.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
+    expect(newNode.activeScriptHash).toBe(NEW_FAKE_SCRIPT_HASH)
+  })
+
+  it("specifies active script hash on 'addBlock' deltas", () => {
+    const delta = makeProto(DeltaProto, { addBlock: {} })
+    const NEW_FAKE_SCRIPT_HASH = "new_fake_script_hash"
+    const newRoot = ROOT.applyDelta(
+      "new_session_id",
+      delta,
+      forwardMsgMetadata([0, 1, 1], NEW_FAKE_SCRIPT_HASH)
+    )
+
+    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
+    expect(newNode).toBeDefined()
+
+    // Check that our new scriptRunId has been set only on the touched nodes
+    expect(newRoot.main.getIn([1, 0])?.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
+    expect(newNode.activeScriptHash).toBe(NEW_FAKE_SCRIPT_HASH)
+  })
+
   it("can set fragmentId in 'newElement' deltas", () => {
     const delta = makeProto(DeltaProto, {
       newElement: { text: { body: "newElement!" } },
@@ -972,7 +1061,7 @@ describe("AppRoot.clearStaleNodes", () => {
   })
 
   it("handles currentFragmentId correctly", () => {
-    const root = AppRoot.empty()
+    const root = AppRoot.empty(FAKE_SCRIPT_HASH)
       // Block not corresponding to my_fragment_id. Should be preserved.
       .applyDelta(
         "old_session_id",
@@ -1062,7 +1151,12 @@ describe("AppRoot.getElements", () => {
 /** Create a `Text` element node with the given properties. */
 function text(text: string, scriptRunId = NO_SCRIPT_RUN_ID): ElementNode {
   const element = makeProto(Element, { text: { body: text } })
-  return new ElementNode(element, ForwardMsgMetadata.create(), scriptRunId)
+  return new ElementNode(
+    element,
+    ForwardMsgMetadata.create(),
+    scriptRunId,
+    FAKE_SCRIPT_HASH
+  )
 }
 
 /** Create a BlockNode with the given properties. */
@@ -1070,19 +1164,34 @@ function block(
   children: AppNode[] = [],
   scriptRunId = NO_SCRIPT_RUN_ID
 ): BlockNode {
-  return new BlockNode(children, makeProto(BlockProto, {}), scriptRunId)
+  return new BlockNode(
+    FAKE_SCRIPT_HASH,
+    children,
+    makeProto(BlockProto, {}),
+    scriptRunId
+  )
 }
 
 /** Create an arrowTable element node with the given properties. */
 function arrowTable(scriptRunId = NO_SCRIPT_RUN_ID): ElementNode {
   const element = makeProto(Element, { arrowTable: { data: UNICODE } })
-  return new ElementNode(element, ForwardMsgMetadata.create(), scriptRunId)
+  return new ElementNode(
+    element,
+    ForwardMsgMetadata.create(),
+    scriptRunId,
+    FAKE_SCRIPT_HASH
+  )
 }
 
 /** Create an arrowDataFrame element node with the given properties. */
 function arrowDataFrame(scriptRunId = NO_SCRIPT_RUN_ID): ElementNode {
   const element = makeProto(Element, { arrowDataFrame: { data: UNICODE } })
-  return new ElementNode(element, ForwardMsgMetadata.create(), scriptRunId)
+  return new ElementNode(
+    element,
+    ForwardMsgMetadata.create(),
+    scriptRunId,
+    FAKE_SCRIPT_HASH
+  )
 }
 
 /** Create an arrowVegaLiteChart element node with the given properties. */
@@ -1091,13 +1200,21 @@ function arrowVegaLiteChart(
   scriptRunId = NO_SCRIPT_RUN_ID
 ): ElementNode {
   const element = makeProto(Element, { arrowVegaLiteChart: data })
-  return new ElementNode(element, ForwardMsgMetadata.create(), scriptRunId)
+  return new ElementNode(
+    element,
+    ForwardMsgMetadata.create(),
+    scriptRunId,
+    FAKE_SCRIPT_HASH
+  )
 }
 
 /** Create a ForwardMsgMetadata with the given container and path */
-function forwardMsgMetadata(deltaPath: number[]): ForwardMsgMetadata {
+function forwardMsgMetadata(
+  deltaPath: number[],
+  activeScriptHash = FAKE_SCRIPT_HASH
+): ForwardMsgMetadata {
   expect(deltaPath.length).toBeGreaterThanOrEqual(2)
-  return makeProto(ForwardMsgMetadata, { deltaPath })
+  return makeProto(ForwardMsgMetadata, { deltaPath, activeScriptHash })
 }
 
 /**
diff --git a/frontend/lib/src/AppNode.ts b/frontend/lib/src/AppNode.ts
index 1e0cec9e0..06ee00da8 100644
--- a/frontend/lib/src/AppNode.ts
+++ b/frontend/lib/src/AppNode.ts
@@ -25,6 +25,7 @@ import {
   ForwardMsgMetadata,
   IArrow,
   IArrowNamedDataSet,
+  Logo,
 } from "./proto"
 import {
   VegaLiteChartElement,
@@ -42,6 +43,11 @@ import {
 } from "./util/utils"
 
 const NO_SCRIPT_RUN_ID = "NO_SCRIPT_RUN_ID"
+interface AppLogo {
+  logo: Logo
+  // Associated scriptHash that created the logo
+  activeScriptHash: string
+}
 
 /**
  * An immutable node of the "App Data Tree".
@@ -96,6 +102,11 @@ export interface AppNode {
    */
   readonly fragmentId?: string
 
+  /**
+   * The hash of the script that created this node.
+   */
+  readonly activeScriptHash?: string
+
   /**
    * Return the AppNode for the given index path, or undefined if the path
    * is invalid.
@@ -108,6 +119,12 @@ export interface AppNode {
    */
   setIn(path: number[], node: AppNode, scriptRunId: string): AppNode
 
+  /**
+   * Recursively remove children nodes whose activeScriptHash is no longer
+   * associated with the mainScriptHash.
+   */
+  filterMainScriptElements(mainScriptHash: string): AppNode | undefined
+
   /**
    * Recursively remove children nodes whose scriptRunId is no longer current.
    * If this node should no longer exist, return undefined.
@@ -142,16 +159,21 @@ export class ElementNode implements AppNode {
 
   private lazyVegaLiteChartElement?: VegaLiteChartElement
 
+  // The hash of the script that created this element.
+  public readonly activeScriptHash: string
+
   /** Create a new ElementNode. */
   public constructor(
     element: Element,
     metadata: ForwardMsgMetadata,
     scriptRunId: string,
+    activeScriptHash: string,
     fragmentId?: string
   ) {
     this.element = element
     this.metadata = metadata
     this.scriptRunId = scriptRunId
+    this.activeScriptHash = activeScriptHash
     this.fragmentId = fragmentId
   }
 
@@ -216,6 +238,16 @@ export class ElementNode implements AppNode {
     throw new Error("'setIn' cannot be called on an ElementNode")
   }
 
+  public filterMainScriptElements(
+    mainScriptHash: string
+  ): AppNode | undefined {
+    if (this.activeScriptHash !== mainScriptHash) {
+      return undefined
+    }
+
+    return this
+  }
+
   public clearStaleNodes(
     currentScriptRunId: string,
     fragmentIdsThisRun?: Array<string>,
@@ -261,6 +293,7 @@ export class ElementNode implements AppNode {
       this.element,
       this.metadata,
       scriptRunId,
+      this.activeScriptHash,
       this.fragmentId
     )
 
@@ -356,12 +389,17 @@ export class BlockNode implements AppNode {
 
   public readonly fragmentId?: string
 
+  // The hash of the script that created this block.
+  public readonly activeScriptHash: string
+
   public constructor(
+    activeScriptHash: string,
     children?: AppNode[],
     deltaBlock?: BlockProto,
     scriptRunId?: string,
     fragmentId?: string
   ) {
+    this.activeScriptHash = activeScriptHash
     this.children = children ?? []
     this.deltaBlock = deltaBlock ?? new BlockProto({})
     this.scriptRunId = scriptRunId ?? NO_SCRIPT_RUN_ID
@@ -416,6 +454,7 @@ export class BlockNode implements AppNode {
     }
 
     return new BlockNode(
+      this.activeScriptHash,
       newChildren,
       this.deltaBlock,
       scriptRunId,
@@ -423,6 +462,25 @@ export class BlockNode implements AppNode {
     )
   }
 
+  filterMainScriptElements(mainScriptHash: string): AppNode | undefined {
+    if (this.activeScriptHash !== mainScriptHash) {
+      return undefined
+    }
+
+    // Recursively clear our children.
+    const newChildren = this.children
+      .map(child => child.filterMainScriptElements(mainScriptHash))
+      .filter(notUndefined)
+
+    return new BlockNode(
+      this.activeScriptHash,
+      newChildren,
+      this.deltaBlock,
+      this.scriptRunId,
+      this.fragmentId
+    )
+  }
+
   public clearStaleNodes(
     currentScriptRunId: string,
     fragmentIdsThisRun?: Array<string>,
@@ -467,6 +525,7 @@ export class BlockNode implements AppNode {
       .filter(notUndefined)
 
     return new BlockNode(
+      this.activeScriptHash,
       newChildren,
       this.deltaBlock,
       currentScriptRunId,
@@ -491,12 +550,18 @@ export class BlockNode implements AppNode {
  * The root of our data tree. It contains the app's top-level BlockNodes.
  */
 export class AppRoot {
-  private readonly root: BlockNode
+  readonly root: BlockNode
+
+  /* The hash of the main script that creates this AppRoot. */
+  readonly mainScriptHash: string
+
+  readonly appLogo: AppLogo | null
 
   /**
    * Create an empty AppRoot with a placeholder "skeleton" element.
    */
   public static empty(
+    mainScriptHash = "",
     isInitialRender = true,
     sidebarElements?: BlockNode | undefined
   ): AppRoot {
@@ -526,12 +591,14 @@ export class AppRoot {
         new ElementNode(
           waitElement,
           ForwardMsgMetadata.create({}),
-          NO_SCRIPT_RUN_ID
+          NO_SCRIPT_RUN_ID,
+          mainScriptHash
         )
       )
     }
 
     const main = new BlockNode(
+      mainScriptHash,
       mainNodes,
       new BlockProto({ allowEmpty: true }),
       NO_SCRIPT_RUN_ID
@@ -539,25 +606,42 @@ export class AppRoot {
 
     const sidebar =
       sidebarElements ||
-      new BlockNode([], new BlockProto({ allowEmpty: true }), NO_SCRIPT_RUN_ID)
+      new BlockNode(
+        mainScriptHash,
+        [],
+        new BlockProto({ allowEmpty: true }),
+        NO_SCRIPT_RUN_ID
+      )
 
     const event = new BlockNode(
+      mainScriptHash,
       [],
       new BlockProto({ allowEmpty: true }),
       NO_SCRIPT_RUN_ID
     )
 
     const bottom = new BlockNode(
+      mainScriptHash,
       [],
       new BlockProto({ allowEmpty: true }),
       NO_SCRIPT_RUN_ID
     )
 
-    return new AppRoot(new BlockNode([main, sidebar, event, bottom]))
+    return new AppRoot(
+      mainScriptHash,
+      new BlockNode(mainScriptHash, [main, sidebar, event, bottom]),
+      null
+    )
   }
 
-  public constructor(root: BlockNode) {
+  public constructor(
+    mainScriptHash: string,
+    root: BlockNode,
+    appLogo: AppLogo | null = null
+  ) {
+    this.mainScriptHash = mainScriptHash
     this.root = root
+    this.appLogo = appLogo
 
     // Verify that our root node has exactly 4 children: a 'main' block,
     // a 'sidebar' block, a `bottom` block and an 'event' block.
@@ -592,6 +676,18 @@ export class AppRoot {
     return bottom as BlockNode
   }
 
+  public get logo(): Logo | null {
+    return this.appLogo?.logo ?? null
+  }
+
+  public appRootWithLogo(logo: Logo, metadata: ForwardMsgMetadata): AppRoot {
+    const { activeScriptHash } = metadata
+    return new AppRoot(this.mainScriptHash, this.root, {
+      logo,
+      activeScriptHash,
+    })
+  }
+
   public applyDelta(
     scriptRunId: string,
     delta: Delta,
@@ -599,7 +695,7 @@ export class AppRoot {
   ): AppRoot {
     // The full path to the AppNode within the element tree.
     // Used to find and update the element node specified by this Delta.
-    const { deltaPath } = metadata
+    const { deltaPath, activeScriptHash } = metadata
 
     switch (delta.type) {
       case "newElement": {
@@ -609,6 +705,7 @@ export class AppRoot {
           scriptRunId,
           element,
           metadata,
+          activeScriptHash,
           delta.fragmentId
         )
       }
@@ -618,6 +715,7 @@ export class AppRoot {
           deltaPath,
           delta.addBlock as BlockProto,
           scriptRunId,
+          activeScriptHash,
           delta.fragmentId
         )
       }
@@ -637,7 +735,8 @@ export class AppRoot {
             deltaPath,
             scriptRunId,
             errorElement,
-            metadata
+            metadata,
+            activeScriptHash
           )
         }
       }
@@ -648,29 +747,63 @@ export class AppRoot {
     }
   }
 
+  filterMainScriptElements(mainScriptHash: string): AppRoot {
+    // clears all nodes that are not associated with the mainScriptHash
+    // Get the current script run id from one of the children
+    const currentScriptRunId = this.main.scriptRunId
+    const main =
+      this.main.filterMainScriptElements(mainScriptHash) ||
+      new BlockNode(mainScriptHash)
+    const sidebar =
+      this.sidebar.filterMainScriptElements(mainScriptHash) ||
+      new BlockNode(mainScriptHash)
+    const event =
+      this.event.filterMainScriptElements(mainScriptHash) ||
+      new BlockNode(mainScriptHash)
+    const bottom =
+      this.bottom.filterMainScriptElements(mainScriptHash) ||
+      new BlockNode(mainScriptHash)
+    const appLogo =
+      this.appLogo?.activeScriptHash === mainScriptHash ? this.appLogo : null
+
+    return new AppRoot(
+      mainScriptHash,
+      new BlockNode(
+        mainScriptHash,
+        [main, sidebar, event, bottom],
+        new BlockProto({ allowEmpty: true }),
+        currentScriptRunId
+      ),
+      appLogo
+    )
+  }
+
   public clearStaleNodes(
     currentScriptRunId: string,
     fragmentIdsThisRun?: Array<string>
   ): AppRoot {
     const main =
       this.main.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
-      new BlockNode()
+      new BlockNode(this.mainScriptHash)
     const sidebar =
       this.sidebar.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
-      new BlockNode()
+      new BlockNode(this.mainScriptHash)
     const event =
       this.event.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
-      new BlockNode()
+      new BlockNode(this.mainScriptHash)
     const bottom =
       this.bottom.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
-      new BlockNode()
+      new BlockNode(this.mainScriptHash)
 
     return new AppRoot(
+      this.mainScriptHash,
       new BlockNode(
+        this.mainScriptHash,
         [main, sidebar, event, bottom],
         new BlockProto({ allowEmpty: true }),
         currentScriptRunId
-      )
+      ),
+      this.appLogo
     )
   }
 
@@ -689,21 +822,28 @@ export class AppRoot {
     scriptRunId: string,
     element: Element,
     metadata: ForwardMsgMetadata,
+    activeScriptHash: string,
     fragmentId?: string
   ): AppRoot {
     const elementNode = new ElementNode(
       element,
       metadata,
       scriptRunId,
+      activeScriptHash,
       fragmentId
     )
-    return new AppRoot(this.root.setIn(deltaPath, elementNode, scriptRunId))
+    return new AppRoot(
+      this.mainScriptHash,
+      this.root.setIn(deltaPath, elementNode, scriptRunId),
+      this.appLogo
+    )
   }
 
   private addBlock(
     deltaPath: number[],
     block: BlockProto,
     scriptRunId: string,
+    activeScriptHash: string,
     fragmentId?: string
   ): AppRoot {
     const existingNode = this.root.getIn(deltaPath)
@@ -714,8 +854,18 @@ export class AppRoot {
     const children: AppNode[] =
       existingNode instanceof BlockNode ? existingNode.children : []
 
-    const blockNode = new BlockNode(children, block, scriptRunId, fragmentId)
-    return new AppRoot(this.root.setIn(deltaPath, blockNode, scriptRunId))
+    const blockNode = new BlockNode(
+      activeScriptHash,
+      children,
+      block,
+      scriptRunId,
+      fragmentId
+    )
+    return new AppRoot(
+      this.mainScriptHash,
+      this.root.setIn(deltaPath, blockNode, scriptRunId),
+      this.appLogo
+    )
   }
 
   private arrowAddRows(
@@ -729,7 +879,11 @@ export class AppRoot {
     }
 
     const elementNode = existingNode.arrowAddRows(namedDataSet, scriptRunId)
-    return new AppRoot(this.root.setIn(deltaPath, elementNode, scriptRunId))
+    return new AppRoot(
+      this.mainScriptHash,
+      this.root.setIn(deltaPath, elementNode, scriptRunId),
+      this.appLogo
+    )
   }
 }
 
diff --git a/frontend/lib/src/StreamlitEndpoints.ts b/frontend/lib/src/StreamlitEndpoints.ts
index a2eecef88..37e10cf10 100644
--- a/frontend/lib/src/StreamlitEndpoints.ts
+++ b/frontend/lib/src/StreamlitEndpoints.ts
@@ -53,11 +53,7 @@ export interface StreamlitEndpoints {
    * @param page the page's AppPage protobuf properties
    * @param pageIndex the page's zero-based index
    */
-  buildAppPageURL(
-    pageLinkBaseURL: string | undefined,
-    page: IAppPage,
-    pageIndex: number
-  ): string
+  buildAppPageURL(pageLinkBaseURL: string | undefined, page: IAppPage): string
 
   /**
    * Upload a file to the FileUploader endpoint.
diff --git a/frontend/lib/src/WidgetStateManager.test.ts b/frontend/lib/src/WidgetStateManager.test.ts
index 355a224a5..57329bca4 100644
--- a/frontend/lib/src/WidgetStateManager.test.ts
+++ b/frontend/lib/src/WidgetStateManager.test.ts
@@ -955,4 +955,40 @@ describe("WidgetStateDict", () => {
     expect(widgetStateDict.getState(widgetId2)).toEqual({ id: widgetId2 })
     expect(widgetStateDict.getState(widgetId3)).toEqual({ id: widgetId3 })
   })
+
+  it("supplies WidgetStates with for active widgets based on input", () => {
+    const widgetStateManager = new WidgetStateManager({
+      sendRerunBackMsg: jest.fn(),
+      formsDataChanged: jest.fn(),
+    })
+
+    widgetStateManager.setStringValue(
+      { id: "widget1" },
+      "foo",
+      {
+        fromUi: false,
+      },
+      undefined
+    )
+    widgetStateManager.setStringValue(
+      { id: "widget2" },
+      "bar",
+      {
+        fromUi: false,
+      },
+      undefined
+    )
+
+    const activeIds = new Set(["widget2"])
+    const widgetStates = widgetStateManager.getActiveWidgetStates(activeIds)
+
+    expect(widgetStates).toEqual({
+      widgets: [
+        {
+          id: "widget2",
+          stringValue: "bar",
+        },
+      ],
+    })
+  })
 })
diff --git a/frontend/lib/src/WidgetStateManager.ts b/frontend/lib/src/WidgetStateManager.ts
index 2c80c3348..a2318bfcb 100644
--- a/frontend/lib/src/WidgetStateManager.ts
+++ b/frontend/lib/src/WidgetStateManager.ts
@@ -586,6 +586,16 @@ export class WidgetStateManager {
     )
   }
 
+  public getActiveWidgetStates(activeIds: Set<string>): WidgetStates {
+    const msg = new WidgetStates()
+    this.widgetStates.forEach(widgetState => {
+      if (activeIds.has(widgetState.id)) {
+        msg.widgets.push(widgetState)
+      }
+    })
+    return msg
+  }
+
   /**
    * Remove the state of widgets that are not contained in `activeIds`.
    * This is called when a script finishes running, so that we don't retain
diff --git a/frontend/lib/src/components/core/Block/Block.test.tsx b/frontend/lib/src/components/core/Block/Block.test.tsx
index 247661f26..3f770400c 100644
--- a/frontend/lib/src/components/core/Block/Block.test.tsx
+++ b/frontend/lib/src/components/core/Block/Block.test.tsx
@@ -26,6 +26,7 @@ import { ScriptRunState } from "@streamlit/lib/src/ScriptRunState"
 
 import VerticalBlock from "./Block"
 
+const FAKE_SCRIPT_HASH = "fake_script_hash"
 class ResizeObserver {
   observe(): void {}
 
@@ -36,6 +37,7 @@ class ResizeObserver {
 
 function makeColumn(weight: number, children: BlockNode[] = []): BlockNode {
   return new BlockNode(
+    FAKE_SCRIPT_HASH,
     children,
     new BlockProto({ allowEmpty: true, column: { weight } })
   )
@@ -45,6 +47,7 @@ function makeHorizontalBlock(numColumns: number): BlockNode {
   const weight = 1 / numColumns
 
   return new BlockNode(
+    FAKE_SCRIPT_HASH,
     Array.from({ length: numColumns }, () => makeColumn(weight)),
     new BlockProto({ allowEmpty: true, horizontal: { gap: "small" } })
   )
@@ -55,6 +58,7 @@ function makeVerticalBlock(
   additionalProps: Partial<BlockProto> = {}
 ): BlockNode {
   return new BlockNode(
+    FAKE_SCRIPT_HASH,
     children,
     new BlockProto({ allowEmpty: true, ...additionalProps })
   )
diff --git a/frontend/lib/src/components/core/Block/ElementNodeRenderer.test.tsx b/frontend/lib/src/components/core/Block/ElementNodeRenderer.test.tsx
index c1c86d573..b339076ae 100644
--- a/frontend/lib/src/components/core/Block/ElementNodeRenderer.test.tsx
+++ b/frontend/lib/src/components/core/Block/ElementNodeRenderer.test.tsx
@@ -37,13 +37,16 @@ import ElementNodeRenderer, {
   ElementNodeRendererProps,
 } from "./ElementNodeRenderer"
 
+const FAKE_SCRIPT_HASH = "fake_script_hash"
+
 function createBalloonNode(scriptRunId: string): ElementNode {
   const node = new ElementNode(
     new BalloonsProto({
       show: true,
     }),
     ForwardMsgMetadata.create({}),
-    scriptRunId
+    scriptRunId,
+    FAKE_SCRIPT_HASH
   )
   node.element.type = "balloons"
   return node
@@ -55,7 +58,8 @@ function createSnowNode(scriptRunId: string): ElementNode {
       show: true,
     }),
     ForwardMsgMetadata.create({}),
-    scriptRunId
+    scriptRunId,
+    FAKE_SCRIPT_HASH
   )
   node.element.type = "snow"
   return node
diff --git a/frontend/lib/src/components/core/Block/utils.test.ts b/frontend/lib/src/components/core/Block/utils.test.ts
index 6b26e3305..69c9b2996 100644
--- a/frontend/lib/src/components/core/Block/utils.test.ts
+++ b/frontend/lib/src/components/core/Block/utils.test.ts
@@ -20,8 +20,14 @@ import { ScriptRunState } from "@streamlit/lib/src/ScriptRunState"
 import { isElementStale } from "./utils"
 
 describe("isElementStale", () => {
-  // @ts-expect-error
-  const node = new ElementNode(null, null, "myScriptRunId", "myFragmentId")
+  const node = new ElementNode(
+    // @ts-expect-error
+    null,
+    null,
+    "myScriptRunId",
+    "activeScriptHash",
+    "myFragmentId"
+  )
 
   it("returns true if scriptRunState is RERUN_REQUESTED", () => {
     expect(
diff --git a/frontend/lib/src/components/elements/Tabs/Tabs.test.tsx b/frontend/lib/src/components/elements/Tabs/Tabs.test.tsx
index de0f9d4fe..af8e89444 100644
--- a/frontend/lib/src/components/elements/Tabs/Tabs.test.tsx
+++ b/frontend/lib/src/components/elements/Tabs/Tabs.test.tsx
@@ -24,8 +24,11 @@ import { Block as BlockProto } from "@streamlit/lib/src/proto"
 
 import Tabs, { TabProps } from "./Tabs"
 
+const FAKE_SCRIPT_HASH = "fake_script_hash"
+
 function makeTab(label: string, children: BlockNode[] = []): BlockNode {
   return new BlockNode(
+    FAKE_SCRIPT_HASH,
     children,
     new BlockProto({ allowEmpty: true, tab: { label } })
   )
@@ -33,6 +36,7 @@ function makeTab(label: string, children: BlockNode[] = []): BlockNode {
 
 function makeTabsNode(tabs: number): BlockNode {
   return new BlockNode(
+    FAKE_SCRIPT_HASH,
     Array.from({ length: tabs }, (_element, index) => makeTab(`Tab ${index}`)),
     new BlockProto({ allowEmpty: true })
   )
diff --git a/frontend/lib/src/util/Hooks.test.ts b/frontend/lib/src/util/Hooks.test.ts
index d9eb54869..e7c8142a5 100644
--- a/frontend/lib/src/util/Hooks.test.ts
+++ b/frontend/lib/src/util/Hooks.test.ts
@@ -21,6 +21,7 @@ const stateSetters: Array<any> = []
 jest.mock("react", () => ({
   __esModule: true,
   ...jest.requireActual("react"),
+  useCallback: jest.fn().mockImplementation(cb => cb),
   useEffect: jest.fn().mockImplementation(cb => cb()),
   useState: jest.fn().mockImplementation(() => {
     const setValue = jest.fn()
diff --git a/frontend/lib/src/util/Hooks.ts b/frontend/lib/src/util/Hooks.ts
index 1f135409c..a8e869701 100644
--- a/frontend/lib/src/util/Hooks.ts
+++ b/frontend/lib/src/util/Hooks.ts
@@ -14,7 +14,13 @@
  * limitations under the License.
  */
 
-import { MutableRefObject, useRef, useEffect, useState } from "react"
+import {
+  MutableRefObject,
+  useCallback,
+  useEffect,
+  useRef,
+  useState,
+} from "react"
 
 export const usePrevious = (value: any): any => {
   const ref = useRef()
@@ -32,14 +38,31 @@ export const useIsOverflowing = (
 ): boolean => {
   const { current } = ref
   const [isOverflowing, setIsOverflowing] = useState(false)
-
-  useEffect(() => {
+  const checkOverflowing = useCallback(() => {
     if (current) {
       const { scrollHeight, clientHeight } = current
 
       setIsOverflowing(scrollHeight > clientHeight)
     }
-  }, [setIsOverflowing, expanded, current, current?.clientHeight])
+  }, [current])
+
+  // We want to double check if the element is overflowing
+  // when the expanded state changes or the height of the
+  // element changes
+  useEffect(() => {
+    checkOverflowing()
+    // eslint-disable-next-line react-hooks/exhaustive-deps
+  }, [expanded, current?.clientHeight])
+
+  // Window resizing can also affect the overflow state
+  // so we need to check it as well
+  useEffect(() => {
+    window.addEventListener("resize", checkOverflowing)
+
+    return () => {
+      window.removeEventListener("resize", checkOverflowing)
+    }
+  }, [checkOverflowing])
 
   return isOverflowing
 }
diff --git a/lib/streamlit/__init__.py b/lib/streamlit/__init__.py
index ae95a3d3d..c44823e04 100644
--- a/lib/streamlit/__init__.py
+++ b/lib/streamlit/__init__.py
@@ -106,6 +106,8 @@ import streamlit.column_config as _column_config
 
 from streamlit.echo import echo as echo
 from streamlit.commands.logo import logo as logo
+from streamlit.commands.navigation import navigation as navigation
+from streamlit.navigation.page import Page as Page
 from streamlit.elements.spinner import spinner as spinner
 
 from streamlit.commands.page_config import set_page_config as set_page_config
diff --git a/lib/streamlit/commands/execution_control.py b/lib/streamlit/commands/execution_control.py
index 23dfd48d8..75ad107a5 100644
--- a/lib/streamlit/commands/execution_control.py
+++ b/lib/streamlit/commands/execution_control.py
@@ -18,11 +18,11 @@ import os
 from typing import Final, NoReturn
 
 import streamlit as st
-from streamlit import source_util
 from streamlit.deprecation_util import make_deprecated_name_warning
 from streamlit.errors import NoSessionContext, StreamlitAPIException
 from streamlit.file_util import get_main_script_directory, normalize_path_join
 from streamlit.logger import get_logger
+from streamlit.navigation.page import StreamlitPage
 from streamlit.runtime.metrics_util import gather_metrics
 from streamlit.runtime.scriptrunner import RerunData, get_script_run_ctx
 
@@ -96,7 +96,7 @@ def experimental_rerun() -> NoReturn:
 
 
 @gather_metrics("switch_page")
-def switch_page(page: str) -> NoReturn:  # type: ignore[misc]
+def switch_page(page: str | StreamlitPage) -> NoReturn:  # type: ignore[misc]
     """Programmatically switch the current page in a multipage app.
 
     When ``st.switch_page`` is called, the current page execution stops and
@@ -107,8 +107,10 @@ def switch_page(page: str) -> NoReturn:  # type: ignore[misc]
 
     Parameters
     ----------
-    page: str
-        The file path (relative to the main script) of the page to switch to.
+    page: str or st.Page
+        The file path (relative to the main script) or an st.Page indicating
+        the page to switch to.
+
 
     Example
     -------
@@ -141,21 +143,29 @@ def switch_page(page: str) -> NoReturn:  # type: ignore[misc]
         # This should never be the case
         raise NoSessionContext()
 
-    main_script_directory = get_main_script_directory(ctx.main_script_path)
-    requested_page = os.path.realpath(normalize_path_join(main_script_directory, page))
-    all_app_pages = source_util.get_pages(ctx.main_script_path).values()
+    page_script_hash = ""
+    if isinstance(page, StreamlitPage):
+        page_script_hash = page._script_hash
+    else:
+        main_script_directory = get_main_script_directory(ctx.main_script_path)
+        requested_page = os.path.realpath(
+            normalize_path_join(main_script_directory, page)
+        )
+        all_app_pages = ctx.pages_manager.get_pages().values()
 
-    matched_pages = [p for p in all_app_pages if p["script_path"] == requested_page]
+        matched_pages = [p for p in all_app_pages if p["script_path"] == requested_page]
 
-    if len(matched_pages) == 0:
-        raise StreamlitAPIException(
-            f"Could not find page: `{page}`. Must be the file path relative to the main script, from the directory: `{os.path.basename(main_script_directory)}`. Only the main app file and files in the `pages/` directory are supported."
-        )
+        if len(matched_pages) == 0:
+            raise StreamlitAPIException(
+                f"Could not find page: `{page}`. Must be the file path relative to the main script, from the directory: `{os.path.basename(main_script_directory)}`. Only the main app file and files in the `pages/` directory are supported."
+            )
+
+        page_script_hash = matched_pages[0]["page_script_hash"]
 
     ctx.script_requests.request_rerun(
         RerunData(
             query_string=ctx.query_string,
-            page_script_hash=matched_pages[0]["page_script_hash"],
+            page_script_hash=page_script_hash,
         )
     )
     # Force a yield point so the runner can do the rerun
diff --git a/lib/streamlit/commands/navigation.py b/lib/streamlit/commands/navigation.py
new file mode 100644
index 000000000..23765c03e
--- /dev/null
+++ b/lib/streamlit/commands/navigation.py
@@ -0,0 +1,191 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from __future__ import annotations
+
+from pathlib import Path
+from typing import Literal
+
+from typing_extensions import TypeAlias
+
+from streamlit.errors import StreamlitAPIException
+from streamlit.navigation.page import StreamlitPage
+from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
+from streamlit.proto.Navigation_pb2 import Navigation as NavigationProto
+from streamlit.runtime.metrics_util import gather_metrics
+from streamlit.runtime.scriptrunner.script_run_context import (
+    ScriptRunContext,
+    get_script_run_ctx,
+)
+from streamlit.source_util import PageHash, PageInfo
+
+SectionHeader: TypeAlias = str
+
+
+def pages_from_nav_sections(
+    nav_sections: dict[SectionHeader, list[StreamlitPage]]
+) -> list[StreamlitPage]:
+    page_list = []
+    for pages in nav_sections.values():
+        for page in pages:
+            page_list.append(page)
+
+    return page_list
+
+
+def send_page_not_found(ctx: ScriptRunContext):
+    msg = ForwardMsg()
+    msg.page_not_found.page_name = ""
+    ctx.enqueue(msg)
+
+
+@gather_metrics("navigation")
+def navigation(
+    pages: list[StreamlitPage] | dict[SectionHeader, list[StreamlitPage]],
+    *,
+    position: Literal["sidebar", "hidden"] = "sidebar",
+) -> StreamlitPage | None:
+    """
+    Configure the available pages in a multipage app.
+
+    Call `st.navigation` in your main script with one or more pages defined by
+    `st.Page`. `st.navigation` returns the current page which can be executed
+    using `Page.run()`.
+
+    When using `st.navigation`, the main script is executed on every app rerun,
+    with the current page executed in-line using `Page.run()`. The set of
+    available pages can be updated with each rerun for dynamic navigation. In
+    this mode, the `pages/` folder is ignored.
+
+    By default, `st.navigation` draws the available pages in the side
+    navigation. This behavior can be changed using the `position=` keyword
+    argument.
+
+    Parameters
+    ----------
+    pages: list[st.Page] or dict[str, list[st.Page]]
+        A list of `st.Page` objects or a dictionary where the keys are section
+        headers and the values are lists of `st.Page` objects.
+
+    position: "sidebar" or "hidden"
+        The position of the navigation menu. Can be "sidebar" or "hidden".
+
+    Example
+    -------
+    >>> import streamlit as st
+    >>> from pages import page1, page2
+    >>>
+    >>>	pg = st.navigation([st.Page(page1), st.Page(page2)])
+    >>>
+    >>>	st.title("My Awesome App")
+    >>> pg.run()
+    """
+    ctx = get_script_run_ctx()
+    if not ctx:
+        return None
+
+    nav_sections = {"": pages} if isinstance(pages, list) else pages
+    page_list = pages_from_nav_sections(nav_sections)
+
+    if not page_list:
+        raise StreamlitAPIException(
+            "`st.navigation` must be called with at least one `st.Page`."
+        )
+
+    default_page = None
+    pagehash_to_pageinfo: dict[PageHash, PageInfo] = {}
+
+    # This nested loop keeps track of two things:
+    # 1. the default page
+    # 2. the pagehash to pageinfo mapping
+    for section_header in nav_sections:
+        for page in nav_sections[section_header]:
+            if page._default:
+                if default_page is not None:
+                    raise StreamlitAPIException(
+                        "Multiple Pages specified with `default=True`. "
+                        "At most one Page can be set to default."
+                    )
+                default_page = page
+
+            if isinstance(page._page, Path):
+                script_path = str(page._page)
+            else:
+                script_path = ""
+
+            script_hash = page._script_hash
+            if script_hash in pagehash_to_pageinfo:
+                # The page script hash is soley based on the url path
+                # So duplicate page script hashes are due to duplicate url paths
+                raise StreamlitAPIException(
+                    f"Multiple Pages specified with URL pathname {page.url_path}. "
+                    "URL pathnames must be unique. The url pathname may be "
+                    "inferred from the filename, callable name, or title."
+                )
+
+            pagehash_to_pageinfo[script_hash] = {
+                "page_script_hash": script_hash,
+                "page_name": page.title,
+                "icon": page.icon,
+                "script_path": script_path,
+                "url_pathname": page.url_path,
+            }
+
+    if default_page is None:
+        default_page = page_list[0]
+        default_page._default = True
+
+    msg = ForwardMsg()
+    if position == "hidden":
+        msg.navigation.position = NavigationProto.Position.HIDDEN
+    else:
+        msg.navigation.position = NavigationProto.Position.SIDEBAR
+    msg.navigation.sections[:] = nav_sections.keys()
+    for section_header in nav_sections:
+        for page in nav_sections[section_header]:
+            p = msg.navigation.app_pages.add()
+            p.page_script_hash = page._script_hash
+            p.page_name = page.title
+            p.icon = page.icon
+            p.is_default = page._default
+            p.section_header = section_header
+            p.url_pathname = page.url_path
+
+    # Inform our page manager about the set of pages we have
+    ctx.pages_manager.set_pages(pagehash_to_pageinfo)
+    found_page = ctx.pages_manager.get_page_script(
+        fallback_page_hash=default_page._script_hash
+    )
+
+    page_to_return = None
+    if found_page:
+        found_page_script_hash = found_page["page_script_hash"]
+        matching_pages = [
+            p for p in page_list if p._script_hash == found_page_script_hash
+        ]
+        if len(matching_pages) > 0:
+            page_to_return = matching_pages[0]
+
+    if not page_to_return:
+        send_page_not_found(ctx)
+        page_to_return = default_page
+
+    # Ordain the page that can be called
+    page_to_return._can_be_called = True
+    msg.navigation.page_script_hash = page_to_return._script_hash
+
+    # This will either navigation or yield if the page is not found
+    ctx.enqueue(msg)
+
+    return page_to_return
diff --git a/lib/streamlit/components/v1/custom_component.py b/lib/streamlit/components/v1/custom_component.py
index a56d748ca..1cad1b444 100644
--- a/lib/streamlit/components/v1/custom_component.py
+++ b/lib/streamlit/components/v1/custom_component.py
@@ -180,7 +180,7 @@ And if you're using Streamlit Cloud, add "pyarrow" to your requirements.txt."""
                     key=key,
                     json_args=serialized_json_args,
                     special_args=special_args,
-                    page=ctx.page_script_hash if ctx else None,
+                    page=ctx.active_script_hash if ctx else None,
                 )
             else:
                 computed_id = compute_widget_id(
@@ -190,7 +190,7 @@ And if you're using Streamlit Cloud, add "pyarrow" to your requirements.txt."""
                     form_id=current_form_id(dg),
                     url=self.url,
                     key=key,
-                    page=ctx.page_script_hash if ctx else None,
+                    page=ctx.active_script_hash if ctx else None,
                 )
             element.component_instance.id = computed_id
 
diff --git a/lib/streamlit/elements/media.py b/lib/streamlit/elements/media.py
index bac054ec2..2e8286a9d 100644
--- a/lib/streamlit/elements/media.py
+++ b/lib/streamlit/elements/media.py
@@ -576,7 +576,7 @@ def marshall_video(
             loop=loop,
             autoplay=autoplay,
             muted=muted,
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         proto.id = id
@@ -752,6 +752,6 @@ def marshall_audio(
             end_time=end_time,
             loop=loop,
             autoplay=autoplay,
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
         proto.id = id
diff --git a/lib/streamlit/elements/plotly_chart.py b/lib/streamlit/elements/plotly_chart.py
index 480ea14f7..bdec20416 100644
--- a/lib/streamlit/elements/plotly_chart.py
+++ b/lib/streamlit/elements/plotly_chart.py
@@ -509,7 +509,7 @@ class PlotlyMixin:
             theme=theme,
             form_id=plotly_chart_proto.form_id,
             use_container_width=use_container_width,
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         if is_selection_activated:
diff --git a/lib/streamlit/elements/widgets/button.py b/lib/streamlit/elements/widgets/button.py
index 3d8049f0d..138b0a4b8 100644
--- a/lib/streamlit/elements/widgets/button.py
+++ b/lib/streamlit/elements/widgets/button.py
@@ -22,7 +22,7 @@ from typing import TYPE_CHECKING, BinaryIO, Final, Literal, TextIO, Union, cast
 
 from typing_extensions import TypeAlias
 
-from streamlit import runtime, source_util
+from streamlit import runtime
 from streamlit.elements.form import current_form_id, is_in_form
 from streamlit.elements.lib.policies import (
     check_cache_replay_rules,
@@ -31,6 +31,7 @@ from streamlit.elements.lib.policies import (
 )
 from streamlit.errors import StreamlitAPIException
 from streamlit.file_util import get_main_script_directory, normalize_path_join
+from streamlit.navigation.page import StreamlitPage
 from streamlit.proto.Button_pb2 import Button as ButtonProto
 from streamlit.proto.DownloadButton_pb2 import DownloadButton as DownloadButtonProto
 from streamlit.proto.LinkButton_pb2 import LinkButton as LinkButtonProto
@@ -46,6 +47,7 @@ from streamlit.runtime.state import (
 from streamlit.runtime.state.common import compute_widget_id, save_for_app_testing
 from streamlit.string_util import validate_icon_or_emoji
 from streamlit.type_util import Key, to_key
+from streamlit.url_util import is_url
 
 if TYPE_CHECKING:
     from streamlit.delta_generator import DeltaGenerator
@@ -443,7 +445,7 @@ class ButtonMixin:
     @gather_metrics("page_link")
     def page_link(
         self,
-        page: str,
+        page: str | StreamlitPage,
         *,
         label: str | None = None,
         icon: str | None = None,
@@ -463,10 +465,10 @@ class ButtonMixin:
 
         Parameters
         ----------
-        page : str
-            The file path (relative to the main script) of the page to switch to.
-            Alternatively, this can be the URL to an external page (must start
-            with "http://" or "https://").
+        page : str or st.Page
+            The file path (relative to the main script) or an st.Page indicating
+            the page to switch to. Alternatively, this can be the URL to an
+            external page (must start with "http://" or "https://").
         label : str
             The label for the page link. Labels are required for external pages.
             Labels can optionally contain Markdown and supports the following
@@ -593,7 +595,7 @@ class ButtonMixin:
             help=help,
             type=type,
             use_container_width=use_container_width,
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         if is_in_form(self.dg):
@@ -656,7 +658,7 @@ class ButtonMixin:
 
     def _page_link(
         self,
-        page: str,
+        page: str | StreamlitPage,
         *,  # keyword-only arguments:
         label: str | None = None,
         icon: str | None = None,
@@ -679,38 +681,45 @@ class ButtonMixin:
         if use_container_width is not None:
             page_link_proto.use_container_width = use_container_width
 
-        # Handle external links:
-        if page.startswith("http://") or page.startswith("https://"):
-            if label is None or label == "":
-                raise StreamlitAPIException(
-                    f"The label param is required for external links used with st.page_link - please provide a label."
-                )
-            else:
-                page_link_proto.page = page
-                page_link_proto.external = True
-                return self.dg._enqueue("page_link", page_link_proto)
-
-        ctx = get_script_run_ctx()
-        ctx_main_script = ""
-        if ctx:
-            ctx_main_script = ctx.main_script_path
+        if isinstance(page, StreamlitPage):
+            page_link_proto.page_script_hash = page._script_hash
+            page_link_proto.page = page.url_path
+            if label is None:
+                page_link_proto.label = page.title
+        else:
+            # Handle external links:
+            if is_url(page):
+                if label is None or label == "":
+                    raise StreamlitAPIException(
+                        "The label param is required for external links used with st.page_link - please provide a label."
+                    )
+                else:
+                    page_link_proto.page = page
+                    page_link_proto.external = True
+                    return self.dg._enqueue("page_link", page_link_proto)
+
+            ctx = get_script_run_ctx()
+            ctx_main_script = ""
+            all_app_pages = {}
+            if ctx:
+                ctx_main_script = ctx.main_script_path
+                all_app_pages = ctx.pages_manager.get_pages()
+
+            main_script_directory = get_main_script_directory(ctx_main_script)
+            requested_page = os.path.realpath(
+                normalize_path_join(main_script_directory, page)
+            )
 
-        main_script_directory = get_main_script_directory(ctx_main_script)
-        requested_page = os.path.realpath(
-            normalize_path_join(main_script_directory, page)
-        )
-        all_app_pages = source_util.get_pages(ctx_main_script).values()
-
-        # Handle retrieving the page_script_hash & page
-        for page_data in all_app_pages:
-            full_path = page_data["script_path"]
-            page_name = page_data["page_name"]
-            if requested_page == full_path:
-                if label is None:
-                    page_link_proto.label = page_name.replace("_", " ")
-                page_link_proto.page_script_hash = page_data["page_script_hash"]
-                page_link_proto.page = page_name
-                break
+            # Handle retrieving the page_script_hash & page
+            for page_data in all_app_pages.values():
+                full_path = page_data["script_path"]
+                page_name = page_data["page_name"]
+                if requested_page == full_path:
+                    if label is None:
+                        page_link_proto.label = page_name.replace("_", " ")
+                    page_link_proto.page_script_hash = page_data["page_script_hash"]
+                    page_link_proto.page = page_name
+                    break
 
         if page_link_proto.page_script_hash == "":
             raise StreamlitAPIException(
@@ -750,7 +759,7 @@ class ButtonMixin:
             is_form_submitter=is_form_submitter,
             type=type,
             use_container_width=use_container_width,
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         # It doesn't make sense to create a button inside a form (except
diff --git a/lib/streamlit/elements/widgets/camera_input.py b/lib/streamlit/elements/widgets/camera_input.py
index 148b0d21d..85753a63b 100644
--- a/lib/streamlit/elements/widgets/camera_input.py
+++ b/lib/streamlit/elements/widgets/camera_input.py
@@ -212,7 +212,7 @@ class CameraInputMixin:
             key=key,
             help=help,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         camera_input_proto = CameraInputProto()
diff --git a/lib/streamlit/elements/widgets/chat.py b/lib/streamlit/elements/widgets/chat.py
index 6d28d4c03..c089a8f9a 100644
--- a/lib/streamlit/elements/widgets/chat.py
+++ b/lib/streamlit/elements/widgets/chat.py
@@ -328,7 +328,7 @@ class ChatMixin:
             key=key,
             placeholder=placeholder,
             max_chars=max_chars,
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         # It doesn't make sense to create a chat input inside a form.
diff --git a/lib/streamlit/elements/widgets/checkbox.py b/lib/streamlit/elements/widgets/checkbox.py
index d31c53c7e..94407bb26 100644
--- a/lib/streamlit/elements/widgets/checkbox.py
+++ b/lib/streamlit/elements/widgets/checkbox.py
@@ -297,7 +297,7 @@ class CheckboxMixin:
             key=key,
             help=help,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         checkbox_proto = CheckboxProto()
diff --git a/lib/streamlit/elements/widgets/color_picker.py b/lib/streamlit/elements/widgets/color_picker.py
index b792f472b..feb9b6278 100644
--- a/lib/streamlit/elements/widgets/color_picker.py
+++ b/lib/streamlit/elements/widgets/color_picker.py
@@ -187,7 +187,7 @@ class ColorPickerMixin:
             key=key,
             help=help,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         # set value default
diff --git a/lib/streamlit/elements/widgets/data_editor.py b/lib/streamlit/elements/widgets/data_editor.py
index 236f33823..7197d272b 100644
--- a/lib/streamlit/elements/widgets/data_editor.py
+++ b/lib/streamlit/elements/widgets/data_editor.py
@@ -883,7 +883,7 @@ class DataEditorMixin:
             num_rows=num_rows,
             key=key,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         proto = ArrowProto()
diff --git a/lib/streamlit/elements/widgets/file_uploader.py b/lib/streamlit/elements/widgets/file_uploader.py
index 995341956..5f77d4b51 100644
--- a/lib/streamlit/elements/widgets/file_uploader.py
+++ b/lib/streamlit/elements/widgets/file_uploader.py
@@ -417,7 +417,7 @@ class FileUploaderMixin:
             key=key,
             help=help,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         if type:
diff --git a/lib/streamlit/elements/widgets/multiselect.py b/lib/streamlit/elements/widgets/multiselect.py
index 12c8f0e2d..c4fc3e026 100644
--- a/lib/streamlit/elements/widgets/multiselect.py
+++ b/lib/streamlit/elements/widgets/multiselect.py
@@ -314,7 +314,7 @@ class MultiSelectMixin:
             max_selections=max_selections,
             placeholder=placeholder,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         default_value: list[int] = [] if indices is None else indices
diff --git a/lib/streamlit/elements/widgets/number_input.py b/lib/streamlit/elements/widgets/number_input.py
index e60221eb5..bc619cf66 100644
--- a/lib/streamlit/elements/widgets/number_input.py
+++ b/lib/streamlit/elements/widgets/number_input.py
@@ -303,7 +303,7 @@ class NumberInputMixin:
             help=help,
             placeholder=None if placeholder is None else str(placeholder),
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         # Ensure that all arguments are of the same type.
diff --git a/lib/streamlit/elements/widgets/radio.py b/lib/streamlit/elements/widgets/radio.py
index 130704bdc..941914b70 100644
--- a/lib/streamlit/elements/widgets/radio.py
+++ b/lib/streamlit/elements/widgets/radio.py
@@ -276,7 +276,7 @@ class RadioMixin:
             horizontal=horizontal,
             captions=captions,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         if not isinstance(index, int) and index is not None:
diff --git a/lib/streamlit/elements/widgets/select_slider.py b/lib/streamlit/elements/widgets/select_slider.py
index 240acbac1..ec84d86d7 100644
--- a/lib/streamlit/elements/widgets/select_slider.py
+++ b/lib/streamlit/elements/widgets/select_slider.py
@@ -303,7 +303,7 @@ class SelectSliderMixin:
             key=key,
             help=help,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         slider_proto = SliderProto()
diff --git a/lib/streamlit/elements/widgets/selectbox.py b/lib/streamlit/elements/widgets/selectbox.py
index 82e6d47d8..b5d8eea77 100644
--- a/lib/streamlit/elements/widgets/selectbox.py
+++ b/lib/streamlit/elements/widgets/selectbox.py
@@ -255,7 +255,7 @@ class SelectboxMixin:
             help=help,
             placeholder=placeholder,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         if not isinstance(index, int) and index is not None:
diff --git a/lib/streamlit/elements/widgets/slider.py b/lib/streamlit/elements/widgets/slider.py
index 86e667070..181ce9a3a 100644
--- a/lib/streamlit/elements/widgets/slider.py
+++ b/lib/streamlit/elements/widgets/slider.py
@@ -386,7 +386,7 @@ class SliderMixin:
             key=key,
             help=help,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         SUPPORTED_TYPES = {
diff --git a/lib/streamlit/elements/widgets/text_widgets.py b/lib/streamlit/elements/widgets/text_widgets.py
index edfd55bdc..b6e0831f4 100644
--- a/lib/streamlit/elements/widgets/text_widgets.py
+++ b/lib/streamlit/elements/widgets/text_widgets.py
@@ -279,7 +279,7 @@ class TextWidgetsMixin:
             autocomplete=autocomplete,
             placeholder=str(placeholder),
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         session_state = get_session_state().filtered_state
@@ -546,7 +546,7 @@ class TextWidgetsMixin:
             help=help,
             placeholder=str(placeholder),
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
 
         session_state = get_session_state().filtered_state
diff --git a/lib/streamlit/elements/widgets/time_widgets.py b/lib/streamlit/elements/widgets/time_widgets.py
index 0e7e38e9d..a770f3c41 100644
--- a/lib/streamlit/elements/widgets/time_widgets.py
+++ b/lib/streamlit/elements/widgets/time_widgets.py
@@ -458,7 +458,7 @@ class TimeWidgetsMixin:
             help=help,
             step=step,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
         del value
 
@@ -731,7 +731,7 @@ class TimeWidgetsMixin:
             help=help,
             format=format,
             form_id=current_form_id(self.dg),
-            page=ctx.page_script_hash if ctx else None,
+            page=ctx.active_script_hash if ctx else None,
         )
         if not bool(ALLOWED_DATE_FORMATS.match(format)):
             raise StreamlitAPIException(
diff --git a/lib/streamlit/navigation/__init__.py b/lib/streamlit/navigation/__init__.py
new file mode 100644
index 000000000..02b6b4014
--- /dev/null
+++ b/lib/streamlit/navigation/__init__.py
@@ -0,0 +1,13 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
diff --git a/lib/streamlit/navigation/page.py b/lib/streamlit/navigation/page.py
new file mode 100644
index 000000000..84623fd03
--- /dev/null
+++ b/lib/streamlit/navigation/page.py
@@ -0,0 +1,197 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from __future__ import annotations
+
+import types
+from pathlib import Path
+from typing import Callable
+
+from streamlit.errors import StreamlitAPIException
+from streamlit.runtime.metrics_util import gather_metrics
+from streamlit.runtime.scriptrunner.script_run_context import get_script_run_ctx
+from streamlit.source_util import page_icon_and_name
+from streamlit.string_util import validate_icon_or_emoji
+from streamlit.util import calc_md5
+
+
+@gather_metrics("Page")
+def Page(
+    page: str | Path | Callable[[], None],
+    *,
+    title: str | None = None,
+    icon: str | None = None,
+    url_path: str | None = None,
+    default: bool = False,
+):
+    """Configure a page inÂ `st.navigation` in a multipage app.
+
+    The Page object is passed to `st.navigation` and returned when the user
+    navigates to that page. Call `Page.run()` on the returned Page in your
+    main script to execute the page code.
+
+    Page code can be specified by file path of the page (relative to the main
+    script) or by passing a Callable such as a function.
+
+    Parameters
+    ----------
+
+    page: str or Path or callable
+        The path to the script file or a callable that defines the page.
+        The path must be relative to the main script.
+
+    title: str or None
+        The title of the page. If None, the title will be inferred from the
+        page path or callable name.
+
+    icon: str or None
+        An optional emoji or icon to display next to the alert. If ``icon``
+        is ``None`` (default), no icon is displayed. If ``icon`` is a
+        string, the following options are valid:
+
+        * A single-character emoji. For example, you can set ``icon="ðŸš¨"``
+            or ``icon="ðŸ”¥"``. Emoji short codes are not supported.
+
+        * An icon from the Material Symbols library (outlined style) in the
+            format ``":material/icon_name:"`` where "icon_name" is the name
+            of the icon in snake case.
+
+            For example, ``icon=":material/thumb_up:"`` will display the
+            Thumb Up icon. Find additional icons in the `Material Symbols \
+            <https://fonts.google.com/icons?icon.set=Material+Symbols&icon.style=Outlined>`_
+            font library.
+
+    url_path: str or None
+        The URL pathname associated with a page. If None, the URL pathname will be
+        inferred from the file name, callable name. The default page will have
+        a url_path of "" to indicate the root url and ignore the value of url_path
+
+    default: bool
+        Whether this page is the default page to be shown when the app is
+        loaded. Only one page can be marked default. If no default page is
+        provided, the first page will be the default page.
+
+    Example
+    -------
+    >>> import streamlit as st
+    >>>
+    >>> def page2():
+    >>>     st.title("Second page")
+    >>> pg = st.navigation([
+    >>>	    st.Page("page1.py", title="First page", icon="ðŸ”¥"),
+    >>>	    st.Page(page2, title="Second page", icon=":material/favorite:"),
+    >>> ])
+    >>> pg.run()
+    """
+    return StreamlitPage(
+        page, title=title, icon=icon, url_path=url_path, default=default
+    )
+
+
+class StreamlitPage:
+    def __init__(
+        self,
+        page: str | Path | Callable[[], None],
+        *,
+        title: str | None = None,
+        icon: str | None = None,
+        url_path: str | None = None,
+        default: bool = False,
+    ):
+        ctx = get_script_run_ctx()
+        if not ctx:
+            return
+
+        main_path = Path(ctx.pages_manager.main_script_path).parent
+        if isinstance(page, str):
+            page = Path(page)
+        if isinstance(page, Path):
+            page = (main_path / page).resolve()
+
+        inferred_name = ""
+        inferred_icon = ""
+        if isinstance(page, Path):
+            inferred_icon, inferred_name = page_icon_and_name(page)
+        elif hasattr(page, "__name__"):
+            inferred_name = str(page.__name__)
+        elif title is None:
+            # At this point, we know the page is not a string or a path, so it
+            # must be a callable. We expect it to have a __name__ attribute,
+            # but in special cases (e.g. a callable class instance), one may
+            # not exist. In that case, we should inform the user the title is
+            # mandatory.
+            raise StreamlitAPIException(
+                "Cannot infer page title for Callable. Set the `title=` keyword argument."
+            )
+
+        self._page: Path | Callable[[], None] = page
+        self._title: str = title or inferred_name.replace("_", " ")
+        self._icon: str = icon or inferred_icon
+        if url_path is not None and url_path.strip() == "" and not default:
+            raise StreamlitAPIException(
+                "The URL path cannot be an empty string unless the page is the default page."
+            )
+
+        self._url_path: str = inferred_name
+        if url_path is not None:
+            self._url_path = url_path.lstrip("/")
+
+        if self._icon:
+            validate_icon_or_emoji(self._icon)
+
+        self._default: bool = default
+        # used by st.navigation to ordain a page as runnable
+        self._can_be_called: bool = False
+
+    @property
+    def title(self) -> str:
+        return self._title
+
+    @property
+    def icon(self) -> str:
+        return self._icon
+
+    @property
+    def url_path(self) -> str:
+        return "" if self._default else self._url_path
+
+    def run(self) -> None:
+        if not self._can_be_called:
+            raise StreamlitAPIException(
+                "This page cannot be called directly. Only the page returned from st.navigation can be called once."
+            )
+
+        self._can_be_called = False
+
+        ctx = get_script_run_ctx()
+        if not ctx:
+            return
+
+        with ctx.pages_manager.run_with_active_hash(self._script_hash):
+            if callable(self._page):
+                self._page()
+                return
+            else:
+                code = ctx.pages_manager.get_page_script_byte_code(str(self._page))
+
+                # We create a module named __page__ for this specific
+                # script. This is differentiate it from the `__main__` module
+                module = types.ModuleType("__page__")
+                # We want __file__ to be the path to the script
+                module.__dict__["__file__"] = self._page
+                exec(code, module.__dict__)
+
+    @property
+    def _script_hash(self) -> str:
+        return calc_md5(self._url_path)
diff --git a/lib/streamlit/runtime/app_session.py b/lib/streamlit/runtime/app_session.py
index 06d18bc66..3dee8b999 100644
--- a/lib/streamlit/runtime/app_session.py
+++ b/lib/streamlit/runtime/app_session.py
@@ -21,7 +21,7 @@ from enum import Enum
 from typing import TYPE_CHECKING, Callable, Final
 
 import streamlit.elements.exception as exception_utils
-from streamlit import config, runtime, source_util
+from streamlit import config, runtime
 from streamlit.case_converters import to_snake_case
 from streamlit.logger import get_logger
 from streamlit.proto.BackMsg_pb2 import BackMsg
@@ -40,11 +40,13 @@ from streamlit.runtime import caching
 from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
 from streamlit.runtime.fragment import FragmentStorage, MemoryFragmentStorage
 from streamlit.runtime.metrics_util import Installation
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.script_data import ScriptData
 from streamlit.runtime.scriptrunner import RerunData, ScriptRunner, ScriptRunnerEvent
 from streamlit.runtime.scriptrunner.script_cache import ScriptCache
 from streamlit.runtime.secrets import secrets_singleton
 from streamlit.runtime.uploaded_file_manager import UploadedFileManager
+from streamlit.source_util import PageHash, PageInfo
 from streamlit.version import STREAMLIT_VERSION_STRING
 from streamlit.watcher import LocalSourcesWatcher
 
@@ -127,6 +129,9 @@ class AppSession:
         self._script_data = script_data
         self._uploaded_file_mgr = uploaded_file_manager
         self._script_cache = script_cache
+        self._pages_manager = PagesManager(
+            script_data.main_script_path, self._script_cache
+        )
 
         # The browser queue contains messages that haven't yet been
         # delivered to the browser. Periodically, the server flushes
@@ -182,9 +187,7 @@ class AppSession:
         to.
         """
         if self._local_sources_watcher is None:
-            self._local_sources_watcher = LocalSourcesWatcher(
-                self._script_data.main_script_path
-            )
+            self._local_sources_watcher = LocalSourcesWatcher(self._pages_manager)
 
         self._local_sources_watcher.register_file_change_callback(
             self._on_source_file_changed
@@ -192,7 +195,7 @@ class AppSession:
         self._stop_config_listener = config.on_config_parsed(
             self._on_source_file_changed, force_connect=True
         )
-        self._stop_pages_listener = source_util.register_pages_changed_callback(
+        self._stop_pages_listener = self._pages_manager.register_pages_changed_callback(
             self._on_pages_changed
         )
         secrets_singleton.file_change_listener.connect(self._on_secrets_file_changed)
@@ -408,6 +411,7 @@ class AppSession:
             initial_rerun_data=initial_rerun_data,
             user_info=self._user_info,
             fragment_storage=self._fragment_storage,
+            pages_manager=self._pages_manager,
         )
         self._scriptrunner.on_event.connect(self._on_scriptrunner_event)
         self._scriptrunner.start()
@@ -417,8 +421,7 @@ class AppSession:
         return self._session_state
 
     def _should_rerun_on_file_change(self, filepath: str) -> bool:
-        main_script_path = self._script_data.main_script_path
-        pages = source_util.get_pages(main_script_path)
+        pages = self._pages_manager.get_pages()
 
         changed_page_script_hash = next(
             filter(lambda k: pages[k]["script_path"] == filepath, pages),
@@ -455,7 +458,7 @@ class AppSession:
 
     def _on_pages_changed(self, _) -> None:
         msg = ForwardMsg()
-        _populate_app_pages(msg.pages_changed, self._script_data.main_script_path)
+        self._populate_app_pages(msg.pages_changed, self._pages_manager.get_pages())
         self._enqueue_forward_msg(msg)
 
         if self._local_sources_watcher is not None:
@@ -473,6 +476,7 @@ class AppSession:
         client_state: ClientState | None = None,
         page_script_hash: str | None = None,
         fragment_ids_this_run: set[str] | None = None,
+        pages: dict[PageHash, PageInfo] | None = None,
     ) -> None:
         """Called when our ScriptRunner emits an event.
 
@@ -489,6 +493,7 @@ class AppSession:
                 client_state,
                 page_script_hash,
                 fragment_ids_this_run,
+                pages,
             )
         )
 
@@ -501,6 +506,7 @@ class AppSession:
         client_state: ClientState | None = None,
         page_script_hash: str | None = None,
         fragment_ids_this_run: set[str] | None = None,
+        pages: dict[PageHash, PageInfo] | None = None,
     ) -> None:
         """Handle a ScriptRunner event.
 
@@ -572,7 +578,7 @@ class AppSession:
 
             self._enqueue_forward_msg(
                 self._create_new_session_message(
-                    page_script_hash, fragment_ids_this_run
+                    page_script_hash, fragment_ids_this_run, pages
                 )
             )
 
@@ -603,6 +609,7 @@ class AppSession:
                 # that change which modules should be watched.
                 if self._local_sources_watcher:
                     self._local_sources_watcher.update_watched_modules()
+                    self._local_sources_watcher.update_watched_pages()
             else:
                 # The script didn't complete successfully: send the exception
                 # to the frontend.
@@ -666,20 +673,26 @@ class AppSession:
         return msg
 
     def _create_new_session_message(
-        self, page_script_hash: str, fragment_ids_this_run: set[str] | None = None
+        self,
+        page_script_hash: str,
+        fragment_ids_this_run: set[str] | None = None,
+        pages: dict[PageHash, PageInfo] | None = None,
     ) -> ForwardMsg:
         """Create and return a new_session ForwardMsg."""
         msg = ForwardMsg()
 
         msg.new_session.script_run_id = _generate_scriptrun_id()
         msg.new_session.name = self._script_data.name
-        msg.new_session.main_script_path = self._script_data.main_script_path
+        msg.new_session.main_script_path = self._pages_manager.main_script_path
+        msg.new_session.main_script_hash = self._pages_manager.main_script_hash
         msg.new_session.page_script_hash = page_script_hash
 
         if fragment_ids_this_run:
             msg.new_session.fragment_ids_this_run.extend(fragment_ids_this_run)
 
-        _populate_app_pages(msg.new_session, self._script_data.main_script_path)
+        self._populate_app_pages(
+            msg.new_session, pages or self._pages_manager.get_pages()
+        )
         _populate_config_msg(msg.new_session.config)
         _populate_theme_msg(msg.new_session.custom_theme)
 
@@ -829,6 +842,16 @@ class AppSession:
 
         self._enqueue_forward_msg(msg)
 
+    def _populate_app_pages(
+        self, msg: NewSession | PagesChanged, pages: dict[PageHash, PageInfo]
+    ) -> None:
+        for page_script_hash, page_info in pages.items():
+            page_proto = msg.app_pages.add()
+
+            page_proto.page_script_hash = page_script_hash
+            page_proto.page_name = page_info["page_name"]
+            page_proto.icon = page_info["icon"]
+
 
 # Config.ToolbarMode.ValueType does not exist at runtime (only in the pyi stubs), so
 # we need to use quotes.
@@ -913,12 +936,3 @@ def _populate_theme_msg(msg: CustomThemeConfig) -> None:
 def _populate_user_info_msg(msg: UserInfo) -> None:
     msg.installation_id = Installation.instance().installation_id
     msg.installation_id_v3 = Installation.instance().installation_id_v3
-
-
-def _populate_app_pages(msg: NewSession | PagesChanged, main_script_path: str) -> None:
-    for page_script_hash, page_info in source_util.get_pages(main_script_path).items():
-        page_proto = msg.app_pages.add()
-
-        page_proto.page_script_hash = page_script_hash
-        page_proto.page_name = page_info["page_name"]
-        page_proto.icon = page_info["icon"]
diff --git a/lib/streamlit/runtime/fragment.py b/lib/streamlit/runtime/fragment.py
index 5a41dbdf1..c098f429c 100644
--- a/lib/streamlit/runtime/fragment.py
+++ b/lib/streamlit/runtime/fragment.py
@@ -133,6 +133,10 @@ def _fragment(
         )
         fragment_id = h.hexdigest()
 
+        # We intentionally want to capture the active script hash here to ensure
+        # that the fragment is associated with the correct script running.
+        initialized_active_script_hash = ctx.active_script_hash
+
         def wrapped_fragment():
             import streamlit as st
 
@@ -157,8 +161,20 @@ def _fragment(
                 ctx.current_fragment_id = fragment_id
 
             try:
-                with st.container():
-                    result = non_optional_func(*args, **kwargs)
+                # Make sure we set the active script hash to the same value
+                # for the fragment run as when defined upon initialization
+                # This ensures that elements (especially widgets) are tied
+                # to a consistent active script hash
+                active_hash_context = (
+                    ctx.pages_manager.run_with_active_hash(
+                        initialized_active_script_hash
+                    )
+                    if initialized_active_script_hash != ctx.active_script_hash
+                    else contextlib.nullcontext()
+                )
+                with active_hash_context:
+                    with st.container():
+                        result = non_optional_func(*args, **kwargs)
             finally:
                 ctx.current_fragment_id = None
 
diff --git a/lib/streamlit/runtime/pages_manager.py b/lib/streamlit/runtime/pages_manager.py
new file mode 100644
index 000000000..92f31f4d8
--- /dev/null
+++ b/lib/streamlit/runtime/pages_manager.py
@@ -0,0 +1,354 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from __future__ import annotations
+
+import contextlib
+import os
+import threading
+from pathlib import Path
+from typing import TYPE_CHECKING, Any, Callable, Final, Type
+
+from streamlit import source_util
+from streamlit.logger import get_logger
+from streamlit.runtime.scriptrunner.script_cache import ScriptCache
+from streamlit.util import calc_md5
+from streamlit.watcher import watch_dir
+
+if TYPE_CHECKING:
+    from streamlit.source_util import PageHash, PageInfo, PageName, ScriptPath
+
+_LOGGER: Final = get_logger(__name__)
+
+
+class PagesStrategyV1:
+    """
+    Strategy for MPA v1. This strategy handles pages being set directly
+    by a call to `st.navigation`. The key differences here are:
+    - The pages are defined by the existence of a `pages` directory
+    - We will ensure one watcher is watching the scripts in the directory.
+    - Only one script runs for a full rerun.
+    - We know at the beginning the intended page script to run.
+
+    NOTE: Thread safety of the pages is handled by the source_util module
+    """
+
+    is_watching_pages_dir: bool = False
+    pages_watcher_lock = threading.Lock()
+
+    # This is a static method because we only want to watch the pages directory
+    # once on initial load.
+    @staticmethod
+    def watch_pages_dir(pages_manager: PagesManager):
+        with PagesStrategyV1.pages_watcher_lock:
+            if PagesStrategyV1.is_watching_pages_dir:
+                return
+
+            def _handle_page_changed(_path: str) -> None:
+                source_util.invalidate_pages_cache()
+
+            main_script_path = Path(pages_manager.main_script_path)
+            pages_dir = main_script_path.parent / "pages"
+            watch_dir(
+                str(pages_dir),
+                _handle_page_changed,
+                glob_pattern="*.py",
+                allow_nonexistent=True,
+            )
+            PagesStrategyV1.is_watching_pages_dir = True
+
+    def __init__(self, pages_manager: PagesManager, setup_watcher: bool = True):
+        self.pages_manager = pages_manager
+
+        if setup_watcher:
+            PagesStrategyV1.watch_pages_dir(pages_manager)
+
+    # In MPA v1, there's no difference between the active hash
+    # and the page script hash.
+    def get_active_script_hash(self) -> "PageHash":
+        return self.pages_manager.current_page_hash
+
+    def set_active_script_hash(self, _page_hash: "PageHash"):
+        # Intentionally do nothing as MPA v1 active_script_hash does not
+        # differentiate the active_script_hash and the page_script_hash
+        pass
+
+    def get_initial_active_script(
+        self, page_script_hash: "PageHash", page_name: "PageName"
+    ) -> "PageInfo" | None:
+        pages = self.get_pages()
+
+        if page_script_hash:
+            return pages.get(page_script_hash, None)
+        elif not page_script_hash and page_name:
+            # If a user navigates directly to a non-main page of an app, we get
+            # the first script run request before the list of pages has been
+            # sent to the frontend. In this case, we choose the first script
+            # with a name matching the requested page name.
+            return next(
+                filter(
+                    # There seems to be this weird bug with mypy where it
+                    # thinks that p can be None (which is impossible given the
+                    # types of pages), so we add `p and` at the beginning of
+                    # the predicate to circumvent this.
+                    lambda p: p and (p["page_name"] == page_name),
+                    pages.values(),
+                ),
+                None,
+            )
+
+        # If no information about what page to run is given, default to
+        # running the main page.
+        # Safe because pages will at least contain the app's main page.
+        main_page_info = list(pages.values())[0]
+        return main_page_info
+
+    def get_pages(self) -> dict["PageHash", "PageInfo"]:
+        return source_util.get_pages(self.pages_manager.main_script_path)
+
+    def register_pages_changed_callback(
+        self,
+        callback: Callable[[str], None],
+    ) -> Callable[[], None]:
+        return source_util.register_pages_changed_callback(callback)
+
+    def set_pages(self, _pages: dict["PageHash", "PageInfo"]) -> None:
+        raise NotImplementedError("Unable to set pages in this V1 strategy")
+
+    def get_page_script(self, _fallback_page_hash: "PageHash") -> "PageInfo" | None:
+        raise NotImplementedError("Unable to get page script in this V1 strategy")
+
+
+class PagesStrategyV2:
+    """
+    Strategy for MPA v2. This strategy handles pages being set directly
+    by a call to `st.navigation`. The key differences here are:
+    - The pages are set directly by the user
+    - The initial active script will always be the main script
+    - More than one script can run in a single app run (sequentially),
+      so we must keep track of the active script hash
+    - We rely on pages manager to retrieve the intended page script per run
+
+    NOTE: We don't provide any locks on the pages since the pages are not
+    shared across sessions. Only the user script thread can write to
+    pages and the event loop thread only reads
+    """
+
+    def __init__(self, pages_manager: PagesManager, **kwargs):
+        self.pages_manager = pages_manager
+        self._active_script_hash: "PageHash" = self.pages_manager.main_script_hash
+        self._pages: dict["PageHash", "PageInfo"] | None = None
+
+    def get_active_script_hash(self) -> "PageHash":
+        return self._active_script_hash
+
+    def set_active_script_hash(self, page_hash: "PageHash"):
+        self._active_script_hash = page_hash
+
+    def get_initial_active_script(
+        self, page_script_hash: "PageHash", page_name: "PageName"
+    ) -> "PageInfo":
+        return {
+            # We always run the main script in V2 as it's the common code
+            "script_path": self.pages_manager.main_script_path,
+            "page_script_hash": page_script_hash
+            or self.pages_manager.main_script_hash,  # Default Hash
+        }
+
+    def get_page_script(self, fallback_page_hash: "PageHash") -> "PageInfo" | None:
+        if self._pages is None:
+            return None
+
+        if self.pages_manager.intended_page_script_hash:
+            # We assume that if initial page hash is specified, that a page should
+            # exist, so we check out the page script hash or the default page hash
+            # as a backup
+            return self._pages.get(
+                self.pages_manager.intended_page_script_hash,
+                self._pages.get(fallback_page_hash, None),
+            )
+        elif self.pages_manager.intended_page_name:
+            # If a user navigates directly to a non-main page of an app, the
+            # the page name can identify the page script to run
+            return next(
+                filter(
+                    # There seems to be this weird bug with mypy where it
+                    # thinks that p can be None (which is impossible given the
+                    # types of pages), so we add `p and` at the beginning of
+                    # the predicate to circumvent this.
+                    lambda p: p
+                    and (p["url_pathname"] == self.pages_manager.intended_page_name),
+                    self._pages.values(),
+                ),
+                None,
+            )
+
+        return self._pages.get(fallback_page_hash, None)
+
+    def get_pages(self) -> dict["PageHash", "PageInfo"]:
+        # If pages are not set, provide the common page info where
+        # - the main script path is the executing script to start
+        # - the page script hash and name reflects the intended page requested
+        return self._pages or {
+            self.pages_manager.main_script_hash: {
+                "page_script_hash": self.pages_manager.intended_page_script_hash or "",
+                "page_name": self.pages_manager.intended_page_name or "",
+                "icon": "",
+                "script_path": self.pages_manager.main_script_path,
+            }
+        }
+
+    def set_pages(self, pages: dict["PageHash", "PageInfo"]) -> None:
+        self._pages = pages
+
+    def register_pages_changed_callback(
+        self,
+        callback: Callable[[str], None],
+    ) -> Callable[[], None]:
+        # V2 strategy does not handle any pages changed event
+        return lambda: None
+
+
+class PagesManager:
+    """
+    PagesManager is responsible for managing the set of pages based on the
+    strategy. By default, PagesManager uses V1 which relies on the original
+    assumption that there exists a `pages` directory with all the scripts.
+
+    If the `pages` are being set directly, the strategy is switched to V2.
+    This indicates someone has written an `st.navigation` call in their app
+    which informs us of the pages.
+
+    NOTE: Each strategy handles its own thread safety when accessing the pages
+    """
+
+    DefaultStrategy: Type[PagesStrategyV1 | PagesStrategyV2] = PagesStrategyV1
+
+    def __init__(
+        self,
+        main_script_path: "ScriptPath",
+        script_cache: ScriptCache | None = None,
+        **kwargs,
+    ):
+        self._main_script_path = main_script_path
+        self._main_script_hash: "PageHash" = calc_md5(main_script_path)
+        self._current_page_hash: "PageHash" = self._main_script_hash
+        self.pages_strategy = PagesManager.DefaultStrategy(self, **kwargs)
+        self._script_cache = script_cache
+        self._intended_page_script_hash: "PageHash" | None = None
+        self._intended_page_name: "PageName" | None = None
+
+    @property
+    def current_page_hash(self) -> "PageHash":
+        return self._current_page_hash
+
+    @property
+    def main_script_path(self) -> "ScriptPath":
+        return self._main_script_path
+
+    @property
+    def main_script_hash(self) -> "PageHash":
+        return self._main_script_hash
+
+    @property
+    def intended_page_name(self) -> "PageName" | None:
+        return self._intended_page_name
+
+    @property
+    def intended_page_script_hash(self) -> "PageHash" | None:
+        return self._intended_page_script_hash
+
+    def get_main_page(self) -> "PageInfo":
+        return {
+            "script_path": self._main_script_path,
+            "page_script_hash": self._main_script_hash,
+        }
+
+    def get_current_page_script_hash(self) -> "PageHash":
+        """Gets the script hash of the associated page of a script."""
+        return self._current_page_hash
+
+    def set_current_page_script_hash(self, page_hash: "PageHash") -> None:
+        self._current_page_hash = page_hash
+
+    def get_active_script_hash(self) -> "PageHash":
+        """Gets the script hash of the currently executing script."""
+        return self.pages_strategy.get_active_script_hash()
+
+    def set_active_script_hash(self, page_hash: "PageHash"):
+        return self.pages_strategy.set_active_script_hash(page_hash)
+
+    def set_script_intent(
+        self, page_script_hash: "PageHash", page_name: "PageName"
+    ) -> None:
+        self._intended_page_script_hash = page_script_hash
+        self._intended_page_name = page_name
+
+    def get_initial_active_script(
+        self, page_script_hash: "PageHash", page_name: "PageName"
+    ) -> "PageInfo" | None:
+        return self.pages_strategy.get_initial_active_script(
+            page_script_hash, page_name
+        )
+
+    @contextlib.contextmanager
+    def run_with_active_hash(self, page_hash: "PageHash"):
+        original_page_hash = self.get_active_script_hash()
+        self.set_active_script_hash(page_hash)
+        try:
+            yield
+        finally:
+            # in the event of any exception, ensure we set the active hash back
+            self.set_active_script_hash(original_page_hash)
+
+    def get_pages(self) -> dict["PageHash", "PageInfo"]:
+        return self.pages_strategy.get_pages()
+
+    def set_pages(self, pages: dict["PageHash", "PageInfo"]) -> None:
+        # Manually setting the pages indicates we are using MPA v2.
+        if isinstance(self.pages_strategy, PagesStrategyV1):
+            if os.path.exists(Path(self.main_script_path).parent / "pages"):
+                _LOGGER.warning(
+                    "st.navigation was called in an app with a pages/ directory. This may cause unusual app behavior. You may want to rename the pages/ directory."
+                )
+            PagesManager.DefaultStrategy = PagesStrategyV2
+            self.pages_strategy = PagesStrategyV2(self)
+
+        self.pages_strategy.set_pages(pages)
+
+    def get_page_script(self, fallback_page_hash: "PageHash" = "") -> "PageInfo" | None:
+        # We assume the pages strategy is V2 cause this is used
+        # in the st.navigation call, but we just swallow the error
+        try:
+            return self.pages_strategy.get_page_script(fallback_page_hash)
+        except NotImplementedError:
+            return None
+
+    def register_pages_changed_callback(
+        self,
+        callback: Callable[[str], None],
+    ) -> Callable[[], None]:
+        """Register a callback to be called when the set of pages changes.
+
+        The callback will be called with the path changed.
+        """
+
+        return self.pages_strategy.register_pages_changed_callback(callback)
+
+    def get_page_script_byte_code(self, script_path: str) -> Any:
+        if self._script_cache is None:
+            # Returning an empty string for an empty script
+            return ""
+
+        return self._script_cache.get_bytecode(script_path)
diff --git a/lib/streamlit/runtime/scriptrunner/script_run_context.py b/lib/streamlit/runtime/scriptrunner/script_run_context.py
index 7ea9a08b1..5df631052 100644
--- a/lib/streamlit/runtime/scriptrunner/script_run_context.py
+++ b/lib/streamlit/runtime/scriptrunner/script_run_context.py
@@ -33,6 +33,7 @@ from streamlit.runtime.uploaded_file_manager import UploadedFileManager
 
 if TYPE_CHECKING:
     from streamlit.runtime.fragment import FragmentStorage
+    from streamlit.runtime.pages_manager import PagesManager
 
 _LOGGER: Final = get_logger(__name__)
 
@@ -60,9 +61,9 @@ class ScriptRunContext:
     session_state: SafeSessionState
     uploaded_file_mgr: UploadedFileManager
     main_script_path: str
-    page_script_hash: str
     user_info: UserInfo
     fragment_storage: "FragmentStorage"
+    pages_manager: "PagesManager"
 
     gather_usage_stats: bool = False
     command_tracking_deactivated: bool = False
@@ -87,6 +88,14 @@ class ScriptRunContext:
     _experimental_query_params_used = False
     _production_query_params_used = False
 
+    @property
+    def page_script_hash(self):
+        return self.pages_manager.get_current_page_script_hash()
+
+    @property
+    def active_script_hash(self):
+        return self.pages_manager.get_active_script_hash()
+
     def reset(
         self,
         query_string: str = "",
@@ -98,7 +107,7 @@ class ScriptRunContext:
         self.widget_user_keys_this_run = set()
         self.form_ids_this_run = set()
         self.query_string = query_string
-        self.page_script_hash = page_script_hash
+        self.pages_manager.set_current_page_script_hash(page_script_hash)
         # Permit set_page_config when the ScriptRunContext is reused on a rerun
         self._set_page_config_allowed = True
         self._has_script_started = False
@@ -142,6 +151,8 @@ class ScriptRunContext:
         ):
             self._set_page_config_allowed = False
 
+        msg.metadata.active_script_hash = self.active_script_hash
+
         # Pass the message up to our associated ScriptRunner.
         self._enqueue(msg)
 
diff --git a/lib/streamlit/runtime/scriptrunner/script_runner.py b/lib/streamlit/runtime/scriptrunner/script_runner.py
index 88ed09140..dd17d69dd 100644
--- a/lib/streamlit/runtime/scriptrunner/script_runner.py
+++ b/lib/streamlit/runtime/scriptrunner/script_runner.py
@@ -52,6 +52,7 @@ from streamlit.vendor.ipython.modified_sys_path import modified_sys_path
 
 if TYPE_CHECKING:
     from streamlit.runtime.fragment import FragmentStorage
+    from streamlit.runtime.pages_manager import PagesManager
 
 _LOGGER: Final = get_logger(__name__)
 
@@ -115,6 +116,7 @@ class ScriptRunner:
         initial_rerun_data: RerunData,
         user_info: dict[str, str | None],
         fragment_storage: "FragmentStorage",
+        pages_manager: "PagesManager",
     ):
         """Initialize the ScriptRunner.
 
@@ -164,6 +166,7 @@ class ScriptRunner:
         self._user_info = user_info
         self._fragment_storage = fragment_storage
 
+        self._pages_manager = pages_manager
         self._requests = ScriptRequests()
         self._requests.request_rerun(initial_rerun_data)
 
@@ -291,10 +294,10 @@ class ScriptRunner:
             session_state=self._session_state,
             uploaded_file_mgr=self._uploaded_file_mgr,
             main_script_path=self._main_script_path,
-            page_script_hash="",
             user_info=self._user_info,
             gather_usage_stats=bool(config.get_option("browser.gatherUsageStats")),
             fragment_storage=self._fragment_storage,
+            pages_manager=self._pages_manager,
         )
         add_script_run_ctx(threading.current_thread(), ctx)
 
@@ -426,39 +429,18 @@ class ScriptRunner:
             # Reset DeltaGenerators, widgets, media files.
             runtime.get_instance().media_file_mgr.clear_session_refs()
 
-            main_script_path = self._main_script_path
-            pages = source_util.get_pages(main_script_path)
-            # Safe because pages will at least contain the app's main page.
-            main_page_info = list(pages.values())[0]
-            current_page_info = None
+            self._pages_manager.set_script_intent(
+                rerun_data.page_script_hash, rerun_data.page_name
+            )
+            active_script = self._pages_manager.get_initial_active_script(
+                rerun_data.page_script_hash, rerun_data.page_name
+            )
+            main_page_info = self._pages_manager.get_main_page()
             uncaught_exception = None
 
-            if rerun_data.page_script_hash:
-                current_page_info = pages.get(rerun_data.page_script_hash, None)
-            elif not rerun_data.page_script_hash and rerun_data.page_name:
-                # If a user navigates directly to a non-main page of an app, we get
-                # the first script run request before the list of pages has been
-                # sent to the frontend. In this case, we choose the first script
-                # with a name matching the requested page name.
-                current_page_info = next(
-                    filter(
-                        # There seems to be this weird bug with mypy where it
-                        # thinks that p can be None (which is impossible given the
-                        # types of pages), so we add `p and` at the beginning of
-                        # the predicate to circumvent this.
-                        lambda p: p and (p["page_name"] == rerun_data.page_name),
-                        pages.values(),
-                    ),
-                    None,
-                )
-            else:
-                # If no information about what page to run is given, default to
-                # running the main page.
-                current_page_info = main_page_info
-
             page_script_hash = (
-                current_page_info["page_script_hash"]
-                if current_page_info is not None
+                active_script["page_script_hash"]
+                if active_script is not None
                 else main_page_info["page_script_hash"]
             )
 
@@ -488,16 +470,18 @@ class ScriptRunner:
                 event=ScriptRunnerEvent.SCRIPT_STARTED,
                 page_script_hash=page_script_hash,
                 fragment_ids_this_run=fragment_ids_this_run,
+                pages=self._pages_manager.get_pages(),
             )
 
             # Compile the script. Any errors thrown here will be surfaced
             # to the user via a modal dialog in the frontend, and won't result
             # in their previous script elements disappearing.
             try:
-                if current_page_info:
-                    script_path = current_page_info["script_path"]
+                if active_script is not None:
+                    script_path = active_script["script_path"]
                 else:
-                    script_path = main_script_path
+                    # page must not be found
+                    script_path = main_page_info["script_path"]
 
                     # At this point, we know that either
                     #   * the script corresponding to the hash requested no longer
@@ -646,9 +630,11 @@ class ScriptRunner:
                                 ctx.tracked_commands,
                                 exec_time=to_microseconds(timer() - start_time),
                                 prep_time=to_microseconds(prep_time),
-                                uncaught_exception=type(uncaught_exception).__name__
-                                if uncaught_exception
-                                else None,
+                                uncaught_exception=(
+                                    type(uncaught_exception).__name__
+                                    if uncaught_exception
+                                    else None
+                                ),
                             )
                         )
                     except Exception as ex:
diff --git a/lib/streamlit/source_util.py b/lib/streamlit/source_util.py
index 298fd105b..fd88b13de 100644
--- a/lib/streamlit/source_util.py
+++ b/lib/streamlit/source_util.py
@@ -17,9 +17,10 @@ from __future__ import annotations
 import re
 import threading
 from pathlib import Path
-from typing import Any, Callable, Final, cast
+from typing import Any, Callable, Final, TypedDict, cast
 
 from blinker import Signal
+from typing_extensions import NotRequired, TypeAlias
 
 from streamlit.logger import get_logger
 from streamlit.string_util import extract_leading_emoji
@@ -27,6 +28,19 @@ from streamlit.util import calc_md5
 
 _LOGGER: Final = get_logger(__name__)
 
+PageHash: TypeAlias = str
+PageName: TypeAlias = str
+ScriptPath: TypeAlias = str
+Icon: TypeAlias = str
+
+
+class PageInfo(TypedDict):
+    script_path: ScriptPath
+    page_script_hash: PageHash
+    icon: NotRequired[Icon]
+    page_name: NotRequired[PageName]
+    url_pathname: NotRequired[str]
+
 
 def open_python_file(filename: str):
     """Open a read-only Python file taking proper care of its encoding.
@@ -91,7 +105,7 @@ def page_icon_and_name(script_path: Path) -> tuple[str, str]:
 
 
 _pages_cache_lock = threading.RLock()
-_cached_pages: dict[str, dict[str, str]] | None = None
+_cached_pages: dict[PageHash, PageInfo] | None = None
 _on_pages_changed = Signal(doc="Emitted when the pages directory is changed")
 
 
@@ -105,13 +119,13 @@ def invalidate_pages_cache() -> None:
     _on_pages_changed.send()
 
 
-def get_pages(main_script_path_str: str) -> dict[str, dict[str, str]]:
+def get_pages(main_script_path_str: ScriptPath) -> dict[PageHash, PageInfo]:
     global _cached_pages
 
     # Avoid taking the lock if the pages cache hasn't been invalidated.
-    pages = _cached_pages
-    if pages is not None:
-        return pages
+    precached_pages = _cached_pages
+    if precached_pages is not None:
+        return precached_pages
 
     with _pages_cache_lock:
         # The cache may have been repopulated while we were waiting to grab
@@ -121,14 +135,14 @@ def get_pages(main_script_path_str: str) -> dict[str, dict[str, str]]:
 
         main_script_path = Path(main_script_path_str)
         main_page_icon, main_page_name = page_icon_and_name(main_script_path)
-        main_page_script_hash = calc_md5(main_script_path_str)
+        main_script_hash = calc_md5(main_script_path_str)
 
-        # NOTE: We include the page_script_hash in the dict even though it is
+        # NOTE: We include the script_hash in the dict even though it is
         #       already used as the key because that occasionally makes things
         #       easier for us when we need to iterate over pages.
-        pages = {
-            main_page_script_hash: {
-                "page_script_hash": main_page_script_hash,
+        pages: dict[PageHash, PageInfo] = {
+            main_script_hash: {
+                "page_script_hash": main_script_hash,
                 "page_name": main_page_name,
                 "icon": main_page_icon,
                 "script_path": str(main_script_path.resolve()),
diff --git a/lib/streamlit/testing/v1/app_test.py b/lib/streamlit/testing/v1/app_test.py
index 5ec36daa4..f2df0d039 100644
--- a/lib/streamlit/testing/v1/app_test.py
+++ b/lib/streamlit/testing/v1/app_test.py
@@ -31,6 +31,7 @@ from streamlit.runtime.caching.storage.dummy_cache_storage import (
 )
 from streamlit.runtime.media_file_manager import MediaFileManager
 from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.secrets import Secrets
 from streamlit.runtime.state.common import TESTING_KEY
 from streamlit.runtime.state.safe_session_state import SafeSessionState
@@ -321,6 +322,7 @@ class AppTest:
         )
         mock_runtime.cache_storage_manager = MemoryCacheStorageManager()
         Runtime._instance = mock_runtime
+        pages_manager = PagesManager(self._script_path, setup_watcher=False)
         with source_util._pages_cache_lock:
             saved_cached_pages = source_util._cached_pages
             source_util._cached_pages = None
@@ -333,7 +335,11 @@ class AppTest:
             st.secrets = new_secrets
 
         script_runner = LocalScriptRunner(
-            self._script_path, self.session_state, args=self.args, kwargs=self.kwargs
+            self._script_path,
+            self.session_state,
+            pages_manager,
+            args=self.args,
+            kwargs=self.kwargs,
         )
         with patch_config_options({"global.appTest": True}):
             self._tree = script_runner.run(
diff --git a/lib/streamlit/testing/v1/local_script_runner.py b/lib/streamlit/testing/v1/local_script_runner.py
index 7a191c2d6..72efe6db4 100644
--- a/lib/streamlit/testing/v1/local_script_runner.py
+++ b/lib/streamlit/testing/v1/local_script_runner.py
@@ -16,7 +16,7 @@ from __future__ import annotations
 import os
 import time
 import types
-from typing import Any
+from typing import TYPE_CHECKING, Any
 from urllib import parse
 
 from streamlit import runtime
@@ -31,6 +31,9 @@ from streamlit.runtime.scriptrunner.script_run_context import ScriptRunContext
 from streamlit.runtime.state.safe_session_state import SafeSessionState
 from streamlit.testing.v1.element_tree import ElementTree, parse_tree_from_messages
 
+if TYPE_CHECKING:
+    from streamlit.runtime.pages_manager import PagesManager
+
 
 class LocalScriptRunner(ScriptRunner):
     """Subclasses ScriptRunner to provide some testing features."""
@@ -39,6 +42,7 @@ class LocalScriptRunner(ScriptRunner):
         self,
         script_path: str,
         session_state: SafeSessionState,
+        pages_manager: "PagesManager",
         args=None,
         kwargs=None,
     ):
@@ -61,6 +65,7 @@ class LocalScriptRunner(ScriptRunner):
             initial_rerun_data=RerunData(),
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=pages_manager,
         )
 
         # Accumulates all ScriptRunnerEvents emitted by us.
diff --git a/lib/streamlit/watcher/local_sources_watcher.py b/lib/streamlit/watcher/local_sources_watcher.py
index 45aad7a91..9927b1ab9 100644
--- a/lib/streamlit/watcher/local_sources_watcher.py
+++ b/lib/streamlit/watcher/local_sources_watcher.py
@@ -19,17 +19,19 @@ import os
 import sys
 import types
 from pathlib import Path
-from typing import Callable, Final
+from typing import TYPE_CHECKING, Callable, Final
 
 from streamlit import config, file_util
 from streamlit.folder_black_list import FolderBlackList
 from streamlit.logger import get_logger
-from streamlit.source_util import get_pages
 from streamlit.watcher.path_watcher import (
     NoOpPathWatcher,
     get_default_path_watcher_class,
 )
 
+if TYPE_CHECKING:
+    from streamlit.runtime.pages_manager import PagesManager
+
 _LOGGER: Final = get_logger(__name__)
 
 WatchedModule = collections.namedtuple("WatchedModule", ["watcher", "module_name"])
@@ -40,8 +42,9 @@ PathWatcher = None
 
 
 class LocalSourcesWatcher:
-    def __init__(self, main_script_path: str):
-        self._main_script_path = os.path.abspath(main_script_path)
+    def __init__(self, pages_manager: "PagesManager"):
+        self._pages_manager = pages_manager
+        self._main_script_path = os.path.abspath(self._pages_manager.main_script_path)
         self._script_folder = os.path.dirname(self._main_script_path)
         self._on_file_changed: list[Callable[[str], None]] = []
         self._is_closed = False
@@ -58,22 +61,29 @@ class LocalSourcesWatcher:
         self.update_watched_pages()
 
     def update_watched_pages(self) -> None:
-        old_watched_pages = self._watched_pages
+        old_page_paths = self._watched_pages.copy()
         new_pages_paths: set[str] = set()
 
-        for page_info in get_pages(self._main_script_path).values():
+        for page_info in self._pages_manager.get_pages().values():
+            if not page_info["script_path"]:
+                continue
+
             new_pages_paths.add(page_info["script_path"])
-            if page_info["script_path"] not in old_watched_pages:
+            if page_info["script_path"] not in self._watched_pages:
                 self._register_watcher(
                     page_info["script_path"],
                     module_name=None,
                 )
 
-        for old_page_path in old_watched_pages:
-            if old_page_path not in new_pages_paths:
+        for old_page_path in old_page_paths:
+            # Only remove pages that are no longer valid files
+            if old_page_path not in new_pages_paths and not os.path.isfile(
+                old_page_path
+            ):
                 self._deregister_watcher(old_page_path)
+                self._watched_pages.remove(old_page_path)
 
-        self._watched_pages = new_pages_paths
+        self._watched_pages = self._watched_pages.union(new_pages_paths)
 
     def register_file_change_callback(self, cb: Callable[[str], None]) -> None:
         self._on_file_changed.append(cb)
diff --git a/lib/streamlit/web/bootstrap.py b/lib/streamlit/web/bootstrap.py
index 410d137d7..e0b9d9ff0 100644
--- a/lib/streamlit/web/bootstrap.py
+++ b/lib/streamlit/web/bootstrap.py
@@ -18,7 +18,6 @@ import asyncio
 import os
 import signal
 import sys
-from pathlib import Path
 from typing import Any, Final
 
 from streamlit import (
@@ -34,8 +33,7 @@ from streamlit import (
 from streamlit.config import CONFIG_FILENAMES
 from streamlit.git_util import MIN_GIT_VERSION, GitRepo
 from streamlit.logger import get_logger
-from streamlit.source_util import invalidate_pages_cache
-from streamlit.watcher import report_watchdog_availability, watch_dir, watch_file
+from streamlit.watcher import report_watchdog_availability, watch_file
 from streamlit.web.server import Server, server_address_is_unix_socket, server_util
 
 _LOGGER: Final = get_logger(__name__)
@@ -348,21 +346,6 @@ def _install_config_watchers(flag_options: dict[str, Any]) -> None:
             watch_file(filename, on_config_changed)
 
 
-def _install_pages_watcher(main_script_path_str: str) -> None:
-    def _on_pages_changed(_path: str) -> None:
-        invalidate_pages_cache()
-
-    main_script_path = Path(main_script_path_str)
-    pages_dir = main_script_path.parent / "pages"
-
-    watch_dir(
-        str(pages_dir),
-        _on_pages_changed,
-        glob_pattern="*.py",
-        allow_nonexistent=True,
-    )
-
-
 def run(
     main_script_path: str,
     is_hello: bool,
@@ -379,7 +362,6 @@ def run(
     _fix_pydeck_mapbox_api_warning()
     _fix_pydantic_duplicate_validators_error()
     _install_config_watchers(flag_options)
-    _install_pages_watcher(main_script_path)
 
     # Create the server. It won't start running yet.
     server = Server(main_script_path, is_hello)
diff --git a/lib/streamlit/web/server/routes.py b/lib/streamlit/web/server/routes.py
index 1c22e4ac3..fda55eb97 100644
--- a/lib/streamlit/web/server/routes.py
+++ b/lib/streamlit/web/server/routes.py
@@ -41,10 +41,15 @@ def allow_cross_origin_requests() -> bool:
 
 
 class StaticFileHandler(tornado.web.StaticFileHandler):
-    def initialize(self, path, default_filename, get_pages):
-        self._pages = get_pages()
+    def initialize(
+        self,
+        path: str,
+        default_filename: str | None = None,
+        reserved_paths: list[str] = [],
+    ):
+        self._reserved_paths = reserved_paths
 
-        super().initialize(path=path, default_filename=default_filename)
+        super().initialize(path, default_filename)
 
     def set_extra_headers(self, path: str) -> None:
         """Disable cache for HTML files.
@@ -59,28 +64,21 @@ class StaticFileHandler(tornado.web.StaticFileHandler):
         else:
             self.set_header("Cache-Control", "public")
 
-    def parse_url_path(self, url_path: str) -> str:
-        url_parts = url_path.split("/")
-
-        maybe_page_name = url_parts[0]
-        if maybe_page_name in self._pages:
-            # If we're trying to navigate to a page, we return "index.html"
-            # directly here instead of deferring to the superclass below after
-            # modifying the url_path. The reason why is that tornado handles
-            # requests to "directories" (which is what navigating to a page
-            # looks like) by appending a trailing '/' if there is none and
-            # redirecting.
-            #
-            # This would work, but it
-            #   * adds an unnecessary redirect+roundtrip
-            #   * adds a trailing '/' to the URL appearing in the browser, which
-            #     looks bad
-            if len(url_parts) == 1:
-                return "index.html"
-
-            url_path = "/".join(url_parts[1:])
-
-        return super().parse_url_path(url_path)
+    def validate_absolute_path(self, root: str, absolute_path: str) -> str | None:
+        try:
+            return super().validate_absolute_path(root, absolute_path)
+        except tornado.web.HTTPError as e:
+            # If the file is not found, and there are no reserved paths,
+            # we try to serve the default file and allow the frontend to handle the issue.
+            if e.status_code == 404:
+                if any([self.path.endswith(x) for x in self._reserved_paths]):
+                    raise e
+
+                self.path = self.parse_url_path(self.default_filename or "index.html")
+                absolute_path = self.get_absolute_path(self.root, self.path)
+                return super().validate_absolute_path(root, absolute_path)
+
+            raise e
 
     def write_error(self, status_code: int, **kwargs) -> None:
         if status_code == 404:
diff --git a/lib/streamlit/web/server/server.py b/lib/streamlit/web/server/server.py
index dceb76f07..51d0b385b 100644
--- a/lib/streamlit/web/server/server.py
+++ b/lib/streamlit/web/server/server.py
@@ -28,7 +28,7 @@ import tornado.web
 import tornado.websocket
 from tornado.httpserver import HTTPServer
 
-from streamlit import cli_util, config, file_util, source_util, util
+from streamlit import cli_util, config, file_util, util
 from streamlit.config_option import ConfigOption
 from streamlit.logger import get_logger
 from streamlit.runtime import Runtime, RuntimeConfig, RuntimeState
@@ -86,7 +86,8 @@ UPLOAD_FILE_ENDPOINT: Final = "/_stcore/upload_file"
 STREAM_ENDPOINT: Final = r"_stcore/stream"
 METRIC_ENDPOINT: Final = r"(?:st-metrics|_stcore/metrics)"
 MESSAGE_ENDPOINT: Final = r"_stcore/message"
-HEALTH_ENDPOINT: Final = r"(?:healthz|_stcore/health)"
+NEW_HEALTH_ENDPOINT: Final = "_stcore/health"
+HEALTH_ENDPOINT: Final = rf"(?:healthz|{NEW_HEALTH_ENDPOINT})"
 HOST_CONFIG_ENDPOINT: Final = r"_stcore/host-config"
 SCRIPT_HEALTH_CHECK_ENDPOINT: Final = (
     r"(?:script-health-check|_stcore/script-health-check)"
@@ -368,12 +369,12 @@ class Server:
                         {
                             "path": "%s/" % static_path,
                             "default_filename": "index.html",
-                            "get_pages": lambda: {
-                                page_info["page_name"]
-                                for page_info in source_util.get_pages(
-                                    self.main_script_path
-                                ).values()
-                            },
+                            "reserved_paths": [
+                                # These paths are required for identifying
+                                # the base url path.
+                                NEW_HEALTH_ENDPOINT,
+                                HOST_CONFIG_ENDPOINT,
+                            ],
                         },
                     ),
                     (make_url_path_regex(base, trailing_slash=False), AddSlashHandler),
diff --git a/lib/tests/conftest.py b/lib/tests/conftest.py
index b870e4874..671142429 100644
--- a/lib/tests/conftest.py
+++ b/lib/tests/conftest.py
@@ -99,6 +99,11 @@ def pytest_configure(config: pytest.Config):
 
 
 def pytest_runtest_setup(item: pytest.Item):
+    # Ensure Default Strategy is V1 to start
+    from streamlit.runtime.pages_manager import PagesManager, PagesStrategyV1
+
+    PagesManager.DefaultStrategy = PagesStrategyV1
+
     is_require_snowflake = item.config.getoption("--require-snowflake", default=False)
     has_require_snowflake_marker = bool(
         list(item.iter_markers(name="require_snowflake"))
diff --git a/lib/tests/delta_generator_test_case.py b/lib/tests/delta_generator_test_case.py
index 9a76514dc..a3a92c942 100644
--- a/lib/tests/delta_generator_test_case.py
+++ b/lib/tests/delta_generator_test_case.py
@@ -30,6 +30,7 @@ from streamlit.runtime.fragment import MemoryFragmentStorage
 from streamlit.runtime.media_file_manager import MediaFileManager
 from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner import (
     ScriptRunContext,
     add_script_run_ctx,
@@ -55,10 +56,10 @@ class DeltaGeneratorTestCase(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager(UPLOAD_FILE_ENDPOINT),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             script_requests=ScriptRequests(),
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
         add_script_run_ctx(threading.current_thread(), self.script_run_ctx)
 
diff --git a/lib/tests/exception_capturing_thread.py b/lib/tests/exception_capturing_thread.py
index ea6ccd818..192b66b9d 100644
--- a/lib/tests/exception_capturing_thread.py
+++ b/lib/tests/exception_capturing_thread.py
@@ -18,6 +18,7 @@ from typing import Any, Callable, Optional
 from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
 from streamlit.runtime.fragment import MemoryFragmentStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner import ScriptRunContext, add_script_run_ctx
 from streamlit.runtime.state import SafeSessionState, SessionState
 
@@ -66,9 +67,9 @@ def call_on_threads(
                 session_state=SafeSessionState(SessionState(), lambda: None),
                 uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
                 main_script_path="",
-                page_script_hash="",
                 user_info={"email": "test@test.com"},
                 fragment_storage=MemoryFragmentStorage(),
+                pages_manager=PagesManager(""),
             )
             thread = threads[ii]
             add_script_run_ctx(thread, ctx)
diff --git a/lib/tests/streamlit/commands/navigation_test.py b/lib/tests/streamlit/commands/navigation_test.py
new file mode 100644
index 000000000..584fe1825
--- /dev/null
+++ b/lib/tests/streamlit/commands/navigation_test.py
@@ -0,0 +1,139 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import pytest
+
+import streamlit as st
+from streamlit.errors import StreamlitAPIException
+from streamlit.proto.Navigation_pb2 import Navigation as NavigationProto
+from tests.delta_generator_test_case import DeltaGeneratorTestCase
+
+
+class NavigationTest(DeltaGeneratorTestCase):
+    """Test st.navigation"""
+
+    def test_no_pages(self):
+        """Test that an error is thrown with no pages"""
+        with pytest.raises(StreamlitAPIException):
+            st.navigation([])
+
+    def test_single_page(self):
+        """Test that a single page is returned"""
+        single_page = st.Page("page1.py")
+        page = st.navigation([single_page])
+        assert page == single_page
+
+    def test_first_page_is_default(self):
+        """Test that the first page is returned if there are multiple pages and no default"""
+        single_page = st.Page("page1.py")
+        page = st.navigation([single_page, st.Page("page2.py"), st.Page("page3.py")])
+        assert page == single_page
+        assert page._default
+
+    def test_default_page_returned_if_specified(self):
+        """Test that the first page is returned if there are multiple pages and no default"""
+        default_page = st.Page("page3.py", default=True)
+        page = st.navigation([st.Page("page1.py"), st.Page("page2.py"), default_page])
+        assert page == default_page
+        assert page._default
+
+    def test_multiple_defaults_raises_APIException(self):
+        """Test that an error is thrown if multiple defaults are specified"""
+        with pytest.raises(StreamlitAPIException):
+            st.navigation(
+                [st.Page("page1.py", default=True), st.Page("page2.py", default=True)]
+            )
+
+    def test_same_url_paths_raises_APIException(self):
+        """Test that an error is thrown if same url_paths are specified"""
+        with pytest.raises(StreamlitAPIException):
+            st.navigation(
+                [
+                    st.Page("page1.py", url_path="foo"),
+                    st.Page("page2.py", url_path="foo"),
+                ]
+            )
+
+    def test_same_inferred_url_paths_raises_APIException(self):
+        """Test that an error is thrown if the same inferred url_paths are specified"""
+        with pytest.raises(StreamlitAPIException):
+            st.navigation(
+                [
+                    st.Page("page1.py", url_path="foo"),
+                    st.Page("foo.py"),
+                ]
+            )
+
+    def test_page_found_by_hash(self):
+        found_page = st.Page("page2.py")
+        self.script_run_ctx.pages_manager.set_script_intent(found_page._script_hash, "")
+        page = st.navigation([st.Page("page1.py"), found_page, st.Page("page3.py")])
+        assert page == found_page
+
+    def test_page_found_by_name(self):
+        found_page = st.Page("page2.py")
+        self.script_run_ctx.pages_manager.set_script_intent("", "page2")
+        page = st.navigation([st.Page("page1.py"), found_page, st.Page("page3.py")])
+        assert page == found_page
+
+    def test_page_not_found_by_name(self):
+        default_page = st.Page("page1.py")
+        self.script_run_ctx.pages_manager.set_script_intent("", "bad_page")
+        page = st.navigation([default_page, st.Page("page2.py"), st.Page("page3.py")])
+
+        c = self.get_message_from_queue(-2)
+        assert c.HasField("page_not_found")
+        assert page == default_page
+
+    def test_page_not_found_by_hash_returns_default(self):
+        default_page = st.Page("page1.py")
+        self.script_run_ctx.pages_manager.set_script_intent("bad_hash", "")
+        page = st.navigation([default_page, st.Page("page2.py"), st.Page("page3.py")])
+        assert page == default_page
+
+    def test_navigation_message(self):
+        st.navigation(
+            {
+                "Section 1": [st.Page("page1.py")],
+                "Section 2": [st.Page("page2.py"), st.Page("page3.py")],
+            }
+        )
+
+        c = self.get_message_from_queue().navigation
+        assert len(c.app_pages) == 3
+        assert c.app_pages[0].section_header == "Section 1"
+        assert c.app_pages[1].section_header == "Section 2"
+        assert c.app_pages[2].section_header == "Section 2"
+        assert c.app_pages[0].is_default
+        assert not c.app_pages[1].is_default
+        assert not c.app_pages[2].is_default
+        assert c.position == NavigationProto.Position.SIDEBAR
+        assert c.sections == ["Section 1", "Section 2"]
+
+    def test_navigation_message_with_position(self):
+        st.navigation(
+            [st.Page("page1.py"), st.Page("page2.py"), st.Page("page3.py")],
+            position="hidden",
+        )
+
+        c = self.get_message_from_queue().navigation
+        assert len(c.app_pages) == 3
+        assert c.app_pages[0].section_header == ""
+        assert c.app_pages[1].section_header == ""
+        assert c.app_pages[2].section_header == ""
+        assert c.app_pages[0].is_default
+        assert not c.app_pages[1].is_default
+        assert not c.app_pages[2].is_default
+        assert c.position == NavigationProto.Position.HIDDEN
+        assert c.sections == [""]
diff --git a/lib/tests/streamlit/elements/number_input_test.py b/lib/tests/streamlit/elements/number_input_test.py
index 396901f29..da2e6814d 100644
--- a/lib/tests/streamlit/elements/number_input_test.py
+++ b/lib/tests/streamlit/elements/number_input_test.py
@@ -323,7 +323,7 @@ class NumberInputTest(DeltaGeneratorTestCase):
         # Generate widget id and reset context
         st.number_input("a number", min_value=1, max_value=100, key="number")
         widget_id = self.script_run_ctx.session_state.get_widget_states()[0].id
-        self.script_run_ctx.reset()
+        self.script_run_ctx.reset(page_script_hash=self.script_run_ctx.page_script_hash)
 
         # Set the state of the widgets to the test state
         widget_state = WidgetState()
diff --git a/lib/tests/streamlit/elements/page_link_test.py b/lib/tests/streamlit/elements/page_link_test.py
index c952a500a..ebbe492a6 100644
--- a/lib/tests/streamlit/elements/page_link_test.py
+++ b/lib/tests/streamlit/elements/page_link_test.py
@@ -29,22 +29,22 @@ class PageLinkTest(DeltaGeneratorTestCase):
         st.page_link(page="http://example.com", label="HTTP Test")
 
         c = self.get_delta_from_queue().new_element.page_link
-        self.assertEqual(c.label, "HTTP Test")
-        self.assertEqual(c.page, "http://example.com")
-        self.assertTrue(c.external)
-        self.assertFalse(c.disabled)
-        self.assertEqual(c.icon, "")
-        self.assertEqual(c.help, "")
+        assert c.label == "HTTP Test"
+        assert c.page == "http://example.com"
+        assert c.external
+        assert not c.disabled
+        assert c.icon == ""
+        assert c.help == ""
 
     def test_external_https_page(self):
         """Test that it can be called with an external https page link."""
         st.page_link(page="https://example.com", label="HTTPS Test")
 
         c = self.get_delta_from_queue().new_element.page_link
-        self.assertEqual(c.label, "HTTPS Test")
-        self.assertEqual(c.page, "https://example.com")
-        self.assertTrue(c.external)
-        self.assertFalse(c.disabled)
+        assert c.label == "HTTPS Test"
+        assert c.page == "https://example.com"
+        assert c.external
+        assert not c.disabled
 
     def test_external_no_label(self):
         """Test that page_link throws an StreamlitAPIException on external link, no label."""
@@ -56,20 +56,20 @@ class PageLinkTest(DeltaGeneratorTestCase):
         st.page_link(page="https://streamlit.io", label="the label", icon="ðŸ¶")
 
         c = self.get_delta_from_queue().new_element.page_link
-        self.assertEqual(c.label, "the label")
-        self.assertEqual(c.page, "https://streamlit.io")
-        self.assertTrue(c.external)
-        self.assertEqual(c.icon, "ðŸ¶")
+        assert c.label == "the label"
+        assert c.page == "https://streamlit.io"
+        assert c.external
+        assert c.icon == "ðŸ¶"
 
     def test_disabled(self):
         """Test that it can be called with disabled param."""
         st.page_link(page="https://streamlit.io", label="the label", disabled=True)
 
         c = self.get_delta_from_queue().new_element.page_link
-        self.assertEqual(c.label, "the label")
-        self.assertEqual(c.page, "https://streamlit.io")
-        self.assertTrue(c.external)
-        self.assertTrue(c.disabled)
+        assert c.label == "the label"
+        assert c.page == "https://streamlit.io"
+        assert c.external
+        assert c.disabled
 
     def test_help(self):
         """Test that it can be called with help param."""
@@ -78,10 +78,10 @@ class PageLinkTest(DeltaGeneratorTestCase):
         )
 
         c = self.get_delta_from_queue().new_element.page_link
-        self.assertEqual(c.label, "the label")
-        self.assertEqual(c.page, "https://streamlit.io")
-        self.assertTrue(c.external)
-        self.assertEqual(c.help, "Some help text")
+        assert c.label == "the label"
+        assert c.page == "https://streamlit.io"
+        assert c.external
+        assert c.help == "Some help text"
 
     def test_use_container_width_can_be_set_to_true(self):
         """Test use_container_width can be set to true."""
@@ -90,10 +90,10 @@ class PageLinkTest(DeltaGeneratorTestCase):
         )
 
         c = self.get_delta_from_queue().new_element.page_link
-        self.assertEqual(c.label, "the label")
-        self.assertEqual(c.page, "https://streamlit.io")
-        self.assertTrue(c.external)
-        self.assertEqual(c.use_container_width, True)
+        assert c.label == "the label"
+        assert c.page == "https://streamlit.io"
+        assert c.external
+        assert c.use_container_width == True
 
     def test_use_container_width_can_be_set_to_false(self):
         """Test use_container_width can be set to false."""
@@ -102,7 +102,49 @@ class PageLinkTest(DeltaGeneratorTestCase):
         )
 
         c = self.get_delta_from_queue().new_element.page_link
-        self.assertEqual(c.label, "the label")
-        self.assertEqual(c.page, "https://streamlit.io")
-        self.assertTrue(c.external)
-        self.assertEqual(c.use_container_width, False)
+        assert c.label == "the label"
+        assert c.page == "https://streamlit.io"
+        assert c.external
+        assert c.use_container_width == False
+
+    def test_st_page_with_label(self):
+        """Test that st.page_link accepts an st.Page, but does not uses its title"""
+        page = st.Page("foo.py", title="Bar Test")
+        st.page_link(page=page, label="Foo Test")
+
+        c = self.get_delta_from_queue().new_element.page_link
+        assert c.label == "Foo Test"
+        assert c.page_script_hash == page._script_hash
+        assert c.page == "foo"
+        assert not c.external
+        assert not c.disabled
+        assert c.icon == ""
+        assert c.help == ""
+
+    def test_st_page_without_label(self):
+        """Test that st.page_link accepts an st.Page, but will use its title if necessary"""
+        page = st.Page("foo.py", title="Bar Test")
+        st.page_link(page=page)
+
+        c = self.get_delta_from_queue().new_element.page_link
+        assert c.label == "Bar Test"
+        assert c.page_script_hash == page._script_hash
+        assert c.page == "foo"
+        assert not c.external
+        assert not c.disabled
+        assert c.icon == ""
+        assert c.help == ""
+
+    def test_st_page_with_url_path(self):
+        """Test that st.page_link accepts an st.Page, but will use the url_path if necessary"""
+        page = st.Page("foo.py", title="Bar Test", url_path="bar")
+        st.page_link(page=page)
+
+        c = self.get_delta_from_queue().new_element.page_link
+        assert c.label == "Bar Test"
+        assert c.page_script_hash == page._script_hash
+        assert c.page == "bar"
+        assert not c.external
+        assert not c.disabled
+        assert c.icon == ""
+        assert c.help == ""
diff --git a/lib/tests/streamlit/navigation/__init__.py b/lib/tests/streamlit/navigation/__init__.py
new file mode 100644
index 000000000..02b6b4014
--- /dev/null
+++ b/lib/tests/streamlit/navigation/__init__.py
@@ -0,0 +1,13 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
diff --git a/lib/tests/streamlit/navigation/page_test.py b/lib/tests/streamlit/navigation/page_test.py
new file mode 100644
index 000000000..eeceb4cac
--- /dev/null
+++ b/lib/tests/streamlit/navigation/page_test.py
@@ -0,0 +1,140 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import pytest
+
+import streamlit as st
+from streamlit.errors import StreamlitAPIException
+from tests.delta_generator_test_case import DeltaGeneratorTestCase
+
+
+class StPagesTest(DeltaGeneratorTestCase):
+    """Test st.Page"""
+
+    def test_cannot_infer_title_raises_exception(self):
+        """Test that passing a page without a title raises an exception."""
+
+        class Foo:
+            def __call__(self):
+                pass
+
+        with pytest.raises(StreamlitAPIException):
+            st.Page(Foo())
+
+        try:
+            st.Page(Foo(), title="Hello")
+        except Exception:
+            pytest.fail("Should not raise exception")
+
+    def test_invalid_icon_raises_exception(self):
+        """Test that passing an invalid icon raises an exception."""
+
+        with pytest.raises(StreamlitAPIException):
+            st.Page("page.py", icon="hello world")
+
+    def test_valid_icon(self):
+        """Test that passing a valid icon does not raise an exception."""
+
+        st.Page("page.py", icon="ðŸ˜±")
+        # Provide an assertion to ensure no error
+        assert True
+
+    def test_script_hash_for_paths_are_different(self):
+        """Tests that script hashes are different when url path (inferred or not) is unique"""
+        assert st.Page("page1.py")._script_hash != st.Page("page2.py")._script_hash
+        assert (
+            st.Page(lambda: True, url_path="path_1")._script_hash
+            != st.Page(lambda: True, url_path="path_2")._script_hash
+        )
+
+    def test_url_path_is_inferred_from_filename(self):
+        """Tests that url path is inferred from filename if not provided"""
+        page = st.Page("page_8.py")
+        assert page.url_path == "page_8"
+
+    def test_url_path_is_inferred_from_function_name(self):
+        """Tests that url path is inferred from function name if not provided"""
+
+        def page_9():
+            pass
+
+        page = st.Page(page_9)
+        assert page.url_path == "page_9"
+
+    def test_url_path_overrides_if_specified(self):
+        """Tests that url path specified directly overrides inferred path"""
+        page = st.Page("page_8.py", url_path="my_url_path")
+        assert page.url_path == "my_url_path"
+
+    def test_url_path_strips_leading_slash(self):
+        """Tests that url path strips leading slash if provided"""
+        page = st.Page("page_8.py", url_path="/my_url_path")
+        assert page.url_path == "my_url_path"
+
+    def test_url_path_is_empty_string_if_default(self):
+        """Tests that url path is "" if the page is the default page"""
+
+        def page_9():
+            pass
+
+        page = st.Page(page_9, default=True)
+        assert page.url_path == ""
+
+    def test_url_path_is_empty_string_if_default(self):
+        """Tests that url path is "" if the page is the default page"""
+
+        def page_9():
+            pass
+
+        page = st.Page(page_9, default=True)
+        assert page.url_path == ""
+
+    def test_non_default_pages_cannot_have_empty_url_path(self):
+        """Tests that an error is raised if the empty url path is provided for a non-default page"""
+
+        def page_9():
+            pass
+
+        with pytest.raises(StreamlitAPIException):
+            page = st.Page(page_9, url_path="")
+
+    def test_page_run_cannot_run_standalone(self):
+        """Test that a page cannot run standalone."""
+        with pytest.raises(StreamlitAPIException):
+            st.Page("page.py").run()
+
+    def test_page_run_can_be_run_if_ordained(self):
+        """Test that a page can be run if ordained."""
+
+        # Indicates we are in V2
+        self.script_run_ctx.pages_manager.set_pages({})
+
+        page = st.Page(lambda: True)
+        page._can_be_called = True
+        page.run()
+        # Provide an assertion to ensure no error
+        assert True
diff --git a/lib/tests/streamlit/proto_compatibility_test.py b/lib/tests/streamlit/proto_compatibility_test.py
index a2284c961..1014f19fa 100644
--- a/lib/tests/streamlit/proto_compatibility_test.py
+++ b/lib/tests/streamlit/proto_compatibility_test.py
@@ -45,6 +45,9 @@ FD = FieldDescriptor
                 ("page_script_hash", FD.LABEL_OPTIONAL, FD.TYPE_STRING),
                 ("page_name", FD.LABEL_OPTIONAL, FD.TYPE_STRING),
                 ("icon", FD.LABEL_OPTIONAL, FD.TYPE_STRING),
+                ("is_default", FD.LABEL_OPTIONAL, FD.TYPE_BOOL),
+                ("section_header", FD.LABEL_OPTIONAL, FD.TYPE_STRING),
+                ("url_pathname", FD.LABEL_OPTIONAL, FD.TYPE_STRING),
             },
         ),
         (
@@ -59,6 +62,7 @@ FD = FieldDescriptor
                 ("app_pages", FD.LABEL_REPEATED, FD.TYPE_MESSAGE),
                 ("page_script_hash", FD.LABEL_OPTIONAL, FD.TYPE_STRING),
                 ("fragment_ids_this_run", FD.LABEL_REPEATED, FD.TYPE_STRING),
+                ("main_script_hash", FD.LABEL_OPTIONAL, FD.TYPE_STRING),
             },
         ),
         (
diff --git a/lib/tests/streamlit/runtime/app_session_test.py b/lib/tests/streamlit/runtime/app_session_test.py
index 98d1c6c93..25f9392f6 100644
--- a/lib/tests/streamlit/runtime/app_session_test.py
+++ b/lib/tests/streamlit/runtime/app_session_test.py
@@ -19,7 +19,7 @@ import unittest
 from asyncio import AbstractEventLoop
 from typing import Any, Callable, List, Optional, cast
 from unittest import IsolatedAsyncioTestCase
-from unittest.mock import MagicMock, patch
+from unittest.mock import DEFAULT, MagicMock, patch
 
 import pytest
 
@@ -39,6 +39,7 @@ from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
 from streamlit.runtime.fragment import MemoryFragmentStorage
 from streamlit.runtime.media_file_manager import MediaFileManager
 from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.script_data import ScriptData
 from streamlit.runtime.scriptrunner import (
     RerunData,
@@ -312,6 +313,7 @@ class AppSessionTest(unittest.TestCase):
             initial_rerun_data=RerunData(),
             user_info={"email": "test@test.com"},
             fragment_storage=session._fragment_storage,
+            pages_manager=session._pages_manager,
         )
 
         assert session._scriptrunner is not None
@@ -417,8 +419,9 @@ class AppSessionTest(unittest.TestCase):
 
         assert not session.request_rerun.called
 
-    @patch(
-        "streamlit.runtime.app_session.source_util.get_pages",
+    @patch.object(
+        PagesManager,
+        "get_pages",
         MagicMock(
             return_value={
                 "hash1": {"page_name": "page1", "icon": "", "script_path": "script1"},
@@ -441,21 +444,22 @@ class AppSessionTest(unittest.TestCase):
 
         mock_enqueue.assert_called_once_with(expected_msg)
 
-    @patch(
-        "streamlit.runtime.app_session.source_util.register_pages_changed_callback",
-    )
+    @patch.object(PagesManager, "register_pages_changed_callback")
     def test_installs_pages_watcher_on_init(self, patched_register_callback):
         session = _create_test_session()
         patched_register_callback.assert_called_once_with(session._on_pages_changed)
 
-    @patch("streamlit.runtime.app_session.source_util._on_pages_changed")
-    def test_deregisters_pages_watcher_on_shutdown(self, patched_on_pages_changed):
-        session = _create_test_session()
-        session.shutdown()
+    def test_deregisters_pages_watcher_on_shutdown(self):
+        disconnect_mock = MagicMock()
+        with patch.object(
+            PagesManager,
+            "register_pages_changed_callback",
+            return_value=disconnect_mock,
+        ):
+            session = _create_test_session()
+            session.shutdown()
 
-        patched_on_pages_changed.disconnect.assert_called_once_with(
-            session._on_pages_changed
-        )
+            disconnect_mock.assert_called_once()
 
     def test_tags_fwd_msgs_with_last_backmsg_id_if_set(self):
         session = _create_test_session()
@@ -467,15 +471,19 @@ class AppSessionTest(unittest.TestCase):
         assert msg.debug_last_backmsg_id == "some backmsg id"
 
     @patch("streamlit.runtime.app_session.config.on_config_parsed")
-    @patch("streamlit.runtime.app_session.source_util.register_pages_changed_callback")
     @patch(
         "streamlit.runtime.app_session.secrets_singleton.file_change_listener.connect"
     )
+    @patch.multiple(
+        PagesManager,
+        register_pages_changed_callback=DEFAULT,
+        get_pages=MagicMock(return_value={}),
+    )
     def test_registers_file_watchers(
         self,
         patched_secrets_connect,
-        patched_register_pages_changed_callback,
         patched_on_config_parsed,
+        register_pages_changed_callback,
     ):
         session = _create_test_session()
 
@@ -485,13 +493,18 @@ class AppSessionTest(unittest.TestCase):
         patched_on_config_parsed.assert_called_once_with(
             session._on_source_file_changed, force_connect=True
         )
-        patched_register_pages_changed_callback.assert_called_once_with(
+        register_pages_changed_callback.assert_called_once_with(
             session._on_pages_changed
         )
         patched_secrets_connect.assert_called_once_with(
             session._on_secrets_file_changed
         )
 
+    @patch.object(
+        PagesManager,
+        "get_pages",
+        MagicMock(return_value={}),
+    )
     def test_recreates_local_sources_watcher_if_none(self):
         session = _create_test_session()
         session._local_sources_watcher = None
@@ -638,8 +651,9 @@ class AppSessionScriptEventTest(IsolatedAsyncioTestCase):
         "streamlit.runtime.app_session.config.get_options_for_section",
         MagicMock(side_effect=_mock_get_options_for_section()),
     )
-    @patch(
-        "streamlit.runtime.app_session.source_util.get_pages",
+    @patch.object(
+        PagesManager,
+        "get_pages",
         MagicMock(
             return_value={
                 "hash1": {"page_name": "page1", "icon": "", "script_path": "script1"},
@@ -663,9 +677,9 @@ class AppSessionScriptEventTest(IsolatedAsyncioTestCase):
             session_state=MagicMock(),
             uploaded_file_mgr=MagicMock(),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
         add_script_run_ctx(ctx=ctx)
 
@@ -716,6 +730,11 @@ class AppSessionScriptEventTest(IsolatedAsyncioTestCase):
         "streamlit.runtime.app_session._generate_scriptrun_id",
         MagicMock(return_value="mock_scriptrun_id"),
     )
+    @patch.object(
+        PagesManager,
+        "register_pages_changed_callback",
+        MagicMock(return_value=lambda: None),
+    )
     async def test_new_session_message_includes_fragment_ids(self):
         session = _create_test_session(asyncio.get_running_loop())
 
@@ -727,9 +746,9 @@ class AppSessionScriptEventTest(IsolatedAsyncioTestCase):
             session_state=MagicMock(),
             uploaded_file_mgr=MagicMock(),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
         add_script_run_ctx(ctx=ctx)
 
@@ -810,6 +829,11 @@ class AppSessionScriptEventTest(IsolatedAsyncioTestCase):
         "streamlit.runtime.app_session._generate_scriptrun_id",
         MagicMock(return_value="mock_scriptrun_id"),
     )
+    @patch.object(
+        PagesManager,
+        "register_pages_changed_callback",
+        MagicMock(return_value=lambda: None),
+    )
     async def test_handle_backmsg_exception(self):
         """handle_backmsg_exception is a bit of a hack. Test that it does
         what it says.
@@ -1011,8 +1035,9 @@ class PopulateCustomThemeMsgTest(unittest.TestCase):
         )
 
 
-@patch(
-    "streamlit.runtime.app_session.source_util.get_pages",
+@patch.object(
+    PagesManager,
+    "get_pages",
     MagicMock(
         return_value={
             "hash1": {"page_name": "page1", "script_path": "page1.py"},
diff --git a/lib/tests/streamlit/runtime/caching/common_cache_test.py b/lib/tests/streamlit/runtime/caching/common_cache_test.py
index c82d7eae1..230c82cf5 100644
--- a/lib/tests/streamlit/runtime/caching/common_cache_test.py
+++ b/lib/tests/streamlit/runtime/caching/common_cache_test.py
@@ -39,6 +39,7 @@ from streamlit.runtime.caching.storage.dummy_cache_storage import (
 from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
 from streamlit.runtime.fragment import MemoryFragmentStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner import (
     ScriptRunContext,
     add_script_run_ctx,
@@ -254,9 +255,9 @@ class CommonCacheTest(DeltaGeneratorTestCase):
                 session_state=SafeSessionState(SessionState(), lambda: None),
                 uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
                 main_script_path="",
-                page_script_hash="",
                 user_info={"email": "test@test.com"},
                 fragment_storage=MemoryFragmentStorage(),
+                pages_manager=PagesManager(""),
             ),
         )
 
diff --git a/lib/tests/streamlit/runtime/fragment_test.py b/lib/tests/streamlit/runtime/fragment_test.py
index 3fada1bc1..e4ae47476 100644
--- a/lib/tests/streamlit/runtime/fragment_test.py
+++ b/lib/tests/streamlit/runtime/fragment_test.py
@@ -21,6 +21,7 @@ from parameterized import parameterized
 from streamlit.delta_generator import DeltaGenerator, dg_stack
 from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
 from streamlit.runtime.fragment import MemoryFragmentStorage, fragment
+from streamlit.runtime.pages_manager import PagesManager
 
 
 class MemoryFragmentStorageTest(unittest.TestCase):
@@ -258,3 +259,38 @@ class FragmentTest(unittest.TestCase):
             )
         else:
             ctx.enqueue.assert_not_called()
+
+    @patch("streamlit.runtime.fragment.get_script_run_ctx")
+    def test_sets_active_script_hash_if_needed(self, patched_get_script_run_ctx):
+        ctx = MagicMock()
+        ctx.fragment_storage = MemoryFragmentStorage()
+        ctx.pages_manager = PagesManager("")
+        ctx.pages_manager.set_pages({})  # Migrate to MPAv2
+        ctx.pages_manager.set_active_script_hash("some_hash")
+        ctx.active_script_hash = ctx.pages_manager.get_active_script_hash()
+        patched_get_script_run_ctx.return_value = ctx
+
+        with patch.object(
+            ctx.pages_manager, "run_with_active_hash"
+        ) as patched_run_with_active_hash:
+
+            @fragment
+            def my_fragment():
+                pass
+
+            my_fragment()
+
+            # Reach inside our MemoryFragmentStorage internals to pull out our saved
+            # fragment.
+            saved_fragment = list(ctx.fragment_storage._fragments.values())[0]
+
+            # set the hash to something different for subsequent calls
+            ctx.pages_manager.set_active_script_hash("a_different_hash")
+            ctx.active_script_hash = ctx.pages_manager.get_active_script_hash()
+
+            # Verify subsequent calls will run with the original active script hash
+            saved_fragment()
+            patched_run_with_active_hash.assert_called_with("some_hash")
+            patched_run_with_active_hash.reset_mock()
+            saved_fragment()
+            patched_run_with_active_hash.assert_called_with("some_hash")
diff --git a/lib/tests/streamlit/runtime/pages_manager_test.py b/lib/tests/streamlit/runtime/pages_manager_test.py
new file mode 100644
index 000000000..5e5ee4be9
--- /dev/null
+++ b/lib/tests/streamlit/runtime/pages_manager_test.py
@@ -0,0 +1,202 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Unit tests for PagesManager"""
+
+import os
+import unittest
+from unittest.mock import MagicMock, patch
+
+import streamlit.source_util as source_util
+from streamlit.runtime.pages_manager import PagesManager, PagesStrategyV1
+from streamlit.util import calc_md5
+
+
+class PagesManagerTest(unittest.TestCase):
+    def test_register_pages_changed_callback(self):
+        """Test that the pages changed callback is correctly registered and unregistered"""
+        pages_manager = PagesManager("main_script_path")
+        with patch.object(source_util, "_on_pages_changed", MagicMock()):
+            callback = lambda: None
+
+            disconnect = pages_manager.register_pages_changed_callback(callback)
+
+            source_util._on_pages_changed.connect.assert_called_once_with(
+                callback, weak=False
+            )
+
+            disconnect()
+            source_util._on_pages_changed.disconnect.assert_called_once_with(callback)
+
+    @patch("streamlit.runtime.pages_manager.watch_dir")
+    @patch.object(source_util, "invalidate_pages_cache", MagicMock())
+    def test_install_pages_watcher(self, patched_watch_dir):
+        """Test that the pages watcher is correctly installed and uninstalled"""
+        # Ensure PagesStrategyV1.is_watching_pages_dir is False to start
+        PagesStrategyV1.is_watching_pages_dir = False
+        PagesManager(os.path.normpath("/foo/bar/streamlit_app.py"))
+
+        patched_watch_dir.assert_called_once()
+        args, _ = patched_watch_dir.call_args_list[0]
+        on_pages_changed = args[1]
+
+        patched_watch_dir.assert_called_once_with(
+            os.path.normpath("/foo/bar/pages"),
+            on_pages_changed,
+            glob_pattern="*.py",
+            allow_nonexistent=True,
+        )
+
+        patched_watch_dir.reset_mock()
+
+        _ = PagesManager(os.path.normpath("/foo/bar/streamlit_app.py"))
+        patched_watch_dir.assert_not_called()
+
+        on_pages_changed("/foo/bar/pages")
+        source_util.invalidate_pages_cache.assert_called_once()
+
+
+class PagesManagerV2Test(unittest.TestCase):
+    def setUp(self):
+        self.pages_manager = PagesManager("main_script_path")
+
+        # This signifies the change to V2
+        self.pages_manager.set_pages({})
+
+    def test_run_with_active_hash(self):
+        """Ensure the active script is set correctly"""
+        main_script_hash = self.pages_manager.main_script_hash
+        assert self.pages_manager.get_active_script_hash() == main_script_hash
+
+        with self.pages_manager.run_with_active_hash("new_hash"):
+            assert self.pages_manager.get_active_script_hash() == "new_hash"
+
+        assert self.pages_manager.get_active_script_hash() == main_script_hash
+
+    def test_get_page_script_valid_hash(self):
+        """Ensure the page script is provided with valid page hash specified"""
+
+        self.pages_manager.set_script_intent("page_hash", "")
+        self.pages_manager.set_pages({"page_hash": {"page_script_hash": "page_hash"}})
+
+        page_script = self.pages_manager.get_page_script(
+            self.pages_manager.main_script_hash
+        )
+        assert page_script["page_script_hash"] == "page_hash"
+
+    def test_get_page_script_invalid_hash(self):
+        """Ensure the page script is provided with invalid page hash specified"""
+
+        self.pages_manager.set_script_intent("bad_hash", "")
+        self.pages_manager.set_pages({"page_hash": {"page_script_hash": "page_hash"}})
+
+        page_script = self.pages_manager.get_page_script(
+            self.pages_manager.main_script_hash
+        )
+        assert page_script is None
+
+    def test_get_page_script_valid_name(self):
+        """Ensure the page script is provided with valid page name specified"""
+
+        self.pages_manager.set_script_intent("", "page_name")
+        self.pages_manager.set_pages(
+            {
+                "page_hash": {
+                    "page_script_hash": "page_hash",
+                    "url_pathname": "page_name",
+                }
+            }
+        )
+
+        page_script = self.pages_manager.get_page_script(
+            self.pages_manager.main_script_hash
+        )
+        assert page_script["page_script_hash"] == "page_hash"
+
+    def test_get_page_script_invalid_name(self):
+        """Ensure the page script is not provided with invalid page name specified"""
+
+        self.pages_manager.set_script_intent("", "foo")
+        self.pages_manager.set_pages(
+            {
+                "page_hash": {
+                    "page_script_hash": "page_hash",
+                    "url_pathname": "page_name",
+                }
+            }
+        )
+
+        page_script = self.pages_manager.get_page_script(
+            self.pages_manager.main_script_hash
+        )
+        assert page_script is None
+
+    def test_get_initial_active_script(self):
+        """Test that the initial active script is correctly retrieved with the
+        main script path provided."""
+        page_info = self.pages_manager.get_initial_active_script("page_hash", "")
+
+        self.assertDictEqual(
+            page_info,
+            {"script_path": "main_script_path", "page_script_hash": "page_hash"},
+        )
+
+
+# NOTE: We write this test function using pytest conventions (as opposed to
+# using unittest.TestCase like in the rest of the codebase) because the tmpdir
+# pytest fixture is so useful for writing this test it's worth having the
+# slight inconsistency.
+@patch("streamlit.source_util._cached_pages", new=None)
+def test_get_initial_active_script_v1(tmpdir):
+    # Write an empty string to create a file.
+    tmpdir.join("streamlit_app.py").write("")
+
+    pages_dir = tmpdir.mkdir("pages")
+    pages = [
+        "03_other_page.py",
+        "04 last numbered page.py",
+        "01-page.py",
+    ]
+    for p in pages:
+        pages_dir.join(p).write("")
+
+    main_script_path = str(tmpdir / "streamlit_app.py")
+    pages_manager = PagesManager(main_script_path)
+
+    example_page_script_hash = calc_md5(str(pages_dir / "01-page.py"))
+
+    # positive case - get by hash
+    page = pages_manager.get_initial_active_script(example_page_script_hash, None)
+    assert page["page_script_hash"] == example_page_script_hash
+
+    # bad hash should not return a page
+    page = pages_manager.get_initial_active_script("random_hash", None)
+    assert page is None
+
+    # Even if the page name is specified, we detect via the hash only
+    page = pages_manager.get_initial_active_script("random_hash", "page")
+    assert page is None
+
+    # Find by page name works
+    page = pages_manager.get_initial_active_script("", "page")
+    assert page["page_script_hash"] == example_page_script_hash
+
+    # Try different page name
+    alternate_page_script_hash = calc_md5(str(pages_dir / "03_other_page.py"))
+    page = pages_manager.get_initial_active_script("", "other_page")
+    assert page["page_script_hash"] == alternate_page_script_hash
+
+    # Even if the valid page name is specified, we detect via the hash only
+    page = pages_manager.get_initial_active_script(alternate_page_script_hash, "page")
+    assert page["page_script_hash"] == alternate_page_script_hash
diff --git a/lib/tests/streamlit/runtime/runtime_test_case.py b/lib/tests/streamlit/runtime/runtime_test_case.py
index f492229c3..fe873936e 100644
--- a/lib/tests/streamlit/runtime/runtime_test_case.py
+++ b/lib/tests/streamlit/runtime/runtime_test_case.py
@@ -25,6 +25,7 @@ from streamlit.runtime.caching.storage.dummy_cache_storage import (
 )
 from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.script_data import ScriptData
 from streamlit.runtime.scriptrunner.script_cache import ScriptCache
 from streamlit.runtime.session_manager import (
@@ -67,6 +68,8 @@ class MockSessionManager(SessionManager):
     ) -> str:
         with mock.patch(
             "streamlit.runtime.scriptrunner.ScriptRunner", new=mock.MagicMock()
+        ), mock.patch.object(
+            PagesManager, "get_pages", mock.MagicMock(return_value={})
         ):
             session = AppSession(
                 script_data=script_data,
diff --git a/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py b/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py
index 2911797c1..c6d9e3bd7 100644
--- a/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py
+++ b/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py
@@ -35,6 +35,7 @@ from streamlit.runtime.fragment import MemoryFragmentStorage
 from streamlit.runtime.media_file_manager import MediaFileManager
 from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner import (
     RerunData,
     RerunException,
@@ -1012,6 +1013,7 @@ class TestScriptRunner(ScriptRunner):
             initial_rerun_data=RerunData(),
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(main_script_path),
         )
 
         # Accumulates uncaught exceptions thrown by our run thread.
diff --git a/lib/tests/streamlit/script_run_context_test.py b/lib/tests/streamlit/script_run_context_test.py
index c6eb80566..d019d9389 100644
--- a/lib/tests/streamlit/script_run_context_test.py
+++ b/lib/tests/streamlit/script_run_context_test.py
@@ -20,6 +20,7 @@ from streamlit.errors import StreamlitAPIException
 from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
 from streamlit.runtime.fragment import MemoryFragmentStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner import ScriptRunContext
 from streamlit.runtime.state import SafeSessionState, SessionState
 
@@ -36,9 +37,9 @@ class ScriptRunContextTest(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager("mock/upload"),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
 
         msg = ForwardMsg()
@@ -60,9 +61,9 @@ class ScriptRunContextTest(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
 
         ctx.on_script_start()
@@ -88,9 +89,9 @@ class ScriptRunContextTest(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
 
         ctx.on_script_start()
@@ -115,9 +116,9 @@ class ScriptRunContextTest(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
 
         ctx.on_script_start()
@@ -133,6 +134,43 @@ class ScriptRunContextTest(unittest.TestCase):
         except StreamlitAPIException:
             self.fail("set_page_config should have succeeded after reset!")
 
+    def test_active_script_hash(self):
+        """ensures active script hash is set correctly when enqueueing messages"""
+
+        fake_path = "my/custom/script/path"
+        pg_mgr = PagesManager(fake_path)
+
+        fake_enqueue = lambda msg: None
+        ctx = ScriptRunContext(
+            session_id="TestSessionID",
+            _enqueue=fake_enqueue,
+            query_string="",
+            session_state=SafeSessionState(SessionState(), lambda: None),
+            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
+            main_script_path="",
+            user_info={"email": "test@test.com"},
+            fragment_storage=MemoryFragmentStorage(),
+            pages_manager=pg_mgr,
+        )
+
+        ctx.on_script_start()
+
+        msg = ForwardMsg()
+        msg.delta.new_element.markdown.body = "foo"
+
+        ctx.enqueue(msg)
+        self.assertEqual(
+            msg.metadata.active_script_hash, pg_mgr.get_active_script_hash()
+        )
+
+        pg_mgr.set_current_page_script_hash("new_hash")
+
+        new_msg = ForwardMsg()
+        new_msg.delta.new_element.markdown.body = "bar"
+
+        ctx.enqueue(new_msg)
+        self.assertEqual(new_msg.metadata.active_script_hash, "new_hash")
+
     @parameterized.expand(
         [
             (True, True, True),  # Both APIs used
@@ -152,9 +190,9 @@ class ScriptRunContextTest(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
         ctx._experimental_query_params_used = experimental_used
         ctx._production_query_params_used = production_used
@@ -174,9 +212,9 @@ class ScriptRunContextTest(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
         ctx.mark_experimental_query_params_used()
         assert ctx._experimental_query_params_used == True
@@ -190,9 +228,9 @@ class ScriptRunContextTest(unittest.TestCase):
             session_state=SafeSessionState(SessionState(), lambda: None),
             uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
             main_script_path="",
-            page_script_hash="",
             user_info={"email": "test@test.com"},
             fragment_storage=MemoryFragmentStorage(),
+            pages_manager=PagesManager(""),
         )
         ctx.mark_production_query_params_used()
         assert ctx._production_query_params_used == True
diff --git a/lib/tests/streamlit/source_util_test.py b/lib/tests/streamlit/source_util_test.py
index 9a30c15d4..9424b1a16 100644
--- a/lib/tests/streamlit/source_util_test.py
+++ b/lib/tests/streamlit/source_util_test.py
@@ -178,7 +178,3 @@ def test_get_pages(tmpdir):
             "icon": "",
         },
     }
-
-    # Assert address-equality to verify the cache is used the second time
-    # get_pages is called.
-    assert source_util.get_pages(main_script_path) is received_pages
diff --git a/lib/tests/streamlit/streamlit_test.py b/lib/tests/streamlit/streamlit_test.py
index c4016d14a..d16687ad4 100644
--- a/lib/tests/streamlit/streamlit_test.py
+++ b/lib/tests/streamlit/streamlit_test.py
@@ -169,6 +169,8 @@ class StreamlitTest(unittest.TestCase):
                 "query_params",
                 "cache_data",
                 "cache_resource",
+                "navigation",
+                "Page",
                 # Experimental APIs:
                 "experimental_dialog",
                 "experimental_user",
diff --git a/lib/tests/streamlit/testing/app_test_test.py b/lib/tests/streamlit/testing/app_test_test.py
index 55961be34..308d32461 100644
--- a/lib/tests/streamlit/testing/app_test_test.py
+++ b/lib/tests/streamlit/testing/app_test_test.py
@@ -227,7 +227,6 @@ def test_trigger_recursion():
         import streamlit as st
 
         if st.button(label="Submit"):
-            print("CLICKED!")
             time.sleep(1)
             st.rerun()
 
diff --git a/lib/tests/streamlit/user_info_test.py b/lib/tests/streamlit/user_info_test.py
index b2fdb64c9..72c8a986f 100644
--- a/lib/tests/streamlit/user_info_test.py
+++ b/lib/tests/streamlit/user_info_test.py
@@ -18,6 +18,7 @@ import streamlit as st
 from streamlit.errors import StreamlitAPIException
 from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
 from streamlit.runtime.fragment import MemoryFragmentStorage
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner import (
     ScriptRunContext,
     add_script_run_ctx,
@@ -104,9 +105,9 @@ class UserInfoProxyTest(DeltaGeneratorTestCase):
                     session_state=SafeSessionState(SessionState(), lambda: None),
                     uploaded_file_mgr=None,
                     main_script_path="",
-                    page_script_hash="",
                     user_info={"email": "something@else.com"},
                     fragment_storage=MemoryFragmentStorage(),
+                    pages_manager=PagesManager(""),
                 ),
             )
 
diff --git a/lib/tests/streamlit/watcher/local_sources_watcher_test.py b/lib/tests/streamlit/watcher/local_sources_watcher_test.py
index a8b2921b5..15f237762 100644
--- a/lib/tests/streamlit/watcher/local_sources_watcher_test.py
+++ b/lib/tests/streamlit/watcher/local_sources_watcher_test.py
@@ -25,6 +25,7 @@ import tests.streamlit.watcher.test_data.misbehaved_module as MISBEHAVED_MODULE
 import tests.streamlit.watcher.test_data.nested_module_child as NESTED_MODULE_CHILD
 import tests.streamlit.watcher.test_data.nested_module_parent as NESTED_MODULE_PARENT
 from streamlit import config
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.watcher import local_sources_watcher
 from streamlit.watcher.path_watcher import NoOpPathWatcher, _is_watchdog_available
 
@@ -69,8 +70,8 @@ class LocalSourcesWatcherTest(unittest.TestCase):
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_just_script(self, fob):
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
         fob.assert_called_once()
         args, _ = fob.call_args
@@ -79,23 +80,23 @@ class LocalSourcesWatcherTest(unittest.TestCase):
         self.assertEqual(type(args[1]), method_type)
 
         fob.reset_mock()
-        lso.update_watched_modules()
-        lso.update_watched_modules()
-        lso.update_watched_modules()
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
+        lsw.update_watched_modules()
+        lsw.update_watched_modules()
+        lsw.update_watched_modules()
 
         self.assertEqual(fob.call_count, 1)  # __init__.py
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_permission_error(self, fob):
         fob.side_effect = PermissionError("This error should be caught!")
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_script_and_2_modules_at_once(self, fob):
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
         fob.assert_called_once()
 
@@ -103,7 +104,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
         sys.modules["DUMMY_MODULE_2"] = DUMMY_MODULE_2
 
         fob.reset_mock()
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
 
         self.assertEqual(fob.call_count, 3)  # dummy modules and __init__.py
 
@@ -121,21 +122,21 @@ class LocalSourcesWatcherTest(unittest.TestCase):
         self.assertEqual(type(args[1]), method_type)
 
         fob.reset_mock()
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
 
         self.assertEqual(fob.call_count, 0)
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_script_and_2_modules_in_series(self, fob):
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
         fob.assert_called_once()
 
         sys.modules["DUMMY_MODULE_1"] = DUMMY_MODULE_1
         fob.reset_mock()
 
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
 
         self.assertEqual(fob.call_count, 2)  # dummy module and __init__.py
 
@@ -152,7 +153,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
 
         sys.modules["DUMMY_MODULE_2"] = DUMMY_MODULE_2
         fob.reset_mock()
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
 
         args, _ = fob.call_args
         self.assertEqual(args[0], DUMMY_MODULE_2_FILE)
@@ -163,14 +164,14 @@ class LocalSourcesWatcherTest(unittest.TestCase):
     @patch("streamlit.watcher.local_sources_watcher._LOGGER")
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_misbehaved_module(self, fob, patched_logger):
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
         fob.assert_called_once()
 
         sys.modules["MISBEHAVED_MODULE"] = MISBEHAVED_MODULE.MisbehavedModule
         fob.reset_mock()
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
 
         fob.assert_called_once()  # Just __init__.py
 
@@ -180,8 +181,8 @@ class LocalSourcesWatcherTest(unittest.TestCase):
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_nested_module_parent_unloaded(self, fob):
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
         fob.assert_called_once()
 
@@ -193,10 +194,10 @@ class LocalSourcesWatcherTest(unittest.TestCase):
                 "NESTED_MODULE_CHILD": NESTED_MODULE_CHILD,
             },
         ):
-            lso.update_watched_modules()
+            lsw.update_watched_modules()
 
             # Simulate a change to the child module
-            lso.on_file_changed(NESTED_MODULE_CHILD_FILE)
+            lsw.on_file_changed(NESTED_MODULE_CHILD_FILE)
 
             # Assert that both the parent and child are unloaded, ready for reload
             self.assertNotIn("NESTED_MODULE_CHILD", sys.modules)
@@ -211,15 +212,15 @@ class LocalSourcesWatcherTest(unittest.TestCase):
             "server.folderWatchBlacklist", [os.path.dirname(DUMMY_MODULE_1.__file__)]
         )
 
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
         fob.assert_called_once()
 
         sys.modules["DUMMY_MODULE_1"] = DUMMY_MODULE_1
         fob.reset_mock()
 
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
 
         fob.assert_not_called()
 
@@ -263,7 +264,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher", new=NoOpPathWatcher)
     def test_does_nothing_if_NoOpPathWatcher(self):
-        lsw = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
         lsw.register_file_change_callback(NOOP_CALLBACK)
         lsw.update_watched_modules()
         self.assertEqual(len(lsw._watched_modules), 0)
@@ -274,7 +275,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
 
         pkg_path = os.path.abspath(pkg.__path__._path[0])
 
-        lsw = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
         lsw.register_file_change_callback(NOOP_CALLBACK)
 
         fob.assert_called_once()
@@ -292,34 +293,34 @@ class LocalSourcesWatcherTest(unittest.TestCase):
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_module_caching(self, _fob):
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(NOOP_CALLBACK)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(NOOP_CALLBACK)
 
         register = MagicMock()
-        lso._register_necessary_watchers = register
+        lsw._register_necessary_watchers = register
 
         # Updates modules on first run
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
         register.assert_called_once()
 
         # Skips update when module list hasn't changed
         register.reset_mock()
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
         register.assert_not_called()
 
         # Invalidates cache when a new module is imported
         register.reset_mock()
         sys.modules["DUMMY_MODULE_2"] = DUMMY_MODULE_2
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
         register.assert_called_once()
 
         # Skips update when new module is part of cache
         register.reset_mock()
-        lso.update_watched_modules()
+        lsw.update_watched_modules()
         register.assert_not_called()
 
     @patch(
-        "streamlit.watcher.local_sources_watcher.get_pages",
+        "streamlit.runtime.pages_manager.PagesManager.get_pages",
         MagicMock(
             return_value={
                 "someHash1": {
@@ -335,7 +336,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
     )
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_watches_all_page_scripts(self, fob):
-        lsw = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
         lsw.register_file_change_callback(NOOP_CALLBACK)
 
         args1, _ = fob.call_args_list[0]
@@ -345,7 +346,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
         assert args2[0] == "streamlit_app2.py"
 
     @patch(
-        "streamlit.watcher.local_sources_watcher.get_pages",
+        "streamlit.runtime.pages_manager.PagesManager.get_pages",
         MagicMock(
             side_effect=[
                 {
@@ -373,7 +374,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
     )
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_watches_new_page_scripts(self, fob):
-        lsw = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
         lsw.register_file_change_callback(NOOP_CALLBACK)
 
         args1, _ = fob.call_args_list[0]
@@ -387,7 +388,7 @@ class LocalSourcesWatcherTest(unittest.TestCase):
         assert args3[0] == "streamlit_app3.py"
 
     @patch(
-        "streamlit.watcher.local_sources_watcher.get_pages",
+        "streamlit.runtime.pages_manager.PagesManager.get_pages",
         MagicMock(
             side_effect=[
                 {
@@ -414,12 +415,51 @@ class LocalSourcesWatcherTest(unittest.TestCase):
         ),
     )
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher", MagicMock())
-    def test_not_watches_removed_page_scripts(self):
-        lsw = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
+    def test_watches_union_of_page_scripts(self):
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
         assert lsw._watched_pages == {"page1.py", "page2.py"}
 
-        lsw.update_watched_pages()
-        assert lsw._watched_pages == {"page1.py", "page3.py"}
+        isfile_mock = lambda x: True
+        with patch("os.path.isfile", wraps=isfile_mock):
+            lsw.update_watched_pages()
+            assert lsw._watched_pages == {"page1.py", "page2.py", "page3.py"}
+
+    @patch(
+        "streamlit.runtime.pages_manager.PagesManager.get_pages",
+        MagicMock(
+            side_effect=[
+                {
+                    "someHash1": {
+                        "page_name": "page1",
+                        "script_path": "page1.py",
+                    },
+                    "someHash2": {
+                        "page_name": "page2",
+                        "script_path": "page2.py",
+                    },
+                },
+                {
+                    "someHash1": {
+                        "page_name": "page1",
+                        "script_path": "page1.py",
+                    },
+                    "someHash3": {
+                        "page_name": "page3",
+                        "script_path": "page3.py",
+                    },
+                },
+            ]
+        ),
+    )
+    @patch("streamlit.watcher.local_sources_watcher.PathWatcher", MagicMock())
+    def test_unwatches_invalid_page_script_paths(self):
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        assert lsw._watched_pages == {"page1.py", "page2.py"}
+
+        isfile_mock = lambda x: x != "page2.py"
+        with patch("os.path.isfile", wraps=isfile_mock):
+            lsw.update_watched_pages()
+            assert lsw._watched_pages == {"page1.py", "page3.py"}
 
     @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
     def test_passes_filepath_to_callback(self, fob):
@@ -430,11 +470,11 @@ class LocalSourcesWatcherTest(unittest.TestCase):
 
             saved_filepath = filepath
 
-        lso = local_sources_watcher.LocalSourcesWatcher(SCRIPT_PATH)
-        lso.register_file_change_callback(callback)
+        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
+        lsw.register_file_change_callback(callback)
 
         # Simulate a change to the report script
-        lso.on_file_changed(SCRIPT_PATH)
+        lsw.on_file_changed(SCRIPT_PATH)
 
         self.assertEqual(saved_filepath, SCRIPT_PATH)
 
diff --git a/lib/tests/streamlit/web/bootstrap_test.py b/lib/tests/streamlit/web/bootstrap_test.py
index dede7de2d..fef1849a3 100644
--- a/lib/tests/streamlit/web/bootstrap_test.py
+++ b/lib/tests/streamlit/web/bootstrap_test.py
@@ -463,23 +463,3 @@ class BootstrapPrintTest(IsolatedAsyncioTestCase):
                 "server.port": 8502,
             },
         )
-
-    @patch("streamlit.web.bootstrap.invalidate_pages_cache")
-    @patch("streamlit.web.bootstrap.watch_dir")
-    def test_install_pages_watcher(
-        self, patched_watch_dir, patched_invalidate_pages_cache
-    ):
-        bootstrap._install_pages_watcher(os.path.normpath("/foo/bar/streamlit_app.py"))
-
-        args, _ = patched_watch_dir.call_args_list[0]
-        on_pages_changed = args[1]
-
-        patched_watch_dir.assert_called_once_with(
-            os.path.normpath("/foo/bar/pages"),
-            on_pages_changed,
-            glob_pattern="*.py",
-            allow_nonexistent=True,
-        )
-
-        on_pages_changed("/foo/bar/pages")
-        patched_invalidate_pages_cache.assert_called_once()
diff --git a/lib/tests/streamlit/web/server/routes_test.py b/lib/tests/streamlit/web/server/routes_test.py
index 8c21f2fe8..95d7861b6 100644
--- a/lib/tests/streamlit/web/server/routes_test.py
+++ b/lib/tests/streamlit/web/server/routes_test.py
@@ -29,6 +29,7 @@ from streamlit.web.server.server import (
     HEALTH_ENDPOINT,
     HOST_CONFIG_ENDPOINT,
     MESSAGE_ENDPOINT,
+    NEW_HEALTH_ENDPOINT,
     HealthHandler,
     HostConfigHandler,
     MessageCacheHandler,
@@ -135,9 +136,6 @@ class StaticFileHandlerTest(tornado.testing.AsyncHTTPTestCase):
         self._tmpfile.close()
         self._tmpdir.cleanup()
 
-    def get_pages(self):
-        return {"page1": "page_info1", "page2": "page_info2"}
-
     def get_app(self):
         return tornado.web.Application(
             [
@@ -147,7 +145,10 @@ class StaticFileHandlerTest(tornado.testing.AsyncHTTPTestCase):
                     {
                         "path": self._tmpdir.name,
                         "default_filename": self._filename,
-                        "get_pages": self.get_pages,
+                        "reserved_paths": [
+                            NEW_HEALTH_ENDPOINT,
+                            HOST_CONFIG_ENDPOINT,
+                        ],
                     },
                 )
             ]
@@ -166,13 +167,22 @@ class StaticFileHandlerTest(tornado.testing.AsyncHTTPTestCase):
         for r in responses:
             assert r.code == 200
 
-    def test_parse_url_path_404(self):
+    def test_nonexistent_urls_return_default_page(self):
         responses = [
             self.fetch("/nonexistent"),
             self.fetch("/page2/nonexistent"),
             self.fetch(f"/page3/{self._filename}"),
         ]
 
+        for r in responses:
+            assert r.code == 200
+
+    def test_reserved_paths_serve_404(self):
+        responses = [
+            self.fetch("/nonexistent/_stcore/health"),
+            self.fetch("/page2/_stcore/host-config"),
+        ]
+
         for r in responses:
             assert r.code == 404
 
diff --git a/lib/tests/testutil.py b/lib/tests/testutil.py
index a6a120907..5b9fbe9f4 100644
--- a/lib/tests/testutil.py
+++ b/lib/tests/testutil.py
@@ -21,6 +21,7 @@ from typing import TYPE_CHECKING
 from streamlit import config
 from streamlit.runtime.fragment import MemoryFragmentStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
+from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner import ScriptRunContext
 from streamlit.runtime.state import SafeSessionState, SessionState
 from tests.constants import SNOWFLAKE_CREDENTIAL_FILE
@@ -53,9 +54,9 @@ def create_mock_script_run_ctx() -> ScriptRunContext:
         session_state=SafeSessionState(SessionState(), lambda: None),
         uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
         main_script_path="",
-        page_script_hash="mock_page_script_hash",
         user_info={"email": "mock@test.com"},
         fragment_storage=MemoryFragmentStorage(),
+        pages_manager=PagesManager(""),
     )
 
 
diff --git a/proto/streamlit/proto/AppPage.proto b/proto/streamlit/proto/AppPage.proto
index 945bd531e..aeeb333f0 100644
--- a/proto/streamlit/proto/AppPage.proto
+++ b/proto/streamlit/proto/AppPage.proto
@@ -29,4 +29,9 @@ message AppPage {
   string page_script_hash = 1;
   string page_name = 2;
   string icon = 3;
+
+  // A feature for MPA v2 to inform the frontend what's the default page
+  bool is_default = 4;
+  string section_header = 5;
+  string url_pathname = 6;
 }
diff --git a/proto/streamlit/proto/ForwardMsg.proto b/proto/streamlit/proto/ForwardMsg.proto
index 39cec3594..7690075e6 100644
--- a/proto/streamlit/proto/ForwardMsg.proto
+++ b/proto/streamlit/proto/ForwardMsg.proto
@@ -24,6 +24,7 @@ import "streamlit/proto/Common.proto";
 import "streamlit/proto/Delta.proto";
 import "streamlit/proto/GitInfo.proto";
 import "streamlit/proto/Logo.proto";
+import "streamlit/proto/Navigation.proto";
 import "streamlit/proto/NewSession.proto";
 import "streamlit/proto/PageConfig.proto";
 import "streamlit/proto/PageInfo.proto";
@@ -73,6 +74,7 @@ message ForwardMsg {
     SessionEvent session_event = 10;
 
     // Other messages.
+    Navigation navigation = 23;
     PageNotFound page_not_found = 15;
     PagesChanged pages_changed = 16;
     FileURLsResponse file_urls_response = 19;
@@ -97,7 +99,7 @@ message ForwardMsg {
   string debug_last_backmsg_id = 17;
 
   reserved 7, 8;
-  // Next: 23
+  // Next: 24
 }
 
 // ForwardMsgMetadata contains all data that does _not_ get hashed (or cached)
@@ -116,6 +118,11 @@ message ForwardMsgMetadata {
 
   // DEPRECATED: This is not used anymore.
   ElementDimensionSpec element_dimension_spec = 3;
+
+  // active_script_hash the forward message is associated from.
+  // For multipage apps v1, this will always be the page file running
+  // For multipage apps v2, this can be the main script or the page script
+  string active_script_hash = 4;
 }
 
 // DEPRECATED: This is not used anymore.
diff --git a/proto/streamlit/proto/Navigation.proto b/proto/streamlit/proto/Navigation.proto
new file mode 100644
index 000000000..7400c2722
--- /dev/null
+++ b/proto/streamlit/proto/Navigation.proto
@@ -0,0 +1,40 @@
+/**!
+ * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+syntax = "proto3";
+
+option java_package = "com.snowflake.apps.streamlit";
+
+
+import "streamlit/proto/AppPage.proto";
+
+message Navigation {
+  repeated string sections = 1;
+  repeated AppPage app_pages = 2;
+  Position position = 3;
+
+  // The script hash for the page identified by st.navigation
+  string page_script_hash = 4;
+
+  // Position of the Navigation
+  enum Position {
+    // do not display the navigation
+    HIDDEN = 0;
+
+    // display navigation in the sidebar
+    SIDEBAR = 1;
+  }
+}
diff --git a/proto/streamlit/proto/NewSession.proto b/proto/streamlit/proto/NewSession.proto
index 43c572de3..a5abb0a3d 100644
--- a/proto/streamlit/proto/NewSession.proto
+++ b/proto/streamlit/proto/NewSession.proto
@@ -66,6 +66,9 @@ message NewSession {
   // The fragment IDs being run in this session if it corresponds to a fragment
   // script run.
   repeated string fragment_ids_this_run = 10;
+
+  // Hash of the main script running (ie streamlit run main_script.py)
+  string main_script_hash = 11;
 }
 
 // Contains the session status that existed at the time the user connected.
