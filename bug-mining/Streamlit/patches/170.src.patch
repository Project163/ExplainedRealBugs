diff --git a/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[chromium].png b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[chromium].png
new file mode 100644
index 000000000..00505b60b
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[firefox].png b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[firefox].png
new file mode 100644
index 000000000..da0362318
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[webkit].png b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[webkit].png
new file mode 100644
index 000000000..30d2ead15
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-33[webkit].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[chromium].png b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[chromium].png
new file mode 100644
index 000000000..ae23a4304
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[firefox].png b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[firefox].png
new file mode 100644
index 000000000..4d3b5bb85
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[firefox].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[webkit].png b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[webkit].png
new file mode 100644
index 000000000..40d534bb5
Binary files /dev/null and b/e2e_playwright/__snapshots__/linux/st_table_test/st_table-34[webkit].png differ
diff --git a/e2e_playwright/st_table.py b/e2e_playwright/st_table.py
index 747182fd2..f236ef536 100644
--- a/e2e_playwright/st_table.py
+++ b/e2e_playwright/st_table.py
@@ -245,7 +245,6 @@ styled_df.set_tooltips(
 
 st.table(styled_df)
 
-
 st.header("Markdown Support")
 index = pd.Index(
     [
@@ -281,3 +280,18 @@ data = pd.DataFrame(
 )
 
 st.table(data)
+
+st.header("Border Parameter")
+
+st.subheader("No borders (border=False)")
+data = {
+    "A": [1, 2, 3],
+    "B": ["X", "Y", "Z"],
+    "C": [10.5, 20.3, 30.1],
+    "D": ["Alpha", "Beta", "Gamma"],
+    "E": [True, False, True],
+}
+st.table(data, border=False)
+
+st.subheader("Horizontal borders only (border='horizontal')")
+st.table(data, border="horizontal")
diff --git a/e2e_playwright/st_table_test.py b/e2e_playwright/st_table_test.py
index 0547eab71..3045f82e3 100644
--- a/e2e_playwright/st_table_test.py
+++ b/e2e_playwright/st_table_test.py
@@ -17,7 +17,7 @@ from playwright.sync_api import Page, expect
 from e2e_playwright.conftest import ImageCompareFunction
 from e2e_playwright.shared.app_utils import check_top_level_class
 
-TOTAL_TABLE_ELEMENTS = 33
+TOTAL_TABLE_ELEMENTS = 35
 
 
 def test_table_rendering(app: Page, assert_snapshot: ImageCompareFunction):
diff --git a/frontend/lib/src/components/core/Block/ElementNodeRenderer.tsx b/frontend/lib/src/components/core/Block/ElementNodeRenderer.tsx
index 69e5ebcd9..b391c6932 100644
--- a/frontend/lib/src/components/core/Block/ElementNodeRenderer.tsx
+++ b/frontend/lib/src/components/core/Block/ElementNodeRenderer.tsx
@@ -209,8 +209,16 @@ const RawElementNodeRenderer = (
       )
     }
 
-    case "arrowTable":
-      return <ArrowTable element={node.quiverElement} {...elementProps} />
+    case "arrowTable": {
+      const arrowProto = node.element.arrowTable as ArrowProto
+      return (
+        <ArrowTable
+          element={arrowProto}
+          data={node.quiverElement}
+          {...elementProps}
+        />
+      )
+    }
 
     case "audio":
       return (
diff --git a/frontend/lib/src/components/elements/ArrowTable/ArrowTable.test.tsx b/frontend/lib/src/components/elements/ArrowTable/ArrowTable.test.tsx
index 187d2c271..4bdcfddaf 100644
--- a/frontend/lib/src/components/elements/ArrowTable/ArrowTable.test.tsx
+++ b/frontend/lib/src/components/elements/ArrowTable/ArrowTable.test.tsx
@@ -18,6 +18,8 @@ import React from "react"
 
 import { screen } from "@testing-library/react"
 
+import { Arrow as ArrowProto } from "@streamlit/protobuf"
+
 import { Quiver } from "~lib/dataframes/Quiver"
 import { EMPTY, UNICODE } from "~lib/mocks/arrow"
 import { render } from "~lib/test_util"
@@ -25,7 +27,8 @@ import { render } from "~lib/test_util"
 import { ArrowTable, TableProps } from "./ArrowTable"
 
 const getProps = (data: Uint8Array): TableProps => ({
-  element: new Quiver({ data }),
+  element: ArrowProto.create({ borderMode: ArrowProto.BorderMode.ALL }),
+  data: new Quiver({ data }),
 })
 
 describe("st._arrow_table", () => {
@@ -52,4 +55,66 @@ describe("st._arrow_table", () => {
       screen.getByTestId("stTableStyledEmptyTableCell")
     ).toBeInTheDocument()
   })
+
+  it("renders with all borders when border=true", () => {
+    const modifiedProps: TableProps = {
+      element: ArrowProto.create({ borderMode: ArrowProto.BorderMode.ALL }),
+      data: new Quiver({ data: UNICODE }),
+    }
+
+    const { container } = render(<ArrowTable {...modifiedProps} />)
+
+    // Check that the table border wrapper has border styling
+    const tableBorder = container.querySelector(
+      '[data-testid="stTable"] > div'
+    )
+    if (tableBorder) {
+      const borderStyle = getComputedStyle(tableBorder)
+      expect(borderStyle.borderStyle).toBe("solid")
+    }
+  })
+
+  it("renders without borders when border=false", () => {
+    // Create a Quiver with border=false
+    const modifiedProps: TableProps = {
+      element: ArrowProto.create({ borderMode: ArrowProto.BorderMode.NONE }),
+      data: new Quiver({ data: UNICODE }),
+    }
+
+    const { container } = render(<ArrowTable {...modifiedProps} />)
+
+    // Check that the table border wrapper has no border styling
+    const tableBorder = container.querySelector(
+      '[data-testid="stTable"] > div'
+    )
+    expect(tableBorder).toHaveStyle("border: none")
+
+    // Check that table cells have no bottom borders
+    const tableCell = container.querySelector("td")
+    expect(tableCell).toHaveStyle("border-bottom: none")
+  })
+
+  it("renders with horizontal borders only when border='horizontal'", () => {
+    const modifiedProps: TableProps = {
+      element: ArrowProto.create({
+        borderMode: ArrowProto.BorderMode.HORIZONTAL,
+      }),
+      data: new Quiver({ data: UNICODE }),
+    }
+
+    const { container } = render(<ArrowTable {...modifiedProps} />)
+
+    // Check that the table border wrapper has no border (horizontal borders are on cells)
+    const tableBorder = container.querySelector(
+      '[data-testid="stTable"] > div'
+    )
+    expect(tableBorder).toHaveStyle("border: none")
+
+    // Check that table cells have bottom borders (horizontal lines between rows)
+    const tableCell = container.querySelector("td")
+    if (tableCell) {
+      const cellStyle = getComputedStyle(tableCell)
+      expect(cellStyle.borderBottomStyle).toBe("solid")
+    }
+  })
 })
diff --git a/frontend/lib/src/components/elements/ArrowTable/ArrowTable.tsx b/frontend/lib/src/components/elements/ArrowTable/ArrowTable.tsx
index a3f8d79dc..1174a60ec 100644
--- a/frontend/lib/src/components/elements/ArrowTable/ArrowTable.tsx
+++ b/frontend/lib/src/components/elements/ArrowTable/ArrowTable.tsx
@@ -18,6 +18,8 @@ import React, { memo, ReactElement } from "react"
 
 import range from "lodash/range"
 
+import { Arrow as ArrowProto } from "@streamlit/protobuf"
+
 import StreamlitMarkdown from "~lib/components/shared/StreamlitMarkdown/StreamlitMarkdown"
 import { format as formatArrowCell } from "~lib/dataframes/arrowFormatUtils"
 import {
@@ -41,36 +43,39 @@ import {
 } from "./styled-components"
 
 export interface TableProps {
-  element: Quiver
+  element: ArrowProto
+  data: Quiver
 }
 
 export function ArrowTable(props: Readonly<TableProps>): ReactElement {
-  const table = props.element
+  const table = props.data
   const { cssId, cssStyles, caption } = table.styler ?? {}
   const { numHeaderRows, numDataRows, numColumns } = table.dimensions
   const dataRowIndices = range(numDataRows)
+  const borderMode = props.element.borderMode
 
   return (
     <StyledTableContainer className="stTable" data-testid="stTable">
       {cssStyles && <style>{cssStyles}</style>}
       {/* Add an extra wrapper with the border. This makes sure the border shows around
       the entire table when scrolling horizontally. See also `styled-components.ts`. */}
-      <StyledTableBorder>
+      <StyledTableBorder borderMode={borderMode}>
         <StyledTable id={cssId} data-testid="stTableStyledTable">
-          {numHeaderRows > 0 && generateTableHeader(table)}
+          {numHeaderRows > 0 && generateTableHeader(table, borderMode)}
           <tbody>
             {dataRowIndices.length === 0 ? (
               <tr>
                 <StyledEmptyTableCell
                   data-testid="stTableStyledEmptyTableCell"
                   colSpan={numColumns || 1}
+                  borderMode={borderMode}
                 >
                   empty
                 </StyledEmptyTableCell>
               </tr>
             ) : (
               dataRowIndices.map(rowIndex =>
-                generateTableRow(table, rowIndex, numColumns)
+                generateTableRow(table, rowIndex, numColumns, borderMode)
               )
             )}
           </tbody>
@@ -91,27 +96,46 @@ export function ArrowTable(props: Readonly<TableProps>): ReactElement {
 /**
  * Generate the table header rows from a Quiver object.
  */
-function generateTableHeader(table: Quiver): ReactElement {
+function generateTableHeader(
+  table: Quiver,
+  borderMode: ArrowProto.BorderMode
+): ReactElement {
+  // When there are no vertical borders, we want to align the header text with the data.
+  const shouldAlignWithData =
+    borderMode === ArrowProto.BorderMode.NONE ||
+    borderMode === ArrowProto.BorderMode.HORIZONTAL
+
   return (
     <thead>
       {getStyledHeaders(table).map((headerRow, rowIndex) => (
         // TODO: Update to match React best practices
         // eslint-disable-next-line @eslint-react/no-array-index-key
         <tr key={rowIndex}>
-          {headerRow.map((header, colIndex) => (
-            <StyledTableCellHeader
-              // TODO: Update to match React best practices
-              // eslint-disable-next-line @eslint-react/no-array-index-key
-              key={colIndex}
-              className={header.cssClass}
-              scope="col"
-            >
-              <StreamlitMarkdown
-                source={header.name || "\u00A0"}
-                allowHTML={false}
-              />
-            </StyledTableCellHeader>
-          ))}
+          {headerRow.map((header, colIndex) => {
+            // Determine alignment based on column data type when no vertical borders
+            let textAlign: React.CSSProperties["textAlign"] = "inherit"
+            if (shouldAlignWithData && table.dimensions.numDataRows > 0) {
+              const { contentType } = table.getCell(0, colIndex)
+              textAlign = isNumericType(contentType) ? "right" : "left"
+            }
+
+            return (
+              <StyledTableCellHeader
+                // TODO: Update to match React best practices
+                // eslint-disable-next-line @eslint-react/no-array-index-key
+                key={colIndex}
+                className={header.cssClass}
+                scope="col"
+                borderMode={borderMode}
+                style={{ textAlign }}
+              >
+                <StreamlitMarkdown
+                  source={header.name || "\u00A0"}
+                  allowHTML={false}
+                />
+              </StyledTableCellHeader>
+            )
+          })}
         </tr>
       ))}
     </thead>
@@ -124,12 +148,13 @@ function generateTableHeader(table: Quiver): ReactElement {
 function generateTableRow(
   table: Quiver,
   rowIndex: number,
-  columns: number
+  columns: number,
+  borderMode: ArrowProto.BorderMode
 ): ReactElement {
   return (
     <tr key={rowIndex}>
       {range(columns).map(columnIndex =>
-        generateTableCell(table, rowIndex, columnIndex)
+        generateTableCell(table, rowIndex, columnIndex, borderMode)
       )}
     </tr>
   )
@@ -141,7 +166,8 @@ function generateTableRow(
 function generateTableCell(
   table: Quiver,
   rowIndex: number,
-  columnIndex: number
+  columnIndex: number,
+  borderMode: ArrowProto.BorderMode
 ): ReactElement {
   const { type, content, contentType } = table.getCell(rowIndex, columnIndex)
   const styledCell = getStyledCell(table, rowIndex, columnIndex)
@@ -177,6 +203,7 @@ function generateTableCell(
           scope="row"
           id={styledCell?.cssId}
           className={styledCell?.cssClass}
+          borderMode={borderMode}
         >
           {hasStylerTooltip && <span className="pd-t" />}
           <StreamlitMarkdown
@@ -193,6 +220,7 @@ function generateTableCell(
           id={styledCell?.cssId}
           className={styledCell?.cssClass}
           style={style}
+          borderMode={borderMode}
         >
           {hasStylerTooltip && <span className="pd-t" />}
           <StreamlitMarkdown
diff --git a/frontend/lib/src/components/elements/ArrowTable/styled-components.ts b/frontend/lib/src/components/elements/ArrowTable/styled-components.ts
index 890465d1d..2ae85ac0f 100644
--- a/frontend/lib/src/components/elements/ArrowTable/styled-components.ts
+++ b/frontend/lib/src/components/elements/ArrowTable/styled-components.ts
@@ -16,6 +16,8 @@
 
 import styled, { CSSObject } from "@emotion/styled"
 
+import { Arrow } from "@streamlit/protobuf"
+
 import { EmotionTheme } from "~lib/theme"
 
 export const StyledTableContainer = styled.div(({ theme }) => ({
@@ -36,14 +38,19 @@ export const StyledTableCaption = styled.div(({ theme }) => ({
   display: "inline-block",
 }))
 
-export const StyledTableBorder = styled.div(({ theme }) => ({
-  // Add the enclosing border on an extra wrapper around the table. This ensures that
-  // when the table scrolls horizontally on small windows, it still shows a border all
-  // around the table and the table doesn't look cut off.
-  border: `${theme.sizes.borderWidth} solid ${theme.colors.dataframeBorderColor}`,
-  borderRadius: theme.radii.default,
-  overflow: "auto",
-}))
+export const StyledTableBorder = styled.div<{ borderMode: Arrow.BorderMode }>(
+  ({ theme, borderMode }) => ({
+    // Add the enclosing border on an extra wrapper around the table. This ensures that
+    // when the table scrolls horizontally on small windows, it still shows a border all
+    // around the table and the table doesn't look cut off.
+    border:
+      borderMode === Arrow.BorderMode.ALL
+        ? `${theme.sizes.borderWidth} solid ${theme.colors.dataframeBorderColor}`
+        : "none",
+    borderRadius: theme.radii.default,
+    overflow: "auto",
+  })
+)
 
 export const StyledTable = styled.table(({ theme }) => ({
   width: theme.sizes.full,
@@ -51,34 +58,79 @@ export const StyledTable = styled.table(({ theme }) => ({
   borderSpacing: 0,
 }))
 
-const styleCellFunction = (theme: EmotionTheme): CSSObject => ({
-  // Only have borders on the bottom and right of each cell. And remove the borders
-  // of the last row and column to prevent double borders together with the enclosing
-  // border from `StyledTableBorder`.
-  borderBottom: `${theme.sizes.borderWidth} solid ${theme.colors.dataframeBorderColor}`,
+const styleCellFunction = (
+  theme: EmotionTheme,
+  border: Arrow.BorderMode = Arrow.BorderMode.ALL
+): CSSObject => ({
+  // Only have borders on the bottom and right of each cell.
+  borderBottom:
+    border !== Arrow.BorderMode.NONE
+      ? `${theme.sizes.borderWidth} solid ${theme.colors.dataframeBorderColor}`
+      : "none",
   "tbody tr:last-child &": {
-    borderBottom: "none",
+    // For "all" borders, remove bottom border of last row to prevent double border with
+    // table border. For "horizontal" borders, also remove bottom border of last row
+    // since there's no content after it.
+    borderBottom:
+      border === Arrow.BorderMode.ALL || border === Arrow.BorderMode.HORIZONTAL
+        ? "none"
+        : undefined,
   },
-  borderRight: `${theme.sizes.borderWidth} solid ${theme.colors.dataframeBorderColor}`,
+  borderRight:
+    border === Arrow.BorderMode.ALL
+      ? `${theme.sizes.borderWidth} solid ${theme.colors.dataframeBorderColor}`
+      : "none",
   "&:last-child": {
-    borderRight: "none",
+    borderRight: border === Arrow.BorderMode.ALL ? "none" : undefined,
+    // Remove right padding from last cell when no borders, so that the table aligns
+    // with the rest of the page.
+    paddingRight: border === Arrow.BorderMode.NONE ? "0" : theme.spacing.xs,
   },
   verticalAlign: "middle",
   padding: `${theme.spacing.twoXS} ${theme.spacing.xs}`,
+  // Increase the space between columns when there are no vertical borders.
+  "&:not(:first-of-type)": {
+    paddingLeft:
+      border === Arrow.BorderMode.NONE ||
+      border === Arrow.BorderMode.HORIZONTAL
+        ? theme.spacing.lg
+        : theme.spacing.xs,
+  },
+  // Remove left padding from first column when no borders, so that the table aligns
+  // with the rest of the page.
+  "&:first-of-type": {
+    paddingLeft: border === Arrow.BorderMode.NONE ? "0" : theme.spacing.xs,
+  },
   fontWeight: theme.fontWeights.normal,
 })
 
-export const StyledTableCell = styled.td(({ theme }) =>
-  styleCellFunction(theme)
+export const StyledTableCell = styled.td<{ borderMode: Arrow.BorderMode }>(
+  ({ theme, borderMode }) => styleCellFunction(theme, borderMode)
 )
-export const StyledTableCellHeader = styled.th(({ theme }) => ({
-  ...styleCellFunction(theme),
+export const StyledTableCellHeader = styled.th<{
+  borderMode: Arrow.BorderMode
+}>(({ theme, borderMode }) => ({
+  ...styleCellFunction(theme, borderMode),
   textAlign: "inherit",
   color: theme.colors.fadedText60,
-  paddingLeft: theme.spacing.sm,
+  // Remove left padding from first cell when no borders, so that the table aligns
+  // with the rest of the page.
+  "&:first-of-type": {
+    paddingLeft: borderMode === Arrow.BorderMode.NONE ? "0" : theme.spacing.sm,
+  },
+  // Increase the space between columns when there are no vertical borders.
+  "&:not(:first-of-type)": {
+    paddingLeft:
+      borderMode === Arrow.BorderMode.NONE ||
+      borderMode === Arrow.BorderMode.HORIZONTAL
+        ? theme.spacing.lg
+        : theme.spacing.sm,
+  },
 }))
 
-export const StyledEmptyTableCell = styled(StyledTableCell)(({ theme }) => ({
+export const StyledEmptyTableCell = styled(StyledTableCell)<{
+  borderMode: Arrow.BorderMode
+}>(({ theme }) => ({
   color: theme.colors.darkGray,
   fontStyle: "italic",
   fontSize: theme.fontSizes.md,
diff --git a/lib/streamlit/elements/arrow.py b/lib/streamlit/elements/arrow.py
index 87b1c8378..a99b051c7 100644
--- a/lib/streamlit/elements/arrow.py
+++ b/lib/streamlit/elements/arrow.py
@@ -16,15 +16,7 @@ from __future__ import annotations
 
 import json
 from dataclasses import dataclass
-from typing import (
-    TYPE_CHECKING,
-    Any,
-    Final,
-    Literal,
-    TypedDict,
-    cast,
-    overload,
-)
+from typing import TYPE_CHECKING, Any, Final, Literal, TypedDict, cast, overload
 
 from typing_extensions import TypeAlias
 
@@ -51,7 +43,7 @@ from streamlit.elements.lib.layout_utils import (
 from streamlit.elements.lib.pandas_styler_utils import marshall_styler
 from streamlit.elements.lib.policies import check_widget_policies
 from streamlit.elements.lib.utils import Key, compute_and_register_element_id, to_key
-from streamlit.errors import StreamlitAPIException
+from streamlit.errors import StreamlitAPIException, StreamlitValueError
 from streamlit.proto.Arrow_pb2 import Arrow as ArrowProto
 from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
 from streamlit.runtime.metrics_util import gather_metrics
@@ -270,6 +262,17 @@ def parse_selection_mode(
     return set(parsed_selection_modes)
 
 
+def parse_border_mode(
+    border: bool | Literal["horizontal"],
+) -> ArrowProto.BorderMode.ValueType:
+    """Parse and check the user provided border mode."""
+    if isinstance(border, bool):
+        return ArrowProto.BorderMode.ALL if border else ArrowProto.BorderMode.NONE
+    if border == "horizontal":
+        return ArrowProto.BorderMode.HORIZONTAL
+    raise StreamlitValueError("border", ["True", "False", "'horizontal'"])
+
+
 class ArrowMixin:
     @overload
     def dataframe(
@@ -751,7 +754,9 @@ class ArrowMixin:
         return self.dg._enqueue("arrow_data_frame", proto, layout_config=layout_config)
 
     @gather_metrics("table")
-    def table(self, data: Data = None) -> DeltaGenerator:
+    def table(
+        self, data: Data = None, *, border: bool | Literal["horizontal"] = True
+    ) -> DeltaGenerator:
         """Display a static table.
 
         While ``st.dataframe`` is geared towards large datasets and interactive
@@ -775,49 +780,59 @@ class ArrowMixin:
             .. |st.markdown| replace:: ``st.markdown``
             .. _st.markdown: https://docs.streamlit.io/develop/api-reference/text/st.markdown
 
+        border : bool or "horizontal"
+            Whether to show borders around the table and between cells. This can be one
+            of the following:
+
+            - ``True`` (default): Show borders around the table and between cells
+            - ``False``: Show no borders
+            - ``"horizontal"``: Show only horizontal borders between rows
+
         Examples
         --------
-        **Example 1: Display a simple dataframe as a static table**
+        **Example 1: Display a confusion matrix**
 
         >>> import pandas as pd
-        >>> import streamlit as st
-        >>> from numpy.random import default_rng as rng
         >>>
-        >>> df = pd.DataFrame(
-        ...     rng(0).standard_normal(size=(10, 5)),
-        ...     columns=("col %d" % i for i in range(5)),
+        >>> confusion_matrix = pd.DataFrame(
+        ...     {
+        ...         "Predicted Cat": [85, 3, 2, 1],
+        ...         "Predicted Dog": [2, 78, 4, 0],
+        ...         "Predicted Bird": [1, 5, 72, 3],
+        ...         "Predicted Fish": [0, 2, 1, 89],
+        ...     },
+        ...     index=["Actual Cat", "Actual Dog", "Actual Bird", "Actual Fish"],
         ... )
-        >>>
-        >>> st.table(df)
+        >>> st.table(confusion_matrix)
 
         .. output::
            https://doc-table.streamlit.app/
            height: 480px
 
-        **Example 2: Display a table of Markdown strings**
+        **Example 2: Display a product leaderboard with Markdown and horizontal borders**
 
-        >>> import pandas as pd
         >>> import streamlit as st
         >>>
-        >>> df = pd.DataFrame(
-        ...     {
-        ...         "Command": ["**st.table**", "*st.dataframe*"],
-        ...         "Type": ["`static`", "`interactive`"],
-        ...         "Docs": [
-        ...             "[:rainbow[docs]](https://docs.streamlit.io"
-        ...             "/develop/api-reference/data/st.dataframe)",
-        ...             "[:open_book:](https://docs.streamlit.io"
-        ...             "/develop/api-reference/data/st.table)",
-        ...         ],
-        ...     }
-        ... )
-        >>>
-        >>> st.table(df)
+        >>> product_data = {
+        ...     "Product": [
+        ...         ":material/devices: Widget Pro",
+        ...         ":material/smart_toy: Smart Device",
+        ...         ":material/inventory: Premium Kit",
+        ...     ],
+        ...     "Category": [":blue[Electronics]", ":green[IoT]", ":violet[Bundle]"],
+        ...     "Stock": ["ðŸŸ¢ Full", "ðŸŸ¡ Low", "ðŸ”´ Empty"],
+        ...     "Units sold": [1247, 892, 654],
+        ...     "Revenue": [125000, 89000, 98000],
+        ... }
+        >>> st.table(product_data, border="horizontal")
 
         .. output::
            https://doc-table-markdown.streamlit.app/
            height: 200px
+
         """
+        # Parse border parameter to enum value
+        border_mode = parse_border_mode(border)
 
         # Check if data is uncollected, and collect it but with 100 rows max, instead of
         # 10k rows, which is done in all other cases.
@@ -843,6 +858,7 @@ class ArrowMixin:
 
         proto = ArrowProto()
         marshall(proto, data, default_uuid)
+        proto.border_mode = border_mode
         return self.dg._enqueue("arrow_table", proto, layout_config=layout_config)
 
     @gather_metrics("add_rows")
diff --git a/lib/tests/streamlit/elements/arrow_table_test.py b/lib/tests/streamlit/elements/arrow_table_test.py
index ec959cfad..990d22560 100644
--- a/lib/tests/streamlit/elements/arrow_table_test.py
+++ b/lib/tests/streamlit/elements/arrow_table_test.py
@@ -19,12 +19,16 @@ from unittest.mock import patch
 import numpy as np
 import pandas as pd
 import pyarrow as pa
+import pytest
+from parameterized import parameterized
 
 import streamlit as st
 from streamlit.dataframe_util import (
     convert_arrow_bytes_to_pandas_df,
     convert_arrow_table_to_arrow_bytes,
 )
+from streamlit.errors import StreamlitValueError
+from streamlit.proto.Arrow_pb2 import Arrow as ArrowProto
 from tests.delta_generator_test_case import DeltaGeneratorTestCase
 
 
@@ -125,3 +129,27 @@ class ArrowTest(DeltaGeneratorTestCase):
 
             st.table(df)
             convert_anything_to_df.assert_called_once()
+
+    @parameterized.expand(
+        [
+            (True, ArrowProto.BorderMode.ALL),
+            (False, ArrowProto.BorderMode.NONE),
+            ("horizontal", ArrowProto.BorderMode.HORIZONTAL),
+        ]
+    )
+    def test_table_border_parameter(self, border, expected):
+        """Test that st.table border parameter converts values correctly."""
+        df = mock_data_frame()
+        st.table(df, border=border)
+        proto = self.get_delta_from_queue().new_element.arrow_table
+        assert proto.border_mode == expected
+
+    def test_table_border_invalid_value(self):
+        """Test that st.table raises StreamlitValueError for invalid border values."""
+        df = mock_data_frame()
+
+        with pytest.raises(
+            StreamlitValueError,
+            match=r"Invalid `border` value.*True, False, 'horizontal'",
+        ):
+            st.table(df, border="invalid")
diff --git a/proto/streamlit/proto/Arrow.proto b/proto/streamlit/proto/Arrow.proto
index cab48ea4a..20b7dee27 100644
--- a/proto/streamlit/proto/Arrow.proto
+++ b/proto/streamlit/proto/Arrow.proto
@@ -46,6 +46,9 @@ message Arrow {
   repeated SelectionMode selection_mode = 12;
   // Row height in pixels
   optional uint32 row_height = 13;
+  // How to show borders around the table and between cells. Note that this property
+  // is only used for `st.table` at the moment.
+  BorderMode border_mode = 14;
 
   // Available editing modes:
   enum EditingMode {
@@ -54,7 +57,7 @@ message Arrow {
     DYNAMIC = 2; // Activates editing and allow adding & deleting rows.
   }
 
-  // Available editing modes:
+  // Available selection modes:
   enum SelectionMode {
     SINGLE_ROW = 0; // Only one row can be selected at a time.
     MULTI_ROW = 1; // Multiple rows can be selected at a time.
@@ -63,6 +66,13 @@ message Arrow {
     SINGLE_CELL = 4; // Only one cell can be selected at a time.
     MULTI_CELL = 5; // Multiple cells (continuous range) can be selected.
   }
+
+  // Available border modes:
+  enum BorderMode {
+    ALL = 0; // Show borders around the table and between cells.
+    NONE = 1; // Show no borders.
+    HORIZONTAL = 2; // Show only horizontal borders between rows.
+  }
 }
 
 message Styler {
