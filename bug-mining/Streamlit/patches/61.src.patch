diff --git a/e2e_playwright/__snapshots__/linux/st_dialog_test/st_dialog-with_inline_error[chromium].png b/e2e_playwright/__snapshots__/linux/st_dialog_test/st_dialog-with_inline_error[chromium].png
index a804b5fc9..2fb021121 100644
Binary files a/e2e_playwright/__snapshots__/linux/st_dialog_test/st_dialog-with_inline_error[chromium].png and b/e2e_playwright/__snapshots__/linux/st_dialog_test/st_dialog-with_inline_error[chromium].png differ
diff --git a/e2e_playwright/__snapshots__/linux/st_experimental_fragment_chat_response_test/chart_after_fragment_rerun[chromium].png b/e2e_playwright/__snapshots__/linux/st_fragment_chat_response_test/chart_after_fragment_rerun[chromium].png
similarity index 100%
rename from e2e_playwright/__snapshots__/linux/st_experimental_fragment_chat_response_test/chart_after_fragment_rerun[chromium].png
rename to e2e_playwright/__snapshots__/linux/st_fragment_chat_response_test/chart_after_fragment_rerun[chromium].png
diff --git a/e2e_playwright/__snapshots__/linux/st_experimental_fragment_chat_response_test/chart_before_fragment_rerun[chromium].png b/e2e_playwright/__snapshots__/linux/st_fragment_chat_response_test/chart_before_fragment_rerun[chromium].png
similarity index 100%
rename from e2e_playwright/__snapshots__/linux/st_experimental_fragment_chat_response_test/chart_before_fragment_rerun[chromium].png
rename to e2e_playwright/__snapshots__/linux/st_fragment_chat_response_test/chart_before_fragment_rerun[chromium].png
diff --git a/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py b/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
index de812eec7..da1539803 100644
--- a/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
+++ b/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
@@ -56,7 +56,7 @@ def page_9():
 def page_10():
     st.header("Page 10")
 
-    @st.experimental_fragment
+    @st.fragment
     def get_input():
         st.text_input("Some input")
         if st.button("Submit"):
diff --git a/e2e_playwright/st_altair_chart_basic_select.py b/e2e_playwright/st_altair_chart_basic_select.py
index e232e6bc3..89fdb5116 100644
--- a/e2e_playwright/st_altair_chart_basic_select.py
+++ b/e2e_playwright/st_altair_chart_basic_select.py
@@ -272,7 +272,7 @@ selection = st.altair_chart(
 st.header("Selections in fragment:")
 
 
-@st.experimental_fragment
+@st.fragment
 def test_fragment():
     selection = st.altair_chart(
         histogram_point,
diff --git a/e2e_playwright/st_color_picker.py b/e2e_playwright/st_color_picker.py
index b35752a78..800411078 100644
--- a/e2e_playwright/st_color_picker.py
+++ b/e2e_playwright/st_color_picker.py
@@ -46,7 +46,7 @@ if "color_picker_form" in st.session_state:
     )
 
 
-@st.experimental_fragment()
+@st.fragment
 def test_fragment():
     selection = st.color_picker("Fragment Color Picker")
     st.write("color_picker-in-fragment selection:", str(selection))
diff --git a/e2e_playwright/st_dataframe_selections.py b/e2e_playwright/st_dataframe_selections.py
index fda82afcd..5d48cbb4e 100644
--- a/e2e_playwright/st_dataframe_selections.py
+++ b/e2e_playwright/st_dataframe_selections.py
@@ -137,7 +137,7 @@ st.dataframe(
 st.header("Selections in fragment:")
 
 
-@st.experimental_fragment()
+@st.fragment
 def test_fragment():
     selection = st.dataframe(
         df,
diff --git a/e2e_playwright/st_dialog.py b/e2e_playwright/st_dialog.py
index 812494b5d..935c972c1 100644
--- a/e2e_playwright/st_dialog.py
+++ b/e2e_playwright/st_dialog.py
@@ -16,6 +16,7 @@ import numpy as np
 import pandas as pd
 
 import streamlit as st
+from streamlit.runtime.scriptrunner.script_run_context import get_script_run_ctx
 
 
 @st.experimental_dialog("Test Dialog with Images")
@@ -90,6 +91,19 @@ with st.sidebar:
         dialog_in_sidebar()
 
 
+@st.experimental_dialog("Submit-button Dialog")
+def submit_button_dialog():
+    st.write("This dialog has a submit button.")
+    st.write(f"Fragment Id: {get_script_run_ctx().current_fragment_id}")
+
+    if st.button("Submit", key="dialog6-btn"):
+        st.rerun()
+
+
+if st.button("Open submit-button Dialog"):
+    submit_button_dialog()
+
+
 @st.experimental_dialog("Level2 Dialog")
 def level2_dialog():
     st.write("Second level dialog")
@@ -98,6 +112,7 @@ def level2_dialog():
 @st.experimental_dialog("Level1 Dialog")
 def level1_dialog():
     st.write("First level dialog")
+    st.write(f"Fragment Id: {get_script_run_ctx().current_fragment_id}")
     level2_dialog()
 
 
diff --git a/e2e_playwright/st_dialog_test.py b/e2e_playwright/st_dialog_test.py
index 480645b2f..01e06511e 100644
--- a/e2e_playwright/st_dialog_test.py
+++ b/e2e_playwright/st_dialog_test.py
@@ -16,6 +16,7 @@ import pytest
 from playwright.sync_api import Page, expect
 
 from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
+from e2e_playwright.shared.app_utils import get_markdown
 
 modal_test_id = "stModal"
 
@@ -46,6 +47,14 @@ def open_dialog_with_internal_error(app: Page):
     app.get_by_role("button").filter(has_text="Open Dialog with Key Error").click()
 
 
+def open_nested_dialogs(app: Page):
+    app.get_by_role("button").filter(has_text="Open Nested Dialogs").click()
+
+
+def open_submit_button_dialog(app: Page):
+    app.get_by_role("button").filter(has_text="Open submit-button Dialog").click()
+
+
 def click_to_dismiss(app: Page):
     # Click somewhere outside the close popover container:
     app.keyboard.press("Escape")
@@ -74,7 +83,7 @@ def test_dialog_closes_properly(app: Page):
 
 
 def test_dialog_dismisses_properly(app: Page):
-    """Test that dialog is dismissed properly after clicking on modal close (= dismiss)."""
+    """Test that dialog is dismissed properly after clicking on close (= dismiss)."""
     open_dialog_with_images(app)
     wait_for_app_run(app)
     main_dialog = app.get_by_test_id(modal_test_id)
@@ -86,7 +95,8 @@ def test_dialog_dismisses_properly(app: Page):
     expect(main_dialog).to_have_count(0)
 
 
-# on webkit this test was flaky and manually reproducing the flaky error did not work, so we skip it for now
+# on webkit this test was flaky and manually reproducing the flaky error did not work,
+# so we skip it for now
 @pytest.mark.skip_browser("webkit")
 def test_dialog_reopens_properly_after_dismiss(app: Page):
     """Test that dialog reopens after dismiss."""
@@ -98,8 +108,8 @@ def test_dialog_reopens_properly_after_dismiss(app: Page):
 
         main_dialog = app.get_by_test_id(modal_test_id)
 
-        # sometimes the dialog does not seem to open in the test, so retry opening it by clicking on it.
-        # if it does not open after the second attempt, fail the test.
+        # sometimes the dialog does not seem to open in the test, so retry opening it by
+        # clicking on it. if it does not open after the second attempt, fail the test.
         if main_dialog.count() == 0:
             app.wait_for_timeout(100)
             open_dialog_without_images(app)
@@ -164,7 +174,7 @@ def test_fullscreen_is_disabled_for_dialog_elements(app: Page):
 
 
 def test_actions_for_dialog_headings(app: Page):
-    """Test that headings within the dialog show the tooltip icon but not the link icon."""
+    """Test that dialog headings show the tooltip icon but not the link icon."""
     open_headings_dialogs(app)
     wait_for_app_run(app)
     main_dialog = app.get_by_test_id(modal_test_id)
@@ -188,7 +198,8 @@ def test_dialog_displays_correctly(app: Page, assert_snapshot: ImageCompareFunct
     open_dialog_without_images(app)
     wait_for_app_run(app)
     dialog = app.get_by_role("dialog")
-    # click on the dialog title to take away focus of all elements and make the screenshot stable. Then hover over the button for visual effect.
+    # click on the dialog title to take away focus of all elements and make the
+    # screenshot stable. Then hover over the button for visual effect.
     dialog.locator("div", has_text="Simple Dialog").click()
     submit_button = dialog.get_by_test_id("stButton")
     expect(submit_button).to_be_visible()
@@ -202,7 +213,8 @@ def test_largewidth_dialog_displays_correctly(
     open_largewidth_dialog(app)
     wait_for_app_run(app)
     dialog = app.get_by_role("dialog")
-    # click on the dialog title to take away focus of all elements and make the screenshot stable. Then hover over the button for visual effect.
+    # click on the dialog title to take away focus of all elements and make the
+    # screenshot stable. Then hover over the button for visual effect.
     dialog.locator("div", has_text="Large-width Dialog").click()
     submit_button = dialog.get_by_test_id("stButton")
     expect(submit_button).to_be_visible()
@@ -210,14 +222,17 @@ def test_largewidth_dialog_displays_correctly(
     assert_snapshot(dialog, name="st_dialog-with_large_width")
 
 
-# its enough to test this on one browser as showing the error inline is more a backend functionality than a frontend one
+# its enough to test this on one browser as showing the error inline is more a backend
+# functionality than a frontend one
 @pytest.mark.only_browser("chromium")
 def test_dialog_shows_error_inline(app: Page, assert_snapshot: ImageCompareFunction):
-    """Additional check to the unittests we have to ensure errors thrown during the main script execution (not a fragment-only rerun) are rendered within the dialog."""
+    """Additional check to the unittests we have to ensure errors thrown during the main
+    script execution (not a fragment-only rerun) are rendered within the dialog."""
     open_dialog_with_internal_error(app)
     wait_for_app_run(app)
     dialog = app.get_by_role("dialog")
-    # click on the dialog title to take away focus of all elements and make the screenshot stable. Then hover over the button for visual effect.
+    # click on the dialog title to take away focus of all elements and make the
+    # screenshot stable. Then hover over the button for visual effect.
     dialog.locator("div", has_text="Dialog with error").click()
     expect(dialog.get_by_text("TypeError")).to_be_visible()
     assert_snapshot(dialog, name="st_dialog-with_inline_error")
@@ -231,17 +246,57 @@ def test_sidebar_dialog_displays_correctly(
     dialog = app.get_by_role("dialog")
     submit_button = dialog.get_by_test_id("stButton")
     expect(submit_button).to_be_visible()
-    # ensure focus of the button to avoid flakiness where sometimes snapshots are made when the button is not in focus
+    # ensure focus of the button to avoid flakiness where sometimes snapshots are made
+    # when the button is not in focus
     submit_button.get_by_test_id("baseButton-secondary").hover()
     assert_snapshot(dialog, name="st_dialog-in_sidebar")
 
 
 def test_nested_dialogs(app: Page):
     """Test that st.dialog may not be nested inside other dialogs."""
-    app.get_by_text("Open Nested Dialogs").click()
+    open_nested_dialogs(app)
     wait_for_app_run(app)
     exception_message = app.get_by_test_id("stException")
 
     expect(exception_message).to_contain_text(
         "StreamlitAPIException: Dialogs may not be nested inside other dialogs."
     )
+
+
+# on webkit this test was flaky and manually reproducing the flaky error did not work,
+# so we skip it for now
+@pytest.mark.skip_browser("webkit")
+def test_dialogs_have_different_fragment_ids(app: Page):
+    """Test that st.dialog may not be nested inside other dialogs."""
+    open_submit_button_dialog(app)
+    wait_for_app_run(app)
+    large_width_dialog_fragment_id = get_markdown(app, "Fragment Id:").text_content()
+    dialog = app.get_by_role("dialog")
+    submit_button = dialog.get_by_test_id("stButton")
+    expect(submit_button).to_be_visible()
+    submit_button.get_by_test_id("baseButton-secondary").click()
+    wait_for_app_run(app)
+
+    open_nested_dialogs(app)
+    wait_for_app_run(app)
+    nested_dialog_fragment_id = get_markdown(app, "Fragment Id:").text_content()
+    exception_message = app.get_by_test_id("stException")
+    expect(exception_message).to_contain_text(
+        "StreamlitAPIException: Dialogs may not be nested inside other dialogs."
+    )
+    click_to_dismiss(app)
+    # wait after dismiss so that we can open the next dialog
+    app.wait_for_timeout(200)
+    expect(app.get_by_test_id(modal_test_id)).not_to_be_attached()
+    open_submit_button_dialog(app)
+    wait_for_app_run(app)
+    dialog = app.get_by_role("dialog")
+    submit_button = dialog.get_by_test_id("stButton")
+    expect(submit_button).to_be_visible()
+    submit_button.get_by_test_id("baseButton-secondary").click()
+    wait_for_app_run(app)
+
+    exception_message = app.get_by_test_id("stException")
+    expect(exception_message).not_to_be_attached()
+
+    assert large_width_dialog_fragment_id != nested_dialog_fragment_id
diff --git a/e2e_playwright/st_experimental_fragment_multiple_fragments_test.py b/e2e_playwright/st_experimental_fragment_multiple_fragments_test.py
deleted file mode 100644
index a35433b42..000000000
--- a/e2e_playwright/st_experimental_fragment_multiple_fragments_test.py
+++ /dev/null
@@ -1,46 +0,0 @@
-# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-from playwright.sync_api import Page, expect
-
-from e2e_playwright.conftest import wait_for_app_run
-
-
-def get_uuids(app: Page):
-    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)
-
-    fragment_1_text = app.get_by_test_id("stMarkdown").first.text_content()
-    fragment_2_text = app.get_by_test_id("stMarkdown").last.text_content()
-
-    return fragment_1_text, fragment_2_text
-
-
-def test_fragments_run_independently(app: Page):
-    fragment_1_text, fragment_2_text = get_uuids(app)
-
-    # Click the first button and verify that only the uuid in the first fragment
-    # changed.
-    app.get_by_test_id("stButton").locator("button").first.click()
-    wait_for_app_run(app)
-    expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(fragment_1_text)
-    expect(app.get_by_test_id("stMarkdown").last).to_have_text(fragment_2_text)
-
-    fragment_1_text, fragment_2_text = get_uuids(app)
-
-    # Click the second button and verify that only the uuid in the second fragment
-    # changed.
-    app.get_by_test_id("stButton").locator("button").last.click()
-    wait_for_app_run(app)
-    expect(app.get_by_test_id("stMarkdown").first).to_have_text(fragment_1_text)
-    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(fragment_2_text)
diff --git a/e2e_playwright/st_experimental_fragment_basics.py b/e2e_playwright/st_fragment_basics.py
similarity index 98%
rename from e2e_playwright/st_experimental_fragment_basics.py
rename to e2e_playwright/st_fragment_basics.py
index 02b06b3df..340deb0a7 100644
--- a/e2e_playwright/st_experimental_fragment_basics.py
+++ b/e2e_playwright/st_fragment_basics.py
@@ -26,7 +26,7 @@ import streamlit as st
 # return values. We also don't test the camera_input, data_editor, and file_uploader
 # widgets as well as custom components here due to the disproportionate amount of work
 # required to do so.
-@st.experimental_fragment
+@st.fragment
 def my_big_fragment():
     st.button("a button")
     st.download_button("a download button", b"")
diff --git a/e2e_playwright/st_experimental_fragment_basics_test.py b/e2e_playwright/st_fragment_basics_test.py
similarity index 100%
rename from e2e_playwright/st_experimental_fragment_basics_test.py
rename to e2e_playwright/st_fragment_basics_test.py
diff --git a/e2e_playwright/st_experimental_fragment_chat_response.py b/e2e_playwright/st_fragment_chat_response.py
similarity index 98%
rename from e2e_playwright/st_experimental_fragment_chat_response.py
rename to e2e_playwright/st_fragment_chat_response.py
index cae5efba8..d88e0998c 100644
--- a/e2e_playwright/st_experimental_fragment_chat_response.py
+++ b/e2e_playwright/st_fragment_chat_response.py
@@ -34,7 +34,7 @@ st.line_chart(app_df, x="day", y=y)
 """
 
 
-@st.experimental_fragment
+@st.fragment
 def parse_and_exec(response):
     code_match = re.search(r"```python\n(.*)\n```", response, re.DOTALL)
     if code_match:
diff --git a/e2e_playwright/st_experimental_fragment_chat_response_test.py b/e2e_playwright/st_fragment_chat_response_test.py
similarity index 100%
rename from e2e_playwright/st_experimental_fragment_chat_response_test.py
rename to e2e_playwright/st_fragment_chat_response_test.py
diff --git a/e2e_playwright/st_experimental_fragment_dynamic_form.py b/e2e_playwright/st_fragment_dynamic_form.py
similarity index 98%
rename from e2e_playwright/st_experimental_fragment_dynamic_form.py
rename to e2e_playwright/st_fragment_dynamic_form.py
index d9165fc7d..ce2ed712a 100644
--- a/e2e_playwright/st_experimental_fragment_dynamic_form.py
+++ b/e2e_playwright/st_fragment_dynamic_form.py
@@ -24,7 +24,7 @@ states = {
 }
 
 
-@st.experimental_fragment
+@st.fragment
 def get_location():
     with st.container(border=True):
         st.subheader("Enter your location")
diff --git a/e2e_playwright/st_experimental_fragment_dynamic_form_test.py b/e2e_playwright/st_fragment_dynamic_form_test.py
similarity index 100%
rename from e2e_playwright/st_experimental_fragment_dynamic_form_test.py
rename to e2e_playwright/st_fragment_dynamic_form_test.py
diff --git a/e2e_playwright/st_fragment_mixed_execution_flow.py b/e2e_playwright/st_fragment_mixed_execution_flow.py
new file mode 100644
index 000000000..11c6e01db
--- /dev/null
+++ b/e2e_playwright/st_fragment_mixed_execution_flow.py
@@ -0,0 +1,41 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import time
+from uuid import uuid4
+
+import streamlit as st
+
+if "sleep_time" not in st.session_state:
+    st.session_state["sleep_time"] = 0
+sleep_time = st.session_state["sleep_time"]
+
+
+@st.fragment
+def my_fragment(n):
+    with st.container(border=True):
+        st.button("rerun this fragment", key=n)
+        st.write(f"uuid in fragment {n}: {uuid4()}")
+    # sleep here so that we have time to react to the flow
+    # and trigger buttons etc. before the fragment is finished
+    # and the next starts to render
+    time.sleep(sleep_time)
+
+
+my_fragment(1)
+my_fragment(2)
+my_fragment(3)
+
+st.session_state["sleep_time"] = 3
+st.button("Full app rerun")
diff --git a/e2e_playwright/st_fragment_mixed_execution_flow_test.py b/e2e_playwright/st_fragment_mixed_execution_flow_test.py
new file mode 100644
index 000000000..4f6978177
--- /dev/null
+++ b/e2e_playwright/st_fragment_mixed_execution_flow_test.py
@@ -0,0 +1,58 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from playwright.sync_api import Page, expect
+
+from e2e_playwright.conftest import wait_for_app_run
+
+
+def get_uuids(app: Page):
+    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)
+
+    fragment_1_text = app.get_by_test_id("stMarkdown").first.text_content()
+    fragment_2_text = app.get_by_test_id("stMarkdown").last.text_content()
+
+    return fragment_1_text, fragment_2_text
+
+
+def test_fragments_rerun_correctly_during_full_app_run(app: Page):
+    """Test that fragments can send fragment-bound reruns during full app runs.
+
+    Click on the full app rerun button and immediately click on the second
+    fragment button. This will send a rerun message bound to the fragment while
+    the full app run is still executing. The expectation is that the full app
+    run is still continuing and the following fragments are also registered
+    and executing correctly.
+    """
+
+    app.get_by_test_id("stButton").locator("button").filter(
+        has_text="Full app rerun"
+    ).click()
+
+    # wait until first fragment is finished
+    sleep_time_of_fragment = 3500
+    app.wait_for_timeout(sleep_time_of_fragment)
+
+    app.get_by_test_id("stButton").locator("button").nth(1).click()
+    wait_for_app_run(app)
+
+    expect(
+        app.get_by_test_id("stMarkdown").filter(has_text="uuid in fragment 1").first
+    ).to_be_attached()
+    expect(
+        app.get_by_test_id("stMarkdown").filter(has_text="uuid in fragment 2").first
+    ).to_be_attached()
+    expect(
+        app.get_by_test_id("stMarkdown").filter(has_text="uuid in fragment 3").first
+    ).to_be_attached()
diff --git a/e2e_playwright/st_experimental_fragment_multiple_fragments.py b/e2e_playwright/st_fragment_multiple_fragments.py
similarity index 69%
rename from e2e_playwright/st_experimental_fragment_multiple_fragments.py
rename to e2e_playwright/st_fragment_multiple_fragments.py
index 16c3cb8de..b466b24e7 100644
--- a/e2e_playwright/st_experimental_fragment_multiple_fragments.py
+++ b/e2e_playwright/st_fragment_multiple_fragments.py
@@ -16,13 +16,23 @@ from uuid import uuid4
 
 import streamlit as st
 
+raise_exception = st.checkbox("Raise Exception in Fragment", value=False)
 
-@st.experimental_fragment
+
+@st.fragment
 def my_fragment(n):
     with st.container(border=True):
         st.button("rerun this fragment", key=n)
         st.write(f"uuid in fragment {n}: {uuid4()}")
 
 
+@st.fragment
+def exception_raising_fragment():
+    if st.checkbox("Raise Exception", value=raise_exception):
+        raise RuntimeError("This is an exception raised in a fragment")
+
+
 my_fragment(1)
+# fragment that raises an exception during full app run stops the execution
+exception_raising_fragment()
 my_fragment(2)
diff --git a/e2e_playwright/st_fragment_multiple_fragments_test.py b/e2e_playwright/st_fragment_multiple_fragments_test.py
new file mode 100644
index 000000000..acd00d0ba
--- /dev/null
+++ b/e2e_playwright/st_fragment_multiple_fragments_test.py
@@ -0,0 +1,99 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from playwright.sync_api import Locator, Page, expect
+
+from e2e_playwright.conftest import wait_for_app_run
+
+
+def _get_uuids(app: Page, expected_markdown_count: int = 2):
+    """Test that fragments run and the uuids are written."""
+    expect(app.get_by_test_id("stMarkdown")).to_have_count(expected_markdown_count)
+
+    fragment_1_text = app.get_by_test_id("stMarkdown").first.text_content()
+    fragment_2_text = app.get_by_test_id("stMarkdown").last.text_content()
+
+    return fragment_1_text, fragment_2_text
+
+
+def _get_fragment_checkbox(app: Page) -> Locator:
+    return app.get_by_test_id("stCheckbox").nth(1).locator("span").first
+
+
+def _get_app_raise_exception_checkbox(app: Page) -> Locator:
+    return app.get_by_test_id("stCheckbox").nth(0).locator("span").first
+
+
+def test_fragments_run_independently(app: Page):
+    fragment_1_text, fragment_2_text = _get_uuids(app)
+
+    # Click the first button and verify that only the uuid in the first fragment
+    # changed.
+    app.get_by_test_id("stButton").locator("button").first.click()
+    wait_for_app_run(app)
+    expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(fragment_1_text)
+    expect(app.get_by_test_id("stMarkdown").last).to_have_text(fragment_2_text)
+
+    fragment_1_text, fragment_2_text = _get_uuids(app)
+
+    # Click the second button and verify that only the uuid in the second fragment
+    # changed.
+    app.get_by_test_id("stButton").locator("button").last.click()
+    wait_for_app_run(app)
+    expect(app.get_by_test_id("stMarkdown").first).to_have_text(fragment_1_text)
+    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(fragment_2_text)
+
+
+def test_fragment_exception_disappears_when_rerun(app: Page):
+    """Unselecting the checkbox should hide the exception message.
+    If this does not work, the reason might be that the exception is
+    written in the main app's delta path and a fragment rerun does not
+    remove the element.
+    """
+    fragment_1_text, fragment_2_text = _get_uuids(app)
+    wait_for_app_run(app)
+    assert fragment_1_text is not None
+    assert fragment_2_text is not None
+    assert fragment_1_text != fragment_2_text
+
+    # show exception
+    _get_fragment_checkbox(app).click()
+    expect(app.get_by_test_id("stException")).to_have_count(1)
+
+    # ensure that the fragment texts are still visible
+    fragment_1_text, fragment_2_text = _get_uuids(app)
+    wait_for_app_run(app)
+    assert fragment_1_text is not None
+    assert fragment_2_text is not None
+    assert fragment_1_text != fragment_2_text
+
+    # hide exception
+    _get_fragment_checkbox(app).click()
+    expect(app.get_by_test_id("stException")).to_have_count(0)
+
+
+def test_fragment_exception_during_full_app_run(app: Page):
+    fragment_1_text, fragment_2_text = _get_uuids(app)
+    wait_for_app_run(app)
+    assert fragment_1_text is not None
+    assert fragment_2_text is not None
+    assert fragment_1_text != fragment_2_text
+
+    _get_app_raise_exception_checkbox(app).click()
+    wait_for_app_run(app)
+    fragment_1_text, fragment_2_text = _get_uuids(app, expected_markdown_count=1)
+    expect(app.get_by_test_id("stException")).to_have_count(1)
+    # the second fragment did not run, so _get_uuids has returned
+    # the text for the first fragment twice
+    assert fragment_1_text == fragment_2_text
diff --git a/e2e_playwright/st_fragment_queue.py b/e2e_playwright/st_fragment_queue.py
new file mode 100644
index 000000000..78f7d383e
--- /dev/null
+++ b/e2e_playwright/st_fragment_queue.py
@@ -0,0 +1,45 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import time
+
+import streamlit as st
+
+
+@st.fragment
+def my_fragment1():
+    st.button("rerun fragment 1")
+    time.sleep(3)
+    st.write("fragment 1 done!")
+
+
+@st.fragment
+def my_fragment2():
+    if st.button("rerun fragment 2"):
+        st.write("ran fragment 2")
+    st.write("fragment 2 done!")
+
+
+@st.fragment
+def my_fragment3():
+    st.button("rerun fragment 3")
+    st.write("fragment 3 done!")
+
+
+with st.container(border=True):
+    my_fragment1()
+with st.container(border=True):
+    my_fragment2()
+with st.container(border=True):
+    my_fragment3()
diff --git a/e2e_playwright/st_fragment_queue_test.py b/e2e_playwright/st_fragment_queue_test.py
new file mode 100644
index 000000000..990da869d
--- /dev/null
+++ b/e2e_playwright/st_fragment_queue_test.py
@@ -0,0 +1,44 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from playwright.sync_api import Page, expect
+
+from e2e_playwright.conftest import wait_for_app_run
+from e2e_playwright.shared.app_utils import get_button, get_markdown
+
+
+def test_fragment_queue(app: Page):
+    # Sanity check:
+    expect(app.get_by_test_id("stMarkdown")).to_have_count(3)
+    get_markdown(app, "fragment 1 done!")
+    get_markdown(app, "fragment 2 done!")
+    get_markdown(app, "fragment 3 done!")
+
+    # Quickly click all 3 buttons on the page without waiting for the app to finish
+    # between each click.
+    for b in [
+        get_button(app, "rerun fragment 1"),
+        get_button(app, "rerun fragment 2"),
+        get_button(app, "rerun fragment 3"),
+    ]:
+        b.click()
+    wait_for_app_run(app)
+
+    # Verify that the second button click wasn't dropped by checking that
+    # "ran fragment 2" was indeed printed.
+    expect(app.get_by_test_id("stMarkdown")).to_have_count(4)
+    get_markdown(app, "fragment 1 done!")
+    get_markdown(app, "ran fragment 2")
+    get_markdown(app, "fragment 2 done!")
+    get_markdown(app, "fragment 3 done!")
diff --git a/e2e_playwright/st_experimental_fragment_run_every.py b/e2e_playwright/st_fragment_run_every.py
similarity index 94%
rename from e2e_playwright/st_experimental_fragment_run_every.py
rename to e2e_playwright/st_fragment_run_every.py
index 53209a782..c3231d6b7 100644
--- a/e2e_playwright/st_experimental_fragment_run_every.py
+++ b/e2e_playwright/st_fragment_run_every.py
@@ -17,7 +17,7 @@ from uuid import uuid4
 import streamlit as st
 
 
-@st.experimental_fragment(run_every=1.0)
+@st.fragment(run_every=1.0)
 def my_auto_updating_fragment():
     st.write(f"uuid in fragment: {uuid4()}")
 
diff --git a/e2e_playwright/st_experimental_fragment_run_every_test.py b/e2e_playwright/st_fragment_run_every_test.py
similarity index 100%
rename from e2e_playwright/st_experimental_fragment_run_every_test.py
rename to e2e_playwright/st_fragment_run_every_test.py
diff --git a/e2e_playwright/st_fragments_nested.py b/e2e_playwright/st_fragments_nested.py
new file mode 100644
index 000000000..d1b451de3
--- /dev/null
+++ b/e2e_playwright/st_fragments_nested.py
@@ -0,0 +1,37 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from uuid import uuid4
+
+import streamlit as st
+
+
+@st.fragment
+def outer_fragment():
+    with st.container(border=True):
+        st.write(f"outer fragment: {uuid4()}")
+        st.button("rerun outer fragment")
+        inner_fragment()
+
+
+@st.fragment
+def inner_fragment():
+    with st.container(border=True):
+        st.write(f"inner fragment: {uuid4()}")
+        st.button("rerun inner fragment")
+
+
+st.write(f"outside all fragments: {uuid4()}")
+st.button("rerun whole app")
+outer_fragment()
diff --git a/e2e_playwright/st_fragments_nested_test.py b/e2e_playwright/st_fragments_nested_test.py
new file mode 100644
index 000000000..d113ef0f6
--- /dev/null
+++ b/e2e_playwright/st_fragments_nested_test.py
@@ -0,0 +1,67 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+from playwright.sync_api import Page, expect
+
+from e2e_playwright.shared.app_utils import click_button
+
+
+def get_uuids(app: Page):
+    expect(app.get_by_test_id("stMarkdown")).to_have_count(3)
+
+    outside_fragment_text = app.get_by_test_id("stMarkdown").first.text_content()
+    outer_fragment_text = app.get_by_test_id("stMarkdown").nth(1).text_content()
+    inner_fragment_text = app.get_by_test_id("stMarkdown").last.text_content()
+
+    return outside_fragment_text, outer_fragment_text, inner_fragment_text
+
+
+def test_full_app_rerun(app: Page):
+    outside_fragment_text, outer_fragment_text, inner_fragment_text = get_uuids(app)
+
+    click_button(app, "rerun whole app")
+
+    # The full app reran, so all of the UUIDs in the app should have changed.
+    expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(
+        outside_fragment_text
+    )
+    expect(app.get_by_test_id("stMarkdown").nth(1)).not_to_have_text(
+        outer_fragment_text
+    )
+    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(inner_fragment_text)
+
+
+def test_outer_fragment_rerun(app: Page):
+    outside_fragment_text, outer_fragment_text, inner_fragment_text = get_uuids(app)
+
+    click_button(app, "rerun outer fragment")
+
+    # We reran the outer fragment, so the UUID outside of the fragments should stay
+    # constant, but the other two should have changed.
+    expect(app.get_by_test_id("stMarkdown").first).to_have_text(outside_fragment_text)
+    expect(app.get_by_test_id("stMarkdown").nth(1)).not_to_have_text(
+        outer_fragment_text
+    )
+    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(inner_fragment_text)
+
+
+def test_inner_fragment_rerun(app: Page):
+    outside_fragment_text, outer_fragment_text, inner_fragment_text = get_uuids(app)
+
+    click_button(app, "rerun inner fragment")
+
+    # We reran the inner fragment. Only that corresponding UUID should have changed.
+    expect(app.get_by_test_id("stMarkdown").first).to_have_text(outside_fragment_text)
+    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(outer_fragment_text)
+    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(inner_fragment_text)
diff --git a/e2e_playwright/st_rerun.py b/e2e_playwright/st_rerun.py
index ae8c9220e..6a34097a6 100644
--- a/e2e_playwright/st_rerun.py
+++ b/e2e_playwright/st_rerun.py
@@ -14,17 +14,31 @@
 
 import streamlit as st
 
+if "count" not in st.session_state:
+    st.session_state.count = 0
+    st.session_state.fragment_count = 0
 
-@st.cache_resource
-def rerun_record():
-    return [0]
 
+@st.fragment
+def my_fragment():
+    if st.button("rerun fragment"):
+        st.session_state.fragment_count += 1
+        st.rerun(scope="fragment")
 
-count = rerun_record()
-count[0] += 1
+    st.write(f"fragment run count: {st.session_state.fragment_count}")
 
-if count[0] < 4:
+    if st.session_state.fragment_count % 5 != 0:
+        st.session_state.fragment_count += 1
+        st.rerun(scope="fragment")
+
+
+st.session_state.count += 1
+
+if st.session_state.count < 4:
     st.rerun()
 
-if count[0] >= 4:
+if st.session_state.count >= 4:
     st.text("Being able to rerun a session is awesome!")
+
+my_fragment()
+st.write(f"app run count: {st.session_state.count}")
diff --git a/e2e_playwright/st_rerun_test.py b/e2e_playwright/st_rerun_test.py
index 1178bb8f2..6858a13e8 100644
--- a/e2e_playwright/st_rerun_test.py
+++ b/e2e_playwright/st_rerun_test.py
@@ -14,8 +14,26 @@
 
 from playwright.sync_api import Page, expect
 
+from e2e_playwright.shared.app_utils import click_button
+
 
 def test_st_rerun_restarts_the_session_when_invoked(app: Page):
     expect(app.get_by_test_id("stText")).to_have_text(
         "Being able to rerun a session is awesome!"
     )
+
+
+def test_fragment_scoped_st_rerun(app: Page):
+    expect(app.get_by_test_id("stText")).to_have_text(
+        "Being able to rerun a session is awesome!"
+    )
+
+    click_button(app, "rerun fragment")
+    expect(app.get_by_test_id("stMarkdown").first).to_have_text("fragment run count: 5")
+    expect(app.get_by_test_id("stMarkdown").last).to_have_text("app run count: 4")
+
+    click_button(app, "rerun fragment")
+    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
+        "fragment run count: 10"
+    )
+    expect(app.get_by_test_id("stMarkdown").last).to_have_text("app run count: 4")
diff --git a/e2e_playwright/st_select_slider.py b/e2e_playwright/st_select_slider.py
index 0e7436fb6..ffda7e394 100644
--- a/e2e_playwright/st_select_slider.py
+++ b/e2e_playwright/st_select_slider.py
@@ -119,7 +119,7 @@ with st.form(key="my_form", clear_on_submit=True):
 st.write("select_slider-in-form selection:", str(selection))
 
 
-@st.experimental_fragment()
+@st.fragment
 def test_fragment():
     selection = st.select_slider(
         label="Label 11 (fragment)",
diff --git a/e2e_playwright/st_slider.py b/e2e_playwright/st_slider.py
index e41af7d75..07f0348b8 100644
--- a/e2e_playwright/st_slider.py
+++ b/e2e_playwright/st_slider.py
@@ -100,7 +100,7 @@ with st.form(key="my_form", clear_on_submit=True):
 st.write("slider-in-form selection:", str(selection))
 
 
-@st.experimental_fragment()
+@st.fragment
 def test_fragment():
     selection = st.slider(
         "Label 10",
diff --git a/lib/streamlit/__init__.py b/lib/streamlit/__init__.py
index 7cda62d0b..6fce6da3a 100644
--- a/lib/streamlit/__init__.py
+++ b/lib/streamlit/__init__.py
@@ -81,7 +81,10 @@ from streamlit.runtime.caching import (
 from streamlit.runtime.connection_factory import (
     connection_factory as _connection,
 )
-from streamlit.runtime.fragment import fragment as _fragment
+from streamlit.runtime.fragment import (
+    experimental_fragment as _experimental_fragment,
+    fragment as _fragment,
+)
 from streamlit.runtime.metrics_util import gather_metrics as _gather_metrics
 from streamlit.runtime.secrets import secrets_singleton as _secrets_singleton
 from streamlit.runtime.context import ContextProxy as _ContextProxy
@@ -235,9 +238,17 @@ column_config = _column_config
 # Connection
 connection = _connection
 
+# Fragment and dialog
+fragment = _fragment
+
 # Experimental APIs
 experimental_dialog = _dialog_decorator
-experimental_fragment = _fragment
+experimental_fragment = _deprecate_func_name(
+    _experimental_fragment,
+    "experimental_fragment",
+    "2025-01-01",
+    name_override="fragment",
+)
 experimental_user = _UserInfoProxy()
 
 _EXPERIMENTAL_QUERY_PARAMS_DEPRECATE_MSG = "Refer to our [docs page](https://docs.streamlit.io/develop/api-reference/caching-and-state/st.query_params) for more information."
diff --git a/lib/streamlit/commands/execution_control.py b/lib/streamlit/commands/execution_control.py
index 1fc44022b..a7598c048 100644
--- a/lib/streamlit/commands/execution_control.py
+++ b/lib/streamlit/commands/execution_control.py
@@ -15,7 +15,8 @@
 from __future__ import annotations
 
 import os
-from typing import Final, NoReturn
+from itertools import dropwhile
+from typing import Final, Literal, NoReturn
 
 import streamlit as st
 from streamlit.errors import NoSessionContext, StreamlitAPIException
@@ -23,7 +24,11 @@ from streamlit.file_util import get_main_script_directory, normalize_path_join
 from streamlit.logger import get_logger
 from streamlit.navigation.page import StreamlitPage
 from streamlit.runtime.metrics_util import gather_metrics
-from streamlit.runtime.scriptrunner import RerunData, get_script_run_ctx
+from streamlit.runtime.scriptrunner import (
+    RerunData,
+    ScriptRunContext,
+    get_script_run_ctx,
+)
 
 _LOGGER: Final = get_logger(__name__)
 
@@ -54,22 +59,76 @@ def stop() -> NoReturn:  # type: ignore[misc]
         st.empty()
 
 
+def _new_fragment_id_queue(
+    ctx: ScriptRunContext,
+    scope: Literal["app", "fragment"],
+) -> list[str]:
+    if scope == "app":
+        return []
+
+    else:  # scope == "fragment"
+        curr_queue = (
+            ctx.script_requests.fragment_id_queue if ctx.script_requests else []
+        )
+
+        # If st.rerun(scope="fragment") is called during a full script run, we raise an
+        # exception. This occurs, of course, if st.rerun(scope="fragment") is called
+        # outside of a fragment, but it somewhat surprisingly occurs if it gets called
+        # from within a fragment during a run of the full script. While this behvior may
+        # be surprising, it seems somewhat reasonable given that the correct behavior of
+        # calling st.rerun(scope="fragment") in this situation is unclear to me:
+        #   * Rerunning just the fragment immediately may cause weirdness down the line
+        #     as any part of the script that occurs after the fragment will not be
+        #     executed.
+        #   * Waiting until the full script run completes before rerunning the fragment
+        #     seems odd (even if we normally do this before running a fragment not
+        #     triggered by st.rerun()) because it defers the execution of st.rerun().
+        #   * Rerunning the full app feels incorrect as we're seemingly ignoring the
+        #     `scope` argument.
+        # With these issues and given that it seems pretty unnatural to have a
+        # fragment-scoped rerun happen during a full script run to begin with, it seems
+        # reasonable to just disallow this completely for now.
+        if not curr_queue:
+            raise StreamlitAPIException(
+                'scope="fragment" can only be specified from `@st.fragment`-decorated '
+                "functions during fragment reruns."
+            )
+
+        assert (
+            new_queue := list(
+                dropwhile(lambda x: x != ctx.current_fragment_id, curr_queue)
+            )
+        ), "Could not find current_fragment_id in fragment_id_queue. This should never happen."
+
+        return new_queue
+
+
 @gather_metrics("rerun")
-def rerun() -> NoReturn:  # type: ignore[misc]
+def rerun(  # type: ignore[misc]
+    *,  # The scope argument can only be passed via keyword.
+    scope: Literal["app", "fragment"] = "app",
+) -> NoReturn:
     """Rerun the script immediately.
 
     When ``st.rerun()`` is called, the script is halted - no more statements will
-    be run, and the script will be queued to re-run from the top.
+    be run, and the script will be queued to re-run.
+
+    Parameters
+    ----------
+    scope : Literal["app", "fragment"]
+        Specifies what part of the app should rerun. Setting scope="app" reruns the
+        full script; scope="fragment" limits the rerun to only the fragment from which
+        this function is called. If unspecified, defaults to "app".
+
+        Note that setting scope="fragment" is only valid
+            * inside of a fragment
+            * *not* during a full script run.
+        Passing this argument to ``st.rerun()`` from outside of a fragment or within a
+        fragment but when the full script is running raises a ``StreamlitAPIException``.
     """
 
     ctx = get_script_run_ctx()
 
-    # TODO: (rerun[scope] project): in order to make it a fragment-scoped rerun, pass
-    # the fragment_id_queue to the RerunData object and add the following line:
-    # fragment_id_queue=[ctx.current_fragment_id] if scope == "fragment" else []
-    # The script_runner RerunException is checking for the fragment_id_queue to decide
-    # whether or not to reset the dg_stack.
-
     if ctx and ctx.script_requests:
         query_string = ctx.query_string
         page_script_hash = ctx.page_script_hash
@@ -78,6 +137,8 @@ def rerun() -> NoReturn:  # type: ignore[misc]
             RerunData(
                 query_string=query_string,
                 page_script_hash=page_script_hash,
+                fragment_id_queue=_new_fragment_id_queue(ctx, scope),
+                is_fragment_scoped_rerun=True,
             )
         )
         # Force a yield point so the runner can do the rerun
diff --git a/lib/streamlit/delta_generator.py b/lib/streamlit/delta_generator.py
index 78b3261c1..063b5c385 100644
--- a/lib/streamlit/delta_generator.py
+++ b/lib/streamlit/delta_generator.py
@@ -441,9 +441,9 @@ class DeltaGenerator(
         ctx = get_script_run_ctx()
         if ctx and ctx.current_fragment_id and _writes_directly_to_sidebar(dg):
             raise StreamlitAPIException(
-                "Calling `st.sidebar` in a function wrapped with `st.experimental_fragment` "
-                "is not supported. To write elements to the sidebar with a fragment, "
-                "call your fragment function inside a `with st.sidebar` context manager."
+                "Calling `st.sidebar` in a function wrapped with `st.fragment` is not "
+                "supported. To write elements to the sidebar with a fragment, call your "
+                "fragment function inside a `with st.sidebar` context manager."
             )
 
         # Warn if an element is being changed but the user isn't running the streamlit server.
diff --git a/lib/streamlit/elements/dialog_decorator.py b/lib/streamlit/elements/dialog_decorator.py
index d713f8c62..7a21cf358 100644
--- a/lib/streamlit/elements/dialog_decorator.py
+++ b/lib/streamlit/elements/dialog_decorator.py
@@ -72,7 +72,12 @@ def _dialog_decorator(
             return None
 
         # the fragment decorator has multiple return types so that you can pass arguments to it. Here we know the return type, so we cast
-        fragmented_dialog_content = cast(Callable[[], None], _fragment(dialog_content))
+        fragmented_dialog_content = cast(
+            Callable[[], None],
+            _fragment(
+                dialog_content, additional_hash_info=non_optional_func.__qualname__
+            ),
+        )
         with dialog:
             fragmented_dialog_content()
             return None
@@ -115,7 +120,7 @@ def dialog_decorator(
     dialog programmatically, call ``st.rerun()`` explicitly inside of the
     dialog function.
 
-    ``st.experimental_dialog`` inherits behavior from |st.experimental_fragment|_.
+    ``st.experimental_dialog`` inherits behavior from |st.fragment|_.
     When a user interacts with an input widget created inside a dialog function,
     Streamlit only reruns the dialog function instead of the full script.
 
@@ -133,8 +138,8 @@ def dialog_decorator(
         fragments, and fragments can't contain dialogs. Using dialogs in widget
         callback functions is not supported.
 
-    .. |st.experimental_fragment| replace:: ``st.experimental_fragment``
-    .. _st.experimental_fragment: https://docs.streamlit.io/develop/api-reference/execution-flow/st.fragment
+    .. |st.fragment| replace:: ``st.fragment``
+    .. _st.fragment: https://docs.streamlit.io/develop/api-reference/execution-flow/st.fragment
 
     Parameters
     ----------
diff --git a/lib/streamlit/errors.py b/lib/streamlit/errors.py
index ed8230e2f..94d6266cd 100644
--- a/lib/streamlit/errors.py
+++ b/lib/streamlit/errors.py
@@ -38,6 +38,21 @@ class DeprecationError(Error):
     pass
 
 
+class FragmentStorageKeyError(Error, KeyError):
+    """A KeyError raised when a KeyError is encountered during a FragmentStorage
+    operation."""
+
+    pass
+
+
+class FragmentHandledException(Exception):
+    """An exception that is raised by the fragment
+    when it has handled the exception itself.
+    """
+
+    pass
+
+
 class NoStaticFiles(Error):
     pass
 
diff --git a/lib/streamlit/runtime/app_session.py b/lib/streamlit/runtime/app_session.py
index b379b929b..f5513ca5c 100644
--- a/lib/streamlit/runtime/app_session.py
+++ b/lib/streamlit/runtime/app_session.py
@@ -122,6 +122,7 @@ class AppSession:
             service that a Streamlit Runtime is running in wants to tie the lifecycle of
             a Streamlit session to some other session-like object that it manages.
         """
+
         # Each AppSession has a unique string ID.
         self.id = session_id_override or str(uuid.uuid4())
 
@@ -361,7 +362,7 @@ class AppSession:
                 client_state.widget_states,
                 client_state.page_script_hash,
                 client_state.page_name,
-                fragment_id_queue=[fragment_id] if fragment_id else [],
+                fragment_id=fragment_id if fragment_id else None,
             )
         else:
             rerun_data = RerunData()
@@ -369,7 +370,7 @@ class AppSession:
         if self._scriptrunner is not None:
             if (
                 bool(config.get_option("runner.fastReruns"))
-                and not rerun_data.fragment_id_queue
+                and not rerun_data.fragment_id
             ):
                 # If fastReruns is enabled and this is *not* a rerun of a fragment,
                 # we don't send rerun requests to our existing ScriptRunner. Instead, we
@@ -477,8 +478,9 @@ class AppSession:
         exception: BaseException | None = None,
         client_state: ClientState | None = None,
         page_script_hash: str | None = None,
-        fragment_ids_this_run: set[str] | None = None,
+        fragment_ids_this_run: list[str] | None = None,
         pages: dict[PageHash, PageInfo] | None = None,
+        clear_forward_msg_queue: bool = True,
     ) -> None:
         """Called when our ScriptRunner emits an event.
 
@@ -496,6 +498,7 @@ class AppSession:
                 page_script_hash,
                 fragment_ids_this_run,
                 pages,
+                clear_forward_msg_queue,
             )
         )
 
@@ -507,8 +510,9 @@ class AppSession:
         exception: BaseException | None = None,
         client_state: ClientState | None = None,
         page_script_hash: str | None = None,
-        fragment_ids_this_run: set[str] | None = None,
+        fragment_ids_this_run: list[str] | None = None,
         pages: dict[PageHash, PageInfo] | None = None,
+        clear_forward_msg_queue: bool = True,
     ) -> None:
         """Handle a ScriptRunner event.
 
@@ -540,10 +544,14 @@ class AppSession:
             A hash of the script path corresponding to the page currently being
             run. Set only for the SCRIPT_STARTED event.
 
-        fragment_ids_this_run : set[str] | None
+        fragment_ids_this_run : list[str] | None
             The fragment IDs of the fragments being executed in this script run. Only
             set for the SCRIPT_STARTED event. If this value is falsy, this script run
             must be for the full script.
+
+        clear_forward_msg_queue : bool
+            If set (the default), clears the queue of forward messages to be sent to the
+            browser. Set only for the SCRIPT_STARTED event.
         """
 
         assert (
@@ -569,13 +577,7 @@ class AppSession:
                 page_script_hash is not None
             ), "page_script_hash must be set for the SCRIPT_STARTED event"
 
-            # When running the full script, we clear the browser ForwardMsg queue since
-            # anything from a previous script run that has yet to be sent to the browser
-            # will be overwritten. For fragment runs, however, we don't want to do this
-            # as the ForwardMsgs in the queue may not correspond to the running
-            # fragment, so dropping the messages may result in the app missing
-            # information.
-            if not fragment_ids_this_run:
+            if clear_forward_msg_queue:
                 self._clear_queue()
 
             self._enqueue_forward_msg(
@@ -677,7 +679,7 @@ class AppSession:
     def _create_new_session_message(
         self,
         page_script_hash: str,
-        fragment_ids_this_run: set[str] | None = None,
+        fragment_ids_this_run: list[str] | None = None,
         pages: dict[PageHash, PageInfo] | None = None,
     ) -> ForwardMsg:
         """Create and return a new_session ForwardMsg."""
diff --git a/lib/streamlit/runtime/forward_msg_queue.py b/lib/streamlit/runtime/forward_msg_queue.py
index 21b67ee27..54a7dadc3 100644
--- a/lib/streamlit/runtime/forward_msg_queue.py
+++ b/lib/streamlit/runtime/forward_msg_queue.py
@@ -98,6 +98,7 @@ class ForwardMsgQueue:
                 for msg in self._queue
                 if msg.WhichOneof("type")
                 in {
+                    "new_session",
                     "script_finished",
                     "session_status_changed",
                     "parent_message",
diff --git a/lib/streamlit/runtime/fragment.py b/lib/streamlit/runtime/fragment.py
index b63d5f92b..b75318398 100644
--- a/lib/streamlit/runtime/fragment.py
+++ b/lib/streamlit/runtime/fragment.py
@@ -22,22 +22,24 @@ from copy import deepcopy
 from functools import wraps
 from typing import TYPE_CHECKING, Any, Callable, Protocol, TypeVar, overload
 
+from streamlit.error_util import handle_uncaught_app_exception
+from streamlit.errors import FragmentHandledException, FragmentStorageKeyError
 from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
 from streamlit.runtime.metrics_util import gather_metrics
 from streamlit.runtime.scriptrunner import get_script_run_ctx
-from streamlit.runtime.scriptrunner.exec_code import exec_func_with_error_handling
+from streamlit.runtime.scriptrunner.exceptions import RerunException, StopException
 from streamlit.time_util import time_to_seconds
 
 if TYPE_CHECKING:
     from datetime import timedelta
 
+
 F = TypeVar("F", bound=Callable[..., Any])
 Fragment = Callable[[], Any]
 
 
 class FragmentStorage(Protocol):
-    """A key-value store for Fragments. Used to implement the @st.experimental_fragment
-    decorator.
+    """A key-value store for Fragments. Used to implement the @st.fragment decorator.
 
     We intentionally define this as its own protocol despite how generic it appears to
     be at first glance. The reason why is that, in any case where fragments aren't just
@@ -47,6 +49,14 @@ class FragmentStorage(Protocol):
     protocols.
     """
 
+    # Weirdly, we have to define this above the `set` method, or mypy gets it confused
+    # with the `set` type of `new_fragments_ids`.
+    @abstractmethod
+    def clear(self, new_fragment_ids: set[str] | None = None) -> None:
+        """Remove all fragments saved in this FragmentStorage unless listed in
+        new_fragment_ids."""
+        raise NotImplementedError
+
     @abstractmethod
     def get(self, key: str) -> Fragment:
         """Returns the stored fragment for the given key."""
@@ -63,8 +73,8 @@ class FragmentStorage(Protocol):
         raise NotImplementedError
 
     @abstractmethod
-    def clear(self) -> None:
-        """Remove all fragments saved in this FragmentStorage."""
+    def contains(self, key: str) -> bool:
+        """Return whether the given key is present in this FragmentStorage."""
         raise NotImplementedError
 
 
@@ -83,21 +93,42 @@ class MemoryFragmentStorage(FragmentStorage):
     def __init__(self):
         self._fragments: dict[str, Fragment] = {}
 
+    # Weirdly, we have to define this above the `set` method, or mypy gets it confused
+    # with the `set` type of `new_fragments_ids`.
+    def clear(self, new_fragment_ids: set[str] | None = None) -> None:
+        if new_fragment_ids is None:
+            new_fragment_ids = set()
+
+        fragment_ids = list(self._fragments.keys())
+
+        for fid in fragment_ids:
+            if fid not in new_fragment_ids:
+                del self._fragments[fid]
+
     def get(self, key: str) -> Fragment:
-        return self._fragments[key]
+        try:
+            return self._fragments[key]
+        except KeyError as e:
+            raise FragmentStorageKeyError(str(e))
 
     def set(self, key: str, value: Fragment) -> None:
         self._fragments[key] = value
 
     def delete(self, key: str) -> None:
-        del self._fragments[key]
+        try:
+            del self._fragments[key]
+        except KeyError as e:
+            raise FragmentStorageKeyError(str(e))
 
-    def clear(self) -> None:
-        self._fragments.clear()
+    def contains(self, key: str) -> bool:
+        return key in self._fragments
 
 
 def _fragment(
-    func: F | None = None, *, run_every: int | float | timedelta | str | None = None
+    func: F | None = None,
+    *,
+    run_every: int | float | timedelta | str | None = None,
+    additional_hash_info: str = "",
 ) -> Callable[[F], F] | F:
     """Contains the actual fragment logic.
 
@@ -128,10 +159,9 @@ def _fragment(
 
         cursors_snapshot = deepcopy(ctx.cursors)
         dg_stack_snapshot = deepcopy(dg_stack.get())
-        active_dg = dg_stack_snapshot[-1]
         h = hashlib.new("md5")
         h.update(
-            f"{non_optional_func.__module__}.{non_optional_func.__qualname__}{active_dg._get_delta_path_str()}".encode()
+            f"{non_optional_func.__module__}.{non_optional_func.__qualname__}{dg_stack_snapshot[-1]._get_delta_path_str()}{additional_hash_info}".encode()
         )
         fragment_id = h.hexdigest()
 
@@ -149,18 +179,22 @@ def _fragment(
             ctx = get_script_run_ctx(suppress_warning=True)
             assert ctx is not None
 
-            if ctx.fragment_ids_this_run:
+            if ctx.script_requests and ctx.script_requests.fragment_id_queue:
                 # This script run is a run of one or more fragments. We restore the
                 # state of ctx.cursors and dg_stack to the snapshots we took when this
                 # fragment was declared.
                 ctx.cursors = deepcopy(cursors_snapshot)
                 dg_stack.set(deepcopy(dg_stack_snapshot))
-            else:
-                # Otherwise, we must be in a full script run. We need to temporarily set
-                # ctx.current_fragment_id so that elements corresponding to this
-                # fragment get tagged with the appropriate ID. ctx.current_fragment_id
-                # gets reset after the fragment function finishes running.
-                ctx.current_fragment_id = fragment_id
+
+            # Always add the fragment id to new_fragment_ids. For full app runs
+            # we need to add them anyways and for fragment runs we add them
+            # in case the to-be-executed fragment id was cleared from the storage
+            # by the full app run.
+            ctx.new_fragment_ids.add(fragment_id)
+            # Set ctx.current_fragment_id so that elements corresponding to this
+            # fragment get tagged with the appropriate ID. ctx.current_fragment_id gets
+            # reset after the fragment function finishes running.
+            ctx.current_fragment_id = fragment_id
 
             try:
                 # Make sure we set the active script hash to the same value
@@ -174,18 +208,48 @@ def _fragment(
                     if initialized_active_script_hash != ctx.active_script_hash
                     else contextlib.nullcontext()
                 )
+                result = None
                 with active_hash_context:
                     with st.container():
-                        ctx.current_fragment_delta_path = (
-                            active_dg._cursor.delta_path if active_dg._cursor else []
-                        )
-                        result = non_optional_func(*args, **kwargs)
+                        try:
+                            # use dg_stack instead of active_dg to have correct copy
+                            # during execution (otherwise we can run into concurrency
+                            # issues with multiple fragments). Use dg_stack because we
+                            # just entered a container and [:-1] of the delta path
+                            # because thats the prefix of the fragment,
+                            # e.g. [0, 3, 0] -> [0, 3].
+                            # All fragment elements start with [0, 3].
+                            active_dg = dg_stack.get()[-1]
+                            ctx.current_fragment_delta_path = (
+                                active_dg._cursor.delta_path
+                                if active_dg._cursor
+                                else []
+                            )[:-1]
+                            result = non_optional_func(*args, **kwargs)
+                        except (
+                            RerunException,
+                            StopException,
+                        ) as e:
+                            # The wrapped_fragment function is executed
+                            # inside of a exec_func_with_error_handling call, so
+                            # there is a correct handler for these exceptions.
+                            raise e
+                        except Exception as e:
+                            # render error here so that the delta path is correct
+                            # for full app runs, the error will be displayed by the
+                            # main code handler
+                            # if not is_full_app_run:
+                            handle_uncaught_app_exception(e)
+                            # raise here again in case we are in full app execution
+                            # and some flags have to be set
+                            raise FragmentHandledException(e)
+                    return result
             finally:
                 ctx.current_fragment_id = None
+                ctx.current_fragment_delta_path = []
 
-            return result
-
-        ctx.fragment_storage.set(fragment_id, wrapped_fragment)
+        if not ctx.fragment_storage.contains(fragment_id):
+            ctx.fragment_storage.set(fragment_id, wrapped_fragment)
 
         if run_every:
             msg = ForwardMsg()
@@ -193,15 +257,8 @@ def _fragment(
             msg.auto_rerun.fragment_id = fragment_id
             ctx.enqueue(msg)
 
-        # Wrap the fragment function in the same try-except block as in a normal
-        # script_run so that for a main-app run (this execution) and a fragment-rerun
-        # the same execution and error-handling logic is used. This makes errors in the
-        # fragment appear in the fragment path also for the first execution here in
-        # context of a full app run.
-        result, _, _, _ = exec_func_with_error_handling(
-            wrapped_fragment, ctx, reraise_rerun_exception=True
-        )
-        return result
+        # Immediate execute the wrapped fragment since we are in a full app run
+        return wrapped_fragment()
 
     with contextlib.suppress(AttributeError):
         # Make this a well-behaved decorator by preserving important function
@@ -230,7 +287,7 @@ def fragment(
 ) -> Callable[[F], F]: ...
 
 
-@gather_metrics("experimental_fragment")
+@gather_metrics("fragment")
 def fragment(
     func: F | None = None,
     *,
@@ -297,14 +354,14 @@ def fragment(
     Examples
     --------
     The following example demonstrates basic usage of
-    ``@st.experimental_fragment``. As an anology, "inflating balloons" is a
-    slow process that happens outside of the fragment. "Releasing balloons" is
-    a quick process that happens inside of the fragment.
+    ``@st.fragment``. As an analogy, "inflating balloons" is a slow process that happens
+    outside of the fragment. "Releasing balloons" is a quick process that happens inside
+    of the fragment.
 
     >>> import streamlit as st
     >>> import time
     >>>
-    >>> @st.experimental_fragment
+    >>> @st.fragment
     >>> def release_the_balloons():
     >>>     st.button("Release the balloons", help="Fragment rerun")
     >>>     st.balloons()
@@ -332,14 +389,14 @@ def fragment(
     >>>     st.session_state.app_runs = 0
     >>>     st.session_state.fragment_runs = 0
     >>>
-    >>> @st.experimental_fragment
-    >>> def fragment():
+    >>> @st.fragment
+    >>> def my_fragment():
     >>>     st.session_state.fragment_runs += 1
     >>>     st.button("Rerun fragment")
     >>>     st.write(f"Fragment says it ran {st.session_state.fragment_runs} times.")
     >>>
     >>> st.session_state.app_runs += 1
-    >>> fragment()
+    >>> my_fragment()
     >>> st.button("Rerun full app")
     >>> st.write(f"Full app says it ran {st.session_state.app_runs} times.")
     >>> st.write(f"Full app sees that fragment ran {st.session_state.fragment_runs} times.")
@@ -356,7 +413,7 @@ def fragment(
     >>> if "clicks" not in st.session_state:
     >>>     st.session_state.clicks = 0
     >>>
-    >>> @st.experimental_fragment
+    >>> @st.fragment
     >>> def count_to_five():
     >>>     if st.button("Plus one!"):
     >>>         st.session_state.clicks += 1
@@ -376,3 +433,31 @@ def fragment(
 
     """
     return _fragment(func, run_every=run_every)
+
+
+@overload
+def experimental_fragment(
+    func: F,
+    *,
+    run_every: int | float | timedelta | str | None = None,
+) -> F: ...
+
+
+# Support being able to pass parameters to this decorator (that is, being able to write
+# `@fragment(run_every=5.0)`).
+@overload
+def experimental_fragment(
+    func: None = None,
+    *,
+    run_every: int | float | timedelta | str | None = None,
+) -> Callable[[F], F]: ...
+
+
+@gather_metrics("experimental_fragment")
+def experimental_fragment(
+    func: F | None = None,
+    *,
+    run_every: int | float | timedelta | str | None = None,
+) -> Callable[[F], F] | F:
+    """Deprecated alias for @st.fragment. See the docstring for the decorator's new name."""
+    return _fragment(func, run_every=run_every)
diff --git a/lib/streamlit/runtime/metrics_util.py b/lib/streamlit/runtime/metrics_util.py
index 2a4f2de43..0c68ec65f 100644
--- a/lib/streamlit/runtime/metrics_util.py
+++ b/lib/streamlit/runtime/metrics_util.py
@@ -482,6 +482,8 @@ def create_page_profile_message(
         page_profile.uncaught_exception = uncaught_exception
 
     if ctx := get_script_run_ctx():
-        page_profile.is_fragment_run = bool(ctx.fragment_ids_this_run)
+        page_profile.is_fragment_run = bool(
+            ctx.script_requests and ctx.script_requests.fragment_id_queue
+        )
 
     return msg
diff --git a/lib/streamlit/runtime/scriptrunner/exec_code.py b/lib/streamlit/runtime/scriptrunner/exec_code.py
index 12e567986..13160ce6d 100644
--- a/lib/streamlit/runtime/scriptrunner/exec_code.py
+++ b/lib/streamlit/runtime/scriptrunner/exec_code.py
@@ -17,6 +17,7 @@ from __future__ import annotations
 from typing import TYPE_CHECKING, Any, Callable
 
 from streamlit.error_util import handle_uncaught_app_exception
+from streamlit.errors import FragmentHandledException
 from streamlit.runtime.scriptrunner.exceptions import RerunException, StopException
 
 if TYPE_CHECKING:
@@ -25,10 +26,7 @@ if TYPE_CHECKING:
 
 
 def exec_func_with_error_handling(
-    func: Callable[[], None],
-    ctx: ScriptRunContext,
-    *,
-    reraise_rerun_exception: bool = False,
+    func: Callable[[], None], ctx: ScriptRunContext
 ) -> tuple[Any | None, bool, RerunData | None, bool]:
     """Execute the passed function wrapped in a try/except block.
 
@@ -43,10 +41,6 @@ def exec_func_with_error_handling(
         The function to execute wrapped in the try/except block.
     ctx : ScriptRunContext
         The context in which the script is being run.
-    reraise_rerun_exception : bool, default False
-        If True, an occuring RerunException will be raised instead of handled. This can
-        be used if this function is called outside of the script_run context and we want
-        the script_runner to react on the rerun exception.
 
     Returns
     -------
@@ -70,16 +64,6 @@ def exec_func_with_error_handling(
     # is interrupted by a RerunException.
     rerun_exception_data: RerunData | None = None
 
-    # Saving and restoring our original cursors/dg_stack is needed
-    # specifically to handle the case where a RerunException is raised while
-    # running a fragment. In this case, we need to restore both to their states
-    # at the start of the script run to ensure that we write to the correct
-    # places in the app during the rerun (without this, ctx.cursors and dg_stack
-    # will still be set to the snapshots they were restored from when running
-    # the fragment).
-    original_cursors = ctx.cursors
-    original_dg_stack = dg_stack.get()
-
     # If the script stops early, we don't want to remove unseen widgets,
     # so we track this to potentially skip session state cleanup later.
     premature_stop: bool = False
@@ -90,22 +74,17 @@ def exec_func_with_error_handling(
     try:
         result = func()
     except RerunException as e:
-        if reraise_rerun_exception:
-            raise e
-
         rerun_exception_data = e.rerun_data
-        if rerun_exception_data.fragment_id_queue:
-            # This is a fragment-specific rerun, so we need to restore the stack
-            ctx.cursors = original_cursors
-            dg_stack.set(original_dg_stack)
-        else:
-            # If it is a full-app rerun, the stack needs to be refreshed.
-            # We should land here when `st.rerun` is called from within a
-            # fragment. Since we re-use the same thread, we have to clear the
-            # stack or otherwise we might render the main app in the old
-            # fragment's dg_stack.
-            ctx.cursors.clear()
-            dg_stack.set(get_default_dg_stack())
+
+        # Since the script is about to rerun, we may need to reset our cursors/dg_stack
+        # so that we write to the right place in the app. For full script runs, this
+        # needs to happen in case the same thread reruns our script (a different thread
+        # would automatically come with fresh cursors/dg_stack values). For fragments,
+        # it doesn't matter either way since the fragment resets these values from its
+        # snapshot before execution.
+        ctx.cursors.clear()
+        dg_stack.set(get_default_dg_stack())
+
         # Interruption due to a rerun is usually from `st.rerun()`, which
         # we want to count as a script completion so triggers reset.
         # It is also possible for this to happen if fast reruns is off,
@@ -116,11 +95,12 @@ def exec_func_with_error_handling(
         # This is thrown when the script executes `st.stop()`.
         # We don't have to do anything here.
         premature_stop = True
-
+    except FragmentHandledException:
+        run_without_errors = False
+        premature_stop = True
     except Exception as ex:
         run_without_errors = False
-        uncaught_exception = ex
-        handle_uncaught_app_exception(uncaught_exception)
         premature_stop = True
+        handle_uncaught_app_exception(ex)
 
     return result, run_without_errors, rerun_exception_data, premature_stop
diff --git a/lib/streamlit/runtime/scriptrunner/script_requests.py b/lib/streamlit/runtime/scriptrunner/script_requests.py
index dba643cef..53b8daa7d 100644
--- a/lib/streamlit/runtime/scriptrunner/script_requests.py
+++ b/lib/streamlit/runtime/scriptrunner/script_requests.py
@@ -15,7 +15,7 @@
 from __future__ import annotations
 
 import threading
-from dataclasses import dataclass, field
+from dataclasses import dataclass, field, replace
 from enum import Enum
 from typing import TYPE_CHECKING, cast
 
@@ -48,7 +48,12 @@ class RerunData:
     widget_states: WidgetStates | None = None
     page_script_hash: str = ""
     page_name: str = ""
+
+    # A single fragment_id to append to fragment_id_queue.
+    fragment_id: str | None = None
+    # The queue of fragment_ids waiting to be run.
     fragment_id_queue: list[str] = field(default_factory=list)
+    is_fragment_scoped_rerun: bool = False
 
     def __repr__(self) -> str:
         return util.repr_(self)
@@ -71,6 +76,20 @@ class ScriptRequest:
         return util.repr_(self)
 
 
+def _fragment_run_should_not_preempt_script(
+    fragment_id_queue: list[str],
+    is_fragment_scoped_rerun: bool,
+) -> bool:
+    """Returns whether the currently running script should be preempted due to a
+    fragment rerun.
+
+    Reruns corresponding to fragment runs that weren't caused by calls to
+    `st.rerun(scope="fragment")` should *not* cancel the current script run
+    as doing so will affect elements outside of the fragment.
+    """
+    return bool(fragment_id_queue) and not is_fragment_scoped_rerun
+
+
 class ScriptRequests:
     """An interface for communicating with a ScriptRunner. Thread-safe.
 
@@ -83,6 +102,13 @@ class ScriptRequests:
         self._state = ScriptRequestType.CONTINUE
         self._rerun_data = RerunData()
 
+    @property
+    def fragment_id_queue(self) -> list[str]:
+        if not self._rerun_data:
+            return []
+
+        return self._rerun_data.fragment_id_queue
+
     def request_stop(self) -> None:
         """Request that the ScriptRunner stop running. A stopped ScriptRunner
         can't be used anymore. STOP requests succeed unconditionally.
@@ -110,6 +136,15 @@ class ScriptRequests:
                 # rerun it as of yet. We can handle a rerun request unconditionally so
                 # just change self._state and set self._rerun_data.
                 self._state = ScriptRequestType.RERUN
+
+                # Convert from a single fragment_id into fragment_id_queue.
+                if new_data.fragment_id:
+                    new_data = replace(
+                        new_data,
+                        fragment_id=None,
+                        fragment_id_queue=[new_data.fragment_id],
+                    )
+
                 self._rerun_data = new_data
                 return True
 
@@ -121,17 +156,17 @@ class ScriptRequests:
                     self._rerun_data.widget_states, new_data.widget_states
                 )
 
-                if new_data.fragment_id_queue:
-                    # This RERUN request corresponds to a fragment run. We append the
-                    # new fragment ID to the end of the current fragment_id_queue if it
-                    # isn't already contained in it.
+                if new_data.fragment_id:
+                    # This RERUN request corresponds to a new fragment run. We append
+                    # the new fragment ID to the end of the current fragment_id_queue if
+                    # it isn't already contained in it.
                     fragment_id_queue = [*self._rerun_data.fragment_id_queue]
-                    if (
-                        # new_data.fragment_id_queue is always a singleton
-                        (new_fragment_id := new_data.fragment_id_queue[0])
-                        not in fragment_id_queue
-                    ):
-                        fragment_id_queue.append(new_fragment_id)
+
+                    if new_data.fragment_id not in fragment_id_queue:
+                        fragment_id_queue.append(new_data.fragment_id)
+                elif new_data.fragment_id_queue:
+                    # new_data contains a new fragment_id_queue, so we just use it.
+                    fragment_id_queue = new_data.fragment_id_queue
                 else:
                     # Otherwise, this is a request to rerun the full script, so we want
                     # to clear out any fragments we have queued to run since they'll all
@@ -144,6 +179,7 @@ class ScriptRequests:
                     page_script_hash=new_data.page_script_hash,
                     page_name=new_data.page_name,
                     fragment_id_queue=fragment_id_queue,
+                    is_fragment_scoped_rerun=new_data.is_fragment_scoped_rerun,
                 )
 
                 return True
@@ -154,30 +190,35 @@ class ScriptRequests:
     def on_scriptrunner_yield(self) -> ScriptRequest | None:
         """Called by the ScriptRunner when it's at a yield point.
 
-        If we have no request or a RERUN request corresponding to one or more fragments,
-        return None.
+        If we have no request or a RERUN request corresponding to one or more fragments
+        (that is not a fragment-scoped rerun), return None.
 
-        If we have a (full script) RERUN request, return the request and set our internal
-        state to CONTINUE.
+        If we have a (full script or fragment-scoped) RERUN request, return the request
+        and set our internal state to CONTINUE.
 
         If we have a STOP request, return the request and remain stopped.
         """
         if self._state == ScriptRequestType.CONTINUE or (
-            # Reruns corresponding to fragments should *not* cancel the current script
-            # run as doing so will affect elements outside of the fragment.
             self._state == ScriptRequestType.RERUN
-            and self._rerun_data.fragment_id_queue
+            and _fragment_run_should_not_preempt_script(
+                self._rerun_data.fragment_id_queue,
+                self._rerun_data.is_fragment_scoped_rerun,
+            )
         ):
-            # We avoid taking the lock in the common cases of having no request and
-            # having a RERUN request corresponding to >=1 fragments. If a STOP or
-            # (full script) RERUN request is received between the `if` and `return`, it
+            # We avoid taking the lock in the common cases described above. If a STOP or
+            # preempting RERUN request is received after we've taken this code path, it
             # will be handled at the next `on_scriptrunner_yield`, or when
             # `on_scriptrunner_ready` is called.
             return None
 
         with self._lock:
             if self._state == ScriptRequestType.RERUN:
-                if self._rerun_data.fragment_id_queue:
+                # We already made this check in the fast-path above but need to do so
+                # again in case our state changed while we were waiting on the lock.
+                if _fragment_run_should_not_preempt_script(
+                    self._rerun_data.fragment_id_queue,
+                    self._rerun_data.is_fragment_scoped_rerun,
+                ):
                     return None
 
                 self._state = ScriptRequestType.CONTINUE
diff --git a/lib/streamlit/runtime/scriptrunner/script_run_context.py b/lib/streamlit/runtime/scriptrunner/script_run_context.py
index d62d70033..32e91c339 100644
--- a/lib/streamlit/runtime/scriptrunner/script_run_context.py
+++ b/lib/streamlit/runtime/scriptrunner/script_run_context.py
@@ -77,7 +77,7 @@ class ScriptRunContext:
     cursors: dict[int, RunningCursor] = field(default_factory=dict)
     script_requests: ScriptRequests | None = None
     current_fragment_id: str | None = None
-    fragment_ids_this_run: set[str] | None = None
+    new_fragment_ids: set[str] = field(default_factory=set)
     # we allow only one dialog to be open at the same time
     has_dialog_opened: bool = False
     # If true, it indicates that we are in a cached function that disallows
@@ -100,7 +100,6 @@ class ScriptRunContext:
         self,
         query_string: str = "",
         page_script_hash: str = "",
-        fragment_ids_this_run: set[str] | None = None,
     ) -> None:
         self.cursors = {}
         self.widget_ids_this_run = set()
@@ -116,7 +115,7 @@ class ScriptRunContext:
         self.tracked_commands_counter = collections.Counter()
         self.current_fragment_id = None
         self.current_fragment_delta_path: list[int] = []
-        self.fragment_ids_this_run = fragment_ids_this_run
+        self.new_fragment_ids = set()
         self.has_dialog_opened = False
         self.disallow_cached_widget_usage = False
 
diff --git a/lib/streamlit/runtime/scriptrunner/script_runner.py b/lib/streamlit/runtime/scriptrunner/script_runner.py
index 754405576..e92137cc2 100644
--- a/lib/streamlit/runtime/scriptrunner/script_runner.py
+++ b/lib/streamlit/runtime/scriptrunner/script_runner.py
@@ -26,6 +26,7 @@ from typing import TYPE_CHECKING, Callable, Final
 from blinker import Signal
 
 from streamlit import config, runtime, util
+from streamlit.errors import FragmentStorageKeyError
 from streamlit.logger import get_logger
 from streamlit.proto.ClientState_pb2 import ClientState
 from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
@@ -432,8 +433,6 @@ class ScriptRunner:
                 else main_page_info["page_script_hash"]
             )
 
-            fragment_ids_this_run = set(rerun_data.fragment_id_queue)
-
             ctx = self._get_script_run_ctx()
             # Clear widget state on page change. This normally happens implicitly
             # in the script run cleanup steps, but doing it explicitly ensures
@@ -458,16 +457,25 @@ class ScriptRunner:
             ctx.reset(
                 query_string=rerun_data.query_string,
                 page_script_hash=page_script_hash,
-                fragment_ids_this_run=fragment_ids_this_run,
             )
             self._pages_manager.reset_active_script_hash()
 
+            # We want to clear the forward_msg_queue during full script runs and
+            # fragment-scoped fragment reruns. For normal fragment runs, clearing the
+            # forward_msg_queue may cause us to drop messages either corresponding to
+            # other, unrelated fragments or that this fragment run depends on.
+            fragment_ids_this_run = rerun_data.fragment_id_queue
+            clear_forward_msg_queue = (
+                not fragment_ids_this_run or rerun_data.is_fragment_scoped_rerun
+            )
+
             self.on_event.send(
                 self,
                 event=ScriptRunnerEvent.SCRIPT_STARTED,
                 page_script_hash=page_script_hash,
                 fragment_ids_this_run=fragment_ids_this_run,
                 pages=self._pages_manager.get_pages(),
+                clear_forward_msg_queue=clear_forward_msg_queue,
             )
 
             # Compile the script. Any errors thrown here will be surfaced
@@ -544,16 +552,29 @@ class ScriptRunner:
                                 wrapped_fragment = self._fragment_storage.get(
                                     fragment_id
                                 )
-                                ctx.current_fragment_id = fragment_id
                                 wrapped_fragment()
 
-                            except KeyError:
+                            except FragmentStorageKeyError:
                                 raise RuntimeError(
                                     f"Could not find fragment with id {fragment_id}"
                                 )
+                            except (RerunException, StopException) as e:
+                                # The wrapped_fragment function is executed
+                                # inside of a exec_func_with_error_handling call, so
+                                # there is a correct handler for these exceptions.
+                                raise e
+                            except Exception:
+                                # Ignore exceptions raised by fragments here as we don't
+                                # want to stop the execution of other fragments. The
+                                # error itself is already rendered within the wrapped
+                                # fragment.
+                                pass
+
                     else:
-                        self._fragment_storage.clear()
                         exec(code, module.__dict__)
+                        self._fragment_storage.clear(
+                            new_fragment_ids=ctx.new_fragment_ids
+                        )
 
                     self._session_state.maybe_check_serializable()
                     # check for control requests, e.g. rerun requests have arrived
diff --git a/lib/streamlit/runtime/state/session_state.py b/lib/streamlit/runtime/state/session_state.py
index 86785179e..82d5ebce4 100644
--- a/lib/streamlit/runtime/state/session_state.py
+++ b/lib/streamlit/runtime/state/session_state.py
@@ -579,9 +579,13 @@ class SessionState:
         if ctx is None:
             return
 
+        fragment_ids_this_run = (
+            set(ctx.script_requests.fragment_id_queue) if ctx.script_requests else set()
+        )
+
         self._new_widget_state.remove_stale_widgets(
             active_widget_ids,
-            ctx.fragment_ids_this_run,
+            fragment_ids_this_run,
         )
 
         # Remove entries from _old_state corresponding to
@@ -594,7 +598,7 @@ class SessionState:
                 or not _is_stale_widget(
                     self._new_widget_state.widget_metadata.get(k),
                     active_widget_ids,
-                    ctx.fragment_ids_this_run,
+                    fragment_ids_this_run,
                 )
             )
         }
diff --git a/lib/streamlit/runtime/state/widgets.py b/lib/streamlit/runtime/state/widgets.py
index 69f56adf5..6a7110c18 100644
--- a/lib/streamlit/runtime/state/widgets.py
+++ b/lib/streamlit/runtime/state/widgets.py
@@ -21,6 +21,7 @@ from typing import TYPE_CHECKING, Final, Mapping
 from typing_extensions import TypeAlias
 
 from streamlit.errors import DuplicateWidgetID
+from streamlit.proto.Common_pb2 import StringTriggerValue as StringTriggerValueProto
 from streamlit.proto.WidgetStates_pb2 import WidgetState, WidgetStates
 from streamlit.runtime.state.common import (
     RegisterWidgetResult,
@@ -244,20 +245,31 @@ def coalesce_widget_states(
         wstate.id: wstate for wstate in new_states.widgets
     }
 
-    trigger_value_types = [("trigger_value", False), ("string_trigger_value", None)]
+    trigger_value_types = [
+        ("trigger_value", False),
+        ("string_trigger_value", StringTriggerValueProto(data=None)),
+    ]
     for old_state in old_states.widgets:
         for trigger_value_type, unset_value in trigger_value_types:
             if (
                 old_state.WhichOneof("value") == trigger_value_type
-                and old_state.trigger_value != unset_value
+                and getattr(old_state, trigger_value_type) != unset_value
             ):
-                # Ensure the corresponding new_state is also a trigger;
-                # otherwise, a widget that was previously a button but no longer is
-                # could get a bad value.
                 new_trigger_val = states_by_id.get(old_state.id)
-                if (
-                    new_trigger_val
-                    and new_trigger_val.WhichOneof("value") == trigger_value_type
+                # It should nearly always be the case that new_trigger_val is None
+                # here as trigger values are deleted from the client's WidgetStateManager
+                # as soon as a rerun_script BackMsg is sent to the server. Since it's
+                # impossible to test that the client sends us state in the expected
+                # format in a unit test, we test for this behavior in
+                # e2e_playwright/test_fragment_queue_test.py
+                if not new_trigger_val or (
+                    # Ensure the corresponding new_state is also a trigger;
+                    # otherwise, a widget that was previously a button/chat_input but no
+                    # longer is could get a bad value.
+                    new_trigger_val.WhichOneof("value") == trigger_value_type
+                    # We only want to take the value of old_state if new_trigger_val is
+                    # unset as the old value may be stale if a newer one was entered.
+                    and getattr(new_trigger_val, trigger_value_type) == unset_value
                 ):
                     states_by_id[old_state.id] = old_state
 
diff --git a/lib/tests/streamlit/commands/execution_control_test.py b/lib/tests/streamlit/commands/execution_control_test.py
new file mode 100644
index 000000000..37b25b086
--- /dev/null
+++ b/lib/tests/streamlit/commands/execution_control_test.py
@@ -0,0 +1,59 @@
+# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2024)
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import unittest
+from unittest.mock import MagicMock
+
+import pytest
+
+from streamlit.commands.execution_control import _new_fragment_id_queue
+from streamlit.errors import StreamlitAPIException
+
+
+class NewFragmentIdQueueTest(unittest.TestCase):
+    def test_returns_empty_list_if_scope_is_app(self):
+        assert _new_fragment_id_queue(None, scope="app") == []
+
+    def test_raises_exception_if_no_fragment_id_queue(self):
+        ctx = MagicMock()
+        ctx.script_requests.fragment_id_queue = []
+
+        with pytest.raises(StreamlitAPIException):
+            _new_fragment_id_queue(ctx, scope="fragment")
+
+    def test_asserts_if_curr_id_not_in_queue(self):
+        ctx = MagicMock()
+        ctx.script_requests.fragment_id_queue = ["some_fragment_id"]
+        ctx.current_fragment_id = "some_other_fragment_id"
+
+        with pytest.raises(AssertionError):
+            _new_fragment_id_queue(ctx, scope="fragment")
+
+    def test_drops_items_in_queue_until_curr_id(self):
+        ctx = MagicMock()
+        ctx.script_requests.fragment_id_queue = [
+            "id1",
+            "id2",
+            "id3",
+            "curr_id",
+            "id4",
+            "id5",
+        ]
+        ctx.current_fragment_id = "curr_id"
+
+        assert _new_fragment_id_queue(ctx, scope="fragment") == [
+            "curr_id",
+            "id4",
+            "id5",
+        ]
diff --git a/lib/tests/streamlit/delta_generator_test.py b/lib/tests/streamlit/delta_generator_test.py
index 6a93d0de0..2476cf6a1 100644
--- a/lib/tests/streamlit/delta_generator_test.py
+++ b/lib/tests/streamlit/delta_generator_test.py
@@ -397,7 +397,8 @@ class DeltaGeneratorClassTest(DeltaGeneratorTestCase):
     def test_enqueue_explodes_if_fragment_writes_to_sidebar(self):
         ctx = get_script_run_ctx()
         ctx.current_fragment_id = "my_fragment_id"
-        ctx.fragment_ids_this_run = {"my_fragment_id"}
+        ctx.script_requests = MagicMock()
+        ctx.script_requests.fragment_id_queue = ["my_fragment_id"]
 
         exc = "is not supported"
         with pytest.raises(StreamlitAPIException, match=exc):
@@ -406,7 +407,8 @@ class DeltaGeneratorClassTest(DeltaGeneratorTestCase):
     def test_enqueue_can_write_to_container_in_sidebar(self):
         ctx = get_script_run_ctx()
         ctx.current_fragment_id = "my_fragment_id"
-        ctx.fragment_ids_this_run = {"my_fragment_id"}
+        ctx.script_requests = MagicMock()
+        ctx.script_requests.fragment_id_queue = ["my_fragment_id"]
 
         delta_generator.sidebar_dg.container().write("Hello world")
 
diff --git a/lib/tests/streamlit/elements/layouts_test.py b/lib/tests/streamlit/elements/layouts_test.py
index 771daeb2e..f6103d4f3 100644
--- a/lib/tests/streamlit/elements/layouts_test.py
+++ b/lib/tests/streamlit/elements/layouts_test.py
@@ -12,12 +12,11 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-from unittest.mock import patch
-
+import pytest
 from parameterized import parameterized
 
 import streamlit as st
-from streamlit.errors import StreamlitAPIException
+from streamlit.errors import FragmentHandledException, StreamlitAPIException
 from streamlit.proto.Block_pb2 import Block as BlockProto
 from tests.delta_generator_test_case import DeltaGeneratorTestCase
 
@@ -567,13 +566,9 @@ class DialogTest(DeltaGeneratorTestCase):
         def level1_dialog():
             level2_dialog()
 
-        with patch("streamlit.exception") as mock_st_exception:
+        with pytest.raises(FragmentHandledException) as e:
             level1_dialog()
-            mock_st_exception.assert_called_once()
-            assert (
-                str(mock_st_exception.call_args[0][0])
-                == "Dialogs may not be nested inside other dialogs."
-            )
+        assert str(e.value) == "Dialogs may not be nested inside other dialogs."
 
     def test_only_one_dialog_can_be_opened_at_same_time(self):
         @st.experimental_dialog("Dialog1")
diff --git a/lib/tests/streamlit/runtime/app_session_test.py b/lib/tests/streamlit/runtime/app_session_test.py
index d2c20a1e3..84b14efb6 100644
--- a/lib/tests/streamlit/runtime/app_session_test.py
+++ b/lib/tests/streamlit/runtime/app_session_test.py
@@ -763,7 +763,8 @@ class AppSessionScriptEventTest(IsolatedAsyncioTestCase):
             sender=mock_scriptrunner,
             event=ScriptRunnerEvent.SCRIPT_STARTED,
             page_script_hash="",
-            fragment_ids_this_run={"my_fragment_id"},
+            fragment_ids_this_run=["my_fragment_id"],
+            clear_forward_msg_queue=False,
         )
 
         # Yield to let the AppSession's callbacks run.
@@ -778,6 +779,26 @@ class AppSessionScriptEventTest(IsolatedAsyncioTestCase):
 
         add_script_run_ctx(ctx=orig_ctx)
 
+    async def test_clears_forward_msg_queue_by_default(self):
+        session = _create_test_session(asyncio.get_running_loop())
+
+        mock_scriptrunner = MagicMock(spec=ScriptRunner)
+        session._scriptrunner = mock_scriptrunner
+        session._clear_queue = MagicMock()
+
+        # Send a mock SCRIPT_STARTED event.
+        session._on_scriptrunner_event(
+            sender=mock_scriptrunner,
+            event=ScriptRunnerEvent.SCRIPT_STARTED,
+            page_script_hash="",
+            fragment_ids_this_run=["my_fragment_id"],
+        )
+
+        # Yield to let the AppSession's callbacks run.
+        await asyncio.sleep(0)
+
+        session._clear_queue.assert_called_once()
+
     async def test_events_handled_on_event_loop(self):
         """ScriptRunner events should be handled on the main thread only."""
         session = _create_test_session(asyncio.get_running_loop())
diff --git a/lib/tests/streamlit/runtime/forward_msg_queue_test.py b/lib/tests/streamlit/runtime/forward_msg_queue_test.py
index e341266ff..70e91ea8d 100644
--- a/lib/tests/streamlit/runtime/forward_msg_queue_test.py
+++ b/lib/tests/streamlit/runtime/forward_msg_queue_test.py
@@ -227,6 +227,7 @@ class ForwardMsgQueueTest(unittest.TestCase):
 
         fmq.clear(retain_lifecycle_msgs=True)
         assert fmq._queue == [
+            NEW_SESSION_MSG,
             script_finished_msg,
             session_status_changed_msg,
             parent_msg,
diff --git a/lib/tests/streamlit/runtime/fragment_test.py b/lib/tests/streamlit/runtime/fragment_test.py
index 340df1943..70b05bbec 100644
--- a/lib/tests/streamlit/runtime/fragment_test.py
+++ b/lib/tests/streamlit/runtime/fragment_test.py
@@ -23,7 +23,8 @@ from parameterized import parameterized
 
 import streamlit as st
 from streamlit.delta_generator import DeltaGenerator, dg_stack
-from streamlit.runtime.fragment import MemoryFragmentStorage, fragment
+from streamlit.errors import FragmentHandledException, FragmentStorageKeyError
+from streamlit.runtime.fragment import MemoryFragmentStorage, _fragment, fragment
 from streamlit.runtime.pages_manager import PagesManager
 from streamlit.runtime.scriptrunner.exceptions import RerunException
 from tests.delta_generator_test_case import DeltaGeneratorTestCase
@@ -48,8 +49,8 @@ class MemoryFragmentStorageTest(unittest.TestCase):
     def test_get(self):
         assert self._storage.get("some_key") == "some_fragment"
 
-    def test_get_KeyError(self):
-        with pytest.raises(KeyError):
+    def test_get_FragmentStorageKeyError(self):
+        with pytest.raises(FragmentStorageKeyError):
             self._storage.get("nonexistent_key")
 
     def test_set(self):
@@ -61,11 +62,11 @@ class MemoryFragmentStorageTest(unittest.TestCase):
 
     def test_delete(self):
         self._storage.delete("some_key")
-        with pytest.raises(KeyError):
+        with pytest.raises(FragmentStorageKeyError):
             self._storage.get("nonexistent_key")
 
-    def test_del_KeyError(self):
-        with pytest.raises(KeyError):
+    def test_del_FragmentStorageKeyError(self):
+        with pytest.raises(FragmentStorageKeyError):
             self._storage.delete("nonexistent_key")
 
     def test_clear(self):
@@ -75,6 +76,18 @@ class MemoryFragmentStorageTest(unittest.TestCase):
         self._storage.clear()
         assert len(self._storage._fragments) == 0
 
+    def test_clear_with_new_fragment_ids(self):
+        self._storage._fragments["some_other_key"] = "some_other_fragment"
+        assert len(self._storage._fragments) == 2
+
+        self._storage.clear(new_fragment_ids={"some_key"})
+        assert len(self._storage._fragments) == 1
+        assert self._storage._fragments["some_key"] == "some_fragment"
+
+    def test_contains(self):
+        assert self._storage.contains("some_key")
+        assert not self._storage.contains("some_other_key")
+
 
 class FragmentTest(unittest.TestCase):
     def setUp(self):
@@ -135,10 +148,10 @@ class FragmentTest(unittest.TestCase):
             raise Exception(exception_message)
 
         ctx.current_fragment_id = "my_fragment_id"
-        with patch("streamlit.exception") as mock_st_exception:
+        with pytest.raises(Exception) as ex:
             my_exploding_fragment()
-            mock_st_exception.assert_called_once()
-            assert str(mock_st_exception.call_args[0][0]) == exception_message
+
+        assert str(ex.value) == exception_message
 
         assert ctx.current_fragment_id is None
 
@@ -147,23 +160,27 @@ class FragmentTest(unittest.TestCase):
         self, patched_get_script_run_ctx
     ):
         ctx = MagicMock()
+        ctx.fragment_storage = MemoryFragmentStorage()
+        ctx.fragment_storage.set = MagicMock(wraps=ctx.fragment_storage.set)
+
         patched_get_script_run_ctx.return_value = ctx
 
         @fragment
         def my_fragment():
             pass
 
+        # Call the fragment-decorated function twice, and verify that we only save the
+        # fragment a single time.
+        my_fragment()
         my_fragment()
-
         ctx.fragment_storage.set.assert_called_once()
 
     @patch("streamlit.runtime.fragment.get_script_run_ctx")
-    def test_sets_dg_stack_and_cursor_to_snapshots_if_current_fragment_id_set(
+    def test_sets_dg_stack_and_cursor_to_snapshots_if_fragment_id_queue(
         self, patched_get_script_run_ctx
     ):
         ctx = MagicMock()
-        ctx.fragment_ids_this_run = {"my_fragment_id"}
-        ctx.current_fragment_id = "my_fragment_id"
+        ctx.script_requests.fragment_id_queue = ["my_fragment_id"]
         ctx.fragment_storage = MemoryFragmentStorage()
         patched_get_script_run_ctx.return_value = ctx
 
@@ -179,6 +196,8 @@ class FragmentTest(unittest.TestCase):
         def my_fragment():
             nonlocal call_count
 
+            assert ctx.current_fragment_id is not None
+
             curr_dg_stack = dg_stack.get()
             # Verify that mutations made in previous runs of my_fragment aren't
             # persisted.
@@ -200,9 +219,7 @@ class FragmentTest(unittest.TestCase):
         # Verify that we can't mutate our dg_stack from within my_fragment. If a
         # mutation is persisted between fragment runs, the assert on `my_random_field`
         # will fail.
-        ctx.current_fragment_id = "my_fragment_id"
         saved_fragment()
-        ctx.current_fragment_id = "my_fragment_id"
         saved_fragment()
 
         # Called once when calling my_fragment and three times calling the saved
@@ -210,9 +227,12 @@ class FragmentTest(unittest.TestCase):
         assert call_count == 3
 
     @patch("streamlit.runtime.fragment.get_script_run_ctx")
-    def test_sets_current_fragment_id_if_not_set(self, patched_get_script_run_ctx):
+    def test_sets_current_fragment_id_in_full_script_runs(
+        self, patched_get_script_run_ctx
+    ):
         ctx = MagicMock()
-        ctx.fragment_ids_this_run = {}
+        ctx.script_requests.fragment_id_queue = []
+        ctx.new_fragment_ids = set()
         ctx.current_fragment_id = None
         ctx.fragment_storage = MemoryFragmentStorage()
         patched_get_script_run_ctx.return_value = ctx
@@ -228,8 +248,12 @@ class FragmentTest(unittest.TestCase):
             curr_dg_stack = dg_stack.get()
             curr_dg_stack[0].my_random_field += 1
 
+        assert len(ctx.new_fragment_ids) == 0
         my_fragment()
 
+        # Verify that `my_fragment`'s id was added to the `new_fragment_id`s set.
+        assert len(ctx.new_fragment_ids) == 1
+
         # Reach inside our MemoryFragmentStorage internals to pull out our saved
         # fragment.
         saved_fragment = list(ctx.fragment_storage._fragments.values())[0]
@@ -337,7 +361,10 @@ class FragmentTest(unittest.TestCase):
     def test_fragment_raises_rerun_exception_in_main_execution_context(
         self, patched_get_script_run_ctx
     ):
-        """Ensure that a rerun exception raised in a fragment when executed in the main execution context (meaning first execution in the app flow, not via a fragment-only rerun) is raised in the main execution context."""
+        """Ensure that a rerun exception raised in a fragment when executed in the main
+        execution context (meaning first execution in the app flow, not via a
+        fragment-only rerun) is raised in the main execution context.
+        """
         ctx = MagicMock()
         ctx.fragment_storage = MemoryFragmentStorage()
         patched_get_script_run_ctx.return_value = ctx
@@ -350,10 +377,10 @@ class FragmentTest(unittest.TestCase):
             my_fragment()
 
     @parameterized.expand([(ValueError), (TypeError), (RuntimeError), (Exception)])
-    def test_fragment_handles_non_rerun_exceptions_in_fragment_execution_context(
-        self, exception_type: Exception
+    def test_fragment_raises_FragmentHandledException_in_full_app_run(
+        self, exception_type: type[Exception]
     ):
-        """Ensures that all non-rerun exceptions are caught by the fragment code and not raised."""
+        """Ensures that during full-app run the exceptions are raised."""
         with patch(
             "streamlit.runtime.fragment.get_script_run_ctx"
         ) as patched_get_script_run_ctx:
@@ -365,7 +392,28 @@ class FragmentTest(unittest.TestCase):
             def my_fragment():
                 raise exception_type()
 
-            my_fragment()
+            with pytest.raises(FragmentHandledException):
+                my_fragment()
+
+    @patch("streamlit.runtime.fragment.get_script_run_ctx")
+    def test_fragment_additional_hash_info_param_used_for_generating_id(
+        self, patched_get_script_run_ctx
+    ):
+        """Test that the internal function can be called with an
+        additional hash info parameter."""
+        ctx = MagicMock()
+        patched_get_script_run_ctx.return_value = ctx
+
+        def my_function():
+            return ctx.current_fragment_id
+
+        fragment_id1 = _fragment(my_function)()
+        fragment_id2 = _fragment(my_function, additional_hash_info="some_hash_info")()
+        assert fragment_id1 != fragment_id2
+
+        # countercheck
+        fragment_id2 = _fragment(my_function, additional_hash_info="")()
+        assert fragment_id1 == fragment_id2
 
 
 # TESTS FOR WRITING TO CONTAINERS OUTSIDE AND INSIDE OF FRAGMENT
@@ -521,13 +569,13 @@ class FragmentCannotWriteToOutsidePathTest(DeltaGeneratorTestCase):
         _app: Callable[[Callable[[], DeltaGenerator]], None],
         _element_producer: ELEMENT_PRODUCER,
     ):
-        with patch("streamlit.exception") as mock_st_exception:
+        with pytest.raises(FragmentHandledException) as ex:
             _app(_element_producer)
-            mock_st_exception.assert_called_once()
-            assert (
-                str(mock_st_exception.call_args[0][0])
-                == "Fragments cannot write to elements outside of their container."
-            )
+
+        assert (
+            str(ex.value)
+            == "Fragments cannot write to elements outside of their container."
+        )
 
     @parameterized.expand(
         get_test_tuples(outside_container_writing_apps, NON_WIDGET_ELEMENTS)
diff --git a/lib/tests/streamlit/runtime/metrics_util_test.py b/lib/tests/streamlit/runtime/metrics_util_test.py
index e9779b949..e2fb3984b 100644
--- a/lib/tests/streamlit/runtime/metrics_util_test.py
+++ b/lib/tests/streamlit/runtime/metrics_util_test.py
@@ -177,7 +177,8 @@ class PageTelemetryTest(DeltaGeneratorTestCase):
 
     def test_create_page_profile_message_is_fragment_run(self):
         ctx = get_script_run_ctx()
-        ctx.fragment_ids_this_run = {"some_fragment_id"}
+        ctx.script_requests = MagicMock()
+        ctx.script_requests.fragment_id_queue = ["some_fragment_id"]
 
         forward_msg = metrics_util.create_page_profile_message(
             commands=[
diff --git a/lib/tests/streamlit/runtime/scriptrunner/code_exec_test.py b/lib/tests/streamlit/runtime/scriptrunner/code_exec_test.py
index a2e994396..a417c6ff5 100644
--- a/lib/tests/streamlit/runtime/scriptrunner/code_exec_test.py
+++ b/lib/tests/streamlit/runtime/scriptrunner/code_exec_test.py
@@ -71,20 +71,6 @@ class TestWrapInTryAndExec(unittest.TestCase):
         assert rerun_exception_data == rerun_data
         assert premature_stop is False
 
-    def test_func_throws_and_reraises_rerun_exception(self):
-        rerun_data = RerunData(query_string="foo")
-
-        def test_func():
-            """Test function that raises a RerunException."""
-            raise RerunException(rerun_data)
-
-        with self.assertRaises(RerunException) as rerun_exception_data:
-            exec_func_with_error_handling(
-                test_func, self.ctx, reraise_rerun_exception=True
-            )
-
-        assert rerun_exception_data.exception.rerun_data == rerun_data
-
     def test_func_throws_stop_exception(self):
         def test_func():
             """Test function that raises a StopException."""
diff --git a/lib/tests/streamlit/runtime/scriptrunner/script_requests_test.py b/lib/tests/streamlit/runtime/scriptrunner/script_requests_test.py
index 2e1485c39..707c75555 100644
--- a/lib/tests/streamlit/runtime/scriptrunner/script_requests_test.py
+++ b/lib/tests/streamlit/runtime/scriptrunner/script_requests_test.py
@@ -167,15 +167,15 @@ class ScriptRequestsTest(unittest.TestCase):
     def test_request_rerun_appends_new_fragment_ids_to_queue(self):
         reqs = ScriptRequests()
 
-        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment1"]))
+        reqs.request_rerun(RerunData(fragment_id="my_fragment1"))
 
         # Sanity check
         self.assertEqual(reqs._rerun_data.fragment_id_queue, ["my_fragment1"])
 
-        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment2"]))
-        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment3"]))
+        reqs.request_rerun(RerunData(fragment_id="my_fragment2"))
+        reqs.request_rerun(RerunData(fragment_id="my_fragment3"))
         # Test that duplicate fragment_id isn't appended to queue.
-        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment1"]))
+        reqs.request_rerun(RerunData(fragment_id="my_fragment1"))
 
         self.assertEqual(
             reqs._rerun_data.fragment_id_queue,
@@ -188,9 +188,15 @@ class ScriptRequestsTest(unittest.TestCase):
 
     def test_request_rerun_appends_clears_fragment_queue_on_full_rerun(self):
         reqs = ScriptRequests()
-        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment1"]))
-        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment2"]))
-        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment3"]))
+        reqs.request_rerun(
+            RerunData(
+                fragment_id_queue=[
+                    "my_fragment1",
+                    "my_fragment2",
+                    "my_fragment3",
+                ]
+            )
+        )
 
         # Sanity check
         self.assertEqual(
@@ -224,6 +230,24 @@ class ScriptRequestsTest(unittest.TestCase):
             reqs._rerun_data, RerunData(fragment_id_queue=["my_fragment_id"])
         )
 
+    def test_on_script_yield_with_is_fragment_scoped_rerun(self):
+        """Return RERUN; transition to the CONTINUE state."""
+        rerun_data = RerunData(
+            fragment_id_queue=["my_fragment_id"], is_fragment_scoped_rerun=True
+        )
+        reqs = ScriptRequests()
+        reqs.request_rerun(rerun_data)
+
+        result = reqs.on_scriptrunner_yield()
+        self.assertEqual(ScriptRequest(ScriptRequestType.RERUN, rerun_data), result)
+        self.assertEqual(ScriptRequestType.CONTINUE, reqs._state)
+        self.assertEqual(
+            reqs._rerun_data,
+            RerunData(
+                fragment_id_queue=["my_fragment_id"], is_fragment_scoped_rerun=True
+            ),
+        )
+
     def test_on_script_yield_with_stop_request(self):
         """Return STOP; remain in the STOP state."""
         reqs = ScriptRequests()
diff --git a/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py b/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py
index e62e7f636..e4a048183 100644
--- a/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py
+++ b/lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py
@@ -28,10 +28,11 @@ from tornado.testing import AsyncTestCase
 
 from streamlit.delta_generator import DeltaGenerator, dg_stack
 from streamlit.elements.exception import _GENERIC_UNCAUGHT_EXCEPTION_TEXT
+from streamlit.errors import FragmentStorageKeyError
 from streamlit.proto.WidgetStates_pb2 import WidgetState, WidgetStates
 from streamlit.runtime import Runtime
 from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
-from streamlit.runtime.fragment import MemoryFragmentStorage
+from streamlit.runtime.fragment import MemoryFragmentStorage, _fragment
 from streamlit.runtime.media_file_manager import MediaFileManager
 from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
 from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
@@ -330,11 +331,15 @@ class ScriptRunnerTest(AsyncTestCase):
         scriptrunner._fragment_storage.set("my_fragment2", fragment)
         scriptrunner._fragment_storage.set("my_fragment3", fragment)
 
-        # scriptrunner.request_rerun assumes that fragments will only ever be enqueued
-        # one at a time as that's what happens with real rerun requests.
-        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment1"]))
-        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment2"]))
-        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment3"]))
+        scriptrunner.request_rerun(
+            RerunData(
+                fragment_id_queue=[
+                    "my_fragment1",
+                    "my_fragment2",
+                    "my_fragment3",
+                ]
+            )
+        )
         scriptrunner.start()
         scriptrunner.join()
 
@@ -350,6 +355,91 @@ class ScriptRunnerTest(AsyncTestCase):
         fragment.assert_has_calls([call(), call(), call()])
         Runtime._instance.media_file_mgr.clear_session_refs.assert_not_called()
 
+    def test_run_multiple_fragments_even_if_one_raised_an_exception(self):
+        """Tests that fragments continue to run when previous fragment raised an error."""
+        fragment = MagicMock()
+        scriptrunner = TestScriptRunner("good_script.py")
+
+        raised_exception = {"called": False}
+
+        def raise_exception():
+            raised_exception["called"] = True
+            raise RuntimeError("this fragment errored out")
+
+        scriptrunner._fragment_storage.set("my_fragment1", raise_exception)
+        scriptrunner._fragment_storage.set("my_fragment2", fragment)
+        scriptrunner._fragment_storage.set("my_fragment3", fragment)
+
+        scriptrunner.request_rerun(
+            RerunData(
+                fragment_id_queue=[
+                    "my_fragment1",
+                    "my_fragment2",
+                    "my_fragment3",
+                ]
+            )
+        )
+        scriptrunner.start()
+        scriptrunner.join()
+        self._assert_events(
+            scriptrunner,
+            [
+                ScriptRunnerEvent.SCRIPT_STARTED,
+                ScriptRunnerEvent.FRAGMENT_STOPPED_WITH_SUCCESS,
+                ScriptRunnerEvent.SHUTDOWN,
+            ],
+        )
+
+        self.assertTrue(raised_exception["called"])
+        fragment.assert_has_calls([call(), call()])
+        Runtime._instance.media_file_mgr.clear_session_refs.assert_not_called()
+
+    @patch("streamlit.runtime.scriptrunner.exec_code.handle_uncaught_app_exception")
+    def test_FragmentStorageKeyError_becomes_RuntimeError(
+        self, patched_handle_exception
+    ):
+        fragment = MagicMock()
+        fragment.side_effect = FragmentStorageKeyError("kaboom")
+
+        scriptrunner = TestScriptRunner("good_script.py")
+        scriptrunner._fragment_storage.set("my_fragment", fragment)
+
+        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment"]))
+        scriptrunner.start()
+        scriptrunner.join()
+
+        ex = patched_handle_exception.call_args[0][0]
+        assert isinstance(ex, RuntimeError)
+
+    @patch("streamlit.runtime.fragment.get_script_run_ctx")
+    @patch("streamlit.runtime.fragment.handle_uncaught_app_exception")
+    def test_regular_KeyError_is_rethrown(
+        self, patched_handle_exception, patched_get_script_run_ctx
+    ):
+        """Test that regular key-errors within a fragment are surfaced
+        as such and not caught by the FragmentStorageKeyError.
+        """
+
+        ctx = MagicMock()
+        patched_get_script_run_ctx.return_value = ctx
+        ctx.current_fragment_id = "my_fragment_id"
+
+        def non_optional_func():
+            raise KeyError("kaboom")
+
+        def fragment():
+            _fragment(non_optional_func)()
+
+        scriptrunner = TestScriptRunner("good_script.py")
+        scriptrunner._fragment_storage.set("my_fragment", fragment)
+
+        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment"]))
+        scriptrunner.start()
+        scriptrunner.join()
+
+        ex = patched_handle_exception.call_args[0][0]
+        assert isinstance(ex, KeyError)
+
     def test_compile_error(self):
         """Tests that we get an exception event when a script can't compile."""
         scriptrunner = TestScriptRunner("compile_error.py.txt")
diff --git a/lib/tests/streamlit/runtime/state/session_state_test.py b/lib/tests/streamlit/runtime/state/session_state_test.py
index 2390fc3b1..d82a50363 100644
--- a/lib/tests/streamlit/runtime/state/session_state_test.py
+++ b/lib/tests/streamlit/runtime/state/session_state_test.py
@@ -688,6 +688,10 @@ class SessionStateMethodTests(unittest.TestCase):
         assert not self.session_state._widget_changed("foo")
 
     def test_remove_stale_widgets(self):
+        ctx = get_script_run_ctx()
+        ctx.script_requests = MagicMock()
+        ctx.script_requests.fragment_id_queue = []
+
         existing_widget_key = f"{GENERATED_WIDGET_ID_PREFIX}-existing_widget"
         generated_widget_key = f"{GENERATED_WIDGET_ID_PREFIX}-removed_widget"
 
diff --git a/lib/tests/streamlit/runtime/state/widgets_test.py b/lib/tests/streamlit/runtime/state/widgets_test.py
index de0317658..b0cc20283 100644
--- a/lib/tests/streamlit/runtime/state/widgets_test.py
+++ b/lib/tests/streamlit/runtime/state/widgets_test.py
@@ -228,6 +228,9 @@ class WidgetManagerTests(unittest.TestCase):
         ).string_trigger_value.CopyFrom(StringTriggerValueProto(data=None))
         _create_widget("missing_in_new", old_states).int_value = 123
         _create_widget("shape_changing_trigger", old_states).trigger_value = True
+        _create_widget(
+            "overwritten_string_trigger", old_states
+        ).string_trigger_value.CopyFrom(StringTriggerValueProto(data="old string"))
 
         session_state._set_widget_metadata(
             create_metadata("old_set_trigger", "trigger_value")
@@ -250,6 +253,9 @@ class WidgetManagerTests(unittest.TestCase):
         session_state._set_widget_metadata(
             create_metadata("shape changing trigger", "trigger_value")
         )
+        session_state._set_widget_metadata(
+            create_metadata("overwritten_string_trigger", "string_trigger_value")
+        )
 
         new_states = WidgetStates()
 
@@ -268,6 +274,12 @@ class WidgetManagerTests(unittest.TestCase):
         )
         _create_widget("added_in_new", new_states).int_value = 456
         _create_widget("shape_changing_trigger", new_states).int_value = 3
+        _create_widget(
+            "overwritten_string_trigger", new_states
+        ).string_trigger_value.CopyFrom(
+            StringTriggerValueProto(data="Overwritten string")
+        )
+
         session_state._set_widget_metadata(
             create_metadata("new_set_trigger", "trigger_value")
         )
@@ -295,6 +307,9 @@ class WidgetManagerTests(unittest.TestCase):
         self.assertEqual(
             "Some other string", session_state["new_set_string_trigger"].data
         )
+        self.assertEqual(
+            "Overwritten string", session_state["overwritten_string_trigger"].data
+        )
 
         # Widgets that were triggers before, but no longer are, will *not*
         # be coalesced
diff --git a/lib/tests/streamlit/streamlit_test.py b/lib/tests/streamlit/streamlit_test.py
index c98a984c2..42a17e5d1 100644
--- a/lib/tests/streamlit/streamlit_test.py
+++ b/lib/tests/streamlit/streamlit_test.py
@@ -175,6 +175,7 @@ class StreamlitTest(unittest.TestCase):
                 "cache_resource",
                 "navigation",
                 "Page",
+                "fragment",
                 # Experimental APIs:
                 "experimental_dialog",
                 "experimental_fragment",
