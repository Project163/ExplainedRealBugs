diff --git a/e2e_playwright/shared/app_utils.py b/e2e_playwright/shared/app_utils.py
index 3d5710ec0..f82a0d834 100644
--- a/e2e_playwright/shared/app_utils.py
+++ b/e2e_playwright/shared/app_utils.py
@@ -229,7 +229,7 @@ def expect_markdown(
     locator: Locator | Page,
     expected_message: str | Pattern[str],
 ) -> None:
-    """Expect an exception to be displayed in the app.
+    """Expect markdown with the given message to be displayed in the app.
 
     Parameters
     ----------
diff --git a/e2e_playwright/st_rerun.py b/e2e_playwright/st_rerun.py
index 501643e1e..69013e612 100644
--- a/e2e_playwright/st_rerun.py
+++ b/e2e_playwright/st_rerun.py
@@ -21,6 +21,9 @@ if "count" not in st.session_state:
 
 @st.fragment
 def my_fragment():
+    if st.button("rerun whole app (from fragment)"):
+        st.rerun(scope="app")
+
     if st.button("rerun fragment"):
         st.session_state.fragment_count += 1
         st.rerun(scope="fragment")
@@ -49,6 +52,14 @@ if st.session_state.count < 4:
 if st.session_state.count >= 4:
     st.text("Being able to rerun a session is awesome!")
 
+
+s = st.selectbox(
+    "i should retain my state",
+    ["a", "b", "c"],
+    index=None,
+)
+st.write(f"selectbox selection: {s}")
+
 my_fragment()
 fragment_with_rerun_in_try_block()
 st.write(f"app run count: {st.session_state.count}")
diff --git a/e2e_playwright/st_rerun_test.py b/e2e_playwright/st_rerun_test.py
index 39e4968ab..6d3867a3a 100644
--- a/e2e_playwright/st_rerun_test.py
+++ b/e2e_playwright/st_rerun_test.py
@@ -14,7 +14,8 @@
 
 from playwright.sync_api import Page, expect
 
-from e2e_playwright.shared.app_utils import click_button
+from e2e_playwright.conftest import wait_for_app_run
+from e2e_playwright.shared.app_utils import click_button, expect_markdown
 
 
 def _expect_initial_reruns_finished(app: Page):
@@ -37,11 +38,13 @@ def test_fragment_scoped_st_rerun(app: Page):
     )
 
     click_button(app, "rerun fragment")
-    expect(app.get_by_test_id("stMarkdown").first).to_have_text("fragment run count: 5")
+    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(
+        "fragment run count: 5"
+    )
     _expect_initial_reruns_count_text(app)
 
     click_button(app, "rerun fragment")
-    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
+    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(
         "fragment run count: 10"
     )
     # the main apps rerun count should not have been incremented
@@ -56,3 +59,21 @@ def test_rerun_works_in_try_except_block(app: Page):
     # the rerun in the try-block worked as expected, so the session_state count
     # incremented
     expect(app.get_by_test_id("stMarkdown").last).to_have_text("app run count: 5")
+
+
+def test_state_retained_on_app_scoped_rerun(app: Page):
+    # Sanity check 1
+    expect_markdown(app, "selectbox selection: None")
+
+    # Click on the selectbox and select the first option.
+    app.get_by_test_id("stSelectbox").first.locator("input").click()
+    selection_dropdown = app.locator('[data-baseweb="popover"]').first
+    selection_dropdown.locator("li").first.click()
+    wait_for_app_run(app)
+
+    # Sanity check 2
+    expect_markdown(app, "selectbox selection: a")
+
+    # Rerun the fragment and verify that the selectbox kept its state
+    click_button(app, "rerun whole app (from fragment)")
+    expect_markdown(app, "selectbox selection: a")
diff --git a/lib/streamlit/commands/execution_control.py b/lib/streamlit/commands/execution_control.py
index f0a39835f..4be1ff019 100644
--- a/lib/streamlit/commands/execution_control.py
+++ b/lib/streamlit/commands/execution_control.py
@@ -67,9 +67,7 @@ def _new_fragment_id_queue(
         return []
 
     else:  # scope == "fragment"
-        curr_queue = (
-            ctx.script_requests.fragment_id_queue if ctx.script_requests else []
-        )
+        curr_queue = ctx.fragment_ids_this_run
 
         # If st.rerun(scope="fragment") is called during a full script run, we raise an
         # exception. This occurs, of course, if st.rerun(scope="fragment") is called
@@ -143,7 +141,7 @@ def rerun(  # type: ignore[misc]
                 query_string=query_string,
                 page_script_hash=page_script_hash,
                 fragment_id_queue=_new_fragment_id_queue(ctx, scope),
-                is_fragment_scoped_rerun=True,
+                is_fragment_scoped_rerun=scope == "fragment",
             )
         )
         # Force a yield point so the runner can do the rerun
diff --git a/lib/streamlit/runtime/fragment.py b/lib/streamlit/runtime/fragment.py
index d5582b1d0..ce9bdb8da 100644
--- a/lib/streamlit/runtime/fragment.py
+++ b/lib/streamlit/runtime/fragment.py
@@ -193,7 +193,7 @@ def _fragment(
             ctx = get_script_run_ctx(suppress_warning=True)
             assert ctx is not None
 
-            if ctx.script_requests and ctx.script_requests.fragment_id_queue:
+            if ctx.fragment_ids_this_run:
                 # This script run is a run of one or more fragments. We restore the
                 # state of ctx.cursors and dg_stack to the snapshots we took when this
                 # fragment was declared.
diff --git a/lib/streamlit/runtime/metrics_util.py b/lib/streamlit/runtime/metrics_util.py
index 0c68ec65f..2a4f2de43 100644
--- a/lib/streamlit/runtime/metrics_util.py
+++ b/lib/streamlit/runtime/metrics_util.py
@@ -482,8 +482,6 @@ def create_page_profile_message(
         page_profile.uncaught_exception = uncaught_exception
 
     if ctx := get_script_run_ctx():
-        page_profile.is_fragment_run = bool(
-            ctx.script_requests and ctx.script_requests.fragment_id_queue
-        )
+        page_profile.is_fragment_run = bool(ctx.fragment_ids_this_run)
 
     return msg
diff --git a/lib/streamlit/runtime/scriptrunner/script_requests.py b/lib/streamlit/runtime/scriptrunner/script_requests.py
index 53b8daa7d..345a9e1ef 100644
--- a/lib/streamlit/runtime/scriptrunner/script_requests.py
+++ b/lib/streamlit/runtime/scriptrunner/script_requests.py
@@ -102,13 +102,6 @@ class ScriptRequests:
         self._state = ScriptRequestType.CONTINUE
         self._rerun_data = RerunData()
 
-    @property
-    def fragment_id_queue(self) -> list[str]:
-        if not self._rerun_data:
-            return []
-
-        return self._rerun_data.fragment_id_queue
-
     def request_stop(self) -> None:
         """Request that the ScriptRunner stop running. A stopped ScriptRunner
         can't be used anymore. STOP requests succeed unconditionally.
diff --git a/lib/streamlit/runtime/scriptrunner/script_run_context.py b/lib/streamlit/runtime/scriptrunner/script_run_context.py
index 0d90f8c63..43ef802d9 100644
--- a/lib/streamlit/runtime/scriptrunner/script_run_context.py
+++ b/lib/streamlit/runtime/scriptrunner/script_run_context.py
@@ -77,6 +77,7 @@ class ScriptRunContext:
     cursors: dict[int, RunningCursor] = field(default_factory=dict)
     script_requests: ScriptRequests | None = None
     current_fragment_id: str | None = None
+    fragment_ids_this_run: list[str] | None = None
     new_fragment_ids: set[str] = field(default_factory=set)
     # we allow only one dialog to be open at the same time
     has_dialog_opened: bool = False
@@ -100,6 +101,7 @@ class ScriptRunContext:
         self,
         query_string: str = "",
         page_script_hash: str = "",
+        fragment_ids_this_run: list[str] | None = None,
     ) -> None:
         self.cursors = {}
         self.widget_ids_this_run = set()
@@ -115,7 +117,7 @@ class ScriptRunContext:
         self.tracked_commands_counter = collections.Counter()
         self.current_fragment_id = None
         self.current_fragment_delta_path: list[int] = []
-        self.fragment_ids_this_run = None
+        self.fragment_ids_this_run = fragment_ids_this_run
         self.new_fragment_ids = set()
         self.has_dialog_opened = False
         self.disallow_cached_widget_usage = False
diff --git a/lib/streamlit/runtime/scriptrunner/script_runner.py b/lib/streamlit/runtime/scriptrunner/script_runner.py
index e92137cc2..85b4c43ea 100644
--- a/lib/streamlit/runtime/scriptrunner/script_runner.py
+++ b/lib/streamlit/runtime/scriptrunner/script_runner.py
@@ -433,6 +433,8 @@ class ScriptRunner:
                 else main_page_info["page_script_hash"]
             )
 
+            fragment_ids_this_run = list(rerun_data.fragment_id_queue)
+
             ctx = self._get_script_run_ctx()
             # Clear widget state on page change. This normally happens implicitly
             # in the script run cleanup steps, but doing it explicitly ensures
@@ -457,6 +459,7 @@ class ScriptRunner:
             ctx.reset(
                 query_string=rerun_data.query_string,
                 page_script_hash=page_script_hash,
+                fragment_ids_this_run=fragment_ids_this_run,
             )
             self._pages_manager.reset_active_script_hash()
 
diff --git a/lib/streamlit/runtime/state/session_state.py b/lib/streamlit/runtime/state/session_state.py
index 82d5ebce4..099ee8ad0 100644
--- a/lib/streamlit/runtime/state/session_state.py
+++ b/lib/streamlit/runtime/state/session_state.py
@@ -186,7 +186,7 @@ class WStates(MutableMapping[str, Any]):
     def remove_stale_widgets(
         self,
         active_widget_ids: set[str],
-        fragment_ids_this_run: set[str] | None,
+        fragment_ids_this_run: list[str] | None,
     ) -> None:
         """Remove widget state for stale widgets."""
         self.states = {
@@ -579,13 +579,9 @@ class SessionState:
         if ctx is None:
             return
 
-        fragment_ids_this_run = (
-            set(ctx.script_requests.fragment_id_queue) if ctx.script_requests else set()
-        )
-
         self._new_widget_state.remove_stale_widgets(
             active_widget_ids,
-            fragment_ids_this_run,
+            ctx.fragment_ids_this_run,
         )
 
         # Remove entries from _old_state corresponding to
@@ -598,7 +594,7 @@ class SessionState:
                 or not _is_stale_widget(
                     self._new_widget_state.widget_metadata.get(k),
                     active_widget_ids,
-                    fragment_ids_this_run,
+                    ctx.fragment_ids_this_run,
                 )
             )
         }
@@ -706,7 +702,7 @@ def _is_internal_key(key: str) -> bool:
 def _is_stale_widget(
     metadata: WidgetMetadata[Any] | None,
     active_widget_ids: set[str],
-    fragment_ids_this_run: set[str] | None,
+    fragment_ids_this_run: list[str] | None,
 ) -> bool:
     if not metadata:
         return True
diff --git a/lib/tests/streamlit/commands/execution_control_test.py b/lib/tests/streamlit/commands/execution_control_test.py
index 37b25b086..e392098e1 100644
--- a/lib/tests/streamlit/commands/execution_control_test.py
+++ b/lib/tests/streamlit/commands/execution_control_test.py
@@ -13,12 +13,13 @@
 # limitations under the License.
 
 import unittest
-from unittest.mock import MagicMock
+from unittest.mock import MagicMock, patch
 
 import pytest
 
-from streamlit.commands.execution_control import _new_fragment_id_queue
+from streamlit.commands.execution_control import _new_fragment_id_queue, rerun
 from streamlit.errors import StreamlitAPIException
+from streamlit.runtime.scriptrunner import RerunData
 
 
 class NewFragmentIdQueueTest(unittest.TestCase):
@@ -27,14 +28,14 @@ class NewFragmentIdQueueTest(unittest.TestCase):
 
     def test_raises_exception_if_no_fragment_id_queue(self):
         ctx = MagicMock()
-        ctx.script_requests.fragment_id_queue = []
+        ctx.fragment_ids_this_run = []
 
         with pytest.raises(StreamlitAPIException):
             _new_fragment_id_queue(ctx, scope="fragment")
 
     def test_asserts_if_curr_id_not_in_queue(self):
         ctx = MagicMock()
-        ctx.script_requests.fragment_id_queue = ["some_fragment_id"]
+        ctx.fragment_ids_this_run = ["some_fragment_id"]
         ctx.current_fragment_id = "some_other_fragment_id"
 
         with pytest.raises(AssertionError):
@@ -42,7 +43,7 @@ class NewFragmentIdQueueTest(unittest.TestCase):
 
     def test_drops_items_in_queue_until_curr_id(self):
         ctx = MagicMock()
-        ctx.script_requests.fragment_id_queue = [
+        ctx.fragment_ids_this_run = [
             "id1",
             "id2",
             "id3",
@@ -57,3 +58,41 @@ class NewFragmentIdQueueTest(unittest.TestCase):
             "id4",
             "id5",
         ]
+
+
+@patch("streamlit.commands.execution_control.get_script_run_ctx")
+def test_st_rerun_is_fragment_scoped_rerun_flag_False(patched_get_script_run_ctx):
+    ctx = MagicMock()
+    patched_get_script_run_ctx.return_value = ctx
+
+    rerun(scope="app")
+
+    ctx.script_requests.request_rerun.assert_called_with(
+        RerunData(
+            query_string=ctx.query_string,
+            page_script_hash=ctx.page_script_hash,
+            fragment_id_queue=[],
+            is_fragment_scoped_rerun=False,
+        )
+    )
+
+
+@patch(
+    "streamlit.commands.execution_control._new_fragment_id_queue",
+    MagicMock(return_value=["some_fragment_ids"]),
+)
+@patch("streamlit.commands.execution_control.get_script_run_ctx")
+def test_st_rerun_is_fragment_scoped_rerun_flag_True(patched_get_script_run_ctx):
+    ctx = MagicMock()
+    patched_get_script_run_ctx.return_value = ctx
+
+    rerun(scope="fragment")
+
+    ctx.script_requests.request_rerun.assert_called_with(
+        RerunData(
+            query_string=ctx.query_string,
+            page_script_hash=ctx.page_script_hash,
+            fragment_id_queue=["some_fragment_ids"],
+            is_fragment_scoped_rerun=True,
+        )
+    )
diff --git a/lib/tests/streamlit/delta_generator_test.py b/lib/tests/streamlit/delta_generator_test.py
index 2476cf6a1..31a319a0a 100644
--- a/lib/tests/streamlit/delta_generator_test.py
+++ b/lib/tests/streamlit/delta_generator_test.py
@@ -397,8 +397,7 @@ class DeltaGeneratorClassTest(DeltaGeneratorTestCase):
     def test_enqueue_explodes_if_fragment_writes_to_sidebar(self):
         ctx = get_script_run_ctx()
         ctx.current_fragment_id = "my_fragment_id"
-        ctx.script_requests = MagicMock()
-        ctx.script_requests.fragment_id_queue = ["my_fragment_id"]
+        ctx.fragment_ids_this_run = ["my_fragment_id"]
 
         exc = "is not supported"
         with pytest.raises(StreamlitAPIException, match=exc):
@@ -407,8 +406,7 @@ class DeltaGeneratorClassTest(DeltaGeneratorTestCase):
     def test_enqueue_can_write_to_container_in_sidebar(self):
         ctx = get_script_run_ctx()
         ctx.current_fragment_id = "my_fragment_id"
-        ctx.script_requests = MagicMock()
-        ctx.script_requests.fragment_id_queue = ["my_fragment_id"]
+        ctx.fragment_ids_this_run = ["my_fragment_id"]
 
         delta_generator.sidebar_dg.container().write("Hello world")
 
diff --git a/lib/tests/streamlit/runtime/fragment_test.py b/lib/tests/streamlit/runtime/fragment_test.py
index a3a01f0b8..d5025d534 100644
--- a/lib/tests/streamlit/runtime/fragment_test.py
+++ b/lib/tests/streamlit/runtime/fragment_test.py
@@ -182,11 +182,11 @@ class FragmentTest(unittest.TestCase):
         ctx.fragment_storage.set.assert_called_once()
 
     @patch("streamlit.runtime.fragment.get_script_run_ctx")
-    def test_sets_dg_stack_and_cursor_to_snapshots_if_fragment_id_queue(
+    def test_sets_dg_stack_and_cursor_to_snapshots_if_fragment_ids_this_run(
         self, patched_get_script_run_ctx
     ):
         ctx = MagicMock()
-        ctx.script_requests.fragment_id_queue = ["my_fragment_id"]
+        ctx.fragment_ids_this_run = ["my_fragment_id"]
         ctx.fragment_storage = MemoryFragmentStorage()
         patched_get_script_run_ctx.return_value = ctx
 
@@ -237,7 +237,7 @@ class FragmentTest(unittest.TestCase):
         self, patched_get_script_run_ctx
     ):
         ctx = MagicMock()
-        ctx.script_requests.fragment_id_queue = []
+        ctx.fragment_ids_this_run = []
         ctx.new_fragment_ids = set()
         ctx.current_fragment_id = None
         ctx.fragment_storage = MemoryFragmentStorage()
diff --git a/lib/tests/streamlit/runtime/metrics_util_test.py b/lib/tests/streamlit/runtime/metrics_util_test.py
index e2fb3984b..1c8768c94 100644
--- a/lib/tests/streamlit/runtime/metrics_util_test.py
+++ b/lib/tests/streamlit/runtime/metrics_util_test.py
@@ -177,8 +177,7 @@ class PageTelemetryTest(DeltaGeneratorTestCase):
 
     def test_create_page_profile_message_is_fragment_run(self):
         ctx = get_script_run_ctx()
-        ctx.script_requests = MagicMock()
-        ctx.script_requests.fragment_id_queue = ["some_fragment_id"]
+        ctx.fragment_ids_this_run = ["some_fragment_id"]
 
         forward_msg = metrics_util.create_page_profile_message(
             commands=[
diff --git a/lib/tests/streamlit/runtime/state/session_state_test.py b/lib/tests/streamlit/runtime/state/session_state_test.py
index d82a50363..2390fc3b1 100644
--- a/lib/tests/streamlit/runtime/state/session_state_test.py
+++ b/lib/tests/streamlit/runtime/state/session_state_test.py
@@ -688,10 +688,6 @@ class SessionStateMethodTests(unittest.TestCase):
         assert not self.session_state._widget_changed("foo")
 
     def test_remove_stale_widgets(self):
-        ctx = get_script_run_ctx()
-        ctx.script_requests = MagicMock()
-        ctx.script_requests.fragment_id_queue = []
-
         existing_widget_key = f"{GENERATED_WIDGET_ID_PREFIX}-existing_widget"
         generated_widget_key = f"{GENERATED_WIDGET_ID_PREFIX}-removed_widget"
 
