diff --git a/lib/streamlit/elements/widgets/time_widgets.py b/lib/streamlit/elements/widgets/time_widgets.py
index 50c832147..8dd8fd5ae 100644
--- a/lib/streamlit/elements/widgets/time_widgets.py
+++ b/lib/streamlit/elements/widgets/time_widgets.py
@@ -47,6 +47,7 @@ from streamlit.runtime.state import (
     WidgetArgs,
     WidgetCallback,
     WidgetKwargs,
+    get_session_state,
     register_widget,
 )
 from streamlit.runtime.state.common import compute_widget_id
@@ -68,13 +69,15 @@ ALLOWED_DATE_FORMATS = re.compile(
 
 
 def _parse_date_value(
-    value: DateValue | Literal["today"],
+    value: DateValue | Literal["today"] | Literal["default_value_today"],
 ) -> Tuple[List[date] | None, bool]:
     parsed_dates: List[date]
     range_value: bool = False
     if value is None:
         return None, range_value
     if value == "today":
+        parsed_dates = [datetime.now().date()]
+    elif value == "default_value_today":
         # Set value default.
         parsed_dates = [datetime.now().date()]
     elif isinstance(value, datetime):
@@ -150,7 +153,7 @@ class _DateInputValues:
     @classmethod
     def from_raw_values(
         cls,
-        value: DateValue | Literal["today"],
+        value: DateValue | Literal["today"] | Literal["default_value_today"],
         min_value: SingleDateValue,
         max_value: SingleDateValue,
     ) -> "_DateInputValues":
@@ -494,7 +497,7 @@ class TimeWidgetsMixin:
     def date_input(
         self,
         label: str,
-        value: DateValue | Literal["today"] = "today",
+        value: DateValue | Literal["today"] = "default_value_today",  # type: ignore[assignment]
         min_value: SingleDateValue = None,
         max_value: SingleDateValue = None,
         key: Key | None = None,
@@ -648,7 +651,9 @@ class TimeWidgetsMixin:
     def _date_input(
         self,
         label: str,
-        value: DateValue | Literal["today"] = "today",
+        value: DateValue
+        | Literal["today"]
+        | Literal["default_value_today"] = "default_value_today",
         min_value: SingleDateValue = None,
         max_value: SingleDateValue = None,
         key: Key | None = None,
@@ -665,13 +670,13 @@ class TimeWidgetsMixin:
         key = to_key(key)
         check_callback_rules(self.dg, on_change)
         check_session_state_rules(
-            default_value=value if value != "today" else None, key=key
+            default_value=value if value != "default_value_today" else None, key=key
         )
 
         maybe_raise_label_warnings(label, label_visibility)
 
         def parse_date_deterministic(
-            v: SingleDateValue | Literal["today"],
+            v: SingleDateValue | Literal["today"] | Literal["default_value_today"],
         ) -> str | None:
             if isinstance(v, datetime):
                 return date.strftime(v.date(), "%Y/%m/%d")
@@ -683,7 +688,7 @@ class TimeWidgetsMixin:
         parsed_max_date = parse_date_deterministic(max_value)
 
         parsed: str | None | List[str | None]
-        if value == "today" or value is None:
+        if value == "today" or value == "default_value_today" or value is None:
             parsed = None
         elif isinstance(value, (datetime, date)):
             parsed = parse_date_deterministic(value)
@@ -717,6 +722,23 @@ class TimeWidgetsMixin:
             min_value=min_value,
             max_value=max_value,
         )
+
+        if value == "default_value_today":
+            # We need to know if this is a single or range date_input, but don't have
+            # a default value, so we check if session_state can tell us.
+            # We already calculated the id, so there is no risk of this causing
+            # the id to change.
+
+            session_state = get_session_state().filtered_state
+
+            if key is not None and key in session_state:
+                state_value = session_state[key]
+                parsed_values = _DateInputValues.from_raw_values(
+                    value=state_value,
+                    min_value=min_value,
+                    max_value=max_value,
+                )
+
         del value, min_value, max_value
 
         date_input_proto = DateInputProto()
diff --git a/lib/tests/streamlit/elements/date_input_test.py b/lib/tests/streamlit/elements/date_input_test.py
index e0d06cc32..97249ce04 100644
--- a/lib/tests/streamlit/elements/date_input_test.py
+++ b/lib/tests/streamlit/elements/date_input_test.py
@@ -173,7 +173,7 @@ class DateInputTest(DeltaGeneratorTestCase):
 
     def test_range_session_state(self):
         """Test a range set by session state."""
-        date_range_input = [datetime.today(), datetime.today() + timedelta(2)]
+        date_range_input = [date(2024, 1, 15), date(2024, 1, 15) + timedelta(2)]
         state = st.session_state
         state["date_range"] = date_range_input[:]
 
@@ -182,10 +182,15 @@ class DateInputTest(DeltaGeneratorTestCase):
             key="date_range",
         )
 
+        c = self.get_delta_from_queue().new_element.date_input
+
         assert date_range == date_range_input
 
+        self.assertEqual(c.value, ["2024/01/15", "2024/01/17"])
+        self.assertEqual(c.is_range, True)
+
     def test_inside_column(self):
-        """Test that it works correctly inside of a column."""
+        """Test that it works correctly inside a column."""
         col1, col2 = st.columns(2)
 
         with col1:
