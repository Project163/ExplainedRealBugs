diff --git a/e2e_playwright/st_dialog.py b/e2e_playwright/st_dialog.py
index 935c972c1..cdf9c39ea 100644
--- a/e2e_playwright/st_dialog.py
+++ b/e2e_playwright/st_dialog.py
@@ -19,7 +19,7 @@ import streamlit as st
 from streamlit.runtime.scriptrunner.script_run_context import get_script_run_ctx
 
 
-@st.experimental_dialog("Test Dialog with Images")
+@st.dialog("Test Dialog with Images")
 def dialog_with_images():
     st.write("Hello!")
     st.slider("Slide me!", 0, 10)
@@ -43,7 +43,7 @@ if st.button("Open Dialog with Images"):
     dialog_with_images()
 
 
-@st.experimental_dialog("Simple Dialog")
+@st.dialog("Simple Dialog")
 def simple_dialog():
     st.write("Hello again!")
     st.text_input("Enter something!")
@@ -56,7 +56,7 @@ if st.button("Open Dialog without Images"):
     simple_dialog()
 
 
-@st.experimental_dialog("Large-width Dialog", width="large")
+@st.dialog("Large-width Dialog", width="large")
 def large_width_dialog():
     st.write("This dialog has a large width.")
 
@@ -68,7 +68,7 @@ if st.button("Open large-width Dialog"):
     large_width_dialog()
 
 
-@st.experimental_dialog("Dialog with headings")
+@st.dialog("Dialog with headings")
 def headings_dialog():
     st.header("Header", help="Some tooltip!")
 
@@ -80,7 +80,7 @@ if st.button("Open headings Dialog"):
 # is non-deterministic
 with st.sidebar:
 
-    @st.experimental_dialog("Simple Dialog in Sidebar")
+    @st.dialog("Simple Dialog in Sidebar")
     def dialog_in_sidebar():
         st.write("Hello sidebar dialog!")
 
@@ -91,7 +91,7 @@ with st.sidebar:
         dialog_in_sidebar()
 
 
-@st.experimental_dialog("Submit-button Dialog")
+@st.dialog("Submit-button Dialog")
 def submit_button_dialog():
     st.write("This dialog has a submit button.")
     st.write(f"Fragment Id: {get_script_run_ctx().current_fragment_id}")
@@ -104,12 +104,12 @@ if st.button("Open submit-button Dialog"):
     submit_button_dialog()
 
 
-@st.experimental_dialog("Level2 Dialog")
+@st.dialog("Level2 Dialog")
 def level2_dialog():
     st.write("Second level dialog")
 
 
-@st.experimental_dialog("Level1 Dialog")
+@st.dialog("Level1 Dialog")
 def level1_dialog():
     st.write("First level dialog")
     st.write(f"Fragment Id: {get_script_run_ctx().current_fragment_id}")
@@ -120,7 +120,7 @@ if st.button("Open Nested Dialogs"):
     level1_dialog()
 
 
-@st.experimental_dialog("Dialog with error")
+@st.dialog("Dialog with error")
 def dialog_with_error():
     with st.form(key="forecast_form"):
         # key is an invalid argument, so this shows an error
diff --git a/lib/streamlit/__init__.py b/lib/streamlit/__init__.py
index 6fce6da3a..f717846d2 100644
--- a/lib/streamlit/__init__.py
+++ b/lib/streamlit/__init__.py
@@ -72,7 +72,10 @@ from streamlit.delta_generator import (
     bottom_dg as _bottom_dg,
 )
 
-from streamlit.elements.dialog_decorator import dialog_decorator as _dialog_decorator
+from streamlit.elements.dialog_decorator import (
+    dialog_decorator as _dialog_decorator,
+    experimental_dialog_decorator as _experimental_dialog_decorator,
+)
 from streamlit.runtime.caching import (
     cache_resource as _cache_resource,
     cache_data as _cache_data,
@@ -239,10 +242,16 @@ column_config = _column_config
 connection = _connection
 
 # Fragment and dialog
+dialog = _dialog_decorator
 fragment = _fragment
 
 # Experimental APIs
-experimental_dialog = _dialog_decorator
+experimental_dialog = _deprecate_func_name(
+    _experimental_dialog_decorator,
+    "experimental_dialog",
+    "2025-01-01",
+    name_override="dialog",
+)
 experimental_fragment = _deprecate_func_name(
     _experimental_fragment,
     "experimental_fragment",
diff --git a/lib/streamlit/elements/dialog_decorator.py b/lib/streamlit/elements/dialog_decorator.py
index 7a21cf358..ee0996960 100644
--- a/lib/streamlit/elements/dialog_decorator.py
+++ b/lib/streamlit/elements/dialog_decorator.py
@@ -28,11 +28,15 @@ if TYPE_CHECKING:
 
 def _assert_no_nested_dialogs() -> None:
     """Check the current stack for existing DeltaGenerator's of type 'dialog'.
-    Note that the check like this only works when Dialog is called as a context manager, as this populates the dg_stack in delta_generator correctly.
+    Note that the check like this only works when Dialog is called as a context manager,
+    as this populates the dg_stack in delta_generator correctly.
 
-    This does not detect the edge case in which someone calls, for example, `with st.sidebar` inside of a dialog function and opens a dialog in there,
-    as `with st.sidebar` pushes the new DeltaGenerator to the stack. In order to check for that edge case, we could try to check all DeltaGenerators in the stack,
-    and not only the last one. Since we deem this to be an edge case, we lean towards simplicity here.
+    This does not detect the edge case in which someone calls, for example,
+    `with st.sidebar` inside of a dialog function and opens a dialog in there, as
+    `with st.sidebar` pushes the new DeltaGenerator to the stack. In order to check for
+    that edge case, we could try to check all DeltaGenerators in the stack, and not only
+    the last one. Since we deem this to be an edge case, we lean towards simplicity
+    here.
 
     Raises
     ------
@@ -54,30 +58,34 @@ def _dialog_decorator(
 ) -> F:
     if title is None or title == "":
         raise StreamlitAPIException(
-            'A non-empty `title` argument has to be provided for dialogs, for example `@st.experimental_dialog("Example Title")`.'
+            "A non-empty `title` argument has to be provided for dialogs, for example "
+            '`@st.dialog("Example Title")`.'
         )
 
     @wraps(non_optional_func)
     def wrap(*args, **kwargs) -> None:
         _assert_no_nested_dialogs()
         # Call the Dialog on the event_dg because it lives outside of the normal
-        # Streamlit UI flow. For example, if it is called from the sidebar, it should not
-        # inherit the sidebar theming.
+        # Streamlit UI flow. For example, if it is called from the sidebar, it should
+        # not inherit the sidebar theming.
         dialog = event_dg._dialog(title=title, dismissible=True, width=width)
         dialog.open()
 
         def dialog_content() -> None:
-            # if the dialog should be closed, st.rerun() has to be called (same behavior as with st.fragment)
+            # if the dialog should be closed, st.rerun() has to be called
+            # (same behavior as with st.fragment)
             _ = non_optional_func(*args, **kwargs)
             return None
 
-        # the fragment decorator has multiple return types so that you can pass arguments to it. Here we know the return type, so we cast
+        # the fragment decorator has multiple return types so that you can pass
+        # arguments to it. Here we know the return type, so we cast
         fragmented_dialog_content = cast(
             Callable[[], None],
             _fragment(
                 dialog_content, additional_hash_info=non_optional_func.__qualname__
             ),
         )
+
         with dialog:
             fragmented_dialog_content()
             return None
@@ -91,21 +99,23 @@ def dialog_decorator(
 ) -> Callable[[F], F]: ...
 
 
-# 'title' can be a function since `dialog_decorator` is a decorator. We just call it 'title' here though
-# to make the user-doc more friendly as we want the user to pass a title, not a function.
-# The user is supposed to call it like @st.dialog("my_title") , which makes 'title' a positional arg, hence
-# this 'trick'. The overload is required to have a good type hint for the decorated function args.
+# 'title' can be a function since `dialog_decorator` is a decorator.
+# We just call it 'title' here though to make the user-doc more friendly as
+# we want the user to pass a title, not a function. The user is supposed to
+# call it like @st.dialog("my_title") , which makes 'title' a positional arg, hence
+# this 'trick'. The overload is required to have a good type hint for the decorated
+# function args.
 @overload
 def dialog_decorator(title: F, *, width: DialogWidth = "small") -> F: ...
 
 
-@gather_metrics("experimental_dialog")
+@gather_metrics("dialog")
 def dialog_decorator(
     title: F | str, *, width: DialogWidth = "small"
 ) -> F | Callable[[F], F]:
     """Function decorator to create a modal dialog.
 
-    A function decorated with ``@st.experimental_dialog`` becomes a dialog
+    A function decorated with ``@st.dialog`` becomes a dialog
     function. When you call a dialog function, Streamlit inserts a modal dialog
     into your app. Streamlit element commands called within the dialog function
     render inside the modal dialog.
@@ -120,7 +130,7 @@ def dialog_decorator(
     dialog programmatically, call ``st.rerun()`` explicitly inside of the
     dialog function.
 
-    ``st.experimental_dialog`` inherits behavior from |st.fragment|_.
+    ``st.dialog`` inherits behavior from |st.fragment|_.
     When a user interacts with an input widget created inside a dialog function,
     Streamlit only reruns the dialog function instead of the full script.
 
@@ -133,10 +143,7 @@ def dialog_decorator(
 
     .. warning::
         Only one dialog function may be called in a script run, which means
-        that only one dialog can be open at any given time. Since a dialog is
-        also a fragment, all fragment limitations apply. Dialogs can't contain
-        fragments, and fragments can't contain dialogs. Using dialogs in widget
-        callback functions is not supported.
+        that only one dialog can be open at any given time.
 
     .. |st.fragment| replace:: ``st.fragment``
     .. _st.fragment: https://docs.streamlit.io/develop/api-reference/execution-flow/st.fragment
@@ -152,7 +159,7 @@ def dialog_decorator(
 
     Examples
     --------
-    The following example demonstrates the basic usage of ``@st.experimental_dialog``.
+    The following example demonstrates the basic usage of ``@st.dialog``.
     In this app, clicking "**A**" or "**B**" will open a modal dialog and prompt you
     to enter a reason for your vote. In the modal dialog, click "**Submit**" to record
     your vote into Session State and rerun the app. This will close the modal dialog
@@ -160,7 +167,7 @@ def dialog_decorator(
 
     >>> import streamlit as st
     >>>
-    >>> @st.experimental_dialog("Cast your vote")
+    >>> @st.dialog("Cast your vote")
     >>> def vote(item):
     >>>     st.write(f"Why is {item} your favorite?")
     >>>     reason = st.text_input("Because...")
@@ -194,3 +201,25 @@ def dialog_decorator(
 
     func: F = func_or_title
     return _dialog_decorator(func, "", width=width)
+
+
+@overload
+def experimental_dialog_decorator(
+    title: str, *, width: DialogWidth = "small"
+) -> Callable[[F], F]: ...
+
+
+# 'title' can be a function since `dialog_decorator` is a decorator. We just call it
+# 'title' here though to make the user-doc more friendly as we want the user to pass a
+#  title, not a function. The user is supposed to call it like @st.dialog("my_title"),
+#  which makes 'title' a positional arg, hence this 'trick'. The overload is required to
+#  have a good type hint for the decorated function args.
+@overload
+def experimental_dialog_decorator(title: F, *, width: DialogWidth = "small") -> F: ...
+
+
+@gather_metrics("experimental_dialog")
+def experimental_dialog_decorator(
+    title: F | str, *, width: DialogWidth = "small"
+) -> F | Callable[[F], F]:
+    return dialog_decorator(title, width=width)
diff --git a/lib/streamlit/runtime/scriptrunner/script_run_context.py b/lib/streamlit/runtime/scriptrunner/script_run_context.py
index 32e91c339..0d90f8c63 100644
--- a/lib/streamlit/runtime/scriptrunner/script_run_context.py
+++ b/lib/streamlit/runtime/scriptrunner/script_run_context.py
@@ -115,6 +115,7 @@ class ScriptRunContext:
         self.tracked_commands_counter = collections.Counter()
         self.current_fragment_id = None
         self.current_fragment_delta_path: list[int] = []
+        self.fragment_ids_this_run = None
         self.new_fragment_ids = set()
         self.has_dialog_opened = False
         self.disallow_cached_widget_usage = False
diff --git a/lib/tests/streamlit/elements/layouts_test.py b/lib/tests/streamlit/elements/layouts_test.py
index f6103d4f3..d0c914606 100644
--- a/lib/tests/streamlit/elements/layouts_test.py
+++ b/lib/tests/streamlit/elements/layouts_test.py
@@ -12,6 +12,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+from typing import Literal
+
 import pytest
 from parameterized import parameterized
 
@@ -58,7 +60,7 @@ class ColumnsTest(DeltaGeneratorTestCase):
         ]
     )
     def test_columns_with_vertical_alignment(
-        self, vertical_alignment: str, expected_alignment
+        self, vertical_alignment: Literal["top", "bottom", "center"], expected_alignment
     ):
         """Test that it works correctly with vertical_alignment argument"""
 
@@ -112,6 +114,7 @@ class ColumnsTest(DeltaGeneratorTestCase):
 
         for column in columns:
             with column:
+                # Noop
                 pass
 
         all_deltas = self.get_all_deltas_from_queue()
@@ -125,7 +128,8 @@ class ColumnsTest(DeltaGeneratorTestCase):
         self.assertEqual(columns_blocks[2].add_block.column.weight, 5.0 / sum_weights)
 
     def test_columns_with_default_small_gap(self):
-        """Test that it works correctly with no gap argument (gap size is default of small)"""
+        """Test that it works correctly with no gap argument
+        (gap size is default of small)"""
 
         st.columns(3)
 
@@ -134,7 +138,8 @@ class ColumnsTest(DeltaGeneratorTestCase):
         horizontal_block = all_deltas[0]
         columns_blocks = all_deltas[1:4]
 
-        # 4 elements will be created: 1 horizontal block, 3 columns, each receives "small" gap arg
+        # 4 elements will be created: 1 horizontal block, 3 columns, each receives
+        # "small" gap arg
         self.assertEqual(len(all_deltas), 4)
         self.assertEqual(horizontal_block.add_block.horizontal.gap, "small")
         self.assertEqual(columns_blocks[0].add_block.column.gap, "small")
@@ -151,7 +156,8 @@ class ColumnsTest(DeltaGeneratorTestCase):
         horizontal_block = all_deltas[0]
         columns_blocks = all_deltas[1:4]
 
-        # 4 elements will be created: 1 horizontal block, 3 columns, each receives "medium" gap arg
+        # 4 elements will be created: 1 horizontal block, 3 columns, each receives
+        # "medium" gap arg
         self.assertEqual(len(all_deltas), 4)
         self.assertEqual(horizontal_block.add_block.horizontal.gap, "medium")
         self.assertEqual(columns_blocks[0].add_block.column.gap, "medium")
@@ -168,7 +174,8 @@ class ColumnsTest(DeltaGeneratorTestCase):
         horizontal_block = all_deltas[0]
         columns_blocks = all_deltas[1:4]
 
-        # 4 elements will be created: 1 horizontal block, 3 columns, each receives "large" gap arg
+        # 4 elements will be created: 1 horizontal block, 3 columns, each receives
+        # "large" gap arg
         self.assertEqual(len(all_deltas), 4)
         self.assertEqual(horizontal_block.add_block.horizontal.gap, "large")
         self.assertEqual(columns_blocks[0].add_block.column.gap, "large")
@@ -187,17 +194,19 @@ class ExpanderTest(DeltaGeneratorTestCase):
         expander = st.expander("label")
 
         with expander:
+            # Noop
             pass
 
         expander_block = self.get_delta_from_queue()
         self.assertEqual(expander_block.add_block.expandable.label, "label")
-        self.assertEqual(expander_block.add_block.expandable.expanded, False)
+        self.assertFalse(expander_block.add_block.expandable.expanded)
 
     def test_valid_emoji_icon(self):
         """Test that it can be called with an emoji icon"""
         expander = st.expander("label", icon="ðŸ¦„")
 
         with expander:
+            # Noop
             pass
 
         expander_block = self.get_delta_from_queue()
@@ -209,6 +218,7 @@ class ExpanderTest(DeltaGeneratorTestCase):
         expander = st.expander("label", icon=":material/download:")
 
         with expander:
+            # Noop
             pass
 
         expander_block = self.get_delta_from_queue()
@@ -223,7 +233,8 @@ class ExpanderTest(DeltaGeneratorTestCase):
             st.expander("label", icon="invalid")
         self.assertEqual(
             str(e.exception),
-            'The value "invalid" is not a valid emoji. Shortcodes are not allowed, please use a single character instead.',
+            'The value "invalid" is not a valid emoji. Shortcodes are not allowed, '
+            "please use a single character instead.",
         )
 
     def test_invalid_material_icon(self):
@@ -243,14 +254,14 @@ class ContainerTest(DeltaGeneratorTestCase):
         """Test that it can be called with border parameter"""
         st.container(border=True)
         container_block = self.get_delta_from_queue()
-        self.assertEqual(container_block.add_block.vertical.border, True)
+        self.assertTrue(container_block.add_block.vertical.border)
 
     def test_without_parameters(self):
         """Test that it can be called without any parameters."""
         st.container()
         container_block = self.get_delta_from_queue()
-        self.assertEqual(container_block.add_block.vertical.border, False)
-        self.assertEqual(container_block.add_block.allow_empty, False)
+        self.assertFalse(container_block.add_block.vertical.border)
+        self.assertFalse(container_block.add_block.allow_empty)
 
     def test_height_parameter(self):
         """Test that it can be called with height parameter"""
@@ -259,8 +270,8 @@ class ContainerTest(DeltaGeneratorTestCase):
         container_block = self.get_delta_from_queue()
         self.assertEqual(container_block.add_block.vertical.height, 100)
         # Should allow empty and have a border as default:
-        self.assertEqual(container_block.add_block.vertical.border, True)
-        self.assertEqual(container_block.add_block.allow_empty, True)
+        self.assertTrue(container_block.add_block.vertical.border)
+        self.assertTrue(container_block.add_block.allow_empty)
 
 
 class PopoverContainerTest(DeltaGeneratorTestCase):
@@ -273,39 +284,43 @@ class PopoverContainerTest(DeltaGeneratorTestCase):
         """Test that it correctly applies label param."""
         popover = st.popover("label")
         with popover:
+            # Noop
             pass
 
         popover_block = self.get_delta_from_queue()
         self.assertEqual(popover_block.add_block.popover.label, "label")
-        self.assertEqual(popover_block.add_block.popover.use_container_width, False)
-        self.assertEqual(popover_block.add_block.popover.disabled, False)
+        self.assertFalse(popover_block.add_block.popover.use_container_width)
+        self.assertFalse(popover_block.add_block.popover.disabled)
         self.assertEqual(popover_block.add_block.popover.help, "")
-        self.assertEqual(popover_block.add_block.allow_empty, True)
+        self.assertTrue(popover_block.add_block.allow_empty)
 
     def test_use_container_width(self):
         """Test that it correctly applies use_container_width param."""
         popover = st.popover("label", use_container_width=True)
         with popover:
+            # Noop
             pass
 
         popover_block = self.get_delta_from_queue()
         self.assertEqual(popover_block.add_block.popover.label, "label")
-        self.assertEqual(popover_block.add_block.popover.use_container_width, True)
+        self.assertTrue(popover_block.add_block.popover.use_container_width)
 
     def test_disabled(self):
         """Test that it correctly applies disabled param."""
         popover = st.popover("label", disabled=True)
         with popover:
+            # Noop
             pass
 
         popover_block = self.get_delta_from_queue()
         self.assertEqual(popover_block.add_block.popover.label, "label")
-        self.assertEqual(popover_block.add_block.popover.disabled, True)
+        self.assertTrue(popover_block.add_block.popover.disabled)
 
     def test_help(self):
         """Test that it correctly applies help param."""
         popover = st.popover("label", help="help text")
         with popover:
+            # Noop
             pass
 
         popover_block = self.get_delta_from_queue()
@@ -329,7 +344,7 @@ class StatusContainerTest(DeltaGeneratorTestCase):
         st.status("label")
         status_block = self.get_delta_from_queue()
         self.assertEqual(status_block.add_block.expandable.label, "label")
-        self.assertEqual(status_block.add_block.expandable.expanded, False)
+        self.assertFalse(status_block.add_block.expandable.expanded)
         self.assertEqual(status_block.add_block.expandable.icon, "spinner")
 
     def test_expanded_param(self):
@@ -338,7 +353,7 @@ class StatusContainerTest(DeltaGeneratorTestCase):
 
         status_block = self.get_delta_from_queue()
         self.assertEqual(status_block.add_block.expandable.label, "label")
-        self.assertEqual(status_block.add_block.expandable.expanded, True)
+        self.assertTrue(status_block.add_block.expandable.expanded)
         self.assertEqual(status_block.add_block.expandable.icon, "spinner")
 
     def test_state_param_complete(self):
@@ -347,7 +362,7 @@ class StatusContainerTest(DeltaGeneratorTestCase):
 
         status_block = self.get_delta_from_queue()
         self.assertEqual(status_block.add_block.expandable.label, "label")
-        self.assertEqual(status_block.add_block.expandable.expanded, False)
+        self.assertFalse(status_block.add_block.expandable.expanded)
         self.assertEqual(status_block.add_block.expandable.icon, ":material/check:")
 
     def test_state_param_error(self):
@@ -356,19 +371,21 @@ class StatusContainerTest(DeltaGeneratorTestCase):
 
         status_block = self.get_delta_from_queue()
         self.assertEqual(status_block.add_block.expandable.label, "label")
-        self.assertEqual(status_block.add_block.expandable.expanded, False)
+        self.assertFalse(status_block.add_block.expandable.expanded, False)
         self.assertEqual(status_block.add_block.expandable.icon, ":material/error:")
 
     def test_usage_with_context_manager(self):
-        """Test that it correctly switches to complete state when used as context manager."""
+        """Test that it correctly switches to complete state when used as
+        context manager."""
         status = st.status("label")
 
         with status:
+            # Noop
             pass
 
         status_block = self.get_delta_from_queue()
         self.assertEqual(status_block.add_block.expandable.label, "label")
-        self.assertEqual(status_block.add_block.expandable.expanded, False)
+        self.assertFalse(status_block.add_block.expandable.expanded)
         self.assertEqual(status_block.add_block.expandable.icon, ":material/check:")
 
     def test_mutation_via_update(self):
@@ -378,17 +395,18 @@ class StatusContainerTest(DeltaGeneratorTestCase):
 
         status_block = self.get_delta_from_queue()
         self.assertEqual(status_block.add_block.expandable.label, "new label")
-        self.assertEqual(status_block.add_block.expandable.expanded, True)
+        self.assertTrue(status_block.add_block.expandable.expanded)
         self.assertEqual(status_block.add_block.expandable.icon, ":material/error:")
 
     def test_mutation_via_update_in_cm(self):
-        """Test that update can be used in context manager to change the label, state and expand."""
+        """Test that update can be used in context manager to change the label, state
+        and expand."""
         with st.status("label", expanded=False) as status:
             status.update(label="new label", state="error", expanded=True)
 
         status_block = self.get_delta_from_queue()
         self.assertEqual(status_block.add_block.expandable.label, "new label")
-        self.assertEqual(status_block.add_block.expandable.expanded, True)
+        self.assertTrue(status_block.add_block.expandable.expanded)
         self.assertEqual(status_block.add_block.expandable.icon, ":material/error:")
 
 
@@ -417,6 +435,7 @@ class TabsTest(DeltaGeneratorTestCase):
 
         for tab in tabs:
             with tab:
+                # Noop
                 pass
 
         all_deltas = self.get_all_deltas_from_queue()
@@ -430,7 +449,8 @@ class TabsTest(DeltaGeneratorTestCase):
 
 
 class DialogTest(DeltaGeneratorTestCase):
-    """Run unit tests for the non-public delta-generator dialog and also the dialog decorator."""
+    """Run unit tests for the non-public delta-generator dialog and also the dialog
+    decorator."""
 
     title = "Test Dialog"
 
@@ -477,12 +497,22 @@ class DialogTest(DeltaGeneratorTestCase):
             dialog.open()
         dialog.close()
         with self.assertRaises(StreamlitAPIException):
-            # Close does not reset the dialog-flag as this is handled per script-run context
+            # Close does not reset the dialog-flag as this is handled per script-run
+            # context
             dialog.open()
 
     def test_dialog_decorator_with_title_opens(self):
         """Test that the dialog decorator having a title does not throw an error"""
 
+        @st.dialog("example title")
+        def dialog():
+            return None
+
+        dialog()
+
+    def test_experimental_dialog_decorator_also_works(self):
+        """Test that the dialog decorator having a title does not throw an error"""
+
         @st.experimental_dialog("example title")
         def dialog():
             return None
@@ -493,7 +523,7 @@ class DialogTest(DeltaGeneratorTestCase):
         """Test that the title is required in decorator"""
         with self.assertRaises(TypeError) as e:
 
-            @st.experimental_dialog()
+            @st.dialog()
             def dialog():
                 return None
 
@@ -507,7 +537,7 @@ class DialogTest(DeltaGeneratorTestCase):
 
         with self.assertRaises(TypeError) as e:
 
-            @st.experimental_dialog()
+            @st.dialog()
             def dialog_with_arguments(a, b):
                 return None
 
@@ -521,7 +551,7 @@ class DialogTest(DeltaGeneratorTestCase):
 
         with self.assertRaises(StreamlitAPIException) as e:
 
-            @st.experimental_dialog("")
+            @st.dialog("")
             def dialog():
                 return None
 
@@ -533,7 +563,7 @@ class DialogTest(DeltaGeneratorTestCase):
         """Test that the decorator must be called like a function."""
         with self.assertRaises(StreamlitAPIException):
 
-            @st.experimental_dialog
+            @st.dialog
             def dialog():
                 return None
 
@@ -541,7 +571,7 @@ class DialogTest(DeltaGeneratorTestCase):
 
         with self.assertRaises(StreamlitAPIException):
 
-            @st.experimental_dialog
+            @st.dialog
             def dialog_with_arg(a):
                 return None
 
@@ -549,7 +579,7 @@ class DialogTest(DeltaGeneratorTestCase):
 
         with self.assertRaises(StreamlitAPIException):
 
-            @st.experimental_dialog
+            @st.dialog
             def dialog_with_args(a, b):
                 return None
 
@@ -558,11 +588,11 @@ class DialogTest(DeltaGeneratorTestCase):
     def test_nested_dialog_raises_error(self):
         """Test that dialogs cannot be called nested."""
 
-        @st.experimental_dialog("Level2 dialog")
+        @st.dialog("Level2 dialog")
         def level2_dialog():
             st.empty()
 
-        @st.experimental_dialog("Level1 dialog")
+        @st.dialog("Level1 dialog")
         def level1_dialog():
             level2_dialog()
 
@@ -571,11 +601,11 @@ class DialogTest(DeltaGeneratorTestCase):
         assert str(e.value) == "Dialogs may not be nested inside other dialogs."
 
     def test_only_one_dialog_can_be_opened_at_same_time(self):
-        @st.experimental_dialog("Dialog1")
+        @st.dialog("Dialog1")
         def dialog1():
             st.empty()
 
-        @st.experimental_dialog("Dialog2")
+        @st.dialog("Dialog2")
         def dialog2():
             st.empty()
 
diff --git a/lib/tests/streamlit/streamlit_test.py b/lib/tests/streamlit/streamlit_test.py
index 42a17e5d1..506641339 100644
--- a/lib/tests/streamlit/streamlit_test.py
+++ b/lib/tests/streamlit/streamlit_test.py
@@ -104,6 +104,7 @@ class StreamlitTest(unittest.TestCase):
                 "dataframe",
                 "data_editor",
                 "date_input",
+                "dialog",
                 "divider",
                 "download_button",
                 "expander",
