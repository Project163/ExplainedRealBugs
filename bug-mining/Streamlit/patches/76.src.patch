diff --git a/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py b/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
index 102822e4c..6f094d7ab 100644
--- a/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
+++ b/e2e_playwright/multipage_apps_v2/mpa_v2_basics.py
@@ -13,6 +13,7 @@
 # limitations under the License.
 
 import pathlib
+import time
 
 from PIL import Image
 
@@ -65,6 +66,17 @@ def page_10():
     get_input()
 
 
+def page_14():
+    time.sleep(0.5)
+    st.number_input("mynum", value=1, key="mynum")
+
+    @st.fragment
+    def fragment_number_input():
+        st.number_input("mynum 2", value=1, key="mynum2")
+
+    fragment_number_input()
+
+
 page7 = st.Page(page_7, default=set_default)
 page8 = st.Page(page_8, url_path="my_url_path")
 page9 = st.Page(page_9)
@@ -72,7 +84,7 @@ page10 = st.Page(page_10)
 page11 = st.Page(page_8, title="page 11", url_path="page_11")
 page12 = st.Page(page_9, title="page 12", url_path="page_12")
 page13 = st.Page(page_8, title="page 13", url_path="page_13")
-page14 = st.Page(page_9, title="page 14", url_path="page_14")
+page14 = st.Page(page_14, title="page 14")
 
 hide_sidebar = st.checkbox("Hide sidebar")
 dynamic_nav = st.checkbox("Change navigation dynamically")
diff --git a/e2e_playwright/multipage_apps_v2/mpa_v2_basics_test.py b/e2e_playwright/multipage_apps_v2/mpa_v2_basics_test.py
index 1994d3c3f..dbafaaee5 100644
--- a/e2e_playwright/multipage_apps_v2/mpa_v2_basics_test.py
+++ b/e2e_playwright/multipage_apps_v2/mpa_v2_basics_test.py
@@ -20,7 +20,11 @@ from e2e_playwright.conftest import (
     wait_for_app_loaded,
     wait_for_app_run,
 )
-from e2e_playwright.shared.app_utils import click_button, click_checkbox
+from e2e_playwright.shared.app_utils import (
+    click_button,
+    click_checkbox,
+    get_element_by_key,
+)
 
 
 def main_heading(app: Page):
@@ -56,6 +60,8 @@ expected_page_order = [
     "page 10",
     "page 11",
     "page 12",
+    "page 13",
+    "page 14",
 ]
 
 
@@ -391,3 +397,35 @@ def test_widget_state_reset_on_page_switch(app: Page):
 
     # Slider reset
     expect(app.get_by_text("x is 1")).to_be_attached()
+
+
+def test_rapid_fire_interaction(app: Page):
+    """Check that the number input can handle rapid fire clicks in an Multipage app."""
+    get_page_link(app, "page 14").click()
+
+    number_input = get_element_by_key(app, "mynum")
+    step_up_btn = number_input.get_by_test_id("stNumberInputStepUp")
+
+    # we need to have the clicking last a long enough time
+    for _ in range(30):
+        step_up_btn.click()
+
+    wait_for_app_run(app)
+
+    expect(number_input.locator("input")).to_have_value("31")
+
+
+def test_rapid_fire_interaction_in_fragment(app: Page):
+    """Check that the number input in a fragment can handle rapid fire clicks in an Multipage app."""
+    get_page_link(app, "page 14").click()
+
+    number_input = get_element_by_key(app, "mynum2")
+    step_up_btn = number_input.get_by_test_id("stNumberInputStepUp")
+
+    # we need to have the clicking last a long enough time
+    for _ in range(30):
+        step_up_btn.click()
+
+    wait_for_app_run(app)
+
+    expect(number_input.locator("input")).to_have_value("31")
diff --git a/lib/streamlit/commands/navigation.py b/lib/streamlit/commands/navigation.py
index b6420cce1..eea285b71 100644
--- a/lib/streamlit/commands/navigation.py
+++ b/lib/streamlit/commands/navigation.py
@@ -256,7 +256,7 @@ def navigation(
     page_to_return._can_be_called = True
     msg.navigation.page_script_hash = page_to_return._script_hash
     # Set the current page script hash to the page that is going to be executed
-    ctx.pages_manager.set_current_page_script_hash(page_to_return._script_hash)
+    ctx.set_mpa_v2_page(page_to_return._script_hash)
 
     # This will either navigation or yield if the page is not found
     ctx.enqueue(msg)
diff --git a/lib/streamlit/elements/arrow.py b/lib/streamlit/elements/arrow.py
index fd6d84717..ef928e28b 100644
--- a/lib/streamlit/elements/arrow.py
+++ b/lib/streamlit/elements/arrow.py
@@ -578,7 +578,7 @@ class ArrowMixin:
                 selection_mode=selection_mode,
                 is_selection_activated=is_selection_activated,
                 form_id=proto.form_id,
-                page=ctx.page_script_hash if ctx else None,
+                page=ctx.active_script_hash if ctx else None,
             )
 
             serde = DataframeSelectionSerde()
diff --git a/lib/streamlit/elements/vega_charts.py b/lib/streamlit/elements/vega_charts.py
index b60e89c69..302d6853a 100644
--- a/lib/streamlit/elements/vega_charts.py
+++ b/lib/streamlit/elements/vega_charts.py
@@ -1906,7 +1906,7 @@ class VegaChartsMixin:
                 use_container_width=use_container_width,
                 selection_mode=parsed_selection_modes,
                 form_id=vega_lite_proto.form_id,
-                page=ctx.page_script_hash if ctx else None,
+                page=ctx.active_script_hash if ctx else None,
             )
 
             serde = VegaLiteStateSerde(parsed_selection_modes)
diff --git a/lib/streamlit/navigation/page.py b/lib/streamlit/navigation/page.py
index 653ca4179..b422577a8 100644
--- a/lib/streamlit/navigation/page.py
+++ b/lib/streamlit/navigation/page.py
@@ -282,7 +282,7 @@ class StreamlitPage:
         if not ctx:
             return
 
-        with ctx.pages_manager.run_with_active_hash(self._script_hash):
+        with ctx.run_with_active_hash(self._script_hash):
             if callable(self._page):
                 self._page()
                 return
diff --git a/lib/streamlit/runtime/fragment.py b/lib/streamlit/runtime/fragment.py
index 8f355862a..fcce22f21 100644
--- a/lib/streamlit/runtime/fragment.py
+++ b/lib/streamlit/runtime/fragment.py
@@ -222,9 +222,7 @@ def _fragment(
                 # This ensures that elements (especially widgets) are tied
                 # to a consistent active script hash
                 active_hash_context = (
-                    ctx.pages_manager.run_with_active_hash(
-                        initialized_active_script_hash
-                    )
+                    ctx.run_with_active_hash(initialized_active_script_hash)
                     if initialized_active_script_hash != ctx.active_script_hash
                     else contextlib.nullcontext()
                 )
diff --git a/lib/streamlit/runtime/pages_manager.py b/lib/streamlit/runtime/pages_manager.py
index fe907b608..6d7a37bba 100644
--- a/lib/streamlit/runtime/pages_manager.py
+++ b/lib/streamlit/runtime/pages_manager.py
@@ -14,7 +14,6 @@
 
 from __future__ import annotations
 
-import contextlib
 import os
 import threading
 from pathlib import Path
@@ -74,15 +73,9 @@ class PagesStrategyV1:
         if setup_watcher:
             PagesStrategyV1.watch_pages_dir(pages_manager)
 
-    # In MPA v1, there's no difference between the active hash
-    # and the page script hash.
-    def get_active_script_hash(self) -> PageHash:
-        return self.pages_manager.current_page_hash
-
-    def set_active_script_hash(self, _page_hash: PageHash):
-        # Intentionally do nothing as MPA v1 active_script_hash does not
-        # differentiate the active_script_hash and the page_script_hash
-        pass
+    @property
+    def initial_active_script_hash(self) -> PageHash:
+        return self.pages_manager.current_page_script_hash
 
     def get_initial_active_script(
         self, page_script_hash: PageHash, page_name: PageName
@@ -147,15 +140,8 @@ class PagesStrategyV2:
 
     def __init__(self, pages_manager: PagesManager, **kwargs):
         self.pages_manager = pages_manager
-        self._active_script_hash: PageHash = self.pages_manager.main_script_hash
         self._pages: dict[PageHash, PageInfo] | None = None
 
-    def get_active_script_hash(self) -> PageHash:
-        return self._active_script_hash
-
-    def set_active_script_hash(self, page_hash: PageHash):
-        self._active_script_hash = page_hash
-
     def get_initial_active_script(
         self, page_script_hash: PageHash, page_name: PageName
     ) -> PageInfo:
@@ -166,6 +152,10 @@ class PagesStrategyV2:
             or self.pages_manager.main_script_hash,  # Default Hash
         }
 
+    @property
+    def initial_active_script_hash(self) -> PageHash:
+        return self.pages_manager.main_script_hash
+
     def get_page_script(self, fallback_page_hash: PageHash) -> PageInfo | None:
         if self._pages is None:
             return None
@@ -243,15 +233,11 @@ class PagesManager:
     ):
         self._main_script_path = main_script_path
         self._main_script_hash: PageHash = calc_md5(main_script_path)
-        self._current_page_hash: PageHash = self._main_script_hash
         self.pages_strategy = PagesManager.DefaultStrategy(self, **kwargs)
         self._script_cache = script_cache
         self._intended_page_script_hash: PageHash | None = None
         self._intended_page_name: PageName | None = None
-
-    @property
-    def current_page_hash(self) -> PageHash:
-        return self._current_page_hash
+        self._current_page_script_hash: PageHash = ""
 
     @property
     def main_script_path(self) -> ScriptPath:
@@ -261,6 +247,10 @@ class PagesManager:
     def main_script_hash(self) -> PageHash:
         return self._main_script_hash
 
+    @property
+    def current_page_script_hash(self) -> PageHash:
+        return self._current_page_script_hash
+
     @property
     def intended_page_name(self) -> PageName | None:
         return self._intended_page_name
@@ -269,34 +259,23 @@ class PagesManager:
     def intended_page_script_hash(self) -> PageHash | None:
         return self._intended_page_script_hash
 
+    @property
+    def initial_active_script_hash(self) -> PageHash:
+        return self.pages_strategy.initial_active_script_hash
+
     @property
     def mpa_version(self) -> int:
         return 2 if isinstance(self.pages_strategy, PagesStrategyV2) else 1
 
+    def set_current_page_script_hash(self, page_script_hash: PageHash) -> None:
+        self._current_page_script_hash = page_script_hash
+
     def get_main_page(self) -> PageInfo:
         return {
             "script_path": self._main_script_path,
             "page_script_hash": self._main_script_hash,
         }
 
-    def get_current_page_script_hash(self) -> PageHash:
-        """Gets the script hash of the associated page of a script."""
-        return self._current_page_hash
-
-    def set_current_page_script_hash(self, page_hash: PageHash) -> None:
-        self._current_page_hash = page_hash
-
-    def get_active_script_hash(self) -> PageHash:
-        """Gets the script hash of the currently executing script."""
-        return self.pages_strategy.get_active_script_hash()
-
-    def set_active_script_hash(self, page_hash: PageHash):
-        return self.pages_strategy.set_active_script_hash(page_hash)
-
-    def reset_active_script_hash(self):
-        # This will only apply to the V2 strategy as V1 ignores the concept
-        self.set_active_script_hash(self.main_script_hash)
-
     def set_script_intent(
         self, page_script_hash: PageHash, page_name: PageName
     ) -> None:
@@ -310,16 +289,6 @@ class PagesManager:
             page_script_hash, page_name
         )
 
-    @contextlib.contextmanager
-    def run_with_active_hash(self, page_hash: PageHash):
-        original_page_hash = self.get_active_script_hash()
-        self.set_active_script_hash(page_hash)
-        try:
-            yield
-        finally:
-            # in the event of any exception, ensure we set the active hash back
-            self.set_active_script_hash(original_page_hash)
-
     def get_pages(self) -> dict[PageHash, PageInfo]:
         return self.pages_strategy.get_pages()
 
diff --git a/lib/streamlit/runtime/scriptrunner/script_runner.py b/lib/streamlit/runtime/scriptrunner/script_runner.py
index ee8931f2d..4ac4b3fb0 100644
--- a/lib/streamlit/runtime/scriptrunner/script_runner.py
+++ b/lib/streamlit/runtime/scriptrunner/script_runner.py
@@ -467,7 +467,6 @@ class ScriptRunner:
                 page_script_hash=page_script_hash,
                 fragment_ids_this_run=fragment_ids_this_run,
             )
-            self._pages_manager.reset_active_script_hash()
 
             self.on_event.send(
                 self,
diff --git a/lib/streamlit/runtime/scriptrunner_utils/script_run_context.py b/lib/streamlit/runtime/scriptrunner_utils/script_run_context.py
index 4d380c23d..18a1adf4f 100644
--- a/lib/streamlit/runtime/scriptrunner_utils/script_run_context.py
+++ b/lib/streamlit/runtime/scriptrunner_utils/script_run_context.py
@@ -15,10 +15,18 @@
 from __future__ import annotations
 
 import collections
+import contextlib
 import contextvars
 import threading
 from dataclasses import dataclass, field
-from typing import TYPE_CHECKING, Callable, Counter, Dict, Final, Union
+from typing import (
+    TYPE_CHECKING,
+    Callable,
+    Counter,
+    Dict,
+    Final,
+    Union,
+)
 from urllib import parse
 
 from typing_extensions import TypeAlias
@@ -90,6 +98,7 @@ class ScriptRunContext:
     current_fragment_id: str | None = None
     fragment_ids_this_run: list[str] | None = None
     new_fragment_ids: set[str] = field(default_factory=set)
+    _active_script_hash: str = ""
     # we allow only one dialog to be open at the same time
     has_dialog_opened: bool = False
 
@@ -99,11 +108,25 @@ class ScriptRunContext:
 
     @property
     def page_script_hash(self):
-        return self.pages_manager.get_current_page_script_hash()
+        return self.pages_manager.current_page_script_hash
 
     @property
     def active_script_hash(self):
-        return self.pages_manager.get_active_script_hash()
+        return self._active_script_hash
+
+    @contextlib.contextmanager
+    def run_with_active_hash(self, page_hash: str):
+        original_page_hash = self._active_script_hash
+        self._active_script_hash = page_hash
+        try:
+            yield
+        finally:
+            # in the event of any exception, ensure we set the active hash back
+            self._active_script_hash = original_page_hash
+
+    def set_mpa_v2_page(self, page_script_hash: str):
+        self._active_script_hash = self.pages_manager.main_script_hash
+        self.pages_manager.set_current_page_script_hash(page_script_hash)
 
     def reset(
         self,
@@ -117,6 +140,7 @@ class ScriptRunContext:
         self.form_ids_this_run = set()
         self.query_string = query_string
         self.pages_manager.set_current_page_script_hash(page_script_hash)
+        self._active_script_hash = self.pages_manager.initial_active_script_hash
         # Permit set_page_config when the ScriptRunContext is reused on a rerun
         self._set_page_config_allowed = True
         self._has_script_started = False
diff --git a/lib/tests/streamlit/elements/number_input_test.py b/lib/tests/streamlit/elements/number_input_test.py
index 4e535ed70..ec9a80310 100644
--- a/lib/tests/streamlit/elements/number_input_test.py
+++ b/lib/tests/streamlit/elements/number_input_test.py
@@ -323,6 +323,8 @@ class NumberInputTest(DeltaGeneratorTestCase):
         )
 
     def test_should_keep_type_of_return_value_after_rerun(self):
+        # set the initial page script hash
+        self.script_run_ctx.reset(page_script_hash=self.script_run_ctx.page_script_hash)
         # Generate widget id and reset context
         st.number_input("a number", min_value=1, max_value=100, key="number")
         widget_id = self.script_run_ctx.session_state.get_widget_states()[0].id
diff --git a/lib/tests/streamlit/runtime/fragment_test.py b/lib/tests/streamlit/runtime/fragment_test.py
index 5c9122a7d..c44684464 100644
--- a/lib/tests/streamlit/runtime/fragment_test.py
+++ b/lib/tests/streamlit/runtime/fragment_test.py
@@ -321,37 +321,33 @@ class FragmentTest(unittest.TestCase):
     @patch("streamlit.runtime.fragment.get_script_run_ctx")
     def test_sets_active_script_hash_if_needed(self, patched_get_script_run_ctx):
         ctx = MagicMock()
+        patched_run_with_active_hash = MagicMock()
+        ctx.run_with_active_hash = patched_run_with_active_hash
         ctx.fragment_storage = MemoryFragmentStorage()
         ctx.pages_manager = PagesManager("")
         ctx.pages_manager.set_pages({})  # Migrate to MPAv2
-        ctx.pages_manager.set_active_script_hash("some_hash")
-        ctx.active_script_hash = ctx.pages_manager.get_active_script_hash()
+        ctx.active_script_hash = "some_hash"
         patched_get_script_run_ctx.return_value = ctx
 
-        with patch.object(
-            ctx.pages_manager, "run_with_active_hash"
-        ) as patched_run_with_active_hash:
-
-            @fragment
-            def my_fragment():
-                pass
+        @fragment
+        def my_fragment():
+            pass
 
-            my_fragment()
+        my_fragment()
 
-            # Reach inside our MemoryFragmentStorage internals to pull out our saved
-            # fragment.
-            saved_fragment = list(ctx.fragment_storage._fragments.values())[0]
+        # Reach inside our MemoryFragmentStorage internals to pull out our saved
+        # fragment.
+        saved_fragment = list(ctx.fragment_storage._fragments.values())[0]
 
-            # set the hash to something different for subsequent calls
-            ctx.pages_manager.set_active_script_hash("a_different_hash")
-            ctx.active_script_hash = ctx.pages_manager.get_active_script_hash()
+        # set the hash to something different for subsequent calls
+        ctx.active_script_hash = "a_different_hash"
 
-            # Verify subsequent calls will run with the original active script hash
-            saved_fragment()
-            patched_run_with_active_hash.assert_called_with("some_hash")
-            patched_run_with_active_hash.reset_mock()
-            saved_fragment()
-            patched_run_with_active_hash.assert_called_with("some_hash")
+        # Verify subsequent calls will run with the original active script hash
+        saved_fragment()
+        patched_run_with_active_hash.assert_called_with("some_hash")
+        patched_run_with_active_hash.reset_mock()
+        saved_fragment()
+        patched_run_with_active_hash.assert_called_with("some_hash")
 
     @patch("streamlit.runtime.fragment.get_script_run_ctx")
     def test_fragment_code_returns_value(
diff --git a/lib/tests/streamlit/runtime/pages_manager_test.py b/lib/tests/streamlit/runtime/pages_manager_test.py
index 882de7108..e301738df 100644
--- a/lib/tests/streamlit/runtime/pages_manager_test.py
+++ b/lib/tests/streamlit/runtime/pages_manager_test.py
@@ -78,26 +78,6 @@ class PagesManagerV2Test(unittest.TestCase):
         # This signifies the change to V2
         self.pages_manager.set_pages({})
 
-    def test_run_with_active_hash(self):
-        """Ensure the active script is set correctly"""
-        main_script_hash = self.pages_manager.main_script_hash
-        assert self.pages_manager.get_active_script_hash() == main_script_hash
-
-        with self.pages_manager.run_with_active_hash("new_hash"):
-            assert self.pages_manager.get_active_script_hash() == "new_hash"
-
-        assert self.pages_manager.get_active_script_hash() == main_script_hash
-
-    def test_reset_active_script_hash(self):
-        """Ensure the active script hash is reset correctly"""
-        main_script_hash = self.pages_manager.main_script_hash
-        assert self.pages_manager.get_active_script_hash() == main_script_hash
-
-        self.pages_manager.set_active_script_hash("new_hash")
-        self.pages_manager.reset_active_script_hash()
-
-        assert self.pages_manager.get_active_script_hash() == main_script_hash
-
     def test_get_page_script_valid_hash(self):
         """Ensure the page script is provided with valid page hash specified"""
 
diff --git a/lib/tests/streamlit/runtime/scriptrunner_utils/script_run_context_test.py b/lib/tests/streamlit/runtime/scriptrunner_utils/script_run_context_test.py
index d00ee57c5..e779c46d7 100644
--- a/lib/tests/streamlit/runtime/scriptrunner_utils/script_run_context_test.py
+++ b/lib/tests/streamlit/runtime/scriptrunner_utils/script_run_context_test.py
@@ -177,6 +177,7 @@ class ScriptRunContextTest(unittest.TestCase):
             fragment_storage=MemoryFragmentStorage(),
             pages_manager=pg_mgr,
         )
+        ctx.reset(page_script_hash="main_script_hash")
 
         ctx.on_script_start()
 
@@ -184,17 +185,16 @@ class ScriptRunContextTest(unittest.TestCase):
         msg.delta.new_element.markdown.body = "foo"
 
         ctx.enqueue(msg)
-        self.assertEqual(
-            msg.metadata.active_script_hash, pg_mgr.get_active_script_hash()
-        )
+        self.assertEqual(msg.metadata.active_script_hash, ctx.active_script_hash)
 
-        pg_mgr.set_current_page_script_hash("new_hash")
+        ctx.set_mpa_v2_page("new_hash")
 
-        new_msg = ForwardMsg()
-        new_msg.delta.new_element.markdown.body = "bar"
+        with ctx.run_with_active_hash("new_hash"):
+            new_msg = ForwardMsg()
+            new_msg.delta.new_element.markdown.body = "bar"
 
-        ctx.enqueue(new_msg)
-        self.assertEqual(new_msg.metadata.active_script_hash, "new_hash")
+            ctx.enqueue(new_msg)
+            assert new_msg.metadata.active_script_hash == "new_hash"
 
     @parameterized.expand(
         [
@@ -330,3 +330,30 @@ class ScriptRunContextTest(unittest.TestCase):
             self.assertEqual(
                 fake_enqueue_result["msg"].delta.fragment_id, "my_fragment_id"
             )
+
+    def test_run_with_active_hash(self):
+        """Ensure the active script is set correctly"""
+        pages_manager = PagesManager("")
+        ctx = ScriptRunContext(
+            session_id="TestSessionID",
+            _enqueue=lambda msg: None,
+            query_string="",
+            session_state=SafeSessionState(SessionState(), lambda: None),
+            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
+            main_script_path="",
+            user_info={"email": "test@test.com"},
+            fragment_storage=MemoryFragmentStorage(),
+            pages_manager=pages_manager,
+            current_fragment_id="my_fragment_id",
+        )
+        ctx.reset(page_script_hash=pages_manager.main_script_hash)
+        assert ctx.active_script_hash == pages_manager.main_script_hash
+
+        pages_manager.set_pages({})
+        ctx.set_mpa_v2_page("new_hash")
+        assert ctx.active_script_hash == pages_manager.main_script_hash
+
+        with ctx.run_with_active_hash("new_hash"):
+            assert ctx.active_script_hash == "new_hash"
+
+        assert ctx.active_script_hash == pages_manager.main_script_hash
