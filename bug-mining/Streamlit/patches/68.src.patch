diff --git a/frontend/lib/src/AppNode.test.ts b/frontend/lib/src/AppNode.test.ts
index 929a2976a..6dddb99af 100644
--- a/frontend/lib/src/AppNode.test.ts
+++ b/frontend/lib/src/AppNode.test.ts
@@ -979,6 +979,94 @@ describe("AppRoot.applyDelta", () => {
     expect(newRoot.sidebar.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
   })
 
+  it("removes a block's children if the block type changes for the same delta path", () => {
+    const newRoot = ROOT.applyDelta(
+      "script_run_id",
+      makeProto(DeltaProto, {
+        addBlock: {
+          expandable: {
+            expanded: true,
+            label: "label",
+            icon: "",
+          },
+        },
+      }),
+      forwardMsgMetadata([0, 1, 1])
+    ).applyDelta(
+      "script_run_id",
+      makeProto(DeltaProto, {
+        newElement: { text: { body: "newElement!" } },
+      }),
+      forwardMsgMetadata([0, 1, 1, 0])
+    )
+
+    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
+    expect(newNode).toBeDefined()
+    expect(newNode.deltaBlock.type).toBe("expandable")
+    expect(newNode.children.length).toBe(1)
+
+    const newRoot2 = newRoot.applyDelta(
+      "new_script_run_id",
+      makeProto(DeltaProto, {
+        addBlock: {
+          tabContainer: {},
+        },
+      }),
+      forwardMsgMetadata([0, 1, 1])
+    )
+
+    const replacedBlock = newRoot2.main.getIn([1, 1]) as BlockNode
+    expect(replacedBlock).toBeDefined()
+    expect(replacedBlock.deltaBlock.type).toBe("tabContainer")
+    expect(replacedBlock.children.length).toBe(0)
+  })
+
+  it("will not remove a block's children if the block type is the same for the same delta path", () => {
+    const newRoot = ROOT.applyDelta(
+      "script_run_id",
+      makeProto(DeltaProto, {
+        addBlock: {
+          expandable: {
+            expanded: true,
+            label: "label",
+            icon: "",
+          },
+        },
+      }),
+      forwardMsgMetadata([0, 1, 1])
+    ).applyDelta(
+      "script_run_id",
+      makeProto(DeltaProto, {
+        newElement: { text: { body: "newElement!" } },
+      }),
+      forwardMsgMetadata([0, 1, 1, 0])
+    )
+
+    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
+    expect(newNode).toBeDefined()
+    expect(newNode.deltaBlock.type).toBe("expandable")
+    expect(newNode.children.length).toBe(1)
+
+    const newRoot2 = newRoot.applyDelta(
+      "new_script_run_id",
+      makeProto(DeltaProto, {
+        addBlock: {
+          expandable: {
+            expanded: true,
+            label: "other label",
+            icon: "",
+          },
+        },
+      }),
+      forwardMsgMetadata([0, 1, 1])
+    )
+
+    const replacedBlock = newRoot2.main.getIn([1, 1]) as BlockNode
+    expect(replacedBlock).toBeDefined()
+    expect(replacedBlock.deltaBlock.type).toBe("expandable")
+    expect(replacedBlock.children.length).toBe(1)
+  })
+
   it("specifies active script hash on 'newElement' deltas", () => {
     const delta = makeProto(DeltaProto, {
       newElement: { text: { body: "newElement!" } },
diff --git a/frontend/lib/src/AppNode.ts b/frontend/lib/src/AppNode.ts
index 7e2ceaaec..6d3df484c 100644
--- a/frontend/lib/src/AppNode.ts
+++ b/frontend/lib/src/AppNode.ts
@@ -860,11 +860,17 @@ export class AppRoot {
   ): AppRoot {
     const existingNode = this.root.getIn(deltaPath)
 
-    // If we're replacing an existing Block, this new Block inherits
-    // the existing Block's children. This prevents existing widgets from
-    // having their values reset.
-    const children: AppNode[] =
-      existingNode instanceof BlockNode ? existingNode.children : []
+    // If we're replacing an existing Block of the same type, this new Block
+    // inherits the existing Block's children. This preserves two things:
+    //  1. Widget State
+    //  2. React state of all elements
+    let children: AppNode[] = []
+    if (
+      existingNode instanceof BlockNode &&
+      existingNode.deltaBlock.type === block.type
+    ) {
+      children = existingNode.children
+    }
 
     const blockNode = new BlockNode(
       activeScriptHash,
