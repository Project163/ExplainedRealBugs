diff --git a/frontend/lib/src/components/widgets/DateInput/DateInput.test.tsx b/frontend/lib/src/components/widgets/DateInput/DateInput.test.tsx
index 13952caab..51b3582d7 100644
--- a/frontend/lib/src/components/widgets/DateInput/DateInput.test.tsx
+++ b/frontend/lib/src/components/widgets/DateInput/DateInput.test.tsx
@@ -16,9 +16,16 @@
 
 import React from "react"
 
-import { act, fireEvent, screen, within } from "@testing-library/react"
+import {
+  act,
+  fireEvent,
+  screen,
+  waitFor,
+  within,
+} from "@testing-library/react"
 import { userEvent } from "@testing-library/user-event"
 import moment from "moment"
+import { MockInstance } from "vitest"
 
 import {
   DateInput as DateInputProto,
@@ -544,5 +551,83 @@ describe("DateInput widget", () => {
       // Quick select should not be visible for single date inputs
       expect(screen.queryByRole("combobox")).not.toBeInTheDocument()
     })
+
+    describe("quick select range", () => {
+      let spy: MockInstance
+      const RealDate = Date
+
+      beforeEach(() => {
+        const STATIC_NOW = 1732112581000
+        // Freeze both Date and moment.now so BaseWeb quick select and our code
+        // agree on "now"
+        const MockDate = class extends RealDate {
+          // @ts-expect-error Mocked constructor
+          constructor(...args: unknown[]) {
+            // If no args, return fixed date instance
+            if (args.length === 0) {
+              return new RealDate(STATIC_NOW)
+            }
+
+            return new RealDate(
+              ...(args as ConstructorParameters<typeof RealDate>)
+            )
+          }
+
+          static override now(): number {
+            return STATIC_NOW
+          }
+        }
+
+        globalThis.Date = MockDate as never
+        spy = vi.spyOn(moment, "now").mockReturnValue(STATIC_NOW)
+      })
+
+      afterEach(() => {
+        spy.mockRestore()
+        globalThis.Date = RealDate as never
+      })
+
+      it("commits quick select range ending today within max without error", async () => {
+        const user = userEvent.setup()
+
+        const today = moment().format("YYYY/MM/DD")
+        const minDate = moment().subtract(800, "days").format("YYYY/MM/DD")
+
+        const props = getProps({
+          isRange: true,
+          min: minDate,
+          max: today,
+          default: [minDate, today],
+          format: "MM.DD.YYYY",
+        })
+
+        render(<DateInput {...props} />)
+
+        // Spy after initial mount commit
+        vi.spyOn(props.widgetMgr, "setStringArrayValue")
+
+        const dateInput = screen.getByTestId("stDateInputField")
+        await user.click(dateInput)
+
+        // Quick select should be visible
+        const quickSelect = screen.getByRole("combobox")
+        expect(quickSelect).toBeVisible()
+
+        // Open quick select options and choose "Past Week" via accessible role/name
+        await user.click(quickSelect)
+        const pastWeekOption = await screen.findByRole("option", {
+          name: /Past\s*Week/i,
+        })
+        await user.click(pastWeekOption)
+
+        // Expect no error icon (wait for async updates) and the selection to be committed
+        await waitFor(() => {
+          expect(
+            screen.queryByTestId("stTooltipErrorHoverTarget")
+          ).not.toBeInTheDocument()
+        })
+        expect(props.widgetMgr.setStringArrayValue).toHaveBeenCalled()
+      })
+    })
   })
 })
diff --git a/frontend/lib/src/components/widgets/DateInput/DateInput.tsx b/frontend/lib/src/components/widgets/DateInput/DateInput.tsx
index 1ebc0580f..57ffd09d0 100644
--- a/frontend/lib/src/components/widgets/DateInput/DateInput.tsx
+++ b/frontend/lib/src/components/widgets/DateInput/DateInput.tsx
@@ -204,8 +204,27 @@ function DateInput({
         return
       }
 
+      /**
+       * Normalize selected dates to start of day (00:00) to avoid time
+       * component inconsistencies. Specifically, BaseWeb quick select uses
+       * 12:00 for the selected date, which can cause validation errors.
+       *
+       * @see https://github.com/streamlit/streamlit/issues/12293
+       */
+      const normalizedDateInput: DateOrEmpty[] | DateOrEmpty = Array.isArray(
+        date
+      )
+        ? date
+            .filter((d): d is Date => Boolean(d))
+            .map(d => normalizeToStartOfDay(d))
+        : normalizeToStartOfDay(date)
+
       // Handles FE date validation
-      const { errorType, newDates } = validateDates(date, minDate, maxDate)
+      const { errorType, newDates } = validateDates(
+        normalizedDateInput,
+        minDate,
+        maxDate
+      )
       if (errorType) {
         setError(createErrorMessage(errorType))
       }
@@ -511,7 +530,10 @@ function updateWidgetMgrState(
   let isValid = true
 
   // Check if date(s) outside of allowed min/max
-  const { errorType } = validateDates(vws.value, minDate, maxDate)
+  const normalizedStateValues = (vws.value || []).map(d =>
+    normalizeToStartOfDay(d)
+  )
+  const { errorType } = validateDates(normalizedStateValues, minDate, maxDate)
   if (errorType) {
     isValid = false
   }
@@ -527,8 +549,10 @@ function updateWidgetMgrState(
   }
 }
 
+type DateOrEmpty = Date | null | undefined
+
 function validateDates(
-  dates: Date | (Date | null | undefined)[] | null | undefined,
+  dates: DateOrEmpty[] | DateOrEmpty,
   minDate: Date,
   maxDate: Date | undefined
 ): ValidationResult {
@@ -573,4 +597,10 @@ function getMaxDate(element: DateInputProto): Date | undefined {
     : undefined
 }
 
+function normalizeToStartOfDay(date: Date): Date {
+  const normalized = new Date(date.getTime())
+  normalized.setHours(0, 0, 0, 0)
+  return normalized
+}
+
 export default memo(DateInput)
