diff --git a/frontend/lib/src/util/fuzzyFilterSelectOptions.test.ts b/frontend/lib/src/util/fuzzyFilterSelectOptions.test.ts
index 408401a86..a09e4b965 100644
--- a/frontend/lib/src/util/fuzzyFilterSelectOptions.test.ts
+++ b/frontend/lib/src/util/fuzzyFilterSelectOptions.test.ts
@@ -14,6 +14,8 @@
  * limitations under the License.
  */
 
+import shuffle from "lodash/shuffle"
+
 import { fuzzyFilterSelectOptions } from "~lib/util/fuzzyFilterSelectOptions"
 
 describe("fuzzyFilterSelectOptions", () => {
@@ -50,4 +52,34 @@ describe("fuzzyFilterSelectOptions", () => {
       "e2e/scripts/st_experimental_get_query_params.py",
     ])
   })
+
+  it("prioritizes matches well with case insensitivity", () => {
+    const options = [
+      { label: "Streamlit", value: "" },
+      { label: "Another streamlit", value: "" },
+      { label: "Yet another streamlit", value: "" },
+      { label: "Some estreamlit", value: "" },
+      { label: "mistreamlit", value: "" },
+    ]
+
+    const results1 = fuzzyFilterSelectOptions(options, "stre")
+    expect(results1.map(it => it.label)).toEqual([
+      "Streamlit",
+      "Another streamlit",
+      "Yet another streamlit",
+      "mistreamlit",
+      "Some estreamlit",
+    ])
+
+    // Randomize options to ensure order is not hiding an issue
+    const randomizedOptions = shuffle(options)
+    const results2 = fuzzyFilterSelectOptions(randomizedOptions, "stre")
+    expect(results2.map(it => it.label)).toEqual([
+      "Streamlit",
+      "Another streamlit",
+      "Yet another streamlit",
+      "mistreamlit",
+      "Some estreamlit",
+    ])
+  })
 })
diff --git a/frontend/lib/src/util/fuzzyFilterSelectOptions.ts b/frontend/lib/src/util/fuzzyFilterSelectOptions.ts
index 71ba10862..493eaf5b3 100644
--- a/frontend/lib/src/util/fuzzyFilterSelectOptions.ts
+++ b/frontend/lib/src/util/fuzzyFilterSelectOptions.ts
@@ -42,6 +42,6 @@ export function fuzzyFilterSelectOptions<T extends LabeledOption>(
     filteredOptions,
     // Use the negative score to sort the list in a stable manner
     // This ensures highest score is first
-    (opt: T) => -score(pattern, opt.label, true)
+    (opt: T) => -score(pattern, opt.label)
   )
 }
