diff --git a/e2e/scripts/redisplayed_widgets.py b/e2e/scripts/redisplayed_widgets.py
new file mode 100644
index 000000000..e08353d08
--- /dev/null
+++ b/e2e/scripts/redisplayed_widgets.py
@@ -0,0 +1,24 @@
+# Copyright 2018-2021 Streamlit Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import streamlit as st
+
+if st._is_running_with_streamlit:
+
+    if st.checkbox("checkbox 1"):
+        if st.checkbox("checkbox 2"):
+            st.write("hello")
+
+        if st.checkbox("checkbox 3", key="c3"):
+            st.write("goodbye")
diff --git a/e2e/specs/redisplayed_widgets.spec.js b/e2e/specs/redisplayed_widgets.spec.js
new file mode 100644
index 000000000..78f395baa
--- /dev/null
+++ b/e2e/specs/redisplayed_widgets.spec.js
@@ -0,0 +1,84 @@
+/**
+ * @license
+ * Copyright 2018-2021 Streamlit Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+describe("redisplayed widgets", () => {
+  beforeEach(() => {
+    cy.visit("http://localhost:3000/");
+  });
+
+  it("does not save widget state when widget is removed and redisplayed", () => {
+    cy.get(".stCheckbox")
+      .eq(0)
+      .click();
+
+    cy.wait(1000);
+
+    cy.get(".stCheckbox")
+      .eq(1)
+      .click();
+
+    cy.wait(1000);
+
+    cy.get(".stMarkdown")
+      .first()
+      .should("have.text", "hello");
+
+    cy.get(".stCheckbox")
+      .eq(0)
+      .click();
+
+    cy.wait(1000);
+
+    cy.get(".stCheckbox")
+      .eq(0)
+      .click();
+
+    cy.contains("hello").should("not.exist");
+  });
+
+  it("does save state when widget is removed and redisplayed if widget is keyed", () => {
+    cy.get(".stCheckbox")
+      .eq(0)
+      .click();
+
+    cy.wait(1000);
+
+    cy.get(".stCheckbox")
+      .eq(2)
+      .click();
+
+    cy.wait(1000);
+
+    cy.get(".stMarkdown")
+      .first()
+      .should("have.text", "goodbye");
+
+    cy.get(".stCheckbox")
+      .eq(0)
+      .click();
+
+    cy.wait(1000);
+
+    cy.get(".stCheckbox")
+      .eq(0)
+      .click();
+
+    cy.get(".stMarkdown")
+      .first()
+      .should("have.text", "goodbye");
+  });
+});
diff --git a/lib/streamlit/state/session_state.py b/lib/streamlit/state/session_state.py
index 556d77ffc..49c15c666 100644
--- a/lib/streamlit/state/session_state.py
+++ b/lib/streamlit/state/session_state.py
@@ -412,26 +412,51 @@ class SessionState(MutableMapping[str, Any]):
     def cull_nonexistent(self, widget_ids: Set[str]):
         self._new_widget_state.cull_nonexistent(widget_ids)
 
+        # Remove entries from _old_state corresponding to widgets not in
+        # widget_ids that do *not* have a user-defined key.
+        self._old_state = {
+            k: v
+            for k, v in self._old_state.items()
+            if (k in widget_ids or not k.startswith(GENERATED_WIDGET_KEY_PREFIX))
+        }
+
     def set_metadata(self, widget_metadata: WidgetMetadata) -> None:
         widget_id = widget_metadata.id
         self._new_widget_state.widget_metadata[widget_id] = widget_metadata
 
     def maybe_set_state_value(self, widget_id: str) -> bool:
+        """Keep widget_state and session_state in sync when a widget is registered.
+
+        This method returns whether the frontend needs to be updated with the
+        new value of this widget.
+        """
         widget_metadata = self._new_widget_state.widget_metadata[widget_id]
         deserializer = widget_metadata.deserializer
         initial_value = deserializer(None, widget_metadata.id)
 
         if widget_id not in self:
+            # This is the first time this widget is being registered, so we set
+            # its value in session_state and remember its initial_value.
             self._old_state[widget_id] = initial_value
             self._initial_widget_values[widget_id] = initial_value
+
         elif (
             widget_id in self._initial_widget_values
             and initial_value != self._initial_widget_values[widget_id]
         ):
+            # The initial_value of this widget has been changed (most likely by
+            # the user live-editing their script), so we update its value in
+            # widget_state and remember the new initial_value.
             self._new_widget_state.set_from_value(widget_id, initial_value)
             self._initial_widget_values[widget_id] = initial_value
             return True
 
+        elif widget_id in self and widget_id not in self._new_widget_state:
+            # This widget is being registered, but it had its value initially
+            # set via st.session_state, so we set it in widget_state to match.
+            self._new_widget_state.set_from_value(widget_id, self[widget_id])
+            return True
+
         return False
 
     def get_value_for_registration(self, widget_id: str) -> Any:
diff --git a/lib/tests/streamlit/state/session_state_test.py b/lib/tests/streamlit/state/session_state_test.py
index 6c28efce0..47666207a 100644
--- a/lib/tests/streamlit/state/session_state_test.py
+++ b/lib/tests/streamlit/state/session_state_test.py
@@ -504,10 +504,30 @@ class SessionStateMethodTests(unittest.TestCase):
         self.session_state._new_widget_state["foo"] = "bar"
         assert not self.session_state._widget_changed("foo")
 
+    def test_cull_nonexistent(self):
+        generated_widget_key = f"{GENERATED_WIDGET_KEY_PREFIX}-removed_widget"
+
+        self.session_state._old_state = {
+            "existing_widget": True,
+            generated_widget_key: True,
+            "val_set_via_state": 5,
+        }
+
+        wstates = WStates()
+        self.session_state._new_widget_state = wstates
+
+        self.session_state.cull_nonexistent({"existing_widget"})
+
+        assert self.session_state["existing_widget"] == True
+        assert generated_widget_key not in self.session_state
+        assert self.session_state["val_set_via_state"] == 5
+
     def test_maybe_set_state_value(self):
         wstates = WStates()
         self.session_state._new_widget_state = wstates
 
+        # The widget is being registered for the first time, so there's no need
+        # to have the frontend update with a new value.
         wstates.set_widget_metadata(
             WidgetMetadata(
                 id="widget_id_1",
@@ -519,6 +539,8 @@ class SessionStateMethodTests(unittest.TestCase):
         assert self.session_state.maybe_set_state_value("widget_id_1") == False
         assert self.session_state["widget_id_1"] == 0
 
+        # The initial value of this widget has changed, so we need to update
+        # it on the client.
         wstates.set_widget_metadata(
             WidgetMetadata(
                 id="widget_id_1",
@@ -530,6 +552,14 @@ class SessionStateMethodTests(unittest.TestCase):
         assert self.session_state.maybe_set_state_value("widget_id_1") == True
         assert self.session_state["widget_id_1"] == 1
 
+        # This widget's value was set via st.session_state before the widget was
+        # registered, so we need to update it on the client.
+        del self.session_state._initial_widget_values["widget_id_1"]
+        del self.session_state._new_widget_state["widget_id_1"]
+        self.session_state._old_state["widget_id_1"] = 2
+        assert self.session_state.maybe_set_state_value("widget_id_1") == True
+        assert self.session_state["widget_id_1"] == 2
+
 
 @patch(
     "streamlit.state.session_state.get_session_state",
