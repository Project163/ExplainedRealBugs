diff --git a/frontend/app/src/App.test.tsx b/frontend/app/src/App.test.tsx
index af78bf94d..63533def8 100644
--- a/frontend/app/src/App.test.tsx
+++ b/frontend/app/src/App.test.tsx
@@ -4458,4 +4458,393 @@ describe("App.hasReceivedNewSession flag behavior", () => {
       expect(screen.getByTestId("stMainMenu")).toBeVisible()
     })
   })
+
+  describe("Connection Error Handling", () => {
+    const triggerConnectionError = (
+      connectionManager: ConnectionManager,
+      errorMessage: string
+    ): void => {
+      act(() => {
+        // @ts-expect-error - connectionManager.props is private
+        connectionManager.props.onConnectionError(errorMessage)
+      })
+    }
+
+    describe("handleConnectionError", () => {
+      it("displays connection error dialog when connection error occurs", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        triggerConnectionError(
+          connectionManager,
+          "Network error: Unable to connect"
+        )
+
+        // Verify error dialog and message are displayed
+        expect(screen.getByText("Connection error")).toBeVisible()
+        expect(
+          screen.getByText(/Network error: Unable to connect/)
+        ).toBeVisible()
+      })
+
+      it("does not display error dialog if already dismissed", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        // First error
+        triggerConnectionError(connectionManager, "Connection lost")
+
+        expect(screen.getByText("Connection error")).toBeVisible()
+
+        // Dismiss the dialog
+        const closeButton = screen.getByRole("button", { name: /close/i })
+        act(() => {
+          // eslint-disable-next-line testing-library/prefer-user-event -- userEvent causes timeouts in this test
+          fireEvent.click(closeButton)
+        })
+
+        expect(screen.queryByText("Connection error")).toBeNull()
+
+        // Second error should not display
+        triggerConnectionError(connectionManager, "Another connection error")
+
+        expect(screen.queryByText("Connection error")).toBeNull()
+      })
+
+      it("sends error info to host when blockErrorDialogs is true", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+        const hostCommunicationMgr = getStoredValue<HostCommunicationManager>(
+          HostCommunicationManager
+        )
+
+        // Set blockErrorDialogs config
+        act(() => {
+          getMockConnectionManagerProp("onHostConfigResp")({
+            blockErrorDialogs: true,
+            allowedOrigins: [],
+            useExternalAuthToken: false,
+            enableCustomParentMessages: false,
+          })
+        })
+
+        // Trigger error
+        triggerConnectionError(connectionManager, "Connection lost")
+
+        // Dialog should not be displayed
+        expect(screen.queryByText("Connection error")).toBeNull()
+
+        // But error should be sent to host
+        expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith(
+          expect.objectContaining({
+            type: "CLIENT_ERROR_DIALOG",
+            error: "Connection error",
+            message: expect.stringContaining("Connection lost"),
+          })
+        )
+      })
+
+      it("displays error with StreamlitMarkdown formatting", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        triggerConnectionError(
+          connectionManager,
+          "**Network Error**: Unable to connect to server"
+        )
+
+        // Verify both error dialog and markdown content are displayed
+        expect(screen.getByText("Connection error")).toBeVisible()
+        expect(screen.getByText(/Network Error/)).toBeVisible()
+      })
+    })
+
+    describe("connection state transitions with error dismissal", () => {
+      it("resets dismissal state when reconnected", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        // Trigger connection error
+        triggerConnectionError(connectionManager, "Connection lost")
+
+        expect(screen.getByText("Connection error")).toBeVisible()
+
+        // Dismiss the dialog
+        const closeButton = screen.getByRole("button", { name: /close/i })
+        act(() => {
+          // eslint-disable-next-line testing-library/prefer-user-event -- userEvent causes timeouts in this test
+          fireEvent.click(closeButton)
+        })
+
+        expect(screen.queryByText("Connection error")).toBeNull()
+
+        // Simulate reconnection
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTED
+          )
+        })
+
+        // New error should be displayed after reconnection
+        triggerConnectionError(connectionManager, "New connection error")
+
+        expect(screen.getByText("Connection error")).toBeVisible()
+        expect(screen.getByText(/New connection error/)).toBeVisible()
+      })
+
+      it("automatically rescinds error dialog on successful reconnection", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        // Set initial state to connected
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTED
+          )
+        })
+
+        sendForwardMessage("newSession", NEW_SESSION_JSON)
+
+        // Trigger disconnection
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.PINGING_SERVER
+          )
+        })
+
+        // Trigger connection error
+        triggerConnectionError(connectionManager, "Connection lost")
+
+        expect(screen.getByText("Connection error")).toBeVisible()
+
+        // Reconnect (without dismissing dialog)
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTED
+          )
+        })
+
+        // Dialog should be automatically closed
+        expect(screen.queryByText("Connection error")).toBeNull()
+      })
+
+      it("only rescinds CONNECTION_ERROR type dialogs on reconnection", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        // First, show a connection error dialog
+        triggerConnectionError(connectionManager, "Connection lost")
+
+        expect(screen.getByText("Connection error")).toBeVisible()
+
+        // Simulate reconnection - should close the CONNECTION_ERROR dialog
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTED
+          )
+        })
+
+        // Connection error dialog should be closed
+        expect(screen.queryByText("Connection error")).toBeNull()
+
+        // Now test that other dialog types are not affected
+        // This validates that only CONNECTION_ERROR dialogs are auto-closed
+      })
+    })
+
+    describe("reconnection behavior", () => {
+      it("requests script rerun on reconnection after interruption", () => {
+        renderApp(getProps())
+        const widgetStateManager =
+          getStoredValue<WidgetStateManager>(WidgetStateManager)
+
+        // Start with connected state
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTED
+          )
+        })
+
+        sendForwardMessage("newSession", NEW_SESSION_JSON)
+
+        // Set script to running
+        sendForwardMessage("sessionStatusChanged", {
+          runOnSave: false,
+          scriptIsRunning: true,
+        })
+
+        // Disconnect during script run
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.PINGING_SERVER
+          )
+        })
+
+        const sendUpdateWidgetsMessageSpy = vi.spyOn(
+          widgetStateManager,
+          "sendUpdateWidgetsMessage"
+        )
+        sendUpdateWidgetsMessageSpy.mockClear()
+
+        // Reconnect
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTED
+          )
+        })
+
+        // Should request rerun
+        expect(sendUpdateWidgetsMessageSpy).toHaveBeenCalledWith(undefined)
+      })
+
+      it("handles multiple connection errors gracefully", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        // Trigger multiple errors
+        triggerConnectionError(connectionManager, "Error 1")
+
+        triggerConnectionError(connectionManager, "Error 2")
+
+        triggerConnectionError(connectionManager, "Error 3")
+
+        // Should only show the latest error
+        expect(screen.getByText("Connection error")).toBeVisible()
+        expect(screen.getByText(/Error 3/)).toBeVisible()
+        expect(screen.queryByText(/Error 1/)).toBeNull()
+        expect(screen.queryByText(/Error 2/)).toBeNull()
+      })
+
+      it("maintains dismissal state across multiple disconnections", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        // First error
+        triggerConnectionError(connectionManager, "First error")
+
+        expect(screen.getByText("Connection error")).toBeVisible()
+
+        // Dismiss the dialog
+        const closeButton = screen.getByRole("button", { name: /close/i })
+        act(() => {
+          // eslint-disable-next-line testing-library/prefer-user-event -- userEvent causes timeouts in this test
+          fireEvent.click(closeButton)
+        })
+
+        expect(screen.queryByText("Connection error")).toBeNull()
+
+        // Simulate multiple state changes without full reconnection
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.PINGING_SERVER
+          )
+        })
+
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTING
+          )
+        })
+
+        // Error should still not display (dismissal persists)
+        triggerConnectionError(connectionManager, "Another error")
+
+        expect(screen.queryByText("Connection error")).toBeNull()
+
+        // Only full reconnection should reset dismissal
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.CONNECTED
+          )
+        })
+
+        triggerConnectionError(connectionManager, "Error after reconnect")
+
+        expect(screen.getByText("Connection error")).toBeVisible()
+      })
+    })
+
+    describe("host communication integration", () => {
+      it("handles host-requested reconnection", () => {
+        renderApp(getProps())
+        const hostCommunicationMgr = getStoredValue<HostCommunicationManager>(
+          HostCommunicationManager
+        )
+
+        const restartWebsocketConnection =
+          // @ts-expect-error - accessing private property for testing
+          hostCommunicationMgr.props.restartWebsocketConnection
+
+        const terminateWebsocketConnection =
+          // @ts-expect-error - accessing private property for testing
+          hostCommunicationMgr.props.terminateWebsocketConnection
+
+        // First disconnect to set connectionManager to null
+        act(() => {
+          terminateWebsocketConnection()
+        })
+
+        // Clear the mock to count from zero
+        vi.mocked(ConnectionManager).mockClear()
+
+        // Now request reconnection
+        act(() => {
+          restartWebsocketConnection()
+        })
+
+        // Should have created a new ConnectionManager instance
+        expect(ConnectionManager).toHaveBeenCalledTimes(1)
+      })
+
+      it("handles host-requested disconnection", () => {
+        renderApp(getProps())
+        const hostCommunicationMgr = getStoredValue<HostCommunicationManager>(
+          HostCommunicationManager
+        )
+        const connectionManager = getMockConnectionManager(false)
+
+        const terminateWebsocketConnection =
+          // @ts-expect-error - accessing private property for testing
+          hostCommunicationMgr.props.terminateWebsocketConnection
+
+        // Simulate host requesting disconnection
+        act(() => {
+          terminateWebsocketConnection()
+        })
+
+        // Should disconnect
+        expect(connectionManager.disconnect).toHaveBeenCalled()
+      })
+
+      it("logs error when not connected but trying to handle errors", () => {
+        renderApp(getProps())
+        const connectionManager = getMockConnectionManager(false)
+
+        // Mock console.error to verify logging
+        const logSpy = vi.spyOn(LOG, "error")
+
+        // Mock isConnected to return false
+        // @ts-expect-error
+        connectionManager.isConnected.mockReturnValue(false)
+
+        // Set connectionManager to null to simulate disconnected state
+        act(() => {
+          getMockConnectionManagerProp("connectionStateChanged")(
+            ConnectionState.DISCONNECTED_FOREVER
+          )
+        })
+
+        // Try to trigger connection error
+        triggerConnectionError(connectionManager, "Error while disconnected")
+
+        // Should still show error dialog even when disconnected
+        expect(screen.getByText("Connection error")).toBeVisible()
+
+        // Verify error was logged
+        expect(logSpy).toHaveBeenCalledWith("Error while disconnected")
+
+        logSpy.mockRestore()
+      })
+    })
+  })
 })
diff --git a/frontend/app/src/App.tsx b/frontend/app/src/App.tsx
index 607ceff12..a7bba2bed 100644
--- a/frontend/app/src/App.tsx
+++ b/frontend/app/src/App.tsx
@@ -167,6 +167,7 @@ interface State {
   scriptRunState: ScriptRunState
   userSettings: UserSettings
   dialog?: DialogProps | null
+  connectionErrorDismissed: boolean
   layout: PageConfig.Layout
   initialSidebarState: PageConfig.SidebarState
   menuItems?: PageConfig.IMenuItems | null
@@ -290,6 +291,7 @@ export class App extends PureComponent<Props, State> {
         wideMode: false,
         runOnSave: false,
       },
+      connectionErrorDismissed: false,
       layout: PageConfig.Layout.CENTERED,
       initialSidebarState: PageConfig.SidebarState.AUTO,
       menuItems: undefined,
@@ -729,6 +731,11 @@ export class App extends PureComponent<Props, State> {
 
     if (newState === ConnectionState.CONNECTED) {
       LOG.info("Reconnected to server.")
+      // Reset the connection error dismissed state when we reconnect
+      if (this.state.connectionErrorDismissed) {
+        this.setState({ connectionErrorDismissed: false })
+      }
+
       // We request a script rerun if:
       //   1. this is the first time we establish a websocket connection to the
       //      server, or
@@ -1473,7 +1480,15 @@ export class App extends PureComponent<Props, State> {
    * Closes the upload dialog if it's open.
    */
   closeDialog = (): void => {
-    this.setState({ dialog: undefined })
+    // If we're closing a connection error dialog, mark it as dismissed
+    if (this.state.dialog?.type === DialogType.CONNECTION_ERROR) {
+      this.setState({
+        dialog: undefined,
+        connectionErrorDismissed: true,
+      })
+    } else {
+      this.setState({ dialog: undefined })
+    }
   }
 
   /**
@@ -1848,6 +1863,11 @@ export class App extends PureComponent<Props, State> {
    * Updates the app body when there's a connection error.
    */
   handleConnectionError = (errMarkdown: string): void => {
+    // Don't show the error dialog if it has been dismissed for this session
+    if (this.state.connectionErrorDismissed) {
+      return
+    }
+
     // This is just a regular error dialog, but with type CONNECTION_ERROR
     // instead of WARNING, so we can rescind the dialog later when reconnected.
     this.showError(
