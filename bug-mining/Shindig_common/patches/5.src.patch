diff --git a/java/common/pom.xml b/java/common/pom.xml
index c3915c58c..eda7631d0 100644
--- a/java/common/pom.xml
+++ b/java/common/pom.xml
@@ -73,5 +73,9 @@ under the License.
       <groupId>joda-time</groupId>
       <artifactId>joda-time</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.json</groupId>
+      <artifactId>json</artifactId>
+    </dependency>
   </dependencies>
 </project>
diff --git a/java/common/src/main/java/org/apache/shindig/common/ContainerConfig.java b/java/common/src/main/java/org/apache/shindig/common/ContainerConfig.java
new file mode 100644
index 000000000..c4c054480
--- /dev/null
+++ b/java/common/src/main/java/org/apache/shindig/common/ContainerConfig.java
@@ -0,0 +1,320 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.shindig.common;
+
+import org.apache.shindig.common.util.ResourceLoader;
+
+import com.google.inject.Inject;
+import com.google.inject.Singleton;
+import com.google.inject.name.Named;
+
+import org.apache.commons.lang.StringUtils;
+import org.json.JSONArray;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.logging.Logger;
+
+/**
+ * Represents a container configuration.
+ *
+ * See config/container.js for an example configuration.
+ *
+ * We use a cascading model, so you only have to specify attributes in
+ * your config that you actually want to change.
+ */
+@Singleton
+public class ContainerConfig {
+  private final Map<String, JSONObject> config;
+  public static final char FILE_SEPARATOR = ',';
+  public static final String DEFAULT_CONTAINER = "default";
+  public static final String PARENT_KEY = "parent";
+  // TODO: Rename this to simply "container", gadgets.container is unnecessary.
+  public static final String CONTAINER_KEY = "gadgets.container";
+  private static final Logger logger
+      = Logger.getLogger("org.apache.shindig.gadgets");
+
+  /**
+   * @return The set of all containers that are currently registered.
+   */
+  public Collection<String> getContainers() {
+    return Collections.unmodifiableSet(config.keySet());
+  }
+
+  /**
+   * Fetches a configuration parameter as a JSON object, array, string, or
+   * number, ensuring that it can be safely passed to javascript without any
+   * additional filtering.
+   *
+   * @param container
+   * @param parameter The value to fetch. May be specified as an x-path like
+   *     object reference such as "gadgets/features/views".
+   * @return A configuration parameter as a JSON object or null if not set or
+   *     can't be interpreted as JSON.
+   */
+  public Object getJson(String container, String parameter) {
+    JSONObject data = config.get(container);
+    if (data == null) {
+      return null;
+    }
+    if (parameter == null) {
+      return data;
+    }
+
+    try {
+      for (String param : parameter.split("/")) {
+        Object next = data.get(param);
+        if (next instanceof JSONObject) {
+          data = (JSONObject)next;
+        } else {
+          return next;
+        }
+      }
+      return data;
+    } catch (JSONException e) {
+      return null;
+    }
+  }
+
+  /**
+   * Attempts to fetch a parameter for the given container, or the default
+   * container if the specified container is not supported.
+   *
+   * @param container
+   * @param parameter
+   * @return A configuration parameter as a string, or null if not set.
+   */
+  public String get(String container, String parameter) {
+    Object data = getJson(container, parameter);
+    return data == null ? null : data.toString();
+  }
+
+  /**
+   * @param container
+   * @param parameter
+   * @return A configuration parameter as a JSON object or null if not set or
+   *     can't be interpreted as JSON.
+   */
+  public JSONObject getJsonObject(String container, String parameter) {
+    Object data = getJson(container, parameter);
+    if (data instanceof JSONObject) {
+      return (JSONObject)data;
+    }
+    return null;
+  }
+
+  /**
+   * @param container
+   * @param parameter
+   * @return A configuration parameter as a JSON object or null if not set or
+   *     can't be interpreted as JSON.
+   */
+  public JSONArray getJsonArray(String container, String parameter) {
+    Object data = getJson(container, parameter);
+    if (data instanceof JSONArray) {
+      return (JSONArray)data;
+    }
+    return null;
+  }
+
+  /**
+   * Loads containers from directories recursively.
+   *
+   * Only files with a .js or .json extension will be loaded.
+   *
+   * @param files The files to examine.
+   * @throws ContainerConfigException
+   */
+  private void loadFiles(File[] files) throws ContainerConfigException {
+    try {
+      for (File file : files) {
+        logger.info("Reading container config: " + file.getName());
+        if (file.isDirectory()) {
+          loadFiles(file.listFiles());
+        } else if (file.getName().endsWith(".js") ||
+                   file.getName().endsWith(".json")) {
+          loadFromString(ResourceLoader.getContent(file));
+        }
+      }
+    } catch (IOException e) {
+      throw new ContainerConfigException(e);
+    }
+  }
+
+  /**
+   * Loads resources recursively.
+   * @param files The base paths to look for container.xml
+   * @throws ContainerConfigException
+   */
+  private void loadResources(String[] files)  throws ContainerConfigException {
+    try {
+      for (String entry : files) {
+        logger.info("Reading container config: " + entry);
+        String content = ResourceLoader.getContent(entry);
+        loadFromString(content);
+      }
+    } catch (IOException e) {
+      throw new ContainerConfigException(e);
+    }
+  }
+
+  /**
+   * Merges two JSON objects together (recursively), with values from "merge"
+   * replacing values in "base" to produce a new object.
+   *
+   * @param base The base object that values will be replaced into.
+   * @param merge The object to merge values from.
+   *
+   * @throws JSONException if the two objects can't be merged for some reason.
+   */
+  private JSONObject mergeObjects(JSONObject base, JSONObject merge)
+      throws JSONException {
+    // Clone the initial object (JSONObject doesn't support "clone").
+
+    JSONObject clone = new JSONObject(base, JSONObject.getNames(base));
+    // Walk parameter list for the merged object and merge recursively.
+    String[] fields = JSONObject.getNames(merge);
+    for (String field : fields) {
+      Object existing = clone.opt(field);
+      Object update = merge.get(field);
+      if (existing == null || update == null) {
+        // It's new custom config, not referenced in the prototype, or
+        // it's removing a pre-configured value.
+        clone.put(field, update);
+      } else {
+        // Merge if object type is JSONObject.
+        if (update instanceof JSONObject &&
+            existing instanceof JSONObject) {
+          clone.put(field, mergeObjects((JSONObject)existing,
+                                        (JSONObject)update));
+        } else {
+          // Otherwise we just overwrite it.
+          clone.put(field, update);
+        }
+      }
+    }
+    return clone;
+  }
+
+  /**
+   * Recursively merge values from parent objects in the prototype chain.
+   *
+   * @return The object merged with all parents.
+   *
+   * @throws ContainerConfigException If there is an invalid parent parameter
+   *    in the prototype chain.
+   */
+  private JSONObject mergeParents(String container)
+      throws ContainerConfigException, JSONException {
+    JSONObject base = config.get(container);
+    if (DEFAULT_CONTAINER.equals(container)) {
+      return base;
+    }
+
+    String parent = base.optString(PARENT_KEY, DEFAULT_CONTAINER);
+    if (!config.containsKey(parent)) {
+      throw new ContainerConfigException(
+          "Unable to locate parent '" + parent + "' required by "
+          + base.getString(CONTAINER_KEY));
+    }
+    return mergeObjects(mergeParents(parent), base);
+  }
+
+  /**
+   * Processes a container file.
+   *
+   * @param json
+   * @throws ContainerConfigException
+   */
+  protected void loadFromString(String json) throws ContainerConfigException {
+    try {
+      JSONObject contents = new JSONObject(json);
+      JSONArray containers = contents.getJSONArray(CONTAINER_KEY);
+
+      for (int i = 0, j = containers.length(); i < j; ++i) {
+        // Copy the default object and produce a new one.
+        String container = containers.getString(i);
+        config.put(container, contents);
+      }
+    } catch (JSONException e) {
+      throw new ContainerConfigException(e);
+    }
+  }
+
+  /**
+   * Loads containers from the specified resource. Follows the same rules
+   * as {@code JsFeatureLoader.loadFeatures} for locating resources.
+   *
+   * @param path
+   * @throws ContainerConfigException
+   */
+  private void loadContainers(String path) throws ContainerConfigException {
+    try {
+      for (String location : StringUtils.split(path, FILE_SEPARATOR)) {
+        if (location.startsWith("res://")) {
+          location = location.substring(6);
+          logger.info("Loading resources from: " + location);
+          if (path.endsWith(".txt")) {
+            loadResources(ResourceLoader.getContent(location).split("[\r\n]+"));
+          } else {
+            loadResources(new String[]{location});
+          }
+        } else {
+          logger.info("Loading files from: " + location);
+          File file = new File(location);
+          loadFiles(new File[]{file});
+        }
+      }
+
+      // Now that all containers are loaded, we go back through them and merge
+      // recursively. This is done at startup to simplify lookups.
+      Map<String, JSONObject> merged
+          = new HashMap<String, JSONObject>(config.size());
+      for (String container : config.keySet()) {
+        merged.put(container, mergeParents(container));
+      }
+      config.putAll(merged);
+    } catch (IOException e) {
+      throw new ContainerConfigException(e);
+    } catch (JSONException e) {
+      throw new ContainerConfigException(e);
+    }
+  }
+
+  /**
+   * Creates a new, empty configuration.
+   * @param containers
+   * @throws ContainerConfigException
+   */
+  @Inject
+  public ContainerConfig(@Named("containers.default") String containers)
+      throws ContainerConfigException {
+    config = new HashMap<String, JSONObject>();
+    if (containers != null) {
+      loadContainers(containers);
+    }
+  }
+}
\ No newline at end of file
diff --git a/java/common/src/test/java/org/apache/shindig/common/ContainerConfigTest.java b/java/common/src/test/java/org/apache/shindig/common/ContainerConfigTest.java
new file mode 100644
index 000000000..81897e068
--- /dev/null
+++ b/java/common/src/test/java/org/apache/shindig/common/ContainerConfigTest.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.shindig.common;
+
+import static org.apache.shindig.common.ContainerConfig.CONTAINER_KEY;
+import static org.apache.shindig.common.ContainerConfig.DEFAULT_CONTAINER;
+import static org.apache.shindig.common.ContainerConfig.PARENT_KEY;
+import static org.junit.Assert.assertEquals;
+
+import org.json.JSONArray;
+import org.json.JSONObject;
+import org.junit.Test;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+
+public class ContainerConfigTest {
+
+  private static final String TOP_LEVEL_NAME = "Top level name";
+  private static final String TOP_LEVEL_VALUE = "Top level value";
+
+  private static final String NESTED_KEY = "ne$ted";
+  private static final String NESTED_NAME = "Nested name";
+  private static final String NESTED_VALUE = "Nested value";
+  private static final String NESTED_ALT_VALUE = "Nested value alt";
+
+  private static final String CHILD_CONTAINER = "child";
+  private static final String CONTAINER_A = "container-a";
+  private static final String CONTAINER_B = "container-b";
+
+  private static final String ARRAY_NAME = "array value";
+  private static final String[] ARRAY_VALUE = new String[]{"Hello", "World"};
+  private static final String ARRAY_ALT_VALUE = "Not an array";
+
+  private File createContainer(JSONObject json) throws Exception {
+    File file = File.createTempFile(getClass().getName(), ".json");
+    file.deleteOnExit();
+    BufferedWriter out = new BufferedWriter(new FileWriter(file));
+    out.write(json.toString());
+    out.close();
+    return file;
+  }
+
+  private File createDefaultContainer() throws Exception {
+
+    // We use a JSON Object here to guarantee that we're well formed up front.
+    JSONObject json = new JSONObject();
+    json.put(CONTAINER_KEY, new String[]{DEFAULT_CONTAINER});
+    json.put(TOP_LEVEL_NAME, TOP_LEVEL_VALUE);
+    json.put(ARRAY_NAME, ARRAY_VALUE);
+
+    // small nested data.
+    JSONObject nested = new JSONObject();
+    nested.put(NESTED_NAME, NESTED_VALUE);
+
+    json.put(NESTED_KEY, nested);
+    return createContainer(json);
+  }
+
+  @Test
+  public void parseBasicConfig() throws Exception {
+    ContainerConfig config
+        = new ContainerConfig(createDefaultContainer().getAbsolutePath());
+
+    assertEquals(1, config.getContainers().size());
+    for (String container : config.getContainers()) {
+      assertEquals(DEFAULT_CONTAINER, container);
+    }
+
+    String value = config.get(DEFAULT_CONTAINER, TOP_LEVEL_NAME);
+    assertEquals(TOP_LEVEL_VALUE, value);
+
+    JSONObject nested = config.getJsonObject(DEFAULT_CONTAINER, NESTED_KEY);
+
+    String nestedValue = nested.getString(NESTED_NAME);
+
+    assertEquals(NESTED_VALUE, nestedValue);
+  }
+
+  @Test
+  public void aliasesArePopulated() throws Exception {
+    JSONObject json = new JSONObject()
+        .put(CONTAINER_KEY, new String[]{CONTAINER_A, CONTAINER_B})
+        .put(NESTED_KEY, NESTED_VALUE);
+
+    File parentFile = createDefaultContainer();
+    File childFile = createContainer(json);
+
+    ContainerConfig config = new ContainerConfig(childFile.getAbsolutePath() +
+        ContainerConfig.FILE_SEPARATOR + parentFile.getAbsolutePath());
+
+    assertEquals(NESTED_VALUE, config.get(CONTAINER_A, NESTED_KEY));
+    assertEquals(NESTED_VALUE, config.get(CONTAINER_B, NESTED_KEY));
+  }
+
+  @Test
+  public void parseWithDefaultInheritance() throws Exception {
+    JSONObject json = new JSONObject();
+    json.put(CONTAINER_KEY, new String[]{CHILD_CONTAINER});
+    json.put(PARENT_KEY, DEFAULT_CONTAINER);
+    json.put(ARRAY_NAME, ARRAY_ALT_VALUE);
+
+    // small nested data.
+    JSONObject nested = new JSONObject();
+    nested.put(NESTED_NAME, NESTED_ALT_VALUE);
+
+    json.put(NESTED_KEY, nested);
+
+    File childFile = createContainer(json);
+    File parentFile = createDefaultContainer();
+    ContainerConfig config = new ContainerConfig(childFile.getAbsolutePath() +
+        ContainerConfig.FILE_SEPARATOR + parentFile.getAbsolutePath());
+
+    String value = config.get(CHILD_CONTAINER, TOP_LEVEL_NAME);
+    assertEquals(TOP_LEVEL_VALUE, value);
+
+    JSONObject nestedObj = config.getJsonObject(CHILD_CONTAINER, NESTED_KEY);
+    String nestedValue = nestedObj.getString(NESTED_NAME);
+    assertEquals(NESTED_ALT_VALUE, nestedValue);
+
+    String arrayValue = config.get(CHILD_CONTAINER, ARRAY_NAME);
+    assertEquals(ARRAY_ALT_VALUE, arrayValue);
+
+    // Verify that the parent value wasn't overwritten as well.
+
+    JSONArray defaultArrayTest = config.getJsonArray(DEFAULT_CONTAINER,
+                                                     ARRAY_NAME);
+    JSONArray defaultArray = new JSONArray(ARRAY_VALUE);
+    assertEquals(defaultArrayTest.toString(), defaultArray.toString());
+  }
+
+  @Test(expected = ContainerConfigException.class)
+  public void badConfigThrows() throws Exception {
+    JSONObject json = new JSONObject();
+    json.put(CONTAINER_KEY, new String[]{CHILD_CONTAINER});
+    json.put(PARENT_KEY, "bad bad bad parent!");
+    json.put(ARRAY_NAME, ARRAY_ALT_VALUE);
+
+    ContainerConfig config
+        = new ContainerConfig(createContainer(json).getAbsolutePath());
+  }
+
+  public void testPathQuery() throws Exception {
+    ContainerConfig config
+        = new ContainerConfig(createDefaultContainer().getAbsolutePath());
+    String path = NESTED_KEY + '/' + NESTED_NAME;
+    String data = config.get(DEFAULT_CONTAINER, path);
+    assertEquals(NESTED_VALUE, data);
+  }
+}
