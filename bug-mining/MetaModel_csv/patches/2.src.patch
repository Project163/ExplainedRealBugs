diff --git a/csv/src/main/java/org/apache/metamodel/csv/CsvDataSet.java b/csv/src/main/java/org/apache/metamodel/csv/CsvDataSet.java
index 4bfb18ca..2edacb1a 100644
--- a/csv/src/main/java/org/apache/metamodel/csv/CsvDataSet.java
+++ b/csv/src/main/java/org/apache/metamodel/csv/CsvDataSet.java
@@ -31,97 +31,99 @@ import au.com.bytecode.opencsv.CSVReader;
 
 /**
  * Streaming DataSet implementation for CSV support
- * 
- * @author Kasper SÃ¸rensen
  */
 final class CsvDataSet extends AbstractDataSet {
 
-	private final CSVReader _reader;
-	private final boolean _failOnInconsistentRowLength;
-	private final int _columnsInTable;
-	private volatile int _rowNumber;
-	private volatile Integer _rowsRemaining;
-	private volatile Row _row;
+    private final CSVReader _reader;
+    private final boolean _failOnInconsistentRowLength;
+    private final int _columnsInTable;
+    private volatile int _rowNumber;
+    private volatile Integer _rowsRemaining;
+    private volatile Row _row;
 
-	public CsvDataSet(CSVReader reader, Column[] columns, Integer maxRows,
-			int columnsInTable, boolean failOnInconsistentRowLength) {
-	    super(columns);
-		_reader = reader;
-		_columnsInTable = columnsInTable;
-		_failOnInconsistentRowLength = failOnInconsistentRowLength;
-		_rowNumber = 0;
-		_rowsRemaining = maxRows;
-	}
+    public CsvDataSet(CSVReader reader, Column[] columns, Integer maxRows, int columnsInTable,
+            boolean failOnInconsistentRowLength) {
+        super(columns);
+        _reader = reader;
+        _columnsInTable = columnsInTable;
+        _failOnInconsistentRowLength = failOnInconsistentRowLength;
+        _rowNumber = 0;
+        _rowsRemaining = maxRows;
+    }
 
-	@Override
-	public void close() {
-		FileHelper.safeClose(_reader);
-		_row = null;
-		_rowsRemaining = null;
-	}
-	
-	@Override
-	protected void finalize() throws Throwable {
-		super.finalize();
-		// close is always safe to invoke
-		close();
-	}
+    @Override
+    public void close() {
+        FileHelper.safeClose(_reader);
+        _row = null;
+        _rowsRemaining = null;
+    }
 
-	@Override
-	public Row getRow() throws MetaModelException {
-		return _row;
-	}
+    @Override
+    protected void finalize() throws Throwable {
+        super.finalize();
+        // close is always safe to invoke
+        close();
+    }
 
-	@Override
-	public boolean next() {
-		if (_rowsRemaining != null && _rowsRemaining > 0) {
-			_rowsRemaining--;
-			return nextInternal();
-		} else if (_rowsRemaining == null) {
-			return nextInternal();
-		} else {
-			return false;
-		}
-	}
-	
-	private boolean nextInternal() {
-		if (_reader == null) {
-			return false;
-		}
-		final String[] csvValues;
-		try {
-			csvValues = _reader.readNext();
-		} catch (IOException e) {
-			throw new IllegalStateException("Exception reading from file", e);
-		}
-		if (csvValues == null) {
-			close();
-			return false;
-		}
-		
-		final int size = getHeader().size();
-		final Object[] rowValues = new Object[size];
-		for (int i = 0; i < size; i++) {
-			Column column = getHeader().getSelectItem(i).getColumn();
-			int columnNumber = column.getColumnNumber();
-			if (columnNumber < csvValues.length) {
-				rowValues[i] = csvValues[columnNumber];
-			} else {
-				// Ticket #125: Missing values should be enterpreted as
-				// null.
-				rowValues[i] = null;
-			}
-		}
-		_row = new DefaultRow(getHeader(), rowValues);
+    @Override
+    public Row getRow() throws MetaModelException {
+        return _row;
+    }
 
-		if (_failOnInconsistentRowLength) {
-			_rowNumber++;
-			if (_columnsInTable != csvValues.length) {
-				throw new InconsistentRowLengthException(_columnsInTable, _row,
-						csvValues, _rowNumber);
-			}
-		}
+    @Override
+    public boolean next() {
+        if (_rowsRemaining != null && _rowsRemaining > 0) {
+            _rowsRemaining--;
+            return nextInternal();
+        } else if (_rowsRemaining == null) {
+            return nextInternal();
+        } else {
+            return false;
+        }
+    }
 
-		return true;
-	}
+    private boolean nextInternal() {
+        if (_reader == null) {
+            return false;
+        }
+        final String[] csvValues;
+        try {
+            csvValues = _reader.readNext();
+        } catch (IOException e) {
+            throw new IllegalStateException("Exception reading from file", e);
+        }
+        if (csvValues == null) {
+            close();
+            return false;
+        }
+
+        if (csvValues.length == 1 && "".equals(csvValues[0])) {
+            // blank line - move to next line
+            return nextInternal();
+        }
+
+        final int size = getHeader().size();
+        final Object[] rowValues = new Object[size];
+        for (int i = 0; i < size; i++) {
+            Column column = getHeader().getSelectItem(i).getColumn();
+            int columnNumber = column.getColumnNumber();
+            if (columnNumber < csvValues.length) {
+                rowValues[i] = csvValues[columnNumber];
+            } else {
+                // Ticket #125: Missing values should be enterpreted as
+                // null.
+                rowValues[i] = null;
+            }
+        }
+        _row = new DefaultRow(getHeader(), rowValues);
+
+        if (_failOnInconsistentRowLength) {
+            _rowNumber++;
+            if (_columnsInTable != csvValues.length) {
+                throw new InconsistentRowLengthException(_columnsInTable, _row, csvValues, _rowNumber);
+            }
+        }
+
+        return true;
+    }
 }
\ No newline at end of file
diff --git a/csv/src/main/java/org/apache/metamodel/csv/SingleLineCsvDataSet.java b/csv/src/main/java/org/apache/metamodel/csv/SingleLineCsvDataSet.java
index 2d8a800e..de6e7eb4 100644
--- a/csv/src/main/java/org/apache/metamodel/csv/SingleLineCsvDataSet.java
+++ b/csv/src/main/java/org/apache/metamodel/csv/SingleLineCsvDataSet.java
@@ -107,6 +107,11 @@ final class SingleLineCsvDataSet extends AbstractDataSet {
                 return false;
             }
 
+            if ("".equals(line)) {
+                // blank line - move to next line
+                return nextInternal();
+            }
+
             _rowNumber++;
             _row = new SingleLineCsvRow(this, line, _columnsInTable, _failOnInconsistentRowLength, _rowNumber);
             return true;
diff --git a/csv/src/test/java/org/apache/metamodel/csv/CsvDataContextTest.java b/csv/src/test/java/org/apache/metamodel/csv/CsvDataContextTest.java
index e9b0f5bd..18160ee3 100644
--- a/csv/src/test/java/org/apache/metamodel/csv/CsvDataContextTest.java
+++ b/csv/src/test/java/org/apache/metamodel/csv/CsvDataContextTest.java
@@ -88,6 +88,30 @@ public class CsvDataContextTest extends TestCase {
                 .readFileAsString(targetFile).replaceAll("\n", "!LINEBREAK!"));
     }
 
+    public void testHandlingOfEmptyLinesMultipleLinesSupport() throws Exception {
+        // test with multiline values
+        DataContext dc = new CsvDataContext(new File("src/test/resources/csv_with_empty_lines.csv"),
+                new CsvConfiguration(1, false, true));
+        testHandlingOfEmptyLines(dc);
+    }
+
+    public void testHandlingOfEmptyLinesSingleLinesSupport() throws Exception {
+        // test with only single line values
+        DataContext dc = new CsvDataContext(new File("src/test/resources/csv_with_empty_lines.csv"),
+                new CsvConfiguration(1, false, false));
+        testHandlingOfEmptyLines(dc);
+    }
+
+    public void testHandlingOfEmptyLines(DataContext dc) throws Exception {
+        DataSet ds = dc.query().from(dc.getDefaultSchema().getTable(0)).selectAll().execute();
+        assertTrue(ds.next());
+        assertEquals("Row[values=[hello, world]]", ds.getRow().toString());
+        assertTrue(ds.next());
+        assertEquals("Row[values=[hi, there]]", ds.getRow().toString());
+        assertFalse(ds.next());
+        ds.close();
+    }
+
     public void testEmptyFileNoHeaderLine() throws Exception {
         DataContext dc = new CsvDataContext(new File("src/test/resources/empty_file.csv"), new CsvConfiguration(
                 CsvConfiguration.NO_COLUMN_NAME_LINE));
diff --git a/csv/src/test/resources/csv_with_empty_lines.csv b/csv/src/test/resources/csv_with_empty_lines.csv
new file mode 100644
index 00000000..40c27877
--- /dev/null
+++ b/csv/src/test/resources/csv_with_empty_lines.csv
@@ -0,0 +1,5 @@
+foo,bar
+hello,world
+
+
+hi,there
