diff --git a/nbxml/src/main/java/org/apache/vysper/xml/decoder/DocumentContentHandler.java b/nbxml/src/main/java/org/apache/vysper/xml/decoder/DocumentContentHandler.java
new file mode 100644
index 00000000..6162707b
--- /dev/null
+++ b/nbxml/src/main/java/org/apache/vysper/xml/decoder/DocumentContentHandler.java
@@ -0,0 +1,171 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *
+ */
+package org.apache.vysper.xml.decoder;
+
+import org.apache.vysper.xml.fragment.Renderer;
+import org.apache.vysper.xml.fragment.XMLElement;
+import org.apache.vysper.xml.fragment.XMLElementBuilder;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.xml.sax.Attributes;
+import org.xml.sax.ContentHandler;
+import org.xml.sax.Locator;
+import org.xml.sax.SAXException;
+
+/**
+ * SAX content handler for the purpose of emitting a complete XML document
+ *
+ * @author The Apache MINA Project (dev@mina.apache.org)
+ */
+public class DocumentContentHandler implements ContentHandler {
+
+    private Logger log = LoggerFactory.getLogger(DocumentContentHandler.class);
+
+    private XMLElementBuilder builder;
+
+    private int depth = 0;
+
+    private XMLElementListener listener;
+
+    public XMLElementListener getListener() {
+        return listener;
+    }
+
+    public void setListener(XMLElementListener listener) {
+        this.listener = listener;
+    }
+
+    public DocumentContentHandler() {
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void characters(char[] ch, int start, int length) throws SAXException {
+        // TODO handle start and length
+        if (builder != null) {
+            builder.addText(new String(ch));
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void endElement(String uri, String localName, String qName) throws SAXException {
+        depth--;
+        if (depth == 0) {
+            // complete document, emit
+            emit();
+        } else {
+            builder.endInnerElement();
+        }
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {
+        // increase element depth
+        depth++;
+        if (builder == null) {
+            builder = new XMLElementBuilder(localName, uri, extractPrefix(qName), null, null);
+        } else {
+            builder.startInnerElement(localName, uri);
+        }
+
+        for (int i = 0; i < atts.getLength(); i++) {
+            builder.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getValue(i));
+        }
+    }
+
+    private void emit() {
+        XMLElement element = builder.build();
+
+        if (log.isDebugEnabled()) {
+            log.debug("Decoder writing stanza: {}", new Renderer(element).getComplete());
+        }
+
+        if (listener != null) {
+            listener.element(element);
+        }
+
+        builder = null;
+    }
+
+    private String extractPrefix(String qname) {
+        int index = qname.indexOf(':');
+        if (index > -1) {
+            return qname.substring(0, index);
+        } else {
+            return "";
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void endDocument() throws SAXException { /* ignore */
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void startPrefixMapping(String prefix, String uri) throws SAXException { /* ignore */
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void endPrefixMapping(String prefix) throws SAXException { /* ignore */
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException { /* ignore */
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void processingInstruction(String target, String data) throws SAXException { /* ignore */
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void setDocumentLocator(Locator locator) { /* ignore */
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void skippedEntity(String name) throws SAXException { /* ignore */
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void startDocument() throws SAXException {
+        depth = 0;
+        builder = null;
+    }
+}
diff --git a/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMLElementListener.java b/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMLElementListener.java
new file mode 100644
index 00000000..f4eb235d
--- /dev/null
+++ b/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMLElementListener.java
@@ -0,0 +1,26 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ *
+ */
+package org.apache.vysper.xml.decoder;
+
+import org.apache.vysper.xml.fragment.XMLElement;
+
+public interface XMLElementListener {
+    void element(XMLElement element);
+}
\ No newline at end of file
diff --git a/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPContentHandler.java b/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPContentHandler.java
index d8a31e0d..dc32873b 100644
--- a/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPContentHandler.java
+++ b/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPContentHandler.java
@@ -46,20 +46,16 @@ public class XMPPContentHandler implements ContentHandler {
 
     private int depth = 0;
 
-    private StanzaListener listener;
+    private XMLElementListener listener;
 
-    public StanzaListener getListener() {
+    public XMLElementListener getListener() {
         return listener;
     }
 
-    public void setListener(StanzaListener listener) {
+    public void setListener(XMLElementListener listener) {
         this.listener = listener;
     }
 
-    public static interface StanzaListener {
-        void stanza(XMLElement element);
-    }
-
     public XMPPContentHandler() {
     }
 
@@ -85,7 +81,7 @@ public class XMPPContentHandler implements ContentHandler {
         depth--;
         if (depth == 1) {
             // complete stanza, emit
-            emitStanza();
+            emit();
         } else if (depth == 0) {
             // end stream:stream element
             // TODO handle
@@ -113,11 +109,11 @@ public class XMPPContentHandler implements ContentHandler {
 
         if (depth == 1) {
             // outer stream:stream element, needs to be dispatched right away
-            emitStanza();
+            emit();
         }
     }
 
-    private void emitStanza() {
+    private void emit() {
         XMLElement element = builder.build();
 
         if (log.isDebugEnabled()) {
@@ -125,7 +121,7 @@ public class XMPPContentHandler implements ContentHandler {
         }
 
         if (listener != null) {
-            listener.stanza(element);
+            listener.element(element);
         }
 
         builder = null;
diff --git a/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPDecoder.java b/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPDecoder.java
index af60db7f..4eb359eb 100644
--- a/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPDecoder.java
+++ b/nbxml/src/main/java/org/apache/vysper/xml/decoder/XMPPDecoder.java
@@ -24,7 +24,6 @@ import org.apache.mina.core.session.IoSession;
 import org.apache.mina.filter.codec.CumulativeProtocolDecoder;
 import org.apache.mina.filter.codec.ProtocolDecoderOutput;
 import org.apache.vysper.charset.CharsetUtil;
-import org.apache.vysper.xml.decoder.XMPPContentHandler.StanzaListener;
 import org.apache.vysper.xml.fragment.XMLElement;
 import org.apache.vysper.xml.sax.NonBlockingXMLReader;
 import org.apache.vysper.xml.sax.impl.DefaultNonBlockingXMLReader;
@@ -52,14 +51,14 @@ public class XMPPDecoder extends CumulativeProtocolDecoder {
         this.builderFactory = builderFactory;
     }
 
-    public static class MinaStanzaListener implements StanzaListener {
+    public static class MinaStanzaListener implements XMLElementListener {
         private ProtocolDecoderOutput protocolDecoder;
 
         public MinaStanzaListener(ProtocolDecoderOutput protocolDecoder) {
             this.protocolDecoder = protocolDecoder;
         }
 
-        public void stanza(XMLElement element) {
+        public void element(XMLElement element) {
             if (element.getName().equals("stream")) {
                 // reset the reader 
             }
diff --git a/nbxml/src/main/java/org/apache/vysper/xml/fragment/XMLElement.java b/nbxml/src/main/java/org/apache/vysper/xml/fragment/XMLElement.java
index b19f385f..430435ad 100644
--- a/nbxml/src/main/java/org/apache/vysper/xml/fragment/XMLElement.java
+++ b/nbxml/src/main/java/org/apache/vysper/xml/fragment/XMLElement.java
@@ -26,6 +26,7 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.regex.Pattern;
 
 /**
  * an immutable xml element specialized for XMPP.
@@ -73,14 +74,26 @@ public class XMLElement implements XMLFragment {
     public XMLElement(String namespaceURI, String name, String namespacePrefix, List<Attribute> attributes,
             List<XMLFragment> innerFragments, Map<String, String> namespaces) {
         this.namespaceURI = namespaceURI == null ? Namespaces.DEFAULT_NAMESPACE_URI : namespaceURI;
+
+        if(namespacePrefix != null && namespacePrefix.length() > 0) {
+            if(!isValidName(namespacePrefix) || namespacePrefix.contains(":")) throw new IllegalArgumentException("Invalid XML element namespace prefix");
+        }
         this.namespacePrefix = namespacePrefix == null ? Namespaces.DEFAULT_NAMESPACE_PREFIX : namespacePrefix;
+        
+        if(name == null || !isValidName(name)) throw new IllegalArgumentException("Invalid XML element name");
         this.name = name;
         this.attributes = (attributes == null) ? Collections.EMPTY_LIST : Collections.unmodifiableList(attributes);
         this.namespaces = (namespaces == null) ? Collections.EMPTY_MAP : Collections.unmodifiableMap(namespaces);
         this.innerFragments = (innerFragments == null) ? Collections.EMPTY_LIST : Collections
                 .unmodifiableList(innerFragments);
-        if (name == null)
-            throw new IllegalArgumentException("XMLElement name cannot be null");
+    }
+    
+    private static final String NAME_START_CHAR = "A-Za-z\\_\\:";
+    private static final String NAME_CHAR = NAME_START_CHAR + "\\-\\.0-9";
+    private static final Pattern namePattern = Pattern.compile("[" + NAME_START_CHAR + "][" + NAME_CHAR + "]*");
+    private boolean isValidName(String name) {
+        // TODO add additional char ranges
+        return namePattern.matcher(name).matches();
     }
 
     public String getName() {
@@ -217,7 +230,7 @@ public class XMLElement implements XMLFragment {
     }
 
     /**
-     * collects all inner elements named as given parameter
+     * collects all inner elements named as given parameter. Namespace UIR is ignored.
      * @param name - must not be NULL
      */
     public List<XMLElement> getInnerElementsNamed(String name) {
diff --git a/nbxml/src/test/java/org/apache/vysper/xml/fragment/XMLElementTestCase.java b/nbxml/src/test/java/org/apache/vysper/xml/fragment/XMLElementTestCase.java
index a0cf8b15..a0b571a6 100644
--- a/nbxml/src/test/java/org/apache/vysper/xml/fragment/XMLElementTestCase.java
+++ b/nbxml/src/test/java/org/apache/vysper/xml/fragment/XMLElementTestCase.java
@@ -157,6 +157,15 @@ public class XMLElementTestCase extends TestCase {
         }
     }
 
+    public void testPrefixWithColon() {
+        try {
+            new XMLElementBuilder("message", "http://example.com", "pre:fix");
+            fail("Must throw IllegalArgumentException");
+        } catch (IllegalArgumentException e) {
+            // ok
+        }
+    }
+    
     public void testLanguageMapping() {
 
         XMLElement xmlElement = new XMLElementBuilder("message", "jabber:test").addText("t1").startInnerElement("body")
