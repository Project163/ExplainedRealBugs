diff --git a/docs/window.dox b/docs/window.dox
index 876927c7..acb58858 100644
--- a/docs/window.dox
+++ b/docs/window.dox
@@ -206,8 +206,9 @@ Zero disables multisampling.  `GLFW_DONT_CARE` means the application has no
 preference.
 
 `GLFW_SRGB_CAPABLE` specifies whether the framebuffer should be sRGB capable.
-If supported, the created context will provide `GL_ARB_framebuffer_sRGB` or
-`GL_EXT_framebuffer_sRGB`.
+If supported, a created OpenGL context will support the `GL_FRAMEBUFFER_SRGB`
+enable, also called `GL_FRAMEBUFFER_SRGB_EXT`) for controlling sRGB rendering
+and a created OpenGL ES context will always have sRGB rendering enabled.
 
 `GLFW_DOUBLEBUFFER` specifies whether the framebuffer should be double buffered.
 You nearly always want to use double buffering.  This is a hard constraint.
diff --git a/src/egl_context.c b/src/egl_context.c
index 579e17f1..00d4a7b4 100644
--- a/src/egl_context.c
+++ b/src/egl_context.c
@@ -259,6 +259,8 @@ GLFWbool _glfwInitEGL(void)
         _glfwPlatformExtensionSupported("EGL_KHR_create_context");
     _glfw.egl.KHR_create_context_no_error =
         _glfwPlatformExtensionSupported("EGL_KHR_create_context_no_error");
+    _glfw.egl.KHR_gl_colorspace =
+        _glfwPlatformExtensionSupported("EGL_KHR_gl_colorspace");
 
     return GLFW_TRUE;
 }
@@ -288,7 +290,7 @@ GLFWbool _glfwCreateContextEGL(_GLFWwindow* window,
                                const _GLFWctxconfig* ctxconfig,
                                const _GLFWfbconfig* fbconfig)
 {
-    int attribs[40];
+    EGLint attribs[40];
     EGLConfig config;
     EGLContext share = NULL;
 
@@ -401,11 +403,26 @@ GLFWbool _glfwCreateContextEGL(_GLFWwindow* window,
         return GLFW_FALSE;
     }
 
+    // Set up attributes for surface creation
+    {
+        int index = 0;
+
+        if (fbconfig->sRGB)
+        {
+            if (_glfw.egl.KHR_gl_colorspace)
+            {
+                setEGLattrib(EGL_GL_COLORSPACE_KHR, EGL_GL_COLORSPACE_SRGB_KHR);
+            }
+        }
+
+        setEGLattrib(EGL_NONE, EGL_NONE);
+    }
+
     window->context.egl.surface =
         eglCreateWindowSurface(_glfw.egl.display,
                                config,
                                _GLFW_EGL_NATIVE_WINDOW,
-                               NULL);
+                               attribs);
     if (window->context.egl.surface == EGL_NO_SURFACE)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
diff --git a/src/egl_context.h b/src/egl_context.h
index c73e1e02..15d5a125 100644
--- a/src/egl_context.h
+++ b/src/egl_context.h
@@ -104,6 +104,8 @@ typedef MirEGLNativeWindowType EGLNativeWindowType;
 #define EGL_CONTEXT_OPENGL_PROFILE_MASK_KHR 0x30fd
 #define EGL_CONTEXT_FLAGS_KHR 0x30fc
 #define EGL_CONTEXT_OPENGL_NO_ERROR_KHR 0x31b3
+#define EGL_GL_COLORSPACE_KHR 0x309d
+#define EGL_GL_COLORSPACE_SRGB_KHR 0x3089
 
 typedef int EGLint;
 typedef unsigned int EGLBoolean;
@@ -174,6 +176,7 @@ typedef struct _GLFWlibraryEGL
 
     GLFWbool        KHR_create_context;
     GLFWbool        KHR_create_context_no_error;
+    GLFWbool        KHR_gl_colorspace;
 
     void*           handle;
 
