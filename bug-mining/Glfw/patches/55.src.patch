diff --git a/docs/intro.dox b/docs/intro.dox
index 7888e5fd..07e0e767 100644
--- a/docs/intro.dox
+++ b/docs/intro.dox
@@ -110,6 +110,10 @@ have been generated specifically for that error.  This lets GLFW provide much
 more specific error descriptions but means you must make a copy if you want to
 keep the description string.
 
+@note Relying on erroneous behavior is not forward compatible.  In other words,
+do not rely on a currently invalid call to generate a specific error, as that
+same call may in future versions generate a different error or become valid.
+
 
 @section coordinate_systems Coordinate systems
 
diff --git a/include/GLFW/glfw3.h b/include/GLFW/glfw3.h
index f6cdd978..cd733bf1 100644
--- a/include/GLFW/glfw3.h
+++ b/include/GLFW/glfw3.h
@@ -520,7 +520,9 @@ extern "C" {
 /*! @brief GLFW could not find support for the requested client API on the
  *  system.
  *
- *  GLFW could not find support for the requested client API on the system.
+ *  GLFW could not find support for the requested client API on the system.  If
+ *  emitted by functions other than @ref glfwCreateWindow, no supported client
+ *  API was found.
  *
  *  @par Analysis
  *  The installed graphics driver does not support the requested client API, or
@@ -537,8 +539,8 @@ extern "C" {
 #define GLFW_API_UNAVAILABLE        0x00010006
 /*! @brief The requested OpenGL or OpenGL ES version is not available.
  *
- *  The requested OpenGL or OpenGL ES version (including any requested profile
- *  or context option) is not available on this machine.
+ *  The requested OpenGL or OpenGL ES version (including any requested context
+ *  or framebuffer hints) is not available on this machine.
  *
  *  @par Analysis
  *  The machine does not support your requirements.  If your application is
@@ -560,7 +562,8 @@ extern "C" {
  *  specific categories.
  *
  *  @par Analysis
- *  A bug in GLFW or the underlying operating system.  Report the bug to our
+ *  A bug or configuration error in GLFW, the underlying operating system or
+ *  its drivers, or a lack of required resources.  Report the issue to our
  *  [issue tracker](https://github.com/glfw/glfw/issues).
  */
 #define GLFW_PLATFORM_ERROR         0x00010008
diff --git a/src/cocoa_monitor.m b/src/cocoa_monitor.m
index d518973a..9b8d3b0f 100644
--- a/src/cocoa_monitor.m
+++ b/src/cocoa_monitor.m
@@ -57,7 +57,8 @@ static char* getDisplayName(CGDirectDisplayID displayID)
                                                  (const void**) &value))
     {
         // This may happen if a desktop Mac is running headless
-        _glfwInputError(GLFW_PLATFORM_ERROR, "Failed to retrieve display name");
+        _glfwInputError(GLFW_PLATFORM_ERROR,
+                        "Cocoa: Failed to retrieve display name");
 
         CFRelease(info);
         return strdup("Unknown");
diff --git a/src/cocoa_window.m b/src/cocoa_window.m
index da20e32f..b5bb4662 100644
--- a/src/cocoa_window.m
+++ b/src/cocoa_window.m
@@ -1211,7 +1211,8 @@ int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
     cursor->ns.object = getStandardCursor(shape);
     if (!cursor->ns.object)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, "Cocoa: Invalid standard cursor");
+        _glfwInputError(GLFW_PLATFORM_ERROR,
+                        "Cocoa: Failed to retrieve standard cursor");
         return GL_FALSE;
     }
 
@@ -1255,7 +1256,8 @@ const char* _glfwPlatformGetClipboardString(_GLFWwindow* window)
 
     if (![[pasteboard types] containsObject:NSStringPboardType])
     {
-        _glfwInputError(GLFW_FORMAT_UNAVAILABLE, NULL);
+        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,
+                        "Cocoa: Failed to retrieve string from pasteboard");
         return NULL;
     }
 
diff --git a/src/context.c b/src/context.c
index 8ca73411..bf53410f 100644
--- a/src/context.c
+++ b/src/context.c
@@ -89,7 +89,7 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
     if (ctxconfig->api != GLFW_OPENGL_API &&
         ctxconfig->api != GLFW_OPENGL_ES_API)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, "Invalid client API requested");
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid client API");
         return GL_FALSE;
     }
 
@@ -107,7 +107,7 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
             // For now, let everything else through
 
             _glfwInputError(GLFW_INVALID_VALUE,
-                            "Invalid OpenGL version %i.%i requested",
+                            "Invalid OpenGL version %i.%i",
                             ctxconfig->major, ctxconfig->minor);
             return GL_FALSE;
         }
@@ -118,7 +118,7 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
                 ctxconfig->profile != GLFW_OPENGL_COMPAT_PROFILE)
             {
                 _glfwInputError(GLFW_INVALID_ENUM,
-                                "Invalid OpenGL profile requested");
+                                "Invalid OpenGL profile");
                 return GL_FALSE;
             }
 
@@ -129,8 +129,7 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
                 // and above
 
                 _glfwInputError(GLFW_INVALID_VALUE,
-                                "Context profiles only exist for "
-                                "OpenGL version 3.2 and above");
+                                "Context profiles are only defined for OpenGL version 3.2 and above");
                 return GL_FALSE;
             }
         }
@@ -139,8 +138,7 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
         {
             // Forward-compatible contexts are only defined for OpenGL version 3.0 and above
             _glfwInputError(GLFW_INVALID_VALUE,
-                            "Forward compatibility only exist for OpenGL "
-                            "version 3.0 and above");
+                            "Forward-compatibility is only defined for OpenGL version 3.0 and above");
             return GL_FALSE;
         }
     }
@@ -156,7 +154,7 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
             // For now, let everything else through
 
             _glfwInputError(GLFW_INVALID_VALUE,
-                            "Invalid OpenGL ES version %i.%i requested",
+                            "Invalid OpenGL ES version %i.%i",
                             ctxconfig->major, ctxconfig->minor);
             return GL_FALSE;
         }
@@ -167,8 +165,8 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
         if (ctxconfig->robustness != GLFW_NO_RESET_NOTIFICATION &&
             ctxconfig->robustness != GLFW_LOSE_CONTEXT_ON_RESET)
         {
-            _glfwInputError(GLFW_INVALID_VALUE,
-                            "Invalid context robustness mode requested");
+            _glfwInputError(GLFW_INVALID_ENUM,
+                            "Invalid context robustness mode");
             return GL_FALSE;
         }
     }
@@ -178,8 +176,8 @@ GLboolean _glfwIsValidContextConfig(const _GLFWctxconfig* ctxconfig)
         if (ctxconfig->release != GLFW_RELEASE_BEHAVIOR_NONE &&
             ctxconfig->release != GLFW_RELEASE_BEHAVIOR_FLUSH)
         {
-            _glfwInputError(GLFW_INVALID_VALUE,
-                            "Invalid context release behavior requested");
+            _glfwInputError(GLFW_INVALID_ENUM,
+                            "Invalid context release behavior");
             return GL_FALSE;
         }
     }
diff --git a/src/egl_context.c b/src/egl_context.c
index ca4843ee..b15ca084 100644
--- a/src/egl_context.c
+++ b/src/egl_context.c
@@ -47,33 +47,25 @@ static const char* getErrorString(EGLint error)
         case EGL_BAD_ALLOC:
             return "EGL failed to allocate resources for the requested operation";
         case EGL_BAD_ATTRIBUTE:
-            return "An unrecognized attribute or attribute value was passed "
-                   "in the attribute list";
+            return "An unrecognized attribute or attribute value was passed in the attribute list";
         case EGL_BAD_CONTEXT:
-            return "An EGLContext argument does not name a valid EGL "
-                   "rendering context";
+            return "An EGLContext argument does not name a valid EGL rendering context";
         case EGL_BAD_CONFIG:
-            return "An EGLConfig argument does not name a valid EGL frame "
-                   "buffer configuration";
+            return "An EGLConfig argument does not name a valid EGL frame buffer configuration";
         case EGL_BAD_CURRENT_SURFACE:
-            return "The current surface of the calling thread is a window, pixel "
-                   "buffer or pixmap that is no longer valid";
+            return "The current surface of the calling thread is a window, pixel buffer or pixmap that is no longer valid";
         case EGL_BAD_DISPLAY:
-            return "An EGLDisplay argument does not name a valid EGL display "
-                   "connection";
+            return "An EGLDisplay argument does not name a valid EGL display connection";
         case EGL_BAD_SURFACE:
-            return "An EGLSurface argument does not name a valid surface "
-                   "configured for GL rendering";
+            return "An EGLSurface argument does not name a valid surface configured for GL rendering";
         case EGL_BAD_MATCH:
             return "Arguments are inconsistent";
         case EGL_BAD_PARAMETER:
             return "One or more argument values are invalid";
         case EGL_BAD_NATIVE_PIXMAP:
-            return "A NativePixmapType argument does not refer to a valid "
-                   "native pixmap";
+            return "A NativePixmapType argument does not refer to a valid native pixmap";
         case EGL_BAD_NATIVE_WINDOW:
-            return "A NativeWindowType argument does not refer to a valid "
-                   "native window";
+            return "A NativeWindowType argument does not refer to a valid native window";
         case EGL_CONTEXT_LOST:
             return "The application must destroy all contexts and reinitialise";
     }
@@ -309,7 +301,7 @@ int _glfwCreateContext(_GLFWwindow* window,
     {
         if (!eglBindAPI(EGL_OPENGL_ES_API))
         {
-            _glfwInputError(GLFW_PLATFORM_ERROR,
+            _glfwInputError(GLFW_API_UNAVAILABLE,
                             "EGL: Failed to bind OpenGL ES: %s",
                             getErrorString(eglGetError()));
             return GL_FALSE;
@@ -319,7 +311,7 @@ int _glfwCreateContext(_GLFWwindow* window,
     {
         if (!eglBindAPI(EGL_OPENGL_API))
         {
-            _glfwInputError(GLFW_PLATFORM_ERROR,
+            _glfwInputError(GLFW_API_UNAVAILABLE,
                             "EGL: Failed to bind OpenGL: %s",
                             getErrorString(eglGetError()));
             return GL_FALSE;
@@ -389,7 +381,7 @@ int _glfwCreateContext(_GLFWwindow* window,
 
     if (window->egl.context == EGL_NO_CONTEXT)
     {
-        _glfwInputError(GLFW_PLATFORM_ERROR,
+        _glfwInputError(GLFW_VERSION_UNAVAILABLE,
                         "EGL: Failed to create context: %s",
                         getErrorString(eglGetError()));
         return GL_FALSE;
diff --git a/src/glx_context.c b/src/glx_context.c
index a13b51db..ec34e8f1 100644
--- a/src/glx_context.c
+++ b/src/glx_context.c
@@ -175,7 +175,7 @@ int _glfwInitContextAPI(void)
     _glfw.glx.libGL = dlopen("libGL.so.1", RTLD_LAZY | RTLD_GLOBAL);
     if (!_glfw.glx.libGL)
     {
-        _glfwInputError(GLFW_PLATFORM_ERROR, "GLX: Failed to find libGL");
+        _glfwInputError(GLFW_API_UNAVAILABLE, "GLX: Failed to find libGL");
         return GL_FALSE;
     }
 #endif
@@ -320,8 +320,7 @@ int _glfwCreateContext(_GLFWwindow* window,
             !_glfw.glx.EXT_create_context_es2_profile)
         {
             _glfwInputError(GLFW_API_UNAVAILABLE,
-                            "GLX: OpenGL ES requested but "
-                            "GLX_EXT_create_context_es2_profile is unavailable");
+                            "GLX: OpenGL ES requested but GLX_EXT_create_context_es2_profile is unavailable");
             return GL_FALSE;
         }
     }
@@ -331,8 +330,7 @@ int _glfwCreateContext(_GLFWwindow* window,
         if (!_glfw.glx.ARB_create_context)
         {
             _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                            "GLX: Forward compatibility requested but "
-                            "GLX_ARB_create_context_profile is unavailable");
+                            "GLX: Forward compatibility requested but GLX_ARB_create_context_profile is unavailable");
             return GL_FALSE;
         }
     }
@@ -343,8 +341,7 @@ int _glfwCreateContext(_GLFWwindow* window,
             !_glfw.glx.ARB_create_context_profile)
         {
             _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                            "GLX: An OpenGL profile requested but "
-                            "GLX_ARB_create_context_profile is unavailable");
+                            "GLX: An OpenGL profile requested but GLX_ARB_create_context_profile is unavailable");
             return GL_FALSE;
         }
     }
@@ -454,7 +451,7 @@ int _glfwCreateContext(_GLFWwindow* window,
 
     if (!window->glx.context)
     {
-        _glfwInputXError(GLFW_PLATFORM_ERROR, "GLX: Failed to create context");
+        _glfwInputXError(GLFW_VERSION_UNAVAILABLE, "GLX: Failed to create context");
         return GL_FALSE;
     }
 
diff --git a/src/input.c b/src/input.c
index 0a8bd1fd..e899e715 100644
--- a/src/input.c
+++ b/src/input.c
@@ -46,7 +46,7 @@ static void setCursorMode(_GLFWwindow* window, int newMode)
         newMode != GLFW_CURSOR_HIDDEN &&
         newMode != GLFW_CURSOR_DISABLED)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, NULL);
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid cursor mode");
         return;
     }
 
@@ -242,7 +242,7 @@ GLFWAPI int glfwGetInputMode(GLFWwindow* handle, int mode)
         case GLFW_STICKY_MOUSE_BUTTONS:
             return window->stickyMouseButtons;
         default:
-            _glfwInputError(GLFW_INVALID_ENUM, NULL);
+            _glfwInputError(GLFW_INVALID_ENUM, "Invalid input mode");
             return 0;
     }
 }
@@ -265,7 +265,7 @@ GLFWAPI void glfwSetInputMode(GLFWwindow* handle, int mode, int value)
             setStickyMouseButtons(window, value ? GL_TRUE : GL_FALSE);
             break;
         default:
-            _glfwInputError(GLFW_INVALID_ENUM, NULL);
+            _glfwInputError(GLFW_INVALID_ENUM, "Invalid input mode");
             break;
     }
 }
@@ -278,7 +278,7 @@ GLFWAPI int glfwGetKey(GLFWwindow* handle, int key)
 
     if (key < 0 || key > GLFW_KEY_LAST)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, "The specified key is invalid");
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid key");
         return GLFW_RELEASE;
     }
 
@@ -301,7 +301,7 @@ GLFWAPI int glfwGetMouseButton(GLFWwindow* handle, int button)
     if (button < 0 || button > GLFW_MOUSE_BUTTON_LAST)
     {
         _glfwInputError(GLFW_INVALID_ENUM,
-                        "The specified mouse button is invalid");
+                        "Invalid mouse button");
         return GLFW_RELEASE;
     }
 
@@ -384,6 +384,17 @@ GLFWAPI GLFWcursor* glfwCreateStandardCursor(int shape)
 
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
 
+    if (shape != GLFW_ARROW_CURSOR &&
+        shape != GLFW_IBEAM_CURSOR &&
+        shape != GLFW_CROSSHAIR_CURSOR &&
+        shape != GLFW_HAND_CURSOR &&
+        shape != GLFW_HRESIZE_CURSOR &&
+        shape != GLFW_VRESIZE_CURSOR)
+    {
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid standard cursor");
+        return NULL;
+    }
+
     cursor = calloc(1, sizeof(_GLFWcursor));
     cursor->next = _glfw.cursorListHead;
     _glfw.cursorListHead = cursor;
@@ -518,7 +529,7 @@ GLFWAPI int glfwJoystickPresent(int joy)
 
     if (joy < 0 || joy > GLFW_JOYSTICK_LAST)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, NULL);
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid joystick");
         return 0;
     }
 
@@ -533,7 +544,7 @@ GLFWAPI const float* glfwGetJoystickAxes(int joy, int* count)
 
     if (joy < 0 || joy > GLFW_JOYSTICK_LAST)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, NULL);
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid joystick");
         return NULL;
     }
 
@@ -548,7 +559,7 @@ GLFWAPI const unsigned char* glfwGetJoystickButtons(int joy, int* count)
 
     if (joy < 0 || joy > GLFW_JOYSTICK_LAST)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, NULL);
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid joystick");
         return NULL;
     }
 
@@ -561,7 +572,7 @@ GLFWAPI const char* glfwGetJoystickName(int joy)
 
     if (joy < 0 || joy > GLFW_JOYSTICK_LAST)
     {
-        _glfwInputError(GLFW_INVALID_ENUM, NULL);
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid joystick");
         return NULL;
     }
 
diff --git a/src/mir_init.c b/src/mir_init.c
index a3c8de9f..7f19b60d 100644
--- a/src/mir_init.c
+++ b/src/mir_init.c
@@ -65,7 +65,7 @@ int _glfwPlatformInit(void)
     if (error)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Mir: Failed to create event mutex: %s\n",
+                        "Mir: Failed to create event mutex: %s",
                         strerror(error));
         return GL_FALSE;
     }
diff --git a/src/mir_monitor.c b/src/mir_monitor.c
index 9776b10e..93073d33 100644
--- a/src/mir_monitor.c
+++ b/src/mir_monitor.c
@@ -127,12 +127,12 @@ void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
 void _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
diff --git a/src/mir_window.c b/src/mir_window.c
index f2890cbd..566a5a11 100644
--- a/src/mir_window.c
+++ b/src/mir_window.c
@@ -470,7 +470,7 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
         if (wndconfig->width > mode.width || wndconfig->height > mode.height)
         {
             _glfwInputError(GLFW_PLATFORM_ERROR,
-                            "Mir: Requested surface size is to large (%i %i)",
+                            "Mir: Requested surface size too large: %ix%i",
                              wndconfig->width, wndconfig->height);
 
             return GL_FALSE;
@@ -502,13 +502,13 @@ void _glfwPlatformDestroyWindow(_GLFWwindow* window)
 void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
@@ -516,19 +516,19 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
                                      int* right, int* bottom)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
@@ -552,39 +552,39 @@ void _glfwPlatformRestoreWindow(_GLFWwindow* window)
 void _glfwPlatformHideWindow(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformShowWindow(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformUnhideWindow(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 int _glfwPlatformWindowFocused(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
     return GL_FALSE;
 }
 
 int _glfwPlatformWindowIconified(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
     return GL_FALSE;
 }
 
 int _glfwPlatformWindowVisible(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
     return GL_FALSE;
 }
 
@@ -628,7 +628,7 @@ int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
                               int xhot, int yhot)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 
     return GL_FALSE;
 }
@@ -636,7 +636,7 @@ int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
 int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 
     return GL_FALSE;
 }
@@ -644,43 +644,43 @@ int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
 void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformSetCursorPos(_GLFWwindow* window, double xpos, double ypos)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformApplyCursorMode(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 void _glfwPlatformSetClipboardString(_GLFWwindow* window, const char* string)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 }
 
 const char* _glfwPlatformGetClipboardString(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_PLATFORM_ERROR,
-                    "Mir: Unsupported function %s!", __PRETTY_FUNCTION__);
+                    "Mir: Unsupported function %s", __PRETTY_FUNCTION__);
 
     return NULL;
 }
diff --git a/src/nsgl_context.m b/src/nsgl_context.m
index 0f0fb86e..28758060 100644
--- a/src/nsgl_context.m
+++ b/src/nsgl_context.m
@@ -42,7 +42,7 @@ int _glfwInitContextAPI(void)
         CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));
     if (_glfw.nsgl.framework == NULL)
     {
-        _glfwInputError(GLFW_PLATFORM_ERROR,
+        _glfwInputError(GLFW_API_UNAVAILABLE,
                         "NSGL: Failed to locate OpenGL framework");
         return GL_FALSE;
     }
@@ -76,8 +76,7 @@ int _glfwCreateContext(_GLFWwindow* window,
     if (ctxconfig->major == 3 && ctxconfig->minor < 2)
     {
         _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                        "NSGL: The targeted version of OS X does not "
-                        "support OpenGL 3.0 or 3.1");
+                        "NSGL: The targeted version of OS X does not support OpenGL 3.0 or 3.1");
         return GL_FALSE;
     }
 
@@ -86,18 +85,14 @@ int _glfwCreateContext(_GLFWwindow* window,
         if (!ctxconfig->forward)
         {
             _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                            "NSGL: The targeted version of OS X only "
-                            "supports OpenGL 3.2 and later versions if they "
-                            "are forward-compatible");
+                            "NSGL: The targeted version of OS X only supports forward-compatible contexts for OpenGL 3.2 and above");
             return GL_FALSE;
         }
 
         if (ctxconfig->profile != GLFW_OPENGL_CORE_PROFILE)
         {
             _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                            "NSGL: The targeted version of OS X only "
-                            "supports OpenGL 3.2 and later versions if they "
-                            "use the core profile");
+                            "NSGL: The targeted version of OS X only supports core profile contexts for OpenGL 3.2 and above");
             return GL_FALSE;
         }
     }
@@ -106,8 +101,7 @@ int _glfwCreateContext(_GLFWwindow* window,
     if (ctxconfig->major > 2)
     {
         _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                        "NSGL: The targeted version of OS X does not "
-                        "support OpenGL version 3.0 or above");
+                        "NSGL: The targeted version of OS X does not support OpenGL version 3.0 or above");
         return GL_FALSE;
     }
 #endif /*MAC_OS_X_VERSION_MAX_ALLOWED*/
@@ -232,7 +226,7 @@ int _glfwCreateContext(_GLFWwindow* window,
                                    shareContext:share];
     if (window->nsgl.context == nil)
     {
-        _glfwInputError(GLFW_PLATFORM_ERROR,
+        _glfwInputError(GLFW_VERSION_UNAVAILABLE,
                         "NSGL: Failed to create OpenGL context");
         return GL_FALSE;
     }
diff --git a/src/wgl_context.c b/src/wgl_context.c
index 57d05763..9b1022bb 100644
--- a/src/wgl_context.c
+++ b/src/wgl_context.c
@@ -167,12 +167,6 @@ static GLboolean choosePixelFormat(_GLFWwindow* window,
                                           NULL);
     }
 
-    if (!nativeCount)
-    {
-        _glfwInputError(GLFW_API_UNAVAILABLE, "WGL: No pixel formats found");
-        return GL_FALSE;
-    }
-
     usableConfigs = calloc(nativeCount, sizeof(_GLFWfbconfig));
     usableCount = 0;
 
@@ -325,7 +319,7 @@ int _glfwInitContextAPI(void)
     _glfw.wgl.opengl32.instance = LoadLibraryW(L"opengl32.dll");
     if (!_glfw.wgl.opengl32.instance)
     {
-        _glfwInputError(GLFW_PLATFORM_ERROR, "Failed to load opengl32.dll");
+        _glfwInputError(GLFW_PLATFORM_ERROR, "WGL: Failed to load opengl32.dll");
         return GL_FALSE;
     }
 
@@ -367,7 +361,7 @@ int _glfwCreateContext(_GLFWwindow* window,
     if (!window->wgl.dc)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to retrieve DC for window");
+                        "WGL: Failed to retrieve DC for window");
         return GL_FALSE;
     }
 
@@ -377,15 +371,14 @@ int _glfwCreateContext(_GLFWwindow* window,
     if (!DescribePixelFormat(window->wgl.dc, pixelFormat, sizeof(pfd), &pfd))
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to retrieve PFD for selected pixel "
-                        "format");
+                        "WGL: Failed to retrieve PFD for selected pixel format");
         return GL_FALSE;
     }
 
     if (!SetPixelFormat(window->wgl.dc, pixelFormat, &pfd))
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to set selected pixel format");
+                        "WGL: Failed to set selected pixel format");
         return GL_FALSE;
     }
 
@@ -478,7 +471,7 @@ int _glfwCreateContext(_GLFWwindow* window,
         window->wgl.context = wglCreateContext(window->wgl.dc);
         if (!window->wgl.context)
         {
-            _glfwInputError(GLFW_PLATFORM_ERROR,
+            _glfwInputError(GLFW_VERSION_UNAVAILABLE,
                             "WGL: Failed to create OpenGL context");
             return GL_FALSE;
         }
@@ -488,8 +481,7 @@ int _glfwCreateContext(_GLFWwindow* window,
             if (!wglShareLists(share, window->wgl.context))
             {
                 _glfwInputError(GLFW_PLATFORM_ERROR,
-                                "WGL: Failed to enable sharing with specified "
-                                "OpenGL context");
+                                "WGL: Failed to enable sharing with specified OpenGL context");
                 return GL_FALSE;
             }
         }
@@ -535,9 +527,7 @@ int _glfwAnalyzeContext(const _GLFWwindow* window,
             if (!window->wgl.ARB_create_context)
             {
                 _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                                "WGL: A forward compatible OpenGL context "
-                                "requested but WGL_ARB_create_context is "
-                                "unavailable");
+                                "WGL: A forward compatible OpenGL context requested but WGL_ARB_create_context is unavailable");
                 return _GLFW_RECREATION_IMPOSSIBLE;
             }
 
@@ -549,8 +539,7 @@ int _glfwAnalyzeContext(const _GLFWwindow* window,
             if (!window->wgl.ARB_create_context_profile)
             {
                 _glfwInputError(GLFW_VERSION_UNAVAILABLE,
-                                "WGL: OpenGL profile requested but "
-                                "WGL_ARB_create_context_profile is unavailable");
+                                "WGL: OpenGL profile requested but WGL_ARB_create_context_profile is unavailable");
                 return _GLFW_RECREATION_IMPOSSIBLE;
             }
 
@@ -570,8 +559,7 @@ int _glfwAnalyzeContext(const _GLFWwindow* window,
             !window->wgl.EXT_create_context_es2_profile)
         {
             _glfwInputError(GLFW_API_UNAVAILABLE,
-                            "WGL: OpenGL ES requested but "
-                            "WGL_ARB_create_context_es2_profile is unavailable");
+                            "WGL: OpenGL ES requested but WGL_ARB_create_context_es2_profile is unavailable");
             return _GLFW_RECREATION_IMPOSSIBLE;
         }
 
diff --git a/src/win32_monitor.c b/src/win32_monitor.c
index 0690dc1f..0ce8e382 100644
--- a/src/win32_monitor.c
+++ b/src/win32_monitor.c
@@ -144,7 +144,7 @@ _GLFWmonitor** _glfwPlatformGetMonitors(int* count)
             if (!name)
             {
                 _glfwInputError(GLFW_PLATFORM_ERROR,
-                                "Failed to convert string to UTF-8");
+                                "Win32: Failed to convert string to UTF-8");
                 continue;
             }
 
diff --git a/src/win32_window.c b/src/win32_window.c
index 7da90d78..da652e8a 100644
--- a/src/win32_window.c
+++ b/src/win32_window.c
@@ -679,7 +679,7 @@ static int createWindow(_GLFWwindow* window,
     if (!wideTitle)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to convert title to wide string");
+                        "Win32: Failed to convert window title to UTF-16");
         return GL_FALSE;
     }
 
@@ -862,7 +862,7 @@ void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
     if (!wideTitle)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to convert title to wide string");
+                        "Win32: Failed to convert window title to UTF-16");
         return;
     }
 
@@ -1168,18 +1168,12 @@ int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
 
 int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
 {
-    LPCWSTR native = translateCursorShape(shape);
-    if (!native)
-    {
-        _glfwInputError(GLFW_INVALID_ENUM, "Win32: Invalid standard cursor");
-        return GL_FALSE;
-    }
-
-    cursor->win32.handle = CopyCursor(LoadCursorW(NULL, native));
+    cursor->win32.handle =
+        CopyCursor(LoadCursorW(NULL, translateCursorShape(shape)));
     if (!cursor->win32.handle)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to retrieve shared cursor");
+                        "Win32: Failed to create standard cursor");
         return GL_FALSE;
     }
 
@@ -1219,8 +1213,7 @@ void _glfwPlatformSetClipboardString(_GLFWwindow* window, const char* string)
     if (!wideString)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to convert clipboard string to "
-                        "wide string");
+                        "Win32: Failed to convert string to UTF-16");
         return;
     }
 
@@ -1259,12 +1252,6 @@ const char* _glfwPlatformGetClipboardString(_GLFWwindow* window)
 {
     HANDLE stringHandle;
 
-    if (!IsClipboardFormatAvailable(CF_UNICODETEXT))
-    {
-        _glfwInputError(GLFW_FORMAT_UNAVAILABLE, NULL);
-        return NULL;
-    }
-
     if (!OpenClipboard(window->win32.handle))
     {
         _glfwInputError(GLFW_PLATFORM_ERROR, "Win32: Failed to open clipboard");
@@ -1276,8 +1263,8 @@ const char* _glfwPlatformGetClipboardString(_GLFWwindow* window)
     {
         CloseClipboard();
 
-        _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Win32: Failed to retrieve clipboard data");
+        _glfwInputError(GLFW_FORMAT_UNAVAILABLE,
+                        "Win32: Failed to convert clipboard to string");
         return NULL;
     }
 
diff --git a/src/window.c b/src/window.c
index 4a46a6e4..3acd48c4 100644
--- a/src/window.c
+++ b/src/window.c
@@ -394,7 +394,7 @@ GLFWAPI void glfwWindowHint(int target, int hint)
             _glfw.hints.release = hint;
             break;
         default:
-            _glfwInputError(GLFW_INVALID_ENUM, NULL);
+            _glfwInputError(GLFW_INVALID_ENUM, "Invalid window hint");
             break;
     }
 }
@@ -479,7 +479,7 @@ GLFWAPI void glfwSetWindowPos(GLFWwindow* handle, int xpos, int ypos)
     if (window->monitor)
     {
         _glfwInputError(GLFW_INVALID_VALUE,
-                        "Full screen windows cannot be positioned");
+                        "Full screen windows cannot be moved");
         return;
     }
 
@@ -624,7 +624,7 @@ GLFWAPI int glfwGetWindowAttrib(GLFWwindow* handle, int attrib)
             return window->context.release;
     }
 
-    _glfwInputError(GLFW_INVALID_ENUM, NULL);
+    _glfwInputError(GLFW_INVALID_ENUM, "Invalid window attribute");
     return 0;
 }
 
diff --git a/src/x11_init.c b/src/x11_init.c
index 8a00eb84..dc460aaf 100644
--- a/src/x11_init.c
+++ b/src/x11_init.c
@@ -722,7 +722,7 @@ int _glfwPlatformInit(void)
     _glfw.x11.display = XOpenDisplay(NULL);
     if (!_glfw.x11.display)
     {
-        _glfwInputError(GLFW_API_UNAVAILABLE, "X11: Failed to open X display");
+        _glfwInputError(GLFW_PLATFORM_ERROR, "X11: Failed to open X display");
         return GL_FALSE;
     }
 
diff --git a/src/x11_window.c b/src/x11_window.c
index 0310ed44..d89f7236 100644
--- a/src/x11_window.c
+++ b/src/x11_window.c
@@ -1619,9 +1619,7 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
             if (_glfwPlatformGetTime() - base > 0.5)
             {
                 _glfwInputError(GLFW_PLATFORM_ERROR,
-                                "X11: The window manager has a broken "
-                                "_NET_REQUEST_FRAME_EXTENTS implementation; "
-                                "please report this issue");
+                                "X11: The window manager has a broken _NET_REQUEST_FRAME_EXTENTS implementation; please report this issue");
                 break;
             }
 
@@ -1660,9 +1658,8 @@ void _glfwPlatformIconifyWindow(_GLFWwindow* window)
     {
         // Override-redirect windows cannot be iconified or restored, as those
         // tasks are performed by the window manager
-        _glfwInputError(GLFW_API_UNAVAILABLE,
-                        "X11: Iconification of full screen windows requires "
-                        "a WM that supports EWMH");
+        _glfwInputError(GLFW_PLATFORM_ERROR,
+                        "X11: Iconification of full screen windows requires a WM that supports EWMH");
         return;
     }
 
@@ -1676,9 +1673,8 @@ void _glfwPlatformRestoreWindow(_GLFWwindow* window)
     {
         // Override-redirect windows cannot be iconified or restored, as those
         // tasks are performed by the window manager
-        _glfwInputError(GLFW_API_UNAVAILABLE,
-                        "X11: Iconification of full screen windows requires "
-                        "a WM that supports EWMH");
+        _glfwInputError(GLFW_PLATFORM_ERROR,
+                        "X11: Iconification of full screen windows requires a WM that supports EWMH");
         return;
     }
 
@@ -1835,14 +1831,8 @@ int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
 
 int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
 {
-    const unsigned int native = translateCursorShape(shape);
-    if (!native)
-    {
-        _glfwInputError(GLFW_INVALID_ENUM, "X11: Invalid standard cursor");
-        return GL_FALSE;
-    }
-
-    cursor->x11.handle = XCreateFontCursor(_glfw.x11.display, native);
+    cursor->x11.handle = XCreateFontCursor(_glfw.x11.display,
+                                           translateCursorShape(shape));
     if (!cursor->x11.handle)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
@@ -1885,7 +1875,7 @@ void _glfwPlatformSetClipboardString(_GLFWwindow* window, const char* string)
         window->x11.handle)
     {
         _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "X11: Failed to become owner of the clipboard selection");
+                        "X11: Failed to become owner of clipboard selection");
     }
 }
 
@@ -1948,7 +1938,7 @@ const char* _glfwPlatformGetClipboardString(_GLFWwindow* window)
     if (_glfw.x11.clipboardString == NULL)
     {
         _glfwInputError(GLFW_FORMAT_UNAVAILABLE,
-                        "X11: Failed to convert selection to string");
+                        "X11: Failed to convert clipboard to string");
     }
 
     return _glfw.x11.clipboardString;
