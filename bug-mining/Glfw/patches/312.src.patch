diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index d87ae8d1..249e8d68 100644
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -31,8 +31,8 @@ jobs:
             - name: Build shared library
               run: cmake --build build-shared --parallel
 
-    build-linux-wayland-clang:
-        name: Wayland (Linux, Clang)
+    build-linux-full-clang:
+        name: X11+Wayland (Linux, Clang)
         runs-on: ubuntu-latest
         env:
             CC: clang
@@ -42,38 +42,15 @@ jobs:
             - name: Install dependencies
               run: |
                   sudo apt update
-                  sudo apt install wayland-protocols libwayland-dev libxkbcommon-dev
+                  sudo apt install libxrandr-dev libxinerama-dev libxcursor-dev libxi-dev libxext-dev wayland-protocols libwayland-dev libxkbcommon-dev
 
             - name: Configure static library
-              run: cmake -S . -B build-static -D GLFW_USE_WAYLAND=ON
+              run: cmake -S . -B build-static -D GLFW_BUILD_WAYLAND=ON
             - name: Build static library
               run: cmake --build build-static --parallel
 
             - name: Configure shared library
-              run: cmake -S . -B build-shared -D GLFW_USE_WAYLAND=ON -D BUILD_SHARED_LIBS=ON
-            - name: Build shared library
-              run: cmake --build build-shared --parallel
-
-    build-linux-null-clang:
-        name: Null (Linux, Clang)
-        runs-on: ubuntu-latest
-        env:
-            CC: clang
-            CFLAGS: -Werror
-        steps:
-            - uses: actions/checkout@v2
-            - name: Install dependencies
-              run: |
-                  sudo apt update
-                  sudo apt install libosmesa6-dev
-
-            - name: Configure static library
-              run: cmake -S . -B build-static -D GLFW_USE_OSMESA=ON
-            - name: Build static library
-              run: cmake --build build-static --parallel
-
-            - name: Configure shared library
-              run: cmake -S . -B build-shared -D GLFW_USE_OSMESA=ON -D BUILD_SHARED_LIBS=ON
+              run: cmake -S . -B build-shared -D GLFW_BUILD_WAYLAND=ON -D BUILD_SHARED_LIBS=ON
             - name: Build shared library
               run: cmake --build build-shared --parallel
 
diff --git a/CMakeLists.txt b/CMakeLists.txt
index a1169171..5042ab9c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -32,12 +32,18 @@ option(GLFW_VULKAN_STATIC "Assume the Vulkan loader is linked with the applicati
 include(GNUInstallDirs)
 include(CMakeDependentOption)
 
-cmake_dependent_option(GLFW_USE_OSMESA "Use OSMesa for offscreen context creation" OFF
-                       "UNIX" OFF)
+if (GLFW_USE_OSMESA)
+    message(FATAL_ERROR "GLFW_USE_OSMESA has been removed; set the GLFW_PLATFORM init hint")
+endif()
+
+cmake_dependent_option(GLFW_BUILD_WIN32 "Build support for Win32" ON "WIN32" OFF)
+cmake_dependent_option(GLFW_BUILD_COCOA "Build support for Cocoa" ON "APPLE" OFF)
+cmake_dependent_option(GLFW_BUILD_X11 "Build support for X11" ON "UNIX;NOT APPLE" OFF)
+cmake_dependent_option(GLFW_BUILD_WAYLAND "Build support for Wayland"
+    "${GLFW_USE_WAYLAND}" "UNIX;NOT APPLE" OFF)
+
 cmake_dependent_option(GLFW_USE_HYBRID_HPG "Force use of high-performance GPU on hybrid systems" OFF
                        "WIN32" OFF)
-cmake_dependent_option(GLFW_USE_WAYLAND "Use Wayland for window creation" OFF
-                       "UNIX;NOT APPLE" OFF)
 cmake_dependent_option(USE_MSVC_RUNTIME_LIBRARY_DLL "Use MSVC runtime library DLL" ON
                        "MSVC" OFF)
 
@@ -63,6 +69,22 @@ if (GLFW_BUILD_DOCS)
     find_package(Doxygen)
 endif()
 
+#--------------------------------------------------------------------
+# Report backend selection
+#--------------------------------------------------------------------
+if (GLFW_BUILD_WIN32)
+    message(STATUS "Including Win32 support")
+endif()
+if (GLFW_BUILD_COCOA)
+    message(STATUS "Including Cocoa support")
+endif()
+if (GLFW_BUILD_WAYLAND)
+    message(STATUS "Including Wayland support")
+endif()
+if (GLFW_BUILD_X11)
+    message(STATUS "Including X11 support")
+endif()
+
 #--------------------------------------------------------------------
 # Apply Microsoft C runtime library option
 # This is here because it also applies to tests and examples
@@ -88,28 +110,6 @@ if (MSVC AND NOT USE_MSVC_RUNTIME_LIBRARY_DLL)
     endif()
 endif()
 
-#--------------------------------------------------------------------
-# Detect and select backend APIs
-#--------------------------------------------------------------------
-if (GLFW_USE_WAYLAND)
-    set(_GLFW_WAYLAND 1)
-    message(STATUS "Using Wayland for window creation")
-elseif (GLFW_USE_OSMESA)
-    set(_GLFW_OSMESA 1)
-    message(STATUS "Using OSMesa for headless context creation")
-elseif (WIN32)
-    set(_GLFW_WIN32 1)
-    message(STATUS "Using Win32 for window creation")
-elseif (APPLE)
-    set(_GLFW_COCOA 1)
-    message(STATUS "Using Cocoa for window creation")
-elseif (UNIX)
-    set(_GLFW_X11 1)
-    message(STATUS "Using X11 for window creation")
-else()
-    message(FATAL_ERROR "No supported platform was detected")
-endif()
-
 #--------------------------------------------------------------------
 # Create generated files
 #--------------------------------------------------------------------
diff --git a/README.md b/README.md
index 4c783f7b..d1396af4 100644
--- a/README.md
+++ b/README.md
@@ -116,6 +116,13 @@ information on what to include when reporting a bug.
 
 ## Changelog
 
+ - Added `GLFW_PLATFORM` init hint for runtime platform selection (#1958)
+ - Added `GLFW_ANY_PLATFORM`, `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
+   `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` and `GLFW_PLATFORM_NULL` symbols to
+   specify the desired platform (#1958)
+ - Added `glfwGetPlatform` function to query what platform was selected (#1655,#1958)
+ - Added `glfwPlatformSupported` function to query if a platform is supported
+   (#1655,#1958)
  - Added `glfwInitAllocator` for setting a custom memory allocator (#544,#1628,#1947)
  - Added `GLFWallocator` struct and `GLFWallocatefun`, `GLFWreallocatefun` and
    `GLFWdeallocatefun` types (#544,#1628,#1947)
@@ -126,12 +133,16 @@ information on what to include when reporting a bug.
  - Added `GLFW_POINTING_HAND_CURSOR` alias for `GLFW_HAND_CURSOR` (#427)
  - Added `GLFW_MOUSE_PASSTHROUGH` window hint for letting mouse input pass
    through the window (#1236,#1568)
+ - Added `GLFW_PLATFORM_UNAVAILABLE` error for platform detection failures (#1958)
  - Added `GLFW_FEATURE_UNAVAILABLE` error for platform limitations (#1692)
  - Added `GLFW_FEATURE_UNIMPLEMENTED` error for incomplete backends (#1692)
  - Added `GLFW_ANGLE_PLATFORM_TYPE` init hint and `GLFW_ANGLE_PLATFORM_TYPE_*`
    values to select ANGLE backend (#1380)
  - Added `GLFW_X11_XCB_VULKAN_SURFACE` init hint for selecting X11 Vulkan
    surface extension (#1793)
+ - Added `GLFW_BUILD_WIN32` CMake option for enabling Win32 support (#1958)
+ - Added `GLFW_BUILD_COCOA` CMake option for enabling Cocoa support (#1958)
+ - Added `GLFW_BUILD_X11` CMake option for enabling X11 support (#1958)
  - Added `GLFW_LIBRARY_TYPE` CMake variable for overriding the library type
    (#279,#1307,#1497,#1574,#1928)
  - Added `GLFW_PKG_CONFIG_REQUIRES_PRIVATE` and `GLFW_PKG_CONFIG_LIBS_PRIVATE` CMake
@@ -140,6 +151,8 @@ information on what to include when reporting a bug.
  - Made `GLFW_DOUBLEBUFFER` a read-only window attribute
  - Updated the minimum required CMake version to 3.1
  - Disabled tests and examples by default when built as a CMake subdirectory
+ - Renamed `GLFW_USE_WAYLAND` CMake option to `GLFW_BUILD_WAYLAND` (#1958)
+ - Removed `GLFW_USE_OSMESA` CMake option enabling the Null platform (#1958)
  - Removed CMake generated configuration header
  - Bugfix: The CMake config-file package used an absolute path and was not
    relocatable (#1470)
@@ -442,6 +455,7 @@ skills.
  - Eddie Ringle
  - Max Risuhin
  - Jorge Rodriguez
+ - Jari Ronkainen
  - Luca Rood
  - Ed Ropple
  - Aleksey Rybalkin
diff --git a/docs/compile.dox b/docs/compile.dox
index cc32ea68..8f99472e 100644
--- a/docs/compile.dox
+++ b/docs/compile.dox
@@ -71,37 +71,42 @@ pkg install xorgproto
 On Cygwin the `xorgproto` package in the Devel section of the GUI installer will
 install the headers and other development related files for all of X11.
 
-Once you have the required depdendencies, move on to @ref compile_generate.
+Once you have the required dependencies, move on to @ref compile_generate.
 
 
-@subsubsection compile_deps_wayland Dependencies for Wayland on Unix-like systems
+@subsubsection compile_deps_wayland Dependencies for Wayland and X11 on Unix-like systems
 
-To compile GLFW for Wayland, you need to have the Wayland and xkbcommon
-development packages installed.  They are not needed to build or run programs
-that use GLFW.
+To compile GLFW for both Wayland and X11, you need to have the X11, Wayland and xkbcommon
+development packages installed.  They are not needed to build or run programs that use
+GLFW.  You will also need to set the @ref GLFW_BUILD_WAYLAND CMake option in the next
+step when generating build files.
 
-On Debian and derivates like Ubuntu and Linux Mint you will need the
-`libwayland-dev`, `libxkbcommon-dev` and `wayland-protocols` packages.
+On Debian and derivates like Ubuntu and Linux Mint you will need the `libwayland-dev`,
+`libxkbcommon-dev` and `wayland-protocols` packages and the `xorg-dev` meta-package.
+These will pull in all other dependencies.
 
 @code{.sh}
-sudo apt install libwayland-dev libxkbcommon-dev wayland-protocols
+sudo apt install libwayland-dev libxkbcommon-dev wayland-protocols xorg-dev
 @endcode
 
 On Fedora and derivatives like Red Hat you will need the `wayland-devel`,
-`libxkbcommon-devel` and `wayland-protocols-devel` packages.
+`libxkbcommon-devel`, `wayland-protocols-devel`, `libXcursor-devel`, `libXi-devel`,
+`libXinerama-devel` and `libXrandr-devel` packages.  These will pull in all other
+dependencies.
 
 @code{.sh}
-sudo dnf install wayland-devel libxkbcommon-devel wayland-protocols-devel
+sudo dnf install wayland-devel libxkbcommon-devel wayland-protocols-devel libXcursor-devel libXi-devel libXinerama-devel libXrandr-devel
 @endcode
 
-On FreeBSD you will need the `wayland`, `libxkbcommon` and `wayland-protocols`
-packages.
+On FreeBSD you will need the `wayland`, `libxkbcommon` and `wayland-protocols` packages.
+The X11 headers are installed along the end-user X11 packages, so if you have an X server
+running you should have the headers as well.  If not, install the `xorgproto` package.
 
 @code{.sh}
-pkg install wayland libxkbcommon wayland-protocols
+pkg install wayland libxkbcommon wayland-protocols xorgproto
 @endcode
 
-Once you have the required depdendencies, move on to @ref compile_generate.
+Once you have the required dependencies, move on to @ref compile_generate.
 
 
 @subsection compile_generate Generating build files with CMake
@@ -135,9 +140,9 @@ If you wish change any CMake variables in the list, press _Configure_ and then
 _Generate_ to have the new values take effect.  The variable list will be
 populated after the first configure step.
 
-By default GLFW will use X11 on Linux and other Unix-like systems other
-than macOS.  To use Wayland instead, set the `GLFW_USE_WAYLAND` option in the
-GLFW section of the variable list, then apply the new value as described above.
+By default GLFW will use X11 on Linux and other Unix-like systems other than macOS.  To
+include support for Wayland as well, set the @ref GLFW_BUILD_WAYLAND option in the GLFW
+section of the variable list, then apply the new value as described above.
 
 Once you have generated the project files or makefiles for your chosen
 development environment, move on to @ref compile_compile.
@@ -170,10 +175,11 @@ cmake -S path/to/glfw -B path/to/build -G Xcode
 @endcode
 
 By default GLFW will use X11 on Linux and other Unix-like systems other
-than macOS.  To use Wayland instead, set the `GLFW_USE_WAYLAND` CMake option.
+than macOS.  To also include support for Wayland, set the @ref GLFW_BUILD_WAYLAND CMake
+option.
 
 @code{.sh}
-cmake -S path/to/glfw -B path/to/build -D GLFW_USE_WAYLAND=1
+cmake -S path/to/glfw -B path/to/build -D GLFW_BUILD_WAYLAND=1
 @endcode
 
 Once you have generated the project files or makefiles for your chosen
@@ -274,6 +280,11 @@ directly with the application.  This is disabled by default.
 
 @subsection compile_options_win32 Windows specific CMake options
 
+@anchor GLFW_BUILD_WIN32
+__GLFW_BUILD_WIN32__ determines whether to include support for Win32 when compiling the
+library.  This option is only available when compiling for Windows.  This is enabled by
+default.
+
 @anchor USE_MSVC_RUNTIME_LIBRARY_DLL
 __USE_MSVC_RUNTIME_LIBRARY_DLL__ determines whether to use the DLL version or the
 static library version of the Visual C++ runtime library.  When enabled, the
@@ -292,12 +303,25 @@ will not work if GLFW is built as a DLL.  This is disabled by default, letting
 the operating system and driver decide.
 
 
-@subsection compile_options_wayland Wayland specific CMake options
+@subsection compile_options_macos macOS specific CMake options
+
+@anchor GLFW_BUILD_COCOA
+__GLFW_BUILD_COCOA__ determines whether to include support for Cocoa when compiling the
+library.  This option is only available when compiling for macOS.  This is enabled by
+default.
+
 
-@anchor GLFW_USE_WAYLAND
-__GLFW_USE_WAYLAND__ determines whether to compile the library for Wayland.
-This option is only available on Linux and other Unix-like systems other than
-macOS.  This is disabled by default.
+@subsection compile_options_unix Unix-like system specific CMake options
+
+@anchor GLFW_BUILD_WAYLAND
+__GLFW_BUILD_WAYLAND__ determines whether to include support for Wayland when compiling
+the library.  This option is only available when compiling for Linux and other Unix-like
+systems other than macOS.  This is disabled by default.
+
+@anchor GLFW_BUILD_X11
+__GLFW_BUILD_X11__ determines whether to include support for X11 when compiling the
+library.  This option is only available when compiling for Linux and other Unix-like
+systems other than macOS.  This is enabled by default.
 
 
 @section compile_mingw_cross Cross-compilation with CMake and MinGW
@@ -335,25 +359,26 @@ For more details see the
 
 @section compile_manual Compiling GLFW manually
 
-If you wish to compile GLFW without its CMake build environment then you will
-have to do at least some of the platform detection yourself.  GLFW needs
-a configuration macro to be defined in order to know what window system it is
-being compiled for and also has optional, platform-specific ones for various
-features.
+If you wish to compile GLFW without its CMake build environment then you will have to do
+at least some of the platform detection yourself.  There are preprocessor macros for
+enabling support for the platforms (window systems) available.  There are also optional,
+platform-specific macros for various features.
 
 When building, GLFW will expect the necessary configuration macros to be defined
 on the command-line.  The GLFW CMake files set these as private compile
 definitions on the GLFW target but if you compile the GLFW sources manually you
 will need to define them yourself.
 
-The window creation API is used to create windows, handle input, monitors, gamma
-ramps and clipboard.  The options are:
+The window system is used to create windows, handle input, monitors, gamma ramps and
+clipboard.  The options are:
 
  - @b _GLFW_COCOA to use the Cocoa frameworks
  - @b _GLFW_WIN32 to use the Win32 API
  - @b _GLFW_X11 to use the X Window System
- - @b _GLFW_WAYLAND to use the Wayland API (experimental and incomplete)
- - @b _GLFW_OSMESA to use the OSMesa API (headless and non-interactive)
+ - @b _GLFW_WAYLAND to use the Wayland API (incomplete)
+
+The @b _GLFW_WAYLAND and @b _GLFW_X11 macros may be combined and produces a library that
+attempts to detect the appropriate platform at initialization.
 
 If you are building GLFW as a shared library / dynamic library / DLL then you
 must also define @b _GLFW_BUILD_DLL.  Otherwise, you must not define it.
diff --git a/docs/internal.dox b/docs/internal.dox
index ec2de50f..69227568 100644
--- a/docs/internal.dox
+++ b/docs/internal.dox
@@ -61,12 +61,21 @@ application-provided callbacks.  It is also prohibited from modifying the
 platform-independent part of the internal structs.  Instead, it calls the event
 interface when events interesting to GLFW are received.
 
-The platform interface mirrors those parts of the public interface that needs to
-perform platform-specific operations on some or all platforms.  The are also
-named the same except that the glfw function prefix is replaced by
-_glfwPlatform.
+The platform interface mostly mirrors those parts of the public interface that needs to
+perform platform-specific operations on some or all platforms.
 
-Examples: `_glfwPlatformCreateWindow`
+The window system bits of the platform API is called through the `_GLFWplatform` struct of
+function pointers, to allow runtime selection of platform.  This includes the window and
+context creation, input and event processing, monitor and Vulkan surface creation parts of
+GLFW.  This is located in the global `_glfw` struct.
+
+Examples: `_glfw.platform.createWindow`
+
+The timer, threading and module loading bits of the platform API are plain functions with
+a `_glfwPlatform` prefix, as these things are independent of what window system is being
+used.
+
+Examples: `_glfwPlatformGetTimerValue`
 
 The platform interface also defines structs that contain platform-specific
 global and per-object state.  Their names mirror those of the internal
diff --git a/docs/intro.dox b/docs/intro.dox
index 4134c84d..c50a3722 100644
--- a/docs/intro.dox
+++ b/docs/intro.dox
@@ -30,6 +30,7 @@ successfully initialized, and only from the main thread.
 
  - @ref glfwGetVersion
  - @ref glfwGetVersionString
+ - @ref glfwPlatformSupported
  - @ref glfwGetError
  - @ref glfwSetErrorCallback
  - @ref glfwInitHint
@@ -89,6 +90,15 @@ Setting these hints requires no platform specific headers or functions.
 
 @subsubsection init_hints_shared Shared init hints
 
+@anchor GLFW_PLATFORM
+__GLFW_PLATFORM__ specifies the platform to use for windowing and input.
+Possible values are `GLFW_ANY_PLATFORM`, `GLFW_PLATFORM_WIN32`,
+`GLFW_PLATFORM_COCOA`, `GLFW_PLATFORM_X11`, `GLFW_PLATFORM_WAYLAND` and
+`GLFW_PLATFORM_NULL`.  The default value is `GLFW_ANY_PLATFORM`, which will
+choose any platform the library includes support for except for the Null
+backend.
+
+
 @anchor GLFW_JOYSTICK_HAT_BUTTONS
 __GLFW_JOYSTICK_HAT_BUTTONS__ specifies whether to also expose joystick hats as
 buttons, for compatibility with earlier versions of GLFW that did not have @ref
@@ -137,6 +147,7 @@ the `VK_KHR_xlib_surface` extension.  Possible values are `GLFW_TRUE` and
 
 Initialization hint              | Default value                   | Supported values
 -------------------------------- | ------------------------------- | ----------------
+@ref GLFW_PLATFORM               | `GLFW_ANY_PLATFORM`             | `GLFW_ANY_PLATFORM`, `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`, `GLFW_PLATFORM_X11`, `GLFW_PLATFORM_WAYLAND` or `GLFW_PLATFORM_NULL`
 @ref GLFW_JOYSTICK_HAT_BUTTONS   | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
 @ref GLFW_ANGLE_PLATFORM_TYPE    | `GLFW_ANGLE_PLATFORM_TYPE_NONE` | `GLFW_ANGLE_PLATFORM_TYPE_NONE`, `GLFW_ANGLE_PLATFORM_TYPE_OPENGL`, `GLFW_ANGLE_PLATFORM_TYPE_OPENGLES`, `GLFW_ANGLE_PLATFORM_TYPE_D3D9`, `GLFW_ANGLE_PLATFORM_TYPE_D3D11`, `GLFW_ANGLE_PLATFORM_TYPE_VULKAN` or `GLFW_ANGLE_PLATFORM_TYPE_METAL`
 @ref GLFW_COCOA_CHDIR_RESOURCES  | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
@@ -144,6 +155,48 @@ Initialization hint              | Default value                   | Supported v
 @ref GLFW_X11_XCB_VULKAN_SURFACE | `GLFW_TRUE`                     | `GLFW_TRUE` or `GLFW_FALSE`
 
 
+@subsection platform Runtime platform selection
+
+GLFW can be compiled for more than one platform (window system) at once.  This lets
+a single library binary support both X11 and Wayland on Linux and other Unix-like systems.
+
+You can control platform selection via the @ref GLFW_PLATFORM initialization hint.  By
+default this is set to @ref GLFW_ANY_PLATFORM, which will look for supported window
+systems in order of priority and select the first one it finds.  It can also be set to any
+specific platform to have GLFW only look for that one.
+
+@code
+glfwInitHint(GLFW_PLATFORM, GLFW_PLATFORM_X11);
+@endcode
+
+This mechanism also provides the Null platform, which is always supported but needs to be
+explicitly requested.  This platform is effectively a stub, emulating a window system on
+a single 1080p monitor, but will not interact with any actual window system.
+
+@code
+glfwInitHint(GLFW_PLATFORM, GLFW_PLATFORM_NULL);
+@endcode
+
+You can test whether a library binary was compiled with support for a specific platform
+with @ref glfwPlatformSupported.
+
+@code
+if (glfwPlatformSupported(GLFW_PLATFORM_WAYLAND))
+    glfwInitHint(GLFW_PLATFORM, GLFW_PLATFORM_WAYLAND);
+@endcode
+
+Once GLFW has been initialized, you can query which platform was selected with @ref
+glfwGetPlatform.
+
+@code
+int platform = glfwGetPlatform();
+@endcode
+
+If you are using any [native access functions](@ref native), especially on Linux and other
+Unix-like systems, then you may need to check that you are calling the ones matching the
+selected platform.
+
+
 @subsection init_allocator Custom heap memory allocator
 
 The heap memory allocator can be customized before initialization with @ref
@@ -437,6 +490,11 @@ Library version information may be queried from any thread.
  - @ref glfwGetVersion
  - @ref glfwGetVersionString
 
+Platform information may be queried from any thread.
+
+ - @ref glfwPlatformSupported
+ - @ref glfwGetPlatform
+
 All Vulkan related functions may be called from any thread.
 
  - @ref glfwVulkanSupported
@@ -529,17 +587,32 @@ __Do not use the version string__ to parse the GLFW library version.  The @ref
 glfwGetVersion function already provides the version of the running library
 binary.
 
+__Do not use the version string__ to parse what platforms are supported.  The @ref
+glfwPlatformSupported function lets you query platform support.
+
+__GLFW 3.4:__ The format of this string was changed to support the addition of
+[runtime platform selection](@ref platform).
+
 The format of the string is as follows:
  - The version of GLFW
- - The name of the window system API
- - The name of the context creation API
- - Any additional options or APIs
+ - For each supported platform:
+   - The name of the window system API
+   - The name of the window system specific context creation API, if applicable
+ - The names of the always supported context creation APIs EGL and OSMesa
+ - Any additional compile-time options, APIs and (on Windows) what compiler was used
+
+For example, GLFW 3.4 compiled as a DLL for Windows with MinGW may have a version string
+like this:
+
+@code
+3.4.0 Win32 WGL Null EGL OSMesa MinGW DLL
+@endcode
 
-For example, when compiling GLFW 3.0 with MinGW using the Win32 and WGL
-back ends, the version string may look something like this:
+While GLFW compiled as as static library for Linux with both Wayland and X11 enabled may
+have a version string like this:
 
 @code
-3.0.0 Win32 WGL MinGW
+3.4.0 Wayland X11 GLX Null EGL OSMesa monotonic
 @endcode
 
 */
diff --git a/docs/news.dox b/docs/news.dox
index 6b1367d5..28affab0 100644
--- a/docs/news.dox
+++ b/docs/news.dox
@@ -9,6 +9,14 @@
 
 @subsection features_34 New features in version 3.4
 
+@subsubsection runtime_platform_34 Runtime platform selection
+
+GLFW now supports being compiled for multiple backends and selecting between
+them at runtime with the @ref GLFW_PLATFORM init hint.  After initialization the
+selected platform can be queried with @ref glfwGetPlatform.  You can check if
+support for a given platform is compiled in with @ref glfwPlatformSupported.
+
+
 @subsubsection standard_cursors_34 More standard cursors
 
 GLFW now provides the standard cursor shapes @ref GLFW_RESIZE_NWSE_CURSOR and
@@ -63,7 +71,23 @@ Alt-and-then-Space shortcuts.  This may be useful for more GUI-oriented
 applications.
 
 
-@subsection caveats_34 Caveats for version 3.4
+@subsection caveats Caveats for version 3.4
+
+@subsubsection native_34 Multiple sets of native access functions
+
+Because GLFW now supports runtime selection of platform (window system), a library binary
+may export native access functions for multiple platforms.  Starting with version 3.4 you
+must not assume that GLFW is running on a platform just because it exports native access
+functions for it.  After initialization you can query the selected platform with @ref
+glfwGetPlatform.
+
+
+@subsubsection version_string_34 Version string format has been changed
+
+Because GLFW now supports runtime selection of platform (window system), the version
+string returned by @ref glfwGetVersionString has been expanded.  It now contains the names
+of all APIs for all the platforms that the library binary supports.
+
 
 @subsubsection joysticks_34 Joystick support is initialized on demand
 
@@ -118,6 +142,18 @@ GLFW_TRANSPARENT_FRAMEBUFFER on Windows 7 if DWM transparency is off
 
 @subsection removals_34 Removals in 3.4
 
+@subsubsection osmesa_option_34 GLFW_USE_OSMESA CMake option has been removed
+
+This option was used to compile GLFW for the Null platform.  The Null platform is now
+always supported.  To produce a library binary that only supports this platform, the way
+this CMake option used to do, you will instead need to disable the default platform for
+the target OS.  This means setting the @ref GLFW_BUILD_WIN32, @ref GLFW_BUILD_COCOA or
+@ref GLFW_BUILD_X11 CMake option to false.
+
+You can set all of them to false and the ones that don't apply for the target OS will be
+ignored.
+
+
 @subsubsection wl_shell_34 Support for the wl_shell protocol has been removed
 
 Support for the wl_shell protocol has been removed and GLFW now only supports
@@ -130,6 +166,8 @@ then GLFW will fail to initialize.
 @subsubsection functions_34 New functions in version 3.4
 
  - @ref glfwInitAllocator
+ - @ref glfwGetPlatform
+ - @ref glfwPlatformSupported
 
 
 @subsubsection types_34 New types in version 3.4
@@ -142,6 +180,14 @@ then GLFW will fail to initialize.
 
 @subsubsection constants_34 New constants in version 3.4
 
+ - @ref GLFW_PLATFORM
+ - @ref GLFW_ANY_PLATFORM
+ - @ref GLFW_PLATFORM_WIN32
+ - @ref GLFW_PLATFORM_COCOA
+ - @ref GLFW_PLATFORM_WAYLAND
+ - @ref GLFW_PLATFORM_X11
+ - @ref GLFW_PLATFORM_NULL
+ - @ref GLFW_PLATFORM_UNAVAILABLE
  - @ref GLFW_POINTING_HAND_CURSOR
  - @ref GLFW_RESIZE_EW_CURSOR
  - @ref GLFW_RESIZE_NS_CURSOR
diff --git a/include/GLFW/glfw3.h b/include/GLFW/glfw3.h
index 443af7cd..efd54e0c 100644
--- a/include/GLFW/glfw3.h
+++ b/include/GLFW/glfw3.h
@@ -717,7 +717,7 @@ extern "C" {
  *  GLFW could not find support for the requested API on the system.
  *
  *  @analysis The installed graphics driver does not support the requested
- *  API, or does not support it via the chosen context creation backend.
+ *  API, or does not support it via the chosen context creation API.
  *  Below are a few examples.
  *
  *  @par
@@ -786,7 +786,7 @@ extern "C" {
 /*! @brief The specified cursor shape is not available.
  *
  *  The specified standard cursor shape is not available, either because the
- *  current system cursor theme does not provide it or because it is not
+ *  current platform cursor theme does not provide it or because it is not
  *  available on the platform.
  *
  *  @analysis Platform or system settings limitation.  Pick another
@@ -821,6 +821,28 @@ extern "C" {
  *  updating any existing out parameters.
  */
 #define GLFW_FEATURE_UNIMPLEMENTED  0x0001000D
+/*! @brief Platform unavailable or no matching platform was found.
+ *
+ *  If emitted during initialization, no matching platform was found.  If @ref
+ *  GLFW_PLATFORM is set to `GLFW_ANY_PLATFORM`, GLFW could not detect any of the
+ *  platforms supported by this library binary, except for the Null platform.  If set to
+ *  a specific platform, it is either not supported by this library binary or GLFW was not
+ *  able to detect it.
+ *
+ *  If emitted by a native access function, GLFW was initialized for a different platform
+ *  than the function is for.
+ *
+ *  @analysis Failure to detect any platform usually only happens on non-macOS Unix
+ *  systems, either when no window system is running or the program was run from
+ *  a terminal that does not have the necessary environment variables.  Fall back to
+ *  a different platform if possible or notify the user that no usable platform was
+ *  detected.
+ *
+ *  Failure to detect a specific platform may have the same cause as above or be because
+ *  support for that platform was not compiled in.  Call @ref glfwPlatformSupported to
+ *  check whether a specific platform is supported by a library binary.
+ */
+#define GLFW_PLATFORM_UNAVAILABLE   0x0001000E
 /*! @} */
 
 /*! @addtogroup window
@@ -1125,7 +1147,7 @@ extern "C" {
  *  @brief Standard system cursor shapes.
  *
  *  These are the [standard cursor shapes](@ref cursor_standard) that can be
- *  requested from the window system.
+ *  requested from the platform (window system).
  *
  *  @ingroup input
  *  @{ */
@@ -1242,6 +1264,11 @@ extern "C" {
  *  ANGLE rendering backend [init hint](@ref GLFW_ANGLE_PLATFORM_TYPE_hint).
  */
 #define GLFW_ANGLE_PLATFORM_TYPE    0x00050002
+/*! @brief Platform selection init hint.
+ *
+ *  Platform selection [init hint](@ref GLFW_PLATFORM).
+ */
+#define GLFW_PLATFORM               0x00050003
 /*! @brief macOS specific init hint.
  *
  *  macOS specific [init hint](@ref GLFW_COCOA_CHDIR_RESOURCES_hint).
@@ -1259,6 +1286,20 @@ extern "C" {
 #define GLFW_X11_XCB_VULKAN_SURFACE 0x00052001
 /*! @} */
 
+/*! @addtogroup init
+ *  @{ */
+/*! @brief Hint value that enables automatic platform selection.
+ *
+ *  Hint value for @ref GLFW_PLATFORM that enables automatic platform selection.
+ */
+#define GLFW_ANY_PLATFORM           0x00060000
+#define GLFW_PLATFORM_WIN32         0x00060001
+#define GLFW_PLATFORM_COCOA         0x00060002
+#define GLFW_PLATFORM_WAYLAND       0x00060003
+#define GLFW_PLATFORM_X11           0x00060004
+#define GLFW_PLATFORM_NULL          0x00060005
+/*! @} */
+
 #define GLFW_DONT_CARE              -1
 
 
@@ -1770,7 +1811,7 @@ typedef void (* GLFWscrollfun)(GLFWwindow* window, double xoffset, double yoffse
  *
  *  @param[in] window The window that received the event.
  *  @param[in] key The [keyboard key](@ref keys) that was pressed or released.
- *  @param[in] scancode The system-specific scancode of the key.
+ *  @param[in] scancode The platform-specific scancode of the key.
  *  @param[in] action `GLFW_PRESS`, `GLFW_RELEASE` or `GLFW_REPEAT`.  Future
  *  releases may add more actions.
  *  @param[in] mods Bit field describing which [modifier keys](@ref mods) were
@@ -2047,10 +2088,15 @@ typedef struct GLFWallocator
  *  Additional calls to this function after successful initialization but before
  *  termination will return `GLFW_TRUE` immediately.
  *
+ *  The @ref GLFW_PLATFORM init hint controls which platforms are considered during
+ *  initialization.  This also depends on which platforms the library was compiled to
+ *  support.
+ *
  *  @return `GLFW_TRUE` if successful, or `GLFW_FALSE` if an
  *  [error](@ref error_handling) occurred.
  *
- *  @errors Possible errors include @ref GLFW_PLATFORM_ERROR.
+ *  @errors Possible errors include @ref GLFW_PLATFORM_UNAVAILABLE and @ref
+ *  GLFW_PLATFORM_ERROR.
  *
  *  @remark @macos This function will change the current directory of the
  *  application to the `Contents/Resources` subdirectory of the application's
@@ -2205,15 +2251,18 @@ GLFWAPI void glfwGetVersion(int* major, int* minor, int* rev);
 /*! @brief Returns a string describing the compile-time configuration.
  *
  *  This function returns the compile-time generated
- *  [version string](@ref intro_version_string) of the GLFW library binary.  It
- *  describes the version, platform, compiler and any platform-specific
- *  compile-time options.  It should not be confused with the OpenGL or OpenGL
- *  ES version string, queried with `glGetString`.
+ *  [version string](@ref intro_version_string) of the GLFW library binary.  It describes
+ *  the version, platforms, compiler and any platform or operating system specific
+ *  compile-time options.  It should not be confused with the OpenGL or OpenGL ES version
+ *  string, queried with `glGetString`.
  *
  *  __Do not use the version string__ to parse the GLFW library version.  The
  *  @ref glfwGetVersion function provides the version of the running library
  *  binary in numerical format.
  *
+ *  __Do not use the version string__ to parse what platforms are supported.  The @ref
+ *  glfwPlatformSupported function lets you query platform support.
+ *
  *  @return The ASCII encoded GLFW version string.
  *
  *  @errors None.
@@ -2310,6 +2359,51 @@ GLFWAPI int glfwGetError(const char** description);
  */
 GLFWAPI GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback);
 
+/*! @brief Returns the currently selected platform.
+ *
+ *  This function returns the platform that was selected during initialization.  The
+ *  returned value will be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
+ *  `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.
+ *
+ *  @return The currently selected platform, or zero if an error occurred.
+ *
+ *  @errors Possible errors include @ref GLFW_NOT_INITIALIZED.
+ *
+ *  @thread_safety This function may be called from any thread.
+ *
+ *  @sa @ref platform
+ *  @sa @ref glfwPlatformSupported
+ *
+ *  @since Added in version 3.4.
+ *
+ *  @ingroup init
+ */
+GLFWAPI int glfwGetPlatform(void);
+
+/*! @brief Returns whether the library includes support for the specified platform.
+ *
+ *  This function returns whether the library was compiled with support for the specified
+ *  platform.  The platform must be one of `GLFW_PLATFORM_WIN32`, `GLFW_PLATFORM_COCOA`,
+ *  `GLFW_PLATFORM_WAYLAND`, `GLFW_PLATFORM_X11` or `GLFW_PLATFORM_NULL`.
+ *
+ *  @param[in] platform The platform to query.
+ *  @return `GLFW_TRUE` if the platform is supported, or `GLFW_FALSE` otherwise.
+ *
+ *  @errors Possible errors include @ref GLFW_INVALID_ENUM.
+ *
+ *  @remark This function may be called before @ref glfwInit.
+ *
+ *  @thread_safety This function may be called from any thread.
+ *
+ *  @sa @ref platform
+ *  @sa @ref glfwGetPlatform
+ *
+ *  @since Added in version 3.4.
+ *
+ *  @ingroup init
+ */
+GLFWAPI int glfwPlatformSupported(int platform);
+
 /*! @brief Returns the currently connected monitors.
  *
  *  This function returns an array of handles for all currently connected
@@ -2393,7 +2487,7 @@ GLFWAPI void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);
  *  This function returns the position, in screen coordinates, of the upper-left
  *  corner of the work area of the specified monitor along with the work area
  *  size in screen coordinates. The work area is defined as the area of the
- *  monitor not occluded by the operating system task bar where present. If no
+ *  monitor not occluded by the window system task bar where present. If no
  *  task bar exists then the work area is the monitor resolution in screen
  *  coordinates.
  *
@@ -2424,7 +2518,7 @@ GLFWAPI void glfwGetMonitorWorkarea(GLFWmonitor* monitor, int* xpos, int* ypos,
  *  This function returns the size, in millimetres, of the display area of the
  *  specified monitor.
  *
- *  Some systems do not provide accurate monitor size information, either
+ *  Some platforms do not provide accurate monitor size information, either
  *  because the monitor
  *  [EDID](https://en.wikipedia.org/wiki/Extended_display_identification_data)
  *  data is incorrect or because the driver does not report it accurately.
@@ -3438,7 +3532,7 @@ GLFWAPI void glfwGetWindowFrameSize(GLFWwindow* window, int* left, int* top, int
  *  regardless of their DPI and scaling settings.  This relies on the system DPI
  *  and scaling settings being somewhat correct.
  *
- *  On systems where each monitors can have its own content scale, the window
+ *  On platforms where each monitors can have its own content scale, the window
  *  content scale will depend on which monitor the system considers the window
  *  to be on.
  *
@@ -5677,7 +5771,7 @@ GLFWAPI const char* glfwGetClipboardString(GLFWwindow* window);
  *
  *  The resolution of the timer is system dependent, but is usually on the order
  *  of a few micro- or nanoseconds.  It uses the highest-resolution monotonic
- *  time source on each supported platform.
+ *  time source on each operating system.
  *
  *  @return The current time, in seconds, or zero if an
  *  [error](@ref error_handling) occurred.
@@ -5888,7 +5982,7 @@ GLFWAPI void glfwSwapBuffers(GLFWwindow* window);
  *  GLFW_NO_CURRENT_CONTEXT and @ref GLFW_PLATFORM_ERROR.
  *
  *  @remark This function is not called during context creation, leaving the
- *  swap interval set to whatever is the default on that platform.  This is done
+ *  swap interval set to whatever is the default for that API.  This is done
  *  because some swap interval extensions used by GLFW do not allow the swap
  *  interval to be reset to zero once it has been set to a non-zero value.
  *
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 0dda7386..0ab57255 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -2,8 +2,23 @@
 add_library(glfw ${GLFW_LIBRARY_TYPE}
                  "${GLFW_SOURCE_DIR}/include/GLFW/glfw3.h"
                  "${GLFW_SOURCE_DIR}/include/GLFW/glfw3native.h"
-                 internal.h mappings.h context.c init.c input.c monitor.c
-                 vulkan.c window.c)
+                 internal.h platform.h mappings.h
+                 context.c init.c input.c monitor.c platform.c vulkan.c window.c
+                 egl_context.c osmesa_context.c null_platform.h null_joystick.h
+                 null_init.c null_monitor.c null_window.c null_joystick.c)
+
+# The time, thread and module code is shared between all backends on a given OS,
+# including the null backend, which still needs those bits to be functional
+if (APPLE)
+    target_sources(glfw PRIVATE cocoa_time.h cocoa_time.c posix_thread.h
+                                posix_module.c posix_thread.c)
+elseif (WIN32)
+    target_sources(glfw PRIVATE win32_time.h win32_thread.h win32_module.c
+                                win32_time.c win32_thread.c)
+else()
+    target_sources(glfw PRIVATE posix_time.h posix_thread.h posix_module.c
+                                posix_time.c posix_thread.c)
+endif()
 
 add_custom_target(update_mappings
     COMMAND "${CMAKE_COMMAND}" -P "${GLFW_SOURCE_DIR}/CMake/GenerateMappings.cmake" mappings.h.in mappings.h
@@ -14,56 +29,40 @@ add_custom_target(update_mappings
 
 set_target_properties(update_mappings PROPERTIES FOLDER "GLFW3")
 
-if (_GLFW_COCOA)
+if (GLFW_BUILD_COCOA)
     target_compile_definitions(glfw PRIVATE _GLFW_COCOA)
-    target_sources(glfw PRIVATE cocoa_platform.h cocoa_joystick.h cocoa_time.h
-                                posix_thread.h cocoa_init.m cocoa_joystick.m
-                                cocoa_monitor.m cocoa_window.m cocoa_time.c
-                                posix_thread.c nsgl_context.m egl_context.c
-                                osmesa_context.c)
-elseif (_GLFW_WIN32)
+    target_sources(glfw PRIVATE cocoa_platform.h cocoa_joystick.h cocoa_init.m
+                                cocoa_joystick.m cocoa_monitor.m cocoa_window.m
+                                nsgl_context.m)
+endif()
+
+if (GLFW_BUILD_WIN32)
     target_compile_definitions(glfw PRIVATE _GLFW_WIN32)
-    target_sources(glfw PRIVATE win32_platform.h win32_joystick.h win32_time.h
-                                win32_thread.h win32_init.c win32_joystick.c
-                                win32_monitor.c win32_time.c win32_thread.c
-                                win32_window.c wgl_context.c egl_context.c
-                                osmesa_context.c)
-elseif (_GLFW_X11)
+    target_sources(glfw PRIVATE win32_platform.h win32_joystick.h win32_init.c
+                                win32_joystick.c win32_monitor.c win32_window.c
+                                wgl_context.c)
+endif()
+
+if (GLFW_BUILD_X11)
     target_compile_definitions(glfw PRIVATE _GLFW_X11)
-    target_sources(glfw PRIVATE x11_platform.h xkb_unicode.h posix_time.h
-                                posix_thread.h x11_init.c x11_monitor.c
-                                x11_window.c xkb_unicode.c posix_time.c
-                                posix_thread.c glx_context.c egl_context.c
-                                osmesa_context.c)
-elseif (_GLFW_WAYLAND)
-    target_compile_definitions(glfw PRIVATE _GLFW_WAYLAND)
-    target_sources(glfw PRIVATE wl_platform.h posix_time.h posix_thread.h
-                                xkb_unicode.h wl_init.c wl_monitor.c wl_window.c
-                                posix_time.c posix_thread.c xkb_unicode.c
-                                egl_context.c osmesa_context.c)
-elseif (_GLFW_OSMESA)
-    target_compile_definitions(glfw PRIVATE _GLFW_OSMESA)
-    target_sources(glfw PRIVATE null_platform.h null_joystick.h posix_time.h
-                                posix_thread.h null_init.c null_monitor.c
-                                null_window.c null_joystick.c posix_time.c
-                                posix_thread.c egl_context.c osmesa_context.c)
+    target_sources(glfw PRIVATE x11_platform.h xkb_unicode.h x11_init.c
+                                x11_monitor.c x11_window.c xkb_unicode.c
+                                glx_context.c)
 endif()
 
-if (WIN32)
-    target_sources(glfw PRIVATE win32_module.c)
-else()
-    target_sources(glfw PRIVATE posix_module.c)
+if (GLFW_BUILD_WAYLAND)
+    target_compile_definitions(glfw PRIVATE _GLFW_WAYLAND)
+    target_sources(glfw PRIVATE wl_platform.h xkb_unicode.h wl_init.c
+                                wl_monitor.c wl_window.c xkb_unicode.c)
 endif()
 
-if (_GLFW_X11 OR _GLFW_WAYLAND)
+if (GLFW_BUILD_X11 OR GLFW_BUILD_WAYLAND)
     if (CMAKE_SYSTEM_NAME STREQUAL "Linux")
         target_sources(glfw PRIVATE linux_joystick.h linux_joystick.c)
-    else()
-        target_sources(glfw PRIVATE null_joystick.h null_joystick.c)
     endif()
 endif()
 
-if (_GLFW_WAYLAND)
+if (GLFW_BUILD_WAYLAND)
     include(CheckIncludeFiles)
     include(CheckFunctionExists)
     check_include_files(xkbcommon/xkbcommon-compose.h HAVE_XKBCOMMON_COMPOSE_H)
@@ -161,11 +160,11 @@ if (GLFW_VULKAN_STATIC)
     list(APPEND glfw_PKG_DEPS "vulkan")
 endif()
 
-if (_GLFW_WIN32)
+if (GLFW_BUILD_WIN32)
     list(APPEND glfw_PKG_LIBS "-lgdi32")
 endif()
 
-if (_GLFW_COCOA)
+if (GLFW_BUILD_COCOA)
     target_link_libraries(glfw PRIVATE "-framework Cocoa"
                                        "-framework IOKit"
                                        "-framework CoreFoundation")
@@ -174,7 +173,7 @@ if (_GLFW_COCOA)
     set(glfw_PKG_LIBS "-framework Cocoa -framework IOKit -framework CoreFoundation")
 endif()
 
-if (_GLFW_WAYLAND)
+if (GLFW_BUILD_WAYLAND)
     pkg_check_modules(Wayland REQUIRED
         wayland-client>=0.2.7
         wayland-cursor>=0.2.7
@@ -192,7 +191,7 @@ if (_GLFW_WAYLAND)
     endif()
 endif()
 
-if (_GLFW_X11)
+if (GLFW_BUILD_X11)
     find_package(X11 REQUIRED)
     target_include_directories(glfw PRIVATE "${X11_X11_INCLUDE_PATH}")
 
@@ -251,11 +250,11 @@ endif()
 # Make GCC warn about declarations that VS 2010 and 2012 won't accept for all
 # source files that VS will build (Clang ignores this because we set -std=c99)
 if (CMAKE_C_COMPILER_ID STREQUAL "GNU")
-    set_source_files_properties(context.c init.c input.c monitor.c vulkan.c
-                                window.c win32_init.c win32_joystick.c
-                                win32_module.c win32_monitor.c win32_time.c win32_thread.c
-                                win32_window.c wgl_context.c egl_context.c
-                                osmesa_context.c PROPERTIES
+    set_source_files_properties(context.c init.c input.c monitor.c platform.c vulkan.c
+                                window.c null_init.c null_joystick.c null_monitor.c
+                                null_window.c win32_init.c win32_joystick.c win32_module.c
+                                win32_monitor.c win32_time.c win32_thread.c win32_window.c
+                                wgl_context.c egl_context.c osmesa_context.c PROPERTIES
                                 COMPILE_FLAGS -Wdeclaration-after-statement)
 endif()
 
@@ -276,7 +275,7 @@ elseif (CMAKE_C_COMPILER_ID STREQUAL "GNU" OR
     target_compile_options(glfw PRIVATE "-Wall")
 endif()
 
-if (_GLFW_WIN32)
+if (GLFW_BUILD_WIN32)
     target_compile_definitions(glfw PRIVATE UNICODE _UNICODE)
 endif()
 
@@ -318,7 +317,7 @@ if (MSVC90)
 endif()
 
 # Workaround for -std=c99 on Linux disabling _DEFAULT_SOURCE (POSIX 2008 and more)
-if (_GLFW_X11 OR _GLFW_WAYLAND OR _GLFW_OSMESA)
+if (GLFW_BUILD_X11 OR GLFW_BUILD_WAYLAND)
     if (CMAKE_SYSTEM_NAME STREQUAL "Linux")
         target_compile_definitions(glfw PRIVATE _DEFAULT_SOURCE)
     endif()
diff --git a/src/cocoa_init.m b/src/cocoa_init.m
index 9646ca48..e97d9596 100644
--- a/src/cocoa_init.m
+++ b/src/cocoa_init.m
@@ -444,7 +444,7 @@ static GLFWbool initializeTIS(void)
 
 - (void)applicationDidFinishLaunching:(NSNotification *)notification
 {
-    _glfwPlatformPostEmptyEvent();
+    _glfwPostEmptyEventCocoa();
     [NSApp stop:nil];
 }
 
@@ -489,7 +489,89 @@ void* _glfwLoadLocalVulkanLoaderCocoa(void)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformInit(void)
+GLFWbool _glfwConnectCocoa(int platformID, _GLFWplatform* platform)
+{
+    const _GLFWplatform cocoa =
+    {
+        GLFW_PLATFORM_COCOA,
+        _glfwInitCocoa,
+        _glfwTerminateCocoa,
+        _glfwGetCursorPosCocoa,
+        _glfwSetCursorPosCocoa,
+        _glfwSetCursorModeCocoa,
+        _glfwSetRawMouseMotionCocoa,
+        _glfwRawMouseMotionSupportedCocoa,
+        _glfwCreateCursorCocoa,
+        _glfwCreateStandardCursorCocoa,
+        _glfwDestroyCursorCocoa,
+        _glfwSetCursorCocoa,
+        _glfwGetScancodeNameCocoa,
+        _glfwGetKeyScancodeCocoa,
+        _glfwSetClipboardStringCocoa,
+        _glfwGetClipboardStringCocoa,
+        _glfwInitJoysticksCocoa,
+        _glfwTerminateJoysticksCocoa,
+        _glfwPollJoystickCocoa,
+        _glfwGetMappingNameCocoa,
+        _glfwUpdateGamepadGUIDCocoa,
+        _glfwFreeMonitorCocoa,
+        _glfwGetMonitorPosCocoa,
+        _glfwGetMonitorContentScaleCocoa,
+        _glfwGetMonitorWorkareaCocoa,
+        _glfwGetVideoModesCocoa,
+        _glfwGetVideoModeCocoa,
+        _glfwGetGammaRampCocoa,
+        _glfwSetGammaRampCocoa,
+        _glfwCreateWindowCocoa,
+        _glfwDestroyWindowCocoa,
+        _glfwSetWindowTitleCocoa,
+        _glfwSetWindowIconCocoa,
+        _glfwGetWindowPosCocoa,
+        _glfwSetWindowPosCocoa,
+        _glfwGetWindowSizeCocoa,
+        _glfwSetWindowSizeCocoa,
+        _glfwSetWindowSizeLimitsCocoa,
+        _glfwSetWindowAspectRatioCocoa,
+        _glfwGetFramebufferSizeCocoa,
+        _glfwGetWindowFrameSizeCocoa,
+        _glfwGetWindowContentScaleCocoa,
+        _glfwIconifyWindowCocoa,
+        _glfwRestoreWindowCocoa,
+        _glfwMaximizeWindowCocoa,
+        _glfwShowWindowCocoa,
+        _glfwHideWindowCocoa,
+        _glfwRequestWindowAttentionCocoa,
+        _glfwFocusWindowCocoa,
+        _glfwSetWindowMonitorCocoa,
+        _glfwWindowFocusedCocoa,
+        _glfwWindowIconifiedCocoa,
+        _glfwWindowVisibleCocoa,
+        _glfwWindowMaximizedCocoa,
+        _glfwWindowHoveredCocoa,
+        _glfwFramebufferTransparentCocoa,
+        _glfwGetWindowOpacityCocoa,
+        _glfwSetWindowResizableCocoa,
+        _glfwSetWindowDecoratedCocoa,
+        _glfwSetWindowFloatingCocoa,
+        _glfwSetWindowOpacityCocoa,
+        _glfwSetWindowMousePassthroughCocoa,
+        _glfwPollEventsCocoa,
+        _glfwWaitEventsCocoa,
+        _glfwWaitEventsTimeoutCocoa,
+        _glfwPostEmptyEventCocoa,
+        _glfwGetEGLPlatformCocoa,
+        _glfwGetEGLNativeDisplayCocoa,
+        _glfwGetEGLNativeWindowCocoa,
+        _glfwGetRequiredInstanceExtensionsCocoa,
+        _glfwGetPhysicalDevicePresentationSupportCocoa,
+        _glfwCreateWindowSurfaceCocoa,
+    };
+
+    *platform = cocoa;
+    return GLFW_TRUE;
+}
+
+int _glfwInitCocoa(void)
 {
     @autoreleasepool {
 
@@ -561,7 +643,7 @@ int _glfwPlatformInit(void)
     } // autoreleasepool
 }
 
-void _glfwPlatformTerminate(void)
+void _glfwTerminateCocoa(void)
 {
     @autoreleasepool {
 
@@ -607,12 +689,3 @@ void _glfwPlatformTerminate(void)
     } // autoreleasepool
 }
 
-const char* _glfwPlatformGetVersionString(void)
-{
-    return _GLFW_VERSION_NUMBER " Cocoa NSGL EGL OSMesa"
-#if defined(_GLFW_BUILD_DLL)
-        " dynamic"
-#endif
-        ;
-}
-
diff --git a/src/cocoa_joystick.h b/src/cocoa_joystick.h
index cfcb7ca3..756911a2 100644
--- a/src/cocoa_joystick.h
+++ b/src/cocoa_joystick.h
@@ -26,11 +26,10 @@
 
 #include <IOKit/IOKitLib.h>
 #include <IOKit/IOCFPlugIn.h>
-#include <IOKit/hid/IOHIDLib.h>
 #include <IOKit/hid/IOHIDKeys.h>
 
-#define _GLFW_PLATFORM_JOYSTICK_STATE         _GLFWjoystickNS ns
-#define _GLFW_PLATFORM_LIBRARY_JOYSTICK_STATE struct { int dummyJoystick; }
+#define GLFW_COCOA_JOYSTICK_STATE         _GLFWjoystickNS ns;
+#define GLFW_COCOA_LIBRARY_JOYSTICK_STATE
 
 #define GLFW_BUILD_COCOA_MAPPINGS
 
@@ -44,3 +43,9 @@ typedef struct _GLFWjoystickNS
     CFMutableArrayRef   hats;
 } _GLFWjoystickNS;
 
+GLFWbool _glfwInitJoysticksCocoa(void);
+void _glfwTerminateJoysticksCocoa(void);
+int _glfwPollJoystickCocoa(_GLFWjoystick* js, int mode);
+const char* _glfwGetMappingNameCocoa(void);
+void _glfwUpdateGamepadGUIDCocoa(char* guid);
+
diff --git a/src/cocoa_joystick.m b/src/cocoa_joystick.m
index 5e2666b2..74f20d02 100644
--- a/src/cocoa_joystick.m
+++ b/src/cocoa_joystick.m
@@ -307,7 +307,7 @@ static void removeCallback(void* context,
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-GLFWbool _glfwPlatformInitJoysticks(void)
+GLFWbool _glfwInitJoysticksCocoa(void)
 {
     CFMutableArrayRef matching;
     const long usages[] =
@@ -384,7 +384,7 @@ GLFWbool _glfwPlatformInitJoysticks(void)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminateJoysticks(void)
+void _glfwTerminateJoysticksCocoa(void)
 {
     int jid;
 
@@ -399,7 +399,7 @@ void _glfwPlatformTerminateJoysticks(void)
 }
 
 
-int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode)
+int _glfwPollJoystickCocoa(_GLFWjoystick* js, int mode)
 {
     if (mode & _GLFW_POLL_AXES)
     {
@@ -469,12 +469,12 @@ int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode)
     return js->present;
 }
 
-const char* _glfwPlatformGetMappingName(void)
+const char* _glfwGetMappingNameCocoa(void)
 {
     return "Mac OS X";
 }
 
-void _glfwPlatformUpdateGamepadGUID(char* guid)
+void _glfwUpdateGamepadGUIDCocoa(char* guid)
 {
     if ((strncmp(guid + 4, "000000000000", 12) == 0) &&
         (strncmp(guid + 20, "000000000000", 12) == 0))
diff --git a/src/cocoa_monitor.m b/src/cocoa_monitor.m
index 5416f5bf..2109a7fe 100644
--- a/src/cocoa_monitor.m
+++ b/src/cocoa_monitor.m
@@ -388,7 +388,7 @@ void _glfwPollMonitorsCocoa(void)
 void _glfwSetVideoModeCocoa(_GLFWmonitor* monitor, const GLFWvidmode* desired)
 {
     GLFWvidmode current;
-    _glfwPlatformGetVideoMode(monitor, &current);
+    _glfwGetVideoModeCocoa(monitor, &current);
 
     const GLFWvidmode* best = _glfwChooseVideoMode(monitor, desired);
     if (_glfwCompareVideoModes(&current, best) == 0)
@@ -447,11 +447,11 @@ void _glfwRestoreVideoModeCocoa(_GLFWmonitor* monitor)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-void _glfwPlatformFreeMonitor(_GLFWmonitor* monitor)
+void _glfwFreeMonitorCocoa(_GLFWmonitor* monitor)
 {
 }
 
-void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
+void _glfwGetMonitorPosCocoa(_GLFWmonitor* monitor, int* xpos, int* ypos)
 {
     @autoreleasepool {
 
@@ -465,8 +465,8 @@ void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
     } // autoreleasepool
 }
 
-void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
-                                         float* xscale, float* yscale)
+void _glfwGetMonitorContentScaleCocoa(_GLFWmonitor* monitor,
+                                      float* xscale, float* yscale)
 {
     @autoreleasepool {
 
@@ -487,9 +487,9 @@ void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
     } // autoreleasepool
 }
 
-void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
-                                     int* xpos, int* ypos,
-                                     int* width, int* height)
+void _glfwGetMonitorWorkareaCocoa(_GLFWmonitor* monitor,
+                                  int* xpos, int* ypos,
+                                  int* width, int* height)
 {
     @autoreleasepool {
 
@@ -513,7 +513,7 @@ void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
     } // autoreleasepool
 }
 
-GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count)
+GLFWvidmode* _glfwGetVideoModesCocoa(_GLFWmonitor* monitor, int* count)
 {
     @autoreleasepool {
 
@@ -553,7 +553,7 @@ GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count)
     } // autoreleasepool
 }
 
-void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode *mode)
+void _glfwGetVideoModeCocoa(_GLFWmonitor* monitor, GLFWvidmode *mode)
 {
     @autoreleasepool {
 
@@ -564,7 +564,7 @@ void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode *mode)
     } // autoreleasepool
 }
 
-GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
+GLFWbool _glfwGetGammaRampCocoa(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
 {
     @autoreleasepool {
 
@@ -593,7 +593,7 @@ GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
+void _glfwSetGammaRampCocoa(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
 {
     @autoreleasepool {
 
diff --git a/src/cocoa_platform.h b/src/cocoa_platform.h
index 76ddcb28..67c1a3cc 100644
--- a/src/cocoa_platform.h
+++ b/src/cocoa_platform.h
@@ -27,6 +27,7 @@
 #include <stdint.h>
 
 #include <Carbon/Carbon.h>
+#include <IOKit/hid/IOHIDLib.h>
 
 // NOTE: All of NSGL was deprecated in the 10.14 SDK
 //       This disables the pointless warnings for every symbol we use
@@ -91,17 +92,13 @@ typedef struct VkMetalSurfaceCreateInfoEXT
 typedef VkResult (APIENTRY *PFN_vkCreateMacOSSurfaceMVK)(VkInstance,const VkMacOSSurfaceCreateInfoMVK*,const VkAllocationCallbacks*,VkSurfaceKHR*);
 typedef VkResult (APIENTRY *PFN_vkCreateMetalSurfaceEXT)(VkInstance,const VkMetalSurfaceCreateInfoEXT*,const VkAllocationCallbacks*,VkSurfaceKHR*);
 
-#include "cocoa_time.h"
-#include "posix_thread.h"
-#include "cocoa_joystick.h"
+#define GLFW_COCOA_WINDOW_STATE         _GLFWwindowNS  ns;
+#define GLFW_COCOA_LIBRARY_WINDOW_STATE _GLFWlibraryNS ns;
+#define GLFW_COCOA_MONITOR_STATE        _GLFWmonitorNS ns;
+#define GLFW_COCOA_CURSOR_STATE         _GLFWcursorNS  ns;
 
-#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowNS  ns
-#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryNS ns
-#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorNS ns
-#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorNS  ns
-
-#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextNSGL nsgl
-#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryNSGL nsgl
+#define GLFW_NSGL_CONTEXT_STATE         _GLFWcontextNSGL nsgl;
+#define GLFW_NSGL_LIBRARY_CONTEXT_STATE _GLFWlibraryNSGL nsgl;
 
 // HIToolbox.framework pointer typedefs
 #define kTISPropertyUnicodeKeyLayoutData _glfw.ns.tis.kPropertyUnicodeKeyLayoutData
@@ -205,6 +202,81 @@ typedef struct _GLFWcursorNS
 } _GLFWcursorNS;
 
 
+GLFWbool _glfwConnectCocoa(int platformID, _GLFWplatform* platform);
+int _glfwInitCocoa(void);
+void _glfwTerminateCocoa(void);
+
+int _glfwCreateWindowCocoa(_GLFWwindow* window, const _GLFWwndconfig* wndconfig, const _GLFWctxconfig* ctxconfig, const _GLFWfbconfig* fbconfig);
+void _glfwDestroyWindowCocoa(_GLFWwindow* window);
+void _glfwSetWindowTitleCocoa(_GLFWwindow* window, const char* title);
+void _glfwSetWindowIconCocoa(_GLFWwindow* window, int count, const GLFWimage* images);
+void _glfwGetWindowPosCocoa(_GLFWwindow* window, int* xpos, int* ypos);
+void _glfwSetWindowPosCocoa(_GLFWwindow* window, int xpos, int ypos);
+void _glfwGetWindowSizeCocoa(_GLFWwindow* window, int* width, int* height);
+void _glfwSetWindowSizeCocoa(_GLFWwindow* window, int width, int height);
+void _glfwSetWindowSizeLimitsCocoa(_GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
+void _glfwSetWindowAspectRatioCocoa(_GLFWwindow* window, int numer, int denom);
+void _glfwGetFramebufferSizeCocoa(_GLFWwindow* window, int* width, int* height);
+void _glfwGetWindowFrameSizeCocoa(_GLFWwindow* window, int* left, int* top, int* right, int* bottom);
+void _glfwGetWindowContentScaleCocoa(_GLFWwindow* window, float* xscale, float* yscale);
+void _glfwIconifyWindowCocoa(_GLFWwindow* window);
+void _glfwRestoreWindowCocoa(_GLFWwindow* window);
+void _glfwMaximizeWindowCocoa(_GLFWwindow* window);
+void _glfwShowWindowCocoa(_GLFWwindow* window);
+void _glfwHideWindowCocoa(_GLFWwindow* window);
+void _glfwRequestWindowAttentionCocoa(_GLFWwindow* window);
+void _glfwFocusWindowCocoa(_GLFWwindow* window);
+void _glfwSetWindowMonitorCocoa(_GLFWwindow* window, _GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
+int _glfwWindowFocusedCocoa(_GLFWwindow* window);
+int _glfwWindowIconifiedCocoa(_GLFWwindow* window);
+int _glfwWindowVisibleCocoa(_GLFWwindow* window);
+int _glfwWindowMaximizedCocoa(_GLFWwindow* window);
+int _glfwWindowHoveredCocoa(_GLFWwindow* window);
+int _glfwFramebufferTransparentCocoa(_GLFWwindow* window);
+void _glfwSetWindowResizableCocoa(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowDecoratedCocoa(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowFloatingCocoa(_GLFWwindow* window, GLFWbool enabled);
+float _glfwGetWindowOpacityCocoa(_GLFWwindow* window);
+void _glfwSetWindowOpacityCocoa(_GLFWwindow* window, float opacity);
+void _glfwSetWindowMousePassthroughCocoa(_GLFWwindow* window, GLFWbool enabled);
+
+void _glfwSetRawMouseMotionCocoa(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwRawMouseMotionSupportedCocoa(void);
+
+void _glfwPollEventsCocoa(void);
+void _glfwWaitEventsCocoa(void);
+void _glfwWaitEventsTimeoutCocoa(double timeout);
+void _glfwPostEmptyEventCocoa(void);
+
+void _glfwGetCursorPosCocoa(_GLFWwindow* window, double* xpos, double* ypos);
+void _glfwSetCursorPosCocoa(_GLFWwindow* window, double xpos, double ypos);
+void _glfwSetCursorModeCocoa(_GLFWwindow* window, int mode);
+const char* _glfwGetScancodeNameCocoa(int scancode);
+int _glfwGetKeyScancodeCocoa(int key);
+int _glfwCreateCursorCocoa(_GLFWcursor* cursor, const GLFWimage* image, int xhot, int yhot);
+int _glfwCreateStandardCursorCocoa(_GLFWcursor* cursor, int shape);
+void _glfwDestroyCursorCocoa(_GLFWcursor* cursor);
+void _glfwSetCursorCocoa(_GLFWwindow* window, _GLFWcursor* cursor);
+void _glfwSetClipboardStringCocoa(const char* string);
+const char* _glfwGetClipboardStringCocoa(void);
+
+EGLenum _glfwGetEGLPlatformCocoa(EGLint** attribs);
+EGLNativeDisplayType _glfwGetEGLNativeDisplayCocoa(void);
+EGLNativeWindowType _glfwGetEGLNativeWindowCocoa(_GLFWwindow* window);
+
+void _glfwGetRequiredInstanceExtensionsCocoa(char** extensions);
+int _glfwGetPhysicalDevicePresentationSupportCocoa(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily);
+VkResult _glfwCreateWindowSurfaceCocoa(VkInstance instance, _GLFWwindow* window, const VkAllocationCallbacks* allocator, VkSurfaceKHR* surface);
+
+void _glfwFreeMonitorCocoa(_GLFWmonitor* monitor);
+void _glfwGetMonitorPosCocoa(_GLFWmonitor* monitor, int* xpos, int* ypos);
+void _glfwGetMonitorContentScaleCocoa(_GLFWmonitor* monitor, float* xscale, float* yscale);
+void _glfwGetMonitorWorkareaCocoa(_GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
+GLFWvidmode* _glfwGetVideoModesCocoa(_GLFWmonitor* monitor, int* count);
+void _glfwGetVideoModeCocoa(_GLFWmonitor* monitor, GLFWvidmode* mode);
+GLFWbool _glfwGetGammaRampCocoa(_GLFWmonitor* monitor, GLFWgammaramp* ramp);
+void _glfwSetGammaRampCocoa(_GLFWmonitor* monitor, const GLFWgammaramp* ramp);
+
 void _glfwPollMonitorsCocoa(void);
 void _glfwSetVideoModeCocoa(_GLFWmonitor* monitor, const GLFWvidmode* desired);
 void _glfwRestoreVideoModeCocoa(_GLFWmonitor* monitor);
diff --git a/src/cocoa_time.h b/src/cocoa_time.h
index 6f41ef19..3512e8b6 100644
--- a/src/cocoa_time.h
+++ b/src/cocoa_time.h
@@ -24,7 +24,7 @@
 //
 //========================================================================
 
-#define _GLFW_PLATFORM_LIBRARY_TIMER_STATE  _GLFWtimerNS   ns
+#define GLFW_COCOA_LIBRARY_TIMER_STATE  _GLFWtimerNS   ns;
 
 // Cocoa-specific global timer data
 //
diff --git a/src/cocoa_window.m b/src/cocoa_window.m
index ab169d96..660bbd31 100644
--- a/src/cocoa_window.m
+++ b/src/cocoa_window.m
@@ -105,20 +105,20 @@ static void updateCursorMode(_GLFWwindow* window)
     if (window->cursorMode == GLFW_CURSOR_DISABLED)
     {
         _glfw.ns.disabledCursorWindow = window;
-        _glfwPlatformGetCursorPos(window,
-                                  &_glfw.ns.restoreCursorPosX,
-                                  &_glfw.ns.restoreCursorPosY);
+        _glfwGetCursorPosCocoa(window,
+                               &_glfw.ns.restoreCursorPosX,
+                               &_glfw.ns.restoreCursorPosY);
         _glfwCenterCursorInContentArea(window);
         CGAssociateMouseAndMouseCursorPosition(false);
     }
     else if (_glfw.ns.disabledCursorWindow == window)
     {
         _glfw.ns.disabledCursorWindow = NULL;
-        _glfwPlatformSetCursorPos(window,
-                                  _glfw.ns.restoreCursorPosX,
-                                  _glfw.ns.restoreCursorPosY);
+        _glfwSetCursorPosCocoa(window,
+                               _glfw.ns.restoreCursorPosX,
+                               _glfw.ns.restoreCursorPosY);
         // NOTE: The matching CGAssociateMouseAndMouseCursorPosition call is
-        //       made in _glfwPlatformSetCursorPos as part of a workaround
+        //       made in _glfwSetCursorPosCocoa as part of a workaround
     }
 
     if (cursorInContentArea(window))
@@ -286,7 +286,7 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
         _glfwCenterCursorInContentArea(window);
 
     int x, y;
-    _glfwPlatformGetWindowPos(window, &x, &y);
+    _glfwGetWindowPosCocoa(window, &x, &y);
     _glfwInputWindowPos(window, x, y);
 }
 
@@ -318,7 +318,7 @@ static const NSRange kEmptyRange = { NSNotFound, 0 };
 - (void)windowDidResignKey:(NSNotification *)notification
 {
     if (window->monitor && window->autoIconify)
-        _glfwPlatformIconifyWindow(window);
+        _glfwIconifyWindowCocoa(window);
 
     _glfwInputWindowFocus(window, GLFW_FALSE);
 }
@@ -803,8 +803,8 @@ static GLFWbool createNativeWindow(_GLFWwindow* window,
         GLFWvidmode mode;
         int xpos, ypos;
 
-        _glfwPlatformGetVideoMode(window->monitor, &mode);
-        _glfwPlatformGetMonitorPos(window->monitor, &xpos, &ypos);
+        _glfwGetVideoModeCocoa(window->monitor, &mode);
+        _glfwGetMonitorPosCocoa(window->monitor, &xpos, &ypos);
 
         contentRect = NSMakeRect(xpos, ypos, mode.width, mode.height);
     }
@@ -872,8 +872,8 @@ static GLFWbool createNativeWindow(_GLFWwindow* window,
         [window->ns.object setTabbingMode:NSWindowTabbingModeDisallowed];
 #endif
 
-    _glfwPlatformGetWindowSize(window, &window->ns.width, &window->ns.height);
-    _glfwPlatformGetFramebufferSize(window, &window->ns.fbWidth, &window->ns.fbHeight);
+    _glfwGetWindowSizeCocoa(window, &window->ns.width, &window->ns.height);
+    _glfwGetFramebufferSizeCocoa(window, &window->ns.fbWidth, &window->ns.fbHeight);
 
     return GLFW_TRUE;
 }
@@ -895,10 +895,10 @@ float _glfwTransformYCocoa(float y)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformCreateWindow(_GLFWwindow* window,
-                              const _GLFWwndconfig* wndconfig,
-                              const _GLFWctxconfig* ctxconfig,
-                              const _GLFWfbconfig* fbconfig)
+int _glfwCreateWindowCocoa(_GLFWwindow* window,
+                           const _GLFWwndconfig* wndconfig,
+                           const _GLFWctxconfig* ctxconfig,
+                           const _GLFWfbconfig* fbconfig)
 {
     @autoreleasepool {
 
@@ -937,8 +937,8 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
 
     if (window->monitor)
     {
-        _glfwPlatformShowWindow(window);
-        _glfwPlatformFocusWindow(window);
+        _glfwShowWindowCocoa(window);
+        _glfwFocusWindowCocoa(window);
         acquireMonitor(window);
     }
 
@@ -947,7 +947,7 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
     } // autoreleasepool
 }
 
-void _glfwPlatformDestroyWindow(_GLFWwindow* window)
+void _glfwDestroyWindowCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
 
@@ -973,12 +973,12 @@ void _glfwPlatformDestroyWindow(_GLFWwindow* window)
     window->ns.object = nil;
 
     // HACK: Allow Cocoa to catch up before returning
-    _glfwPlatformPollEvents();
+    _glfwPollEventsCocoa();
 
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
+void _glfwSetWindowTitleCocoa(_GLFWwindow* window, const char* title)
 {
     @autoreleasepool {
     NSString* string = @(title);
@@ -989,14 +989,14 @@ void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
-                                int count, const GLFWimage* images)
+void _glfwSetWindowIconCocoa(_GLFWwindow* window,
+                             int count, const GLFWimage* images)
 {
     _glfwInputError(GLFW_FEATURE_UNAVAILABLE,
                     "Cocoa: Regular windows do not have icons on macOS");
 }
 
-void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
+void _glfwGetWindowPosCocoa(_GLFWwindow* window, int* xpos, int* ypos)
 {
     @autoreleasepool {
 
@@ -1011,7 +1011,7 @@ void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowPos(_GLFWwindow* window, int x, int y)
+void _glfwSetWindowPosCocoa(_GLFWwindow* window, int x, int y)
 {
     @autoreleasepool {
 
@@ -1023,7 +1023,7 @@ void _glfwPlatformSetWindowPos(_GLFWwindow* window, int x, int y)
     } // autoreleasepool
 }
 
-void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetWindowSizeCocoa(_GLFWwindow* window, int* width, int* height)
 {
     @autoreleasepool {
 
@@ -1037,7 +1037,7 @@ void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
+void _glfwSetWindowSizeCocoa(_GLFWwindow* window, int width, int height)
 {
     @autoreleasepool {
 
@@ -1059,9 +1059,9 @@ void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
-                                      int minwidth, int minheight,
-                                      int maxwidth, int maxheight)
+void _glfwSetWindowSizeLimitsCocoa(_GLFWwindow* window,
+                                   int minwidth, int minheight,
+                                   int maxwidth, int maxheight)
 {
     @autoreleasepool {
 
@@ -1078,7 +1078,7 @@ void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int numer, int denom)
+void _glfwSetWindowAspectRatioCocoa(_GLFWwindow* window, int numer, int denom)
 {
     @autoreleasepool {
     if (numer == GLFW_DONT_CARE || denom == GLFW_DONT_CARE)
@@ -1088,7 +1088,7 @@ void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int numer, int denom
     } // autoreleasepool
 }
 
-void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetFramebufferSizeCocoa(_GLFWwindow* window, int* width, int* height)
 {
     @autoreleasepool {
 
@@ -1103,9 +1103,9 @@ void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* heigh
     } // autoreleasepool
 }
 
-void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
-                                     int* left, int* top,
-                                     int* right, int* bottom)
+void _glfwGetWindowFrameSizeCocoa(_GLFWwindow* window,
+                                  int* left, int* top,
+                                  int* right, int* bottom)
 {
     @autoreleasepool {
 
@@ -1126,8 +1126,8 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
     } // autoreleasepool
 }
 
-void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
-                                        float* xscale, float* yscale)
+void _glfwGetWindowContentScaleCocoa(_GLFWwindow* window,
+                                     float* xscale, float* yscale)
 {
     @autoreleasepool {
 
@@ -1142,14 +1142,14 @@ void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
     } // autoreleasepool
 }
 
-void _glfwPlatformIconifyWindow(_GLFWwindow* window)
+void _glfwIconifyWindowCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     [window->ns.object miniaturize:nil];
     } // autoreleasepool
 }
 
-void _glfwPlatformRestoreWindow(_GLFWwindow* window)
+void _glfwRestoreWindowCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     if ([window->ns.object isMiniaturized])
@@ -1159,7 +1159,7 @@ void _glfwPlatformRestoreWindow(_GLFWwindow* window)
     } // autoreleasepool
 }
 
-void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
+void _glfwMaximizeWindowCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     if (![window->ns.object isZoomed])
@@ -1167,28 +1167,28 @@ void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
     } // autoreleasepool
 }
 
-void _glfwPlatformShowWindow(_GLFWwindow* window)
+void _glfwShowWindowCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     [window->ns.object orderFront:nil];
     } // autoreleasepool
 }
 
-void _glfwPlatformHideWindow(_GLFWwindow* window)
+void _glfwHideWindowCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     [window->ns.object orderOut:nil];
     } // autoreleasepool
 }
 
-void _glfwPlatformRequestWindowAttention(_GLFWwindow* window)
+void _glfwRequestWindowAttentionCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     [NSApp requestUserAttention:NSInformationalRequest];
     } // autoreleasepool
 }
 
-void _glfwPlatformFocusWindow(_GLFWwindow* window)
+void _glfwFocusWindowCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     // Make us the active application
@@ -1200,11 +1200,11 @@ void _glfwPlatformFocusWindow(_GLFWwindow* window)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
-                                   _GLFWmonitor* monitor,
-                                   int xpos, int ypos,
-                                   int width, int height,
-                                   int refreshRate)
+void _glfwSetWindowMonitorCocoa(_GLFWwindow* window,
+                                _GLFWmonitor* monitor,
+                                int xpos, int ypos,
+                                int width, int height,
+                                int refreshRate)
 {
     @autoreleasepool {
 
@@ -1236,7 +1236,7 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
 
     // HACK: Allow the state cached in Cocoa to catch up to reality
     // TODO: Solve this in a less terrible way
-    _glfwPlatformPollEvents();
+    _glfwPollEventsCocoa();
 
     const NSUInteger styleMask = getStyleMask(window);
     [window->ns.object setStyleMask:styleMask];
@@ -1293,35 +1293,35 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
     } // autoreleasepool
 }
 
-int _glfwPlatformWindowFocused(_GLFWwindow* window)
+int _glfwWindowFocusedCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     return [window->ns.object isKeyWindow];
     } // autoreleasepool
 }
 
-int _glfwPlatformWindowIconified(_GLFWwindow* window)
+int _glfwWindowIconifiedCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     return [window->ns.object isMiniaturized];
     } // autoreleasepool
 }
 
-int _glfwPlatformWindowVisible(_GLFWwindow* window)
+int _glfwWindowVisibleCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     return [window->ns.object isVisible];
     } // autoreleasepool
 }
 
-int _glfwPlatformWindowMaximized(_GLFWwindow* window)
+int _glfwWindowMaximizedCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     return [window->ns.object isZoomed];
     } // autoreleasepool
 }
 
-int _glfwPlatformWindowHovered(_GLFWwindow* window)
+int _glfwWindowHoveredCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
 
@@ -1339,21 +1339,21 @@ int _glfwPlatformWindowHovered(_GLFWwindow* window)
     } // autoreleasepool
 }
 
-int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
+int _glfwFramebufferTransparentCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     return ![window->ns.object isOpaque] && ![window->ns.view isOpaque];
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowResizable(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowResizableCocoa(_GLFWwindow* window, GLFWbool enabled)
 {
     @autoreleasepool {
     [window->ns.object setStyleMask:getStyleMask(window)];
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowDecoratedCocoa(_GLFWwindow* window, GLFWbool enabled)
 {
     @autoreleasepool {
     [window->ns.object setStyleMask:getStyleMask(window)];
@@ -1361,7 +1361,7 @@ void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowFloatingCocoa(_GLFWwindow* window, GLFWbool enabled)
 {
     @autoreleasepool {
     if (enabled)
@@ -1371,39 +1371,39 @@ void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowMousePassthroughCocoa(_GLFWwindow* window, GLFWbool enabled)
 {
     @autoreleasepool {
     [window->ns.object setIgnoresMouseEvents:enabled];
     }
 }
 
-float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
+float _glfwGetWindowOpacityCocoa(_GLFWwindow* window)
 {
     @autoreleasepool {
     return (float) [window->ns.object alphaValue];
     } // autoreleasepool
 }
 
-void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
+void _glfwSetWindowOpacityCocoa(_GLFWwindow* window, float opacity)
 {
     @autoreleasepool {
     [window->ns.object setAlphaValue:opacity];
     } // autoreleasepool
 }
 
-void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
+void _glfwSetRawMouseMotionCocoa(_GLFWwindow *window, GLFWbool enabled)
 {
     _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
                     "Cocoa: Raw mouse motion not yet implemented");
 }
 
-GLFWbool _glfwPlatformRawMouseMotionSupported(void)
+GLFWbool _glfwRawMouseMotionSupportedCocoa(void)
 {
     return GLFW_FALSE;
 }
 
-void _glfwPlatformPollEvents(void)
+void _glfwPollEventsCocoa(void)
 {
     @autoreleasepool {
 
@@ -1422,7 +1422,7 @@ void _glfwPlatformPollEvents(void)
     } // autoreleasepool
 }
 
-void _glfwPlatformWaitEvents(void)
+void _glfwWaitEventsCocoa(void)
 {
     @autoreleasepool {
 
@@ -1435,12 +1435,12 @@ void _glfwPlatformWaitEvents(void)
                                           dequeue:YES];
     [NSApp sendEvent:event];
 
-    _glfwPlatformPollEvents();
+    _glfwPollEventsCocoa();
 
     } // autoreleasepool
 }
 
-void _glfwPlatformWaitEventsTimeout(double timeout)
+void _glfwWaitEventsTimeoutCocoa(double timeout)
 {
     @autoreleasepool {
 
@@ -1452,12 +1452,12 @@ void _glfwPlatformWaitEventsTimeout(double timeout)
     if (event)
         [NSApp sendEvent:event];
 
-    _glfwPlatformPollEvents();
+    _glfwPollEventsCocoa();
 
     } // autoreleasepool
 }
 
-void _glfwPlatformPostEmptyEvent(void)
+void _glfwPostEmptyEventCocoa(void)
 {
     @autoreleasepool {
 
@@ -1475,7 +1475,7 @@ void _glfwPlatformPostEmptyEvent(void)
     } // autoreleasepool
 }
 
-void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
+void _glfwGetCursorPosCocoa(_GLFWwindow* window, double* xpos, double* ypos)
 {
     @autoreleasepool {
 
@@ -1491,7 +1491,7 @@ void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetCursorPos(_GLFWwindow* window, double x, double y)
+void _glfwSetCursorPosCocoa(_GLFWwindow* window, double x, double y)
 {
     @autoreleasepool {
 
@@ -1527,15 +1527,15 @@ void _glfwPlatformSetCursorPos(_GLFWwindow* window, double x, double y)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
+void _glfwSetCursorModeCocoa(_GLFWwindow* window, int mode)
 {
     @autoreleasepool {
-    if (_glfwPlatformWindowFocused(window))
+    if (_glfwWindowFocusedCocoa(window))
         updateCursorMode(window);
     } // autoreleasepool
 }
 
-const char* _glfwPlatformGetScancodeName(int scancode)
+const char* _glfwGetScancodeNameCocoa(int scancode)
 {
     @autoreleasepool {
 
@@ -1584,14 +1584,14 @@ const char* _glfwPlatformGetScancodeName(int scancode)
     } // autoreleasepool
 }
 
-int _glfwPlatformGetKeyScancode(int key)
+int _glfwGetKeyScancodeCocoa(int key)
 {
     return _glfw.ns.scancodes[key];
 }
 
-int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
-                              const GLFWimage* image,
-                              int xhot, int yhot)
+int _glfwCreateCursorCocoa(_GLFWcursor* cursor,
+                           const GLFWimage* image,
+                           int xhot, int yhot)
 {
     @autoreleasepool {
 
@@ -1633,7 +1633,7 @@ int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
     } // autoreleasepool
 }
 
-int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
+int _glfwCreateStandardCursorCocoa(_GLFWcursor* cursor, int shape)
 {
     @autoreleasepool {
 
@@ -1707,7 +1707,7 @@ int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
     } // autoreleasepool
 }
 
-void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
+void _glfwDestroyCursorCocoa(_GLFWcursor* cursor)
 {
     @autoreleasepool {
     if (cursor->ns.object)
@@ -1715,7 +1715,7 @@ void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
+void _glfwSetCursorCocoa(_GLFWwindow* window, _GLFWcursor* cursor)
 {
     @autoreleasepool {
     if (cursorInContentArea(window))
@@ -1723,7 +1723,7 @@ void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
     } // autoreleasepool
 }
 
-void _glfwPlatformSetClipboardString(const char* string)
+void _glfwSetClipboardStringCocoa(const char* string)
 {
     @autoreleasepool {
     NSPasteboard* pasteboard = [NSPasteboard generalPasteboard];
@@ -1732,7 +1732,7 @@ void _glfwPlatformSetClipboardString(const char* string)
     } // autoreleasepool
 }
 
-const char* _glfwPlatformGetClipboardString(void)
+const char* _glfwGetClipboardStringCocoa(void)
 {
     @autoreleasepool {
 
@@ -1761,7 +1761,7 @@ const char* _glfwPlatformGetClipboardString(void)
     } // autoreleasepool
 }
 
-EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
+EGLenum _glfwGetEGLPlatformCocoa(EGLint** attribs)
 {
     if (_glfw.egl.ANGLE_platform_angle)
     {
@@ -1792,17 +1792,17 @@ EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
     return 0;
 }
 
-EGLNativeDisplayType _glfwPlatformGetEGLNativeDisplay(void)
+EGLNativeDisplayType _glfwGetEGLNativeDisplayCocoa(void)
 {
     return EGL_DEFAULT_DISPLAY;
 }
 
-EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window)
+EGLNativeWindowType _glfwGetEGLNativeWindowCocoa(_GLFWwindow* window)
 {
     return window->ns.layer;
 }
 
-void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
+void _glfwGetRequiredInstanceExtensionsCocoa(char** extensions)
 {
     if (_glfw.vk.KHR_surface && _glfw.vk.EXT_metal_surface)
     {
@@ -1816,17 +1816,17 @@ void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
     }
 }
 
-int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
-                                                      VkPhysicalDevice device,
-                                                      uint32_t queuefamily)
+int _glfwGetPhysicalDevicePresentationSupportCocoa(VkInstance instance,
+                                                   VkPhysicalDevice device,
+                                                   uint32_t queuefamily)
 {
     return GLFW_TRUE;
 }
 
-VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
-                                          _GLFWwindow* window,
-                                          const VkAllocationCallbacks* allocator,
-                                          VkSurfaceKHR* surface)
+VkResult _glfwCreateWindowSurfaceCocoa(VkInstance instance,
+                                       _GLFWwindow* window,
+                                       const VkAllocationCallbacks* allocator,
+                                       VkSurfaceKHR* surface)
 {
     @autoreleasepool {
 
@@ -1923,6 +1923,14 @@ GLFWAPI id glfwGetCocoaWindow(GLFWwindow* handle)
 {
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(nil);
+
+    if (_glfw.platform.platformID != GLFW_PLATFORM_COCOA)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                        "Cocoa: Platform not initialized");
+        return NULL;
+    }
+
     return window->ns.object;
 }
 
diff --git a/src/egl_context.c b/src/egl_context.c
index 8d4df682..593a153c 100644
--- a/src/egl_context.c
+++ b/src/egl_context.c
@@ -123,6 +123,7 @@ static GLFWbool chooseEGLConfig(const _GLFWctxconfig* ctxconfig,
             continue;
 
 #if defined(_GLFW_X11)
+        if (_glfw.platform.platformID == GLFW_PLATFORM_X11)
         {
             XVisualInfo vi = {0};
 
@@ -267,11 +268,10 @@ static GLFWglproc getProcAddressEGL(const char* procname)
 
 static void destroyContextEGL(_GLFWwindow* window)
 {
-#if defined(_GLFW_X11)
     // NOTE: Do not unload libGL.so.1 while the X11 display is still open,
     //       as it will make XCloseDisplay segfault
-    if (window->context.client != GLFW_OPENGL_API)
-#endif // _GLFW_X11
+    if (_glfw.platform.platformID != GLFW_PLATFORM_X11 ||
+        window->context.client != GLFW_OPENGL_API)
     {
         if (window->context.egl.client)
         {
@@ -429,16 +429,16 @@ GLFWbool _glfwInitEGL(void)
             eglGetProcAddress("eglCreatePlatformWindowSurfaceEXT");
     }
 
-    _glfw.egl.platform = _glfwPlatformGetEGLPlatform(&attribs);
+    _glfw.egl.platform = _glfw.platform.getEGLPlatform(&attribs);
     if (_glfw.egl.platform)
     {
         _glfw.egl.display =
             eglGetPlatformDisplayEXT(_glfw.egl.platform,
-                                     _glfwPlatformGetEGLNativeDisplay(),
+                                     _glfw.platform.getEGLNativeDisplay(),
                                      attribs);
     }
     else
-        _glfw.egl.display = eglGetDisplay(_glfwPlatformGetEGLNativeDisplay());
+        _glfw.egl.display = eglGetDisplay(_glfw.platform.getEGLNativeDisplay());
 
     _glfw_free(attribs);
 
@@ -648,7 +648,7 @@ GLFWbool _glfwCreateContextEGL(_GLFWwindow* window,
 
     setAttrib(EGL_NONE, EGL_NONE);
 
-    native = _glfwPlatformGetEGLNativeWindow(window);
+    native = _glfw.platform.getEGLNativeWindow(window);
     // HACK: ANGLE does not implement eglCreatePlatformWindowSurfaceEXT
     //       despite reporting EGL_EXT_platform_base
     if (_glfw.egl.platform && _glfw.egl.platform != EGL_PLATFORM_ANGLE_ANGLE)
diff --git a/src/glx_context.c b/src/glx_context.c
index 02c1c5e4..4a92353c 100644
--- a/src/glx_context.c
+++ b/src/glx_context.c
@@ -425,7 +425,7 @@ GLFWbool _glfwInitGLX(void)
 void _glfwTerminateGLX(void)
 {
     // NOTE: This function must not call any X11 functions, as it is called
-    //       after XCloseDisplay (see _glfwPlatformTerminate for details)
+    //       after XCloseDisplay (see _glfwTerminateX11 for details)
 
     if (_glfw.glx.handle)
     {
@@ -674,6 +674,12 @@ GLFWAPI GLXContext glfwGetGLXContext(GLFWwindow* handle)
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
 
+    if (_glfw.platform.platformID != GLFW_PLATFORM_X11)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "GLX: Platform not initialized");
+        return NULL;
+    }
+
     if (window->context.client != GLFW_NATIVE_CONTEXT_API)
     {
         _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);
@@ -688,6 +694,12 @@ GLFWAPI GLXWindow glfwGetGLXWindow(GLFWwindow* handle)
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(None);
 
+    if (_glfw.platform.platformID != GLFW_PLATFORM_X11)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "GLX: Platform not initialized");
+        return None;
+    }
+
     if (window->context.client != GLFW_NATIVE_CONTEXT_API)
     {
         _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);
diff --git a/src/init.c b/src/init.c
index f74b497d..cdb7ae41 100644
--- a/src/init.c
+++ b/src/init.c
@@ -54,6 +54,7 @@ static _GLFWinitconfig _glfwInitHints =
 {
     GLFW_TRUE,      // hat buttons
     GLFW_ANGLE_PLATFORM_TYPE_NONE, // ANGLE backend
+    GLFW_ANY_PLATFORM, // preferred platform
     {
         GLFW_TRUE,  // macOS menu bar
         GLFW_TRUE   // macOS bundle chdir
@@ -102,7 +103,7 @@ static void terminate(void)
     {
         _GLFWmonitor* monitor = _glfw.monitors[i];
         if (monitor->originalRamp.size)
-            _glfwPlatformSetGammaRamp(monitor, &monitor->originalRamp);
+            _glfw.platform.setGammaRamp(monitor, &monitor->originalRamp);
         _glfwFreeMonitor(monitor);
     }
 
@@ -115,8 +116,8 @@ static void terminate(void)
     _glfw.mappingCount = 0;
 
     _glfwTerminateVulkan();
-    _glfwPlatformTerminateJoysticks();
-    _glfwPlatformTerminate();
+    _glfw.platform.terminateJoysticks();
+    _glfw.platform.terminate();
 
     _glfw.initialized = GLFW_FALSE;
 
@@ -274,6 +275,8 @@ void _glfwInputError(int code, const char* format, ...)
             strcpy(description, "The requested feature cannot be implemented for this platform");
         else if (code == GLFW_FEATURE_UNIMPLEMENTED)
             strcpy(description, "The requested feature has not yet been implemented for this platform");
+        else if (code == GLFW_PLATFORM_UNAVAILABLE)
+            strcpy(description, "The requested platform is unavailable");
         else
             strcpy(description, "ERROR: UNKNOWN GLFW ERROR");
     }
@@ -322,7 +325,10 @@ GLFWAPI int glfwInit(void)
         _glfw.allocator.deallocate = defaultDeallocate;
     }
 
-    if (!_glfwPlatformInit())
+    if (!_glfwSelectPlatform(_glfw.hints.init.platformID, &_glfw.platform))
+        return GLFW_FALSE;
+
+    if (!_glfw.platform.init())
     {
         terminate();
         return GLFW_FALSE;
@@ -367,6 +373,9 @@ GLFWAPI void glfwInitHint(int hint, int value)
         case GLFW_ANGLE_PLATFORM_TYPE:
             _glfwInitHints.angleType = value;
             return;
+        case GLFW_PLATFORM:
+            _glfwInitHints.platformID = value;
+            return;
         case GLFW_COCOA_CHDIR_RESOURCES:
             _glfwInitHints.ns.chdir = value;
             return;
@@ -405,11 +414,6 @@ GLFWAPI void glfwGetVersion(int* major, int* minor, int* rev)
         *rev = GLFW_VERSION_REVISION;
 }
 
-GLFWAPI const char* glfwGetVersionString(void)
-{
-    return _glfwPlatformGetVersionString();
-}
-
 GLFWAPI int glfwGetError(const char** description)
 {
     _GLFWerror* error;
diff --git a/src/input.c b/src/input.c
index 920db8de..f2604c86 100644
--- a/src/input.c
+++ b/src/input.c
@@ -50,9 +50,9 @@ static GLFWbool initJoysticks(void)
 {
     if (!_glfw.joysticksInitialized)
     {
-        if (!_glfwPlatformInitJoysticks())
+        if (!_glfw.platform.initJoysticks())
         {
-            _glfwPlatformTerminateJoysticks();
+            _glfw.platform.terminateJoysticks();
             return GLFW_FALSE;
         }
     }
@@ -234,7 +234,7 @@ static GLFWbool parseMapping(_GLFWmapping* mapping, const char* string)
             }
             else
             {
-                const char* name = _glfwPlatformGetMappingName();
+                const char* name = _glfw.platform.getMappingName();
                 length = strlen(name);
                 if (strncmp(c, name, length) != 0)
                     return GLFW_FALSE;
@@ -253,7 +253,7 @@ static GLFWbool parseMapping(_GLFWmapping* mapping, const char* string)
             mapping->guid[i] += 'a' - 'A';
     }
 
-    _glfwPlatformUpdateGamepadGUID(mapping->guid);
+    _glfw.platform.updateGamepadGUID(mapping->guid);
     return GLFW_TRUE;
 }
 
@@ -481,8 +481,8 @@ void _glfwCenterCursorInContentArea(_GLFWwindow* window)
 {
     int width, height;
 
-    _glfwPlatformGetWindowSize(window, &width, &height);
-    _glfwPlatformSetCursorPos(window, width / 2.0, height / 2.0);
+    _glfw.platform.getWindowSize(window, &width, &height);
+    _glfw.platform.setCursorPos(window, width / 2.0, height / 2.0);
 }
 
 
@@ -539,10 +539,10 @@ GLFWAPI void glfwSetInputMode(GLFWwindow* handle, int mode, int value)
 
         window->cursorMode = value;
 
-        _glfwPlatformGetCursorPos(window,
-                                  &window->virtualCursorPosX,
-                                  &window->virtualCursorPosY);
-        _glfwPlatformSetCursorMode(window, value);
+        _glfw.platform.getCursorPos(window,
+                                    &window->virtualCursorPosX,
+                                    &window->virtualCursorPosY);
+        _glfw.platform.setCursorMode(window, value);
     }
     else if (mode == GLFW_STICKY_KEYS)
     {
@@ -590,7 +590,7 @@ GLFWAPI void glfwSetInputMode(GLFWwindow* handle, int mode, int value)
     }
     else if (mode == GLFW_RAW_MOUSE_MOTION)
     {
-        if (!_glfwPlatformRawMouseMotionSupported())
+        if (!_glfw.platform.rawMouseMotionSupported())
         {
             _glfwInputError(GLFW_PLATFORM_ERROR,
                             "Raw mouse motion is not supported on this system");
@@ -602,7 +602,7 @@ GLFWAPI void glfwSetInputMode(GLFWwindow* handle, int mode, int value)
             return;
 
         window->rawMouseMotion = value;
-        _glfwPlatformSetRawMouseMotion(window, value);
+        _glfw.platform.setRawMouseMotion(window, value);
     }
     else
         _glfwInputError(GLFW_INVALID_ENUM, "Invalid input mode 0x%08X", mode);
@@ -611,7 +611,7 @@ GLFWAPI void glfwSetInputMode(GLFWwindow* handle, int mode, int value)
 GLFWAPI int glfwRawMouseMotionSupported(void)
 {
     _GLFW_REQUIRE_INIT_OR_RETURN(GLFW_FALSE);
-    return _glfwPlatformRawMouseMotionSupported();
+    return _glfw.platform.rawMouseMotionSupported();
 }
 
 GLFWAPI const char* glfwGetKeyName(int key, int scancode)
@@ -627,10 +627,10 @@ GLFWAPI const char* glfwGetKeyName(int key, int scancode)
             return NULL;
         }
 
-        scancode = _glfwPlatformGetKeyScancode(key);
+        scancode = _glfw.platform.getKeyScancode(key);
     }
 
-    return _glfwPlatformGetScancodeName(scancode);
+    return _glfw.platform.getScancodeName(scancode);
 }
 
 GLFWAPI int glfwGetKeyScancode(int key)
@@ -643,7 +643,7 @@ GLFWAPI int glfwGetKeyScancode(int key)
         return GLFW_RELEASE;
     }
 
-    return _glfwPlatformGetKeyScancode(key);
+    return _glfw.platform.getKeyScancode(key);
 }
 
 GLFWAPI int glfwGetKey(GLFWwindow* handle, int key)
@@ -712,7 +712,7 @@ GLFWAPI void glfwGetCursorPos(GLFWwindow* handle, double* xpos, double* ypos)
             *ypos = window->virtualCursorPosY;
     }
     else
-        _glfwPlatformGetCursorPos(window, xpos, ypos);
+        _glfw.platform.getCursorPos(window, xpos, ypos);
 }
 
 GLFWAPI void glfwSetCursorPos(GLFWwindow* handle, double xpos, double ypos)
@@ -731,7 +731,7 @@ GLFWAPI void glfwSetCursorPos(GLFWwindow* handle, double xpos, double ypos)
         return;
     }
 
-    if (!_glfwPlatformWindowFocused(window))
+    if (!_glfw.platform.windowFocused(window))
         return;
 
     if (window->cursorMode == GLFW_CURSOR_DISABLED)
@@ -743,7 +743,7 @@ GLFWAPI void glfwSetCursorPos(GLFWwindow* handle, double xpos, double ypos)
     else
     {
         // Update system cursor position
-        _glfwPlatformSetCursorPos(window, xpos, ypos);
+        _glfw.platform.setCursorPos(window, xpos, ypos);
     }
 }
 
@@ -759,7 +759,7 @@ GLFWAPI GLFWcursor* glfwCreateCursor(const GLFWimage* image, int xhot, int yhot)
     cursor->next = _glfw.cursorListHead;
     _glfw.cursorListHead = cursor;
 
-    if (!_glfwPlatformCreateCursor(cursor, image, xhot, yhot))
+    if (!_glfw.platform.createCursor(cursor, image, xhot, yhot))
     {
         glfwDestroyCursor((GLFWcursor*) cursor);
         return NULL;
@@ -793,7 +793,7 @@ GLFWAPI GLFWcursor* glfwCreateStandardCursor(int shape)
     cursor->next = _glfw.cursorListHead;
     _glfw.cursorListHead = cursor;
 
-    if (!_glfwPlatformCreateStandardCursor(cursor, shape))
+    if (!_glfw.platform.createStandardCursor(cursor, shape))
     {
         glfwDestroyCursor((GLFWcursor*) cursor);
         return NULL;
@@ -822,7 +822,7 @@ GLFWAPI void glfwDestroyCursor(GLFWcursor* handle)
         }
     }
 
-    _glfwPlatformDestroyCursor(cursor);
+    _glfw.platform.destroyCursor(cursor);
 
     // Unlink cursor from global linked list
     {
@@ -847,7 +847,7 @@ GLFWAPI void glfwSetCursor(GLFWwindow* windowHandle, GLFWcursor* cursorHandle)
 
     window->cursor = cursor;
 
-    _glfwPlatformSetCursor(window, cursor);
+    _glfw.platform.setCursor(window, cursor);
 }
 
 GLFWAPI GLFWkeyfun glfwSetKeyCallback(GLFWwindow* handle, GLFWkeyfun cbfun)
@@ -956,7 +956,7 @@ GLFWAPI int glfwJoystickPresent(int jid)
     if (!js->present)
         return GLFW_FALSE;
 
-    return _glfwPlatformPollJoystick(js, _GLFW_POLL_PRESENCE);
+    return _glfw.platform.pollJoystick(js, _GLFW_POLL_PRESENCE);
 }
 
 GLFWAPI const float* glfwGetJoystickAxes(int jid, int* count)
@@ -984,7 +984,7 @@ GLFWAPI const float* glfwGetJoystickAxes(int jid, int* count)
     if (!js->present)
         return NULL;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_AXES))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_AXES))
         return NULL;
 
     *count = js->axisCount;
@@ -1016,7 +1016,7 @@ GLFWAPI const unsigned char* glfwGetJoystickButtons(int jid, int* count)
     if (!js->present)
         return NULL;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_BUTTONS))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_BUTTONS))
         return NULL;
 
     if (_glfw.hints.init.hatButtons)
@@ -1052,7 +1052,7 @@ GLFWAPI const unsigned char* glfwGetJoystickHats(int jid, int* count)
     if (!js->present)
         return NULL;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_BUTTONS))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_BUTTONS))
         return NULL;
 
     *count = js->hatCount;
@@ -1081,7 +1081,7 @@ GLFWAPI const char* glfwGetJoystickName(int jid)
     if (!js->present)
         return NULL;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_PRESENCE))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_PRESENCE))
         return NULL;
 
     return js->name;
@@ -1109,7 +1109,7 @@ GLFWAPI const char* glfwGetJoystickGUID(int jid)
     if (!js->present)
         return NULL;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_PRESENCE))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_PRESENCE))
         return NULL;
 
     return js->guid;
@@ -1240,7 +1240,7 @@ GLFWAPI int glfwJoystickIsGamepad(int jid)
     if (!js->present)
         return GLFW_FALSE;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_PRESENCE))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_PRESENCE))
         return GLFW_FALSE;
 
     return js->mapping != NULL;
@@ -1268,7 +1268,7 @@ GLFWAPI const char* glfwGetGamepadName(int jid)
     if (!js->present)
         return NULL;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_PRESENCE))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_PRESENCE))
         return NULL;
 
     if (!js->mapping)
@@ -1303,7 +1303,7 @@ GLFWAPI int glfwGetGamepadState(int jid, GLFWgamepadstate* state)
     if (!js->present)
         return GLFW_FALSE;
 
-    if (!_glfwPlatformPollJoystick(js, _GLFW_POLL_ALL))
+    if (!_glfw.platform.pollJoystick(js, _GLFW_POLL_ALL))
         return GLFW_FALSE;
 
     if (!js->mapping)
@@ -1368,13 +1368,13 @@ GLFWAPI void glfwSetClipboardString(GLFWwindow* handle, const char* string)
     assert(string != NULL);
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformSetClipboardString(string);
+    _glfw.platform.setClipboardString(string);
 }
 
 GLFWAPI const char* glfwGetClipboardString(GLFWwindow* handle)
 {
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
-    return _glfwPlatformGetClipboardString();
+    return _glfw.platform.getClipboardString();
 }
 
 GLFWAPI double glfwGetTime(void)
diff --git a/src/internal.h b/src/internal.h
index af882be5..45ae45ab 100644
--- a/src/internal.h
+++ b/src/internal.h
@@ -68,6 +68,7 @@ typedef struct _GLFWctxconfig   _GLFWctxconfig;
 typedef struct _GLFWfbconfig    _GLFWfbconfig;
 typedef struct _GLFWcontext     _GLFWcontext;
 typedef struct _GLFWwindow      _GLFWwindow;
+typedef struct _GLFWplatform    _GLFWplatform;
 typedef struct _GLFWlibrary     _GLFWlibrary;
 typedef struct _GLFWmonitor     _GLFWmonitor;
 typedef struct _GLFWcursor      _GLFWcursor;
@@ -332,19 +333,7 @@ typedef void (APIENTRY * PFN_vkVoidFunction)(void);
   #define vkGetInstanceProcAddr _glfw.vk.GetInstanceProcAddr
 #endif
 
-#if defined(_GLFW_COCOA)
- #include "cocoa_platform.h"
-#elif defined(_GLFW_WIN32)
- #include "win32_platform.h"
-#elif defined(_GLFW_X11)
- #include "x11_platform.h"
-#elif defined(_GLFW_WAYLAND)
- #include "wl_platform.h"
-#elif defined(_GLFW_OSMESA)
- #include "null_platform.h"
-#else
- #error "No supported window creation API selected"
-#endif
+#include "platform.h"
 
 // Constructs a version number string from the public header macros
 #define _GLFW_CONCAT_VERSION(m, n, r) #m "." #n "." #r
@@ -393,6 +382,7 @@ struct _GLFWinitconfig
 {
     GLFWbool      hatButtons;
     int           angleType;
+    int           platformID;
     struct {
         GLFWbool  menubar;
         GLFWbool  chdir;
@@ -527,8 +517,8 @@ struct _GLFWcontext
         void*           buffer;
     } osmesa;
 
-    // This is defined in the context API's context.h
-    _GLFW_PLATFORM_CONTEXT_STATE;
+    // This is defined in platform.h
+    GLFW_PLATFORM_CONTEXT_STATE
 };
 
 // Window and context structure
@@ -587,8 +577,8 @@ struct _GLFWwindow
         GLFWdropfun               drop;
     } callbacks;
 
-    // This is defined in the window API's platform.h
-    _GLFW_PLATFORM_WINDOW_STATE;
+    // This is defined in platform.h
+    GLFW_PLATFORM_WINDOW_STATE
 };
 
 // Monitor structure
@@ -611,8 +601,8 @@ struct _GLFWmonitor
     GLFWgammaramp   originalRamp;
     GLFWgammaramp   currentRamp;
 
-    // This is defined in the window API's platform.h
-    _GLFW_PLATFORM_MONITOR_STATE;
+    // This is defined in platform.h
+    GLFW_PLATFORM_MONITOR_STATE
 };
 
 // Cursor structure
@@ -620,9 +610,8 @@ struct _GLFWmonitor
 struct _GLFWcursor
 {
     _GLFWcursor*    next;
-
-    // This is defined in the window API's platform.h
-    _GLFW_PLATFORM_CURSOR_STATE;
+    // This is defined in platform.h
+    GLFW_PLATFORM_CURSOR_STATE
 };
 
 // Gamepad mapping element structure
@@ -661,24 +650,108 @@ struct _GLFWjoystick
     char            guid[33];
     _GLFWmapping*   mapping;
 
-    // This is defined in the joystick API's joystick.h
-    _GLFW_PLATFORM_JOYSTICK_STATE;
+    // This is defined in platform.h
+    GLFW_PLATFORM_JOYSTICK_STATE
 };
 
 // Thread local storage structure
 //
 struct _GLFWtls
 {
-    // This is defined in the platform's thread.h
-    _GLFW_PLATFORM_TLS_STATE;
+    // This is defined in platform.h
+    GLFW_PLATFORM_TLS_STATE
 };
 
 // Mutex structure
 //
 struct _GLFWmutex
 {
-    // This is defined in the platform's thread.h
-    _GLFW_PLATFORM_MUTEX_STATE;
+    // This is defined in platform.h
+    GLFW_PLATFORM_MUTEX_STATE
+};
+
+// Platform API structure
+//
+struct _GLFWplatform
+{
+    int platformID;
+    // init
+    GLFWbool (*init)(void);
+    void (*terminate)(void);
+    // input
+    void (*getCursorPos)(_GLFWwindow*,double*,double*);
+    void (*setCursorPos)(_GLFWwindow*,double,double);
+    void (*setCursorMode)(_GLFWwindow*,int);
+    void (*setRawMouseMotion)(_GLFWwindow*,GLFWbool);
+    GLFWbool (*rawMouseMotionSupported)(void);
+    int (*createCursor)(_GLFWcursor*,const GLFWimage*,int,int);
+    int (*createStandardCursor)(_GLFWcursor*,int);
+    void (*destroyCursor)(_GLFWcursor*);
+    void (*setCursor)(_GLFWwindow*,_GLFWcursor*);
+    const char* (*getScancodeName)(int);
+    int (*getKeyScancode)(int);
+    void (*setClipboardString)(const char*);
+    const char* (*getClipboardString)(void);
+    GLFWbool (*initJoysticks)(void);
+    void (*terminateJoysticks)(void);
+    int (*pollJoystick)(_GLFWjoystick*,int);
+    const char* (*getMappingName)(void);
+    void (*updateGamepadGUID)(char*);
+    // monitor
+    void (*freeMonitor)(_GLFWmonitor*);
+    void (*getMonitorPos)(_GLFWmonitor*,int*,int*);
+    void (*getMonitorContentScale)(_GLFWmonitor*,float*,float*);
+    void (*getMonitorWorkarea)(_GLFWmonitor*,int*,int*,int*,int*);
+    GLFWvidmode* (*getVideoModes)(_GLFWmonitor*,int*);
+    void (*getVideoMode)(_GLFWmonitor*,GLFWvidmode*);
+    GLFWbool (*getGammaRamp)(_GLFWmonitor*,GLFWgammaramp*);
+    void (*setGammaRamp)(_GLFWmonitor*,const GLFWgammaramp*);
+    // window
+    int (*createWindow)(_GLFWwindow*,const _GLFWwndconfig*,const _GLFWctxconfig*,const _GLFWfbconfig*);
+    void (*destroyWindow)(_GLFWwindow*);
+    void (*setWindowTitle)(_GLFWwindow*,const char*);
+    void (*setWindowIcon)(_GLFWwindow*,int,const GLFWimage*);
+    void (*getWindowPos)(_GLFWwindow*,int*,int*);
+    void (*setWindowPos)(_GLFWwindow*,int,int);
+    void (*getWindowSize)(_GLFWwindow*,int*,int*);
+    void (*setWindowSize)(_GLFWwindow*,int,int);
+    void (*setWindowSizeLimits)(_GLFWwindow*,int,int,int,int);
+    void (*setWindowAspectRatio)(_GLFWwindow*,int,int);
+    void (*getFramebufferSize)(_GLFWwindow*,int*,int*);
+    void (*getWindowFrameSize)(_GLFWwindow*,int*,int*,int*,int*);
+    void (*getWindowContentScale)(_GLFWwindow*,float*,float*);
+    void (*iconifyWindow)(_GLFWwindow*);
+    void (*restoreWindow)(_GLFWwindow*);
+    void (*maximizeWindow)(_GLFWwindow*);
+    void (*showWindow)(_GLFWwindow*);
+    void (*hideWindow)(_GLFWwindow*);
+    void (*requestWindowAttention)(_GLFWwindow*);
+    void (*focusWindow)(_GLFWwindow*);
+    void (*setWindowMonitor)(_GLFWwindow*,_GLFWmonitor*,int,int,int,int,int);
+    int (*windowFocused)(_GLFWwindow*);
+    int (*windowIconified)(_GLFWwindow*);
+    int (*windowVisible)(_GLFWwindow*);
+    int (*windowMaximized)(_GLFWwindow*);
+    int (*windowHovered)(_GLFWwindow*);
+    int (*framebufferTransparent)(_GLFWwindow*);
+    float (*getWindowOpacity)(_GLFWwindow*);
+    void (*setWindowResizable)(_GLFWwindow*,GLFWbool);
+    void (*setWindowDecorated)(_GLFWwindow*,GLFWbool);
+    void (*setWindowFloating)(_GLFWwindow*,GLFWbool);
+    void (*setWindowOpacity)(_GLFWwindow*,float);
+    void (*setWindowMousePassthrough)(_GLFWwindow*,GLFWbool);
+    void (*pollEvents)(void);
+    void (*waitEvents)(void);
+    void (*waitEventsTimeout)(double);
+    void (*postEmptyEvent)(void);
+    // EGL
+    EGLenum (*getEGLPlatform)(EGLint**);
+    EGLNativeDisplayType (*getEGLNativeDisplay)(void);
+    EGLNativeWindowType (*getEGLNativeWindow)(_GLFWwindow*);
+    // vulkan
+    void (*getRequiredInstanceExtensions)(char**);
+    int (*getPhysicalDevicePresentationSupport)(VkInstance,VkPhysicalDevice,uint32_t);
+    VkResult (*createWindowSurface)(VkInstance,_GLFWwindow*,const VkAllocationCallbacks*,VkSurfaceKHR*);
 };
 
 // Library global data
@@ -688,6 +761,8 @@ struct _GLFWlibrary
     GLFWbool            initialized;
     GLFWallocator       allocator;
 
+    _GLFWplatform       platform;
+
     struct {
         _GLFWinitconfig init;
         _GLFWfbconfig   framebuffer;
@@ -714,8 +789,8 @@ struct _GLFWlibrary
 
     struct {
         uint64_t        offset;
-        // This is defined in the platform's time.h
-        _GLFW_PLATFORM_LIBRARY_TIMER_STATE;
+        // This is defined in platform.h
+        GLFW_PLATFORM_LIBRARY_TIMER_STATE
     } timer;
 
     struct {
@@ -784,17 +859,12 @@ struct _GLFWlibrary
         PFN_vkGetInstanceProcAddr GetInstanceProcAddr;
 #endif
         GLFWbool        KHR_surface;
-#if defined(_GLFW_WIN32)
         GLFWbool        KHR_win32_surface;
-#elif defined(_GLFW_COCOA)
         GLFWbool        MVK_macos_surface;
         GLFWbool        EXT_metal_surface;
-#elif defined(_GLFW_X11)
         GLFWbool        KHR_xlib_surface;
         GLFWbool        KHR_xcb_surface;
-#elif defined(_GLFW_WAYLAND)
         GLFWbool        KHR_wayland_surface;
-#endif
     } vk;
 
     struct {
@@ -802,12 +872,10 @@ struct _GLFWlibrary
         GLFWjoystickfun joystick;
     } callbacks;
 
-    // This is defined in the window API's platform.h
-    _GLFW_PLATFORM_LIBRARY_WINDOW_STATE;
-    // This is defined in the context API's context.h
-    _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE;
-    // This is defined in the platform's joystick.h
-    _GLFW_PLATFORM_LIBRARY_JOYSTICK_STATE;
+    // These are defined in platform.h
+    GLFW_PLATFORM_LIBRARY_WINDOW_STATE
+    GLFW_PLATFORM_LIBRARY_CONTEXT_STATE
+    GLFW_PLATFORM_LIBRARY_JOYSTICK_STATE
 };
 
 // Global state shared between compilation units of GLFW
@@ -819,110 +887,10 @@ extern _GLFWlibrary _glfw;
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformInit(void);
-void _glfwPlatformTerminate(void);
-const char* _glfwPlatformGetVersionString(void);
-
-void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos);
-void _glfwPlatformSetCursorPos(_GLFWwindow* window, double xpos, double ypos);
-void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode);
-void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled);
-GLFWbool _glfwPlatformRawMouseMotionSupported(void);
-int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
-                              const GLFWimage* image, int xhot, int yhot);
-int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape);
-void _glfwPlatformDestroyCursor(_GLFWcursor* cursor);
-void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor);
-
-const char* _glfwPlatformGetScancodeName(int scancode);
-int _glfwPlatformGetKeyScancode(int key);
-
-void _glfwPlatformFreeMonitor(_GLFWmonitor* monitor);
-void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos);
-void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
-                                         float* xscale, float* yscale);
-void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor, int* xpos, int* ypos, int *width, int *height);
-GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count);
-void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode);
-GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp);
-void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor, const GLFWgammaramp* ramp);
-
-void _glfwPlatformSetClipboardString(const char* string);
-const char* _glfwPlatformGetClipboardString(void);
-
-GLFWbool _glfwPlatformInitJoysticks(void);
-void _glfwPlatformTerminateJoysticks(void);
-int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode);
-void _glfwPlatformUpdateGamepadGUID(char* guid);
-const char* _glfwPlatformGetMappingName(void);
-
 void _glfwPlatformInitTimer(void);
 uint64_t _glfwPlatformGetTimerValue(void);
 uint64_t _glfwPlatformGetTimerFrequency(void);
 
-int _glfwPlatformCreateWindow(_GLFWwindow* window,
-                              const _GLFWwndconfig* wndconfig,
-                              const _GLFWctxconfig* ctxconfig,
-                              const _GLFWfbconfig* fbconfig);
-void _glfwPlatformDestroyWindow(_GLFWwindow* window);
-void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title);
-void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
-                                int count, const GLFWimage* images);
-void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos);
-void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos);
-void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height);
-void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height);
-void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
-                                      int minwidth, int minheight,
-                                      int maxwidth, int maxheight);
-void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int numer, int denom);
-void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* height);
-void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
-                                     int* left, int* top,
-                                     int* right, int* bottom);
-void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
-                                        float* xscale, float* yscale);
-void _glfwPlatformIconifyWindow(_GLFWwindow* window);
-void _glfwPlatformRestoreWindow(_GLFWwindow* window);
-void _glfwPlatformMaximizeWindow(_GLFWwindow* window);
-void _glfwPlatformShowWindow(_GLFWwindow* window);
-void _glfwPlatformHideWindow(_GLFWwindow* window);
-void _glfwPlatformRequestWindowAttention(_GLFWwindow* window);
-void _glfwPlatformFocusWindow(_GLFWwindow* window);
-void _glfwPlatformSetWindowMonitor(_GLFWwindow* window, _GLFWmonitor* monitor,
-                                   int xpos, int ypos, int width, int height,
-                                   int refreshRate);
-int _glfwPlatformWindowFocused(_GLFWwindow* window);
-int _glfwPlatformWindowIconified(_GLFWwindow* window);
-int _glfwPlatformWindowVisible(_GLFWwindow* window);
-int _glfwPlatformWindowMaximized(_GLFWwindow* window);
-int _glfwPlatformWindowHovered(_GLFWwindow* window);
-int _glfwPlatformFramebufferTransparent(_GLFWwindow* window);
-float _glfwPlatformGetWindowOpacity(_GLFWwindow* window);
-void _glfwPlatformSetWindowResizable(_GLFWwindow* window, GLFWbool enabled);
-void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled);
-void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled);
-void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enabled);
-void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity);
-
-void _glfwPlatformPollEvents(void);
-void _glfwPlatformWaitEvents(void);
-void _glfwPlatformWaitEventsTimeout(double timeout);
-void _glfwPlatformPostEmptyEvent(void);
-
-EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs);
-EGLNativeDisplayType _glfwPlatformGetEGLNativeDisplay(void);
-EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window);
-
-void _glfwPlatformGetRequiredInstanceExtensions(char** extensions);
-int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
-                                                      VkPhysicalDevice device,
-                                                      uint32_t queuefamily);
-VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
-                                          _GLFWwindow* window,
-                                          const VkAllocationCallbacks* allocator,
-                                          VkSurfaceKHR* surface);
-
 GLFWbool _glfwPlatformCreateTls(_GLFWtls* tls);
 void _glfwPlatformDestroyTls(_GLFWtls* tls);
 void* _glfwPlatformGetTls(_GLFWtls* tls);
@@ -983,6 +951,8 @@ void _glfwInputError(int code, const char* format, ...);
 //////                       GLFW internal API                      //////
 //////////////////////////////////////////////////////////////////////////
 
+GLFWbool _glfwSelectPlatform(int platformID, _GLFWplatform* platform);
+
 GLFWbool _glfwStringInExtensionString(const char* string, const char* extensions);
 const _GLFWfbconfig* _glfwChooseFBConfig(const _GLFWfbconfig* desired,
                                          const _GLFWfbconfig* alternatives,
diff --git a/src/linux_joystick.c b/src/linux_joystick.c
index edb53e4c..6ea63942 100644
--- a/src/linux_joystick.c
+++ b/src/linux_joystick.c
@@ -307,7 +307,7 @@ void _glfwDetectJoystickConnectionLinux(void)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-GLFWbool _glfwPlatformInitJoysticks(void)
+GLFWbool _glfwInitJoysticksLinux(void)
 {
     const char* dirname = "/dev/input";
 
@@ -361,7 +361,7 @@ GLFWbool _glfwPlatformInitJoysticks(void)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminateJoysticks(void)
+void _glfwTerminateJoysticksLinux(void)
 {
     int jid;
 
@@ -382,7 +382,7 @@ void _glfwPlatformTerminateJoysticks(void)
     }
 }
 
-int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode)
+int _glfwPollJoystickLinux(_GLFWjoystick* js, int mode)
 {
     // Read all queued events (non-blocking)
     for (;;)
@@ -422,12 +422,12 @@ int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode)
     return js->present;
 }
 
-const char* _glfwPlatformGetMappingName(void)
+const char* _glfwGetMappingNameLinux(void)
 {
     return "Linux";
 }
 
-void _glfwPlatformUpdateGamepadGUID(char* guid)
+void _glfwUpdateGamepadGUIDLinux(char* guid)
 {
 }
 
diff --git a/src/linux_joystick.h b/src/linux_joystick.h
index 1766a3bf..37e5d1ae 100644
--- a/src/linux_joystick.h
+++ b/src/linux_joystick.h
@@ -28,8 +28,8 @@
 #include <linux/limits.h>
 #include <regex.h>
 
-#define _GLFW_PLATFORM_JOYSTICK_STATE         _GLFWjoystickLinux linjs
-#define _GLFW_PLATFORM_LIBRARY_JOYSTICK_STATE _GLFWlibraryLinux  linjs
+#define GLFW_LINUX_JOYSTICK_STATE         _GLFWjoystickLinux linjs;
+#define GLFW_LINUX_LIBRARY_JOYSTICK_STATE _GLFWlibraryLinux  linjs;
 
 #define GLFW_BUILD_LINUX_MAPPINGS
 
@@ -57,3 +57,9 @@ typedef struct _GLFWlibraryLinux
 
 void _glfwDetectJoystickConnectionLinux(void);
 
+GLFWbool _glfwInitJoysticksLinux(void);
+void _glfwTerminateJoysticksLinux(void);
+int _glfwPollJoystickLinux(_GLFWjoystick* js, int mode);
+const char* _glfwGetMappingNameLinux(void);
+void _glfwUpdateGamepadGUIDLinux(char* guid);
+
diff --git a/src/monitor.c b/src/monitor.c
index 938582b2..31921b46 100644
--- a/src/monitor.c
+++ b/src/monitor.c
@@ -74,7 +74,7 @@ static GLFWbool refreshVideoModes(_GLFWmonitor* monitor)
     if (monitor->modes)
         return GLFW_TRUE;
 
-    modes = _glfwPlatformGetVideoModes(monitor, &modeCount);
+    modes = _glfw.platform.getVideoModes(monitor, &modeCount);
     if (!modes)
         return GLFW_FALSE;
 
@@ -123,10 +123,10 @@ void _glfwInputMonitor(_GLFWmonitor* monitor, int action, int placement)
             if (window->monitor == monitor)
             {
                 int width, height, xoff, yoff;
-                _glfwPlatformGetWindowSize(window, &width, &height);
-                _glfwPlatformSetWindowMonitor(window, NULL, 0, 0, width, height, 0);
-                _glfwPlatformGetWindowFrameSize(window, &xoff, &yoff, NULL, NULL);
-                _glfwPlatformSetWindowPos(window, xoff, yoff);
+                _glfw.platform.getWindowSize(window, &width, &height);
+                _glfw.platform.setWindowMonitor(window, NULL, 0, 0, width, height, 0);
+                _glfw.platform.getWindowFrameSize(window, &xoff, &yoff, NULL, NULL);
+                _glfw.platform.setWindowPos(window, xoff, yoff);
             }
         }
 
@@ -183,7 +183,7 @@ void _glfwFreeMonitor(_GLFWmonitor* monitor)
     if (monitor == NULL)
         return;
 
-    _glfwPlatformFreeMonitor(monitor);
+    _glfw.platform.freeMonitor(monitor);
 
     _glfwFreeGammaArrays(&monitor->originalRamp);
     _glfwFreeGammaArrays(&monitor->currentRamp);
@@ -332,7 +332,7 @@ GLFWAPI void glfwGetMonitorPos(GLFWmonitor* handle, int* xpos, int* ypos)
 
     _GLFW_REQUIRE_INIT();
 
-    _glfwPlatformGetMonitorPos(monitor, xpos, ypos);
+    _glfw.platform.getMonitorPos(monitor, xpos, ypos);
 }
 
 GLFWAPI void glfwGetMonitorWorkarea(GLFWmonitor* handle,
@@ -353,7 +353,7 @@ GLFWAPI void glfwGetMonitorWorkarea(GLFWmonitor* handle,
 
     _GLFW_REQUIRE_INIT();
 
-    _glfwPlatformGetMonitorWorkarea(monitor, xpos, ypos, width, height);
+    _glfw.platform.getMonitorWorkarea(monitor, xpos, ypos, width, height);
 }
 
 GLFWAPI void glfwGetMonitorPhysicalSize(GLFWmonitor* handle, int* widthMM, int* heightMM)
@@ -386,7 +386,7 @@ GLFWAPI void glfwGetMonitorContentScale(GLFWmonitor* handle,
         *yscale = 0.f;
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformGetMonitorContentScale(monitor, xscale, yscale);
+    _glfw.platform.getMonitorContentScale(monitor, xscale, yscale);
 }
 
 GLFWAPI const char* glfwGetMonitorName(GLFWmonitor* handle)
@@ -447,7 +447,7 @@ GLFWAPI const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* handle)
 
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
 
-    _glfwPlatformGetVideoMode(monitor, &monitor->currentMode);
+    _glfw.platform.getVideoMode(monitor, &monitor->currentMode);
     return &monitor->currentMode;
 }
 
@@ -506,7 +506,7 @@ GLFWAPI const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* handle)
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
 
     _glfwFreeGammaArrays(&monitor->currentRamp);
-    if (!_glfwPlatformGetGammaRamp(monitor, &monitor->currentRamp))
+    if (!_glfw.platform.getGammaRamp(monitor, &monitor->currentRamp))
         return NULL;
 
     return &monitor->currentRamp;
@@ -534,10 +534,10 @@ GLFWAPI void glfwSetGammaRamp(GLFWmonitor* handle, const GLFWgammaramp* ramp)
 
     if (!monitor->originalRamp.size)
     {
-        if (!_glfwPlatformGetGammaRamp(monitor, &monitor->originalRamp))
+        if (!_glfw.platform.getGammaRamp(monitor, &monitor->originalRamp))
             return;
     }
 
-    _glfwPlatformSetGammaRamp(monitor, ramp);
+    _glfw.platform.setGammaRamp(monitor, ramp);
 }
 
diff --git a/src/nsgl_context.m b/src/nsgl_context.m
index 940ee848..694937c6 100644
--- a/src/nsgl_context.m
+++ b/src/nsgl_context.m
@@ -358,6 +358,13 @@ GLFWAPI id glfwGetNSGLContext(GLFWwindow* handle)
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(nil);
 
+    if (_glfw.platform.platformID != GLFW_PLATFORM_COCOA)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                        "NSGL: Platform not initialized");
+        return nil;
+    }
+
     if (window->context.client != GLFW_NATIVE_CONTEXT_API)
     {
         _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);
diff --git a/src/null_init.c b/src/null_init.c
index d2968fc1..de4b28f3 100644
--- a/src/null_init.c
+++ b/src/null_init.c
@@ -36,22 +36,98 @@
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformInit(void)
+GLFWbool _glfwConnectNull(int platformID, _GLFWplatform* platform)
 {
-    _glfwPollMonitorsNull();
+    const _GLFWplatform null =
+    {
+        GLFW_PLATFORM_NULL,
+        _glfwInitNull,
+        _glfwTerminateNull,
+        _glfwGetCursorPosNull,
+        _glfwSetCursorPosNull,
+        _glfwSetCursorModeNull,
+        _glfwSetRawMouseMotionNull,
+        _glfwRawMouseMotionSupportedNull,
+        _glfwCreateCursorNull,
+        _glfwCreateStandardCursorNull,
+        _glfwDestroyCursorNull,
+        _glfwSetCursorNull,
+        _glfwGetScancodeNameNull,
+        _glfwGetKeyScancodeNull,
+        _glfwSetClipboardStringNull,
+        _glfwGetClipboardStringNull,
+        _glfwInitJoysticksNull,
+        _glfwTerminateJoysticksNull,
+        _glfwPollJoystickNull,
+        _glfwGetMappingNameNull,
+        _glfwUpdateGamepadGUIDNull,
+        _glfwFreeMonitorNull,
+        _glfwGetMonitorPosNull,
+        _glfwGetMonitorContentScaleNull,
+        _glfwGetMonitorWorkareaNull,
+        _glfwGetVideoModesNull,
+        _glfwGetVideoModeNull,
+        _glfwGetGammaRampNull,
+        _glfwSetGammaRampNull,
+        _glfwCreateWindowNull,
+        _glfwDestroyWindowNull,
+        _glfwSetWindowTitleNull,
+        _glfwSetWindowIconNull,
+        _glfwGetWindowPosNull,
+        _glfwSetWindowPosNull,
+        _glfwGetWindowSizeNull,
+        _glfwSetWindowSizeNull,
+        _glfwSetWindowSizeLimitsNull,
+        _glfwSetWindowAspectRatioNull,
+        _glfwGetFramebufferSizeNull,
+        _glfwGetWindowFrameSizeNull,
+        _glfwGetWindowContentScaleNull,
+        _glfwIconifyWindowNull,
+        _glfwRestoreWindowNull,
+        _glfwMaximizeWindowNull,
+        _glfwShowWindowNull,
+        _glfwHideWindowNull,
+        _glfwRequestWindowAttentionNull,
+        _glfwFocusWindowNull,
+        _glfwSetWindowMonitorNull,
+        _glfwWindowFocusedNull,
+        _glfwWindowIconifiedNull,
+        _glfwWindowVisibleNull,
+        _glfwWindowMaximizedNull,
+        _glfwWindowHoveredNull,
+        _glfwFramebufferTransparentNull,
+        _glfwGetWindowOpacityNull,
+        _glfwSetWindowResizableNull,
+        _glfwSetWindowDecoratedNull,
+        _glfwSetWindowFloatingNull,
+        _glfwSetWindowOpacityNull,
+        _glfwSetWindowMousePassthroughNull,
+        _glfwPollEventsNull,
+        _glfwWaitEventsNull,
+        _glfwWaitEventsTimeoutNull,
+        _glfwPostEmptyEventNull,
+        _glfwGetEGLPlatformNull,
+        _glfwGetEGLNativeDisplayNull,
+        _glfwGetEGLNativeWindowNull,
+        _glfwGetRequiredInstanceExtensionsNull,
+        _glfwGetPhysicalDevicePresentationSupportNull,
+        _glfwCreateWindowSurfaceNull,
+    };
 
+    *platform = null;
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminate(void)
+int _glfwInitNull(void)
 {
-    _glfw_free(_glfw.null.clipboardString);
-    _glfwTerminateOSMesa();
-    _glfwTerminateEGL();
+    _glfwPollMonitorsNull();
+    return GLFW_TRUE;
 }
 
-const char* _glfwPlatformGetVersionString(void)
+void _glfwTerminateNull(void)
 {
-    return _GLFW_VERSION_NUMBER " null OSMesa EGL";
+    free(_glfw.null.clipboardString);
+    _glfwTerminateOSMesa();
+    _glfwTerminateEGL();
 }
 
diff --git a/src/null_joystick.c b/src/null_joystick.c
index de5066ca..e2770dd8 100644
--- a/src/null_joystick.c
+++ b/src/null_joystick.c
@@ -33,26 +33,26 @@
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-GLFWbool _glfwPlatformInitJoysticks(void)
+GLFWbool _glfwInitJoysticksNull(void)
 {
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminateJoysticks(void)
+void _glfwTerminateJoysticksNull(void)
 {
 }
 
-int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode)
+int _glfwPollJoystickNull(_GLFWjoystick* js, int mode)
 {
     return GLFW_FALSE;
 }
 
-const char* _glfwPlatformGetMappingName(void)
+const char* _glfwGetMappingNameNull(void)
 {
     return "";
 }
 
-void _glfwPlatformUpdateGamepadGUID(char* guid)
+void _glfwUpdateGamepadGUIDNull(char* guid)
 {
 }
 
diff --git a/src/null_joystick.h b/src/null_joystick.h
index a1ff7fcd..ec223ecd 100644
--- a/src/null_joystick.h
+++ b/src/null_joystick.h
@@ -24,6 +24,9 @@
 //
 //========================================================================
 
-#define _GLFW_PLATFORM_JOYSTICK_STATE         struct { int dummyJoystick; }
-#define _GLFW_PLATFORM_LIBRARY_JOYSTICK_STATE struct { int dummyLibraryJoystick; }
+GLFWbool _glfwInitJoysticksNull(void);
+void _glfwTerminateJoysticksNull(void);
+int _glfwPollJoystickNull(_GLFWjoystick* js, int mode);
+const char* _glfwGetMappingNameNull(void);
+void _glfwUpdateGamepadGUIDNull(char* guid);
 
diff --git a/src/null_monitor.c b/src/null_monitor.c
index a071e0c4..63a1cd20 100644
--- a/src/null_monitor.c
+++ b/src/null_monitor.c
@@ -65,12 +65,12 @@ void _glfwPollMonitorsNull(void)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-void _glfwPlatformFreeMonitor(_GLFWmonitor* monitor)
+void _glfwFreeMonitorNull(_GLFWmonitor* monitor)
 {
     _glfwFreeGammaArrays(&monitor->null.ramp);
 }
 
-void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
+void _glfwGetMonitorPosNull(_GLFWmonitor* monitor, int* xpos, int* ypos)
 {
     if (xpos)
         *xpos = 0;
@@ -78,8 +78,8 @@ void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
         *ypos = 0;
 }
 
-void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
-                                         float* xscale, float* yscale)
+void _glfwGetMonitorContentScaleNull(_GLFWmonitor* monitor,
+                                     float* xscale, float* yscale)
 {
     if (xscale)
         *xscale = 1.f;
@@ -87,9 +87,9 @@ void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
         *yscale = 1.f;
 }
 
-void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
-                                     int* xpos, int* ypos,
-                                     int* width, int* height)
+void _glfwGetMonitorWorkareaNull(_GLFWmonitor* monitor,
+                                 int* xpos, int* ypos,
+                                 int* width, int* height)
 {
     const GLFWvidmode mode = getVideoMode();
 
@@ -103,7 +103,7 @@ void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
         *height = mode.height - 10;
 }
 
-GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* found)
+GLFWvidmode* _glfwGetVideoModesNull(_GLFWmonitor* monitor, int* found)
 {
     GLFWvidmode* mode = _glfw_calloc(1, sizeof(GLFWvidmode));
     *mode = getVideoMode();
@@ -111,18 +111,20 @@ GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* found)
     return mode;
 }
 
-void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
+void _glfwGetVideoModeNull(_GLFWmonitor* monitor, GLFWvidmode* mode)
 {
     *mode = getVideoMode();
 }
 
-GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
+GLFWbool _glfwGetGammaRampNull(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
 {
     if (!monitor->null.ramp.size)
     {
+        unsigned int i;
+
         _glfwAllocGammaArrays(&monitor->null.ramp, 256);
 
-        for (unsigned int i = 0;  i < monitor->null.ramp.size;  i++)
+        for (i = 0;  i < monitor->null.ramp.size;  i++)
         {
             const float gamma = 2.2f;
             float value;
@@ -143,7 +145,7 @@ GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
+void _glfwSetGammaRampNull(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
 {
     if (monitor->null.ramp.size != ramp->size)
     {
diff --git a/src/null_platform.h b/src/null_platform.h
index e0b3f2ce..30e50a85 100644
--- a/src/null_platform.h
+++ b/src/null_platform.h
@@ -25,17 +25,14 @@
 //
 //========================================================================
 
-#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowNull null
-#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryNull null
-#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorNull null
+#define GLFW_NULL_WINDOW_STATE          _GLFWwindowNull null;
+#define GLFW_NULL_LIBRARY_WINDOW_STATE  _GLFWlibraryNull null;
+#define GLFW_NULL_MONITOR_STATE         _GLFWmonitorNull null;
 
-#define _GLFW_PLATFORM_CONTEXT_STATE         struct { int dummyContext; }
-#define _GLFW_PLATFORM_CURSOR_STATE          struct { int dummyCursor; }
-#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE struct { int dummyLibraryContext; }
+#define GLFW_NULL_CONTEXT_STATE
+#define GLFW_NULL_CURSOR_STATE
+#define GLFW_NULL_LIBRARY_CONTEXT_STATE
 
-#include "posix_time.h"
-#include "posix_thread.h"
-#include "null_joystick.h"
 
 // Null-specific per-window data
 //
@@ -75,3 +72,79 @@ typedef struct _GLFWlibraryNull
 
 void _glfwPollMonitorsNull(void);
 
+GLFWbool _glfwConnectNull(int platformID, _GLFWplatform* platform);
+int _glfwInitNull(void);
+void _glfwTerminateNull(void);
+
+void _glfwFreeMonitorNull(_GLFWmonitor* monitor);
+void _glfwGetMonitorPosNull(_GLFWmonitor* monitor, int* xpos, int* ypos);
+void _glfwGetMonitorContentScaleNull(_GLFWmonitor* monitor, float* xscale, float* yscale);
+void _glfwGetMonitorWorkareaNull(_GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
+GLFWvidmode* _glfwGetVideoModesNull(_GLFWmonitor* monitor, int* found);
+void _glfwGetVideoModeNull(_GLFWmonitor* monitor, GLFWvidmode* mode);
+GLFWbool _glfwGetGammaRampNull(_GLFWmonitor* monitor, GLFWgammaramp* ramp);
+void _glfwSetGammaRampNull(_GLFWmonitor* monitor, const GLFWgammaramp* ramp);
+
+int _glfwCreateWindowNull(_GLFWwindow* window, const _GLFWwndconfig* wndconfig, const _GLFWctxconfig* ctxconfig, const _GLFWfbconfig* fbconfig);
+void _glfwDestroyWindowNull(_GLFWwindow* window);
+void _glfwSetWindowTitleNull(_GLFWwindow* window, const char* title);
+void _glfwSetWindowIconNull(_GLFWwindow* window, int count, const GLFWimage* images);
+void _glfwSetWindowMonitorNull(_GLFWwindow* window, _GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
+void _glfwGetWindowPosNull(_GLFWwindow* window, int* xpos, int* ypos);
+void _glfwSetWindowPosNull(_GLFWwindow* window, int xpos, int ypos);
+void _glfwGetWindowSizeNull(_GLFWwindow* window, int* width, int* height);
+void _glfwSetWindowSizeNull(_GLFWwindow* window, int width, int height);
+void _glfwSetWindowSizeLimitsNull(_GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
+void _glfwSetWindowAspectRatioNull(_GLFWwindow* window, int n, int d);
+void _glfwGetFramebufferSizeNull(_GLFWwindow* window, int* width, int* height);
+void _glfwGetWindowFrameSizeNull(_GLFWwindow* window, int* left, int* top, int* right, int* bottom);
+void _glfwGetWindowContentScaleNull(_GLFWwindow* window, float* xscale, float* yscale);
+void _glfwIconifyWindowNull(_GLFWwindow* window);
+void _glfwRestoreWindowNull(_GLFWwindow* window);
+void _glfwMaximizeWindowNull(_GLFWwindow* window);
+int _glfwWindowMaximizedNull(_GLFWwindow* window);
+int _glfwWindowHoveredNull(_GLFWwindow* window);
+int _glfwFramebufferTransparentNull(_GLFWwindow* window);
+void _glfwSetWindowResizableNull(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowDecoratedNull(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowFloatingNull(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowMousePassthroughNull(_GLFWwindow* window, GLFWbool enabled);
+float _glfwGetWindowOpacityNull(_GLFWwindow* window);
+void _glfwSetWindowOpacityNull(_GLFWwindow* window, float opacity);
+void _glfwSetRawMouseMotionNull(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwRawMouseMotionSupportedNull(void);
+void _glfwShowWindowNull(_GLFWwindow* window);
+void _glfwRequestWindowAttentionNull(_GLFWwindow* window);
+void _glfwRequestWindowAttentionNull(_GLFWwindow* window);
+void _glfwUnhideWindowNull(_GLFWwindow* window);
+void _glfwHideWindowNull(_GLFWwindow* window);
+void _glfwFocusWindowNull(_GLFWwindow* window);
+int _glfwWindowFocusedNull(_GLFWwindow* window);
+int _glfwWindowIconifiedNull(_GLFWwindow* window);
+int _glfwWindowVisibleNull(_GLFWwindow* window);
+void _glfwPollEventsNull(void);
+void _glfwWaitEventsNull(void);
+void _glfwWaitEventsTimeoutNull(double timeout);
+void _glfwPostEmptyEventNull(void);
+void _glfwGetCursorPosNull(_GLFWwindow* window, double* xpos, double* ypos);
+void _glfwSetCursorPosNull(_GLFWwindow* window, double x, double y);
+void _glfwSetCursorModeNull(_GLFWwindow* window, int mode);
+int _glfwCreateCursorNull(_GLFWcursor* cursor, const GLFWimage* image, int xhot, int yhot);
+int _glfwCreateStandardCursorNull(_GLFWcursor* cursor, int shape);
+void _glfwDestroyCursorNull(_GLFWcursor* cursor);
+void _glfwSetCursorNull(_GLFWwindow* window, _GLFWcursor* cursor);
+void _glfwSetClipboardStringNull(const char* string);
+const char* _glfwGetClipboardStringNull(void);
+const char* _glfwGetScancodeNameNull(int scancode);
+int _glfwGetKeyScancodeNull(int key);
+
+EGLenum _glfwGetEGLPlatformNull(EGLint** attribs);
+EGLNativeDisplayType _glfwGetEGLNativeDisplayNull(void);
+EGLNativeWindowType _glfwGetEGLNativeWindowNull(_GLFWwindow* window);
+
+void _glfwGetRequiredInstanceExtensionsNull(char** extensions);
+int _glfwGetPhysicalDevicePresentationSupportNull(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily);
+VkResult _glfwCreateWindowSurfaceNull(VkInstance instance, _GLFWwindow* window, const VkAllocationCallbacks* allocator, VkSurfaceKHR* surface);
+
+void _glfwPollMonitorsNull(void);
+
diff --git a/src/null_window.c b/src/null_window.c
index 6a251153..10c5293f 100644
--- a/src/null_window.c
+++ b/src/null_window.c
@@ -53,10 +53,10 @@ static void applySizeLimits(_GLFWwindow* window, int* width, int* height)
 static void fitToMonitor(_GLFWwindow* window)
 {
     GLFWvidmode mode;
-    _glfwPlatformGetVideoMode(window->monitor, &mode);
-    _glfwPlatformGetMonitorPos(window->monitor,
-                               &window->null.xpos,
-                               &window->null.ypos);
+    _glfwGetVideoModeNull(window->monitor, &mode);
+    _glfwGetMonitorPosNull(window->monitor,
+                           &window->null.xpos,
+                           &window->null.ypos);
     window->null.width = mode.width;
     window->null.height = mode.height;
 }
@@ -103,10 +103,10 @@ static int createNativeWindow(_GLFWwindow* window,
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformCreateWindow(_GLFWwindow* window,
-                              const _GLFWwndconfig* wndconfig,
-                              const _GLFWctxconfig* ctxconfig,
-                              const _GLFWfbconfig* fbconfig)
+int _glfwCreateWindowNull(_GLFWwindow* window,
+                          const _GLFWwndconfig* wndconfig,
+                          const _GLFWctxconfig* ctxconfig,
+                          const _GLFWfbconfig* fbconfig)
 {
     if (!createNativeWindow(window, wndconfig, fbconfig))
         return GLFW_FALSE;
@@ -132,15 +132,15 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
 
     if (window->monitor)
     {
-        _glfwPlatformShowWindow(window);
-        _glfwPlatformFocusWindow(window);
+        _glfwShowWindowNull(window);
+        _glfwFocusWindowNull(window);
         acquireMonitor(window);
     }
 
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyWindow(_GLFWwindow* window)
+void _glfwDestroyWindowNull(_GLFWwindow* window)
 {
     if (window->monitor)
         releaseMonitor(window);
@@ -152,27 +152,26 @@ void _glfwPlatformDestroyWindow(_GLFWwindow* window)
         window->context.destroy(window);
 }
 
-void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
+void _glfwSetWindowTitleNull(_GLFWwindow* window, const char* title)
 {
 }
 
-void _glfwPlatformSetWindowIcon(_GLFWwindow* window, int count,
-                                const GLFWimage* images)
+void _glfwSetWindowIconNull(_GLFWwindow* window, int count, const GLFWimage* images)
 {
 }
 
-void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
-                                   _GLFWmonitor* monitor,
-                                   int xpos, int ypos,
-                                   int width, int height,
-                                   int refreshRate)
+void _glfwSetWindowMonitorNull(_GLFWwindow* window,
+                               _GLFWmonitor* monitor,
+                               int xpos, int ypos,
+                               int width, int height,
+                               int refreshRate)
 {
     if (window->monitor == monitor)
     {
         if (!monitor)
         {
-            _glfwPlatformSetWindowPos(window, xpos, ypos);
-            _glfwPlatformSetWindowSize(window, width, height);
+            _glfwSetWindowPosNull(window, xpos, ypos);
+            _glfwSetWindowSizeNull(window, width, height);
         }
 
         return;
@@ -191,12 +190,12 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
     }
     else
     {
-        _glfwPlatformSetWindowPos(window, xpos, ypos);
-        _glfwPlatformSetWindowSize(window, width, height);
+        _glfwSetWindowPosNull(window, xpos, ypos);
+        _glfwSetWindowSizeNull(window, width, height);
     }
 }
 
-void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
+void _glfwGetWindowPosNull(_GLFWwindow* window, int* xpos, int* ypos)
 {
     if (xpos)
         *xpos = window->null.xpos;
@@ -204,7 +203,7 @@ void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
         *ypos = window->null.ypos;
 }
 
-void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
+void _glfwSetWindowPosNull(_GLFWwindow* window, int xpos, int ypos)
 {
     if (window->monitor)
         return;
@@ -217,7 +216,7 @@ void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
     }
 }
 
-void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetWindowSizeNull(_GLFWwindow* window, int* width, int* height)
 {
     if (width)
         *width = window->null.width;
@@ -225,7 +224,7 @@ void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
         *height = window->null.height;
 }
 
-void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
+void _glfwSetWindowSizeNull(_GLFWwindow* window, int width, int height)
 {
     if (window->monitor)
         return;
@@ -239,25 +238,25 @@ void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
     }
 }
 
-void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
-                                      int minwidth, int minheight,
-                                      int maxwidth, int maxheight)
+void _glfwSetWindowSizeLimitsNull(_GLFWwindow* window,
+                                  int minwidth, int minheight,
+                                  int maxwidth, int maxheight)
 {
     int width = window->null.width;
     int height = window->null.height;
     applySizeLimits(window, &width, &height);
-    _glfwPlatformSetWindowSize(window, width, height);
+    _glfwSetWindowSizeNull(window, width, height);
 }
 
-void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int n, int d)
+void _glfwSetWindowAspectRatioNull(_GLFWwindow* window, int n, int d)
 {
     int width = window->null.width;
     int height = window->null.height;
     applySizeLimits(window, &width, &height);
-    _glfwPlatformSetWindowSize(window, width, height);
+    _glfwSetWindowSizeNull(window, width, height);
 }
 
-void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetFramebufferSizeNull(_GLFWwindow* window, int* width, int* height)
 {
     if (width)
         *width = window->null.width;
@@ -265,9 +264,9 @@ void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* heigh
         *height = window->null.height;
 }
 
-void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
-                                     int* left, int* top,
-                                     int* right, int* bottom)
+void _glfwGetWindowFrameSizeNull(_GLFWwindow* window,
+                                 int* left, int* top,
+                                 int* right, int* bottom)
 {
     if (window->null.decorated && !window->monitor)
     {
@@ -293,8 +292,7 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
     }
 }
 
-void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
-                                        float* xscale, float* yscale)
+void _glfwGetWindowContentScaleNull(_GLFWwindow* window, float* xscale, float* yscale)
 {
     if (xscale)
         *xscale = 1.f;
@@ -302,7 +300,7 @@ void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
         *yscale = 1.f;
 }
 
-void _glfwPlatformIconifyWindow(_GLFWwindow* window)
+void _glfwIconifyWindowNull(_GLFWwindow* window)
 {
     if (_glfw.null.focusedWindow == window)
     {
@@ -320,7 +318,7 @@ void _glfwPlatformIconifyWindow(_GLFWwindow* window)
     }
 }
 
-void _glfwPlatformRestoreWindow(_GLFWwindow* window)
+void _glfwRestoreWindowNull(_GLFWwindow* window)
 {
     if (window->null.iconified)
     {
@@ -337,7 +335,7 @@ void _glfwPlatformRestoreWindow(_GLFWwindow* window)
     }
 }
 
-void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
+void _glfwMaximizeWindowNull(_GLFWwindow* window)
 {
     if (!window->null.maximized)
     {
@@ -346,12 +344,12 @@ void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
     }
 }
 
-int _glfwPlatformWindowMaximized(_GLFWwindow* window)
+int _glfwWindowMaximizedNull(_GLFWwindow* window)
 {
     return window->null.maximized;
 }
 
-int _glfwPlatformWindowHovered(_GLFWwindow* window)
+int _glfwWindowHoveredNull(_GLFWwindow* window)
 {
     return _glfw.null.xcursor >= window->null.xpos &&
            _glfw.null.ycursor >= window->null.ypos &&
@@ -359,59 +357,63 @@ int _glfwPlatformWindowHovered(_GLFWwindow* window)
            _glfw.null.ycursor <= window->null.ypos + window->null.height - 1;
 }
 
-int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
+int _glfwFramebufferTransparentNull(_GLFWwindow* window)
 {
     return window->null.transparent;
 }
 
-void _glfwPlatformSetWindowResizable(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowResizableNull(_GLFWwindow* window, GLFWbool enabled)
 {
     window->null.resizable = enabled;
 }
 
-void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowDecoratedNull(_GLFWwindow* window, GLFWbool enabled)
 {
     window->null.decorated = enabled;
 }
 
-void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowFloatingNull(_GLFWwindow* window, GLFWbool enabled)
 {
     window->null.floating = enabled;
 }
 
-void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowMousePassthroughNull(_GLFWwindow* window, GLFWbool enabled)
 {
 }
 
-float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
+float _glfwGetWindowOpacityNull(_GLFWwindow* window)
 {
     return window->null.opacity;
 }
 
-void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
+void _glfwSetWindowOpacityNull(_GLFWwindow* window, float opacity)
 {
     window->null.opacity = opacity;
 }
 
-void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
+void _glfwSetRawMouseMotionNull(_GLFWwindow *window, GLFWbool enabled)
 {
 }
 
-GLFWbool _glfwPlatformRawMouseMotionSupported(void)
+GLFWbool _glfwRawMouseMotionSupportedNull(void)
 {
     return GLFW_TRUE;
 }
 
-void _glfwPlatformShowWindow(_GLFWwindow* window)
+void _glfwShowWindowNull(_GLFWwindow* window)
 {
     window->null.visible = GLFW_TRUE;
 }
 
-void _glfwPlatformRequestWindowAttention(_GLFWwindow* window)
+void _glfwRequestWindowAttentionNull(_GLFWwindow* window)
+{
+}
+
+void _glfwUnhideWindowNull(_GLFWwindow* window)
 {
 }
 
-void _glfwPlatformHideWindow(_GLFWwindow* window)
+void _glfwHideWindowNull(_GLFWwindow* window)
 {
     if (_glfw.null.focusedWindow == window)
     {
@@ -422,59 +424,61 @@ void _glfwPlatformHideWindow(_GLFWwindow* window)
     window->null.visible = GLFW_FALSE;
 }
 
-void _glfwPlatformFocusWindow(_GLFWwindow* window)
+void _glfwFocusWindowNull(_GLFWwindow* window)
 {
+    _GLFWwindow* previous;
+
     if (_glfw.null.focusedWindow == window)
         return;
 
     if (!window->null.visible)
         return;
 
-    _GLFWwindow* previous = _glfw.null.focusedWindow;
+    previous = _glfw.null.focusedWindow;
     _glfw.null.focusedWindow = window;
 
     if (previous)
     {
         _glfwInputWindowFocus(previous, GLFW_FALSE);
         if (previous->monitor && previous->autoIconify)
-            _glfwPlatformIconifyWindow(previous);
+            _glfwIconifyWindowNull(previous);
     }
 
     _glfwInputWindowFocus(window, GLFW_TRUE);
 }
 
-int _glfwPlatformWindowFocused(_GLFWwindow* window)
+int _glfwWindowFocusedNull(_GLFWwindow* window)
 {
     return _glfw.null.focusedWindow == window;
 }
 
-int _glfwPlatformWindowIconified(_GLFWwindow* window)
+int _glfwWindowIconifiedNull(_GLFWwindow* window)
 {
     return window->null.iconified;
 }
 
-int _glfwPlatformWindowVisible(_GLFWwindow* window)
+int _glfwWindowVisibleNull(_GLFWwindow* window)
 {
     return window->null.visible;
 }
 
-void _glfwPlatformPollEvents(void)
+void _glfwPollEventsNull(void)
 {
 }
 
-void _glfwPlatformWaitEvents(void)
+void _glfwWaitEventsNull(void)
 {
 }
 
-void _glfwPlatformWaitEventsTimeout(double timeout)
+void _glfwWaitEventsTimeoutNull(double timeout)
 {
 }
 
-void _glfwPlatformPostEmptyEvent(void)
+void _glfwPostEmptyEventNull(void)
 {
 }
 
-void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
+void _glfwGetCursorPosNull(_GLFWwindow* window, double* xpos, double* ypos)
 {
     if (xpos)
         *xpos = _glfw.null.xcursor - window->null.xpos;
@@ -482,64 +486,64 @@ void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
         *ypos = _glfw.null.ycursor - window->null.ypos;
 }
 
-void _glfwPlatformSetCursorPos(_GLFWwindow* window, double x, double y)
+void _glfwSetCursorPosNull(_GLFWwindow* window, double x, double y)
 {
     _glfw.null.xcursor = window->null.xpos + (int) x;
     _glfw.null.ycursor = window->null.ypos + (int) y;
 }
 
-void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
+void _glfwSetCursorModeNull(_GLFWwindow* window, int mode)
 {
 }
 
-int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
-                              const GLFWimage* image,
-                              int xhot, int yhot)
+int _glfwCreateCursorNull(_GLFWcursor* cursor,
+                          const GLFWimage* image,
+                          int xhot, int yhot)
 {
     return GLFW_TRUE;
 }
 
-int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
+int _glfwCreateStandardCursorNull(_GLFWcursor* cursor, int shape)
 {
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
+void _glfwDestroyCursorNull(_GLFWcursor* cursor)
 {
 }
 
-void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
+void _glfwSetCursorNull(_GLFWwindow* window, _GLFWcursor* cursor)
 {
 }
 
-void _glfwPlatformSetClipboardString(const char* string)
+void _glfwSetClipboardStringNull(const char* string)
 {
     char* copy = _glfw_strdup(string);
     _glfw_free(_glfw.null.clipboardString);
     _glfw.null.clipboardString = copy;
 }
 
-const char* _glfwPlatformGetClipboardString(void)
+const char* _glfwGetClipboardStringNull(void)
 {
     return _glfw.null.clipboardString;
 }
 
-EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
+EGLenum _glfwGetEGLPlatformNull(EGLint** attribs)
 {
     return 0;
 }
 
-EGLNativeDisplayType _glfwPlatformGetEGLNativeDisplay(void)
+EGLNativeDisplayType _glfwGetEGLNativeDisplayNull(void)
 {
     return 0;
 }
 
-EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window)
+EGLNativeWindowType _glfwGetEGLNativeWindowNull(_GLFWwindow* window)
 {
     return 0;
 }
 
-const char* _glfwPlatformGetScancodeName(int scancode)
+const char* _glfwGetScancodeNameNull(int scancode)
 {
     if (scancode < GLFW_KEY_SPACE || scancode > GLFW_KEY_LAST)
     {
@@ -666,26 +670,26 @@ const char* _glfwPlatformGetScancodeName(int scancode)
     return NULL;
 }
 
-int _glfwPlatformGetKeyScancode(int key)
+int _glfwGetKeyScancodeNull(int key)
 {
     return key;
 }
 
-void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
+void _glfwGetRequiredInstanceExtensionsNull(char** extensions)
 {
 }
 
-int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
-                                                      VkPhysicalDevice device,
-                                                      uint32_t queuefamily)
+int _glfwGetPhysicalDevicePresentationSupportNull(VkInstance instance,
+                                                  VkPhysicalDevice device,
+                                                  uint32_t queuefamily)
 {
     return GLFW_FALSE;
 }
 
-VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
-                                          _GLFWwindow* window,
-                                          const VkAllocationCallbacks* allocator,
-                                          VkSurfaceKHR* surface)
+VkResult _glfwCreateWindowSurfaceNull(VkInstance instance,
+                                      _GLFWwindow* window,
+                                      const VkAllocationCallbacks* allocator,
+                                      VkSurfaceKHR* surface)
 {
     // This seems like the most appropriate error to return here
     return VK_ERROR_EXTENSION_NOT_PRESENT;
diff --git a/src/osmesa_context.c b/src/osmesa_context.c
index 0bae30c9..cf742f89 100644
--- a/src/osmesa_context.c
+++ b/src/osmesa_context.c
@@ -39,7 +39,7 @@ static void makeContextCurrentOSMesa(_GLFWwindow* window)
     if (window)
     {
         int width, height;
-        _glfwPlatformGetFramebufferSize(window, &width, &height);
+        _glfw.platform.getFramebufferSize(window, &width, &height);
 
         // Check to see if we need to allocate a new buffer
         if ((window->context.osmesa.buffer == NULL) ||
diff --git a/src/platform.c b/src/platform.c
new file mode 100644
index 00000000..34fb7acd
--- /dev/null
+++ b/src/platform.c
@@ -0,0 +1,184 @@
+//========================================================================
+// GLFW 3.4 - www.glfw.org
+//------------------------------------------------------------------------
+// Copyright (c) 2002-2006 Marcus Geelnard
+// Copyright (c) 2006-2018 Camilla Lwy <elmindreda@glfw.org>
+//
+// This software is provided 'as-is', without any express or implied
+// warranty. In no event will the authors be held liable for any damages
+// arising from the use of this software.
+//
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+//
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would
+//    be appreciated but is not required.
+//
+// 2. Altered source versions must be plainly marked as such, and must not
+//    be misrepresented as being the original software.
+//
+// 3. This notice may not be removed or altered from any source
+//    distribution.
+//
+//========================================================================
+// Please use C89 style variable declarations in this file because VS 2010
+//========================================================================
+
+#include "internal.h"
+
+//////////////////////////////////////////////////////////////////////////
+//////                       GLFW internal API                      //////
+//////////////////////////////////////////////////////////////////////////
+
+static const struct
+{
+    int ID;
+    GLFWbool (*connect)(int,_GLFWplatform*);
+} supportedPlatforms[] =
+{
+#if defined(_GLFW_WIN32)
+    { GLFW_PLATFORM_WIN32, _glfwConnectWin32 },
+#endif
+#if defined(_GLFW_COCOA)
+    { GLFW_PLATFORM_COCOA, _glfwConnectCocoa },
+#endif
+#if defined(_GLFW_X11)
+    { GLFW_PLATFORM_X11, _glfwConnectX11 },
+#endif
+#if defined(_GLFW_WAYLAND)
+    { GLFW_PLATFORM_WAYLAND, _glfwConnectWayland },
+#endif
+};
+
+GLFWbool _glfwSelectPlatform(int desiredID, _GLFWplatform* platform)
+{
+    const size_t count = sizeof(supportedPlatforms) / sizeof(supportedPlatforms[0]);
+    size_t i;
+
+    if (desiredID != GLFW_ANY_PLATFORM &&
+        desiredID != GLFW_PLATFORM_WIN32 &&
+        desiredID != GLFW_PLATFORM_COCOA &&
+        desiredID != GLFW_PLATFORM_WAYLAND &&
+        desiredID != GLFW_PLATFORM_X11 &&
+        desiredID != GLFW_PLATFORM_NULL)
+    {
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid platform ID 0x%08X", desiredID);
+        return GLFW_FALSE;
+    }
+
+    // Only allow the Null platform if specifically requested
+    if (desiredID == GLFW_PLATFORM_NULL)
+        return _glfwConnectNull(desiredID, platform);
+
+    // If there is only one platform available for auto-selection, let it emit the error
+    // on failure as the platform-specific error description may be more helpful
+    if (desiredID == GLFW_ANY_PLATFORM && count == 1)
+        return supportedPlatforms[0].connect(supportedPlatforms[0].ID, platform);
+
+    for (i = 0;  i < count;  i++)
+    {
+        if (desiredID == GLFW_ANY_PLATFORM || desiredID == supportedPlatforms[i].ID)
+        {
+            if (supportedPlatforms[i].connect(desiredID, platform))
+                return GLFW_TRUE;
+            else if (desiredID == supportedPlatforms[i].ID)
+                return GLFW_FALSE;
+        }
+    }
+
+    if (desiredID == GLFW_ANY_PLATFORM)
+    {
+        if (count)
+            _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "Failed to detect any supported platform");
+        else
+            _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "This binary only supports the Null platform");
+    }
+    else
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "The requested platform is not supported");
+
+    return GLFW_FALSE;
+}
+
+//////////////////////////////////////////////////////////////////////////
+//////                        GLFW public API                       //////
+//////////////////////////////////////////////////////////////////////////
+
+GLFWAPI int glfwGetPlatform(void)
+{
+    _GLFW_REQUIRE_INIT_OR_RETURN(0);
+    return _glfw.platform.platformID;
+}
+
+GLFWAPI int glfwPlatformSupported(int platformID)
+{
+    const size_t count = sizeof(supportedPlatforms) / sizeof(supportedPlatforms[0]);
+    size_t i;
+
+    if (platformID != GLFW_PLATFORM_WIN32 &&
+        platformID != GLFW_PLATFORM_COCOA &&
+        platformID != GLFW_PLATFORM_WAYLAND &&
+        platformID != GLFW_PLATFORM_X11 &&
+        platformID != GLFW_PLATFORM_NULL)
+    {
+        _glfwInputError(GLFW_INVALID_ENUM, "Invalid platform ID 0x%08X", platformID);
+        return GLFW_FALSE;
+    }
+
+    if (platformID == GLFW_PLATFORM_NULL)
+        return GLFW_TRUE;
+
+    for (i = 0;  i < count;  i++)
+    {
+        if (platformID == supportedPlatforms[i].ID)
+            return GLFW_TRUE;
+    }
+
+    return GLFW_FALSE;
+}
+
+GLFWAPI const char* glfwGetVersionString(void)
+{
+    return _GLFW_VERSION_NUMBER
+#if defined(_GLFW_WIN32)
+        " Win32 WGL"
+#endif
+#if defined(_GLFW_COCOA)
+        " Cocoa NSGL"
+#endif
+#if defined(_GLFW_WAYLAND)
+        " Wayland"
+#endif
+#if defined(_GLFW_X11)
+        " X11 GLX"
+#endif
+        " Null"
+        " EGL"
+        " OSMesa"
+#if defined(__MINGW64_VERSION_MAJOR)
+        " MinGW-w64"
+#elif defined(__MINGW32__)
+        " MinGW"
+#elif defined(_MSC_VER)
+        " VisualC"
+#endif
+#if defined(_GLFW_USE_HYBRID_HPG) || defined(_GLFW_USE_OPTIMUS_HPG)
+        " hybrid-GPU"
+#endif
+#if defined(_POSIX_MONOTONIC_CLOCK)
+        " monotonic"
+#endif
+#if defined(_GLFW_BUILD_DLL)
+#if defined(_WIN32)
+        " DLL"
+#elif defined(__APPLE__)
+        " dynamic"
+#else
+        " shared"
+#endif
+#endif
+        ;
+}
+
diff --git a/src/platform.h b/src/platform.h
new file mode 100644
index 00000000..cc842eb8
--- /dev/null
+++ b/src/platform.h
@@ -0,0 +1,179 @@
+//========================================================================
+// GLFW 3.4 - www.glfw.org
+//------------------------------------------------------------------------
+// Copyright (c) 2002-2006 Marcus Geelnard
+// Copyright (c) 2006-2018 Camilla Lwy <elmindreda@glfw.org>
+//
+// This software is provided 'as-is', without any express or implied
+// warranty. In no event will the authors be held liable for any damages
+// arising from the use of this software.
+//
+// Permission is granted to anyone to use this software for any purpose,
+// including commercial applications, and to alter it and redistribute it
+// freely, subject to the following restrictions:
+//
+// 1. The origin of this software must not be misrepresented; you must not
+//    claim that you wrote the original software. If you use this software
+//    in a product, an acknowledgment in the product documentation would
+//    be appreciated but is not required.
+//
+// 2. Altered source versions must be plainly marked as such, and must not
+//    be misrepresented as being the original software.
+//
+// 3. This notice may not be removed or altered from any source
+//    distribution.
+//
+//========================================================================
+
+#include "null_platform.h"
+
+#if defined(_GLFW_WIN32)
+ #include "win32_platform.h"
+#else
+ #define GLFW_WIN32_WINDOW_STATE
+ #define GLFW_WIN32_MONITOR_STATE
+ #define GLFW_WIN32_CURSOR_STATE
+ #define GLFW_WIN32_LIBRARY_WINDOW_STATE
+ #define GLFW_WGL_CONTEXT_STATE
+ #define GLFW_WGL_LIBRARY_CONTEXT_STATE
+#endif
+
+#if defined(_GLFW_COCOA)
+ #include "cocoa_platform.h"
+#else
+ #define GLFW_COCOA_WINDOW_STATE
+ #define GLFW_COCOA_MONITOR_STATE
+ #define GLFW_COCOA_CURSOR_STATE
+ #define GLFW_COCOA_LIBRARY_WINDOW_STATE
+ #define GLFW_NSGL_CONTEXT_STATE
+ #define GLFW_NSGL_LIBRARY_CONTEXT_STATE
+#endif
+
+#if defined(_GLFW_WAYLAND)
+ #include "wl_platform.h"
+#else
+ #define GLFW_WAYLAND_WINDOW_STATE
+ #define GLFW_WAYLAND_MONITOR_STATE
+ #define GLFW_WAYLAND_CURSOR_STATE
+ #define GLFW_WAYLAND_LIBRARY_WINDOW_STATE
+#endif
+
+#if defined(_GLFW_X11)
+ #include "x11_platform.h"
+#else
+ #define GLFW_X11_WINDOW_STATE
+ #define GLFW_X11_MONITOR_STATE
+ #define GLFW_X11_CURSOR_STATE
+ #define GLFW_X11_LIBRARY_WINDOW_STATE
+ #define GLFW_GLX_CONTEXT_STATE
+ #define GLFW_GLX_LIBRARY_CONTEXT_STATE
+#endif
+
+#include "null_joystick.h"
+
+#if defined(_GLFW_WIN32)
+ #include "win32_joystick.h"
+#else
+ #define GLFW_WIN32_JOYSTICK_STATE
+ #define GLFW_WIN32_LIBRARY_JOYSTICK_STATE
+#endif
+
+#if defined(_GLFW_COCOA)
+ #include "cocoa_joystick.h"
+#else
+ #define GLFW_COCOA_JOYSTICK_STATE
+ #define GLFW_COCOA_LIBRARY_JOYSTICK_STATE
+#endif
+
+#if (defined(_GLFW_X11) || defined(_GLFW_WAYLAND)) && defined(__linux__)
+ #include "linux_joystick.h"
+#else
+ #define GLFW_LINUX_JOYSTICK_STATE
+ #define GLFW_LINUX_LIBRARY_JOYSTICK_STATE
+#endif
+
+#if defined(_WIN32)
+ #include "win32_thread.h"
+ #define GLFW_POSIX_TLS_STATE
+ #define GLFW_POSIX_MUTEX_STATE
+#else
+ #include "posix_thread.h"
+ #define GLFW_WIN32_TLS_STATE
+ #define GLFW_WIN32_MUTEX_STATE
+#endif
+
+#if defined(_WIN32)
+ #include "win32_time.h"
+ #define GLFW_POSIX_LIBRARY_TIMER_STATE
+ #define GLFW_COCOA_LIBRARY_TIMER_STATE
+#elif defined(__APPLE__)
+ #include "cocoa_time.h"
+ #define GLFW_WIN32_LIBRARY_TIMER_STATE
+ #define GLFW_POSIX_LIBRARY_TIMER_STATE
+#else
+ #include "posix_time.h"
+ #define GLFW_WIN32_LIBRARY_TIMER_STATE
+ #define GLFW_COCOA_LIBRARY_TIMER_STATE
+#endif
+
+#define GLFW_PLATFORM_WINDOW_STATE \
+        GLFW_WIN32_WINDOW_STATE \
+        GLFW_COCOA_WINDOW_STATE \
+        GLFW_WAYLAND_WINDOW_STATE \
+        GLFW_X11_WINDOW_STATE \
+        GLFW_NULL_WINDOW_STATE \
+
+#define GLFW_PLATFORM_MONITOR_STATE \
+        GLFW_WIN32_MONITOR_STATE \
+        GLFW_COCOA_MONITOR_STATE \
+        GLFW_WAYLAND_MONITOR_STATE \
+        GLFW_X11_MONITOR_STATE \
+        GLFW_NULL_MONITOR_STATE \
+
+#define GLFW_PLATFORM_CURSOR_STATE \
+        GLFW_WIN32_CURSOR_STATE \
+        GLFW_COCOA_CURSOR_STATE \
+        GLFW_WAYLAND_CURSOR_STATE \
+        GLFW_X11_CURSOR_STATE \
+        GLFW_NULL_CURSOR_STATE \
+
+#define GLFW_PLATFORM_JOYSTICK_STATE \
+        GLFW_WIN32_JOYSTICK_STATE \
+        GLFW_COCOA_JOYSTICK_STATE \
+        GLFW_LINUX_JOYSTICK_STATE
+
+#define GLFW_PLATFORM_TLS_STATE \
+        GLFW_WIN32_TLS_STATE \
+        GLFW_POSIX_TLS_STATE \
+
+#define GLFW_PLATFORM_MUTEX_STATE \
+        GLFW_WIN32_MUTEX_STATE \
+        GLFW_POSIX_MUTEX_STATE \
+
+#define GLFW_PLATFORM_LIBRARY_WINDOW_STATE \
+        GLFW_WIN32_LIBRARY_WINDOW_STATE \
+        GLFW_COCOA_LIBRARY_WINDOW_STATE \
+        GLFW_WAYLAND_LIBRARY_WINDOW_STATE \
+        GLFW_X11_LIBRARY_WINDOW_STATE \
+        GLFW_NULL_LIBRARY_WINDOW_STATE \
+
+#define GLFW_PLATFORM_LIBRARY_JOYSTICK_STATE \
+        GLFW_WIN32_LIBRARY_JOYSTICK_STATE \
+        GLFW_COCOA_LIBRARY_JOYSTICK_STATE \
+        GLFW_LINUX_LIBRARY_JOYSTICK_STATE
+
+#define GLFW_PLATFORM_LIBRARY_TIMER_STATE \
+        GLFW_WIN32_LIBRARY_TIMER_STATE \
+        GLFW_COCOA_LIBRARY_TIMER_STATE \
+        GLFW_POSIX_LIBRARY_TIMER_STATE \
+
+#define GLFW_PLATFORM_CONTEXT_STATE \
+        GLFW_WGL_CONTEXT_STATE \
+        GLFW_NSGL_CONTEXT_STATE \
+        GLFW_GLX_CONTEXT_STATE
+
+#define GLFW_PLATFORM_LIBRARY_CONTEXT_STATE \
+        GLFW_WGL_LIBRARY_CONTEXT_STATE \
+        GLFW_NSGL_LIBRARY_CONTEXT_STATE \
+        GLFW_GLX_LIBRARY_CONTEXT_STATE
+
diff --git a/src/posix_thread.h b/src/posix_thread.h
index bfb325af..5a5d7b7c 100644
--- a/src/posix_thread.h
+++ b/src/posix_thread.h
@@ -27,8 +27,8 @@
 
 #include <pthread.h>
 
-#define _GLFW_PLATFORM_TLS_STATE    _GLFWtlsPOSIX   posix
-#define _GLFW_PLATFORM_MUTEX_STATE  _GLFWmutexPOSIX posix
+#define GLFW_POSIX_TLS_STATE    _GLFWtlsPOSIX   posix;
+#define GLFW_POSIX_MUTEX_STATE  _GLFWmutexPOSIX posix;
 
 
 // POSIX-specific thread local storage data
diff --git a/src/posix_time.h b/src/posix_time.h
index 6fd15b06..94374adb 100644
--- a/src/posix_time.h
+++ b/src/posix_time.h
@@ -25,7 +25,7 @@
 //
 //========================================================================
 
-#define _GLFW_PLATFORM_LIBRARY_TIMER_STATE _GLFWtimerPOSIX posix
+#define GLFW_POSIX_LIBRARY_TIMER_STATE _GLFWtimerPOSIX posix;
 
 #include <stdint.h>
 #include <time.h>
diff --git a/src/vulkan.c b/src/vulkan.c
index ad299e5e..51789249 100644
--- a/src/vulkan.c
+++ b/src/vulkan.c
@@ -58,7 +58,7 @@ GLFWbool _glfwInitVulkan(int mode)
 #elif defined(_GLFW_COCOA)
     _glfw.vk.handle = _glfwPlatformLoadModule("libvulkan.1.dylib");
     if (!_glfw.vk.handle)
-        _glfw.vk.handle = _glfwLoadLocalVulkanLoaderNS();
+        _glfw.vk.handle = _glfwLoadLocalVulkanLoaderCocoa();
 #else
     _glfw.vk.handle = _glfwPlatformLoadModule("libvulkan.so.1");
 #endif
@@ -126,30 +126,25 @@ GLFWbool _glfwInitVulkan(int mode)
     {
         if (strcmp(ep[i].extensionName, "VK_KHR_surface") == 0)
             _glfw.vk.KHR_surface = GLFW_TRUE;
-#if defined(_GLFW_WIN32)
         else if (strcmp(ep[i].extensionName, "VK_KHR_win32_surface") == 0)
             _glfw.vk.KHR_win32_surface = GLFW_TRUE;
-#elif defined(_GLFW_COCOA)
         else if (strcmp(ep[i].extensionName, "VK_MVK_macos_surface") == 0)
             _glfw.vk.MVK_macos_surface = GLFW_TRUE;
         else if (strcmp(ep[i].extensionName, "VK_EXT_metal_surface") == 0)
             _glfw.vk.EXT_metal_surface = GLFW_TRUE;
-#elif defined(_GLFW_X11)
         else if (strcmp(ep[i].extensionName, "VK_KHR_xlib_surface") == 0)
             _glfw.vk.KHR_xlib_surface = GLFW_TRUE;
         else if (strcmp(ep[i].extensionName, "VK_KHR_xcb_surface") == 0)
             _glfw.vk.KHR_xcb_surface = GLFW_TRUE;
-#elif defined(_GLFW_WAYLAND)
         else if (strcmp(ep[i].extensionName, "VK_KHR_wayland_surface") == 0)
             _glfw.vk.KHR_wayland_surface = GLFW_TRUE;
-#endif
     }
 
     _glfw_free(ep);
 
     _glfw.vk.available = GLFW_TRUE;
 
-    _glfwPlatformGetRequiredInstanceExtensions(_glfw.vk.extensions);
+    _glfw.platform.getRequiredInstanceExtensions(_glfw.vk.extensions);
 
     return GLFW_TRUE;
 }
@@ -291,9 +286,9 @@ GLFWAPI int glfwGetPhysicalDevicePresentationSupport(VkInstance instance,
         return GLFW_FALSE;
     }
 
-    return _glfwPlatformGetPhysicalDevicePresentationSupport(instance,
-                                                             device,
-                                                             queuefamily);
+    return _glfw.platform.getPhysicalDevicePresentationSupport(instance,
+                                                               device,
+                                                               queuefamily);
 }
 
 GLFWAPI VkResult glfwCreateWindowSurface(VkInstance instance,
@@ -327,6 +322,6 @@ GLFWAPI VkResult glfwCreateWindowSurface(VkInstance instance,
         return VK_ERROR_NATIVE_WINDOW_IN_USE_KHR;
     }
 
-    return _glfwPlatformCreateWindowSurface(instance, window, allocator, surface);
+    return _glfw.platform.createWindowSurface(instance, window, allocator, surface);
 }
 
diff --git a/src/wgl_context.c b/src/wgl_context.c
index a7b3ec7b..774f45bd 100644
--- a/src/wgl_context.c
+++ b/src/wgl_context.c
@@ -34,10 +34,10 @@
 
 // Return the value corresponding to the specified attribute
 //
-static int findPixelFormatAttribValue(const int* attribs,
-                                      int attribCount,
-                                      const int* values,
-                                      int attrib)
+static int findPixelFormatAttribValueWGL(const int* attribs,
+                                         int attribCount,
+                                         const int* values,
+                                         int attrib)
 {
     int i;
 
@@ -58,13 +58,13 @@ static int findPixelFormatAttribValue(const int* attribs,
     attribs[attribCount++] = a; \
 }
 #define findAttribValue(a) \
-    findPixelFormatAttribValue(attribs, attribCount, values, a)
+    findPixelFormatAttribValueWGL(attribs, attribCount, values, a)
 
 // Return a list of available and usable framebuffer configs
 //
-static int choosePixelFormat(_GLFWwindow* window,
-                             const _GLFWctxconfig* ctxconfig,
-                             const _GLFWfbconfig* fbconfig)
+static int choosePixelFormatWGL(_GLFWwindow* window,
+                                const _GLFWctxconfig* ctxconfig,
+                                const _GLFWfbconfig* fbconfig)
 {
     _GLFWfbconfig* usableConfigs;
     const _GLFWfbconfig* closest;
@@ -399,11 +399,6 @@ static void destroyContextWGL(_GLFWwindow* window)
     }
 }
 
-
-//////////////////////////////////////////////////////////////////////////
-//////                       GLFW internal API                      //////
-//////////////////////////////////////////////////////////////////////////
-
 // Initialize WGL
 //
 GLFWbool _glfwInitWGL(void)
@@ -561,7 +556,7 @@ GLFWbool _glfwCreateContextWGL(_GLFWwindow* window,
         return GLFW_FALSE;
     }
 
-    pixelFormat = choosePixelFormat(window, ctxconfig, fbconfig);
+    pixelFormat = choosePixelFormatWGL(window, ctxconfig, fbconfig);
     if (!pixelFormat)
         return GLFW_FALSE;
 
@@ -776,16 +771,18 @@ GLFWbool _glfwCreateContextWGL(_GLFWwindow* window,
 
 #undef setAttrib
 
-
-//////////////////////////////////////////////////////////////////////////
-//////                        GLFW native API                       //////
-//////////////////////////////////////////////////////////////////////////
-
 GLFWAPI HGLRC glfwGetWGLContext(GLFWwindow* handle)
 {
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
 
+    if (_glfw.platform.platformID != GLFW_PLATFORM_WIN32)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                        "WGL: Platform not initialized");
+        return NULL;
+    }
+
     if (window->context.client != GLFW_NATIVE_CONTEXT_API)
     {
         _glfwInputError(GLFW_NO_WINDOW_CONTEXT, NULL);
diff --git a/src/win32_init.c b/src/win32_init.c
index 3441173f..e687d770 100644
--- a/src/win32_init.c
+++ b/src/win32_init.c
@@ -536,12 +536,89 @@ BOOL _glfwIsWindows10BuildOrGreaterWin32(WORD build)
     return RtlVerifyVersionInfo(&osvi, mask, cond) == 0;
 }
 
+GLFWbool _glfwConnectWin32(int platformID, _GLFWplatform* platform)
+{
+    const _GLFWplatform win32 =
+    {
+        GLFW_PLATFORM_WIN32,
+        _glfwInitWin32,
+        _glfwTerminateWin32,
+        _glfwGetCursorPosWin32,
+        _glfwSetCursorPosWin32,
+        _glfwSetCursorModeWin32,
+        _glfwSetRawMouseMotionWin32,
+        _glfwRawMouseMotionSupportedWin32,
+        _glfwCreateCursorWin32,
+        _glfwCreateStandardCursorWin32,
+        _glfwDestroyCursorWin32,
+        _glfwSetCursorWin32,
+        _glfwGetScancodeNameWin32,
+        _glfwGetKeyScancodeWin32,
+        _glfwSetClipboardStringWin32,
+        _glfwGetClipboardStringWin32,
+        _glfwInitJoysticksWin32,
+        _glfwTerminateJoysticksWin32,
+        _glfwPollJoystickWin32,
+        _glfwGetMappingNameWin32,
+        _glfwUpdateGamepadGUIDWin32,
+        _glfwFreeMonitorWin32,
+        _glfwGetMonitorPosWin32,
+        _glfwGetMonitorContentScaleWin32,
+        _glfwGetMonitorWorkareaWin32,
+        _glfwGetVideoModesWin32,
+        _glfwGetVideoModeWin32,
+        _glfwGetGammaRampWin32,
+        _glfwSetGammaRampWin32,
+        _glfwCreateWindowWin32,
+        _glfwDestroyWindowWin32,
+        _glfwSetWindowTitleWin32,
+        _glfwSetWindowIconWin32,
+        _glfwGetWindowPosWin32,
+        _glfwSetWindowPosWin32,
+        _glfwGetWindowSizeWin32,
+        _glfwSetWindowSizeWin32,
+        _glfwSetWindowSizeLimitsWin32,
+        _glfwSetWindowAspectRatioWin32,
+        _glfwGetFramebufferSizeWin32,
+        _glfwGetWindowFrameSizeWin32,
+        _glfwGetWindowContentScaleWin32,
+        _glfwIconifyWindowWin32,
+        _glfwRestoreWindowWin32,
+        _glfwMaximizeWindowWin32,
+        _glfwShowWindowWin32,
+        _glfwHideWindowWin32,
+        _glfwRequestWindowAttentionWin32,
+        _glfwFocusWindowWin32,
+        _glfwSetWindowMonitorWin32,
+        _glfwWindowFocusedWin32,
+        _glfwWindowIconifiedWin32,
+        _glfwWindowVisibleWin32,
+        _glfwWindowMaximizedWin32,
+        _glfwWindowHoveredWin32,
+        _glfwFramebufferTransparentWin32,
+        _glfwGetWindowOpacityWin32,
+        _glfwSetWindowResizableWin32,
+        _glfwSetWindowDecoratedWin32,
+        _glfwSetWindowFloatingWin32,
+        _glfwSetWindowOpacityWin32,
+        _glfwSetWindowMousePassthroughWin32,
+        _glfwPollEventsWin32,
+        _glfwWaitEventsWin32,
+        _glfwWaitEventsTimeoutWin32,
+        _glfwPostEmptyEventWin32,
+        _glfwGetEGLPlatformWin32,
+        _glfwGetEGLNativeDisplayWin32,
+        _glfwGetEGLNativeWindowWin32,
+        _glfwGetRequiredInstanceExtensionsWin32,
+        _glfwGetPhysicalDevicePresentationSupportWin32,
+        _glfwCreateWindowSurfaceWin32,
+    };
+
+    *platform = win32;
+    return GLFW_TRUE;
+}
 
-//////////////////////////////////////////////////////////////////////////
-//////                       GLFW platform API                      //////
-//////////////////////////////////////////////////////////////////////////
-
-int _glfwPlatformInit(void)
+int _glfwInitWin32(void)
 {
     if (!loadLibraries())
         return GLFW_FALSE;
@@ -566,7 +643,7 @@ int _glfwPlatformInit(void)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminate(void)
+void _glfwTerminateWin32(void)
 {
     if (_glfw.win32.deviceNotificationHandle)
         UnregisterDeviceNotification(_glfw.win32.deviceNotificationHandle);
@@ -585,22 +662,3 @@ void _glfwPlatformTerminate(void)
     freeLibraries();
 }
 
-const char* _glfwPlatformGetVersionString(void)
-{
-    return _GLFW_VERSION_NUMBER " Win32 WGL EGL OSMesa"
-#if defined(__MINGW64_VERSION_MAJOR)
-        " MinGW-w64"
-#elif defined(__MINGW32__)
-        " MinGW"
-#elif defined(_MSC_VER)
-        " VisualC"
-#endif
-#if defined(_GLFW_USE_HYBRID_HPG) || defined(_GLFW_USE_OPTIMUS_HPG)
-        " hybrid-GPU"
-#endif
-#if defined(_GLFW_BUILD_DLL)
-        " DLL"
-#endif
-        ;
-}
-
diff --git a/src/win32_joystick.c b/src/win32_joystick.c
index bb5ed1a3..e45e0798 100644
--- a/src/win32_joystick.c
+++ b/src/win32_joystick.c
@@ -561,7 +561,7 @@ void _glfwDetectJoystickDisconnectionWin32(void)
     {
         _GLFWjoystick* js = _glfw.joysticks + jid;
         if (js->present)
-            _glfwPlatformPollJoystick(js, _GLFW_POLL_PRESENCE);
+            _glfwPollJoystickWin32(js, _GLFW_POLL_PRESENCE);
     }
 }
 
@@ -570,7 +570,7 @@ void _glfwDetectJoystickDisconnectionWin32(void)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-GLFWbool _glfwPlatformInitJoysticks(void)
+GLFWbool _glfwInitJoysticksWin32(void)
 {
     if (_glfw.win32.dinput8.instance)
     {
@@ -590,7 +590,7 @@ GLFWbool _glfwPlatformInitJoysticks(void)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminateJoysticks(void)
+void _glfwTerminateJoysticksWin32(void)
 {
     int jid;
 
@@ -601,7 +601,7 @@ void _glfwPlatformTerminateJoysticks(void)
         IDirectInput8_Release(_glfw.win32.dinput8.api);
 }
 
-int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode)
+int _glfwPollJoystickWin32(_GLFWjoystick* js, int mode)
 {
     if (js->win32.device)
     {
@@ -740,12 +740,12 @@ int _glfwPlatformPollJoystick(_GLFWjoystick* js, int mode)
     return GLFW_TRUE;
 }
 
-const char* _glfwPlatformGetMappingName(void)
+const char* _glfwGetMappingNameWin32(void)
 {
     return "Windows";
 }
 
-void _glfwPlatformUpdateGamepadGUID(char* guid)
+void _glfwUpdateGamepadGUIDWin32(char* guid)
 {
     if (strcmp(guid + 20, "504944564944") == 0)
     {
diff --git a/src/win32_joystick.h b/src/win32_joystick.h
index b9bb6779..d7c2bb6f 100644
--- a/src/win32_joystick.h
+++ b/src/win32_joystick.h
@@ -24,8 +24,8 @@
 //
 //========================================================================
 
-#define _GLFW_PLATFORM_JOYSTICK_STATE         _GLFWjoystickWin32 win32
-#define _GLFW_PLATFORM_LIBRARY_JOYSTICK_STATE struct { int dummyLibraryJoystick; }
+#define GLFW_WIN32_JOYSTICK_STATE         _GLFWjoystickWin32 win32;
+#define GLFW_WIN32_LIBRARY_JOYSTICK_STATE
 
 #define GLFW_BUILD_WIN32_MAPPINGS
 
diff --git a/src/win32_monitor.c b/src/win32_monitor.c
index 10e3d282..17359a5f 100644
--- a/src/win32_monitor.c
+++ b/src/win32_monitor.c
@@ -253,7 +253,7 @@ void _glfwSetVideoModeWin32(_GLFWmonitor* monitor, const GLFWvidmode* desired)
     LONG result;
 
     best = _glfwChooseVideoMode(monitor, desired);
-    _glfwPlatformGetVideoMode(monitor, &current);
+    _glfwGetVideoModeWin32(monitor, &current);
     if (_glfwCompareVideoModes(&current, best) == 0)
         return;
 
@@ -313,7 +313,7 @@ void _glfwRestoreVideoModeWin32(_GLFWmonitor* monitor)
     }
 }
 
-void _glfwGetMonitorContentScaleWin32(HMONITOR handle, float* xscale, float* yscale)
+void _glfwGetHMONITORContentScaleWin32(HMONITOR handle, float* xscale, float* yscale)
 {
     UINT xdpi, ydpi;
 
@@ -338,11 +338,11 @@ void _glfwGetMonitorContentScaleWin32(HMONITOR handle, float* xscale, float* ysc
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-void _glfwPlatformFreeMonitor(_GLFWmonitor* monitor)
+void _glfwFreeMonitorWin32(_GLFWmonitor* monitor)
 {
 }
 
-void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
+void _glfwGetMonitorPosWin32(_GLFWmonitor* monitor, int* xpos, int* ypos)
 {
     DEVMODEW dm;
     ZeroMemory(&dm, sizeof(dm));
@@ -359,15 +359,15 @@ void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
         *ypos = dm.dmPosition.y;
 }
 
-void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
-                                         float* xscale, float* yscale)
+void _glfwGetMonitorContentScaleWin32(_GLFWmonitor* monitor,
+                                      float* xscale, float* yscale)
 {
-    _glfwGetMonitorContentScaleWin32(monitor->win32.handle, xscale, yscale);
+    _glfwGetHMONITORContentScaleWin32(monitor->win32.handle, xscale, yscale);
 }
 
-void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
-                                     int* xpos, int* ypos,
-                                     int* width, int* height)
+void _glfwGetMonitorWorkareaWin32(_GLFWmonitor* monitor,
+                                  int* xpos, int* ypos,
+                                  int* width, int* height)
 {
     MONITORINFO mi = { sizeof(mi) };
     GetMonitorInfo(monitor->win32.handle, &mi);
@@ -382,7 +382,7 @@ void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
         *height = mi.rcWork.bottom - mi.rcWork.top;
 }
 
-GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count)
+GLFWvidmode* _glfwGetVideoModesWin32(_GLFWmonitor* monitor, int* count)
 {
     int modeIndex = 0, size = 0;
     GLFWvidmode* result = NULL;
@@ -452,14 +452,14 @@ GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count)
     {
         // HACK: Report the current mode if no valid modes were found
         result = _glfw_calloc(1, sizeof(GLFWvidmode));
-        _glfwPlatformGetVideoMode(monitor, result);
+        _glfwGetVideoModeWin32(monitor, result);
         *count = 1;
     }
 
     return result;
 }
 
-void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
+void _glfwGetVideoModeWin32(_GLFWmonitor* monitor, GLFWvidmode* mode)
 {
     DEVMODEW dm;
     ZeroMemory(&dm, sizeof(dm));
@@ -476,7 +476,7 @@ void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
                   &mode->blueBits);
 }
 
-GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
+GLFWbool _glfwGetGammaRampWin32(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
 {
     HDC dc;
     WORD values[3][256];
@@ -494,7 +494,7 @@ GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
+void _glfwSetGammaRampWin32(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
 {
     HDC dc;
     WORD values[3][256];
diff --git a/src/win32_platform.h b/src/win32_platform.h
index cfea35b5..20e40d74 100644
--- a/src/win32_platform.h
+++ b/src/win32_platform.h
@@ -352,21 +352,17 @@ typedef struct VkWin32SurfaceCreateInfoKHR
 typedef VkResult (APIENTRY *PFN_vkCreateWin32SurfaceKHR)(VkInstance,const VkWin32SurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);
 typedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR)(VkPhysicalDevice,uint32_t);
 
-#include "win32_time.h"
-#include "win32_thread.h"
-#include "win32_joystick.h"
-
 #if !defined(_GLFW_WNDCLASSNAME)
  #define _GLFW_WNDCLASSNAME L"GLFW30"
 #endif
 
-#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWin32  win32
-#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWin32 win32
-#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWin32 win32
-#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWin32  win32
+#define GLFW_WIN32_WINDOW_STATE         _GLFWwindowWin32  win32;
+#define GLFW_WIN32_LIBRARY_WINDOW_STATE _GLFWlibraryWin32 win32;
+#define GLFW_WIN32_MONITOR_STATE        _GLFWmonitorWin32 win32;
+#define GLFW_WIN32_CURSOR_STATE         _GLFWcursorWin32  win32;
 
-#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextWGL wgl
-#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryWGL wgl
+#define GLFW_WGL_CONTEXT_STATE          _GLFWcontextWGL wgl;
+#define GLFW_WGL_LIBRARY_CONTEXT_STATE  _GLFWlibraryWGL wgl;
 
 
 // WGL-specific per-context data
@@ -519,6 +515,10 @@ typedef struct _GLFWcursorWin32
 } _GLFWcursorWin32;
 
 
+GLFWbool _glfwConnectWin32(int platformID, _GLFWplatform* platform);
+int _glfwInitWin32(void);
+void _glfwTerminateWin32(void);
+
 GLFWbool _glfwRegisterWindowClassWin32(void);
 void _glfwUnregisterWindowClassWin32(void);
 
@@ -532,7 +532,84 @@ void _glfwUpdateKeyNamesWin32(void);
 void _glfwPollMonitorsWin32(void);
 void _glfwSetVideoModeWin32(_GLFWmonitor* monitor, const GLFWvidmode* desired);
 void _glfwRestoreVideoModeWin32(_GLFWmonitor* monitor);
-void _glfwGetMonitorContentScaleWin32(HMONITOR handle, float* xscale, float* yscale);
+void _glfwGetHMONITORContentScaleWin32(HMONITOR handle, float* xscale, float* yscale);
+
+int _glfwCreateWindowWin32(_GLFWwindow* window, const _GLFWwndconfig* wndconfig, const _GLFWctxconfig* ctxconfig, const _GLFWfbconfig* fbconfig);
+void _glfwDestroyWindowWin32(_GLFWwindow* window);
+void _glfwSetWindowTitleWin32(_GLFWwindow* window, const char* title);
+void _glfwSetWindowIconWin32(_GLFWwindow* window, int count, const GLFWimage* images);
+void _glfwGetWindowPosWin32(_GLFWwindow* window, int* xpos, int* ypos);
+void _glfwSetWindowPosWin32(_GLFWwindow* window, int xpos, int ypos);
+void _glfwGetWindowSizeWin32(_GLFWwindow* window, int* width, int* height);
+void _glfwSetWindowSizeWin32(_GLFWwindow* window, int width, int height);
+void _glfwSetWindowSizeLimitsWin32(_GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
+void _glfwSetWindowAspectRatioWin32(_GLFWwindow* window, int numer, int denom);
+void _glfwGetFramebufferSizeWin32(_GLFWwindow* window, int* width, int* height);
+void _glfwGetWindowFrameSizeWin32(_GLFWwindow* window, int* left, int* top, int* right, int* bottom);
+void _glfwGetWindowContentScaleWin32(_GLFWwindow* window, float* xscale, float* yscale);
+void _glfwIconifyWindowWin32(_GLFWwindow* window);
+void _glfwRestoreWindowWin32(_GLFWwindow* window);
+void _glfwMaximizeWindowWin32(_GLFWwindow* window);
+void _glfwShowWindowWin32(_GLFWwindow* window);
+void _glfwHideWindowWin32(_GLFWwindow* window);
+void _glfwRequestWindowAttentionWin32(_GLFWwindow* window);
+void _glfwFocusWindowWin32(_GLFWwindow* window);
+void _glfwSetWindowMonitorWin32(_GLFWwindow* window, _GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
+int _glfwWindowFocusedWin32(_GLFWwindow* window);
+int _glfwWindowIconifiedWin32(_GLFWwindow* window);
+int _glfwWindowVisibleWin32(_GLFWwindow* window);
+int _glfwWindowMaximizedWin32(_GLFWwindow* window);
+int _glfwWindowHoveredWin32(_GLFWwindow* window);
+int _glfwFramebufferTransparentWin32(_GLFWwindow* window);
+void _glfwSetWindowResizableWin32(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowDecoratedWin32(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowFloatingWin32(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowMousePassthroughWin32(_GLFWwindow* window, GLFWbool enabled);
+float _glfwGetWindowOpacityWin32(_GLFWwindow* window);
+void _glfwSetWindowOpacityWin32(_GLFWwindow* window, float opacity);
+
+void _glfwSetRawMouseMotionWin32(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwRawMouseMotionSupportedWin32(void);
+
+void _glfwPollEventsWin32(void);
+void _glfwWaitEventsWin32(void);
+void _glfwWaitEventsTimeoutWin32(double timeout);
+void _glfwPostEmptyEventWin32(void);
+
+void _glfwGetCursorPosWin32(_GLFWwindow* window, double* xpos, double* ypos);
+void _glfwSetCursorPosWin32(_GLFWwindow* window, double xpos, double ypos);
+void _glfwSetCursorModeWin32(_GLFWwindow* window, int mode);
+const char* _glfwGetScancodeNameWin32(int scancode);
+int _glfwGetKeyScancodeWin32(int key);
+int _glfwCreateCursorWin32(_GLFWcursor* cursor, const GLFWimage* image, int xhot, int yhot);
+int _glfwCreateStandardCursorWin32(_GLFWcursor* cursor, int shape);
+void _glfwDestroyCursorWin32(_GLFWcursor* cursor);
+void _glfwSetCursorWin32(_GLFWwindow* window, _GLFWcursor* cursor);
+void _glfwSetClipboardStringWin32(const char* string);
+const char* _glfwGetClipboardStringWin32(void);
+
+EGLenum _glfwGetEGLPlatformWin32(EGLint** attribs);
+EGLNativeDisplayType _glfwGetEGLNativeDisplayWin32(void);
+EGLNativeWindowType _glfwGetEGLNativeWindowWin32(_GLFWwindow* window);
+
+void _glfwGetRequiredInstanceExtensionsWin32(char** extensions);
+int _glfwGetPhysicalDevicePresentationSupportWin32(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily);
+VkResult _glfwCreateWindowSurfaceWin32(VkInstance instance, _GLFWwindow* window, const VkAllocationCallbacks* allocator, VkSurfaceKHR* surface);
+
+void _glfwFreeMonitorWin32(_GLFWmonitor* monitor);
+void _glfwGetMonitorPosWin32(_GLFWmonitor* monitor, int* xpos, int* ypos);
+void _glfwGetMonitorContentScaleWin32(_GLFWmonitor* monitor, float* xscale, float* yscale);
+void _glfwGetMonitorWorkareaWin32(_GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
+GLFWvidmode* _glfwGetVideoModesWin32(_GLFWmonitor* monitor, int* count);
+void _glfwGetVideoModeWin32(_GLFWmonitor* monitor, GLFWvidmode* mode);
+GLFWbool _glfwGetGammaRampWin32(_GLFWmonitor* monitor, GLFWgammaramp* ramp);
+void _glfwSetGammaRampWin32(_GLFWmonitor* monitor, const GLFWgammaramp* ramp);
+
+GLFWbool _glfwInitJoysticksWin32(void);
+void _glfwTerminateJoysticksWin32(void);
+int _glfwPollJoystickWin32(_GLFWjoystick* js, int mode);
+const char* _glfwGetMappingNameWin32(void);
+void _glfwUpdateGamepadGUIDWin32(char* guid);
 
 GLFWbool _glfwInitWGL(void);
 void _glfwTerminateWGL(void);
diff --git a/src/win32_thread.h b/src/win32_thread.h
index afc8f546..4b5a696f 100644
--- a/src/win32_thread.h
+++ b/src/win32_thread.h
@@ -27,8 +27,8 @@
 
 #include <windows.h>
 
-#define _GLFW_PLATFORM_TLS_STATE            _GLFWtlsWin32     win32
-#define _GLFW_PLATFORM_MUTEX_STATE          _GLFWmutexWin32   win32
+#define GLFW_WIN32_TLS_STATE            _GLFWtlsWin32     win32;
+#define GLFW_WIN32_MUTEX_STATE          _GLFWmutexWin32   win32;
 
 // Win32-specific thread local storage data
 //
diff --git a/src/win32_time.h b/src/win32_time.h
index a5a7ee80..da5afa41 100644
--- a/src/win32_time.h
+++ b/src/win32_time.h
@@ -27,7 +27,7 @@
 
 #include <windows.h>
 
-#define _GLFW_PLATFORM_LIBRARY_TIMER_STATE  _GLFWtimerWin32   win32
+#define GLFW_WIN32_LIBRARY_TIMER_STATE  _GLFWtimerWin32   win32;
 
 // Win32-specific global timer data
 //
diff --git a/src/win32_window.c b/src/win32_window.c
index 80ae7c79..ae7710a2 100644
--- a/src/win32_window.c
+++ b/src/win32_window.c
@@ -297,9 +297,9 @@ static void disableRawMouseMotion(_GLFWwindow* window)
 static void disableCursor(_GLFWwindow* window)
 {
     _glfw.win32.disabledCursorWindow = window;
-    _glfwPlatformGetCursorPos(window,
-                              &_glfw.win32.restoreCursorPosX,
-                              &_glfw.win32.restoreCursorPosY);
+    _glfwGetCursorPosWin32(window,
+                           &_glfw.win32.restoreCursorPosX,
+                           &_glfw.win32.restoreCursorPosY);
     updateCursorImage(window);
     _glfwCenterCursorInContentArea(window);
     updateClipRect(window);
@@ -317,9 +317,9 @@ static void enableCursor(_GLFWwindow* window)
 
     _glfw.win32.disabledCursorWindow = NULL;
     updateClipRect(NULL);
-    _glfwPlatformSetCursorPos(window,
-                              _glfw.win32.restoreCursorPosX,
-                              _glfw.win32.restoreCursorPosY);
+    _glfwSetCursorPosWin32(window,
+                           _glfw.win32.restoreCursorPosX,
+                           _glfw.win32.restoreCursorPosY);
     updateCursorImage(window);
 }
 
@@ -595,7 +595,7 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg,
                 enableCursor(window);
 
             if (window->monitor && window->autoIconify)
-                _glfwPlatformIconifyWindow(window);
+                _glfwIconifyWindowWin32(window);
 
             _glfwInputWindowFocus(window, GLFW_FALSE);
             return 0;
@@ -755,7 +755,7 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg,
             {
                 // HACK: Release both Shift keys on Shift up event, as when both
                 //       are pressed the first release does not emit any event
-                // NOTE: The other half of this is in _glfwPlatformPollEvents
+                // NOTE: The other half of this is in _glfwPollEventsWin32
                 _glfwInputKey(window, GLFW_KEY_LEFT_SHIFT, scancode, action, mods);
                 _glfwInputKey(window, GLFW_KEY_RIGHT_SHIFT, scancode, action, mods);
             }
@@ -1233,8 +1233,8 @@ static int createNativeWindow(_GLFWwindow* window,
         // NOTE: This window placement is temporary and approximate, as the
         //       correct position and size cannot be known until the monitor
         //       video mode has been picked in _glfwSetVideoModeWin32
-        _glfwPlatformGetMonitorPos(window->monitor, &xpos, &ypos);
-        _glfwPlatformGetVideoMode(window->monitor, &mode);
+        _glfwGetMonitorPosWin32(window->monitor, &xpos, &ypos);
+        _glfwGetVideoModeWin32(window->monitor, &mode);
         fullWidth  = mode.width;
         fullHeight = mode.height;
     }
@@ -1303,7 +1303,7 @@ static int createNativeWindow(_GLFWwindow* window,
         if (wndconfig->scaleToMonitor)
         {
             float xscale, yscale;
-            _glfwPlatformGetWindowContentScale(window, &xscale, &yscale);
+            _glfwGetWindowContentScaleWin32(window, &xscale, &yscale);
             rect.right = (int) (rect.right * xscale);
             rect.bottom = (int) (rect.bottom * yscale);
         }
@@ -1334,16 +1334,11 @@ static int createNativeWindow(_GLFWwindow* window,
         window->win32.transparent = GLFW_TRUE;
     }
 
-    _glfwPlatformGetWindowSize(window, &window->win32.width, &window->win32.height);
+    _glfwGetWindowSizeWin32(window, &window->win32.width, &window->win32.height);
 
     return GLFW_TRUE;
 }
 
-
-//////////////////////////////////////////////////////////////////////////
-//////                       GLFW internal API                      //////
-//////////////////////////////////////////////////////////////////////////
-
 // Registers the GLFW window class
 //
 GLFWbool _glfwRegisterWindowClassWin32(void)
@@ -1387,15 +1382,10 @@ void _glfwUnregisterWindowClassWin32(void)
     UnregisterClassW(_GLFW_WNDCLASSNAME, GetModuleHandleW(NULL));
 }
 
-
-//////////////////////////////////////////////////////////////////////////
-//////                       GLFW platform API                      //////
-//////////////////////////////////////////////////////////////////////////
-
-int _glfwPlatformCreateWindow(_GLFWwindow* window,
-                              const _GLFWwndconfig* wndconfig,
-                              const _GLFWctxconfig* ctxconfig,
-                              const _GLFWfbconfig* fbconfig)
+int _glfwCreateWindowWin32(_GLFWwindow* window,
+                           const _GLFWwndconfig* wndconfig,
+                           const _GLFWctxconfig* ctxconfig,
+                           const _GLFWfbconfig* fbconfig)
 {
     if (!createNativeWindow(window, wndconfig, fbconfig))
         return GLFW_FALSE;
@@ -1427,8 +1417,8 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
 
     if (window->monitor)
     {
-        _glfwPlatformShowWindow(window);
-        _glfwPlatformFocusWindow(window);
+        _glfwShowWindowWin32(window);
+        _glfwFocusWindowWin32(window);
         acquireMonitor(window);
         fitToMonitor(window);
     }
@@ -1436,7 +1426,7 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyWindow(_GLFWwindow* window)
+void _glfwDestroyWindowWin32(_GLFWwindow* window)
 {
     if (window->monitor)
         releaseMonitor(window);
@@ -1461,7 +1451,7 @@ void _glfwPlatformDestroyWindow(_GLFWwindow* window)
         DestroyIcon(window->win32.smallIcon);
 }
 
-void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
+void _glfwSetWindowTitleWin32(_GLFWwindow* window, const char* title)
 {
     WCHAR* wideTitle = _glfwCreateWideStringFromUTF8Win32(title);
     if (!wideTitle)
@@ -1471,8 +1461,8 @@ void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
     _glfw_free(wideTitle);
 }
 
-void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
-                                int count, const GLFWimage* images)
+void _glfwSetWindowIconWin32(_GLFWwindow* window,
+                             int count, const GLFWimage* images)
 {
     HICON bigIcon = NULL, smallIcon = NULL;
 
@@ -1510,7 +1500,7 @@ void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
     }
 }
 
-void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
+void _glfwGetWindowPosWin32(_GLFWwindow* window, int* xpos, int* ypos)
 {
     POINT pos = { 0, 0 };
     ClientToScreen(window->win32.handle, &pos);
@@ -1521,7 +1511,7 @@ void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
         *ypos = pos.y;
 }
 
-void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
+void _glfwSetWindowPosWin32(_GLFWwindow* window, int xpos, int ypos)
 {
     RECT rect = { xpos, ypos, xpos, ypos };
 
@@ -1541,7 +1531,7 @@ void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
                  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
 }
 
-void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetWindowSizeWin32(_GLFWwindow* window, int* width, int* height)
 {
     RECT area;
     GetClientRect(window->win32.handle, &area);
@@ -1552,7 +1542,7 @@ void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
         *height = area.bottom;
 }
 
-void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
+void _glfwSetWindowSizeWin32(_GLFWwindow* window, int width, int height)
 {
     if (window->monitor)
     {
@@ -1584,9 +1574,9 @@ void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
     }
 }
 
-void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
-                                      int minwidth, int minheight,
-                                      int maxwidth, int maxheight)
+void _glfwSetWindowSizeLimitsWin32(_GLFWwindow* window,
+                                           int minwidth, int minheight,
+                                           int maxwidth, int maxheight)
 {
     RECT area;
 
@@ -1603,7 +1593,7 @@ void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
                area.bottom - area.top, TRUE);
 }
 
-void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int numer, int denom)
+void _glfwSetWindowAspectRatioWin32(_GLFWwindow* window, int numer, int denom)
 {
     RECT area;
 
@@ -1618,19 +1608,19 @@ void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int numer, int denom
                area.bottom - area.top, TRUE);
 }
 
-void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetFramebufferSizeWin32(_GLFWwindow* window, int* width, int* height)
 {
-    _glfwPlatformGetWindowSize(window, width, height);
+    _glfwGetWindowSizeWin32(window, width, height);
 }
 
-void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
-                                     int* left, int* top,
-                                     int* right, int* bottom)
+void _glfwGetWindowFrameSizeWin32(_GLFWwindow* window,
+                                          int* left, int* top,
+                                          int* right, int* bottom)
 {
     RECT rect;
     int width, height;
 
-    _glfwPlatformGetWindowSize(window, &width, &height);
+    _glfwGetWindowSizeWin32(window, &width, &height);
     SetRect(&rect, 0, 0, width, height);
 
     if (_glfwIsWindows10AnniversaryUpdateOrGreaterWin32())
@@ -1655,56 +1645,56 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
         *bottom = rect.bottom - height;
 }
 
-void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
-                                        float* xscale, float* yscale)
+void _glfwGetWindowContentScaleWin32(_GLFWwindow* window,
+                                             float* xscale, float* yscale)
 {
     const HANDLE handle = MonitorFromWindow(window->win32.handle,
                                             MONITOR_DEFAULTTONEAREST);
-    _glfwGetMonitorContentScaleWin32(handle, xscale, yscale);
+    _glfwGetHMONITORContentScaleWin32(handle, xscale, yscale);
 }
 
-void _glfwPlatformIconifyWindow(_GLFWwindow* window)
+void _glfwIconifyWindowWin32(_GLFWwindow* window)
 {
     ShowWindow(window->win32.handle, SW_MINIMIZE);
 }
 
-void _glfwPlatformRestoreWindow(_GLFWwindow* window)
+void _glfwRestoreWindowWin32(_GLFWwindow* window)
 {
     ShowWindow(window->win32.handle, SW_RESTORE);
 }
 
-void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
+void _glfwMaximizeWindowWin32(_GLFWwindow* window)
 {
     ShowWindow(window->win32.handle, SW_MAXIMIZE);
 }
 
-void _glfwPlatformShowWindow(_GLFWwindow* window)
+void _glfwShowWindowWin32(_GLFWwindow* window)
 {
     ShowWindow(window->win32.handle, SW_SHOWNA);
 }
 
-void _glfwPlatformHideWindow(_GLFWwindow* window)
+void _glfwHideWindowWin32(_GLFWwindow* window)
 {
     ShowWindow(window->win32.handle, SW_HIDE);
 }
 
-void _glfwPlatformRequestWindowAttention(_GLFWwindow* window)
+void _glfwRequestWindowAttentionWin32(_GLFWwindow* window)
 {
     FlashWindow(window->win32.handle, TRUE);
 }
 
-void _glfwPlatformFocusWindow(_GLFWwindow* window)
+void _glfwFocusWindowWin32(_GLFWwindow* window)
 {
     BringWindowToTop(window->win32.handle);
     SetForegroundWindow(window->win32.handle);
     SetFocus(window->win32.handle);
 }
 
-void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
-                                   _GLFWmonitor* monitor,
-                                   int xpos, int ypos,
-                                   int width, int height,
-                                   int refreshRate)
+void _glfwSetWindowMonitorWin32(_GLFWwindow* window,
+                                _GLFWmonitor* monitor,
+                                int xpos, int ypos,
+                                int width, int height,
+                                int refreshRate)
 {
     if (window->monitor == monitor)
     {
@@ -1810,32 +1800,32 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
     }
 }
 
-int _glfwPlatformWindowFocused(_GLFWwindow* window)
+int _glfwWindowFocusedWin32(_GLFWwindow* window)
 {
     return window->win32.handle == GetActiveWindow();
 }
 
-int _glfwPlatformWindowIconified(_GLFWwindow* window)
+int _glfwWindowIconifiedWin32(_GLFWwindow* window)
 {
     return IsIconic(window->win32.handle);
 }
 
-int _glfwPlatformWindowVisible(_GLFWwindow* window)
+int _glfwWindowVisibleWin32(_GLFWwindow* window)
 {
     return IsWindowVisible(window->win32.handle);
 }
 
-int _glfwPlatformWindowMaximized(_GLFWwindow* window)
+int _glfwWindowMaximizedWin32(_GLFWwindow* window)
 {
     return IsZoomed(window->win32.handle);
 }
 
-int _glfwPlatformWindowHovered(_GLFWwindow* window)
+int _glfwWindowHoveredWin32(_GLFWwindow* window)
 {
     return cursorInContentArea(window);
 }
 
-int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
+int _glfwFramebufferTransparentWin32(_GLFWwindow* window)
 {
     BOOL composition, opaque;
     DWORD color;
@@ -1862,24 +1852,24 @@ int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformSetWindowResizable(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowResizableWin32(_GLFWwindow* window, GLFWbool enabled)
 {
     updateWindowStyles(window);
 }
 
-void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowDecoratedWin32(_GLFWwindow* window, GLFWbool enabled)
 {
     updateWindowStyles(window);
 }
 
-void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowFloatingWin32(_GLFWwindow* window, GLFWbool enabled)
 {
     const HWND after = enabled ? HWND_TOPMOST : HWND_NOTOPMOST;
     SetWindowPos(window->win32.handle, after, 0, 0, 0, 0,
                  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
 }
 
-void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowMousePassthroughWin32(_GLFWwindow* window, GLFWbool enabled)
 {
     COLORREF key = 0;
     BYTE alpha = 0;
@@ -1909,7 +1899,7 @@ void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enable
         SetLayeredWindowAttributes(window->win32.handle, key, alpha, flags);
 }
 
-float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
+float _glfwGetWindowOpacityWin32(_GLFWwindow* window)
 {
     BYTE alpha;
     DWORD flags;
@@ -1924,7 +1914,7 @@ float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
     return 1.f;
 }
 
-void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
+void _glfwSetWindowOpacityWin32(_GLFWwindow* window, float opacity)
 {
     LONG exStyle = GetWindowLongW(window->win32.handle, GWL_EXSTYLE);
     if (opacity < 1.f || (exStyle & WS_EX_TRANSPARENT))
@@ -1945,7 +1935,7 @@ void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
     }
 }
 
-void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
+void _glfwSetRawMouseMotionWin32(_GLFWwindow *window, GLFWbool enabled)
 {
     if (_glfw.win32.disabledCursorWindow != window)
         return;
@@ -1956,12 +1946,12 @@ void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
         disableRawMouseMotion(window);
 }
 
-GLFWbool _glfwPlatformRawMouseMotionSupported(void)
+GLFWbool _glfwRawMouseMotionSupportedWin32(void)
 {
     return GLFW_TRUE;
 }
 
-void _glfwPlatformPollEvents(void)
+void _glfwPollEventsWin32(void)
 {
     MSG msg;
     HWND handle;
@@ -2031,38 +2021,38 @@ void _glfwPlatformPollEvents(void)
     if (window)
     {
         int width, height;
-        _glfwPlatformGetWindowSize(window, &width, &height);
+        _glfwGetWindowSizeWin32(window, &width, &height);
 
         // NOTE: Re-center the cursor only if it has moved since the last call,
         //       to avoid breaking glfwWaitEvents with WM_MOUSEMOVE
         if (window->win32.lastCursorPosX != width / 2 ||
             window->win32.lastCursorPosY != height / 2)
         {
-            _glfwPlatformSetCursorPos(window, width / 2, height / 2);
+            _glfwSetCursorPosWin32(window, width / 2, height / 2);
         }
     }
 }
 
-void _glfwPlatformWaitEvents(void)
+void _glfwWaitEventsWin32(void)
 {
     WaitMessage();
 
-    _glfwPlatformPollEvents();
+    _glfwPollEventsWin32();
 }
 
-void _glfwPlatformWaitEventsTimeout(double timeout)
+void _glfwWaitEventsTimeoutWin32(double timeout)
 {
     MsgWaitForMultipleObjects(0, NULL, FALSE, (DWORD) (timeout * 1e3), QS_ALLEVENTS);
 
-    _glfwPlatformPollEvents();
+    _glfwPollEventsWin32();
 }
 
-void _glfwPlatformPostEmptyEvent(void)
+void _glfwPostEmptyEventWin32(void)
 {
     PostMessage(_glfw.win32.helperWindowHandle, WM_NULL, 0, 0);
 }
 
-void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
+void _glfwGetCursorPosWin32(_GLFWwindow* window, double* xpos, double* ypos)
 {
     POINT pos;
 
@@ -2077,7 +2067,7 @@ void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
     }
 }
 
-void _glfwPlatformSetCursorPos(_GLFWwindow* window, double xpos, double ypos)
+void _glfwSetCursorPosWin32(_GLFWwindow* window, double xpos, double ypos)
 {
     POINT pos = { (int) xpos, (int) ypos };
 
@@ -2089,11 +2079,11 @@ void _glfwPlatformSetCursorPos(_GLFWwindow* window, double xpos, double ypos)
     SetCursorPos(pos.x, pos.y);
 }
 
-void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
+void _glfwSetCursorModeWin32(_GLFWwindow* window, int mode)
 {
     if (mode == GLFW_CURSOR_DISABLED)
     {
-        if (_glfwPlatformWindowFocused(window))
+        if (_glfwWindowFocusedWin32(window))
             disableCursor(window);
     }
     else if (_glfw.win32.disabledCursorWindow == window)
@@ -2102,7 +2092,7 @@ void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
         updateCursorImage(window);
 }
 
-const char* _glfwPlatformGetScancodeName(int scancode)
+const char* _glfwGetScancodeNameWin32(int scancode)
 {
     if (scancode < 0 || scancode > (KF_EXTENDED | 0xff) ||
         _glfw.win32.keycodes[scancode] == GLFW_KEY_UNKNOWN)
@@ -2114,14 +2104,14 @@ const char* _glfwPlatformGetScancodeName(int scancode)
     return _glfw.win32.keynames[_glfw.win32.keycodes[scancode]];
 }
 
-int _glfwPlatformGetKeyScancode(int key)
+int _glfwGetKeyScancodeWin32(int key)
 {
     return _glfw.win32.scancodes[key];
 }
 
-int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
-                              const GLFWimage* image,
-                              int xhot, int yhot)
+int _glfwCreateCursorWin32(_GLFWcursor* cursor,
+                                   const GLFWimage* image,
+                                   int xhot, int yhot)
 {
     cursor->win32.handle = (HCURSOR) createIcon(image, xhot, yhot, GLFW_FALSE);
     if (!cursor->win32.handle)
@@ -2130,7 +2120,7 @@ int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
     return GLFW_TRUE;
 }
 
-int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
+int _glfwCreateStandardCursorWin32(_GLFWcursor* cursor, int shape)
 {
     int id = 0;
 
@@ -2184,19 +2174,19 @@ int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
+void _glfwDestroyCursorWin32(_GLFWcursor* cursor)
 {
     if (cursor->win32.handle)
         DestroyIcon((HICON) cursor->win32.handle);
 }
 
-void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
+void _glfwSetCursorWin32(_GLFWwindow* window, _GLFWcursor* cursor)
 {
     if (cursorInContentArea(window))
         updateCursorImage(window);
 }
 
-void _glfwPlatformSetClipboardString(const char* string)
+void _glfwSetClipboardStringWin32(const char* string)
 {
     int characterCount;
     HANDLE object;
@@ -2239,7 +2229,7 @@ void _glfwPlatformSetClipboardString(const char* string)
     CloseClipboard();
 }
 
-const char* _glfwPlatformGetClipboardString(void)
+const char* _glfwGetClipboardStringWin32(void)
 {
     HANDLE object;
     WCHAR* buffer;
@@ -2278,7 +2268,7 @@ const char* _glfwPlatformGetClipboardString(void)
     return _glfw.win32.clipboardString;
 }
 
-EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
+EGLenum _glfwGetEGLPlatformWin32(EGLint** attribs)
 {
     if (_glfw.egl.ANGLE_platform_angle)
     {
@@ -2319,17 +2309,17 @@ EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
     return 0;
 }
 
-EGLNativeDisplayType _glfwPlatformGetEGLNativeDisplay(void)
+EGLNativeDisplayType _glfwGetEGLNativeDisplayWin32(void)
 {
     return GetDC(_glfw.win32.helperWindowHandle);
 }
 
-EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window)
+EGLNativeWindowType _glfwGetEGLNativeWindowWin32(_GLFWwindow* window)
 {
     return window->win32.handle;
 }
 
-void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
+void _glfwGetRequiredInstanceExtensionsWin32(char** extensions)
 {
     if (!_glfw.vk.KHR_surface || !_glfw.vk.KHR_win32_surface)
         return;
@@ -2338,9 +2328,9 @@ void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
     extensions[1] = "VK_KHR_win32_surface";
 }
 
-int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
-                                                      VkPhysicalDevice device,
-                                                      uint32_t queuefamily)
+int _glfwGetPhysicalDevicePresentationSupportWin32(VkInstance instance,
+                                                   VkPhysicalDevice device,
+                                                   uint32_t queuefamily)
 {
     PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR
         vkGetPhysicalDeviceWin32PresentationSupportKHR =
@@ -2356,10 +2346,10 @@ int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
     return vkGetPhysicalDeviceWin32PresentationSupportKHR(device, queuefamily);
 }
 
-VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
-                                          _GLFWwindow* window,
-                                          const VkAllocationCallbacks* allocator,
-                                          VkSurfaceKHR* surface)
+VkResult _glfwCreateWindowSurfaceWin32(VkInstance instance,
+                                       _GLFWwindow* window,
+                                       const VkAllocationCallbacks* allocator,
+                                       VkSurfaceKHR* surface)
 {
     VkResult err;
     VkWin32SurfaceCreateInfoKHR sci;
@@ -2390,15 +2380,18 @@ VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
     return err;
 }
 
-
-//////////////////////////////////////////////////////////////////////////
-//////                        GLFW native API                       //////
-//////////////////////////////////////////////////////////////////////////
-
 GLFWAPI HWND glfwGetWin32Window(GLFWwindow* handle)
 {
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+
+    if (_glfw.platform.platformID != GLFW_PLATFORM_WIN32)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                        "Win32: Platform not initialized");
+        return NULL;
+    }
+
     return window->win32.handle;
 }
 
diff --git a/src/window.c b/src/window.c
index 93d8a14c..c9845eca 100644
--- a/src/window.c
+++ b/src/window.c
@@ -55,7 +55,7 @@ void _glfwInputWindowFocus(_GLFWwindow* window, GLFWbool focused)
         {
             if (window->keys[key] == GLFW_PRESS)
             {
-                const int scancode = _glfwPlatformGetKeyScancode(key);
+                const int scancode = _glfw.platform.getKeyScancode(key);
                 _glfwInputKey(window, key, scancode, GLFW_RELEASE, 0);
             }
         }
@@ -216,7 +216,7 @@ GLFWAPI GLFWwindow* glfwCreateWindow(int width, int height,
     window->denom       = GLFW_DONT_CARE;
 
     // Open the actual window and create its context
-    if (!_glfwPlatformCreateWindow(window, &wndconfig, &ctxconfig, &fbconfig))
+    if (!_glfw.platform.createWindow(window, &wndconfig, &ctxconfig, &fbconfig))
     {
         glfwDestroyWindow((GLFWwindow*) window);
         return NULL;
@@ -232,7 +232,7 @@ GLFWAPI GLFWwindow* glfwCreateWindow(int width, int height,
     }
 
     if (wndconfig.mousePassthrough)
-        _glfwPlatformSetWindowMousePassthrough(window, GLFW_TRUE);
+        _glfw.platform.setWindowMousePassthrough(window, GLFW_TRUE);
 
     if (window->monitor)
     {
@@ -243,9 +243,9 @@ GLFWAPI GLFWwindow* glfwCreateWindow(int width, int height,
     {
         if (wndconfig.visible)
         {
-            _glfwPlatformShowWindow(window);
+            _glfw.platform.showWindow(window);
             if (wndconfig.focused)
-                _glfwPlatformFocusWindow(window);
+                _glfw.platform.focusWindow(window);
         }
     }
 
@@ -468,7 +468,7 @@ GLFWAPI void glfwDestroyWindow(GLFWwindow* handle)
     if (window == _glfwPlatformGetTls(&_glfw.contextSlot))
         glfwMakeContextCurrent(NULL);
 
-    _glfwPlatformDestroyWindow(window);
+    _glfw.platform.destroyWindow(window);
 
     // Unlink window from global linked list
     {
@@ -508,7 +508,7 @@ GLFWAPI void glfwSetWindowTitle(GLFWwindow* handle, const char* title)
     assert(title != NULL);
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformSetWindowTitle(window, title);
+    _glfw.platform.setWindowTitle(window, title);
 }
 
 GLFWAPI void glfwSetWindowIcon(GLFWwindow* handle,
@@ -520,7 +520,7 @@ GLFWAPI void glfwSetWindowIcon(GLFWwindow* handle,
     assert(count == 0 || images != NULL);
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformSetWindowIcon(window, count, images);
+    _glfw.platform.setWindowIcon(window, count, images);
 }
 
 GLFWAPI void glfwGetWindowPos(GLFWwindow* handle, int* xpos, int* ypos)
@@ -534,7 +534,7 @@ GLFWAPI void glfwGetWindowPos(GLFWwindow* handle, int* xpos, int* ypos)
         *ypos = 0;
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformGetWindowPos(window, xpos, ypos);
+    _glfw.platform.getWindowPos(window, xpos, ypos);
 }
 
 GLFWAPI void glfwSetWindowPos(GLFWwindow* handle, int xpos, int ypos)
@@ -547,7 +547,7 @@ GLFWAPI void glfwSetWindowPos(GLFWwindow* handle, int xpos, int ypos)
     if (window->monitor)
         return;
 
-    _glfwPlatformSetWindowPos(window, xpos, ypos);
+    _glfw.platform.setWindowPos(window, xpos, ypos);
 }
 
 GLFWAPI void glfwGetWindowSize(GLFWwindow* handle, int* width, int* height)
@@ -561,7 +561,7 @@ GLFWAPI void glfwGetWindowSize(GLFWwindow* handle, int* width, int* height)
         *height = 0;
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformGetWindowSize(window, width, height);
+    _glfw.platform.getWindowSize(window, width, height);
 }
 
 GLFWAPI void glfwSetWindowSize(GLFWwindow* handle, int width, int height)
@@ -576,7 +576,7 @@ GLFWAPI void glfwSetWindowSize(GLFWwindow* handle, int width, int height)
     window->videoMode.width  = width;
     window->videoMode.height = height;
 
-    _glfwPlatformSetWindowSize(window, width, height);
+    _glfw.platform.setWindowSize(window, width, height);
 }
 
 GLFWAPI void glfwSetWindowSizeLimits(GLFWwindow* handle,
@@ -619,9 +619,9 @@ GLFWAPI void glfwSetWindowSizeLimits(GLFWwindow* handle,
     if (window->monitor || !window->resizable)
         return;
 
-    _glfwPlatformSetWindowSizeLimits(window,
-                                     minwidth, minheight,
-                                     maxwidth, maxheight);
+    _glfw.platform.setWindowSizeLimits(window,
+                                       minwidth, minheight,
+                                       maxwidth, maxheight);
 }
 
 GLFWAPI void glfwSetWindowAspectRatio(GLFWwindow* handle, int numer, int denom)
@@ -650,7 +650,7 @@ GLFWAPI void glfwSetWindowAspectRatio(GLFWwindow* handle, int numer, int denom)
     if (window->monitor || !window->resizable)
         return;
 
-    _glfwPlatformSetWindowAspectRatio(window, numer, denom);
+    _glfw.platform.setWindowAspectRatio(window, numer, denom);
 }
 
 GLFWAPI void glfwGetFramebufferSize(GLFWwindow* handle, int* width, int* height)
@@ -664,7 +664,7 @@ GLFWAPI void glfwGetFramebufferSize(GLFWwindow* handle, int* width, int* height)
         *height = 0;
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformGetFramebufferSize(window, width, height);
+    _glfw.platform.getFramebufferSize(window, width, height);
 }
 
 GLFWAPI void glfwGetWindowFrameSize(GLFWwindow* handle,
@@ -684,7 +684,7 @@ GLFWAPI void glfwGetWindowFrameSize(GLFWwindow* handle,
         *bottom = 0;
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformGetWindowFrameSize(window, left, top, right, bottom);
+    _glfw.platform.getWindowFrameSize(window, left, top, right, bottom);
 }
 
 GLFWAPI void glfwGetWindowContentScale(GLFWwindow* handle,
@@ -699,7 +699,7 @@ GLFWAPI void glfwGetWindowContentScale(GLFWwindow* handle,
         *yscale = 0.f;
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformGetWindowContentScale(window, xscale, yscale);
+    _glfw.platform.getWindowContentScale(window, xscale, yscale);
 }
 
 GLFWAPI float glfwGetWindowOpacity(GLFWwindow* handle)
@@ -708,7 +708,7 @@ GLFWAPI float glfwGetWindowOpacity(GLFWwindow* handle)
     assert(window != NULL);
 
     _GLFW_REQUIRE_INIT_OR_RETURN(1.f);
-    return _glfwPlatformGetWindowOpacity(window);
+    return _glfw.platform.getWindowOpacity(window);
 }
 
 GLFWAPI void glfwSetWindowOpacity(GLFWwindow* handle, float opacity)
@@ -727,7 +727,7 @@ GLFWAPI void glfwSetWindowOpacity(GLFWwindow* handle, float opacity)
         return;
     }
 
-    _glfwPlatformSetWindowOpacity(window, opacity);
+    _glfw.platform.setWindowOpacity(window, opacity);
 }
 
 GLFWAPI void glfwIconifyWindow(GLFWwindow* handle)
@@ -736,7 +736,7 @@ GLFWAPI void glfwIconifyWindow(GLFWwindow* handle)
     assert(window != NULL);
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformIconifyWindow(window);
+    _glfw.platform.iconifyWindow(window);
 }
 
 GLFWAPI void glfwRestoreWindow(GLFWwindow* handle)
@@ -745,7 +745,7 @@ GLFWAPI void glfwRestoreWindow(GLFWwindow* handle)
     assert(window != NULL);
 
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformRestoreWindow(window);
+    _glfw.platform.restoreWindow(window);
 }
 
 GLFWAPI void glfwMaximizeWindow(GLFWwindow* handle)
@@ -758,7 +758,7 @@ GLFWAPI void glfwMaximizeWindow(GLFWwindow* handle)
     if (window->monitor)
         return;
 
-    _glfwPlatformMaximizeWindow(window);
+    _glfw.platform.maximizeWindow(window);
 }
 
 GLFWAPI void glfwShowWindow(GLFWwindow* handle)
@@ -771,10 +771,10 @@ GLFWAPI void glfwShowWindow(GLFWwindow* handle)
     if (window->monitor)
         return;
 
-    _glfwPlatformShowWindow(window);
+    _glfw.platform.showWindow(window);
 
     if (window->focusOnShow)
-        _glfwPlatformFocusWindow(window);
+        _glfw.platform.focusWindow(window);
 }
 
 GLFWAPI void glfwRequestWindowAttention(GLFWwindow* handle)
@@ -784,7 +784,7 @@ GLFWAPI void glfwRequestWindowAttention(GLFWwindow* handle)
 
     _GLFW_REQUIRE_INIT();
 
-    _glfwPlatformRequestWindowAttention(window);
+    _glfw.platform.requestWindowAttention(window);
 }
 
 GLFWAPI void glfwHideWindow(GLFWwindow* handle)
@@ -797,7 +797,7 @@ GLFWAPI void glfwHideWindow(GLFWwindow* handle)
     if (window->monitor)
         return;
 
-    _glfwPlatformHideWindow(window);
+    _glfw.platform.hideWindow(window);
 }
 
 GLFWAPI void glfwFocusWindow(GLFWwindow* handle)
@@ -807,7 +807,7 @@ GLFWAPI void glfwFocusWindow(GLFWwindow* handle)
 
     _GLFW_REQUIRE_INIT();
 
-    _glfwPlatformFocusWindow(window);
+    _glfw.platform.focusWindow(window);
 }
 
 GLFWAPI int glfwGetWindowAttrib(GLFWwindow* handle, int attrib)
@@ -820,21 +820,21 @@ GLFWAPI int glfwGetWindowAttrib(GLFWwindow* handle, int attrib)
     switch (attrib)
     {
         case GLFW_FOCUSED:
-            return _glfwPlatformWindowFocused(window);
+            return _glfw.platform.windowFocused(window);
         case GLFW_ICONIFIED:
-            return _glfwPlatformWindowIconified(window);
+            return _glfw.platform.windowIconified(window);
         case GLFW_VISIBLE:
-            return _glfwPlatformWindowVisible(window);
+            return _glfw.platform.windowVisible(window);
         case GLFW_MAXIMIZED:
-            return _glfwPlatformWindowMaximized(window);
+            return _glfw.platform.windowMaximized(window);
         case GLFW_HOVERED:
-            return _glfwPlatformWindowHovered(window);
+            return _glfw.platform.windowHovered(window);
         case GLFW_FOCUS_ON_SHOW:
             return window->focusOnShow;
         case GLFW_MOUSE_PASSTHROUGH:
             return window->mousePassthrough;
         case GLFW_TRANSPARENT_FRAMEBUFFER:
-            return _glfwPlatformFramebufferTransparent(window);
+            return _glfw.platform.framebufferTransparent(window);
         case GLFW_RESIZABLE:
             return window->resizable;
         case GLFW_DECORATED:
@@ -888,26 +888,26 @@ GLFWAPI void glfwSetWindowAttrib(GLFWwindow* handle, int attrib, int value)
     {
         window->resizable = value;
         if (!window->monitor)
-            _glfwPlatformSetWindowResizable(window, value);
+            _glfw.platform.setWindowResizable(window, value);
     }
     else if (attrib == GLFW_DECORATED)
     {
         window->decorated = value;
         if (!window->monitor)
-            _glfwPlatformSetWindowDecorated(window, value);
+            _glfw.platform.setWindowDecorated(window, value);
     }
     else if (attrib == GLFW_FLOATING)
     {
         window->floating = value;
         if (!window->monitor)
-            _glfwPlatformSetWindowFloating(window, value);
+            _glfw.platform.setWindowFloating(window, value);
     }
     else if (attrib == GLFW_FOCUS_ON_SHOW)
         window->focusOnShow = value;
     else if (attrib == GLFW_MOUSE_PASSTHROUGH)
     {
         window->mousePassthrough = value;
-        _glfwPlatformSetWindowMousePassthrough(window, value);
+        _glfw.platform.setWindowMousePassthrough(window, value);
     }
     else
         _glfwInputError(GLFW_INVALID_ENUM, "Invalid window attribute 0x%08X", attrib);
@@ -956,9 +956,9 @@ GLFWAPI void glfwSetWindowMonitor(GLFWwindow* wh,
     window->videoMode.height      = height;
     window->videoMode.refreshRate = refreshRate;
 
-    _glfwPlatformSetWindowMonitor(window, monitor,
-                                  xpos, ypos, width, height,
-                                  refreshRate);
+    _glfw.platform.setWindowMonitor(window, monitor,
+                                    xpos, ypos, width, height,
+                                    refreshRate);
 }
 
 GLFWAPI void glfwSetWindowUserPointer(GLFWwindow* handle, void* pointer)
@@ -1081,13 +1081,13 @@ GLFWAPI GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow*
 GLFWAPI void glfwPollEvents(void)
 {
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformPollEvents();
+    _glfw.platform.pollEvents();
 }
 
 GLFWAPI void glfwWaitEvents(void)
 {
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformWaitEvents();
+    _glfw.platform.waitEvents();
 }
 
 GLFWAPI void glfwWaitEventsTimeout(double timeout)
@@ -1103,12 +1103,12 @@ GLFWAPI void glfwWaitEventsTimeout(double timeout)
         return;
     }
 
-    _glfwPlatformWaitEventsTimeout(timeout);
+    _glfw.platform.waitEventsTimeout(timeout);
 }
 
 GLFWAPI void glfwPostEmptyEvent(void)
 {
     _GLFW_REQUIRE_INIT();
-    _glfwPlatformPostEmptyEvent();
+    _glfw.platform.postEmptyEvent();
 }
 
diff --git a/src/wl_init.c b/src/wl_init.c
index 609283f6..031e5d52 100644
--- a/src/wl_init.c
+++ b/src/wl_init.c
@@ -123,7 +123,7 @@ static void pointerHandleEnter(void* data,
 
     window->wl.hovered = GLFW_TRUE;
 
-    _glfwPlatformSetCursor(window, window->wl.currentCursor);
+    _glfwSetCursorWayland(window, window->wl.currentCursor);
     _glfwInputCursorEnter(window, GLFW_TRUE);
 }
 
@@ -1045,7 +1045,136 @@ static void createKeyTables(void)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformInit(void)
+GLFWbool _glfwConnectWayland(int platformID, _GLFWplatform* platform)
+{
+    const _GLFWplatform wayland =
+    {
+        GLFW_PLATFORM_WAYLAND,
+        _glfwInitWayland,
+        _glfwTerminateWayland,
+        _glfwGetCursorPosWayland,
+        _glfwSetCursorPosWayland,
+        _glfwSetCursorModeWayland,
+        _glfwSetRawMouseMotionWayland,
+        _glfwRawMouseMotionSupportedWayland,
+        _glfwCreateCursorWayland,
+        _glfwCreateStandardCursorWayland,
+        _glfwDestroyCursorWayland,
+        _glfwSetCursorWayland,
+        _glfwGetScancodeNameWayland,
+        _glfwGetKeyScancodeWayland,
+        _glfwSetClipboardStringWayland,
+        _glfwGetClipboardStringWayland,
+#if defined(__linux__)
+        _glfwInitJoysticksLinux,
+        _glfwTerminateJoysticksLinux,
+        _glfwPollJoystickLinux,
+        _glfwGetMappingNameLinux,
+        _glfwUpdateGamepadGUIDLinux,
+#else
+        _glfwInitJoysticksNull,
+        _glfwTerminateJoysticksNull,
+        _glfwPollJoystickNull,
+        _glfwGetMappingNameNull,
+        _glfwUpdateGamepadGUIDNull,
+#endif
+        _glfwFreeMonitorWayland,
+        _glfwGetMonitorPosWayland,
+        _glfwGetMonitorContentScaleWayland,
+        _glfwGetMonitorWorkareaWayland,
+        _glfwGetVideoModesWayland,
+        _glfwGetVideoModeWayland,
+        _glfwGetGammaRampWayland,
+        _glfwSetGammaRampWayland,
+        _glfwCreateWindowWayland,
+        _glfwDestroyWindowWayland,
+        _glfwSetWindowTitleWayland,
+        _glfwSetWindowIconWayland,
+        _glfwGetWindowPosWayland,
+        _glfwSetWindowPosWayland,
+        _glfwGetWindowSizeWayland,
+        _glfwSetWindowSizeWayland,
+        _glfwSetWindowSizeLimitsWayland,
+        _glfwSetWindowAspectRatioWayland,
+        _glfwGetFramebufferSizeWayland,
+        _glfwGetWindowFrameSizeWayland,
+        _glfwGetWindowContentScaleWayland,
+        _glfwIconifyWindowWayland,
+        _glfwRestoreWindowWayland,
+        _glfwMaximizeWindowWayland,
+        _glfwShowWindowWayland,
+        _glfwHideWindowWayland,
+        _glfwRequestWindowAttentionWayland,
+        _glfwFocusWindowWayland,
+        _glfwSetWindowMonitorWayland,
+        _glfwWindowFocusedWayland,
+        _glfwWindowIconifiedWayland,
+        _glfwWindowVisibleWayland,
+        _glfwWindowMaximizedWayland,
+        _glfwWindowHoveredWayland,
+        _glfwFramebufferTransparentWayland,
+        _glfwGetWindowOpacityWayland,
+        _glfwSetWindowResizableWayland,
+        _glfwSetWindowDecoratedWayland,
+        _glfwSetWindowFloatingWayland,
+        _glfwSetWindowOpacityWayland,
+        _glfwSetWindowMousePassthroughWayland,
+        _glfwPollEventsWayland,
+        _glfwWaitEventsWayland,
+        _glfwWaitEventsTimeoutWayland,
+        _glfwPostEmptyEventWayland,
+        _glfwGetEGLPlatformWayland,
+        _glfwGetEGLNativeDisplayWayland,
+        _glfwGetEGLNativeWindowWayland,
+        _glfwGetRequiredInstanceExtensionsWayland,
+        _glfwGetPhysicalDevicePresentationSupportWayland,
+        _glfwCreateWindowSurfaceWayland,
+    };
+
+    void* module = _glfwPlatformLoadModule("libwayland-client.so.0");
+    if (!module)
+    {
+        if (platformID == GLFW_PLATFORM_WAYLAND)
+        {
+            _glfwInputError(GLFW_PLATFORM_ERROR,
+                            "Wayland: Failed to open libwayland-client");
+        }
+
+        return GLFW_FALSE;
+    }
+
+    PFN_wl_display_connect wl_display_connect = (PFN_wl_display_connect)
+        _glfwPlatformGetModuleSymbol(module, "wl_display_connect");
+    if (!wl_display_connect)
+    {
+        if (platformID == GLFW_PLATFORM_WAYLAND)
+        {
+            _glfwInputError(GLFW_PLATFORM_ERROR,
+                            "Wayland: Failed to load libwayland-client entry point");
+        }
+
+        _glfwPlatformFreeModule(module);
+        return GLFW_FALSE;
+    }
+
+    struct wl_display* display = wl_display_connect(NULL);
+    if (!display)
+    {
+        if (platformID == GLFW_PLATFORM_WAYLAND)
+            _glfwInputError(GLFW_PLATFORM_ERROR, "Wayland: Failed to connect to display");
+
+        _glfwPlatformFreeModule(module);
+        return GLFW_FALSE;
+    }
+
+    _glfw.wl.display = display;
+    _glfw.wl.client.handle = module;
+
+    *platform = wayland;
+    return GLFW_TRUE;
+}
+
+int _glfwInitWayland(void)
 {
     const char *cursorTheme;
     const char *cursorSizeStr;
@@ -1053,14 +1182,6 @@ int _glfwPlatformInit(void)
     long cursorSizeLong;
     int cursorSize;
 
-    _glfw.wl.client.handle = _glfwPlatformLoadModule("libwayland-client.so.0");
-    if (!_glfw.wl.client.handle)
-    {
-        _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Wayland: Failed to open libwayland-client");
-        return GLFW_FALSE;
-    }
-
     _glfw.wl.client.display_flush = (PFN_wl_display_flush)
         _glfwPlatformGetModuleSymbol(_glfw.wl.client.handle, "wl_display_flush");
     _glfw.wl.client.display_cancel_read = (PFN_wl_display_cancel_read)
@@ -1069,8 +1190,6 @@ int _glfwPlatformInit(void)
         _glfwPlatformGetModuleSymbol(_glfw.wl.client.handle, "wl_display_dispatch_pending");
     _glfw.wl.client.display_read_events = (PFN_wl_display_read_events)
         _glfwPlatformGetModuleSymbol(_glfw.wl.client.handle, "wl_display_read_events");
-    _glfw.wl.client.display_connect = (PFN_wl_display_connect)
-        _glfwPlatformGetModuleSymbol(_glfw.wl.client.handle, "wl_display_connect");
     _glfw.wl.client.display_disconnect = (PFN_wl_display_disconnect)
         _glfwPlatformGetModuleSymbol(_glfw.wl.client.handle, "wl_display_disconnect");
     _glfw.wl.client.display_roundtrip = (PFN_wl_display_roundtrip)
@@ -1102,7 +1221,6 @@ int _glfwPlatformInit(void)
         !_glfw.wl.client.display_cancel_read ||
         !_glfw.wl.client.display_dispatch_pending ||
         !_glfw.wl.client.display_read_events ||
-        !_glfw.wl.client.display_connect ||
         !_glfw.wl.client.display_disconnect ||
         !_glfw.wl.client.display_roundtrip ||
         !_glfw.wl.client.display_get_fd ||
@@ -1200,14 +1318,6 @@ int _glfwPlatformInit(void)
         _glfwPlatformGetModuleSymbol(_glfw.wl.xkb.handle, "xkb_compose_state_get_one_sym");
 #endif
 
-    _glfw.wl.display = wl_display_connect(NULL);
-    if (!_glfw.wl.display)
-    {
-        _glfwInputError(GLFW_PLATFORM_ERROR,
-                        "Wayland: Failed to connect to display");
-        return GLFW_FALSE;
-    }
-
     _glfw.wl.registry = wl_display_get_registry(_glfw.wl.display);
     wl_registry_add_listener(_glfw.wl.registry, &registryListener, NULL);
 
@@ -1285,7 +1395,7 @@ int _glfwPlatformInit(void)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminate(void)
+void _glfwTerminateWayland(void)
 {
     _glfwTerminateEGL();
     if (_glfw.wl.egl.handle)
@@ -1373,15 +1483,3 @@ void _glfwPlatformTerminate(void)
         _glfw_free(_glfw.wl.clipboardSendString);
 }
 
-const char* _glfwPlatformGetVersionString(void)
-{
-    return _GLFW_VERSION_NUMBER " Wayland EGL OSMesa"
-#if defined(_POSIX_MONOTONIC_CLOCK)
-        " monotonic"
-#endif
-        " evdev"
-#if defined(_GLFW_BUILD_DLL)
-        " shared"
-#endif
-        ;
-}
diff --git a/src/wl_monitor.c b/src/wl_monitor.c
index 11f586ad..5bdda918 100644
--- a/src/wl_monitor.c
+++ b/src/wl_monitor.c
@@ -157,13 +157,13 @@ void _glfwAddOutputWayland(uint32_t name, uint32_t version)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-void _glfwPlatformFreeMonitor(_GLFWmonitor* monitor)
+void _glfwFreeMonitorWayland(_GLFWmonitor* monitor)
 {
     if (monitor->wl.output)
         wl_output_destroy(monitor->wl.output);
 }
 
-void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
+void _glfwGetMonitorPosWayland(_GLFWmonitor* monitor, int* xpos, int* ypos)
 {
     if (xpos)
         *xpos = monitor->wl.x;
@@ -171,8 +171,8 @@ void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
         *ypos = monitor->wl.y;
 }
 
-void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
-                                         float* xscale, float* yscale)
+void _glfwGetMonitorContentScaleWayland(_GLFWmonitor* monitor,
+                                        float* xscale, float* yscale)
 {
     if (xscale)
         *xscale = (float) monitor->wl.scale;
@@ -180,9 +180,9 @@ void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
         *yscale = (float) monitor->wl.scale;
 }
 
-void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
-                                     int* xpos, int* ypos,
-                                     int* width, int* height)
+void _glfwGetMonitorWorkareaWayland(_GLFWmonitor* monitor,
+                                    int* xpos, int* ypos,
+                                    int* width, int* height)
 {
     if (xpos)
         *xpos = monitor->wl.x;
@@ -194,26 +194,25 @@ void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor,
         *height = monitor->modes[monitor->wl.currentMode].height;
 }
 
-GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* found)
+GLFWvidmode* _glfwGetVideoModesWayland(_GLFWmonitor* monitor, int* found)
 {
     *found = monitor->modeCount;
     return monitor->modes;
 }
 
-void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
+void _glfwGetVideoModeWayland(_GLFWmonitor* monitor, GLFWvidmode* mode)
 {
     *mode = monitor->modes[monitor->wl.currentMode];
 }
 
-GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
+GLFWbool _glfwGetGammaRampWayland(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
 {
     _glfwInputError(GLFW_FEATURE_UNAVAILABLE,
                     "Wayland: Gamma ramp access is not available");
     return GLFW_FALSE;
 }
 
-void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor,
-                               const GLFWgammaramp* ramp)
+void _glfwSetGammaRampWayland(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
 {
     _glfwInputError(GLFW_FEATURE_UNAVAILABLE,
                     "Wayland: Gamma ramp access is not available");
diff --git a/src/wl_platform.h b/src/wl_platform.h
index 71512b59..1e36a794 100644
--- a/src/wl_platform.h
+++ b/src/wl_platform.h
@@ -44,13 +44,6 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 typedef VkResult (APIENTRY *PFN_vkCreateWaylandSurfaceKHR)(VkInstance,const VkWaylandSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);
 typedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalDevice,uint32_t,struct wl_display*);
 
-#include "posix_thread.h"
-#include "posix_time.h"
-#ifdef __linux__
-#include "linux_joystick.h"
-#else
-#include "null_joystick.h"
-#endif
 #include "xkb_unicode.h"
 
 typedef int (* PFN_wl_display_flush)(struct wl_display *display);
@@ -75,7 +68,6 @@ typedef struct wl_proxy* (* PFN_wl_proxy_marshal_flags)(struct wl_proxy*,uint32_
 #define wl_display_cancel_read _glfw.wl.client.display_cancel_read
 #define wl_display_dispatch_pending _glfw.wl.client.display_dispatch_pending
 #define wl_display_read_events _glfw.wl.client.display_read_events
-#define wl_display_connect _glfw.wl.client.display_connect
 #define wl_display_disconnect _glfw.wl.client.display_disconnect
 #define wl_display_roundtrip _glfw.wl.client.display_roundtrip
 #define wl_display_get_fd _glfw.wl.client.display_get_fd
@@ -132,13 +124,10 @@ struct wl_shm;
 #define xdg_toplevel_interface _glfw_xdg_toplevel_interface
 #define xdg_wm_base_interface _glfw_xdg_wm_base_interface
 
-#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowWayland  wl
-#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryWayland wl
-#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorWayland wl
-#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorWayland  wl
-
-#define _GLFW_PLATFORM_CONTEXT_STATE         struct { int dummyContext; }
-#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE struct { int dummyLibraryContext; }
+#define GLFW_WAYLAND_WINDOW_STATE         _GLFWwindowWayland  wl;
+#define GLFW_WAYLAND_LIBRARY_WINDOW_STATE _GLFWlibraryWayland wl;
+#define GLFW_WAYLAND_MONITOR_STATE        _GLFWmonitorWayland wl;
+#define GLFW_WAYLAND_CURSOR_STATE         _GLFWcursorWayland  wl;
 
 struct wl_cursor_image {
     uint32_t width;
@@ -373,7 +362,6 @@ typedef struct _GLFWlibraryWayland
         PFN_wl_display_cancel_read                  display_cancel_read;
         PFN_wl_display_dispatch_pending             display_dispatch_pending;
         PFN_wl_display_read_events                  display_read_events;
-        PFN_wl_display_connect                      display_connect;
         PFN_wl_display_disconnect                   display_disconnect;
         PFN_wl_display_roundtrip                    display_roundtrip;
         PFN_wl_display_get_fd                       display_get_fd;
@@ -432,6 +420,80 @@ typedef struct _GLFWcursorWayland
     int                         currentImage;
 } _GLFWcursorWayland;
 
+GLFWbool _glfwConnectWayland(int platformID, _GLFWplatform* platform);
+int _glfwInitWayland(void);
+void _glfwTerminateWayland(void);
+
+int _glfwCreateWindowWayland(_GLFWwindow* window, const _GLFWwndconfig* wndconfig, const _GLFWctxconfig* ctxconfig, const _GLFWfbconfig* fbconfig);
+void _glfwDestroyWindowWayland(_GLFWwindow* window);
+void _glfwSetWindowTitleWayland(_GLFWwindow* window, const char* title);
+void _glfwSetWindowIconWayland(_GLFWwindow* window, int count, const GLFWimage* images);
+void _glfwGetWindowPosWayland(_GLFWwindow* window, int* xpos, int* ypos);
+void _glfwSetWindowPosWayland(_GLFWwindow* window, int xpos, int ypos);
+void _glfwGetWindowSizeWayland(_GLFWwindow* window, int* width, int* height);
+void _glfwSetWindowSizeWayland(_GLFWwindow* window, int width, int height);
+void _glfwSetWindowSizeLimitsWayland(_GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
+void _glfwSetWindowAspectRatioWayland(_GLFWwindow* window, int numer, int denom);
+void _glfwGetFramebufferSizeWayland(_GLFWwindow* window, int* width, int* height);
+void _glfwGetWindowFrameSizeWayland(_GLFWwindow* window, int* left, int* top, int* right, int* bottom);
+void _glfwGetWindowContentScaleWayland(_GLFWwindow* window, float* xscale, float* yscale);
+void _glfwIconifyWindowWayland(_GLFWwindow* window);
+void _glfwRestoreWindowWayland(_GLFWwindow* window);
+void _glfwMaximizeWindowWayland(_GLFWwindow* window);
+void _glfwShowWindowWayland(_GLFWwindow* window);
+void _glfwHideWindowWayland(_GLFWwindow* window);
+void _glfwRequestWindowAttentionWayland(_GLFWwindow* window);
+void _glfwFocusWindowWayland(_GLFWwindow* window);
+void _glfwSetWindowMonitorWayland(_GLFWwindow* window, _GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
+int _glfwWindowFocusedWayland(_GLFWwindow* window);
+int _glfwWindowIconifiedWayland(_GLFWwindow* window);
+int _glfwWindowVisibleWayland(_GLFWwindow* window);
+int _glfwWindowMaximizedWayland(_GLFWwindow* window);
+int _glfwWindowHoveredWayland(_GLFWwindow* window);
+int _glfwFramebufferTransparentWayland(_GLFWwindow* window);
+void _glfwSetWindowResizableWayland(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowDecoratedWayland(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowFloatingWayland(_GLFWwindow* window, GLFWbool enabled);
+float _glfwGetWindowOpacityWayland(_GLFWwindow* window);
+void _glfwSetWindowOpacityWayland(_GLFWwindow* window, float opacity);
+void _glfwSetWindowMousePassthroughWayland(_GLFWwindow* window, GLFWbool enabled);
+
+void _glfwSetRawMouseMotionWayland(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwRawMouseMotionSupportedWayland(void);
+
+void _glfwPollEventsWayland(void);
+void _glfwWaitEventsWayland(void);
+void _glfwWaitEventsTimeoutWayland(double timeout);
+void _glfwPostEmptyEventWayland(void);
+
+void _glfwGetCursorPosWayland(_GLFWwindow* window, double* xpos, double* ypos);
+void _glfwSetCursorPosWayland(_GLFWwindow* window, double xpos, double ypos);
+void _glfwSetCursorModeWayland(_GLFWwindow* window, int mode);
+const char* _glfwGetScancodeNameWayland(int scancode);
+int _glfwGetKeyScancodeWayland(int key);
+int _glfwCreateCursorWayland(_GLFWcursor* cursor, const GLFWimage* image, int xhot, int yhot);
+int _glfwCreateStandardCursorWayland(_GLFWcursor* cursor, int shape);
+void _glfwDestroyCursorWayland(_GLFWcursor* cursor);
+void _glfwSetCursorWayland(_GLFWwindow* window, _GLFWcursor* cursor);
+void _glfwSetClipboardStringWayland(const char* string);
+const char* _glfwGetClipboardStringWayland(void);
+
+EGLenum _glfwGetEGLPlatformWayland(EGLint** attribs);
+EGLNativeDisplayType _glfwGetEGLNativeDisplayWayland(void);
+EGLNativeWindowType _glfwGetEGLNativeWindowWayland(_GLFWwindow* window);
+
+void _glfwGetRequiredInstanceExtensionsWayland(char** extensions);
+int _glfwGetPhysicalDevicePresentationSupportWayland(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily);
+VkResult _glfwCreateWindowSurfaceWayland(VkInstance instance, _GLFWwindow* window, const VkAllocationCallbacks* allocator, VkSurfaceKHR* surface);
+
+void _glfwFreeMonitorWayland(_GLFWmonitor* monitor);
+void _glfwGetMonitorPosWayland(_GLFWmonitor* monitor, int* xpos, int* ypos);
+void _glfwGetMonitorContentScaleWayland(_GLFWmonitor* monitor, float* xscale, float* yscale);
+void _glfwGetMonitorWorkareaWayland(_GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
+GLFWvidmode* _glfwGetVideoModesWayland(_GLFWmonitor* monitor, int* count);
+void _glfwGetVideoModeWayland(_GLFWmonitor* monitor, GLFWvidmode* mode);
+GLFWbool _glfwGetGammaRampWayland(_GLFWmonitor* monitor, GLFWgammaramp* ramp);
+void _glfwSetGammaRampWayland(_GLFWmonitor* monitor, const GLFWgammaramp* ramp);
 
 void _glfwAddOutputWayland(uint32_t name, uint32_t version);
 
diff --git a/src/wl_window.c b/src/wl_window.c
index 06cd7084..bf57ce53 100644
--- a/src/wl_window.c
+++ b/src/wl_window.c
@@ -526,7 +526,7 @@ static void xdgToplevelHandleConfigure(void* data,
         }
 
         _glfwInputWindowSize(window, width, height);
-        _glfwPlatformSetWindowSize(window, width, height);
+        _glfwSetWindowSizeWayland(window, width, height);
         _glfwInputWindowDamage(window);
     }
 
@@ -534,7 +534,7 @@ static void xdgToplevelHandleConfigure(void* data,
     {
         if (!activated || !fullscreen)
         {
-            _glfwPlatformIconifyWindow(window);
+            _glfwIconifyWindowWayland(window);
             window->wl.wasFullscreen = GLFW_FALSE;
         }
     }
@@ -789,10 +789,10 @@ static void handleEvents(int timeout)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformCreateWindow(_GLFWwindow* window,
-                              const _GLFWwndconfig* wndconfig,
-                              const _GLFWctxconfig* ctxconfig,
-                              const _GLFWfbconfig* fbconfig)
+int _glfwCreateWindowWayland(_GLFWwindow* window,
+                             const _GLFWwndconfig* wndconfig,
+                             const _GLFWctxconfig* ctxconfig,
+                             const _GLFWfbconfig* fbconfig)
 {
     window->wl.transparent = fbconfig->transparent;
 
@@ -844,7 +844,7 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyWindow(_GLFWwindow* window)
+void _glfwDestroyWindowWayland(_GLFWwindow* window)
 {
     if (window == _glfw.wl.pointerFocus)
     {
@@ -886,7 +886,7 @@ void _glfwPlatformDestroyWindow(_GLFWwindow* window)
     _glfw_free(window->wl.monitors);
 }
 
-void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
+void _glfwSetWindowTitleWayland(_GLFWwindow* window, const char* title)
 {
     if (window->wl.title)
         _glfw_free(window->wl.title);
@@ -895,14 +895,14 @@ void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
         xdg_toplevel_set_title(window->wl.xdg.toplevel, title);
 }
 
-void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
-                                int count, const GLFWimage* images)
+void _glfwSetWindowIconWayland(_GLFWwindow* window,
+                               int count, const GLFWimage* images)
 {
     _glfwInputError(GLFW_FEATURE_UNAVAILABLE,
                     "Wayland: The platform does not support setting the window icon");
 }
 
-void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
+void _glfwGetWindowPosWayland(_GLFWwindow* window, int* xpos, int* ypos)
 {
     // A Wayland client is not aware of its position, so just warn and leave it
     // as (0, 0)
@@ -911,7 +911,7 @@ void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
                     "Wayland: The platform does not provide the window position");
 }
 
-void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
+void _glfwSetWindowPosWayland(_GLFWwindow* window, int xpos, int ypos)
 {
     // A Wayland client can not set its position, so just warn
 
@@ -919,7 +919,7 @@ void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
                     "Wayland: The platform does not support setting the window position");
 }
 
-void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetWindowSizeWayland(_GLFWwindow* window, int* width, int* height)
 {
     if (width)
         *width = window->wl.width;
@@ -927,16 +927,16 @@ void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
         *height = window->wl.height;
 }
 
-void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
+void _glfwSetWindowSizeWayland(_GLFWwindow* window, int width, int height)
 {
     window->wl.width = width;
     window->wl.height = height;
     resizeWindow(window);
 }
 
-void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
-                                      int minwidth, int minheight,
-                                      int maxwidth, int maxheight)
+void _glfwSetWindowSizeLimitsWayland(_GLFWwindow* window,
+                                     int minwidth, int minheight,
+                                     int maxwidth, int maxheight)
 {
     if (window->wl.xdg.toplevel)
     {
@@ -950,8 +950,7 @@ void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
     }
 }
 
-void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window,
-                                       int numer, int denom)
+void _glfwSetWindowAspectRatioWayland(_GLFWwindow* window, int numer, int denom)
 {
     // TODO: find out how to trigger a resize.
     // The actual limits are checked in the xdg_toplevel::configure handler.
@@ -959,19 +958,18 @@ void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window,
                     "Wayland: Window aspect ratio not yet implemented");
 }
 
-void _glfwPlatformGetFramebufferSize(_GLFWwindow* window,
-                                     int* width, int* height)
+void _glfwGetFramebufferSizeWayland(_GLFWwindow* window, int* width, int* height)
 {
-    _glfwPlatformGetWindowSize(window, width, height);
+    _glfwGetWindowSizeWayland(window, width, height);
     if (width)
         *width *= window->wl.scale;
     if (height)
         *height *= window->wl.scale;
 }
 
-void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
-                                     int* left, int* top,
-                                     int* right, int* bottom)
+void _glfwGetWindowFrameSizeWayland(_GLFWwindow* window,
+                                    int* left, int* top,
+                                    int* right, int* bottom)
 {
     if (window->decorated && !window->monitor && !window->wl.decorations.serverSide)
     {
@@ -986,8 +984,8 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
     }
 }
 
-void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
-                                        float* xscale, float* yscale)
+void _glfwGetWindowContentScaleWayland(_GLFWwindow* window,
+                                       float* xscale, float* yscale)
 {
     if (xscale)
         *xscale = (float) window->wl.scale;
@@ -995,13 +993,13 @@ void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
         *yscale = (float) window->wl.scale;
 }
 
-void _glfwPlatformIconifyWindow(_GLFWwindow* window)
+void _glfwIconifyWindowWayland(_GLFWwindow* window)
 {
     if (window->wl.xdg.toplevel)
         xdg_toplevel_set_minimized(window->wl.xdg.toplevel);
 }
 
-void _glfwPlatformRestoreWindow(_GLFWwindow* window)
+void _glfwRestoreWindowWayland(_GLFWwindow* window)
 {
     if (window->wl.xdg.toplevel)
     {
@@ -1016,7 +1014,7 @@ void _glfwPlatformRestoreWindow(_GLFWwindow* window)
     window->wl.maximized = GLFW_FALSE;
 }
 
-void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
+void _glfwMaximizeWindowWayland(_GLFWwindow* window)
 {
     if (window->wl.xdg.toplevel)
     {
@@ -1025,7 +1023,7 @@ void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
     window->wl.maximized = GLFW_TRUE;
 }
 
-void _glfwPlatformShowWindow(_GLFWwindow* window)
+void _glfwShowWindowWayland(_GLFWwindow* window)
 {
     if (!window->wl.visible)
     {
@@ -1034,7 +1032,7 @@ void _glfwPlatformShowWindow(_GLFWwindow* window)
     }
 }
 
-void _glfwPlatformHideWindow(_GLFWwindow* window)
+void _glfwHideWindowWayland(_GLFWwindow* window)
 {
     if (window->wl.xdg.toplevel)
     {
@@ -1046,24 +1044,24 @@ void _glfwPlatformHideWindow(_GLFWwindow* window)
     window->wl.visible = GLFW_FALSE;
 }
 
-void _glfwPlatformRequestWindowAttention(_GLFWwindow* window)
+void _glfwRequestWindowAttentionWayland(_GLFWwindow* window)
 {
     // TODO
     _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
                     "Wayland: Window attention request not implemented yet");
 }
 
-void _glfwPlatformFocusWindow(_GLFWwindow* window)
+void _glfwFocusWindowWayland(_GLFWwindow* window)
 {
     _glfwInputError(GLFW_FEATURE_UNAVAILABLE,
                     "Wayland: The platform does not support setting the input focus");
 }
 
-void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
-                                   _GLFWmonitor* monitor,
-                                   int xpos, int ypos,
-                                   int width, int height,
-                                   int refreshRate)
+void _glfwSetWindowMonitorWayland(_GLFWwindow* window,
+                                  _GLFWmonitor* monitor,
+                                  int xpos, int ypos,
+                                  int width, int height,
+                                  int refreshRate)
 {
     if (monitor)
     {
@@ -1080,46 +1078,46 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
     _glfwInputWindowMonitor(window, monitor);
 }
 
-int _glfwPlatformWindowFocused(_GLFWwindow* window)
+int _glfwWindowFocusedWayland(_GLFWwindow* window)
 {
     return _glfw.wl.keyboardFocus == window;
 }
 
-int _glfwPlatformWindowIconified(_GLFWwindow* window)
+int _glfwWindowIconifiedWayland(_GLFWwindow* window)
 {
     // xdg-shell doesnt give any way to request whether a surface is
     // iconified.
     return GLFW_FALSE;
 }
 
-int _glfwPlatformWindowVisible(_GLFWwindow* window)
+int _glfwWindowVisibleWayland(_GLFWwindow* window)
 {
     return window->wl.visible;
 }
 
-int _glfwPlatformWindowMaximized(_GLFWwindow* window)
+int _glfwWindowMaximizedWayland(_GLFWwindow* window)
 {
     return window->wl.maximized;
 }
 
-int _glfwPlatformWindowHovered(_GLFWwindow* window)
+int _glfwWindowHoveredWayland(_GLFWwindow* window)
 {
     return window->wl.hovered;
 }
 
-int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
+int _glfwFramebufferTransparentWayland(_GLFWwindow* window)
 {
     return window->wl.transparent;
 }
 
-void _glfwPlatformSetWindowResizable(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowResizableWayland(_GLFWwindow* window, GLFWbool enabled)
 {
     // TODO
     _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
                     "Wayland: Window attribute setting not implemented yet");
 }
 
-void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowDecoratedWayland(_GLFWwindow* window, GLFWbool enabled)
 {
     if (!window->monitor)
     {
@@ -1130,14 +1128,14 @@ void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
     }
 }
 
-void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowFloatingWayland(_GLFWwindow* window, GLFWbool enabled)
 {
     // TODO
     _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
                     "Wayland: Window attribute setting not implemented yet");
 }
 
-void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowMousePassthroughWayland(_GLFWwindow* window, GLFWbool enabled)
 {
     if (enabled)
     {
@@ -1150,48 +1148,48 @@ void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enable
     wl_surface_commit(window->wl.surface);
 }
 
-float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
+float _glfwGetWindowOpacityWayland(_GLFWwindow* window)
 {
     return 1.f;
 }
 
-void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
+void _glfwSetWindowOpacityWayland(_GLFWwindow* window, float opacity)
 {
     _glfwInputError(GLFW_FEATURE_UNAVAILABLE,
                     "Wayland: The platform does not support setting the window opacity");
 }
 
-void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
+void _glfwSetRawMouseMotionWayland(_GLFWwindow *window, GLFWbool enabled)
 {
     // This is handled in relativePointerHandleRelativeMotion
 }
 
-GLFWbool _glfwPlatformRawMouseMotionSupported(void)
+GLFWbool _glfwRawMouseMotionSupportedWayland(void)
 {
     return GLFW_TRUE;
 }
 
-void _glfwPlatformPollEvents(void)
+void _glfwPollEventsWayland(void)
 {
     handleEvents(0);
 }
 
-void _glfwPlatformWaitEvents(void)
+void _glfwWaitEventsWayland(void)
 {
     handleEvents(-1);
 }
 
-void _glfwPlatformWaitEventsTimeout(double timeout)
+void _glfwWaitEventsTimeoutWayland(double timeout)
 {
     handleEvents((int) (timeout * 1e3));
 }
 
-void _glfwPlatformPostEmptyEvent(void)
+void _glfwPostEmptyEventWayland(void)
 {
     wl_display_sync(_glfw.wl.display);
 }
 
-void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
+void _glfwGetCursorPosWayland(_GLFWwindow* window, double* xpos, double* ypos)
 {
     if (xpos)
         *xpos = window->wl.cursorPosX;
@@ -1201,7 +1199,7 @@ void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
 
 static GLFWbool isPointerLocked(_GLFWwindow* window);
 
-void _glfwPlatformSetCursorPos(_GLFWwindow* window, double x, double y)
+void _glfwSetCursorPosWayland(_GLFWwindow* window, double x, double y)
 {
     if (isPointerLocked(window))
     {
@@ -1212,12 +1210,12 @@ void _glfwPlatformSetCursorPos(_GLFWwindow* window, double x, double y)
     }
 }
 
-void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
+void _glfwSetCursorModeWayland(_GLFWwindow* window, int mode)
 {
-    _glfwPlatformSetCursor(window, window->wl.currentCursor);
+    _glfwSetCursorWayland(window, window->wl.currentCursor);
 }
 
-const char* _glfwPlatformGetScancodeName(int scancode)
+const char* _glfwGetScancodeNameWayland(int scancode)
 {
     // TODO
     _glfwInputError(GLFW_FEATURE_UNIMPLEMENTED,
@@ -1225,14 +1223,14 @@ const char* _glfwPlatformGetScancodeName(int scancode)
     return NULL;
 }
 
-int _glfwPlatformGetKeyScancode(int key)
+int _glfwGetKeyScancodeWayland(int key)
 {
     return _glfw.wl.scancodes[key];
 }
 
-int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
-                              const GLFWimage* image,
-                              int xhot, int yhot)
+int _glfwCreateCursorWayland(_GLFWcursor* cursor,
+                             const GLFWimage* image,
+                             int xhot, int yhot)
 {
     cursor->wl.buffer = createShmBuffer(image);
     if (!cursor->wl.buffer)
@@ -1245,7 +1243,7 @@ int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
     return GLFW_TRUE;
 }
 
-int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
+int _glfwCreateStandardCursorWayland(_GLFWcursor* cursor, int shape)
 {
     const char* name = NULL;
 
@@ -1346,7 +1344,7 @@ int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
+void _glfwDestroyCursorWayland(_GLFWcursor* cursor)
 {
     // If it's a standard cursor we don't need to do anything here
     if (cursor->wl.cursor)
@@ -1464,7 +1462,7 @@ static GLFWbool isPointerLocked(_GLFWwindow* window)
     return window->wl.pointerLock.lockedPointer != NULL;
 }
 
-void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
+void _glfwSetCursorWayland(_GLFWwindow* window, _GLFWcursor* cursor)
 {
     struct wl_cursor* defaultCursor;
     struct wl_cursor* defaultCursorHiDPI = NULL;
@@ -1605,7 +1603,7 @@ static const struct wl_data_source_listener dataSourceListener = {
     dataSourceHandleCancelled,
 };
 
-void _glfwPlatformSetClipboardString(const char* string)
+void _glfwSetClipboardStringWayland(const char* string)
 {
     if (_glfw.wl.dataSource)
     {
@@ -1661,7 +1659,7 @@ static GLFWbool growClipboardString(void)
     return GLFW_TRUE;
 }
 
-const char* _glfwPlatformGetClipboardString(void)
+const char* _glfwGetClipboardStringWayland(void)
 {
     int fds[2];
     int ret;
@@ -1728,7 +1726,7 @@ const char* _glfwPlatformGetClipboardString(void)
     return _glfw.wl.clipboardString;
 }
 
-EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
+EGLenum _glfwGetEGLPlatformWayland(EGLint** attribs)
 {
     if (_glfw.egl.EXT_platform_base && _glfw.egl.EXT_platform_wayland)
         return EGL_PLATFORM_WAYLAND_EXT;
@@ -1736,17 +1734,17 @@ EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
         return 0;
 }
 
-EGLNativeDisplayType _glfwPlatformGetEGLNativeDisplay(void)
+EGLNativeDisplayType _glfwGetEGLNativeDisplayWayland(void)
 {
     return _glfw.wl.display;
 }
 
-EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window)
+EGLNativeWindowType _glfwGetEGLNativeWindowWayland(_GLFWwindow* window)
 {
     return window->wl.native;
 }
 
-void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
+void _glfwGetRequiredInstanceExtensionsWayland(char** extensions)
 {
     if (!_glfw.vk.KHR_surface || !_glfw.vk.KHR_wayland_surface)
         return;
@@ -1755,9 +1753,9 @@ void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
     extensions[1] = "VK_KHR_wayland_surface";
 }
 
-int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
-                                                      VkPhysicalDevice device,
-                                                      uint32_t queuefamily)
+int _glfwGetPhysicalDevicePresentationSupportWayland(VkInstance instance,
+                                                     VkPhysicalDevice device,
+                                                     uint32_t queuefamily)
 {
     PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR
         vkGetPhysicalDeviceWaylandPresentationSupportKHR =
@@ -1775,10 +1773,10 @@ int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
                                                             _glfw.wl.display);
 }
 
-VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
-                                          _GLFWwindow* window,
-                                          const VkAllocationCallbacks* allocator,
-                                          VkSurfaceKHR* surface)
+VkResult _glfwCreateWindowSurfaceWayland(VkInstance instance,
+                                         _GLFWwindow* window,
+                                         const VkAllocationCallbacks* allocator,
+                                         VkSurfaceKHR* surface)
 {
     VkResult err;
     VkWaylandSurfaceCreateInfoKHR sci;
@@ -1817,6 +1815,14 @@ VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
 GLFWAPI struct wl_display* glfwGetWaylandDisplay(void)
 {
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+
+    if (_glfw.platform.platformID != GLFW_PLATFORM_WAYLAND)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                        "Wayland: Platform not initialized");
+        return NULL;
+    }
+
     return _glfw.wl.display;
 }
 
@@ -1824,6 +1830,14 @@ GLFWAPI struct wl_surface* glfwGetWaylandWindow(GLFWwindow* handle)
 {
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+
+    if (_glfw.platform.platformID != GLFW_PLATFORM_WAYLAND)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                        "Wayland: Platform not initialized");
+        return NULL;
+    }
+
     return window->wl.surface;
 }
 
diff --git a/src/x11_init.c b/src/x11_init.c
index 34e52252..bedd1bc9 100644
--- a/src/x11_init.c
+++ b/src/x11_init.c
@@ -1007,7 +1007,7 @@ static Cursor createHiddenCursor(void)
 {
     unsigned char pixels[16 * 16 * 4] = { 0 };
     GLFWimage image = { 16, 16, pixels };
-    return _glfwCreateCursorX11(&image, 0, 0);
+    return _glfwCreateNativeCursorX11(&image, 0, 0);
 }
 
 // Create a helper window for IPC
@@ -1070,7 +1070,7 @@ void _glfwInputErrorX11(int error, const char* message)
 
 // Creates a native cursor object from the specified image and hotspot
 //
-Cursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot)
+Cursor _glfwCreateNativeCursorX11(const GLFWimage* image, int xhot, int yhot)
 {
     int i;
     Cursor cursor;
@@ -1109,8 +1109,92 @@ Cursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformInit(void)
+GLFWbool _glfwConnectX11(int platformID, _GLFWplatform* platform)
 {
+    const _GLFWplatform x11 =
+    {
+        GLFW_PLATFORM_X11,
+        _glfwInitX11,
+        _glfwTerminateX11,
+        _glfwGetCursorPosX11,
+        _glfwSetCursorPosX11,
+        _glfwSetCursorModeX11,
+        _glfwSetRawMouseMotionX11,
+        _glfwRawMouseMotionSupportedX11,
+        _glfwCreateCursorX11,
+        _glfwCreateStandardCursorX11,
+        _glfwDestroyCursorX11,
+        _glfwSetCursorX11,
+        _glfwGetScancodeNameX11,
+        _glfwGetKeyScancodeX11,
+        _glfwSetClipboardStringX11,
+        _glfwGetClipboardStringX11,
+#if defined(__linux__)
+        _glfwInitJoysticksLinux,
+        _glfwTerminateJoysticksLinux,
+        _glfwPollJoystickLinux,
+        _glfwGetMappingNameLinux,
+        _glfwUpdateGamepadGUIDLinux,
+#else
+        _glfwInitJoysticksNull,
+        _glfwTerminateJoysticksNull,
+        _glfwPollJoystickNull,
+        _glfwGetMappingNameNull,
+        _glfwUpdateGamepadGUIDNull,
+#endif
+        _glfwFreeMonitorX11,
+        _glfwGetMonitorPosX11,
+        _glfwGetMonitorContentScaleX11,
+        _glfwGetMonitorWorkareaX11,
+        _glfwGetVideoModesX11,
+        _glfwGetVideoModeX11,
+        _glfwGetGammaRampX11,
+        _glfwSetGammaRampX11,
+        _glfwCreateWindowX11,
+        _glfwDestroyWindowX11,
+        _glfwSetWindowTitleX11,
+        _glfwSetWindowIconX11,
+        _glfwGetWindowPosX11,
+        _glfwSetWindowPosX11,
+        _glfwGetWindowSizeX11,
+        _glfwSetWindowSizeX11,
+        _glfwSetWindowSizeLimitsX11,
+        _glfwSetWindowAspectRatioX11,
+        _glfwGetFramebufferSizeX11,
+        _glfwGetWindowFrameSizeX11,
+        _glfwGetWindowContentScaleX11,
+        _glfwIconifyWindowX11,
+        _glfwRestoreWindowX11,
+        _glfwMaximizeWindowX11,
+        _glfwShowWindowX11,
+        _glfwHideWindowX11,
+        _glfwRequestWindowAttentionX11,
+        _glfwFocusWindowX11,
+        _glfwSetWindowMonitorX11,
+        _glfwWindowFocusedX11,
+        _glfwWindowIconifiedX11,
+        _glfwWindowVisibleX11,
+        _glfwWindowMaximizedX11,
+        _glfwWindowHoveredX11,
+        _glfwFramebufferTransparentX11,
+        _glfwGetWindowOpacityX11,
+        _glfwSetWindowResizableX11,
+        _glfwSetWindowDecoratedX11,
+        _glfwSetWindowFloatingX11,
+        _glfwSetWindowOpacityX11,
+        _glfwSetWindowMousePassthroughX11,
+        _glfwPollEventsX11,
+        _glfwWaitEventsX11,
+        _glfwWaitEventsTimeoutX11,
+        _glfwPostEmptyEventX11,
+        _glfwGetEGLPlatformX11,
+        _glfwGetEGLNativeDisplayX11,
+        _glfwGetEGLNativeWindowX11,
+        _glfwGetRequiredInstanceExtensionsX11,
+        _glfwGetPhysicalDevicePresentationSupportX11,
+        _glfwCreateWindowSurfaceX11,
+    };
+
     // HACK: If the application has left the locale as "C" then both wide
     //       character text input and explicit UTF-8 input via XIM will break
     //       This sets the CTYPE part of the current locale from the environment
@@ -1119,16 +1203,67 @@ int _glfwPlatformInit(void)
         setlocale(LC_CTYPE, "");
 
 #if defined(__CYGWIN__)
-    _glfw.x11.xlib.handle = _glfwPlatformLoadModule("libX11-6.so");
+    void* module = _glfwPlatformLoadModule("libX11-6.so");
 #else
-    _glfw.x11.xlib.handle = _glfwPlatformLoadModule("libX11.so.6");
+    void* module = _glfwPlatformLoadModule("libX11.so.6");
 #endif
-    if (!_glfw.x11.xlib.handle)
+    if (!module)
     {
-        _glfwInputError(GLFW_PLATFORM_ERROR, "X11: Failed to load Xlib");
+        if (platformID == GLFW_PLATFORM_X11)
+            _glfwInputError(GLFW_PLATFORM_ERROR, "X11: Failed to load Xlib");
+
+        return GLFW_FALSE;
+    }
+
+    PFN_XInitThreads XInitThreads = (PFN_XInitThreads)
+        _glfwPlatformGetModuleSymbol(module, "XInitThreads");
+    PFN_XrmInitialize XrmInitialize = (PFN_XrmInitialize)
+        _glfwPlatformGetModuleSymbol(module, "XrmInitialize");
+    PFN_XOpenDisplay XOpenDisplay = (PFN_XOpenDisplay)
+        _glfwPlatformGetModuleSymbol(module, "XOpenDisplay");
+    if (!XInitThreads || !XrmInitialize || !XOpenDisplay)
+    {
+        if (platformID == GLFW_PLATFORM_X11)
+            _glfwInputError(GLFW_PLATFORM_ERROR, "X11: Failed to load Xlib entry point");
+
+        _glfwPlatformFreeModule(module);
+        return GLFW_FALSE;
+    }
+
+    XInitThreads();
+    XrmInitialize();
+
+    Display* display = XOpenDisplay(NULL);
+    if (!display)
+    {
+        if (platformID == GLFW_PLATFORM_X11)
+        {
+            const char* name = getenv("DISPLAY");
+            if (name)
+            {
+                _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                                "X11: Failed to open display %s", name);
+            }
+            else
+            {
+                _glfwInputError(GLFW_PLATFORM_UNAVAILABLE,
+                                "X11: The DISPLAY environment variable is missing");
+            }
+        }
+
+        _glfwPlatformFreeModule(module);
         return GLFW_FALSE;
     }
 
+    _glfw.x11.display = display;
+    _glfw.x11.xlib.handle = module;
+
+    *platform = x11;
+    return GLFW_TRUE;
+}
+
+int _glfwInitX11(void)
+{
     _glfw.x11.xlib.AllocClassHint = (PFN_XAllocClassHint)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XAllocClassHint");
     _glfw.x11.xlib.AllocSizeHints = (PFN_XAllocSizeHints)
@@ -1217,8 +1352,6 @@ int _glfwPlatformInit(void)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XGrabPointer");
     _glfw.x11.xlib.IconifyWindow = (PFN_XIconifyWindow)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XIconifyWindow");
-    _glfw.x11.xlib.InitThreads = (PFN_XInitThreads)
-        _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XInitThreads");
     _glfw.x11.xlib.InternAtom = (PFN_XInternAtom)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XInternAtom");
     _glfw.x11.xlib.LookupString = (PFN_XLookupString)
@@ -1233,8 +1366,6 @@ int _glfwPlatformInit(void)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XMoveWindow");
     _glfw.x11.xlib.NextEvent = (PFN_XNextEvent)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XNextEvent");
-    _glfw.x11.xlib.OpenDisplay = (PFN_XOpenDisplay)
-        _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XOpenDisplay");
     _glfw.x11.xlib.OpenIM = (PFN_XOpenIM)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XOpenIM");
     _glfw.x11.xlib.PeekEvent = (PFN_XPeekEvent)
@@ -1323,8 +1454,6 @@ int _glfwPlatformInit(void)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XrmGetResource");
     _glfw.x11.xrm.GetStringDatabase = (PFN_XrmGetStringDatabase)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XrmGetStringDatabase");
-    _glfw.x11.xrm.Initialize = (PFN_XrmInitialize)
-        _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XrmInitialize");
     _glfw.x11.xrm.UniqueQuark = (PFN_XrmUniqueQuark)
         _glfwPlatformGetModuleSymbol(_glfw.x11.xlib.handle, "XrmUniqueQuark");
     _glfw.x11.xlib.UnregisterIMInstantiateCallback = (PFN_XUnregisterIMInstantiateCallback)
@@ -1337,27 +1466,6 @@ int _glfwPlatformInit(void)
     if (_glfw.x11.xlib.utf8LookupString && _glfw.x11.xlib.utf8SetWMProperties)
         _glfw.x11.xlib.utf8 = GLFW_TRUE;
 
-    XInitThreads();
-    XrmInitialize();
-
-    _glfw.x11.display = XOpenDisplay(NULL);
-    if (!_glfw.x11.display)
-    {
-        const char* display = getenv("DISPLAY");
-        if (display)
-        {
-            _glfwInputError(GLFW_PLATFORM_ERROR,
-                            "X11: Failed to open display %s", display);
-        }
-        else
-        {
-            _glfwInputError(GLFW_PLATFORM_ERROR,
-                            "X11: The DISPLAY environment variable is missing");
-        }
-
-        return GLFW_FALSE;
-    }
-
     _glfw.x11.screen = DefaultScreen(_glfw.x11.display);
     _glfw.x11.root = RootWindow(_glfw.x11.display, _glfw.x11.screen);
     _glfw.x11.context = XUniqueContext();
@@ -1385,7 +1493,7 @@ int _glfwPlatformInit(void)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformTerminate(void)
+void _glfwTerminateX11(void)
 {
     if (_glfw.x11.helperWindowHandle)
     {
@@ -1479,18 +1587,3 @@ void _glfwPlatformTerminate(void)
     }
 }
 
-const char* _glfwPlatformGetVersionString(void)
-{
-    return _GLFW_VERSION_NUMBER " X11 GLX EGL OSMesa"
-#if defined(_POSIX_MONOTONIC_CLOCK)
-        " monotonic"
-#endif
-#if defined(__linux__)
-        " evdev"
-#endif
-#if defined(_GLFW_BUILD_DLL)
-        " shared"
-#endif
-        ;
-}
-
diff --git a/src/x11_monitor.c b/src/x11_monitor.c
index 97da48db..b031c83c 100644
--- a/src/x11_monitor.c
+++ b/src/x11_monitor.c
@@ -232,7 +232,7 @@ void _glfwSetVideoModeX11(_GLFWmonitor* monitor, const GLFWvidmode* desired)
         RRMode native = None;
 
         const GLFWvidmode* best = _glfwChooseVideoMode(monitor, desired);
-        _glfwPlatformGetVideoMode(monitor, &current);
+        _glfwGetVideoModeX11(monitor, &current);
         if (_glfwCompareVideoModes(&current, best) == 0)
             return;
 
@@ -310,11 +310,11 @@ void _glfwRestoreVideoModeX11(_GLFWmonitor* monitor)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-void _glfwPlatformFreeMonitor(_GLFWmonitor* monitor)
+void _glfwFreeMonitorX11(_GLFWmonitor* monitor)
 {
 }
 
-void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
+void _glfwGetMonitorPosX11(_GLFWmonitor* monitor, int* xpos, int* ypos)
 {
     if (_glfw.x11.randr.available && !_glfw.x11.randr.monitorBroken)
     {
@@ -336,8 +336,8 @@ void _glfwPlatformGetMonitorPos(_GLFWmonitor* monitor, int* xpos, int* ypos)
     }
 }
 
-void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
-                                         float* xscale, float* yscale)
+void _glfwGetMonitorContentScaleX11(_GLFWmonitor* monitor,
+                                    float* xscale, float* yscale)
 {
     if (xscale)
         *xscale = _glfw.x11.contentScaleX;
@@ -345,7 +345,9 @@ void _glfwPlatformGetMonitorContentScale(_GLFWmonitor* monitor,
         *yscale = _glfw.x11.contentScaleY;
 }
 
-void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height)
+void _glfwGetMonitorWorkareaX11(_GLFWmonitor* monitor,
+                                int* xpos, int* ypos,
+                                int* width, int* height)
 {
     int areaX = 0, areaY = 0, areaWidth = 0, areaHeight = 0;
 
@@ -437,7 +439,7 @@ void _glfwPlatformGetMonitorWorkarea(_GLFWmonitor* monitor, int* xpos, int* ypos
         *height = areaHeight;
 }
 
-GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count)
+GLFWvidmode* _glfwGetVideoModesX11(_GLFWmonitor* monitor, int* count)
 {
     GLFWvidmode* result;
 
@@ -483,13 +485,13 @@ GLFWvidmode* _glfwPlatformGetVideoModes(_GLFWmonitor* monitor, int* count)
     {
         *count = 1;
         result = _glfw_calloc(1, sizeof(GLFWvidmode));
-        _glfwPlatformGetVideoMode(monitor, result);
+        _glfwGetVideoModeX11(monitor, result);
     }
 
     return result;
 }
 
-void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
+void _glfwGetVideoModeX11(_GLFWmonitor* monitor, GLFWvidmode* mode)
 {
     if (_glfw.x11.randr.available && !_glfw.x11.randr.monitorBroken)
     {
@@ -519,7 +521,7 @@ void _glfwPlatformGetVideoMode(_GLFWmonitor* monitor, GLFWvidmode* mode)
     }
 }
 
-GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
+GLFWbool _glfwGetGammaRampX11(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
 {
     if (_glfw.x11.randr.available && !_glfw.x11.randr.gammaBroken)
     {
@@ -557,7 +559,7 @@ GLFWbool _glfwPlatformGetGammaRamp(_GLFWmonitor* monitor, GLFWgammaramp* ramp)
     }
 }
 
-void _glfwPlatformSetGammaRamp(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
+void _glfwSetGammaRampX11(_GLFWmonitor* monitor, const GLFWgammaramp* ramp)
 {
     if (_glfw.x11.randr.available && !_glfw.x11.randr.gammaBroken)
     {
diff --git a/src/x11_platform.h b/src/x11_platform.h
index 76444a87..61a0b17d 100644
--- a/src/x11_platform.h
+++ b/src/x11_platform.h
@@ -243,7 +243,6 @@ typedef void (* PFN_Xutf8SetWMProperties)(Display*,Window,const char*,const char
 #define XGetWindowProperty _glfw.x11.xlib.GetWindowProperty
 #define XGrabPointer _glfw.x11.xlib.GrabPointer
 #define XIconifyWindow _glfw.x11.xlib.IconifyWindow
-#define XInitThreads _glfw.x11.xlib.InitThreads
 #define XInternAtom _glfw.x11.xlib.InternAtom
 #define XLookupString _glfw.x11.xlib.LookupString
 #define XMapRaised _glfw.x11.xlib.MapRaised
@@ -251,7 +250,6 @@ typedef void (* PFN_Xutf8SetWMProperties)(Display*,Window,const char*,const char
 #define XMoveResizeWindow _glfw.x11.xlib.MoveResizeWindow
 #define XMoveWindow _glfw.x11.xlib.MoveWindow
 #define XNextEvent _glfw.x11.xlib.NextEvent
-#define XOpenDisplay _glfw.x11.xlib.OpenDisplay
 #define XOpenIM _glfw.x11.xlib.OpenIM
 #define XPeekEvent _glfw.x11.xlib.PeekEvent
 #define XPending _glfw.x11.xlib.Pending
@@ -296,7 +294,6 @@ typedef void (* PFN_Xutf8SetWMProperties)(Display*,Window,const char*,const char
 #define XrmDestroyDatabase _glfw.x11.xrm.DestroyDatabase
 #define XrmGetResource _glfw.x11.xrm.GetResource
 #define XrmGetStringDatabase _glfw.x11.xrm.GetStringDatabase
-#define XrmInitialize _glfw.x11.xrm.Initialize
 #define XrmUniqueQuark _glfw.x11.xrm.UniqueQuark
 #define XUnregisterIMInstantiateCallback _glfw.x11.xlib.UnregisterIMInstantiateCallback
 #define Xutf8LookupString _glfw.x11.xlib.utf8LookupString
@@ -455,22 +452,15 @@ typedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR)(V
 typedef VkResult (APIENTRY *PFN_vkCreateXcbSurfaceKHR)(VkInstance,const VkXcbSurfaceCreateInfoKHR*,const VkAllocationCallbacks*,VkSurfaceKHR*);
 typedef VkBool32 (APIENTRY *PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR)(VkPhysicalDevice,uint32_t,xcb_connection_t*,xcb_visualid_t);
 
-#include "posix_thread.h"
-#include "posix_time.h"
 #include "xkb_unicode.h"
-#if defined(__linux__)
-#include "linux_joystick.h"
-#else
-#include "null_joystick.h"
-#endif
 
-#define _GLFW_PLATFORM_WINDOW_STATE         _GLFWwindowX11  x11
-#define _GLFW_PLATFORM_LIBRARY_WINDOW_STATE _GLFWlibraryX11 x11
-#define _GLFW_PLATFORM_MONITOR_STATE        _GLFWmonitorX11 x11
-#define _GLFW_PLATFORM_CURSOR_STATE         _GLFWcursorX11  x11
+#define GLFW_X11_WINDOW_STATE           _GLFWwindowX11 x11;
+#define GLFW_X11_LIBRARY_WINDOW_STATE   _GLFWlibraryX11 x11;
+#define GLFW_X11_MONITOR_STATE          _GLFWmonitorX11 x11;
+#define GLFW_X11_CURSOR_STATE           _GLFWcursorX11 x11;
 
-#define _GLFW_PLATFORM_CONTEXT_STATE            _GLFWcontextGLX glx
-#define _GLFW_PLATFORM_LIBRARY_CONTEXT_STATE    _GLFWlibraryGLX glx
+#define GLFW_GLX_CONTEXT_STATE          _GLFWcontextGLX glx;
+#define GLFW_GLX_LIBRARY_CONTEXT_STATE  _GLFWlibraryGLX glx;
 
 
 // GLX-specific per-context data
@@ -696,7 +686,6 @@ typedef struct _GLFWlibraryX11
         PFN_XGetWindowProperty GetWindowProperty;
         PFN_XGrabPointer GrabPointer;
         PFN_XIconifyWindow IconifyWindow;
-        PFN_XInitThreads InitThreads;
         PFN_XInternAtom InternAtom;
         PFN_XLookupString LookupString;
         PFN_XMapRaised MapRaised;
@@ -704,7 +693,6 @@ typedef struct _GLFWlibraryX11
         PFN_XMoveResizeWindow MoveResizeWindow;
         PFN_XMoveWindow MoveWindow;
         PFN_XNextEvent NextEvent;
-        PFN_XOpenDisplay OpenDisplay;
         PFN_XOpenIM OpenIM;
         PFN_XPeekEvent PeekEvent;
         PFN_XPending Pending;
@@ -746,7 +734,6 @@ typedef struct _GLFWlibraryX11
         PFN_XrmDestroyDatabase DestroyDatabase;
         PFN_XrmGetResource GetResource;
         PFN_XrmGetStringDatabase GetStringDatabase;
-        PFN_XrmInitialize Initialize;
         PFN_XrmUniqueQuark UniqueQuark;
     } xrm;
 
@@ -907,11 +894,86 @@ typedef struct _GLFWcursorX11
 } _GLFWcursorX11;
 
 
+GLFWbool _glfwConnectX11(int platformID, _GLFWplatform* platform);
+int _glfwInitX11(void);
+void _glfwTerminateX11(void);
+
+int _glfwCreateWindowX11(_GLFWwindow* window, const _GLFWwndconfig* wndconfig, const _GLFWctxconfig* ctxconfig, const _GLFWfbconfig* fbconfig);
+void _glfwDestroyWindowX11(_GLFWwindow* window);
+void _glfwSetWindowTitleX11(_GLFWwindow* window, const char* title);
+void _glfwSetWindowIconX11(_GLFWwindow* window, int count, const GLFWimage* images);
+void _glfwGetWindowPosX11(_GLFWwindow* window, int* xpos, int* ypos);
+void _glfwSetWindowPosX11(_GLFWwindow* window, int xpos, int ypos);
+void _glfwGetWindowSizeX11(_GLFWwindow* window, int* width, int* height);
+void _glfwSetWindowSizeX11(_GLFWwindow* window, int width, int height);
+void _glfwSetWindowSizeLimitsX11(_GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
+void _glfwSetWindowAspectRatioX11(_GLFWwindow* window, int numer, int denom);
+void _glfwGetFramebufferSizeX11(_GLFWwindow* window, int* width, int* height);
+void _glfwGetWindowFrameSizeX11(_GLFWwindow* window, int* left, int* top, int* right, int* bottom);
+void _glfwGetWindowContentScaleX11(_GLFWwindow* window, float* xscale, float* yscale);
+void _glfwIconifyWindowX11(_GLFWwindow* window);
+void _glfwRestoreWindowX11(_GLFWwindow* window);
+void _glfwMaximizeWindowX11(_GLFWwindow* window);
+void _glfwShowWindowX11(_GLFWwindow* window);
+void _glfwHideWindowX11(_GLFWwindow* window);
+void _glfwRequestWindowAttentionX11(_GLFWwindow* window);
+void _glfwFocusWindowX11(_GLFWwindow* window);
+void _glfwSetWindowMonitorX11(_GLFWwindow* window, _GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
+int _glfwWindowFocusedX11(_GLFWwindow* window);
+int _glfwWindowIconifiedX11(_GLFWwindow* window);
+int _glfwWindowVisibleX11(_GLFWwindow* window);
+int _glfwWindowMaximizedX11(_GLFWwindow* window);
+int _glfwWindowHoveredX11(_GLFWwindow* window);
+int _glfwFramebufferTransparentX11(_GLFWwindow* window);
+void _glfwSetWindowResizableX11(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowDecoratedX11(_GLFWwindow* window, GLFWbool enabled);
+void _glfwSetWindowFloatingX11(_GLFWwindow* window, GLFWbool enabled);
+float _glfwGetWindowOpacityX11(_GLFWwindow* window);
+void _glfwSetWindowOpacityX11(_GLFWwindow* window, float opacity);
+void _glfwSetWindowMousePassthroughX11(_GLFWwindow* window, GLFWbool enabled);
+
+void _glfwSetRawMouseMotionX11(_GLFWwindow *window, GLFWbool enabled);
+GLFWbool _glfwRawMouseMotionSupportedX11(void);
+
+void _glfwPollEventsX11(void);
+void _glfwWaitEventsX11(void);
+void _glfwWaitEventsTimeoutX11(double timeout);
+void _glfwPostEmptyEventX11(void);
+
+void _glfwGetCursorPosX11(_GLFWwindow* window, double* xpos, double* ypos);
+void _glfwSetCursorPosX11(_GLFWwindow* window, double xpos, double ypos);
+void _glfwSetCursorModeX11(_GLFWwindow* window, int mode);
+const char* _glfwGetScancodeNameX11(int scancode);
+int _glfwGetKeyScancodeX11(int key);
+int _glfwCreateCursorX11(_GLFWcursor* cursor, const GLFWimage* image, int xhot, int yhot);
+int _glfwCreateStandardCursorX11(_GLFWcursor* cursor, int shape);
+void _glfwDestroyCursorX11(_GLFWcursor* cursor);
+void _glfwSetCursorX11(_GLFWwindow* window, _GLFWcursor* cursor);
+void _glfwSetClipboardStringX11(const char* string);
+const char* _glfwGetClipboardStringX11(void);
+
+EGLenum _glfwGetEGLPlatformX11(EGLint** attribs);
+EGLNativeDisplayType _glfwGetEGLNativeDisplayX11(void);
+EGLNativeWindowType _glfwGetEGLNativeWindowX11(_GLFWwindow* window);
+
+void _glfwGetRequiredInstanceExtensionsX11(char** extensions);
+int _glfwGetPhysicalDevicePresentationSupportX11(VkInstance instance, VkPhysicalDevice device, uint32_t queuefamily);
+VkResult _glfwCreateWindowSurfaceX11(VkInstance instance, _GLFWwindow* window, const VkAllocationCallbacks* allocator, VkSurfaceKHR* surface);
+
+void _glfwFreeMonitorX11(_GLFWmonitor* monitor);
+void _glfwGetMonitorPosX11(_GLFWmonitor* monitor, int* xpos, int* ypos);
+void _glfwGetMonitorContentScaleX11(_GLFWmonitor* monitor, float* xscale, float* yscale);
+void _glfwGetMonitorWorkareaX11(_GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
+GLFWvidmode* _glfwGetVideoModesX11(_GLFWmonitor* monitor, int* count);
+void _glfwGetVideoModeX11(_GLFWmonitor* monitor, GLFWvidmode* mode);
+GLFWbool _glfwGetGammaRampX11(_GLFWmonitor* monitor, GLFWgammaramp* ramp);
+void _glfwSetGammaRampX11(_GLFWmonitor* monitor, const GLFWgammaramp* ramp);
+
 void _glfwPollMonitorsX11(void);
 void _glfwSetVideoModeX11(_GLFWmonitor* monitor, const GLFWvidmode* desired);
 void _glfwRestoreVideoModeX11(_GLFWmonitor* monitor);
 
-Cursor _glfwCreateCursorX11(const GLFWimage* image, int xhot, int yhot);
+Cursor _glfwCreateNativeCursorX11(const GLFWimage* image, int xhot, int yhot);
 
 unsigned long _glfwGetWindowPropertyX11(Window window,
                                         Atom property,
diff --git a/src/x11_window.c b/src/x11_window.c
index 297b975d..3c74a813 100644
--- a/src/x11_window.c
+++ b/src/x11_window.c
@@ -560,9 +560,9 @@ static void disableCursor(_GLFWwindow* window)
         enableRawMouseMotion(window);
 
     _glfw.x11.disabledCursorWindow = window;
-    _glfwPlatformGetCursorPos(window,
-                              &_glfw.x11.restoreCursorPosX,
-                              &_glfw.x11.restoreCursorPosY);
+    _glfwGetCursorPosX11(window,
+                         &_glfw.x11.restoreCursorPosX,
+                         &_glfw.x11.restoreCursorPosY);
     updateCursorImage(window);
     _glfwCenterCursorInContentArea(window);
     XGrabPointer(_glfw.x11.display, window->x11.handle, True,
@@ -582,9 +582,9 @@ static void enableCursor(_GLFWwindow* window)
 
     _glfw.x11.disabledCursorWindow = NULL;
     XUngrabPointer(_glfw.x11.display, CurrentTime);
-    _glfwPlatformSetCursorPos(window,
-                              _glfw.x11.restoreCursorPosX,
-                              _glfw.x11.restoreCursorPosY);
+    _glfwSetCursorPosX11(window,
+                         _glfw.x11.restoreCursorPosX,
+                         _glfw.x11.restoreCursorPosY);
     updateCursorImage(window);
 }
 
@@ -655,7 +655,7 @@ static GLFWbool createNativeWindow(_GLFWwindow* window,
                  (XPointer) window);
 
     if (!wndconfig->decorated)
-        _glfwPlatformSetWindowDecorated(window, GLFW_FALSE);
+        _glfwSetWindowDecoratedX11(window, GLFW_FALSE);
 
     if (_glfw.x11.NET_WM_STATE && !window->monitor)
     {
@@ -777,9 +777,9 @@ static GLFWbool createNativeWindow(_GLFWwindow* window,
     if (_glfw.x11.im)
         _glfwCreateInputContextX11(window);
 
-    _glfwPlatformSetWindowTitle(window, wndconfig->title);
-    _glfwPlatformGetWindowPos(window, &window->x11.xpos, &window->x11.ypos);
-    _glfwPlatformGetWindowSize(window, &window->x11.width, &window->x11.height);
+    _glfwSetWindowTitleX11(window, wndconfig->title);
+    _glfwGetWindowPosX11(window, &window->x11.xpos, &window->x11.ypos);
+    _glfwGetWindowSizeX11(window, &window->x11.width, &window->x11.height);
 
     return GLFW_TRUE;
 }
@@ -1118,8 +1118,8 @@ static void acquireMonitor(_GLFWwindow* window)
         GLFWvidmode mode;
 
         // Manually position the window over its monitor
-        _glfwPlatformGetMonitorPos(window->monitor, &xpos, &ypos);
-        _glfwPlatformGetVideoMode(window->monitor, &mode);
+        _glfwGetMonitorPosX11(window->monitor, &xpos, &ypos);
+        _glfwGetVideoModeX11(window->monitor, &mode);
 
         XMoveResizeWindow(_glfw.x11.display, window->x11.handle,
                           xpos, ypos, mode.width, mode.height);
@@ -1787,7 +1787,7 @@ static void processEvent(XEvent *event)
                 XUnsetICFocus(window->x11.ic);
 
             if (window->monitor && window->autoIconify)
-                _glfwPlatformIconifyWindow(window);
+                _glfwIconifyWindowX11(window);
 
             _glfwInputWindowFocus(window, GLFW_FALSE);
             return;
@@ -1827,7 +1827,7 @@ static void processEvent(XEvent *event)
             }
             else if (event->xproperty.atom == _glfw.x11.NET_WM_STATE)
             {
-                const GLFWbool maximized = _glfwPlatformWindowMaximized(window);
+                const GLFWbool maximized = _glfwWindowMaximizedX11(window);
                 if (window->x11.maximized != maximized)
                 {
                     window->x11.maximized = maximized;
@@ -1970,10 +1970,10 @@ void _glfwCreateInputContextX11(_GLFWwindow* window)
 //////                       GLFW platform API                      //////
 //////////////////////////////////////////////////////////////////////////
 
-int _glfwPlatformCreateWindow(_GLFWwindow* window,
-                              const _GLFWwndconfig* wndconfig,
-                              const _GLFWctxconfig* ctxconfig,
-                              const _GLFWfbconfig* fbconfig)
+int _glfwCreateWindowX11(_GLFWwindow* window,
+                         const _GLFWwndconfig* wndconfig,
+                         const _GLFWctxconfig* ctxconfig,
+                         const _GLFWfbconfig* fbconfig)
 {
     Visual* visual = NULL;
     int depth;
@@ -2031,7 +2031,7 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
 
     if (window->monitor)
     {
-        _glfwPlatformShowWindow(window);
+        _glfwShowWindowX11(window);
         updateWindowMode(window);
         acquireMonitor(window);
     }
@@ -2040,7 +2040,7 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyWindow(_GLFWwindow* window)
+void _glfwDestroyWindowX11(_GLFWwindow* window)
 {
     if (_glfw.x11.disabledCursorWindow == window)
         _glfw.x11.disabledCursorWindow = NULL;
@@ -2074,7 +2074,7 @@ void _glfwPlatformDestroyWindow(_GLFWwindow* window)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
+void _glfwSetWindowTitleX11(_GLFWwindow* window, const char* title)
 {
     if (_glfw.x11.xlib.utf8)
     {
@@ -2098,8 +2098,7 @@ void _glfwPlatformSetWindowTitle(_GLFWwindow* window, const char* title)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
-                                int count, const GLFWimage* images)
+void _glfwSetWindowIconX11(_GLFWwindow* window, int count, const GLFWimage* images)
 {
     if (count)
     {
@@ -2143,7 +2142,7 @@ void _glfwPlatformSetWindowIcon(_GLFWwindow* window,
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
+void _glfwGetWindowPosX11(_GLFWwindow* window, int* xpos, int* ypos)
 {
     Window dummy;
     int x, y;
@@ -2157,11 +2156,11 @@ void _glfwPlatformGetWindowPos(_GLFWwindow* window, int* xpos, int* ypos)
         *ypos = y;
 }
 
-void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
+void _glfwSetWindowPosX11(_GLFWwindow* window, int xpos, int ypos)
 {
     // HACK: Explicitly setting PPosition to any value causes some WMs, notably
     //       Compiz and Metacity, to honor the position of unmapped windows
-    if (!_glfwPlatformWindowVisible(window))
+    if (!_glfwWindowVisibleX11(window))
     {
         long supplied;
         XSizeHints* hints = XAllocSizeHints();
@@ -2181,7 +2180,7 @@ void _glfwPlatformSetWindowPos(_GLFWwindow* window, int xpos, int ypos)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetWindowSizeX11(_GLFWwindow* window, int* width, int* height)
 {
     XWindowAttributes attribs;
     XGetWindowAttributes(_glfw.x11.display, window->x11.handle, &attribs);
@@ -2192,7 +2191,7 @@ void _glfwPlatformGetWindowSize(_GLFWwindow* window, int* width, int* height)
         *height = attribs.height;
 }
 
-void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
+void _glfwSetWindowSizeX11(_GLFWwindow* window, int width, int height)
 {
     if (window->monitor)
     {
@@ -2210,32 +2209,32 @@ void _glfwPlatformSetWindowSize(_GLFWwindow* window, int width, int height)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformSetWindowSizeLimits(_GLFWwindow* window,
-                                      int minwidth, int minheight,
-                                      int maxwidth, int maxheight)
+void _glfwSetWindowSizeLimitsX11(_GLFWwindow* window,
+                                 int minwidth, int minheight,
+                                 int maxwidth, int maxheight)
 {
     int width, height;
-    _glfwPlatformGetWindowSize(window, &width, &height);
+    _glfwGetWindowSizeX11(window, &width, &height);
     updateNormalHints(window, width, height);
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformSetWindowAspectRatio(_GLFWwindow* window, int numer, int denom)
+void _glfwSetWindowAspectRatioX11(_GLFWwindow* window, int numer, int denom)
 {
     int width, height;
-    _glfwPlatformGetWindowSize(window, &width, &height);
+    _glfwGetWindowSizeX11(window, &width, &height);
     updateNormalHints(window, width, height);
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformGetFramebufferSize(_GLFWwindow* window, int* width, int* height)
+void _glfwGetFramebufferSizeX11(_GLFWwindow* window, int* width, int* height)
 {
-    _glfwPlatformGetWindowSize(window, width, height);
+    _glfwGetWindowSizeX11(window, width, height);
 }
 
-void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
-                                     int* left, int* top,
-                                     int* right, int* bottom)
+void _glfwGetWindowFrameSizeX11(_GLFWwindow* window,
+                                int* left, int* top,
+                                int* right, int* bottom)
 {
     long* extents = NULL;
 
@@ -2245,7 +2244,7 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
     if (_glfw.x11.NET_FRAME_EXTENTS == None)
         return;
 
-    if (!_glfwPlatformWindowVisible(window) &&
+    if (!_glfwWindowVisibleX11(window) &&
         _glfw.x11.NET_REQUEST_FRAME_EXTENTS)
     {
         XEvent event;
@@ -2294,8 +2293,7 @@ void _glfwPlatformGetWindowFrameSize(_GLFWwindow* window,
         XFree(extents);
 }
 
-void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
-                                        float* xscale, float* yscale)
+void _glfwGetWindowContentScaleX11(_GLFWwindow* window, float* xscale, float* yscale)
 {
     if (xscale)
         *xscale = _glfw.x11.contentScaleX;
@@ -2303,7 +2301,7 @@ void _glfwPlatformGetWindowContentScale(_GLFWwindow* window,
         *yscale = _glfw.x11.contentScaleY;
 }
 
-void _glfwPlatformIconifyWindow(_GLFWwindow* window)
+void _glfwIconifyWindowX11(_GLFWwindow* window)
 {
     if (window->x11.overrideRedirect)
     {
@@ -2318,7 +2316,7 @@ void _glfwPlatformIconifyWindow(_GLFWwindow* window)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformRestoreWindow(_GLFWwindow* window)
+void _glfwRestoreWindowX11(_GLFWwindow* window)
 {
     if (window->x11.overrideRedirect)
     {
@@ -2329,12 +2327,12 @@ void _glfwPlatformRestoreWindow(_GLFWwindow* window)
         return;
     }
 
-    if (_glfwPlatformWindowIconified(window))
+    if (_glfwWindowIconifiedX11(window))
     {
         XMapWindow(_glfw.x11.display, window->x11.handle);
         waitForVisibilityNotify(window);
     }
-    else if (_glfwPlatformWindowVisible(window))
+    else if (_glfwWindowVisibleX11(window))
     {
         if (_glfw.x11.NET_WM_STATE &&
             _glfw.x11.NET_WM_STATE_MAXIMIZED_VERT &&
@@ -2352,7 +2350,7 @@ void _glfwPlatformRestoreWindow(_GLFWwindow* window)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
+void _glfwMaximizeWindowX11(_GLFWwindow* window)
 {
     if (!_glfw.x11.NET_WM_STATE ||
         !_glfw.x11.NET_WM_STATE_MAXIMIZED_VERT ||
@@ -2361,7 +2359,7 @@ void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
         return;
     }
 
-    if (_glfwPlatformWindowVisible(window))
+    if (_glfwWindowVisibleX11(window))
     {
         sendEventToWM(window,
                     _glfw.x11.NET_WM_STATE,
@@ -2417,22 +2415,22 @@ void _glfwPlatformMaximizeWindow(_GLFWwindow* window)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformShowWindow(_GLFWwindow* window)
+void _glfwShowWindowX11(_GLFWwindow* window)
 {
-    if (_glfwPlatformWindowVisible(window))
+    if (_glfwWindowVisibleX11(window))
         return;
 
     XMapWindow(_glfw.x11.display, window->x11.handle);
     waitForVisibilityNotify(window);
 }
 
-void _glfwPlatformHideWindow(_GLFWwindow* window)
+void _glfwHideWindowX11(_GLFWwindow* window)
 {
     XUnmapWindow(_glfw.x11.display, window->x11.handle);
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformRequestWindowAttention(_GLFWwindow* window)
+void _glfwRequestWindowAttentionX11(_GLFWwindow* window)
 {
     if (!_glfw.x11.NET_WM_STATE || !_glfw.x11.NET_WM_STATE_DEMANDS_ATTENTION)
         return;
@@ -2444,11 +2442,11 @@ void _glfwPlatformRequestWindowAttention(_GLFWwindow* window)
                   0, 1, 0);
 }
 
-void _glfwPlatformFocusWindow(_GLFWwindow* window)
+void _glfwFocusWindowX11(_GLFWwindow* window)
 {
     if (_glfw.x11.NET_ACTIVE_WINDOW)
         sendEventToWM(window, _glfw.x11.NET_ACTIVE_WINDOW, 1, 0, 0, 0, 0);
-    else if (_glfwPlatformWindowVisible(window))
+    else if (_glfwWindowVisibleX11(window))
     {
         XRaiseWindow(_glfw.x11.display, window->x11.handle);
         XSetInputFocus(_glfw.x11.display, window->x11.handle,
@@ -2458,11 +2456,11 @@ void _glfwPlatformFocusWindow(_GLFWwindow* window)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
-                                   _GLFWmonitor* monitor,
-                                   int xpos, int ypos,
-                                   int width, int height,
-                                   int refreshRate)
+void _glfwSetWindowMonitorX11(_GLFWwindow* window,
+                              _GLFWmonitor* monitor,
+                              int xpos, int ypos,
+                              int width, int height,
+                              int refreshRate)
 {
     if (window->monitor == monitor)
     {
@@ -2486,8 +2484,8 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
 
     if (window->monitor)
     {
-        _glfwPlatformSetWindowDecorated(window, window->decorated);
-        _glfwPlatformSetWindowFloating(window, window->floating);
+        _glfwSetWindowDecoratedX11(window, window->decorated);
+        _glfwSetWindowFloatingX11(window, window->floating);
         releaseMonitor(window);
     }
 
@@ -2496,7 +2494,7 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
 
     if (window->monitor)
     {
-        if (!_glfwPlatformWindowVisible(window))
+        if (!_glfwWindowVisibleX11(window))
         {
             XMapRaised(_glfw.x11.display, window->x11.handle);
             waitForVisibilityNotify(window);
@@ -2515,7 +2513,7 @@ void _glfwPlatformSetWindowMonitor(_GLFWwindow* window,
     XFlush(_glfw.x11.display);
 }
 
-int _glfwPlatformWindowFocused(_GLFWwindow* window)
+int _glfwWindowFocusedX11(_GLFWwindow* window)
 {
     Window focused;
     int state;
@@ -2524,19 +2522,19 @@ int _glfwPlatformWindowFocused(_GLFWwindow* window)
     return window->x11.handle == focused;
 }
 
-int _glfwPlatformWindowIconified(_GLFWwindow* window)
+int _glfwWindowIconifiedX11(_GLFWwindow* window)
 {
     return getWindowState(window) == IconicState;
 }
 
-int _glfwPlatformWindowVisible(_GLFWwindow* window)
+int _glfwWindowVisibleX11(_GLFWwindow* window)
 {
     XWindowAttributes wa;
     XGetWindowAttributes(_glfw.x11.display, window->x11.handle, &wa);
     return wa.map_state == IsViewable;
 }
 
-int _glfwPlatformWindowMaximized(_GLFWwindow* window)
+int _glfwWindowMaximizedX11(_GLFWwindow* window)
 {
     Atom* states;
     unsigned long i;
@@ -2571,7 +2569,7 @@ int _glfwPlatformWindowMaximized(_GLFWwindow* window)
     return maximized;
 }
 
-int _glfwPlatformWindowHovered(_GLFWwindow* window)
+int _glfwWindowHoveredX11(_GLFWwindow* window)
 {
     Window w = _glfw.x11.root;
     while (w)
@@ -2599,7 +2597,7 @@ int _glfwPlatformWindowHovered(_GLFWwindow* window)
     return GLFW_FALSE;
 }
 
-int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
+int _glfwFramebufferTransparentX11(_GLFWwindow* window)
 {
     if (!window->x11.transparent)
         return GLFW_FALSE;
@@ -2607,14 +2605,14 @@ int _glfwPlatformFramebufferTransparent(_GLFWwindow* window)
     return XGetSelectionOwner(_glfw.x11.display, _glfw.x11.NET_WM_CM_Sx) != None;
 }
 
-void _glfwPlatformSetWindowResizable(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowResizableX11(_GLFWwindow* window, GLFWbool enabled)
 {
     int width, height;
-    _glfwPlatformGetWindowSize(window, &width, &height);
+    _glfwGetWindowSizeX11(window, &width, &height);
     updateNormalHints(window, width, height);
 }
 
-void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowDecoratedX11(_GLFWwindow* window, GLFWbool enabled)
 {
     struct
     {
@@ -2636,12 +2634,12 @@ void _glfwPlatformSetWindowDecorated(_GLFWwindow* window, GLFWbool enabled)
                     sizeof(hints) / sizeof(long));
 }
 
-void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowFloatingX11(_GLFWwindow* window, GLFWbool enabled)
 {
     if (!_glfw.x11.NET_WM_STATE || !_glfw.x11.NET_WM_STATE_ABOVE)
         return;
 
-    if (_glfwPlatformWindowVisible(window))
+    if (_glfwWindowVisibleX11(window))
     {
         const long action = enabled ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
         sendEventToWM(window,
@@ -2706,7 +2704,7 @@ void _glfwPlatformSetWindowFloating(_GLFWwindow* window, GLFWbool enabled)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enabled)
+void _glfwSetWindowMousePassthroughX11(_GLFWwindow* window, GLFWbool enabled)
 {
     if (!_glfw.x11.xshape.available)
         return;
@@ -2725,7 +2723,7 @@ void _glfwPlatformSetWindowMousePassthrough(_GLFWwindow* window, GLFWbool enable
     }
 }
 
-float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
+float _glfwGetWindowOpacityX11(_GLFWwindow* window)
 {
     float opacity = 1.f;
 
@@ -2748,7 +2746,7 @@ float _glfwPlatformGetWindowOpacity(_GLFWwindow* window)
     return opacity;
 }
 
-void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
+void _glfwSetWindowOpacityX11(_GLFWwindow* window, float opacity)
 {
     const CARD32 value = (CARD32) (0xffffffffu * (double) opacity);
     XChangeProperty(_glfw.x11.display, window->x11.handle,
@@ -2756,7 +2754,7 @@ void _glfwPlatformSetWindowOpacity(_GLFWwindow* window, float opacity)
                     PropModeReplace, (unsigned char*) &value, 1);
 }
 
-void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
+void _glfwSetRawMouseMotionX11(_GLFWwindow *window, GLFWbool enabled)
 {
     if (!_glfw.x11.xi.available)
         return;
@@ -2770,12 +2768,12 @@ void _glfwPlatformSetRawMouseMotion(_GLFWwindow *window, GLFWbool enabled)
         disableRawMouseMotion(window);
 }
 
-GLFWbool _glfwPlatformRawMouseMotionSupported(void)
+GLFWbool _glfwRawMouseMotionSupportedX11(void)
 {
     return _glfw.x11.xi.available;
 }
 
-void _glfwPlatformPollEvents(void)
+void _glfwPollEventsX11(void)
 {
     _GLFWwindow* window;
 
@@ -2796,29 +2794,29 @@ void _glfwPlatformPollEvents(void)
     if (window)
     {
         int width, height;
-        _glfwPlatformGetWindowSize(window, &width, &height);
+        _glfwGetWindowSizeX11(window, &width, &height);
 
         // NOTE: Re-center the cursor only if it has moved since the last call,
         //       to avoid breaking glfwWaitEvents with MotionNotify
         if (window->x11.lastCursorPosX != width / 2 ||
             window->x11.lastCursorPosY != height / 2)
         {
-            _glfwPlatformSetCursorPos(window, width / 2, height / 2);
+            _glfwSetCursorPosX11(window, width / 2, height / 2);
         }
     }
 
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformWaitEvents(void)
+void _glfwWaitEventsX11(void)
 {
     while (!XPending(_glfw.x11.display))
         waitForEvent(NULL);
 
-    _glfwPlatformPollEvents();
+    _glfwPollEventsX11();
 }
 
-void _glfwPlatformWaitEventsTimeout(double timeout)
+void _glfwWaitEventsTimeoutX11(double timeout)
 {
     while (!XPending(_glfw.x11.display))
     {
@@ -2826,10 +2824,10 @@ void _glfwPlatformWaitEventsTimeout(double timeout)
             break;
     }
 
-    _glfwPlatformPollEvents();
+    _glfwPollEventsX11();
 }
 
-void _glfwPlatformPostEmptyEvent(void)
+void _glfwPostEmptyEventX11(void)
 {
     XEvent event = { ClientMessage };
     event.xclient.window = _glfw.x11.helperWindowHandle;
@@ -2840,7 +2838,7 @@ void _glfwPlatformPostEmptyEvent(void)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
+void _glfwGetCursorPosX11(_GLFWwindow* window, double* xpos, double* ypos)
 {
     Window root, child;
     int rootX, rootY, childX, childY;
@@ -2857,7 +2855,7 @@ void _glfwPlatformGetCursorPos(_GLFWwindow* window, double* xpos, double* ypos)
         *ypos = childY;
 }
 
-void _glfwPlatformSetCursorPos(_GLFWwindow* window, double x, double y)
+void _glfwSetCursorPosX11(_GLFWwindow* window, double x, double y)
 {
     // Store the new position so it can be recognized later
     window->x11.warpCursorPosX = (int) x;
@@ -2868,11 +2866,11 @@ void _glfwPlatformSetCursorPos(_GLFWwindow* window, double x, double y)
     XFlush(_glfw.x11.display);
 }
 
-void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
+void _glfwSetCursorModeX11(_GLFWwindow* window, int mode)
 {
     if (mode == GLFW_CURSOR_DISABLED)
     {
-        if (_glfwPlatformWindowFocused(window))
+        if (_glfwWindowFocusedX11(window))
             disableCursor(window);
     }
     else if (_glfw.x11.disabledCursorWindow == window)
@@ -2883,7 +2881,7 @@ void _glfwPlatformSetCursorMode(_GLFWwindow* window, int mode)
     XFlush(_glfw.x11.display);
 }
 
-const char* _glfwPlatformGetScancodeName(int scancode)
+const char* _glfwGetScancodeNameX11(int scancode)
 {
     if (!_glfw.x11.xkb.available)
         return NULL;
@@ -2913,23 +2911,23 @@ const char* _glfwPlatformGetScancodeName(int scancode)
     return _glfw.x11.keynames[key];
 }
 
-int _glfwPlatformGetKeyScancode(int key)
+int _glfwGetKeyScancodeX11(int key)
 {
     return _glfw.x11.scancodes[key];
 }
 
-int _glfwPlatformCreateCursor(_GLFWcursor* cursor,
-                              const GLFWimage* image,
-                              int xhot, int yhot)
+int _glfwCreateCursorX11(_GLFWcursor* cursor,
+                         const GLFWimage* image,
+                         int xhot, int yhot)
 {
-    cursor->x11.handle = _glfwCreateCursorX11(image, xhot, yhot);
+    cursor->x11.handle = _glfwCreateNativeCursorX11(image, xhot, yhot);
     if (!cursor->x11.handle)
         return GLFW_FALSE;
 
     return GLFW_TRUE;
 }
 
-int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
+int _glfwCreateStandardCursorX11(_GLFWcursor* cursor, int shape)
 {
     if (_glfw.x11.xcursor.handle)
     {
@@ -3027,13 +3025,13 @@ int _glfwPlatformCreateStandardCursor(_GLFWcursor* cursor, int shape)
     return GLFW_TRUE;
 }
 
-void _glfwPlatformDestroyCursor(_GLFWcursor* cursor)
+void _glfwDestroyCursorX11(_GLFWcursor* cursor)
 {
     if (cursor->x11.handle)
         XFreeCursor(_glfw.x11.display, cursor->x11.handle);
 }
 
-void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
+void _glfwSetCursorX11(_GLFWwindow* window, _GLFWcursor* cursor)
 {
     if (window->cursorMode == GLFW_CURSOR_NORMAL)
     {
@@ -3042,7 +3040,7 @@ void _glfwPlatformSetCursor(_GLFWwindow* window, _GLFWcursor* cursor)
     }
 }
 
-void _glfwPlatformSetClipboardString(const char* string)
+void _glfwSetClipboardStringX11(const char* string)
 {
     char* copy = _glfw_strdup(string);
     _glfw_free(_glfw.x11.clipboardString);
@@ -3061,12 +3059,12 @@ void _glfwPlatformSetClipboardString(const char* string)
     }
 }
 
-const char* _glfwPlatformGetClipboardString(void)
+const char* _glfwGetClipboardStringX11(void)
 {
     return getSelectionString(_glfw.x11.CLIPBOARD);
 }
 
-EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
+EGLenum _glfwGetEGLPlatformX11(EGLint** attribs)
 {
     if (_glfw.egl.ANGLE_platform_angle)
     {
@@ -3102,12 +3100,12 @@ EGLenum _glfwPlatformGetEGLPlatform(EGLint** attribs)
     return 0;
 }
 
-EGLNativeDisplayType _glfwPlatformGetEGLNativeDisplay(void)
+EGLNativeDisplayType _glfwGetEGLNativeDisplayX11(void)
 {
     return _glfw.x11.display;
 }
 
-EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window)
+EGLNativeWindowType _glfwGetEGLNativeWindowX11(_GLFWwindow* window)
 {
     if (_glfw.egl.platform)
         return &window->x11.handle;
@@ -3115,7 +3113,7 @@ EGLNativeWindowType _glfwPlatformGetEGLNativeWindow(_GLFWwindow* window)
         return (EGLNativeWindowType) window->x11.handle;
 }
 
-void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
+void _glfwGetRequiredInstanceExtensionsX11(char** extensions)
 {
     if (!_glfw.vk.KHR_surface)
         return;
@@ -3136,9 +3134,9 @@ void _glfwPlatformGetRequiredInstanceExtensions(char** extensions)
         extensions[1] = "VK_KHR_xlib_surface";
 }
 
-int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
-                                                      VkPhysicalDevice device,
-                                                      uint32_t queuefamily)
+int _glfwGetPhysicalDevicePresentationSupportX11(VkInstance instance,
+                                                 VkPhysicalDevice device,
+                                                 uint32_t queuefamily)
 {
     VisualID visualID = XVisualIDFromVisual(DefaultVisual(_glfw.x11.display,
                                                           _glfw.x11.screen));
@@ -3189,10 +3187,10 @@ int _glfwPlatformGetPhysicalDevicePresentationSupport(VkInstance instance,
     }
 }
 
-VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
-                                          _GLFWwindow* window,
-                                          const VkAllocationCallbacks* allocator,
-                                          VkSurfaceKHR* surface)
+VkResult _glfwCreateWindowSurfaceX11(VkInstance instance,
+                                     _GLFWwindow* window,
+                                     const VkAllocationCallbacks* allocator,
+                                     VkSurfaceKHR* surface)
 {
     if (_glfw.vk.KHR_xcb_surface && _glfw.x11.x11xcb.handle)
     {
@@ -3272,6 +3270,13 @@ VkResult _glfwPlatformCreateWindowSurface(VkInstance instance,
 GLFWAPI Display* glfwGetX11Display(void)
 {
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+
+    if (_glfw.platform.platformID != GLFW_PLATFORM_X11)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "X11: Platform not initialized");
+        return NULL;
+    }
+
     return _glfw.x11.display;
 }
 
@@ -3279,6 +3284,13 @@ GLFWAPI Window glfwGetX11Window(GLFWwindow* handle)
 {
     _GLFWwindow* window = (_GLFWwindow*) handle;
     _GLFW_REQUIRE_INIT_OR_RETURN(None);
+
+    if (_glfw.platform.platformID != GLFW_PLATFORM_X11)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "X11: Platform not initialized");
+        return None;
+    }
+
     return window->x11.handle;
 }
 
@@ -3286,6 +3298,12 @@ GLFWAPI void glfwSetX11SelectionString(const char* string)
 {
     _GLFW_REQUIRE_INIT();
 
+    if (_glfw.platform.platformID != GLFW_PLATFORM_X11)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "X11: Platform not initialized");
+        return;
+    }
+
     _glfw_free(_glfw.x11.primarySelectionString);
     _glfw.x11.primarySelectionString = _glfw_strdup(string);
 
@@ -3305,6 +3323,13 @@ GLFWAPI void glfwSetX11SelectionString(const char* string)
 GLFWAPI const char* glfwGetX11SelectionString(void)
 {
     _GLFW_REQUIRE_INIT_OR_RETURN(NULL);
+
+    if (_glfw.platform.platformID != GLFW_PLATFORM_X11)
+    {
+        _glfwInputError(GLFW_PLATFORM_UNAVAILABLE, "X11: Platform not initialized");
+        return NULL;
+    }
+
     return getSelectionString(_glfw.x11.PRIMARY);
 }
 
diff --git a/tests/glfwinfo.c b/tests/glfwinfo.c
index dea3ac22..a76ca1c2 100644
--- a/tests/glfwinfo.c
+++ b/tests/glfwinfo.c
@@ -64,10 +64,24 @@
 #define ANGLE_TYPE_VULKAN   "vk"
 #define ANGLE_TYPE_METAL    "mtl"
 
+#define PLATFORM_NAME_ANY   "any"
+#define PLATFORM_NAME_WIN32 "win32"
+#define PLATFORM_NAME_COCOA "cooca"
+#define PLATFORM_NAME_WL    "wayland"
+#define PLATFORM_NAME_X11   "x11"
+#define PLATFORM_NAME_NULL  "null"
+
 static void usage(void)
 {
     printf("Usage: glfwinfo [OPTION]...\n");
     printf("Options:\n");
+    printf("      --platform=PLATFORM   the platform to use ("
+                                        PLATFORM_NAME_ANY " or "
+                                        PLATFORM_NAME_WIN32 " or "
+                                        PLATFORM_NAME_COCOA " or "
+                                        PLATFORM_NAME_X11 " or "
+                                        PLATFORM_NAME_WL " or "
+                                        PLATFORM_NAME_NULL ")\n");
     printf("  -a, --client-api=API      the client API to use ("
                                         API_NAME_OPENGL " or "
                                         API_NAME_OPENGL_ES ")\n");
@@ -126,6 +140,22 @@ static void error_callback(int error, const char* description)
     fprintf(stderr, "Error: %s\n", description);
 }
 
+static const char* get_platform_name(int platform)
+{
+    if (platform == GLFW_PLATFORM_WIN32)
+        return "Win32";
+    else if (platform == GLFW_PLATFORM_COCOA)
+        return "Cocoa";
+    else if (platform == GLFW_PLATFORM_WAYLAND)
+        return "Wayland";
+    else if (platform == GLFW_PLATFORM_X11)
+        return "X11";
+    else if (platform == GLFW_PLATFORM_NULL)
+        return "Null";
+
+    return "unknown";
+}
+
 static const char* get_device_type_name(VkPhysicalDeviceType type)
 {
     if (type == VK_PHYSICAL_DEVICE_TYPE_OTHER)
@@ -325,12 +355,34 @@ static void print_version(void)
     printf("GLFW library version string: \"%s\"\n", glfwGetVersionString());
 }
 
+static void print_platform(void)
+{
+    const int platforms[] =
+    {
+        GLFW_PLATFORM_WIN32,
+        GLFW_PLATFORM_COCOA,
+        GLFW_PLATFORM_WAYLAND,
+        GLFW_PLATFORM_X11,
+        GLFW_PLATFORM_NULL
+    };
+
+    printf("GLFW platform: %s\n", get_platform_name(glfwGetPlatform()));
+    printf("GLFW supported platforms:\n");
+
+    for (size_t i = 0;  i < sizeof(platforms) / sizeof(platforms[0]);  i++)
+    {
+        if (glfwPlatformSupported(platforms[i]))
+            printf(" %s\n", get_platform_name(platforms[i]));
+    }
+}
+
 int main(int argc, char** argv)
 {
     int ch;
     bool list_extensions = false, list_layers = false;
 
     // These duplicate the defaults for each hint
+    int platform = GLFW_ANY_PLATFORM;
     int client_api = GLFW_OPENGL_API;
     int context_major = 1;
     int context_minor = 0;
@@ -360,7 +412,7 @@ int main(int argc, char** argv)
     bool cocoa_graphics_switching = false;
     bool disable_xcb_surface = false;
 
-    enum { CLIENT, CONTEXT, BEHAVIOR, DEBUG_CONTEXT, FORWARD, HELP,
+    enum { PLATFORM, CLIENT, CONTEXT, BEHAVIOR, DEBUG_CONTEXT, FORWARD, HELP,
            EXTENSIONS, LAYERS,
            MAJOR, MINOR, PROFILE, ROBUSTNESS, VERSION,
            REDBITS, GREENBITS, BLUEBITS, ALPHABITS, DEPTHBITS, STENCILBITS,
@@ -369,6 +421,7 @@ int main(int argc, char** argv)
            ANGLE_TYPE, GRAPHICS_SWITCHING, XCB_SURFACE };
     const struct option options[] =
     {
+        { "platform",           1, NULL, PLATFORM },
         { "behavior",           1, NULL, BEHAVIOR },
         { "client-api",         1, NULL, CLIENT },
         { "context-api",        1, NULL, CONTEXT },
@@ -408,6 +461,23 @@ int main(int argc, char** argv)
     {
         switch (ch)
         {
+            case PLATFORM:
+                if (strcasecmp(optarg, PLATFORM_NAME_WIN32) == 0)
+                    platform = GLFW_PLATFORM_WIN32;
+                else if (strcasecmp(optarg, PLATFORM_NAME_COCOA) == 0)
+                    platform = GLFW_PLATFORM_COCOA;
+                else if (strcasecmp(optarg, PLATFORM_NAME_WL) == 0)
+                    platform = GLFW_PLATFORM_WAYLAND;
+                else if (strcasecmp(optarg, PLATFORM_NAME_X11) == 0)
+                    platform = GLFW_PLATFORM_X11;
+                else if (strcasecmp(optarg, PLATFORM_NAME_NULL) == 0)
+                    platform = GLFW_PLATFORM_NULL;
+                else
+                {
+                    usage();
+                    exit(EXIT_FAILURE);
+                }
+                break;
             case 'a':
             case CLIENT:
                 if (strcasecmp(optarg, API_NAME_OPENGL) == 0)
@@ -623,6 +693,8 @@ int main(int argc, char** argv)
 
     glfwSetErrorCallback(error_callback);
 
+    glfwInitHint(GLFW_PLATFORM, platform);
+
     glfwInitHint(GLFW_COCOA_MENUBAR, false);
 
     glfwInitHint(GLFW_ANGLE_PLATFORM_TYPE, angle_type);
@@ -632,6 +704,7 @@ int main(int argc, char** argv)
         exit(EXIT_FAILURE);
 
     print_version();
+    print_platform();
 
     glfwWindowHint(GLFW_VISIBLE, false);
 
