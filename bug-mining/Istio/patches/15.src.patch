diff --git a/istioctl/pkg/admin/istiodconfig.go b/istioctl/pkg/admin/istiodconfig.go
index 06043af9ee..669064a50a 100644
--- a/istioctl/pkg/admin/istiodconfig.go
+++ b/istioctl/pkg/admin/istiodconfig.go
@@ -470,20 +470,19 @@ func istiodLogCmd(ctx cli.Context) *cobra.Command {
 			return nil
 		},
 		RunE: func(logCmd *cobra.Command, args []string) error {
-			client, err := ctx.CLIClientWithRevision(opts.Revision)
+			resolvedRevision := ctx.RevisionOrDefault(opts.Revision)
+			client, err := ctx.CLIClientWithRevision(resolvedRevision)
 			if err != nil {
 				return fmt.Errorf("failed to create k8s client: %v", err)
 			}
 
 			var podName, ns string
 			if len(args) == 0 {
-				if opts.Revision == "" {
-					opts.Revision = "default"
-				}
+				// resolvedRevision is already set by ctx.RevisionOrDefault(opts.Revision)
 				if len(istiodLabelSelector) > 0 {
-					istiodLabelSelector = fmt.Sprintf("%s,%s=%s", istiodLabelSelector, label.IoIstioRev.Name, opts.Revision)
+					istiodLabelSelector = fmt.Sprintf("%s,%s=%s", istiodLabelSelector, label.IoIstioRev.Name, resolvedRevision)
 				} else {
-					istiodLabelSelector = fmt.Sprintf("%s=%s", label.IoIstioRev.Name, opts.Revision)
+					istiodLabelSelector = fmt.Sprintf("%s=%s", label.IoIstioRev.Name, resolvedRevision)
 				}
 				pl, err := client.PodsForSelector(context.TODO(), ctx.NamespaceOrDefault(ctx.IstioNamespace()), istiodLabelSelector)
 				if err != nil {
diff --git a/istioctl/pkg/cli/context.go b/istioctl/pkg/cli/context.go
index 2572e3acf0..8aa9b3cc11 100644
--- a/istioctl/pkg/cli/context.go
+++ b/istioctl/pkg/cli/context.go
@@ -28,6 +28,7 @@ import (
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/maps"
 	"istio.io/istio/pkg/ptr"
+	"istio.io/istio/pkg/revisions"
 	"istio.io/istio/pkg/slices"
 )
 
@@ -36,6 +37,8 @@ type Context interface {
 	CLIClient() (kube.CLIClient, error)
 	// CLIClientWithRevision returns a client for the given revision
 	CLIClientWithRevision(rev string) (kube.CLIClient, error)
+	// RevisionOrDefault returns the given revision if non-empty, otherwise returns the default revision
+	RevisionOrDefault(rev string) string
 	// InferPodInfoFromTypedResource returns the pod name and namespace for the given typed resource
 	InferPodInfoFromTypedResource(name, namespace string) (pod string, ns string, err error)
 	// InferPodsFromTypedResource returns the pod names and namespace for the given typed resource
@@ -55,6 +58,8 @@ type instance struct {
 	clients map[string]kube.CLIClient
 	// remoteClients are cached clients for each context with empty revision.
 	remoteClients map[string]kube.CLIClient
+	// defaultWatcher watches for changes to the default revision
+	defaultWatcher revisions.DefaultWatcher
 	RootFlags
 }
 
@@ -203,6 +208,46 @@ func handleNamespace(ns, defaultNamespace string) string {
 	return ns
 }
 
+func (i *instance) RevisionOrDefault(rev string) string {
+	if rev != "" {
+		return rev
+	}
+
+	// Try to get the default revision from the default watcher
+	// We create a simple approach that doesn't cause circular dependencies
+	if i.defaultWatcher == nil {
+		// Try to initialize the default watcher using a basic client
+		if basicClient := i.getBasicClientForDefaultWatcher(); basicClient != nil {
+			i.defaultWatcher = revisions.NewDefaultWatcher(basicClient, "")
+		}
+	}
+
+	if i.defaultWatcher != nil {
+		if defaultRev := i.defaultWatcher.GetDefault(); defaultRev != "" {
+			return defaultRev
+		}
+	}
+
+	// If no default revision found, return empty string (which means default behavior)
+	return ""
+}
+
+// getBasicClientForDefaultWatcher creates a basic kube client just for watching default revisions
+// This avoids circular dependencies by not using RevisionOrDefault
+func (i *instance) getBasicClientForDefaultWatcher() kube.Client {
+	timeout, err := i.KubeClientTimeout()
+	if err != nil {
+		return nil
+	}
+
+	client, err := newKubeClientWithRevision(*i.kubeconfig, *i.configContext, "", timeout, i.getImpersonateConfig())
+	if err != nil {
+		return nil
+	}
+
+	return client
+}
+
 type fakeInstance struct {
 	// clients are cached clients for each revision
 	clients   map[string]kube.CLIClient
@@ -272,6 +317,11 @@ func (f *fakeInstance) IstioNamespace() string {
 	return f.rootFlags.IstioNamespace()
 }
 
+func (f *fakeInstance) RevisionOrDefault(rev string) string {
+	// For fake instance, just return the revision as-is (no default resolution)
+	return rev
+}
+
 type NewFakeContextOption struct {
 	Namespace      string
 	IstioNamespace string
diff --git a/istioctl/pkg/cli/context_test.go b/istioctl/pkg/cli/context_test.go
index 8dbb3c4f8e..4aefb77c15 100644
--- a/istioctl/pkg/cli/context_test.go
+++ b/istioctl/pkg/cli/context_test.go
@@ -50,3 +50,33 @@ func Test_handleNamespace(t *testing.T) {
 		})
 	}
 }
+
+func TestRevisionOrDefault(t *testing.T) {
+	tests := []struct {
+		description    string
+		inputRevision  string
+		expectedResult string
+	}{
+		{
+			description:    "return provided revision when non-empty",
+			inputRevision:  "test-revision",
+			expectedResult: "test-revision",
+		},
+		{
+			description:    "return empty string when no revision provided and no default available",
+			inputRevision:  "",
+			expectedResult: "",
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.description, func(t *testing.T) {
+			// Create a fake context
+			ctx := NewFakeContext(&NewFakeContextOption{})
+			got := ctx.RevisionOrDefault(tt.inputRevision)
+			if got != tt.expectedResult {
+				t.Fatalf("unexpected result: wanted %v got %v", tt.expectedResult, got)
+			}
+		})
+	}
+}
diff --git a/istioctl/pkg/cli/revision_or_default_test.go b/istioctl/pkg/cli/revision_or_default_test.go
new file mode 100644
index 0000000000..f67c023a29
--- /dev/null
+++ b/istioctl/pkg/cli/revision_or_default_test.go
@@ -0,0 +1,73 @@
+// Copyright Istio Authors
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package cli
+
+import (
+	"testing"
+)
+
+func TestRevisionOrDefaultWithMockDefaultRevision(t *testing.T) {
+	tests := []struct {
+		description    string
+		inputRevision  string
+		expectedResult string
+	}{
+		{
+			description:    "return provided revision when non-empty",
+			inputRevision:  "test-revision",
+			expectedResult: "test-revision",
+		},
+		{
+			description:    "return empty string when no revision provided (fake context has no default detection)",
+			inputRevision:  "",
+			expectedResult: "",
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.description, func(t *testing.T) {
+			// Create a fake context - it won't have real default revision detection
+			// but will test the basic logic
+			ctx := NewFakeContext(&NewFakeContextOption{})
+			got := ctx.RevisionOrDefault(tt.inputRevision)
+			if got != tt.expectedResult {
+				t.Fatalf("unexpected result: wanted %v got %v", tt.expectedResult, got)
+			}
+		})
+	}
+}
+
+func TestRevisionOrDefaultCaching(t *testing.T) {
+	// Test that the basic logic works correctly
+	ctx := NewFakeContext(&NewFakeContextOption{})
+
+	// Test that explicit revisions are returned as-is
+	result1 := ctx.RevisionOrDefault("stable-revision")
+	if result1 != "stable-revision" {
+		t.Fatalf("expected stable-revision, got %v", result1)
+	}
+
+	// Test that empty revisions return empty (since fake context has no default detection)
+	result2 := ctx.RevisionOrDefault("")
+	if result2 != "" {
+		t.Fatalf("expected empty string, got %v", result2)
+	}
+
+	// Test consistency
+	result3 := ctx.RevisionOrDefault("explicit-revision")
+	if result3 != "explicit-revision" {
+		t.Fatalf("expected explicit-revision, got %v", result3)
+	}
+}
diff --git a/istioctl/pkg/dashboard/dashboard.go b/istioctl/pkg/dashboard/dashboard.go
index 82ae6b1acc..c8df0169fe 100644
--- a/istioctl/pkg/dashboard/dashboard.go
+++ b/istioctl/pkg/dashboard/dashboard.go
@@ -426,14 +426,15 @@ func istioDebugDashCmd(ctx cli.Context) *cobra.Command {
 				c.Println(c.UsageString())
 				return fmt.Errorf("only one of name, --selector, or --revision can be specified")
 			}
-			client, err := ctx.CLIClientWithRevision(opts.Revision)
+			resolvedRevision := ctx.RevisionOrDefault(opts.Revision)
+			client, err := ctx.CLIClientWithRevision(resolvedRevision)
 			if err != nil {
 				return fmt.Errorf("failed to create k8s client: %v", err)
 			}
 
 			var podName, ns string
-			if opts.Revision != "" {
-				labelSelector = "istio.io/rev=" + opts.Revision + ", app=istiod"
+			if resolvedRevision != "" {
+				labelSelector = "istio.io/rev=" + resolvedRevision + ", app=istiod"
 			}
 
 			if labelSelector != "" {
diff --git a/istioctl/pkg/describe/describe.go b/istioctl/pkg/describe/describe.go
index abda647577..cf096b9948 100644
--- a/istioctl/pkg/describe/describe.go
+++ b/istioctl/pkg/describe/describe.go
@@ -165,7 +165,7 @@ the configuration objects that affect that pod.`,
 			}
 			// TODO look for port collisions between services targeting this pod
 
-			kubeClient, err := ctx.CLIClientWithRevision(opts.Revision)
+			kubeClient, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 			if err != nil {
 				return err
 			}
@@ -1286,7 +1286,7 @@ the configuration objects that affect that service.`,
 				return nil
 			}
 
-			kubeClient, err := ctx.CLIClientWithRevision(opts.Revision)
+			kubeClient, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 			if err != nil {
 				return err
 			}
diff --git a/istioctl/pkg/internaldebug/internal-debug.go b/istioctl/pkg/internaldebug/internal-debug.go
index c626691108..02973261ab 100644
--- a/istioctl/pkg/internaldebug/internal-debug.go
+++ b/istioctl/pkg/internaldebug/internal-debug.go
@@ -114,7 +114,7 @@ By default it will use the default serviceAccount from (istio-system) namespace
   istioctl x internal-debug syncz --xds-label istio.io/rev=default
 `,
 		RunE: func(c *cobra.Command, args []string) error {
-			kubeClient, err := ctx.CLIClientWithRevision(opts.Revision)
+			kubeClient, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 			if err != nil {
 				return err
 			}
diff --git a/istioctl/pkg/kubeinject/kubeinject.go b/istioctl/pkg/kubeinject/kubeinject.go
index bb30f8d45f..df22e4ecc9 100644
--- a/istioctl/pkg/kubeinject/kubeinject.go
+++ b/istioctl/pkg/kubeinject/kubeinject.go
@@ -559,7 +559,7 @@ It's best to do kube-inject when the resource is initially created.
 			var valuesConfig string
 			var sidecarTemplate inject.RawTemplates
 			var meshConfig *meshconfig.MeshConfig
-			rev := opts.Revision
+			rev := cliContext.RevisionOrDefault(opts.Revision)
 			// if the revision is "default", render templates with an empty revision
 			if rev == util.DefaultRevisionName {
 				rev = ""
diff --git a/istioctl/pkg/precheck/precheck.go b/istioctl/pkg/precheck/precheck.go
index 71c0e32f58..44b7e2e1d0 100644
--- a/istioctl/pkg/precheck/precheck.go
+++ b/istioctl/pkg/precheck/precheck.go
@@ -126,7 +126,7 @@ See %s for more information about causes and resolutions.`, url.ConfigAnalysis)
 }
 
 func checkFromVersion(ctx cli.Context, revision, version string) (diag.Messages, error) {
-	cli, err := ctx.CLIClientWithRevision(revision)
+	cli, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(revision))
 	if err != nil {
 		return nil, err
 	}
diff --git a/istioctl/pkg/proxyconfig/clusters.go b/istioctl/pkg/proxyconfig/clusters.go
index 85410c97f4..db3dabac60 100644
--- a/istioctl/pkg/proxyconfig/clusters.go
+++ b/istioctl/pkg/proxyconfig/clusters.go
@@ -35,7 +35,7 @@ func ClustersCommand(ctx cli.Context) *cobra.Command {
 		Use:   "remote-clusters",
 		Short: "Lists the remote clusters each istiod instance is connected to.",
 		RunE: func(cmd *cobra.Command, args []string) error {
-			kubeClient, err := ctx.CLIClientWithRevision(opts.Revision)
+			kubeClient, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 			if err != nil {
 				return err
 			}
diff --git a/istioctl/pkg/proxystatus/proxystatus.go b/istioctl/pkg/proxystatus/proxystatus.go
index e97d85ced4..991e2104e3 100644
--- a/istioctl/pkg/proxystatus/proxystatus.go
+++ b/istioctl/pkg/proxystatus/proxystatus.go
@@ -118,7 +118,7 @@ Retrieves last sent and last acknowledged xDS sync from Istiod to each Envoy in
   istioctl proxy-status --output json`,
 		Aliases: []string{"ps"},
 		RunE: func(c *cobra.Command, args []string) error {
-			kubeClient, err := ctx.CLIClientWithRevision(opts.Revision)
+			kubeClient, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 			if err != nil {
 				return err
 			}
diff --git a/istioctl/pkg/version/version.go b/istioctl/pkg/version/version.go
index 86a64a9a31..e868d8cf7a 100644
--- a/istioctl/pkg/version/version.go
+++ b/istioctl/pkg/version/version.go
@@ -64,7 +64,7 @@ func NewVersionCommand(ctx cli.Context) *cobra.Command {
 }
 
 func getRemoteInfo(ctx cli.Context, opts clioptions.ControlPlaneOptions) (*istioVersion.MeshInfo, error) {
-	kubeClient, err := ctx.CLIClientWithRevision(opts.Revision)
+	kubeClient, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 	if err != nil {
 		return nil, err
 	}
@@ -95,7 +95,7 @@ func getRemoteInfoWrapper(ctx cli.Context, pc **cobra.Command, opts *clioptions.
 
 func getProxyInfoWrapper(ctx cli.Context, opts *clioptions.ControlPlaneOptions) func() (*[]istioVersion.ProxyInfo, error) {
 	return func() (*[]istioVersion.ProxyInfo, error) {
-		client, err := ctx.CLIClientWithRevision(opts.Revision)
+		client, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 		if err != nil {
 			return nil, err
 		}
diff --git a/istioctl/pkg/workload/workload.go b/istioctl/pkg/workload/workload.go
index 29234f8bcb..9a434a392f 100644
--- a/istioctl/pkg/workload/workload.go
+++ b/istioctl/pkg/workload/workload.go
@@ -222,7 +222,7 @@ Configure requires either the WorkloadGroup artifact path or its location on the
 			return nil
 		},
 		RunE: func(cmd *cobra.Command, args []string) error {
-			kubeClient, err := ctx.CLIClientWithRevision(opts.Revision)
+			kubeClient, err := ctx.CLIClientWithRevision(ctx.RevisionOrDefault(opts.Revision))
 			if err != nil {
 				return err
 			}
diff --git a/releasenotes/notes/54518.yaml b/releasenotes/notes/54518.yaml
new file mode 100644
index 0000000000..e5d14a808c
--- /dev/null
+++ b/releasenotes/notes/54518.yaml
@@ -0,0 +1,8 @@
+apiVersion: release-notes/v2
+kind: feature
+area: istioctl
+issue:
+- 54518
+releaseNotes:
+- |
+  **Added** automatic detection of the default revision in `istioctl` commands. When `--revision` is not explicitly specified, the default revision (as configured by `istioctl tag set default`) will be used automatically.
