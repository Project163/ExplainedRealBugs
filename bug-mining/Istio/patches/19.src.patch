diff --git a/pilot/pkg/model/push_context.go b/pilot/pkg/model/push_context.go
index 4a6e1bff6d..ccaacc698e 100644
--- a/pilot/pkg/model/push_context.go
+++ b/pilot/pkg/model/push_context.go
@@ -2607,3 +2607,9 @@ func (ps *PushContext) ServicesForWaypoint(key WaypointKey) []ServiceInfo {
 func (ps *PushContext) ServicesWithWaypoint(key string) []ServiceWaypointInfo {
 	return ps.ambientIndex.ServicesWithWaypoint(key)
 }
+
+// ServiceInfo returns the ambient info about the given service, if present.
+// Key identifiies the service and expected to be in the form of 'namespace/hostname'.
+func (ps *PushContext) ServiceInfo(key string) *ServiceInfo {
+	return ps.ambientIndex.ServiceInfo(key)
+}
diff --git a/pilot/pkg/model/service.go b/pilot/pkg/model/service.go
index 2421b8fd3d..6b18e41a0d 100644
--- a/pilot/pkg/model/service.go
+++ b/pilot/pkg/model/service.go
@@ -948,6 +948,9 @@ type AmbientIndexes interface {
 	Policies(requested sets.Set[ConfigKey]) []WorkloadAuthorization
 	ServicesForWaypoint(WaypointKey) []ServiceInfo
 	WorkloadsForWaypoint(WaypointKey) []WorkloadInfo
+	// ServiceScope returns service information for services matching the key.
+	// The key idenitifies a service and is in form of namespace/hostname string.
+	ServiceInfo(key string) *ServiceInfo
 }
 
 // WaypointKey is a multi-address extension of NetworkAddress which is commonly used for lookups in AmbientIndex
@@ -1040,6 +1043,10 @@ func (u NoopAmbientIndexes) ServicesWithWaypoint(string) []ServiceWaypointInfo {
 	return nil
 }
 
+func (u NoopAmbientIndexes) ServiceInfo(key string) *ServiceInfo {
+	return nil
+}
+
 var _ AmbientIndexes = NoopAmbientIndexes{}
 
 type AddressInfo struct {
diff --git a/pilot/pkg/serviceregistry/aggregate/controller.go b/pilot/pkg/serviceregistry/aggregate/controller.go
index 2582e4e8ae..6fb18685a8 100644
--- a/pilot/pkg/serviceregistry/aggregate/controller.go
+++ b/pilot/pkg/serviceregistry/aggregate/controller.go
@@ -174,6 +174,19 @@ func (c *Controller) AddressInformation(addresses sets.String) ([]model.AddressI
 	return i, removed
 }
 
+func (c *Controller) ServiceInfo(key string) *model.ServiceInfo {
+	if !features.EnableAmbientMultiNetwork {
+		return nil
+	}
+	for _, p := range c.GetRegistries() {
+		// When it comes to service info in ambient multicluster setup, only the local cluster matter.
+		if p.Cluster() == c.configClusterID && p.Provider() == provider.Kubernetes {
+			return p.ServiceInfo(key)
+		}
+	}
+	return nil
+}
+
 type registryEntry struct {
 	serviceregistry.Instance
 	// stop if not nil is the per-registry stop chan. If null, the server stop chan should be used to Run the registry.
diff --git a/pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go b/pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go
index 62e3346a52..fa8f699f64 100644
--- a/pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go
+++ b/pilot/pkg/serviceregistry/kube/controller/ambient/ambientindex.go
@@ -785,6 +785,13 @@ func (a *index) WorkloadsForWaypoint(key model.WaypointKey) []model.WorkloadInfo
 	return model.SortWorkloadsByCreationTime(maps.Values(out))
 }
 
+func (a *index) ServiceInfo(key string) *model.ServiceInfo {
+	if svc := a.lookupService(key); svc != nil {
+		return svc
+	}
+	return nil
+}
+
 func (a *index) AdditionalPodSubscriptions(
 	proxy *model.Proxy,
 	allAddresses sets.String,
diff --git a/pilot/pkg/serviceregistry/memory/discovery.go b/pilot/pkg/serviceregistry/memory/discovery.go
index 10b707685d..2d1a24549b 100644
--- a/pilot/pkg/serviceregistry/memory/discovery.go
+++ b/pilot/pkg/serviceregistry/memory/discovery.go
@@ -388,6 +388,10 @@ func (sd *ServiceDiscovery) WorkloadsForWaypoint(model.WaypointKey) []model.Work
 	return nil
 }
 
+func (sd *ServiceDiscovery) ServiceInfo(string) *model.ServiceInfo {
+	return nil
+}
+
 func (sd *ServiceDiscovery) AddWorkloadInfo(infos ...*model.WorkloadInfo) {
 	sd.mutex.Lock()
 	defer sd.mutex.Unlock()
diff --git a/pilot/pkg/xds/endpoints/endpoint_builder.go b/pilot/pkg/xds/endpoints/endpoint_builder.go
index b97cea7f91..7e4d94aff1 100644
--- a/pilot/pkg/xds/endpoints/endpoint_builder.go
+++ b/pilot/pkg/xds/endpoints/endpoint_builder.go
@@ -15,6 +15,7 @@
 package endpoints
 
 import (
+	"fmt"
 	"math"
 	"net"
 	"sort"
@@ -82,6 +83,7 @@ type EndpointBuilder struct {
 	push         *model.PushContext
 	proxy        *model.Proxy
 	dir          model.TrafficDirection
+	serviceInfo  *model.ServiceInfo
 
 	mtlsChecker *mtlsChecker
 }
@@ -129,6 +131,9 @@ func NewCDSEndpointBuilder(
 	}
 	b.populateSubsetInfo()
 	b.populateFailoverPriorityLabels()
+	if features.EnableAmbientMultiNetwork {
+		b.populateAmbientServiceInfo()
+	}
 	return &b
 }
 
@@ -175,6 +180,18 @@ func (b *EndpointBuilder) populateFailoverPriorityLabels() {
 	}
 }
 
+func (b *EndpointBuilder) populateAmbientServiceInfo() {
+	if !b.ServiceFound() {
+		return
+	}
+
+	svc := fmt.Sprintf("%s/%s", b.service.Attributes.Namespace, b.hostname)
+	b.serviceInfo = b.push.ServiceInfo(svc)
+	if b.serviceInfo == nil {
+		log.Debugf("can not find ServiceInfo for %s while operating with ambient multicluster enabled", svc)
+	}
+}
+
 func (b *EndpointBuilder) DestinationRule() *v1alpha3.DestinationRule {
 	if dr := b.destinationRule.GetRule(); dr != nil {
 		dr, _ := dr.Spec.(*v1alpha3.DestinationRule)
@@ -528,6 +545,12 @@ func (b *EndpointBuilder) filterIstioEndpoint(ep *model.IstioEndpoint) bool {
 			return false
 		}
 	}
+	// If we are in ambient mode, the service is not global and the endpoint is in a different cluster
+	// we filter it out.
+	if b.serviceInfo != nil && b.serviceInfo.Scope != model.Global && b.clusterID != ep.Locality.ClusterID {
+		return false
+	}
+
 	return true
 }
 
diff --git a/pilot/pkg/xds/endpoints/endpoint_builder_test.go b/pilot/pkg/xds/endpoints/endpoint_builder_test.go
index a12aac25a6..dc224fef13 100644
--- a/pilot/pkg/xds/endpoints/endpoint_builder_test.go
+++ b/pilot/pkg/xds/endpoints/endpoint_builder_test.go
@@ -15,27 +15,34 @@
 package endpoints
 
 import (
+	"fmt"
 	"reflect"
 	"testing"
 
 	"google.golang.org/protobuf/types/known/wrapperspb"
 
+	"istio.io/api/label"
 	meshconfig "istio.io/api/mesh/v1alpha1"
 	networking "istio.io/api/networking/v1alpha3"
+	"istio.io/istio/pilot/pkg/features"
 	"istio.io/istio/pilot/pkg/model"
 	"istio.io/istio/pilot/pkg/serviceregistry/memory"
 	"istio.io/istio/pilot/pkg/serviceregistry/util/xdsfake"
 	"istio.io/istio/pkg/config"
+	"istio.io/istio/pkg/config/constants"
 	"istio.io/istio/pkg/config/host"
 	"istio.io/istio/pkg/config/labels"
 	"istio.io/istio/pkg/config/mesh/meshwatcher"
 	"istio.io/istio/pkg/config/protocol"
+	"istio.io/istio/pkg/test"
+	"istio.io/istio/pkg/workloadapi"
 )
 
 // MockDiscovery is an in-memory ServiceDiscover with mock services
 type localServiceDiscovery struct {
 	services         []*model.Service
 	serviceInstances []*model.ServiceInstance
+	serviceInfos     []*model.ServiceInfo
 
 	model.NoopAmbientIndexes
 	model.NetworkGatewaysHandler
@@ -78,6 +85,16 @@ func (l *localServiceDiscovery) MCSServices() []model.MCSServiceInfo {
 	return nil
 }
 
+func (l *localServiceDiscovery) ServiceInfo(key string) *model.ServiceInfo {
+	for _, info := range l.serviceInfos {
+		svcKey := fmt.Sprintf("%s/%s", info.GetNamespace(), info.Service.GetHostname())
+		if key == svcKey {
+			return info
+		}
+	}
+	return nil
+}
+
 func TestPopulateFailoverPriorityLabels(t *testing.T) {
 	tests := []struct {
 		name           string
@@ -294,12 +311,18 @@ func TestPopulateFailoverPriorityLabels(t *testing.T) {
 	}
 }
 
-func TestFilterIstioEndpoint(t *testing.T) {
-	servicePort := &model.Port{
-		Name:     "default",
-		Port:     80,
-		Protocol: protocol.HTTP,
+func makeService(namespace, hostname string, scope model.ServiceScope) *model.ServiceInfo {
+	svc := &workloadapi.Service{
+		Namespace: namespace,
+		Hostname:  hostname,
+	}
+	return &model.ServiceInfo{
+		Service: svc,
+		Scope:   scope,
 	}
+}
+
+func TestFilterIstioEndpoint(t *testing.T) {
 	svc := &model.Service{
 		Hostname: "example.ns.svc.cluster.local",
 		Attributes: model.ServiceAttributes{
@@ -312,7 +335,9 @@ func TestFilterIstioEndpoint(t *testing.T) {
 		Resolution: model.DNSLB,
 		Ports:      model.PortList{{Port: 80, Protocol: protocol.HTTP, Name: "http"}},
 	}
-	proxy := &model.Proxy{
+	localSvc := makeService("ns", "example.ns.svc.cluster.local", model.Local)
+	globalSvc := makeService("ns", "example.ns.svc.cluster.local", model.Global)
+	sidecar := &model.Proxy{
 		Type:        model.SidecarProxy,
 		IPAddresses: []string{"111.111.111.111", "1111:2222::1"},
 		ID:          "v0.default",
@@ -323,66 +348,107 @@ func TestFilterIstioEndpoint(t *testing.T) {
 		},
 		ConfigNamespace: "not-default",
 	}
+	waypoint := &model.Proxy{
+		Type: model.Waypoint,
+		Metadata: &model.NodeMetadata{
+			Namespace: "default",
+			NodeName:  "example",
+			ClusterID: "local",
+		},
+		Labels: map[string]string{label.GatewayManaged.Name: constants.ManagedGatewayMeshControllerLabel},
+	}
 	ep0 := &model.IstioEndpoint{
-		Addresses:       []string{"1.1.1.1"},
-		NodeName:        "example",
-		ServicePortName: "not-default",
+		Addresses: []string{"1.1.1.1"},
+		NodeName:  "example",
 	}
 	ep1 := &model.IstioEndpoint{
-		Addresses:       []string{"1.1.1.1"},
-		NodeName:        "example",
-		ServicePortName: "default",
+		Addresses: []string{"1.1.1.1"},
+		NodeName:  "example",
 	}
 	ep2 := &model.IstioEndpoint{
-		Addresses:       []string{"2001:1::1"},
-		NodeName:        "example",
-		ServicePortName: "default",
+		Addresses: []string{"2001:1::1"},
+		NodeName:  "example",
 	}
 	ep3 := &model.IstioEndpoint{
-		Addresses:       []string{"1.1.1.1", "2001:1::1"},
-		NodeName:        "example",
-		ServicePortName: "default",
+		Addresses: []string{"1.1.1.1", "2001:1::1"},
+		NodeName:  "example",
 	}
 	ep4 := &model.IstioEndpoint{
-		Addresses:       []string{},
-		NodeName:        "example",
-		ServicePortName: "default",
+		Addresses: []string{},
+		NodeName:  "example",
+	}
+	localEp := &model.IstioEndpoint{
+		Addresses: []string{"1.1.1.1"},
+		Locality:  model.Locality{ClusterID: "local"},
+	}
+	remoteEp := &model.IstioEndpoint{
+		Addresses: []string{"1.1.1.1"},
+		Locality:  model.Locality{ClusterID: "remote"},
 	}
 
 	tests := []struct {
 		name     string
+		proxy    *model.Proxy
 		ep       *model.IstioEndpoint
-		p        *model.Port
+		svcInfo  *model.ServiceInfo
 		expected bool
 	}{
 		{
 			name:     "test endpoint with different service port name",
+			proxy:    sidecar,
 			ep:       ep0,
-			p:        servicePort,
 			expected: true,
 		},
 		{
 			name:     "test endpoint with ipv4 address",
+			proxy:    sidecar,
 			ep:       ep1,
-			p:        servicePort,
 			expected: true,
 		},
 		{
 			name:     "test endpoint with ipv6 address",
+			proxy:    sidecar,
 			ep:       ep2,
-			p:        servicePort,
 			expected: true,
 		},
 		{
 			name:     "test endpoint with both ipv4 and ipv6 addresses",
+			proxy:    sidecar,
 			ep:       ep3,
-			p:        servicePort,
 			expected: true,
 		},
 		{
 			name:     "test endpoint without address",
+			proxy:    sidecar,
 			ep:       ep4,
-			p:        servicePort,
+			expected: false,
+		},
+		{
+			name:     "test ambient endpoint in local cluster for global service",
+			proxy:    waypoint,
+			ep:       localEp,
+			svcInfo:  globalSvc,
+			expected: true,
+		},
+		{
+			name:     "test ambient endpoint in remote cluster for global service",
+			proxy:    waypoint,
+			ep:       remoteEp,
+			svcInfo:  globalSvc,
+			expected: true,
+		},
+		{
+			name:     "test ambient endpoint in local cluster for local service",
+			proxy:    waypoint,
+			ep:       localEp,
+			svcInfo:  localSvc,
+			expected: true,
+		},
+		{
+			name:     "test ambient endpoint in remote cluster for local service",
+			proxy:    waypoint,
+			ep:       remoteEp,
+			svcInfo:  localSvc,
 			expected: false,
 		},
 	}
@@ -399,11 +465,17 @@ func TestFilterIstioEndpoint(t *testing.T) {
 			if err := env.InitNetworksManager(xdsUpdater); err != nil {
 				t.Fatal(err)
 			}
+			var svcInfos []*model.ServiceInfo
+			if tt.svcInfo != nil {
+				svcInfos = []*model.ServiceInfo{tt.svcInfo}
+				test.SetForTest(t, &features.EnableAmbientMultiNetwork, true)
+			}
 			env.ServiceDiscovery = &localServiceDiscovery{
 				services: []*model.Service{svc},
 				serviceInstances: []*model.ServiceInstance{{
 					Endpoint: tt.ep,
 				}},
+				serviceInfos: svcInfos,
 			}
 			env.Init()
 
@@ -416,7 +488,7 @@ func TestFilterIstioEndpoint(t *testing.T) {
 			}
 
 			builder := NewCDSEndpointBuilder(
-				proxy, push,
+				tt.proxy, push,
 				"outbound||example.ns.svc.cluster.local",
 				model.TrafficDirectionOutbound, "", "example.ns.svc.cluster.local", 80,
 				svc, nil)
diff --git a/pilot/pkg/xds/endpoints/ep_filters_test.go b/pilot/pkg/xds/endpoints/ep_filters_test.go
index d199dada20..5e990b5c06 100644
--- a/pilot/pkg/xds/endpoints/ep_filters_test.go
+++ b/pilot/pkg/xds/endpoints/ep_filters_test.go
@@ -678,6 +678,7 @@ func TestEndpointsByNetworkFilter_SkipLBWithHostname(t *testing.T) {
 }
 
 func TestEndpointsByNetworkFilter_AmbientMuiltiNetwork(t *testing.T) {
+	test.SetForTest(t, &features.EnableAmbient, true)
 	test.SetForTest(t, &features.EnableAmbientMultiNetwork, true)
 	test.SetForTest(t, &features.EnableAmbientWaypointMultiNetwork, true)
 	env := environment(t)
diff --git a/releasenotes/notes/58139.yaml b/releasenotes/notes/58139.yaml
new file mode 100644
index 0000000000..1cd8ba3ee5
--- /dev/null
+++ b/releasenotes/notes/58139.yaml
@@ -0,0 +1,8 @@
+apiVersion: release-notes/v2
+kind: bug-fix
+area: traffic-management
+issue:
+- 58139
+releaseNotes:
+- |
+  **Fixed** an issue where EDS generation code does not consider service scope and, as a result, includes in waypoint configuration remote cluster endpoints that should not be accesible.
