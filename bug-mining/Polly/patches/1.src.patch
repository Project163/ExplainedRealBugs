diff --git a/src/Polly.Net35/Context.cs b/src/Polly.Net35/Context.cs
new file mode 100644
index 00000000..08f6a2ce
--- /dev/null
+++ b/src/Polly.Net35/Context.cs
@@ -0,0 +1,17 @@
+﻿using System.Collections.Generic;
+using Polly.Utilities;
+
+namespace Polly
+{
+    /// <summary>
+    /// A readonly dictionary of string key / object value pairs
+    /// </summary>
+    public class Context : ReadOnlyDictionary<string, object>
+    {
+        internal static Context Empty = new Context(new Dictionary<string, object>());
+
+        internal Context(IDictionary<string, object> values) : base(values)
+        {
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Polly.Net35/ContextualPolicy.cs b/src/Polly.Net35/ContextualPolicy.cs
new file mode 100644
index 00000000..40f8cc7f
--- /dev/null
+++ b/src/Polly.Net35/ContextualPolicy.cs
@@ -0,0 +1,92 @@
+﻿using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+
+namespace Polly
+{
+    /// <summary>
+    /// Transient exception handling policies that can be applied to delegates.
+    /// These policies can be called with arbitrary context data.
+    /// </summary>
+    public class ContextualPolicy
+    {
+         private readonly Action<Action, Context> _exceptionPolicy;
+
+         internal ContextualPolicy(Action<Action, Context> exceptionPolicy)
+        {
+            if (exceptionPolicy == null) throw new ArgumentNullException("exceptionPolicy");
+            
+            _exceptionPolicy = exceptionPolicy;
+        }
+
+         /// <summary>
+         /// Executes the specified action within the policy.
+         /// </summary>
+         /// <param name="action">The action to perform.</param>
+         /// <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
+         /// <exception cref="System.ArgumentNullException">contextData</exception>
+        [DebuggerStepThrough]
+        public void Execute(Action action, IDictionary<string, object> contextData)
+         {
+             if (contextData == null) throw new ArgumentNullException("contextData");
+
+             Execute(action, new Context(contextData));
+         }
+
+        /// <summary>
+        /// Executes the specified action within the policy.
+        /// </summary>
+        /// <param name="action">The action to perform.</param>
+        [DebuggerStepThrough]
+        public void Execute(Action action)
+        {
+            Execute(action, Context.Empty);
+        }
+
+        [DebuggerStepThrough]
+        private void Execute(Action action, Context context)
+        {
+            _exceptionPolicy(action, context);
+        }
+
+        /// <summary>
+        /// Executes the specified action within the policy and returns the result.
+        /// </summary>
+        /// <typeparam name="TResult">The type of the result.</typeparam>
+        /// <param name="action">The action to perform.</param>
+        /// <param name="contextData">Arbitrary data that is passed to the exception policy.</param>
+        /// <returns>
+        /// The value returned by the action
+        /// </returns>
+        /// <exception cref="System.ArgumentNullException">contextData</exception>
+        [DebuggerStepThrough]
+        public TResult Execute<TResult>(Func<TResult> action, IDictionary<string, object> contextData)
+        {
+            if (contextData == null) throw new ArgumentNullException("contextData");
+
+            return Execute(action, new Context(contextData));
+        }
+
+        /// <summary>
+        /// Executes the specified action within the policy and returns the result.
+        /// </summary>
+        /// <typeparam name="TResult">The type of the result.</typeparam>
+        /// <param name="action">The action to perform.</param>
+        /// <returns>
+        /// The value returned by the action
+        /// </returns>
+        [DebuggerStepThrough]
+        public TResult Execute<TResult>(Func<TResult> action)
+        {
+            return Execute(action, Context.Empty);
+        }
+
+        [DebuggerStepThrough]
+        private TResult Execute<TResult>(Func<TResult> action, Context context)
+        {
+            var result = default(TResult);
+            _exceptionPolicy(() => { result = action(); }, context);
+            return result;
+        } 
+    }
+}
\ No newline at end of file
diff --git a/src/Polly.Net35/Polly.Net35.csproj b/src/Polly.Net35/Polly.Net35.csproj
index 76fa539a..26abdf43 100644
--- a/src/Polly.Net35/Polly.Net35.csproj
+++ b/src/Polly.Net35/Polly.Net35.csproj
@@ -59,6 +59,8 @@
     <Compile Include="CircuitBreaker\CircuitBreakerState.cs" />
     <Compile Include="CircuitBreaker\ICircuitBreakerState.cs" />
     <Compile Include="CircuitBreaker\BrokenCircuitException.cs" />
+    <Compile Include="Context.cs" />
+    <Compile Include="ContextualPolicy.cs" />
     <Compile Include="ExceptionPredicate.cs" />
     <Compile Include="OrSyntax.cs" />
     <Compile Include="Policy.cs" />
@@ -70,6 +72,7 @@
     <Compile Include="Retry\RetryPolicyState.cs" />
     <Compile Include="Retry\RetryPolicyStateWithCount.cs" />
     <Compile Include="Retry\RetryPolicyStateWithSleep.cs" />
+    <Compile Include="Utilities\ReadOnlyDictionary.cs" />
     <Compile Include="Utilities\SystemClock.cs" />
     <Compile Include="Utilities\TimedLock.cs" />
   </ItemGroup>
diff --git a/src/Polly.Net35/Retry/RetryPolicyState.cs b/src/Polly.Net35/Retry/RetryPolicyState.cs
index 1aba15fa..b9be3183 100644
--- a/src/Polly.Net35/Retry/RetryPolicyState.cs
+++ b/src/Polly.Net35/Retry/RetryPolicyState.cs
@@ -4,16 +4,23 @@ namespace Polly.Retry
 {
     internal class RetryPolicyState : IRetryPolicyState
     {
-        private readonly Action<Exception> _onRetry;
+        private readonly Action<Exception, Context> _onRetry;
+        private readonly Context _context;
 
-        public RetryPolicyState(Action<Exception> onRetry)
+        public RetryPolicyState(Action<Exception, Context> onRetry, Context context)
         {
             _onRetry = onRetry;
+            _context = context;
+        }
+
+        public RetryPolicyState(Action<Exception> onRetry) :
+            this((exception, context) => onRetry(exception), null)
+        {
         }
 
         public bool CanRetry(Exception ex)
         {
-            _onRetry(ex);
+            _onRetry(ex, _context);
             return true;
         }
     }
diff --git a/src/Polly.Net35/Retry/RetryPolicyStateWithCount.cs b/src/Polly.Net35/Retry/RetryPolicyStateWithCount.cs
index a434b7c4..a4ad71a2 100644
--- a/src/Polly.Net35/Retry/RetryPolicyStateWithCount.cs
+++ b/src/Polly.Net35/Retry/RetryPolicyStateWithCount.cs
@@ -6,12 +6,19 @@ namespace Polly.Retry
     {
         private int _errorCount;
         private readonly int _retryCount;
-        private readonly Action<Exception, int> _onRetry;
+        private readonly Action<Exception, int, Context> _onRetry;
+        private readonly Context _context;
 
-        public RetryPolicyStateWithCount(int retryCount, Action<Exception, int> onRetry)
+        public RetryPolicyStateWithCount(int retryCount, Action<Exception, int, Context> onRetry, Context context)
         {
             _retryCount = retryCount;
             _onRetry = onRetry;
+            _context = context;
+        }
+
+        public RetryPolicyStateWithCount(int retryCount, Action<Exception, int> onRetry) :
+            this(retryCount, (exception, i, context) => onRetry(exception, i), null)
+        {
         }
 
         public bool CanRetry(Exception ex)
@@ -21,7 +28,7 @@ namespace Polly.Retry
             var shouldRetry = _errorCount <= _retryCount;
             if (shouldRetry)
             {
-                _onRetry(ex, _errorCount);
+                _onRetry(ex, _errorCount, _context);
             }
 
             return shouldRetry;
diff --git a/src/Polly.Net35/Retry/RetryPolicyStateWithSleep.cs b/src/Polly.Net35/Retry/RetryPolicyStateWithSleep.cs
index 14c0ce17..06ac6e7a 100644
--- a/src/Polly.Net35/Retry/RetryPolicyStateWithSleep.cs
+++ b/src/Polly.Net35/Retry/RetryPolicyStateWithSleep.cs
@@ -6,13 +6,20 @@ namespace Polly.Retry
 {
     internal class RetryPolicyStateWithSleep : IRetryPolicyState
     {
-        private readonly Action<Exception, TimeSpan> _onRetry;
+        private readonly Action<Exception, TimeSpan, Context> _onRetry;
+        private readonly Context _context;
         private readonly IEnumerator<TimeSpan> _sleepDurationsEnumerator;
 
-        public RetryPolicyStateWithSleep(IEnumerable<TimeSpan> sleepDurations, Action<Exception, TimeSpan> onRetry)
+        public RetryPolicyStateWithSleep(IEnumerable<TimeSpan> sleepDurations, Action<Exception, TimeSpan, Context> onRetry, Context context)
         {
-            _sleepDurationsEnumerator = sleepDurations.GetEnumerator();
             _onRetry = onRetry;
+            _context = context;
+            _sleepDurationsEnumerator = sleepDurations.GetEnumerator();
+        }
+
+        public RetryPolicyStateWithSleep(IEnumerable<TimeSpan> sleepDurations, Action<Exception, TimeSpan> onRetry) :
+            this(sleepDurations, (exception, span, context) => onRetry(exception, span), null)
+        {
         }
 
         public bool CanRetry(Exception ex)
@@ -20,7 +27,7 @@ namespace Polly.Retry
             if (!_sleepDurationsEnumerator.MoveNext()) return false;
 
             var currentTimeSpan = _sleepDurationsEnumerator.Current;
-            _onRetry(ex, currentTimeSpan);
+            _onRetry(ex, currentTimeSpan, _context);
                 
             SystemClock.Sleep(currentTimeSpan);
 
diff --git a/src/Polly.Net35/RetrySyntax.cs b/src/Polly.Net35/RetrySyntax.cs
index 2958d19b..9a05abf3 100644
--- a/src/Polly.Net35/RetrySyntax.cs
+++ b/src/Polly.Net35/RetrySyntax.cs
@@ -33,6 +33,20 @@ namespace Polly
             return policyBuilder.Retry(retryCount, doNothing);
         }
 
+        /// <summary>
+        /// Builds a <see cref="Policy"/> that will retry once
+        /// calling <paramref name="onRetry"/> on retry with the raised exception and retry count.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
+        /// <exception cref="System.ArgumentNullException">onRetry</exception>
+        public static Policy Retry(this PolicyBuilder policyBuilder, Action<Exception, int> onRetry)
+        {
+            return policyBuilder.Retry(1, onRetry);
+        }
+
         /// <summary>
         /// Builds a <see cref="Policy"/> that will retry <paramref name="retryCount"/> times
         /// calling <paramref name="onRetry"/> on each retry with the raised exception and retry count.
@@ -48,8 +62,49 @@ namespace Polly
             if (retryCount <= 0) throw new ArgumentOutOfRangeException("retryCount", "Value must be greater than zero.");
             if (onRetry == null) throw new ArgumentNullException("onRetry");
 
-            Func<IRetryPolicyState> policyStateFactory = () => new RetryPolicyStateWithCount(retryCount, onRetry);
-            return new Policy(action => RetryPolicy.Implementation(action, policyBuilder.ExceptionPredicates, policyStateFactory));
+            return new Policy(action => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates, 
+                () => new RetryPolicyStateWithCount(retryCount, onRetry))
+            );
+        }
+
+        /// <summary>
+        /// Builds a <see cref="Policy"/> that will retry once
+        /// calling <paramref name="onRetry"/> on retry with the raised exception, retry count and 
+        /// execution context.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
+        /// <exception cref="System.ArgumentNullException">onRetry</exception>
+        public static ContextualPolicy Retry(this PolicyBuilder policyBuilder, Action<Exception, int, Context> onRetry)
+        {
+            return Retry(policyBuilder, 1, onRetry);
+        }
+
+        /// <summary>
+        /// Builds a <see cref="Policy"/> that will retry <paramref name="retryCount"/> times
+        /// calling <paramref name="onRetry"/> on each retry with the raised exception, retry count and 
+        /// execution context.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="retryCount">The retry count.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
+        /// <exception cref="System.ArgumentNullException">onRetry</exception>
+        public static ContextualPolicy Retry(this PolicyBuilder policyBuilder, int retryCount, Action<Exception, int, Context> onRetry)
+        {
+            if (retryCount <= 0) throw new ArgumentOutOfRangeException("retryCount", "Value must be greater than zero.");
+            if (onRetry == null) throw new ArgumentNullException("onRetry");
+
+            return new ContextualPolicy((action, context) => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates, 
+                () => new RetryPolicyStateWithCount(retryCount, onRetry, context)
+            ));
         }
 
         /// <summary>
@@ -76,8 +131,31 @@ namespace Polly
         {
             if (onRetry == null) throw new ArgumentNullException("onRetry");
 
-            Func<IRetryPolicyState> policyStateFactory = () => new RetryPolicyState(onRetry);
-            return new Policy(action => RetryPolicy.Implementation(action, policyBuilder.ExceptionPredicates, policyStateFactory));
+            return new Policy(action => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates, 
+                () => new RetryPolicyState(onRetry))
+            );
+        }
+
+        /// <summary>
+        /// Builds a <see cref="Policy"/> that will retry indefinitely
+        /// calling <paramref name="onRetry"/> on each retry with the raised exception and
+        /// execution context.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentNullException">onRetry</exception>
+        public static ContextualPolicy RetryForever(this PolicyBuilder policyBuilder, Action<Exception, Context> onRetry)
+        {
+            if (onRetry == null) throw new ArgumentNullException("onRetry");
+
+            return new ContextualPolicy((action, context) => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates,
+                () => new RetryPolicyState(onRetry, context)
+            ));
         }
 
         /// <summary>
@@ -122,10 +200,46 @@ namespace Polly
             var sleepDurations = Enumerable.Range(1, retryCount)
                                            .Select(sleepDurationProvider);
 
-            Func<IRetryPolicyState> policyStateFactory = () => new RetryPolicyStateWithSleep(sleepDurations, onRetry);
-            return new Policy(action => RetryPolicy.Implementation(action, policyBuilder.ExceptionPredicates, policyStateFactory));
+            return new Policy(action => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates, 
+                () => new RetryPolicyStateWithSleep(sleepDurations, onRetry)
+            ));
         }
 
+        /// <summary>
+        /// Builds a <see cref="Policy"/> that will wait and retry <paramref name="retryCount"/> times
+        /// calling <paramref name="onRetry"/> on each retry with the raised exception, current sleep duration and
+        /// execution context.
+        /// On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
+        /// the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="retryCount">The retry count.</param>
+        /// <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
+        /// <exception cref="System.ArgumentNullException">
+        /// timeSpanProvider
+        /// or
+        /// onRetry
+        /// </exception>
+        public static ContextualPolicy WaitAndRetry(this PolicyBuilder policyBuilder, int retryCount, Func<int, TimeSpan> sleepDurationProvider, Action<Exception, TimeSpan, Context> onRetry)
+        {
+            if (retryCount <= 0) throw new ArgumentOutOfRangeException("retryCount", "Value must be greater than zero.");
+            if (sleepDurationProvider == null) throw new ArgumentNullException("sleepDurationProvider");
+            if (onRetry == null) throw new ArgumentNullException("onRetry");
+
+            var sleepDurations = Enumerable.Range(1, retryCount)
+                                           .Select(sleepDurationProvider);
+
+            return new ContextualPolicy((action, context) => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates, 
+                () => new RetryPolicyStateWithSleep(sleepDurations, onRetry, context)
+            ));
+        }
 
         /// <summary>
         /// Builds a <see cref="Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
@@ -160,8 +274,38 @@ namespace Polly
             if (sleepDurations == null) throw new ArgumentNullException("sleepDurations");
             if (onRetry == null) throw new ArgumentNullException("onRetry");
 
-            Func<IRetryPolicyState> policyStateFactory = () => new RetryPolicyStateWithSleep(sleepDurations, onRetry);
-            return new Policy(action => RetryPolicy.Implementation(action, policyBuilder.ExceptionPredicates, policyStateFactory));
+            return new Policy(action => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates, 
+                () => new RetryPolicyStateWithSleep(sleepDurations, onRetry)
+            ));
+        }
+
+        /// <summary>
+        /// Builds a <see cref="Policy"/> that will wait and retry as many times as there are provided <paramref name="sleepDurations"/>
+        /// calling <paramref name="onRetry"/> on each retry with the raised exception, current sleep duration and
+        /// execution context.
+        /// On each retry, the duration to wait is the current <paramref name="sleepDurations"/> item.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentNullException">
+        /// sleepDurations
+        /// or
+        /// onRetry
+        /// </exception>
+        public static ContextualPolicy WaitAndRetry(this PolicyBuilder policyBuilder, IEnumerable<TimeSpan> sleepDurations, Action<Exception, TimeSpan, Context> onRetry)
+        {
+            if (sleepDurations == null) throw new ArgumentNullException("sleepDurations");
+            if (onRetry == null) throw new ArgumentNullException("onRetry");
+
+            return new ContextualPolicy((action, context) => RetryPolicy.Implementation(
+                action, 
+                policyBuilder.ExceptionPredicates, 
+                () => new RetryPolicyStateWithSleep(sleepDurations, onRetry, context)
+            ));
         }
     }
 }
\ No newline at end of file
diff --git a/src/Polly.Net35/Utilities/ReadOnlyDictionary.cs b/src/Polly.Net35/Utilities/ReadOnlyDictionary.cs
new file mode 100644
index 00000000..45e4925d
--- /dev/null
+++ b/src/Polly.Net35/Utilities/ReadOnlyDictionary.cs
@@ -0,0 +1,365 @@
+﻿using System;
+using System.Collections;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Runtime.InteropServices;
+using System.Threading;
+
+namespace Polly.Utilities
+{
+    /// http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29
+    /// <summary>
+    /// Provides the base class for a generic read-only dictionary.
+    /// </summary>
+    /// <typeparam name="TKey">
+    /// The type of keys in the dictionary.
+    /// </typeparam>
+    /// <typeparam name="TValue">
+    /// The type of values in the dictionary.
+    /// </typeparam>
+    /// <remarks>
+    /// <para>
+    /// An instance of the <b>ReadOnlyDictionary</b> generic class is
+    /// always read-only. A dictionary that is read-only is simply a
+    /// dictionary with a wrapper that prevents modifying the
+    /// dictionary; therefore, if changes are made to the underlying
+    /// dictionary, the read-only dictionary reflects those changes. 
+    /// See <see cref="Dictionary{TKey,TValue}"/> for a modifiable version of 
+    /// this class.
+    /// </para>
+    /// <para>
+    /// <b>Notes to Implementers</b> This base class is provided to 
+    /// make it easier for implementers to create a generic read-only
+    /// custom dictionary. Implementers are encouraged to extend this
+    /// base class instead of creating their own. 
+    /// </para>
+    /// </remarks>
+    [Serializable]
+    [DebuggerDisplay("Count = {Count}")]
+    [ComVisible(false)]
+    [DebuggerTypeProxy(typeof(ReadOnlyDictionaryDebugView<,>))]
+    public class ReadOnlyDictionary<TKey, TValue> : IDictionary<TKey, TValue>, ICollection
+    {
+        private readonly IDictionary<TKey, TValue> source;
+        private object syncRoot;
+
+        /// <summary>
+        /// Initializes a new instance of the
+        /// <see cref="T:ReadOnlyDictionary`2" /> class that wraps
+        /// the supplied <paramref name="values"/>.
+        /// </summary>
+        /// <param name="values">The <see cref="T:IDictionary`2" />
+        /// that will be wrapped.</param>
+        /// <exception cref="T:System.ArgumentNullException">
+        /// Thrown when the dictionary is null.
+        /// </exception>
+        public ReadOnlyDictionary(IDictionary<TKey, TValue> values)
+        {
+            if (values == null)
+            {
+                throw new ArgumentNullException("values");
+            }
+
+            this.source = values;
+        }
+
+        /// <summary>
+        /// Gets the number of key/value pairs contained in the
+        /// <see cref="T:ReadOnlyDictionary`2"></see>.
+        /// </summary>
+        /// <value>The number of key/value pairs.</value>
+        /// <returns>The number of key/value pairs contained in the
+        /// <see cref="T:ReadOnlyDictionary`2"></see>.</returns>
+        public int Count
+        {
+            get { return this.source.Count; }
+        }
+
+        /// <summary>Gets a collection containing the keys in the
+        /// <see cref="T:ReadOnlyDictionary{TKey,TValue}"></see>.</summary>
+        /// <value>A <see cref="Dictionary{TKey,TValue}.KeyCollection"/> 
+        /// containing the keys.</value>
+        /// <returns>A
+        /// <see cref="Dictionary{TKey,TValue}.KeyCollection"/>
+        /// containing the keys in the
+        /// <see cref="Dictionary{TKey,TValue}"></see>.
+        /// </returns>
+        public ICollection<TKey> Keys
+        {
+            get { return this.source.Keys; }
+        }
+
+        /// <summary>
+        /// Gets a collection containing the values of the
+        /// <see cref="T:ReadOnlyDictionary`2"/>.
+        /// </summary>
+        /// <value>The collection of values.</value>
+        public ICollection<TValue> Values
+        {
+            get { return this.source.Values; }
+        }
+
+        /// <summary>Gets a value indicating whether the dictionary is read-only.
+        /// This value will always be true.</summary>
+        bool ICollection<KeyValuePair<TKey, TValue>>.IsReadOnly
+        {
+            get { return true; }
+        }
+
+        /// <summary>
+        /// Gets a value indicating whether access to the dictionary
+        /// is synchronized (thread safe).
+        /// </summary>
+        bool ICollection.IsSynchronized
+        {
+            get { return false; }
+        }
+
+        /// <summary>
+        /// Gets an object that can be used to synchronize access to dictionary.
+        /// </summary>
+        object ICollection.SyncRoot
+        {
+            get
+            {
+                if (this.syncRoot == null)
+                {
+                    ICollection collection = this.source as ICollection;
+
+                    if (collection != null)
+                    {
+                        this.syncRoot = collection.SyncRoot;
+                    }
+                    else
+                    {
+                        Interlocked.CompareExchange(ref this.syncRoot, new object(), null);
+                    }
+                }
+
+                return this.syncRoot;
+            }
+        }
+
+        /// <summary>
+        /// Gets or sets the value associated with the specified key.
+        /// </summary>
+        /// <returns>
+        /// The value associated with the specified key. If the specified key
+        /// is not found, a get operation throws a 
+        /// <see cref="T:System.Collections.Generic.KeyNotFoundException" />,
+        /// and a set operation creates a new element with the specified key.
+        /// </returns>
+        /// <param name="key">The key of the value to get or set.</param>
+        /// <exception cref="T:System.ArgumentNullException">
+        /// Thrown when the key is null.
+        /// </exception>
+        /// <exception cref="T:System.Collections.Generic.KeyNotFoundException">
+        /// The property is retrieved and key does not exist in the collection.
+        /// </exception>
+        public TValue this[TKey key]
+        {
+            get { return this.source[key]; }
+            set { ThrowNotSupportedException(); }
+        }
+
+        /// <summary>This method is not supported by the 
+        /// <see cref="T:ReadOnlyDictionary`2"/>.</summary>
+        /// <param name="key">
+        /// The object to use as the key of the element to add.</param>
+        /// <param name="value">
+        /// The object to use as the value of the element to add.</param>
+        void IDictionary<TKey, TValue>.Add(TKey key, TValue value)
+        {
+            ThrowNotSupportedException();
+        }
+
+        /// <summary>Determines whether the <see cref="T:ReadOnlyDictionary`2" />
+        /// contains the specified key.</summary>
+        /// <returns>
+        /// True if the <see cref="T:ReadOnlyDictionary`2" /> contains
+        /// an element with the specified key; otherwise, false.
+        /// </returns>
+        /// <param name="key">The key to locate in the
+        /// <see cref="T:ReadOnlyDictionary`2"></see>.</param>
+        /// <exception cref="T:System.ArgumentNullException">
+        /// Thrown when the key is null.
+        /// </exception>
+        public bool ContainsKey(TKey key)
+        {
+            return this.source.ContainsKey(key);
+        }
+
+        /// <summary>
+        /// This method is not supported by the <see cref="T:ReadOnlyDictionary`2"/>.
+        /// </summary>
+        /// <param name="key">The key of the element to remove.</param>
+        /// <returns>
+        /// True if the element is successfully removed; otherwise, false.
+        /// </returns>
+        bool IDictionary<TKey, TValue>.Remove(TKey key)
+        {
+            ThrowNotSupportedException();
+            return false;
+        }
+
+        /// <summary>
+        /// Gets the value associated with the specified key.
+        /// </summary>
+        /// <param name="key">The key of the value to get.</param>
+        /// <param name="value">When this method returns, contains the value
+        /// associated with the specified key, if the key is found;
+        /// otherwise, the default value for the type of the value parameter.
+        /// This parameter is passed uninitialized.</param>
+        /// <returns>
+        /// <b>true</b> if the <see cref="T:ReadOnlyDictionary`2" /> contains
+        /// an element with the specified key; otherwise, <b>false</b>.
+        /// </returns>
+        public bool TryGetValue(TKey key, out TValue value)
+        {
+            return this.source.TryGetValue(key, out value);
+        }
+
+        /// <summary>This method is not supported by the
+        /// <see cref="T:ReadOnlyDictionary`2"/>.</summary>
+        /// <param name="item">
+        /// The object to add to the <see cref="T:ICollection`1"/>.
+        /// </param>
+        void ICollection<KeyValuePair<TKey, TValue>>.Add(
+            KeyValuePair<TKey, TValue> item)
+        {
+            ThrowNotSupportedException();
+        }
+
+        /// <summary>This method is not supported by the 
+        /// <see cref="T:ReadOnlyDictionary`2"/>.</summary>
+        void ICollection<KeyValuePair<TKey, TValue>>.Clear()
+        {
+            ThrowNotSupportedException();
+        }
+
+        /// <summary>
+        /// Determines whether the <see cref="T:ICollection`1"/> contains a
+        /// specific value.
+        /// </summary>
+        /// <param name="item">
+        /// The object to locate in the <see cref="T:ICollection`1"/>.
+        /// </param>
+        /// <returns>
+        /// <b>true</b> if item is found in the <b>ICollection</b>; 
+        /// otherwise, <b>false</b>.
+        /// </returns>
+        bool ICollection<KeyValuePair<TKey, TValue>>.Contains(
+            KeyValuePair<TKey, TValue> item)
+        {
+            ICollection<KeyValuePair<TKey, TValue>> collection = this.source;
+
+            return collection.Contains(item);
+        }
+
+        /// <summary>
+        /// Copies the elements of the ICollection to an Array, starting at a
+        /// particular Array index. 
+        /// </summary>
+        /// <param name="array">The one-dimensional Array that is the
+        /// destination of the elements copied from ICollection.
+        /// The Array must have zero-based indexing.
+        /// </param>
+        /// <param name="arrayIndex">
+        /// The zero-based index in array at which copying begins.
+        /// </param>
+        void ICollection<KeyValuePair<TKey, TValue>>.CopyTo(
+            KeyValuePair<TKey, TValue>[] array, int arrayIndex)
+        {
+            ICollection<KeyValuePair<TKey, TValue>> collection = this.source;
+            collection.CopyTo(array, arrayIndex);
+        }
+
+        /// <summary>This method is not supported by the
+        /// <see cref="T:ReadOnlyDictionary`2"/>.</summary>
+        /// <param name="item">
+        /// The object to remove from the ICollection.
+        /// </param>
+        /// <returns>Will never return a value.</returns>
+        bool ICollection<KeyValuePair<TKey, TValue>>.Remove(KeyValuePair<TKey, TValue> item)
+        {
+            ThrowNotSupportedException();
+            return false;
+        }
+
+        /// <summary>
+        /// Returns an enumerator that iterates through the collection.
+        /// </summary>
+        /// <returns>
+        /// A IEnumerator that can be used to iterate through the collection.
+        /// </returns>
+        IEnumerator<KeyValuePair<TKey, TValue>>
+            IEnumerable<KeyValuePair<TKey, TValue>>.GetEnumerator()
+        {
+            IEnumerable<KeyValuePair<TKey, TValue>> enumerator = this.source;
+
+            return enumerator.GetEnumerator();
+        }
+
+        /// <summary>
+        /// Returns an enumerator that iterates through a collection.
+        /// </summary>
+        /// <returns>
+        /// An IEnumerator that can be used to iterate through the collection.
+        /// </returns>
+        IEnumerator IEnumerable.GetEnumerator()
+        {
+            return this.source.GetEnumerator();
+        }
+
+        /// <summary>
+        /// For a description of this member, see <see cref="ICollection.CopyTo"/>. 
+        /// </summary>
+        /// <param name="array">
+        /// The one-dimensional Array that is the destination of the elements copied from 
+        /// ICollection. The Array must have zero-based indexing.
+        /// </param>
+        /// <param name="index">
+        /// The zero-based index in Array at which copying begins.
+        /// </param>
+        void ICollection.CopyTo(Array array, int index)
+        {
+            ICollection collection =
+                new List<KeyValuePair<TKey, TValue>>(this.source);
+
+            collection.CopyTo(array, index);
+        }
+
+        private static void ThrowNotSupportedException()
+        {
+            throw new NotSupportedException("This Dictionary is read-only");
+        }
+    }
+
+    internal sealed class ReadOnlyDictionaryDebugView<TKey, TValue>
+    {
+        private IDictionary<TKey, TValue> dict;
+
+        public ReadOnlyDictionaryDebugView(
+            ReadOnlyDictionary<TKey, TValue> dictionary)
+        {
+            if (dictionary == null)
+            {
+                throw new ArgumentNullException("dictionary");
+            }
+
+            this.dict = dictionary;
+        }
+
+        [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
+        public KeyValuePair<TKey, TValue>[] Items
+        {
+            get
+            {
+                KeyValuePair<TKey, TValue>[] array =
+                    new KeyValuePair<TKey, TValue>[this.dict.Count];
+                this.dict.CopyTo(array, 0);
+                return array;
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Polly.Net40/Polly.Net40.csproj b/src/Polly.Net40/Polly.Net40.csproj
index 167e735f..0b8ceef3 100644
--- a/src/Polly.Net40/Polly.Net40.csproj
+++ b/src/Polly.Net40/Polly.Net40.csproj
@@ -62,6 +62,12 @@
     <Compile Include="..\Polly.Net35\CircuitBreaker\ICircuitBreakerState.cs">
       <Link>CircuitBreaker\ICircuitBreakerState.cs</Link>
     </Compile>
+    <Compile Include="..\Polly.Net35\Context.cs">
+      <Link>Context.cs</Link>
+    </Compile>
+    <Compile Include="..\Polly.Net35\ContextualPolicy.cs">
+      <Link>ContextualPolicy.cs</Link>
+    </Compile>
     <Compile Include="..\Polly.Net35\ExceptionPredicate.cs">
       <Link>ExceptionPredicate.cs</Link>
     </Compile>
@@ -92,6 +98,9 @@
     <Compile Include="..\Polly.Net35\Retry\RetryPolicyStateWithSleep.cs">
       <Link>Retry\RetryPolicyStateWithSleep.cs</Link>
     </Compile>
+    <Compile Include="..\Polly.Net35\Utilities\ReadOnlyDictionary.cs">
+      <Link>Utilities\ReadOnlyDictionary.cs</Link>
+    </Compile>
     <Compile Include="..\Polly.Net35\Utilities\SystemClock.cs">
       <Link>Utilities\SystemClock.cs</Link>
     </Compile>
diff --git a/src/Polly.Net45/Context.cs b/src/Polly.Net45/Context.cs
new file mode 100644
index 00000000..ec388430
--- /dev/null
+++ b/src/Polly.Net45/Context.cs
@@ -0,0 +1,18 @@
+﻿using System.Collections.Generic;
+using System.Collections.ObjectModel;
+
+namespace Polly
+{
+    /// <summary>
+    /// A readonly dictionary of string key / object value pairs
+    /// </summary>
+    public class Context : ReadOnlyDictionary<string, object>
+    {
+        internal static Context Empty = new Context(new Dictionary<string, object>());
+
+        internal Context(IDictionary<string, object> values)
+            : base(values)
+        {
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Polly.Net45/Polly.Net45.csproj b/src/Polly.Net45/Polly.Net45.csproj
index e4af6043..b0cca25f 100644
--- a/src/Polly.Net45/Polly.Net45.csproj
+++ b/src/Polly.Net45/Polly.Net45.csproj
@@ -64,6 +64,9 @@
     <Compile Include="..\Polly.Net35\CircuitBreaker\ICircuitBreakerState.cs">
       <Link>CircuitBreaker\ICircuitBreakerState.cs</Link>
     </Compile>
+    <Compile Include="..\Polly.Net35\ContextualPolicy.cs">
+      <Link>ContextualPolicy.cs</Link>
+    </Compile>
     <Compile Include="..\Polly.Net35\ExceptionPredicate.cs">
       <Link>ExceptionPredicate.cs</Link>
     </Compile>
@@ -101,6 +104,7 @@
       <Link>Utilities\TimedLock.cs</Link>
     </Compile>
     <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="Context.cs" />
   </ItemGroup>
   <ItemGroup>
     <None Include="Polly.snk" />
diff --git a/src/Polly.Specs/ContextualPolicySpecs.cs b/src/Polly.Specs/ContextualPolicySpecs.cs
new file mode 100644
index 00000000..45e783b8
--- /dev/null
+++ b/src/Polly.Specs/ContextualPolicySpecs.cs
@@ -0,0 +1,61 @@
+﻿using System;
+using FluentAssertions;
+using Xunit;
+
+namespace Polly.Specs
+{
+    public class ContextualPolicySpecs
+    {
+        [Fact]
+        public void Executing_the_policy_action_should_execute_the_specified_action()
+        {
+            var executed = false;
+
+            var policy = Policy
+                          .Handle<DivideByZeroException>()
+                          .Retry((_, __, ___) => { });
+
+            policy.Execute(() => executed = true);
+
+            executed.Should()
+                    .BeTrue();
+        } 
+
+        [Fact]
+        public void Executing_the_policy_function_should_execute_the_specified_function_and_return_the_result()
+        {
+            var policy = Policy
+                          .Handle<DivideByZeroException>()
+                          .Retry((_, __, ___) => { });
+
+            var result = policy.Execute(() => 2);
+
+            result.Should()
+                  .Be(2);
+        } 
+
+        [Fact]
+        public void Executing_the_policy_action_should_should_throw_when_context_data_is_null()
+        {
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .Retry((_, __, ___) => { });
+
+            policy.Invoking(p => p.Execute(() => { }, null))
+                  .ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("contextData");
+        }
+
+        [Fact]
+        public void Executing_the_policy_function_should_should_throw_when_context_data_is_null()
+        {
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .Retry((_, __, ___) => { });
+
+            policy.Invoking(p => p.Execute(() => 2, null))
+                  .ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("contextData");
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Polly.Specs/Helpers/ContextualPolicyExtensions.cs b/src/Polly.Specs/Helpers/ContextualPolicyExtensions.cs
new file mode 100644
index 00000000..2292bcf3
--- /dev/null
+++ b/src/Polly.Specs/Helpers/ContextualPolicyExtensions.cs
@@ -0,0 +1,72 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace Polly.Specs.Helpers
+{
+    public static class ContextualPolicyExtensions
+    {
+        public static void RaiseException<TException>(this ContextualPolicy policy,
+                   int numberOfTimesToRaiseException,
+                   Action<TException, int> configureException = null) where TException : Exception, new()
+        {
+            int counter = 0;
+
+            policy.Execute(() =>
+            {
+                if (counter < numberOfTimesToRaiseException)
+                {
+                    counter++;
+
+                    var exception = new TException();
+
+                    if (configureException != null)
+                    {
+                        configureException(exception, counter);
+                    }
+
+                    throw exception;
+                }
+            });
+        }
+
+        public static void RaiseException<TException>(
+            this ContextualPolicy policy,
+            Action<TException, int> configureException = null) where TException : Exception, new()
+        {
+            policy.RaiseException(1, configureException);
+        }
+
+        public static void RaiseException<TException>(this ContextualPolicy policy, 
+            int numberOfTimesToRaiseException, 
+            IDictionary<string, object> contextData,
+            Action<TException, int> configureException = null) where TException : Exception, new()
+        {
+            int counter = 0;
+
+            policy.Execute(() =>
+            {
+                if (counter < numberOfTimesToRaiseException)
+                {
+                    counter++;
+
+                    var exception = new TException();
+                    
+                    if (configureException != null)
+                    {
+                        configureException(exception, counter);
+                    }
+
+                    throw exception;
+                }
+            }, contextData);
+        }
+
+        public static void RaiseException<TException>(
+            this ContextualPolicy policy,
+            IDictionary<string, object> contextData,
+            Action<TException, int> configureException = null) where TException : Exception, new()
+        {
+            policy.RaiseException(1, contextData, configureException);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Polly.Specs/Helpers/ObjectExtensions.cs b/src/Polly.Specs/Helpers/ObjectExtensions.cs
new file mode 100644
index 00000000..6cc85df7
--- /dev/null
+++ b/src/Polly.Specs/Helpers/ObjectExtensions.cs
@@ -0,0 +1,17 @@
+﻿using System.Collections.Generic;
+using System.Linq;
+
+namespace Polly.Specs.Helpers
+{
+    public static class ObjectExtensions
+    {
+        public static IDictionary<string, object> AsDictionary(this object source)
+        {
+            return source.GetType().GetProperties().ToDictionary
+            (
+                propInfo => propInfo.Name,
+                propInfo => propInfo.GetValue(source, null)
+            );
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/Polly.Specs/PolicySpecs.cs b/src/Polly.Specs/PolicySpecs.cs
index f08cfbd3..b66f94e1 100644
--- a/src/Polly.Specs/PolicySpecs.cs
+++ b/src/Polly.Specs/PolicySpecs.cs
@@ -7,11 +7,26 @@ namespace Polly.Specs
     public class PolicySpecs
     {
         [Fact]
-        public void Can_call_execute_on_a_policy_to_get_the_result_of_executing_an_action()
+        public void Executing_the_policy_action_should_execute_the_specified_action()
+        {
+            var executed = false;
+
+            var policy = Policy
+                          .Handle<DivideByZeroException>()
+                          .Retry((_, __) => { });
+
+            policy.Execute(() => executed = true);
+
+            executed.Should()
+                    .BeTrue();
+        }
+
+        [Fact]
+        public void Executing_the_policy_function_should_execute_the_specified_function_and_return_the_result()
         {
             var policy = Policy
                           .Handle<DivideByZeroException>()
-                          .Retry();
+                          .Retry((_, __) => { });
 
             var result = policy.Execute(() => 2);
 
diff --git a/src/Polly.Specs/Polly.Specs.csproj b/src/Polly.Specs/Polly.Specs.csproj
index b7de7bdd..62055dd5 100644
--- a/src/Polly.Specs/Polly.Specs.csproj
+++ b/src/Polly.Specs/Polly.Specs.csproj
@@ -59,6 +59,9 @@
       <Link>Properties\SolutionAssemblyInfo.cs</Link>
     </Compile>
     <Compile Include="CircuitBreakerSpecs.cs" />
+    <Compile Include="ContextualPolicySpecs.cs" />
+    <Compile Include="Helpers\ContextualPolicyExtensions.cs" />
+    <Compile Include="Helpers\ObjectExtensions.cs" />
     <Compile Include="Helpers\PolicyExtensions.cs" />
     <Compile Include="PolicySpecs.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
diff --git a/src/Polly.Specs/RetryForeverSpecs.cs b/src/Polly.Specs/RetryForeverSpecs.cs
index bf30cee7..e0106d43 100644
--- a/src/Polly.Specs/RetryForeverSpecs.cs
+++ b/src/Polly.Specs/RetryForeverSpecs.cs
@@ -10,14 +10,28 @@ namespace Polly.Specs
     public class RetryForeverSpecs
     {
         [Fact]
-        public void Should_throw_when_on_retry_action_is_null()
+        public void Should_throw_when_onretry_action_without_context_is_null()
         {
+            Action<Exception> nullOnRetry = null;
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .RetryForever(null);
+                                      .RetryForever(nullOnRetry);
 
-            policy.ShouldThrow<ArgumentNullException>()
-                  .And
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("onRetry");
+        }
+
+        [Fact]
+        public void Should_throw_when_onretry_action_with_context_is_null()
+        {
+            Action<Exception, Context> nullOnRetry = null;
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .RetryForever(nullOnRetry);
+
+            policy.ShouldThrow<ArgumentNullException>().And
                   .ParamName.Should().Be("onRetry");
         }
 
@@ -131,6 +145,24 @@ namespace Polly.Specs
                 .ContainInOrder(expectedExceptions);
         }
 
+        [Fact]
+        public void Should_call_onretry_on_each_retry_with_the_passed_context()
+        {
+            IDictionary<string, object> contextData = null;
+
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .RetryForever((_, context) => contextData = context);
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key1 = "value1", key2 = "value2" }.AsDictionary()
+            );
+
+            contextData.Should()
+                       .ContainKeys("key1", "key2").And
+                       .ContainValues("value1", "value2");
+        }
+
         [Fact]
         public void Should_not_call_onretry_when_no_retries_are_performed()
         {
@@ -146,5 +178,27 @@ namespace Polly.Specs
             retryExceptions.Should()
                            .BeEmpty();
         }
+
+        [Fact]
+        public void Should_create_new_context_for_each_call_to_policy()
+        {
+            string contextValue = null;
+
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .RetryForever((_, context) => contextValue = context["key"].ToString());
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key = "original_value" }.AsDictionary()
+            );
+
+            contextValue.Should().Be("original_value");
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key = "new_value" }.AsDictionary()
+            );
+
+            contextValue.Should().Be("new_value");
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Polly.Specs/RetrySpecs.cs b/src/Polly.Specs/RetrySpecs.cs
index 2b079cfa..c1d1bf3d 100644
--- a/src/Polly.Specs/RetrySpecs.cs
+++ b/src/Polly.Specs/RetrySpecs.cs
@@ -10,29 +10,55 @@ namespace Polly.Specs
     public class RetrySpecs
     {
         [Fact]
-        public void Should_throw_when_retry_count_is_less_than_one()
+        public void Should_throw_when_retry_count_is_less_than_one_without_context()
         {
+            Action<Exception, int> onRetry = (_, __) => { };
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .Retry(0, onRetry);
+        
+            policy.ShouldThrow<ArgumentOutOfRangeException>().And
+                  .ParamName.Should().Be("retryCount");
+        }
+
+        [Fact]
+        public void Should_throw_when_onretry_action_without_context_is_null()
+        {
+            Action<Exception, int> nullOnRetry = null;
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .Retry(0);
+                                      .Retry(1, nullOnRetry);
 
-            policy.ShouldThrow<ArgumentOutOfRangeException>()
-                  .And
-                  .ParamName.Should()
-                  .Be("retryCount");
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("onRetry");
         }
 
         [Fact]
-        public void Should_throw_when_on_retry_action_is_null()
+        public void Should_throw_when_retry_count_is_less_than_one_with_context()
         {
+            Action<Exception, int, Context> onRetry = (_, __, ___) => { };
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .Retry(1, null);
+                                      .Retry(0, onRetry);
 
-            policy.ShouldThrow<ArgumentNullException>()
-                  .And
-                  .ParamName.Should()
-                  .Be("onRetry");
+            policy.ShouldThrow<ArgumentOutOfRangeException>().And
+                  .ParamName.Should().Be("retryCount");
+        }
+
+        [Fact]
+        public void Should_throw_when_onretry_action_with_context_is_null()
+        {
+            Action<Exception, int, Context> nullOnRetry = null;
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .Retry(1, nullOnRetry);
+
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("onRetry");
         }
 
         [Fact]
@@ -176,7 +202,7 @@ namespace Polly.Specs
         [Fact]
         public void Should_call_onretry_on_each_retry_with_the_current_retry_count()
         {
-            var expectedRetryCounts = new[] {1, 2, 3};
+            var expectedRetryCounts = new[] { 1, 2, 3 };
             var retryCounts = new List<int>();
 
             var policy = Policy
@@ -192,7 +218,7 @@ namespace Polly.Specs
         [Fact]
         public void Should_call_onretry_on_each_retry_with_the_current_exception()
         {
-            var expectedExceptions = new object[] {"Exception #1", "Exception #2", "Exception #3"};
+            var expectedExceptions = new object[] { "Exception #1", "Exception #2", "Exception #3" };
             var retryExceptions = new List<Exception>();
 
             var policy = Policy
@@ -207,6 +233,39 @@ namespace Polly.Specs
                 .ContainInOrder(expectedExceptions);
         }
 
+        [Fact]
+        public void Should_call_onretry_with_the_passed_context()
+        {
+            IDictionary<string, object> contextData = null;
+
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .Retry((_, __, context) => contextData = context);
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key1 = "value1", key2 = "value2" }.AsDictionary()
+            );
+
+            contextData.Should()
+                       .ContainKeys("key1", "key2").And
+                       .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Context_should_be_empty_if_policy_not_initialised_with_any_data()
+        {
+            Context capturedContext = null;
+
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .Retry((_, __, context) => capturedContext = context);
+
+            policy.RaiseException<DivideByZeroException>();
+
+            capturedContext.Should()
+                           .BeEmpty();
+        }
+
         [Fact]
         public void Should_not_call_onretry_when_no_retries_are_performed()
         {
@@ -214,7 +273,7 @@ namespace Polly.Specs
 
             var policy = Policy
                 .Handle<DivideByZeroException>()
-                .Retry(1, (_, retyCount) => retryCounts.Add(retyCount));
+                .Retry((_, retyCount) => retryCounts.Add(retyCount));
 
             policy.Invoking(x => x.RaiseException<ArgumentException>())
                   .ShouldThrow<ArgumentException>();
@@ -236,5 +295,27 @@ namespace Polly.Specs
             policy.Invoking(x => x.RaiseException<DivideByZeroException>())
                   .ShouldNotThrow();
         }
+
+        [Fact]
+        public void Should_create_new_context_for_each_call_to_policy()
+        {
+            string contextValue = null;
+
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .Retry((_, __, context) => contextValue = context["key"].ToString());
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key = "original_value" }.AsDictionary()
+            );
+
+            contextValue.Should().Be("original_value");
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key = "new_value" }.AsDictionary()
+            );
+
+            contextValue.Should().Be("new_value");
+        }
     }
 }
\ No newline at end of file
diff --git a/src/Polly.Specs/WaitAndRetrySpecs.cs b/src/Polly.Specs/WaitAndRetrySpecs.cs
index f968b4d7..dcbaed08 100644
--- a/src/Polly.Specs/WaitAndRetrySpecs.cs
+++ b/src/Polly.Specs/WaitAndRetrySpecs.cs
@@ -17,26 +17,54 @@ namespace Polly.Specs
         }
 
         [Fact]
-        public void Should_throw_when_sleep_durations_is_null()
+        public void Should_throw_when_sleep_durations_is_null_without_context()
         {
+            Action<Exception, TimeSpan> onRetry = (_, __) => { };
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .WaitAndRetry(null, onRetry);
+
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("sleepDurations");
+        }
+
+        [Fact]
+        public void Should_throw_when_sleep_durations_is_null_with_context()
+        {
+            Action<Exception, TimeSpan, Context> onRetry = (_, __, ___) => { };
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .WaitAndRetry(null);
+                                      .WaitAndRetry(null, onRetry);
 
-            policy.ShouldThrow<ArgumentNullException>()
-                  .And
+            policy.ShouldThrow<ArgumentNullException>().And
                   .ParamName.Should().Be("sleepDurations");
         }
 
         [Fact]
-        public void Should_throw_when_on_retry_action_is_null()
+        public void Should_throw_when_onretry_action_is_null_without_context()
         {
+            Action<Exception, TimeSpan> nullOnRetry = null;
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .WaitAndRetry(Enumerable.Empty<TimeSpan>(), nullOnRetry);
+
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("onRetry");
+        }
+
+        [Fact]
+        public void Should_throw_when_onretry_action_is_null_with_context()
+        {
+            Action<Exception, TimeSpan, Context> nullOnRetry = null;
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .WaitAndRetry(Enumerable.Empty<TimeSpan>(), null);
+                                      .WaitAndRetry(Enumerable.Empty<TimeSpan>(), nullOnRetry);
 
-            policy.ShouldThrow<ArgumentNullException>()
-                  .And
+            policy.ShouldThrow<ArgumentNullException>().And
                   .ParamName.Should().Be("onRetry");
         }
         
@@ -349,6 +377,29 @@ namespace Polly.Specs
                 .ContainInOrder(expectedExceptions);
         }
 
+        [Fact]
+        public void Should_call_onretry_with_the_passed_context()
+        {
+            IDictionary<string, object> contextData = null;
+
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .WaitAndRetry(new[]
+                {
+                   1.Seconds(),
+                   2.Seconds(),
+                   3.Seconds()
+                }, (_, __, context) => contextData = context);
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key1 = "value1", key2 = "value2" }.AsDictionary()
+            );
+
+            contextData.Should()
+                       .ContainKeys("key1", "key2").And
+                       .ContainValues("value1", "value2");
+        }
+
         [Fact]
         public void Should_not_call_onretry_when_no_retries_are_performed()
         {
@@ -383,41 +434,109 @@ namespace Polly.Specs
         }
 
         [Fact]
-        public void Should_throw_when_retry_count_is_less_than_one()
+        public void Should_create_new_context_for_each_call_to_policy()
+        {
+            string contextValue = null;
+
+            var policy = Policy
+                .Handle<DivideByZeroException>()
+                .WaitAndRetry(new[]
+                {
+                    1.Seconds()
+                }, 
+                (_, __, context) => contextValue = context["key"].ToString());
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key = "original_value" }.AsDictionary()
+            );
+
+            contextValue.Should().Be("original_value");
+
+            policy.RaiseException<DivideByZeroException>(
+                new { key = "new_value" }.AsDictionary()
+            );
+
+            contextValue.Should().Be("new_value");
+        }
+
+        [Fact]
+        public void Should_throw_when_retry_count_is_less_than_one_without_context()
         {
+            Action<Exception, TimeSpan> onRetry = (_, __) => { };
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .WaitAndRetry(0, _ => new TimeSpan());
+                                      .WaitAndRetry(0, _ => new TimeSpan(), onRetry);
                                            
-            policy.ShouldThrow<ArgumentOutOfRangeException>()
-                  .And
+            policy.ShouldThrow<ArgumentOutOfRangeException>().And                  
+                  .ParamName.Should().Be("retryCount");
+        }
+
+        [Fact]
+        public void Should_throw_when_retry_count_is_less_than_one_with_context()
+        {
+            Action<Exception, TimeSpan, Context> onRetry = (_, __, ___) => { };
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .WaitAndRetry(0, _ => new TimeSpan(), onRetry);
+
+            policy.ShouldThrow<ArgumentOutOfRangeException>().And
                   .ParamName.Should().Be("retryCount");
         }
 
         [Fact]
-        public void Should_throw_when_on_retry_action_is_null_for_overload()
+        public void Should_throw_when_sleep_duration_provider_is_null_without_context()
         {
+            Action<Exception, TimeSpan> onRetry = (_, __) => { };
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .WaitAndRetry(1, _ => new TimeSpan(), null);
+                                      .WaitAndRetry(1, null, onRetry);
 
-            policy.ShouldThrow<ArgumentNullException>()
-                  .And
-                  .ParamName.Should().Be("onRetry");
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("sleepDurationProvider");
         }
 
         [Fact]
-        public void Should_throw_when_sleep_duration_provider_is_null()
+        public void Should_throw_when_sleep_duration_provider_is_null_with_context()
         {
+            Action<Exception, TimeSpan, Context> onRetry = (_, __, ___) => { };
+
             Action policy = () => Policy
                                       .Handle<DivideByZeroException>()
-                                      .WaitAndRetry(1, null);
+                                      .WaitAndRetry(1, null, onRetry);
 
-            policy.ShouldThrow<ArgumentNullException>()
-                  .And
+            policy.ShouldThrow<ArgumentNullException>().And
                   .ParamName.Should().Be("sleepDurationProvider");
         }
 
+        [Fact]
+        public void Should_throw_when_onretry_action_is_null_without_context_when_using_provider_overload()
+        {
+            Action<Exception, TimeSpan> nullOnRetry = null;
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .WaitAndRetry(1, _ => new TimeSpan(), nullOnRetry);
+
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("onRetry");
+        }
+
+        [Fact]
+        public void Should_throw_when_onretry_action_is_null_with_context_when_using_provider_overload()
+        {
+            Action<Exception, TimeSpan, Context> nullOnRetry = null;
+
+            Action policy = () => Policy
+                                      .Handle<DivideByZeroException>()
+                                      .WaitAndRetry(1, _ => new TimeSpan(), nullOnRetry);
+
+            policy.ShouldThrow<ArgumentNullException>().And
+                  .ParamName.Should().Be("onRetry");
+        }
+
         [Fact]
         public void Should_calculate_retry_timespans_from_current_retry_attempt_and_timespan_provider()
         {
