diff --git a/src/Polly.Shared/Wrap/IPolicyWrap.cs b/src/Polly.Shared/Wrap/IPolicyWrap.cs
index 716930af..e021f3e1 100644
--- a/src/Polly.Shared/Wrap/IPolicyWrap.cs
+++ b/src/Polly.Shared/Wrap/IPolicyWrap.cs
@@ -6,6 +6,15 @@
 
     public interface IPolicyWrap : IsPolicy
     {
+        /// <summary>
+        /// Returns the outer <see cref="IsPolicy"/> in this <see cref="IPolicyWrap"/>
+        /// </summary>
+        IsPolicy Outer { get; }
+
+        /// <summary>
+        /// Returns the next inner <see cref="IsPolicy"/> in this <see cref="IPolicyWrap"/>
+        /// </summary>
+        IsPolicy Inner { get; }
     }
 
     /// <summary>
diff --git a/src/Polly.Shared/Wrap/PolicyWrap.cs b/src/Polly.Shared/Wrap/PolicyWrap.cs
index e9b5884e..2aed1d85 100644
--- a/src/Polly.Shared/Wrap/PolicyWrap.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrap.cs
@@ -9,9 +9,43 @@ namespace Polly.Wrap
     /// </summary>
     public partial class PolicyWrap : Policy, IPolicyWrap
     {
+        private Policy _outer;
+        private Policy _inner;
+
+        /// <summary>
+        /// Returns the outer <see cref="IsPolicy"/> in this <see cref="IPolicyWrap"/>
+        /// </summary>
+        public IsPolicy Outer => _outer;
+
+        /// <summary>
+        /// Returns the next inner <see cref="IsPolicy"/> in this <see cref="IPolicyWrap"/>
+        /// </summary>
+        public IsPolicy Inner => _inner;
+
         internal PolicyWrap(Action<Action<Context, CancellationToken>, Context, CancellationToken> policyAction, Policy outer, Policy inner) 
             : base(policyAction, outer.ExceptionPredicates)
         {
+            _outer = outer;
+            _inner = inner;
+        }
+
+        /// <summary>
+        /// Executes the specified action within the cache policy and returns the result.
+        /// </summary>
+        /// <typeparam name="TResult">The type of the result.</typeparam>
+        /// <param name="action">The action to perform.</param>
+        /// <param name="context">Execution context that is passed to the exception policy; defines the cache key to use in cache lookup.</param>
+        /// <param name="cancellationToken">The cancellation token.</param>
+        /// <returns>The value returned by the action, or the cache.</returns>
+        public override TResult Execute<TResult>(Func<Context, CancellationToken, TResult> action, Context context, CancellationToken cancellationToken)
+        {
+            return PolicyWrapEngine.Implementation<TResult>(
+                   action,
+                   context,
+                   cancellationToken,
+                   _outer, 
+                   _inner
+                   );
         }
     }
 
@@ -21,14 +55,28 @@ namespace Polly.Wrap
     /// <typeparam name="TResult">The return type of delegates which may be executed through the policy.</typeparam>
     public partial class PolicyWrap<TResult> : Policy<TResult>, IPolicyWrap<TResult>
     {
+        /// <summary>
+        /// Returns the outer <see cref="IsPolicy"/> in this <see cref="IPolicyWrap"/>
+        /// </summary>
+        public IsPolicy Outer { get; private set; }
+
+        /// <summary>
+        /// Returns the next inner <see cref="IsPolicy"/> in this <see cref="IPolicyWrap"/>
+        /// </summary>
+        public IsPolicy Inner { get; private set; }
+
         internal PolicyWrap(Func<Func<Context, CancellationToken, TResult>, Context, CancellationToken, TResult> policyAction, Policy outer, IsPolicy inner)
             : base(policyAction, outer.ExceptionPredicates,  PredicateHelper<TResult>.EmptyResultPredicates)
         {
+            Outer = outer;
+            Inner = inner;
         }
 
         internal PolicyWrap(Func<Func<Context, CancellationToken, TResult>, Context, CancellationToken, TResult> policyAction, Policy<TResult> outer, IsPolicy inner)
             : base(policyAction, outer.ExceptionPredicates, outer.ResultPredicates)
         {
+            Outer = outer;
+            Inner = inner;
         }
     }
 }
diff --git a/src/Polly.Shared/Wrap/PolicyWrapAsync.cs b/src/Polly.Shared/Wrap/PolicyWrapAsync.cs
index bb794f81..c9919eaf 100644
--- a/src/Polly.Shared/Wrap/PolicyWrapAsync.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrapAsync.cs
@@ -10,6 +10,28 @@ namespace Polly.Wrap
         internal PolicyWrap(Func<Func<Context, CancellationToken, Task>, Context, CancellationToken, bool, Task> policyAction, Policy outer, Policy inner)
             : base(policyAction, outer.ExceptionPredicates)
         {
+            _outer = outer;
+            _inner = inner;
+        }
+
+        /// <summary>
+        /// Executes the specified action asynchronously within the cache policy and returns the result.
+        /// </summary>
+        /// <typeparam name="TResult">The type of the result.</typeparam>
+        /// <param name="action">The action to perform.</param>
+        /// <param name="context">Execution context that is passed to the exception policy; defines the cache key to use in cache lookup.</param>
+        /// <param name="cancellationToken">The cancellation token.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <returns>The value returned by the action, or the cache.</returns>
+        public override Task<TResult> ExecuteAsync<TResult>(Func<Context, CancellationToken, Task<TResult>> action, Context context, CancellationToken cancellationToken, bool continueOnCapturedContext)
+        {
+            return PolicyWrapEngine.ImplementationAsync<TResult>(
+                action,
+                context,
+                cancellationToken,
+                continueOnCapturedContext,
+                _outer,
+                _inner);
         }
     }
 
@@ -18,11 +40,15 @@ namespace Polly.Wrap
         internal PolicyWrap(Func<Func<Context, CancellationToken, Task<TResult>>, Context, CancellationToken, bool, Task<TResult>> policyAction, Policy outer, IsPolicy inner)
             : base(policyAction, outer.ExceptionPredicates, PredicateHelper<TResult>.EmptyResultPredicates)
         {
+            Outer = outer;
+            Inner = inner;
         }
 
         internal PolicyWrap(Func<Func<Context, CancellationToken, Task<TResult>>, Context, CancellationToken, bool, Task<TResult>> policyAction, Policy<TResult> outer, IsPolicy inner)
             : base(policyAction, outer.ExceptionPredicates, outer.ResultPredicates)
         {
+            Outer = outer;
+            Inner = inner;
         }
     }
 }
diff --git a/src/Polly.Shared/Wrap/PolicyWrapEngine.cs b/src/Polly.Shared/Wrap/PolicyWrapEngine.cs
index 64c1325b..d4b268b7 100644
--- a/src/Polly.Shared/Wrap/PolicyWrapEngine.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrapEngine.cs
@@ -22,7 +22,7 @@ namespace Polly.Wrap
            Policy<TResult> outerPolicy,
            Policy innerPolicy)
         {
-            return outerPolicy.Execute((ctx, ct) => innerPolicy.Execute(func, ctx, ct), context, cancellationToken);
+            return outerPolicy.Execute((ctx, ct) => innerPolicy.Execute<TResult>(func, ctx, ct), context, cancellationToken);
         }
 
         internal static TResult Implementation<TResult>(
@@ -35,6 +35,16 @@ namespace Polly.Wrap
             return outerPolicy.Execute<TResult>((ctx, ct) => innerPolicy.Execute(func, ctx, ct), context, cancellationToken);
         }
 
+        internal static TResult Implementation<TResult>(
+           Func<Context, CancellationToken, TResult> func,
+           Context context,
+           CancellationToken cancellationToken,
+           Policy outerPolicy,
+           Policy innerPolicy)
+        {
+            return outerPolicy.Execute<TResult>((ctx, ct) => innerPolicy.Execute<TResult>(func, ctx, ct), context, cancellationToken);
+        }
+
         internal static void Implementation(
            Action<Context, CancellationToken> action,
            Context context,
diff --git a/src/Polly.Shared/Wrap/PolicyWrapEngineAsync.cs b/src/Polly.Shared/Wrap/PolicyWrapEngineAsync.cs
index dbd55b9d..0f162095 100644
--- a/src/Polly.Shared/Wrap/PolicyWrapEngineAsync.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrapEngineAsync.cs
@@ -36,7 +36,7 @@ namespace Polly.Wrap
             Policy innerPolicy)
         {
             return await outerPolicy.ExecuteAsync(
-                async (ctx, ct) => await innerPolicy.ExecuteAsync(
+                async (ctx, ct) => await innerPolicy.ExecuteAsync<TResult>(
                     func,
                     ctx,
                     ct,
@@ -56,7 +56,7 @@ namespace Polly.Wrap
             Policy outerPolicy,
             Policy<TResult> innerPolicy)
         {
-            return await outerPolicy.ExecuteAsync(
+            return await outerPolicy.ExecuteAsync<TResult>(
                 async (ctx, ct) => await innerPolicy.ExecuteAsync(
                     func,
                     ctx,
@@ -69,6 +69,27 @@ namespace Polly.Wrap
                 ).ConfigureAwait(continueOnCapturedContext);
         }
 
+        internal static async Task<TResult> ImplementationAsync<TResult>(
+           Func<Context, CancellationToken, Task<TResult>> func,
+           Context context,
+           CancellationToken cancellationToken,
+           bool continueOnCapturedContext,
+           Policy outerPolicy,
+           Policy innerPolicy)
+        {
+            return await outerPolicy.ExecuteAsync<TResult>(
+                async (ctx, ct) => await innerPolicy.ExecuteAsync<TResult>(
+                    func,
+                    ctx,
+                    ct,
+                    continueOnCapturedContext
+                ).ConfigureAwait(continueOnCapturedContext),
+                context,
+                cancellationToken,
+                continueOnCapturedContext
+            ).ConfigureAwait(continueOnCapturedContext);
+        }
+
         internal static async Task ImplementationAsync(
             Func<Context, CancellationToken, Task> action,
             Context context,
diff --git a/src/Polly.SharedSpecs/Caching/CacheAsyncSpecs.cs b/src/Polly.SharedSpecs/Caching/CacheAsyncSpecs.cs
index 6538ad03..50c03866 100644
--- a/src/Polly.SharedSpecs/Caching/CacheAsyncSpecs.cs
+++ b/src/Polly.SharedSpecs/Caching/CacheAsyncSpecs.cs
@@ -6,6 +6,7 @@ using Polly.Caching;
 using Polly.Specs.Helpers;
 using Polly.Specs.Helpers.Caching;
 using Polly.Utilities;
+using Polly.Wrap;
 using Xunit;
 
 namespace Polly.Specs.Caching
@@ -217,6 +218,94 @@ namespace Polly.Specs.Caching
 
         #endregion
 
+        #region Non-generic CachePolicy in non-generic PolicyWrap
+
+        [Fact]
+        public async Task Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_outermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            IAsyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy cache = Policy.CacheAsync(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOpAsync();
+            PolicyWrap wrap = Policy.WrapAsync(cache, noop);
+
+            await stubCacheProvider.PutAsync(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue), CancellationToken.None, false).ConfigureAwait(false);
+
+            bool delegateExecuted = false;
+
+            (await wrap.ExecuteAsync(async () =>
+            {
+                delegateExecuted = true;
+                await TaskHelper.EmptyTask.ConfigureAwait(false);
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .ConfigureAwait(false))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public async Task Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_innermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            IAsyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy cache = Policy.CacheAsync(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOpAsync();
+            PolicyWrap wrap = Policy.WrapAsync(noop, cache);
+
+            await stubCacheProvider.PutAsync(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue), CancellationToken.None, false).ConfigureAwait(false);
+
+            bool delegateExecuted = false;
+
+            (await wrap.ExecuteAsync(async () =>
+            {
+                delegateExecuted = true;
+                await TaskHelper.EmptyTask.ConfigureAwait(false);
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .ConfigureAwait(false))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public async Task Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_mid_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            IAsyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy cache = Policy.CacheAsync(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOpAsync();
+            PolicyWrap wrap = Policy.WrapAsync(noop, cache, noop);
+
+            await stubCacheProvider.PutAsync(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue), CancellationToken.None, false).ConfigureAwait(false);
+
+            bool delegateExecuted = false;
+
+            (await wrap.ExecuteAsync(async () =>
+            {
+                delegateExecuted = true;
+                await TaskHelper.EmptyTask.ConfigureAwait(false);
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .ConfigureAwait(false))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        #endregion
+
         #region No-op pass-through behaviour
 
         [Fact]
diff --git a/src/Polly.SharedSpecs/Caching/CacheSpecs.cs b/src/Polly.SharedSpecs/Caching/CacheSpecs.cs
index 5979cdb4..c9c860de 100644
--- a/src/Polly.SharedSpecs/Caching/CacheSpecs.cs
+++ b/src/Polly.SharedSpecs/Caching/CacheSpecs.cs
@@ -5,6 +5,7 @@ using Polly.Caching;
 using Polly.Specs.Helpers;
 using Polly.Specs.Helpers.Caching;
 using Polly.Utilities;
+using Polly.Wrap;
 using Xunit;
 
 namespace Polly.Specs.Caching
@@ -212,6 +213,88 @@ namespace Polly.Specs.Caching
 
         #endregion
 
+        #region Non-generic CachePolicy in non-generic PolicyWrap
+
+        [Fact]
+        public void Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_outermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            ISyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy cache = Policy.Cache(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOp();
+            PolicyWrap wrap = Policy.Wrap(cache, noop);
+
+            stubCacheProvider.Put(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue));
+
+            bool delegateExecuted = false;
+
+            wrap.Execute(() =>
+            {
+                delegateExecuted = true;
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public void Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_innermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            ISyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy cache = Policy.Cache(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOp();
+            PolicyWrap wrap = Policy.Wrap(noop, cache);
+
+            stubCacheProvider.Put(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue));
+
+            bool delegateExecuted = false;
+
+            wrap.Execute(() =>
+            {
+                delegateExecuted = true;
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public void Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_mid_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            ISyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy cache = Policy.Cache(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOp();
+            PolicyWrap wrap = Policy.Wrap(noop, cache, noop);
+
+            stubCacheProvider.Put(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue));
+
+            bool delegateExecuted = false;
+
+            wrap.Execute(() =>
+            {
+                delegateExecuted = true;
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        #endregion
+
         #region No-op pass-through behaviour
 
         [Fact]
diff --git a/src/Polly.SharedSpecs/Caching/CacheTResultAsyncSpecs.cs b/src/Polly.SharedSpecs/Caching/CacheTResultAsyncSpecs.cs
index f49a5dc0..9c1f4cf0 100644
--- a/src/Polly.SharedSpecs/Caching/CacheTResultAsyncSpecs.cs
+++ b/src/Polly.SharedSpecs/Caching/CacheTResultAsyncSpecs.cs
@@ -6,6 +6,7 @@ using Polly.Caching;
 using Polly.Specs.Helpers;
 using Polly.Specs.Helpers.Caching;
 using Polly.Utilities;
+using Polly.Wrap;
 using Xunit;
 
 namespace Polly.Specs.Caching
@@ -218,6 +219,94 @@ namespace Polly.Specs.Caching
 
         #endregion
 
+        #region Generic CachePolicy in PolicyWrap
+
+        [Fact]
+        public async Task Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_outermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            IAsyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy<string> cache = Policy.CacheAsync<string>(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOpAsync();
+            PolicyWrap<string> wrap = cache.WrapAsync(noop);
+
+            await stubCacheProvider.PutAsync(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue), CancellationToken.None, false).ConfigureAwait(false);
+
+            bool delegateExecuted = false;
+
+            (await wrap.ExecuteAsync(async () =>
+            {
+                delegateExecuted = true;
+                await TaskHelper.EmptyTask.ConfigureAwait(false);
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .ConfigureAwait(false))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public async Task Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_innermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            IAsyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy<string> cache = Policy.CacheAsync<string>(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOpAsync();
+            PolicyWrap<string> wrap = noop.WrapAsync(cache);
+
+            await stubCacheProvider.PutAsync(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue), CancellationToken.None, false).ConfigureAwait(false);
+
+            bool delegateExecuted = false;
+
+            (await wrap.ExecuteAsync(async () =>
+            {
+                delegateExecuted = true;
+                await TaskHelper.EmptyTask.ConfigureAwait(false);
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .ConfigureAwait(false))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public async Task Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_mid_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            IAsyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy<string> cache = Policy.CacheAsync<string>(stubCacheProvider, TimeSpan.MaxValue);
+            Policy<string> noop = Policy.NoOpAsync<string>();
+            PolicyWrap<string> wrap = Policy.WrapAsync(noop, cache, noop);
+
+            await stubCacheProvider.PutAsync(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue), CancellationToken.None, false).ConfigureAwait(false);
+
+            bool delegateExecuted = false;
+
+            (await wrap.ExecuteAsync(async () =>
+            {
+                delegateExecuted = true;
+                await TaskHelper.EmptyTask.ConfigureAwait(false);
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .ConfigureAwait(false))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        #endregion
+
         #region No-op pass-through behaviour
 
         [Fact]
diff --git a/src/Polly.SharedSpecs/Caching/CacheTResultSpecs.cs b/src/Polly.SharedSpecs/Caching/CacheTResultSpecs.cs
index 2e05fbee..52d1d7a8 100644
--- a/src/Polly.SharedSpecs/Caching/CacheTResultSpecs.cs
+++ b/src/Polly.SharedSpecs/Caching/CacheTResultSpecs.cs
@@ -5,6 +5,7 @@ using Polly.Caching;
 using Polly.Specs.Helpers;
 using Polly.Specs.Helpers.Caching;
 using Polly.Utilities;
+using Polly.Wrap;
 using Xunit;
 
 namespace Polly.Specs.Caching
@@ -212,6 +213,88 @@ namespace Polly.Specs.Caching
 
         #endregion
 
+        #region Generic CachePolicy in PolicyWrap
+
+        [Fact]
+        public void Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_outermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            ISyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy<string> cache = Policy.Cache<string>(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOp();
+            PolicyWrap<string> wrap = cache.Wrap(noop);
+
+            stubCacheProvider.Put(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue));
+
+            bool delegateExecuted = false;
+
+            wrap.Execute(() =>
+            {
+                delegateExecuted = true;
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public void Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_innermost_in_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            ISyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy<string> cache = Policy.Cache<string>(stubCacheProvider, TimeSpan.MaxValue);
+            Policy noop = Policy.NoOp();
+            PolicyWrap<string> wrap = noop.Wrap(cache);
+
+            stubCacheProvider.Put(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue));
+
+            bool delegateExecuted = false;
+
+            wrap.Execute(() =>
+            {
+                delegateExecuted = true;
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        [Fact]
+        public void Should_return_value_from_cache_and_not_execute_delegate_if_cache_holds_value_when_mid_policywrap()
+        {
+            const string valueToReturnFromCache = "valueToReturnFromCache";
+            const string valueToReturnFromExecution = "valueToReturnFromExecution";
+            const string executionKey = "SomeExecutionKey";
+
+            ISyncCacheProvider stubCacheProvider = new StubCacheProvider();
+            CachePolicy<string> cache = Policy.Cache<string>(stubCacheProvider, TimeSpan.MaxValue);
+            Policy<string> noop = Policy.NoOp<string>();
+            PolicyWrap<string> wrap = Policy.Wrap(noop, cache, noop);
+
+            stubCacheProvider.Put(executionKey, valueToReturnFromCache, new Ttl(TimeSpan.MaxValue));
+
+            bool delegateExecuted = false;
+
+            wrap.Execute(() =>
+            {
+                delegateExecuted = true;
+                return valueToReturnFromExecution;
+            }, new Context(executionKey))
+                .Should().Be(valueToReturnFromCache);
+
+            delegateExecuted.Should().BeFalse();
+        }
+
+        #endregion
+
         #region No-op pass-through behaviour
 
         [Fact]
diff --git a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs
index a45f6b16..b27f962e 100644
--- a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs
+++ b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs
@@ -1,6 +1,7 @@
 ï»¿using System;
 using FluentAssertions;
 using Polly.CircuitBreaker;
+using Polly.NoOp;
 using Polly.Retry;
 using Polly.Specs.Helpers;
 using Polly.Wrap;
@@ -53,6 +54,54 @@ namespace Polly.Specs.Wrap
             config.ShouldThrow<ArgumentNullException>().And.ParamName.Should().Be("innerPolicy");
         }
 
+        [Fact]
+        public void Nongeneric_wraps_nongeneric_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy policyA = Policy.NoOp();
+            Policy policyB = Policy.NoOp();
+
+            PolicyWrap wrap = policyA.Wrap(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
+        [Fact]
+        public void Nongeneric_wraps_generic_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy policyA = Policy.NoOp();
+            Policy<int> policyB = Policy.NoOp<int>();
+
+            PolicyWrap<int> wrap = policyA.Wrap(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
+        [Fact]
+        public void Generic_wraps_nongeneric_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy<int> policyA = Policy.NoOp<int>();
+            Policy policyB = Policy.NoOp();
+
+            PolicyWrap<int> wrap = policyA.Wrap(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
+        [Fact]
+        public void Generic_wraps_generic_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy<int> policyA = Policy.NoOp<int>();
+            Policy<int> policyB = Policy.NoOp<int>();
+
+            PolicyWrap<int> wrap = policyA.Wrap(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
         #endregion
 
         #region Static configuration syntax tests, non-generic policies
@@ -96,6 +145,18 @@ namespace Polly.Specs.Wrap
             config.ShouldNotThrow();
         }
 
+        [Fact]
+        public void Wrapping_policies_using_static_wrap_syntax_should_set_outer_inner()
+        {
+            Policy policyA = Policy.NoOp();
+            Policy policyB = Policy.NoOp();
+
+            PolicyWrap wrap = Policy.Wrap(policyA, policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
         #endregion
 
         #region Static configuration syntax tests, strongly-typed policies
@@ -139,6 +200,18 @@ namespace Polly.Specs.Wrap
             config.ShouldNotThrow();
         }
 
+        [Fact]
+        public void Wrapping_policies_using_static_wrap_strongly_typed_syntax_should_set_outer_inner()
+        {
+            Policy<int> policyA = Policy.NoOp<int>();
+            Policy<int> policyB = Policy.NoOp<int>();
+
+            PolicyWrap<int> wrap = Policy.Wrap(policyA, policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
         #endregion
 
         #region Instance-configured: execution tests
diff --git a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs
index ddc1b2c9..4b112412 100644
--- a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs
+++ b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs
@@ -44,7 +44,6 @@ namespace Polly.Specs.Wrap
             config.ShouldThrow<ArgumentNullException>().And.ParamName.Should().Be("innerPolicy");
         }
 
-
         [Fact]
         public void Generic_wraps_generic_instance_syntax_wrapping_null_should_throw()
         {
@@ -55,6 +54,54 @@ namespace Polly.Specs.Wrap
             config.ShouldThrow<ArgumentNullException>().And.ParamName.Should().Be("innerPolicy");
         }
 
+        [Fact]
+        public void Nongeneric_wraps_nongeneric_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy policyA = Policy.NoOpAsync();
+            Policy policyB = Policy.NoOpAsync();
+
+            PolicyWrap wrap = policyA.WrapAsync(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
+        [Fact]
+        public void Nongeneric_wraps_generic_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy policyA = Policy.NoOpAsync();
+            Policy<int> policyB = Policy.NoOpAsync<int>();
+
+            PolicyWrap<int> wrap = policyA.WrapAsync(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
+        [Fact]
+        public void Generic_wraps_nongeneric_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy<int> policyA = Policy.NoOpAsync<int>();
+            Policy policyB = Policy.NoOpAsync();
+
+            PolicyWrap<int> wrap = policyA.WrapAsync(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
+        [Fact]
+        public void Generic_wraps_generic_using_instance_wrap_syntax_should_set_outer_inner()
+        {
+            Policy<int> policyA = Policy.NoOpAsync<int>();
+            Policy<int> policyB = Policy.NoOpAsync<int>();
+
+            PolicyWrap<int> wrap = policyA.WrapAsync(policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
         #endregion
 
         #region Static configuration syntax tests, non-generic policies
@@ -98,6 +145,18 @@ namespace Polly.Specs.Wrap
             config.ShouldNotThrow();
         }
 
+        [Fact]
+        public void Wrapping_policies_using_static_wrap_syntax_should_set_outer_inner()
+        {
+            Policy policyA = Policy.NoOpAsync();
+            Policy policyB = Policy.NoOpAsync();
+
+            PolicyWrap wrap = Policy.WrapAsync(policyA, policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
         #endregion
 
         #region Static configuration syntax tests, strongly-typed policies
@@ -141,6 +200,18 @@ namespace Polly.Specs.Wrap
             config.ShouldNotThrow();
         }
 
+        [Fact]
+        public void Wrapping_policies_using_static_wrap_strongly_typed_syntax_should_set_outer_inner()
+        {
+            Policy<int> policyA = Policy.NoOpAsync<int>();
+            Policy<int> policyB = Policy.NoOpAsync<int>();
+
+            PolicyWrap<int> wrap = Policy.WrapAsync(policyA, policyB);
+
+            wrap.Outer.Should().BeSameAs(policyA);
+            wrap.Inner.Should().BeSameAs(policyB);
+        }
+
         #endregion
 
         #region Instance-configured: execution tests
