diff --git a/CHANGELOG.md b/CHANGELOG.md
index 8c3cdb6f..44de2aa5 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,3 +1,7 @@
+## 5.3.0
+- Fix ExecuteAndCapture() usage with PolicyWrap   
+- Allow Fallback delegates to take execution Context
+
 ## 5.2.0
 - Add PolicyRegistry for storing and retrieving policies.
 - Add interfaces by policy type and execution type.
diff --git a/GitVersionConfig.yaml b/GitVersionConfig.yaml
index d4468eac..0be1745c 100644
--- a/GitVersionConfig.yaml
+++ b/GitVersionConfig.yaml
@@ -1 +1 @@
-next-version: 5.2.0
+next-version: 5.3.0
diff --git a/src/Polly.Net40Async.nuspec b/src/Polly.Net40Async.nuspec
index 17fa7c3d..e134b39f 100644
--- a/src/Polly.Net40Async.nuspec
+++ b/src/Polly.Net40Async.nuspec
@@ -15,6 +15,11 @@
     <releaseNotes>
      v5.0 is a major release with significant new resilience policies: Timeout; Bulkhead Isolation; Fallback; and PolicyWrap.  See release notes back to v5.0.0 for full details.  v5.0.5 includes important circuit-breaker fixes.
 
+     5.3.0
+     ---------------------
+     - Fix ExecuteAndCapture() usage with PolicyWrap   
+     - Allow Fallback delegates to take execution Context
+
      5.2.0
      ---------------------
      - Add PolicyRegistry for storing and retrieving policies.
diff --git a/src/Polly.NetStandard11/Properties/AssemblyInfo.cs b/src/Polly.NetStandard11/Properties/AssemblyInfo.cs
index 99ae7ecc..9fb8b67c 100644
--- a/src/Polly.NetStandard11/Properties/AssemblyInfo.cs
+++ b/src/Polly.NetStandard11/Properties/AssemblyInfo.cs
@@ -3,7 +3,7 @@ using System.Reflection;
 using System.Runtime.CompilerServices;
 
 [assembly: AssemblyTitle("Polly")]
-[assembly: AssemblyVersion("5.2.0.0")]
+[assembly: AssemblyVersion("5.3.0.0")]
 [assembly: CLSCompliant(true)]
 
 [assembly: InternalsVisibleTo("Polly.Pcl.Specs")]
\ No newline at end of file
diff --git a/src/Polly.Shared/Fallback/FallbackEngine.cs b/src/Polly.Shared/Fallback/FallbackEngine.cs
index c61d4069..1f64a629 100644
--- a/src/Polly.Shared/Fallback/FallbackEngine.cs
+++ b/src/Polly.Shared/Fallback/FallbackEngine.cs
@@ -14,7 +14,7 @@ namespace Polly.Fallback
             IEnumerable<ExceptionPredicate> shouldHandleExceptionPredicates,
             IEnumerable<ResultPredicate<TResult>> shouldHandleResultPredicates,
             Action<DelegateResult<TResult>, Context> onFallback,
-            Func<CancellationToken, TResult> fallbackAction)
+            Func<Context, CancellationToken, TResult> fallbackAction)
         {
             DelegateResult<TResult> delegateOutcome;
 
@@ -43,7 +43,7 @@ namespace Polly.Fallback
 
             onFallback(delegateOutcome, context);
 
-            return fallbackAction(cancellationToken);
+            return fallbackAction(context, cancellationToken);
         }
     }
 }
diff --git a/src/Polly.Shared/Fallback/FallbackEngineAsync.cs b/src/Polly.Shared/Fallback/FallbackEngineAsync.cs
index f0398f8e..7beec7ab 100644
--- a/src/Polly.Shared/Fallback/FallbackEngineAsync.cs
+++ b/src/Polly.Shared/Fallback/FallbackEngineAsync.cs
@@ -14,7 +14,7 @@ namespace Polly.Fallback
             IEnumerable<ExceptionPredicate> shouldHandleExceptionPredicates,
             IEnumerable<ResultPredicate<TResult>> shouldHandleResultPredicates,
             Func<DelegateResult<TResult>, Context, Task> onFallbackAsync,
-            Func<CancellationToken, Task<TResult>> fallbackAction,
+            Func<Context, CancellationToken, Task<TResult>> fallbackAction,
             CancellationToken cancellationToken,
             bool continueOnCapturedContext)
         {
@@ -45,7 +45,7 @@ namespace Polly.Fallback
 
             await onFallbackAsync(delegateOutcome, context).ConfigureAwait(continueOnCapturedContext);
 
-            return await fallbackAction(cancellationToken).ConfigureAwait(continueOnCapturedContext);
+            return await fallbackAction(context, cancellationToken).ConfigureAwait(continueOnCapturedContext);
         }
     }
 }
diff --git a/src/Polly.Shared/Fallback/FallbackSyntax.cs b/src/Polly.Shared/Fallback/FallbackSyntax.cs
index 5a761d5f..3ec6a689 100644
--- a/src/Polly.Shared/Fallback/FallbackSyntax.cs
+++ b/src/Polly.Shared/Fallback/FallbackSyntax.cs
@@ -55,7 +55,7 @@ namespace Polly
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(fallbackAction, (exception, ctx) => onFallback(exception));
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(), (exception, ctx) => onFallback(exception));
         }
 
 
@@ -73,7 +73,7 @@ namespace Polly
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(fallbackAction, (exception, ctx) => onFallback(exception));
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(ct), (exception, ctx) => onFallback(exception));
         }
 
         /// <summary>
@@ -85,14 +85,31 @@ namespace Polly
         /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
         /// <exception cref="System.ArgumentNullException">onFallback</exception>
         /// <returns>The policy instance.</returns>
+        [Obsolete("This overload is deprecated and will be removed in a future release. Prefer the overload in which both fallbackAction and onFallback take a Context input parameter.")]
         public static FallbackPolicy Fallback(this PolicyBuilder policyBuilder, Action fallbackAction, Action<Exception, Context> onFallback)
         {
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(ct => fallbackAction(), onFallback);
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(), onFallback);
         }
 
+        /// <summary>
+        /// Builds a <see cref="FallbackPolicy"/> which provides a fallback action if the main execution fails.  Executes the main delegate, but if this throws a handled exception, first calls <paramref name="onFallback"/> with details of the handled exception and the execution context; then calls <paramref name="fallbackAction"/>.  
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="fallbackAction">The fallback action.</param>
+        /// <param name="onFallback">The action to call before invoking the fallback delegate.</param>
+        /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
+        /// <exception cref="System.ArgumentNullException">onFallback</exception>
+        /// <returns>The policy instance.</returns>
+        public static FallbackPolicy Fallback(this PolicyBuilder policyBuilder, Action<Context> fallbackAction, Action<Exception, Context> onFallback)
+        {
+            if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
+            if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
+
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(ctx), onFallback);
+        }
 
         /// <summary>
         /// Builds a <see cref="FallbackPolicy"/> which provides a fallback action if the main execution fails.  Executes the main delegate, but if this throws a handled exception, first calls <paramref name="onFallback"/> with details of the handled exception and the execution context; then calls <paramref name="fallbackAction"/>.  
@@ -103,11 +120,29 @@ namespace Polly
         /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
         /// <exception cref="System.ArgumentNullException">onFallback</exception>
         /// <returns>The policy instance.</returns>
+        [Obsolete("This overload is deprecated and will be removed in a future release. Prefer the overload in which both fallbackAction and onFallback take a Context input parameter.")]
         public static FallbackPolicy Fallback(this PolicyBuilder policyBuilder, Action<CancellationToken> fallbackAction, Action<Exception, Context> onFallback)
         {
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(ct), onFallback);
+        }
+
+        /// <summary>
+        /// Builds a <see cref="FallbackPolicy"/> which provides a fallback action if the main execution fails.  Executes the main delegate, but if this throws a handled exception, first calls <paramref name="onFallback"/> with details of the handled exception and the execution context; then calls <paramref name="fallbackAction"/>.  
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="fallbackAction">The fallback action.</param>
+        /// <param name="onFallback">The action to call before invoking the fallback delegate.</param>
+        /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
+        /// <exception cref="System.ArgumentNullException">onFallback</exception>
+        /// <returns>The policy instance.</returns>
+        public static FallbackPolicy Fallback(this PolicyBuilder policyBuilder, Action<Context, CancellationToken> fallbackAction, Action<Exception, Context> onFallback)
+        {
+            if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
+            if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
+
             return new FallbackPolicy(
                 (action, context, cancellationToken) => FallbackEngine.Implementation(
                     (ctx, ct) => { action(ctx, ct); return EmptyStruct.Instance; },
@@ -116,7 +151,7 @@ namespace Polly
                     policyBuilder.ExceptionPredicates,
                     PredicateHelper<EmptyStruct>.EmptyResultPredicates,
                     (outcome, ctx) => onFallback(outcome.Exception, ctx),
-                    ct => { fallbackAction(ct); return EmptyStruct.Instance; }),
+                    (ctx, ct) => { fallbackAction(ctx, ct); return EmptyStruct.Instance; }),
                 policyBuilder.ExceptionPredicates);
         }
 
@@ -181,7 +216,7 @@ namespace Polly
         {
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(() => fallbackValue, (outcome, ctx) => onFallback(outcome));
+            return policyBuilder.Fallback((ctx, ct) => fallbackValue, (outcome, ctx) => onFallback(outcome));
         }
 
         /// <summary>
@@ -198,7 +233,7 @@ namespace Polly
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(fallbackAction, (outcome, ctx) => onFallback(outcome));
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(), (outcome, ctx) => onFallback(outcome));
         }
 
         /// <summary>
@@ -215,7 +250,7 @@ namespace Polly
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(fallbackAction, (outcome, ctx) => onFallback(outcome));
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(ct), (outcome, ctx) => onFallback(outcome));
         }
 
         /// <summary>
@@ -230,7 +265,7 @@ namespace Polly
         {
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(ct => fallbackValue, onFallback);
+            return policyBuilder.Fallback((ctx, ct) => fallbackValue, onFallback);
         }
 
         /// <summary>
@@ -242,12 +277,13 @@ namespace Polly
         /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
         /// <exception cref="System.ArgumentNullException">onFallback</exception>
         /// <returns>The policy instance.</returns>
+        [Obsolete("This overload is deprecated and will be removed in a future release. Prefer the overload in which both fallbackAction and onFallback take a Context input parameter.")]
         public static FallbackPolicy<TResult> Fallback<TResult>(this PolicyBuilder<TResult> policyBuilder, Func<TResult> fallbackAction, Action<DelegateResult<TResult>, Context> onFallback)
         {
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
-            return policyBuilder.Fallback(ct => fallbackAction(), onFallback);
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(), onFallback);
         }
 
         /// <summary>
@@ -259,11 +295,46 @@ namespace Polly
         /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
         /// <exception cref="System.ArgumentNullException">onFallback</exception>
         /// <returns>The policy instance.</returns>
+        public static FallbackPolicy<TResult> Fallback<TResult>(this PolicyBuilder<TResult> policyBuilder, Func<Context, TResult> fallbackAction, Action<DelegateResult<TResult>, Context> onFallback)
+        {
+            if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
+            if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
+
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(ctx), onFallback);
+        }
+
+        /// <summary>
+        /// Builds a <see cref="FallbackPolicy"/> which provides a fallback value if the main execution fails.  Executes the main delegate, but if this throws a handled exception or raises a handled result, first calls <paramref name="onFallback"/> with details of the handled exception or result and the execution context; then calls <paramref name="fallbackAction"/> and returns its result.  
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="fallbackAction">The fallback action.</param>
+        /// <param name="onFallback">The action to call before invoking the fallback delegate.</param>
+        /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
+        /// <exception cref="System.ArgumentNullException">onFallback</exception>
+        /// <returns>The policy instance.</returns>
+        [Obsolete("This overload is deprecated and will be removed in a future release. Prefer the overload in which both fallbackAction and onFallback take a Context input parameter.")]
         public static FallbackPolicy<TResult> Fallback<TResult>(this PolicyBuilder<TResult> policyBuilder, Func<CancellationToken, TResult> fallbackAction, Action<DelegateResult<TResult>, Context> onFallback)
         {
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
 
+            return policyBuilder.Fallback((ctx, ct) => fallbackAction(ct), onFallback);
+        }
+
+        /// <summary>
+        /// Builds a <see cref="FallbackPolicy"/> which provides a fallback value if the main execution fails.  Executes the main delegate, but if this throws a handled exception or raises a handled result, first calls <paramref name="onFallback"/> with details of the handled exception or result and the execution context; then calls <paramref name="fallbackAction"/> and returns its result.  
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="fallbackAction">The fallback action.</param>
+        /// <param name="onFallback">The action to call before invoking the fallback delegate.</param>
+        /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
+        /// <exception cref="System.ArgumentNullException">onFallback</exception>
+        /// <returns>The policy instance.</returns>
+        public static FallbackPolicy<TResult> Fallback<TResult>(this PolicyBuilder<TResult> policyBuilder, Func<Context, CancellationToken, TResult> fallbackAction, Action<DelegateResult<TResult>, Context> onFallback)
+        {
+            if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
+            if (onFallback == null) throw new ArgumentNullException(nameof(onFallback));
+
             return new FallbackPolicy<TResult>(
                 (action, context, cancellationToken) => FallbackEngine.Implementation<TResult>(
                     action,
diff --git a/src/Polly.Shared/Fallback/FallbackSyntaxAsync.cs b/src/Polly.Shared/Fallback/FallbackSyntaxAsync.cs
index 75ab3f8f..8d2c3b5a 100644
--- a/src/Polly.Shared/Fallback/FallbackSyntaxAsync.cs
+++ b/src/Polly.Shared/Fallback/FallbackSyntaxAsync.cs
@@ -45,7 +45,7 @@ namespace Polly
             if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
 
             return policyBuilder.FallbackAsync(
-                fallbackAction,
+                (ctx, ct) => fallbackAction(ct),
                 (outcome, context) => onFallbackAsync(outcome)
                 );
         }
@@ -59,11 +59,29 @@ namespace Polly
         /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
         /// <exception cref="System.ArgumentNullException">onFallbackAsync</exception>
         /// <returns>The policy instance.</returns>
+        [Obsolete("This overload is deprecated and will be removed in a future release. Prefer the overload in which both fallbackAction and onFallbackAsync take a Context input parameter.")]
         public static FallbackPolicy FallbackAsync(this PolicyBuilder policyBuilder, Func<CancellationToken, Task> fallbackAction, Func<Exception, Context, Task> onFallbackAsync)
         {
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
 
+            return policyBuilder.FallbackAsync((ctx, ct) => fallbackAction(ct), onFallbackAsync);
+        }
+
+        /// <summary>
+        /// Builds a <see cref="FallbackPolicy"/> which provides a fallback action if the main execution fails.  Executes the main delegate asynchronously, but if this throws a handled exception, first asynchronously calls <paramref name="onFallbackAsync"/> with details of the handled exception and execution context; then asynchronously calls <paramref name="fallbackAction"/>.  
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="fallbackAction">The fallback delegate.</param>
+        /// <param name="onFallbackAsync">The action to call asynchronously before invoking the fallback delegate.</param>
+        /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
+        /// <exception cref="System.ArgumentNullException">onFallbackAsync</exception>
+        /// <returns>The policy instance.</returns>
+        public static FallbackPolicy FallbackAsync(this PolicyBuilder policyBuilder, Func<Context, CancellationToken, Task> fallbackAction, Func<Exception, Context, Task> onFallbackAsync)
+        {
+            if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
+            if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
+
             return new FallbackPolicy(
                 (action, context, cancellationToken, continueOnCapturedContext) => FallbackEngine.ImplementationAsync(
                     async (ctx, ct) => { await action(ctx, ct).ConfigureAwait(continueOnCapturedContext); return EmptyStruct.Instance; },
@@ -71,12 +89,11 @@ namespace Polly
                     policyBuilder.ExceptionPredicates,
                     PredicateHelper<EmptyStruct>.EmptyResultPredicates,
                     (outcome, ctx) => onFallbackAsync(outcome.Exception, ctx),
-                    async ct => { await fallbackAction(ct).ConfigureAwait(continueOnCapturedContext); return EmptyStruct.Instance; },
+                    async (ctx, ct) => { await fallbackAction(ctx, ct).ConfigureAwait(continueOnCapturedContext); return EmptyStruct.Instance; },
                     cancellationToken,
                     continueOnCapturedContext),
                 policyBuilder.ExceptionPredicates);
         }
-
     }
 
     /// <summary>
@@ -130,7 +147,7 @@ namespace Polly
             if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
 
             return policyBuilder.FallbackAsync(
-                ct => TaskHelper.FromResult(fallbackValue),
+                (ctx, ct) => TaskHelper.FromResult(fallbackValue),
                 (outcome, context) => onFallbackAsync(outcome)
                 );
         }
@@ -150,7 +167,7 @@ namespace Polly
             if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
 
             return policyBuilder.FallbackAsync(
-                fallbackAction,
+                (ctx, ct) => fallbackAction(ct),
                 (outcome, context) => onFallbackAsync(outcome)
                 );
         }
@@ -168,7 +185,7 @@ namespace Polly
             if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
 
             return policyBuilder.FallbackAsync(
-                ct => TaskHelper.FromResult(fallbackValue),
+                (ctx, ct) => TaskHelper.FromResult(fallbackValue),
                 onFallbackAsync
                 );
         }
@@ -182,11 +199,29 @@ namespace Polly
         /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
         /// <exception cref="System.ArgumentNullException">onFallbackAsync</exception>
         /// <returns>The policy instance.</returns>
+        [Obsolete("This overload is deprecated and will be removed in a future release. Prefer the overload in which both fallbackAction and onFallbackAsync take a Context input parameter.")]
         public static FallbackPolicy<TResult> FallbackAsync<TResult>(this PolicyBuilder<TResult> policyBuilder, Func<CancellationToken, Task<TResult>> fallbackAction, Func<DelegateResult<TResult>, Context, Task> onFallbackAsync)
         {
             if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
             if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
 
+            return policyBuilder.FallbackAsync((ctx, ct) => fallbackAction(ct), onFallbackAsync);
+        }
+
+        /// <summary>
+        /// Builds a <see cref="FallbackPolicy"/> which provides a fallback value if the main execution fails.  Executes the main delegate asynchronously, but if this throws a handled exception or raises a handled result, first asynchronously calls <paramref name="onFallbackAsync"/> with details of the handled exception or result and the execution context; then asynchronously calls <paramref name="fallbackAction"/> and returns its result.  
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="fallbackAction">The fallback delegate.</param>
+        /// <param name="onFallbackAsync">The action to call asynchronously before invoking the fallback delegate.</param>
+        /// <exception cref="System.ArgumentNullException">fallbackAction</exception>
+        /// <exception cref="System.ArgumentNullException">onFallbackAsync</exception>
+        /// <returns>The policy instance.</returns>
+        public static FallbackPolicy<TResult> FallbackAsync<TResult>(this PolicyBuilder<TResult> policyBuilder, Func<Context, CancellationToken, Task<TResult>> fallbackAction, Func<DelegateResult<TResult>, Context, Task> onFallbackAsync)
+        {
+            if (fallbackAction == null) throw new ArgumentNullException(nameof(fallbackAction));
+            if (onFallbackAsync == null) throw new ArgumentNullException(nameof(onFallbackAsync));
+
             return new FallbackPolicy<TResult>(
                 (action, context, cancellationToken, continueOnCapturedContext) => FallbackEngine.ImplementationAsync(
                     action,
diff --git a/src/Polly.Shared/Policy.TResult.cs b/src/Polly.Shared/Policy.TResult.cs
index 070d3917..d5f4c291 100644
--- a/src/Polly.Shared/Policy.TResult.cs
+++ b/src/Polly.Shared/Policy.TResult.cs
@@ -7,15 +7,14 @@ using Polly.Utilities;
 
 namespace Polly
 {
-
     /// <summary>
     /// Transient fault handling policies that can be applied to delegates returning results of type <typeparamref name="TResult"/>
     /// </summary>
     public abstract partial class Policy<TResult> : ISyncPolicy<TResult>
     {
         private readonly Func<Func<Context, CancellationToken, TResult>, Context, CancellationToken, TResult> _executionPolicy;
-        private readonly IEnumerable<ExceptionPredicate> _exceptionPredicates;
-        private readonly IEnumerable<ResultPredicate<TResult>> _resultPredicates;
+        internal IEnumerable<ExceptionPredicate> ExceptionPredicates { get; }
+        internal IEnumerable<ResultPredicate<TResult>> ResultPredicates { get; }
 
         internal Policy(
             Func<Func<Context, CancellationToken, TResult>, Context, CancellationToken, TResult> executionPolicy,
@@ -26,8 +25,8 @@ namespace Polly
             if (executionPolicy == null) throw new ArgumentNullException(nameof(executionPolicy));
 
             _executionPolicy = executionPolicy;
-            _exceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
-            _resultPredicates = resultPredicates ?? PredicateHelper<TResult>.EmptyResultPredicates;
+            ExceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
+            ResultPredicates = resultPredicates ?? PredicateHelper<TResult>.EmptyResultPredicates;
         }
 
         #region Execute overloads
@@ -317,7 +316,7 @@ namespace Polly
             {
                 TResult result = Execute(action, context, cancellationToken);
 
-                if (_resultPredicates.Any(predicate => predicate(result)))
+                if (ResultPredicates.Any(predicate => predicate(result)))
                 {
                     return PolicyResult<TResult>.Failure(result, context);
                 }
@@ -326,7 +325,7 @@ namespace Polly
             }
             catch (Exception exception)
             {
-                return PolicyResult<TResult>.Failure(exception, GetExceptionType(_exceptionPredicates, exception), context);
+                return PolicyResult<TResult>.Failure(exception, GetExceptionType(ExceptionPredicates, exception), context);
             }
         }
 
diff --git a/src/Polly.Shared/Policy.cs b/src/Polly.Shared/Policy.cs
index 4522726a..7205c2e4 100644
--- a/src/Polly.Shared/Policy.cs
+++ b/src/Polly.Shared/Policy.cs
@@ -14,7 +14,7 @@ namespace Polly
     public abstract partial class Policy : ISyncPolicy
     {
         private readonly Action<Action<Context, CancellationToken>, Context, CancellationToken> _exceptionPolicy;
-        private readonly IEnumerable<ExceptionPredicate> _exceptionPredicates;
+        internal IEnumerable<ExceptionPredicate> ExceptionPredicates { get; }
 
         internal Policy(
             Action<Action<Context, CancellationToken>, Context, CancellationToken> exceptionPolicy,
@@ -23,7 +23,7 @@ namespace Polly
             if (exceptionPolicy == null) throw new ArgumentNullException(nameof(exceptionPolicy));
 
             _exceptionPolicy = exceptionPolicy;
-            _exceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
+            ExceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
         }
 
         #region Execute overloads
@@ -449,7 +449,7 @@ namespace Polly
             }
             catch (Exception exception)
             {
-                return PolicyResult.Failure(exception, GetExceptionType(_exceptionPredicates, exception), context);
+                return PolicyResult.Failure(exception, GetExceptionType(ExceptionPredicates, exception), context);
             }
         }
 
@@ -596,7 +596,7 @@ namespace Polly
             }
             catch (Exception exception)
             {
-                return PolicyResult<TResult>.Failure(exception, GetExceptionType(_exceptionPredicates, exception), context);
+                return PolicyResult<TResult>.Failure(exception, GetExceptionType(ExceptionPredicates, exception), context);
             }
         }
         #endregion
diff --git a/src/Polly.Shared/PolicyAsync.TResult.cs b/src/Polly.Shared/PolicyAsync.TResult.cs
index 23893e2c..e60643fe 100644
--- a/src/Polly.Shared/PolicyAsync.TResult.cs
+++ b/src/Polly.Shared/PolicyAsync.TResult.cs
@@ -20,8 +20,8 @@ namespace Polly
             if (asyncExecutionPolicy == null) throw new ArgumentNullException(nameof(asyncExecutionPolicy));
 
             _asyncExecutionPolicy = asyncExecutionPolicy;
-            _exceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
-            _resultPredicates = resultPredicates ?? PredicateHelper<TResult>.EmptyResultPredicates;
+            ExceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
+            ResultPredicates = resultPredicates ?? PredicateHelper<TResult>.EmptyResultPredicates;
         }
 
         #region ExecuteAsync overloads
@@ -577,7 +577,7 @@ namespace Polly
             {
                 TResult result = await ExecuteAsync(action, context, cancellationToken, continueOnCapturedContext).ConfigureAwait(continueOnCapturedContext);
 
-                if (_resultPredicates.Any(predicate => predicate(result)))
+                if (ResultPredicates.Any(predicate => predicate(result)))
                 {
                     return PolicyResult<TResult>.Failure(result, context);
                 }
@@ -586,7 +586,7 @@ namespace Polly
             }
             catch (Exception exception)
             {
-                return PolicyResult<TResult>.Failure(exception, GetExceptionType(_exceptionPredicates, exception), context);
+                return PolicyResult<TResult>.Failure(exception, GetExceptionType(ExceptionPredicates, exception), context);
             }
         }
 
diff --git a/src/Polly.Shared/PolicyAsync.cs b/src/Polly.Shared/PolicyAsync.cs
index 87c46fe4..d3e1d3ad 100644
--- a/src/Polly.Shared/PolicyAsync.cs
+++ b/src/Polly.Shared/PolicyAsync.cs
@@ -18,7 +18,7 @@ namespace Polly
             if (asyncExceptionPolicy == null) throw new ArgumentNullException(nameof(asyncExceptionPolicy));
 
             _asyncExceptionPolicy = asyncExceptionPolicy;
-            _exceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
+            ExceptionPredicates = exceptionPredicates ?? PredicateHelper.EmptyExceptionPredicates;
         }
 
 
@@ -832,7 +832,7 @@ namespace Polly
             }
             catch (Exception exception)
             {
-                return PolicyResult.Failure(exception, GetExceptionType(_exceptionPredicates, exception), context);
+                return PolicyResult.Failure(exception, GetExceptionType(ExceptionPredicates, exception), context);
             }
         }
 
@@ -1134,7 +1134,7 @@ namespace Polly
             }
             catch (Exception exception)
             {
-                return PolicyResult<TResult>.Failure(exception, GetExceptionType(_exceptionPredicates, exception), context);
+                return PolicyResult<TResult>.Failure(exception, GetExceptionType(ExceptionPredicates, exception), context);
             }
         }
 
diff --git a/src/Polly.Shared/Wrap/PolicyWrap.cs b/src/Polly.Shared/Wrap/PolicyWrap.cs
index 9dd4b391..e9b5884e 100644
--- a/src/Polly.Shared/Wrap/PolicyWrap.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrap.cs
@@ -1,7 +1,4 @@
 ï»¿using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Text;
 using System.Threading;
 using Polly.Utilities;
 
@@ -12,8 +9,8 @@ namespace Polly.Wrap
     /// </summary>
     public partial class PolicyWrap : Policy, IPolicyWrap
     {
-        internal PolicyWrap(Action<Action<Context, CancellationToken>, Context, CancellationToken> policyAction) 
-            : base(policyAction, PredicateHelper.EmptyExceptionPredicates)
+        internal PolicyWrap(Action<Action<Context, CancellationToken>, Context, CancellationToken> policyAction, Policy outer, Policy inner) 
+            : base(policyAction, outer.ExceptionPredicates)
         {
         }
     }
@@ -24,8 +21,13 @@ namespace Polly.Wrap
     /// <typeparam name="TResult">The return type of delegates which may be executed through the policy.</typeparam>
     public partial class PolicyWrap<TResult> : Policy<TResult>, IPolicyWrap<TResult>
     {
-        internal PolicyWrap(Func<Func<Context, CancellationToken, TResult>, Context, CancellationToken, TResult> policyAction)
-            : base(policyAction, PredicateHelper.EmptyExceptionPredicates, PredicateHelper<TResult>.EmptyResultPredicates)
+        internal PolicyWrap(Func<Func<Context, CancellationToken, TResult>, Context, CancellationToken, TResult> policyAction, Policy outer, IsPolicy inner)
+            : base(policyAction, outer.ExceptionPredicates,  PredicateHelper<TResult>.EmptyResultPredicates)
+        {
+        }
+
+        internal PolicyWrap(Func<Func<Context, CancellationToken, TResult>, Context, CancellationToken, TResult> policyAction, Policy<TResult> outer, IsPolicy inner)
+            : base(policyAction, outer.ExceptionPredicates, outer.ResultPredicates)
         {
         }
     }
diff --git a/src/Polly.Shared/Wrap/PolicyWrapAsync.cs b/src/Polly.Shared/Wrap/PolicyWrapAsync.cs
index 3ff181de..bb794f81 100644
--- a/src/Polly.Shared/Wrap/PolicyWrapAsync.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrapAsync.cs
@@ -7,16 +7,21 @@ namespace Polly.Wrap
 {
     public partial class PolicyWrap : IPolicyWrap
     {
-        internal PolicyWrap(Func<Func<Context, CancellationToken, Task>, Context, CancellationToken, bool, Task> policyAction)
-            : base(policyAction, PredicateHelper.EmptyExceptionPredicates)
+        internal PolicyWrap(Func<Func<Context, CancellationToken, Task>, Context, CancellationToken, bool, Task> policyAction, Policy outer, Policy inner)
+            : base(policyAction, outer.ExceptionPredicates)
         {
         }
     }
 
     public partial class PolicyWrap<TResult> : IPolicyWrap<TResult>
     {
-        internal PolicyWrap(Func<Func<Context, CancellationToken, Task<TResult>>, Context, CancellationToken, bool, Task<TResult>> policyAction)
-            : base(policyAction, PredicateHelper.EmptyExceptionPredicates, PredicateHelper<TResult>.EmptyResultPredicates)
+        internal PolicyWrap(Func<Func<Context, CancellationToken, Task<TResult>>, Context, CancellationToken, bool, Task<TResult>> policyAction, Policy outer, IsPolicy inner)
+            : base(policyAction, outer.ExceptionPredicates, PredicateHelper<TResult>.EmptyResultPredicates)
+        {
+        }
+
+        internal PolicyWrap(Func<Func<Context, CancellationToken, Task<TResult>>, Context, CancellationToken, bool, Task<TResult>> policyAction, Policy<TResult> outer, IsPolicy inner)
+            : base(policyAction, outer.ExceptionPredicates, outer.ResultPredicates)
         {
         }
     }
diff --git a/src/Polly.Shared/Wrap/PolicyWrapSyntax.cs b/src/Polly.Shared/Wrap/PolicyWrapSyntax.cs
index 7274b57e..acfb6969 100644
--- a/src/Polly.Shared/Wrap/PolicyWrapSyntax.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrapSyntax.cs
@@ -17,7 +17,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap(
-                (action, context, cancellationtoken) => PolicyWrapEngine.Implementation(action, context, cancellationtoken, this, innerPolicy)
+                (action, context, cancellationtoken) => PolicyWrapEngine.Implementation(action, context, cancellationtoken, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
 
@@ -32,7 +34,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap<TResult>(
-                (func, context, cancellationtoken) => PolicyWrapEngine.Implementation<TResult>(func, context, cancellationtoken, this, innerPolicy)
+                (func, context, cancellationtoken) => PolicyWrapEngine.Implementation<TResult>(func, context, cancellationtoken, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
     }
@@ -49,7 +53,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap<TResult>(
-                (func, context, cancellationtoken) => PolicyWrapEngine.Implementation<TResult>(func, context, cancellationtoken, this, innerPolicy)
+                (func, context, cancellationtoken) => PolicyWrapEngine.Implementation<TResult>(func, context, cancellationtoken, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
 
@@ -63,7 +69,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap<TResult>(
-                (func, context, cancellationtoken) => PolicyWrapEngine.Implementation<TResult>(func, context, cancellationtoken, this, innerPolicy)
+                (func, context, cancellationtoken) => PolicyWrapEngine.Implementation<TResult>(func, context, cancellationtoken, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
     }
diff --git a/src/Polly.Shared/Wrap/PolicyWrapSyntaxAsync.cs b/src/Polly.Shared/Wrap/PolicyWrapSyntaxAsync.cs
index 21590180..8f1cfc32 100644
--- a/src/Polly.Shared/Wrap/PolicyWrapSyntaxAsync.cs
+++ b/src/Polly.Shared/Wrap/PolicyWrapSyntaxAsync.cs
@@ -17,7 +17,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap(
-                (action, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync(action, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy)
+                (action, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync(action, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
 
@@ -32,7 +34,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap<TResult>(
-                (func, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync<TResult>(func, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy)
+                (func, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync<TResult>(func, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
     }
@@ -49,7 +53,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap<TResult>(
-                (func, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync<TResult>(func, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy)
+                (func, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync<TResult>(func, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
 
@@ -63,7 +69,9 @@ namespace Polly
             if (innerPolicy == null) throw new ArgumentNullException(nameof(innerPolicy));
 
             return new PolicyWrap<TResult>(
-                (func, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync<TResult>(func, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy)
+                (func, context, cancellationtoken, continueOnCapturedContext) => PolicyWrapEngine.ImplementationAsync<TResult>(func, context, cancellationtoken, continueOnCapturedContext, this, innerPolicy),
+                this,
+                innerPolicy
                 );
         }
     }
diff --git a/src/Polly.SharedSpecs/Fallback/FallbackAsyncSpecs.cs b/src/Polly.SharedSpecs/Fallback/FallbackAsyncSpecs.cs
index b3121fa0..f9f6dab0 100644
--- a/src/Polly.SharedSpecs/Fallback/FallbackAsyncSpecs.cs
+++ b/src/Polly.SharedSpecs/Fallback/FallbackAsyncSpecs.cs
@@ -46,7 +46,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_fallback_func_is_null_with_onFallback_with_context()
         {
-            Func<CancellationToken, Task> fallbackActionAsync  = null;
+            Func<Context, CancellationToken, Task> fallbackActionAsync  = null;
             Func<Exception, Context, Task> onFallbackAsync = (_, __) => TaskHelper.EmptyTask;
 
             Action policy = () => Policy
@@ -74,7 +74,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_onFallback_delegate_is_null_with_context()
         {
-            Func<CancellationToken, Task> fallbackActionAsync  = ct => TaskHelper.EmptyTask;
+            Func<Context, CancellationToken, Task> fallbackActionAsync  = (_, __) => TaskHelper.EmptyTask;
             Func<Exception, Context, Task> onFallbackAsync = null;
 
             Action policy = () => Policy
@@ -300,7 +300,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_the_passed_context()
         {
-            Func<CancellationToken, Task> fallbackActionAsync = _ => TaskHelper.EmptyTask;
+            Func<Context, CancellationToken, Task> fallbackActionAsync = (_, __) => TaskHelper.EmptyTask;
 
             IDictionary<string, object> contextData = null;
 
@@ -322,7 +322,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_the_passed_context_when_execute_and_capture()
         {
-            Func<CancellationToken, Task> fallbackActionAsync = _ => TaskHelper.EmptyTask;
+            Func<Context, CancellationToken, Task> fallbackActionAsync = (_, __) => TaskHelper.EmptyTask;
 
             IDictionary<string, object> contextData = null;
 
@@ -344,7 +344,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_independent_context_for_independent_calls()
         {
-            Func<CancellationToken, Task> fallbackActionAsync = _ => TaskHelper.EmptyTask;
+            Func<Context, CancellationToken, Task> fallbackActionAsync = (_, __) => TaskHelper.EmptyTask;
 
             IDictionary<Type, object> contextData = new Dictionary<Type, object>();
 
@@ -377,10 +377,9 @@ namespace Polly.Specs.Fallback
             Context capturedContext = null;
             bool onFallbackExecuted = false;
 
-            Func<CancellationToken, Task> fallbackActionAsync = _ => TaskHelper.EmptyTask;
+            Func<Context, CancellationToken, Task> fallbackActionAsync = (_, __) => TaskHelper.EmptyTask;
             Func<Exception, Context, Task> onFallbackAsync = (ex, ctx) => { onFallbackExecuted = true; capturedContext = ctx; return TaskHelper.EmptyTask; };
 
-
             FallbackPolicy fallbackPolicy = Policy
                 .Handle<ArgumentNullException>()
                 .Or<DivideByZeroException>()
@@ -392,6 +391,71 @@ namespace Polly.Specs.Fallback
             capturedContext.Should().BeEmpty();
         }
 
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Func<Context, CancellationToken, Task> fallbackActionAsync = (ctx, ct) => { contextData = ctx; return TaskHelper.EmptyTask; };
+
+            Func<Exception, Context, Task> onFallbackAsync = (ex, ctx) => TaskHelper.EmptyTask;
+
+            FallbackPolicy fallbackPolicy = Policy
+                .Handle<ArgumentNullException>()
+                .FallbackAsync(fallbackActionAsync, onFallbackAsync);
+
+            fallbackPolicy.Awaiting(async p => await p.ExecuteAsync(() => { throw new ArgumentNullException(); },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary()))
+                .ShouldNotThrow();
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context_when_execute_and_capture()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Func<Context, CancellationToken, Task> fallbackActionAsync = (ctx, ct) => { contextData = ctx; return TaskHelper.EmptyTask; };
+
+            Func<Exception, Context, Task> onFallbackAsync = (ex, ctx) => TaskHelper.EmptyTask;
+
+            FallbackPolicy fallbackPolicy = Policy
+                .Handle<ArgumentNullException>()
+                .FallbackAsync(fallbackActionAsync, onFallbackAsync);
+
+            fallbackPolicy.Awaiting(async p => await p.ExecuteAndCaptureAsync(() => { throw new ArgumentNullException(); },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary()))
+                .ShouldNotThrow();
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Context_should_be_empty_at_fallbackAction_if_execute_not_called_with_any_context_data()
+        {
+            Context capturedContext = null;
+            bool fallbackExecuted = false;
+
+            Func<Context, CancellationToken, Task> fallbackActionAsync = (ctx, ct) => { fallbackExecuted = true; capturedContext = ctx; return TaskHelper.EmptyTask; };
+
+            Func<Exception, Context, Task> onFallbackAsync = (ex, ctx) => TaskHelper.EmptyTask;
+
+            FallbackPolicy fallbackPolicy = Policy
+                .Handle<ArgumentNullException>()
+                .Or<DivideByZeroException>()
+                .FallbackAsync(fallbackActionAsync, onFallbackAsync);
+
+            fallbackPolicy.RaiseExceptionAsync<DivideByZeroException>();
+
+            fallbackExecuted.Should().BeTrue();
+            capturedContext.Should().BeEmpty();
+        }
+
         #endregion
 
         #region Cancellation tests
diff --git a/src/Polly.SharedSpecs/Fallback/FallbackSpecs.cs b/src/Polly.SharedSpecs/Fallback/FallbackSpecs.cs
index a7925062..cbc9e3c8 100644
--- a/src/Polly.SharedSpecs/Fallback/FallbackSpecs.cs
+++ b/src/Polly.SharedSpecs/Fallback/FallbackSpecs.cs
@@ -71,7 +71,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_fallback_action_is_null_with_onFallback_with_context()
         {
-            Action fallbackAction = null;
+            Action<Context> fallbackAction = null;
             Action<Exception, Context> onFallback = (_, __) => { };
 
             Action policy = () => Policy
@@ -85,7 +85,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_fallback_action_with_cancellation_is_null_with_onFallback_with_context()
         {
-            Action<CancellationToken> fallbackAction = null;
+            Action<Context, CancellationToken> fallbackAction = null;
             Action<Exception, Context> onFallback = (_, __) => { };
 
             Action policy = () => Policy
@@ -127,7 +127,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_onFallback_delegate_is_null_with_context()
         {
-            Action fallbackAction = () => { };
+            Action<Context> fallbackAction = _ => { };
             Action<Exception, Context> onFallback = null;
 
             Action policy = () => Policy
@@ -141,7 +141,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_onFallback_delegate_is_null_with_context_with_action_with_cancellation()
         {
-            Action<CancellationToken> fallbackAction = ct => { };
+            Action<Context, CancellationToken> fallbackAction = (_, __) => { };
             Action<Exception, Context> onFallback = null;
 
             Action policy = () => Policy
@@ -367,7 +367,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_the_passed_context()
         {
-            Action fallbackAction = () => { };
+            Action<Context> fallbackAction = _ => { };
 
             IDictionary<string, object> contextData = null;
 
@@ -389,7 +389,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_the_passed_context_when_execute_and_capture()
         {
-            Action fallbackAction = () => { };
+            Action<Context> fallbackAction = _ => { };
 
             IDictionary<string, object> contextData = null;
 
@@ -411,7 +411,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_independent_context_for_independent_calls()
         {
-            Action fallbackAction = () => { };
+            Action<Context> fallbackAction = _ => { };
 
             IDictionary<Type, object> contextData = new Dictionary<Type, object>();
 
@@ -444,7 +444,7 @@ namespace Polly.Specs.Fallback
             Context capturedContext = null;
             bool onFallbackExecuted = false;
 
-            Action fallbackAction = () => { };
+            Action<Context> fallbackAction = _ => { };
             Action<Exception, Context> onFallback = (ex, ctx) => { onFallbackExecuted = true; capturedContext = ctx; };
 
             FallbackPolicy fallbackPolicy = Policy
@@ -458,6 +458,70 @@ namespace Polly.Specs.Fallback
             capturedContext.Should().BeEmpty();
         }
 
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Action<Context, CancellationToken> fallbackAction = (ctx, ct) => { contextData = ctx;};
+
+            Action<Exception, Context> onFallback = (ex, ctx) => {  };
+
+            FallbackPolicy fallbackPolicy = Policy
+                .Handle<ArgumentNullException>()
+                .Fallback(fallbackAction, onFallback);
+
+            fallbackPolicy.Invoking(p => p.Execute(() => { throw new ArgumentNullException(); },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary()))
+                .ShouldNotThrow();
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context_when_execute_and_capture()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Action<Context, CancellationToken> fallbackAction = (ctx, ct) => { contextData = ctx; };
+
+            Action<Exception, Context> onFallback = (ex, ctx) => { };
+
+            FallbackPolicy fallbackPolicy = Policy
+                .Handle<ArgumentNullException>()
+                .Fallback(fallbackAction, onFallback);
+
+            fallbackPolicy.Invoking(p => p.ExecuteAndCapture(() => { throw new ArgumentNullException(); },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary()))
+                .ShouldNotThrow();
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Context_should_be_empty_at_fallbackAction_if_execute_not_called_with_any_context_data()
+        {
+            Context capturedContext = null;
+            bool fallbackExecuted = false;
+
+            Action<Context, CancellationToken> fallbackAction = (ctx, ct) => { fallbackExecuted = true; capturedContext = ctx;  };
+            Action<Exception, Context> onFallback = (ex, ctx) => {};
+
+            FallbackPolicy fallbackPolicy = Policy
+                .Handle<ArgumentNullException>()
+                .Or<DivideByZeroException>()
+                .Fallback(fallbackAction, onFallback);
+
+            fallbackPolicy.RaiseException<DivideByZeroException>();
+
+            fallbackExecuted.Should().BeTrue();
+            capturedContext.Should().BeEmpty();
+        }
+
         #endregion
 
 
diff --git a/src/Polly.SharedSpecs/Fallback/FallbackTResultAsyncSpecs.cs b/src/Polly.SharedSpecs/Fallback/FallbackTResultAsyncSpecs.cs
index 3c4a14c7..64bd0a17 100644
--- a/src/Polly.SharedSpecs/Fallback/FallbackTResultAsyncSpecs.cs
+++ b/src/Polly.SharedSpecs/Fallback/FallbackTResultAsyncSpecs.cs
@@ -46,7 +46,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_fallback_action_is_null_with_onFallback_with_context()
         {
-            Func<CancellationToken, Task<ResultPrimitive>> fallbackAction = null;
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackAction = null;
             Func<DelegateResult<ResultPrimitive>, Context, Task> onFallbackAsync = (_, __) => TaskHelper.EmptyTask;
 
             Action policy = () => Policy
@@ -88,7 +88,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_onFallback_delegate_is_null_with_context()
         {
-                        Func<CancellationToken, Task<ResultPrimitive>> fallbackAction = ct => Task.FromResult(ResultPrimitive.Substitute);
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackAction = (_, __) => Task.FromResult(ResultPrimitive.Substitute);
             Func<DelegateResult<ResultPrimitive>, Context, Task> onFallbackAsync = null;
 
             Action policy = () => Policy
@@ -102,7 +102,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_onFallback_delegate_is_null_with_context_with_action_with_cancellation()
         {
-            Func<CancellationToken, Task<ResultPrimitive>> fallbackAction = ct => Task.FromResult(ResultPrimitive.Substitute);
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackAction = (_, __) => Task.FromResult(ResultPrimitive.Substitute);
             Func<DelegateResult<ResultPrimitive>, Context, Task> onFallbackAsync = null;
 
             Action policy = () => Policy
@@ -345,7 +345,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_the_passed_context()
         {
-                        Func<CancellationToken, Task<ResultPrimitive>> fallbackAction = ct => Task.FromResult(ResultPrimitive.Substitute);
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackAction = (_, __) => Task.FromResult(ResultPrimitive.Substitute);
 
             IDictionary<string, object> contextData = null;
 
@@ -368,7 +368,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public async void Should_call_onFallback_with_the_passed_context_when_execute_and_capture()
         {
-                        Func<CancellationToken, Task<ResultPrimitive>> fallbackAction = ct => Task.FromResult(ResultPrimitive.Substitute);
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackAction = (_, __) => Task.FromResult(ResultPrimitive.Substitute);
 
             IDictionary<string, object> contextData = null;
 
@@ -390,7 +390,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_independent_context_for_independent_calls()
         {
-                        Func<CancellationToken, Task<ResultPrimitive>> fallbackAction = ct => Task.FromResult(ResultPrimitive.Substitute);
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackAction = (_, __) => Task.FromResult(ResultPrimitive.Substitute);
 
             IDictionary<ResultPrimitive, object> contextData = new Dictionary<ResultPrimitive, object>();
 
@@ -422,7 +422,7 @@ namespace Polly.Specs.Fallback
             Context capturedContext = null;
             bool onFallbackExecuted = false;
 
-                        Func<CancellationToken, Task<ResultPrimitive>> fallbackAction = ct => Task.FromResult(ResultPrimitive.Substitute);
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackAction = (_, __) => Task.FromResult(ResultPrimitive.Substitute);
             Func<DelegateResult<ResultPrimitive>, Context, Task> onFallbackAsync = (ex, ctx) => { onFallbackExecuted = true; capturedContext = ctx; return TaskHelper.EmptyTask; };
 
             FallbackPolicy<ResultPrimitive> fallbackPolicy = Policy
@@ -437,6 +437,73 @@ namespace Polly.Specs.Fallback
             capturedContext.Should().BeEmpty();
         }
 
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackActionAsync = (ctx, ct) => { contextData = ctx; return Task.FromResult(ResultPrimitive.Substitute); };
+
+            Func<DelegateResult<ResultPrimitive>, Context, Task> onFallbackAsync = (dr, ctx) => TaskHelper.EmptyTask;
+
+            FallbackPolicy<ResultPrimitive> fallbackPolicy = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .FallbackAsync(fallbackActionAsync, onFallbackAsync);
+
+            fallbackPolicy.ExecuteAsync(() => { return Task.FromResult(ResultPrimitive.Fault); },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary())
+                .Result
+                .Should().Be(ResultPrimitive.Substitute);
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context_when_execute_and_capture()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackActionAsync = (ctx, ct) => { contextData = ctx; return Task.FromResult(ResultPrimitive.Substitute); };
+
+            Func<Exception, Context, Task> onFallbackAsync = (ex, ctx) => TaskHelper.EmptyTask;
+
+            FallbackPolicy fallbackPolicy = Policy
+                .Handle<ArgumentNullException>()
+                .FallbackAsync(fallbackActionAsync, onFallbackAsync);
+
+            fallbackPolicy.Awaiting(async p => await p.ExecuteAndCaptureAsync(() => { throw new ArgumentNullException(); },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary()))
+                .ShouldNotThrow();
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public async void Context_should_be_empty_at_fallbackAction_if_execute_not_called_with_any_context_data()
+        {
+            Context capturedContext = null;
+            bool fallbackExecuted = false;
+
+            Func<Context, CancellationToken, Task<ResultPrimitive>> fallbackActionAsync = (ctx, ct) => { fallbackExecuted = true; capturedContext = ctx; return Task.FromResult(ResultPrimitive.Substitute);
+            };
+            Func<DelegateResult<ResultPrimitive>, Context, Task> onFallbackAsync = (ex, ctx) => TaskHelper.EmptyTask;
+
+            FallbackPolicy<ResultPrimitive> fallbackPolicy = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .OrResult(ResultPrimitive.FaultAgain)
+                .FallbackAsync(fallbackActionAsync, onFallbackAsync);
+
+            (await fallbackPolicy.RaiseResultSequenceAsync(ResultPrimitive.Fault).ConfigureAwait(false))
+                .Should().Be(ResultPrimitive.Substitute);
+
+
+            fallbackExecuted.Should().BeTrue();
+            capturedContext.Should().BeEmpty();
+        }
         #endregion
 
         #region Cancellation tests
diff --git a/src/Polly.SharedSpecs/Fallback/FallbackTResultSpecs.cs b/src/Polly.SharedSpecs/Fallback/FallbackTResultSpecs.cs
index 9b04a493..abdc6350 100644
--- a/src/Polly.SharedSpecs/Fallback/FallbackTResultSpecs.cs
+++ b/src/Polly.SharedSpecs/Fallback/FallbackTResultSpecs.cs
@@ -71,7 +71,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_fallback_action_is_null_with_onFallback_with_context()
         {
-            Func<ResultPrimitive> fallbackAction = null;
+            Func<Context, ResultPrimitive> fallbackAction = null;
             Action<DelegateResult<ResultPrimitive>, Context> onFallback = (_, __) => { };
 
             Action policy = () => Policy
@@ -85,7 +85,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_fallback_action_with_cancellation_is_null_with_onFallback_with_context()
         {
-            Func<CancellationToken, ResultPrimitive> fallbackAction = null;
+            Func<Context, CancellationToken, ResultPrimitive> fallbackAction = null;
             Action<DelegateResult<ResultPrimitive>, Context> onFallback = (_, __) => { };
 
             Action policy = () => Policy
@@ -127,7 +127,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_onFallback_delegate_is_null_with_context()
         {
-            Func<ResultPrimitive> fallbackAction = () => ResultPrimitive.Substitute;
+            Func<Context, ResultPrimitive> fallbackAction = _ => ResultPrimitive.Substitute;
             Action<DelegateResult<ResultPrimitive>, Context> onFallback = null;
 
             Action policy = () => Policy
@@ -141,7 +141,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_throw_when_onFallback_delegate_is_null_with_context_with_action_with_cancellation()
         {
-            Func<CancellationToken, ResultPrimitive> fallbackAction = ct => ResultPrimitive.Substitute;
+            Func<Context, CancellationToken, ResultPrimitive> fallbackAction = (_, __) => ResultPrimitive.Substitute;
             Action<DelegateResult<ResultPrimitive>, Context> onFallback = null;
 
             Action policy = () => Policy
@@ -375,7 +375,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_the_passed_context()
         {
-            Func<ResultPrimitive> fallbackAction = () => ResultPrimitive.Substitute;
+            Func<Context, ResultPrimitive> fallbackAction = _ => ResultPrimitive.Substitute;
 
             IDictionary<string, object> contextData = null;
 
@@ -397,7 +397,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_the_passed_context_when_execute_and_capture()
         {
-            Func<ResultPrimitive> fallbackAction = () => ResultPrimitive.Substitute;
+            Func<Context, ResultPrimitive> fallbackAction = _ => ResultPrimitive.Substitute;
 
             IDictionary<string, object> contextData = null;
 
@@ -419,7 +419,7 @@ namespace Polly.Specs.Fallback
         [Fact]
         public void Should_call_onFallback_with_independent_context_for_independent_calls()
         {
-            Func<ResultPrimitive> fallbackAction = () => ResultPrimitive.Substitute;
+            Func<Context, ResultPrimitive> fallbackAction = _ => ResultPrimitive.Substitute;
 
             IDictionary<ResultPrimitive, object> contextData = new Dictionary<ResultPrimitive, object>();
 
@@ -449,7 +449,7 @@ namespace Polly.Specs.Fallback
             Context capturedContext = null;
             bool onFallbackExecuted = false;
 
-            Func<ResultPrimitive> fallbackAction = () => ResultPrimitive.Substitute;
+            Func<Context, ResultPrimitive> fallbackAction = _ => ResultPrimitive.Substitute;
             Action<DelegateResult<ResultPrimitive>, Context> onFallback = (ex, ctx) => { onFallbackExecuted = true; capturedContext = ctx; };
 
             FallbackPolicy<ResultPrimitive> fallbackPolicy = Policy
@@ -463,6 +463,70 @@ namespace Polly.Specs.Fallback
             capturedContext.Should().BeEmpty();
         }
 
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Func<Context, CancellationToken, ResultPrimitive> fallbackAction = (ctx, ct) => { contextData = ctx; return ResultPrimitive.Substitute; };
+
+            Action<DelegateResult<ResultPrimitive>, Context> onFallback = (ex, ctx) => { };
+
+            FallbackPolicy<ResultPrimitive> fallbackPolicy = Policy<ResultPrimitive>
+                .HandleResult(ResultPrimitive.Fault)
+                .Fallback(fallbackAction, onFallback);
+
+            fallbackPolicy.Execute(() => { return ResultPrimitive.Fault; },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary())
+                .Should().Be(ResultPrimitive.Substitute);
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Should_call_fallbackAction_with_the_passed_context_when_execute_and_capture()
+        {
+            IDictionary<string, object> contextData = null;
+
+            Func<Context, CancellationToken, ResultPrimitive> fallbackAction = (ctx, ct) => { contextData = ctx; return ResultPrimitive.Substitute; };
+
+            Action<DelegateResult<ResultPrimitive>, Context> onFallback = (ex, ctx) => { };
+
+            FallbackPolicy<ResultPrimitive> fallbackPolicy = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .Fallback(fallbackAction, onFallback);
+
+            fallbackPolicy.ExecuteAndCapture(() => { return ResultPrimitive.Fault; },
+                    new { key1 = "value1", key2 = "value2" }.AsDictionary())
+                .Result.Should().Be(ResultPrimitive.Substitute);
+
+            contextData.Should()
+                .ContainKeys("key1", "key2").And
+                .ContainValues("value1", "value2");
+        }
+
+        [Fact]
+        public void Context_should_be_empty_at_fallbackAction_if_execute_not_called_with_any_context_data()
+        {
+            Context capturedContext = null;
+            bool fallbackExecuted = false;
+
+            Func<Context, CancellationToken, ResultPrimitive> fallbackAction = (ctx, ct) => { fallbackExecuted = true; capturedContext = ctx; return ResultPrimitive.Substitute; };
+
+            Action<DelegateResult<ResultPrimitive>, Context> onFallback = (ex, ctx) => {  };
+
+            FallbackPolicy<ResultPrimitive> fallbackPolicy = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .OrResult(ResultPrimitive.FaultAgain)
+                .Fallback(fallbackAction, onFallback);
+
+            fallbackPolicy.RaiseResultSequence(ResultPrimitive.Fault);
+
+            fallbackExecuted.Should().BeTrue();
+            capturedContext.Should().BeEmpty();
+        }
         #endregion
 
         #region Cancellation tests
diff --git a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs
index 13cfda9b..a45f6b16 100644
--- a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs
+++ b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecs.cs
@@ -236,5 +236,123 @@ namespace Polly.Specs.Wrap
         }
 
         #endregion
+
+        #region ExecuteAndCaptureSpecs
+
+        [Fact]
+        public void Outermost_policy_handling_exception_should_report_as_PolicyWrap_handled_exception()
+        {
+            CircuitBreakerPolicy innerHandlingDBZE = Policy
+                .Handle<DivideByZeroException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            CircuitBreakerPolicy outerHandlingANE = Policy
+                .Handle<ArgumentNullException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            PolicyWrap wrap = outerHandlingANE.Wrap(innerHandlingDBZE);
+
+            PolicyResult executeAndCaptureResultOnPolicyWrap = wrap.ExecuteAndCapture(() => { throw new ArgumentNullException(); });
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<ArgumentNullException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.HandledByThisPolicy);
+        }
+
+        [Fact]
+        public void Outermost_policy_not_handling_exception_even_if_inner_policies_do_should_report_as_unhandled_exception()
+        {
+            CircuitBreakerPolicy innerHandlingDBZE = Policy
+                .Handle<DivideByZeroException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            CircuitBreakerPolicy outerHandlingANE = Policy
+                .Handle<ArgumentNullException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            PolicyWrap wrap = outerHandlingANE.Wrap(innerHandlingDBZE);
+
+            PolicyResult executeAndCaptureResultOnPolicyWrap = wrap.ExecuteAndCapture(() => { throw new DivideByZeroException(); });
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<DivideByZeroException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.Unhandled);
+        }
+
+        [Fact]
+        public void Outermost_generic_policy_handling_exception_should_report_as_PolicyWrap_handled_exception()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingDBZE = Policy<ResultPrimitive>
+                .Handle<DivideByZeroException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            CircuitBreakerPolicy outerHandlingANE = Policy
+                .Handle<ArgumentNullException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingANE.Wrap(innerHandlingDBZE);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = wrap.ExecuteAndCapture(() => { throw new ArgumentNullException(); });
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<ArgumentNullException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.HandledByThisPolicy);
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().Be(FaultType.ExceptionHandledByThisPolicy);
+        }
+
+        [Fact]
+        public void Outermost_generic_policy_not_handling_exception_even_if_inner_policies_do_should_report_as_unhandled_exception()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingDBZE = Policy<ResultPrimitive>
+                .Handle<DivideByZeroException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            CircuitBreakerPolicy outerHandlingANE = Policy
+                .Handle<ArgumentNullException>()
+                .CircuitBreaker(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingANE.Wrap(innerHandlingDBZE);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = wrap.ExecuteAndCapture(() => { throw new DivideByZeroException(); });
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<DivideByZeroException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.Unhandled);
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().Be(FaultType.UnhandledException);
+        }
+
+        [Fact]
+        public void Outermost_generic_policy_handling_result_should_report_as_PolicyWrap_handled_result()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingFaultAgain = Policy
+                .HandleResult(ResultPrimitive.FaultAgain)
+                .CircuitBreaker(1, TimeSpan.Zero);
+            CircuitBreakerPolicy<ResultPrimitive> outerHandlingFault = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .CircuitBreaker(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingFault.Wrap(innerHandlingFaultAgain);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = wrap.ExecuteAndCapture(() => ResultPrimitive.Fault);
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().Be(FaultType.ResultHandledByThisPolicy);
+            executeAndCaptureResultOnPolicyWrap.FinalHandledResult.Should().Be(ResultPrimitive.Fault);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeNull();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().BeNull();
+        }
+
+        [Fact]
+        public void Outermost_generic_policy_not_handling_result_even_if_inner_policies_do_should_not_report_as_handled()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingFaultAgain = Policy
+                .HandleResult(ResultPrimitive.FaultAgain)
+                .CircuitBreaker(1, TimeSpan.Zero);
+            CircuitBreakerPolicy<ResultPrimitive> outerHandlingFault = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .CircuitBreaker(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingFault.Wrap(innerHandlingFaultAgain);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = wrap.ExecuteAndCapture(() => ResultPrimitive.FaultAgain);
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Successful);
+            executeAndCaptureResultOnPolicyWrap.FinalHandledResult.Should().Be(default(ResultPrimitive));
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().BeNull();
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeNull();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().BeNull();
+        }
+
+        #endregion
     }
 }
diff --git a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs
index b76e0b19..982a858d 100644
--- a/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs
+++ b/src/Polly.SharedSpecs/Wrap/PolicyWrapSpecsAsync.cs
@@ -3,6 +3,7 @@ using FluentAssertions;
 using Polly.CircuitBreaker;
 using Polly.Retry;
 using Polly.Specs.Helpers;
+using Polly.Utilities;
 using Polly.Wrap;
 using Xunit;
 
@@ -236,5 +237,126 @@ namespace Polly.Specs.Wrap
         }
 
         #endregion
+
+        #region ExecuteAndCaptureAsyncSpecs
+
+        [Fact]
+        public async void Outermost_policy_handling_exception_should_report_as_PolicyWrap_handled_exception()
+        {
+            CircuitBreakerPolicy innerHandlingDBZE = Policy
+                .Handle<DivideByZeroException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            CircuitBreakerPolicy outerHandlingANE = Policy
+                .Handle<ArgumentNullException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
+
+            PolicyResult executeAndCaptureResultOnPolicyWrap =
+                await wrap.ExecuteAndCaptureAsync(() => { throw new ArgumentNullException(); });
+
+        executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<ArgumentNullException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.HandledByThisPolicy);
+        }
+
+        [Fact]
+        public async void Outermost_policy_not_handling_exception_even_if_inner_policies_do_should_report_as_unhandled_exception()
+        {
+            CircuitBreakerPolicy innerHandlingDBZE = Policy
+                .Handle<DivideByZeroException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            CircuitBreakerPolicy outerHandlingANE = Policy
+                .Handle<ArgumentNullException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            PolicyWrap wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
+
+            PolicyResult executeAndCaptureResultOnPolicyWrap =
+                await wrap.ExecuteAndCaptureAsync(() => { throw new DivideByZeroException(); });
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<DivideByZeroException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.Unhandled);
+        }
+
+        [Fact]
+        public async void Outermost_generic_policy_handling_exception_should_report_as_PolicyWrap_handled_exception()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingDBZE = Policy<ResultPrimitive>
+                .Handle<DivideByZeroException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            CircuitBreakerPolicy<ResultPrimitive> outerHandlingANE = Policy<ResultPrimitive>
+                .Handle<ArgumentNullException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = await  wrap.ExecuteAndCaptureAsync(() => { throw new ArgumentNullException(); });
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<ArgumentNullException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.HandledByThisPolicy);
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().Be(FaultType.ExceptionHandledByThisPolicy);
+        }
+
+        [Fact]
+        public async void Outermost_generic_policy_not_handling_exception_even_if_inner_policies_do_should_report_as_unhandled_exception()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingDBZE = Policy<ResultPrimitive>
+                .Handle<DivideByZeroException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            CircuitBreakerPolicy<ResultPrimitive> outerHandlingANE = Policy<ResultPrimitive>
+                .Handle<ArgumentNullException>()
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingANE.WrapAsync(innerHandlingDBZE);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = await wrap.ExecuteAndCaptureAsync(() => { throw new DivideByZeroException(); });
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeOfType<DivideByZeroException>();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().Be(ExceptionType.Unhandled);
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().Be(FaultType.UnhandledException);
+        }
+
+        [Fact]
+        public async void Outermost_generic_policy_handling_result_should_report_as_PolicyWrap_handled_result()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingFaultAgain = Policy
+                .HandleResult(ResultPrimitive.FaultAgain)
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            CircuitBreakerPolicy<ResultPrimitive> outerHandlingFault = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = await wrap.ExecuteAndCaptureAsync(() => TaskHelper.FromResult(ResultPrimitive.Fault));
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Failure);
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().Be(FaultType.ResultHandledByThisPolicy);
+            executeAndCaptureResultOnPolicyWrap.FinalHandledResult.Should().Be(ResultPrimitive.Fault);
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeNull();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().BeNull();
+        }
+
+        [Fact]
+        public async void Outermost_generic_policy_not_handling_result_even_if_inner_policies_do_should_not_report_as_handled()
+        {
+            CircuitBreakerPolicy<ResultPrimitive> innerHandlingFaultAgain = Policy
+                .HandleResult(ResultPrimitive.FaultAgain)
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            CircuitBreakerPolicy<ResultPrimitive> outerHandlingFault = Policy
+                .HandleResult(ResultPrimitive.Fault)
+                .CircuitBreakerAsync(1, TimeSpan.Zero);
+            PolicyWrap<ResultPrimitive> wrap = outerHandlingFault.WrapAsync(innerHandlingFaultAgain);
+
+            PolicyResult<ResultPrimitive> executeAndCaptureResultOnPolicyWrap = await wrap.ExecuteAndCaptureAsync(() => TaskHelper.FromResult(ResultPrimitive.FaultAgain));
+
+            executeAndCaptureResultOnPolicyWrap.Outcome.Should().Be(OutcomeType.Successful);
+            executeAndCaptureResultOnPolicyWrap.FinalHandledResult.Should().Be(default(ResultPrimitive));
+            executeAndCaptureResultOnPolicyWrap.FaultType.Should().BeNull();
+            executeAndCaptureResultOnPolicyWrap.FinalException.Should().BeNull();
+            executeAndCaptureResultOnPolicyWrap.ExceptionType.Should().BeNull();
+        }
+
+        #endregion
+
     }
 }
