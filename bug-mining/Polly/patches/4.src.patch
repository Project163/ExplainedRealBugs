diff --git a/CHANGELOG.md b/CHANGELOG.md
index b82742e0..175477e4 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,49 +1,49 @@
-2.2.5
-=
-----------
-- Policies with a retry count of zero are now allowed - Thanks to [@nelsonghezzi](https://github.com/nelsonghezzi)
-
-2.2.4
-=
-----------
-- Add .NET Core support
-
-2.2.3
-=
-----------
-- Fix PCL implementation of `SystemClock.Reset`
-- Added ability to capture the results of executing a policy via `ExecuteAndCapture` - Thanks to [@ThomasMentzel](https://github.com/ThomasMentzel)
-
-2.2.2
-=
-----------
-- Added extra `NotOnCapturedContext` call to prevent potential deadlocks when blocking on asynchronous calls - Thanks to [Hacko](https://github.com/hacko-bede)
-
-2.2.1
-=
-----------
-- Replaced non-blocking sleep implementation with a blocking one for PCL
-       
-2.2.0
-=
-----------
-- Added Async Support (PCL)
-- PCL Profile updated from Profile78 ->  Profile 259
-- Added missing WaitAndRetryAsync overload
-
-2.1.0
-=
-----------
-- Added Async Support (.NET Framework 4.5 Only) - Massive thanks to  [@mauricedb](https://github.com/mauricedb) for the implementation
-
-2.0.0
-=
-----------
-- Added Portable Class Library ([Issue #4](https://github.com/michael-wolfenden/Polly/issues/4)) - Thanks to  [@ghuntley](https://github.com/ghuntley) for the implementation
-- The `Polly` NuGet package is now no longer strongly named. The strongly named NuGet package is now `Polly-Signed` ([Issue #5](https://github.com/michael-wolfenden/Polly/issues/5)) 
-
-1.1.0
-=
-----------
-- Added additional overloads to Retry
-- Allow arbitrary data to be passed to policy execution ([Issue #1](https://github.com/michael-wolfenden/Polly/issues/1)) 
+2.2.5
+=
+----------
+- Policies with a retry count of zero are now allowed - Thanks to [@nelsonghezzi](https://github.com/nelsonghezzi)
+
+2.2.4
+=
+----------
+- Add .NET Core support
+
+2.2.3
+=
+----------
+- Fix PCL implementation of `SystemClock.Reset`
+- Added ability to capture the results of executing a policy via `ExecuteAndCapture` - Thanks to [@ThomasMentzel](https://github.com/ThomasMentzel)
+
+2.2.2
+=
+----------
+- Added extra `NotOnCapturedContext` call to prevent potential deadlocks when blocking on asynchronous calls - Thanks to [Hacko](https://github.com/hacko-bede)
+
+2.2.1
+=
+----------
+- Replaced non-blocking sleep implementation with a blocking one for PCL
+       
+2.2.0
+=
+----------
+- Added Async Support (PCL)
+- PCL Profile updated from Profile78 ->  Profile 259
+- Added missing WaitAndRetryAsync overload
+
+2.1.0
+=
+----------
+- Added Async Support (.NET Framework 4.5 Only) - Massive thanks to  [@mauricedb](https://github.com/mauricedb) for the implementation
+
+2.0.0
+=
+----------
+- Added Portable Class Library ([Issue #4](https://github.com/michael-wolfenden/Polly/issues/4)) - Thanks to  [@ghuntley](https://github.com/ghuntley) for the implementation
+- The `Polly` NuGet package is now no longer strongly named. The strongly named NuGet package is now `Polly-Signed` ([Issue #5](https://github.com/michael-wolfenden/Polly/issues/5)) 
+
+1.1.0
+=
+----------
+- Added additional overloads to Retry
+- Allow arbitrary data to be passed to policy execution ([Issue #1](https://github.com/michael-wolfenden/Polly/issues/1)) 
diff --git a/README.md b/README.md
index a733eab4..bb36d360 100644
--- a/README.md
+++ b/README.md
@@ -1,319 +1,321 @@
-Polly
-=
-Polly is a .NET 3.5 / 4.0 / 4.5 / PCL (Profile 259) library that allows developers to express transient exception handling policies such as Retry, Retry Forever, Wait and Retry or Circuit Breaker in a fluent manner.
-
-[![NuGet version](https://badge.fury.io/nu/polly.svg)](http://badge.fury.io/nu/polly) [![Build status](https://ci.appveyor.com/api/projects/status/imt7dymt50346k5u?svg=true)](https://ci.appveyor.com/project/joelhulen/polly)
-
-![](https://raw.github.com/App-vNext/Polly/master/Polly.png)
-
-Installing via NuGet
-=
-
-    Install-Package Polly
-
-You can install the Strongly Named version via: 
-
-    Install-Package Polly-Signed
-
-Usage
-=
-## Step 1 : Specify the type of exceptions you want the policy to handle ##
-
-```csharp
-// Single exception type
-Policy
-  .Handle<DivideByZeroException>()
-
-// Single exception type with condition
-Policy
-  .Handle<SqlException>(ex => ex.Number == 1205)
-
-// Multiple exception types
-Policy
-  .Handle<DivideByZeroException>()
-  .Or<ArgumentException>()
-
-// Multiple exception types with condition
-Policy
-  .Handle<SqlException>(ex => ex.Number == 1205)
-  .Or<ArgumentException>(ex => x.ParamName == "example")
-```
-
-## Step 2 : Specify how the policy should handle those exceptions
-
-### Retry ###
-
-```csharp
-// Retry once
-Policy
-  .Handle<DivideByZeroException>()
-  .Retry()
-
-// Retry multiple times
-Policy
-  .Handle<DivideByZeroException>()
-  .Retry(3)
-
-// Retry multiple times, calling an action on each retry 
-// with the current exception and retry count
-Policy
-    .Handle<DivideByZeroException>()
-    .Retry(3, (exception, retryCount) =>
-    {
-        // do something 
-    });
-
-// Retry multiple times, calling an action on each retry 
-// with the current exception, retry count and context 
-// provided to Execute()
-Policy
-    .Handle<DivideByZeroException>()
-    .Retry(3, (exception, retryCount, context) =>
-    {
-        // do something 
-    });
-```
-
-### Retry forever ###
-
-```csharp
-
-// Retry forever
-Policy
-  .Handle<DivideByZeroException>()
-  .RetryForever()
-
-// Retry forever, calling an action on each retry with the 
-// current exception
-Policy
-  .Handle<DivideByZeroException>()
-  .RetryForever(exception =>
-  {
-        // do something       
-  });
-
-// Retry forever, calling an action on each retry with the
-// current exception and context provided to Execute()
-Policy
-  .Handle<DivideByZeroException>()
-  .RetryForever((exception, context) =>
-  {
-        // do something       
-  });
-```
-
-### Retry and Wait ###
-
-```csharp
-// Retry, waiting a specified duration between each retry
-Policy
-  .Handle<DivideByZeroException>()
-  .WaitAndRetry(new[]
-  {
-    TimeSpan.FromSeconds(1),
-    TimeSpan.FromSeconds(2),
-    TimeSpan.FromSeconds(3)
-  });
-
-// Retry, waiting a specified duration between each retry, 
-// calling an action on each retry with the current exception
-// and duration
-Policy
-  .Handle<DivideByZeroException>()
-  .WaitAndRetry(new[]
-  {
-    1.Seconds(),
-    2.Seconds(),
-    3.Seconds()
-  }, (exception, timeSpan) => {
-    // do something    
-  }); 
-
-// Retry, waiting a specified duration between each retry, 
-// calling an action on each retry with the current exception, 
-// duration and context provided to Execute()
-Policy
-  .Handle<DivideByZeroException>()
-  .WaitAndRetry(new[]
-  {
-    1.Seconds(),
-    2.Seconds(),
-    3.Seconds()
-  }, (exception, timeSpan, context) => {
-    // do something    
-  });
-
-// Retry a specified number of times, using a function to 
-// calculate the duration to wait between retries based on 
-// the current retry attempt (allows for exponential backoff)
-// In this case will wait for
-//  2 ^ 1 = 2 seconds then
-//  2 ^ 2 = 4 seconds then
-//  2 ^ 3 = 8 seconds then
-//  2 ^ 4 = 16 seconds then
-//  2 ^ 5 = 32 seconds
-Policy
-  .Handle<DivideByZeroException>()
-  .WaitAndRetry(5, retryAttempt => 
-	TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) 
-  );
-
-// Retry a specified number of times, using a function to 
-// calculate the duration to wait between retries based on 
-// the current retry attempt, calling an action on each retry 
-// with the current exception, duration and context provided 
-// to Execute()
-Policy
-  .Handle<DivideByZeroException>()
-  .WaitAndRetry(
-    5, 
-    retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), 
-    (exception, timeSpan, context) => {
-      // do something
-    }
-  );
-```
-
-### Circuit Breaker ###
-```csharp
-// Break the circuit after the specified number of exceptions
-// and keep circuit broken for the specified duration
-Policy
-  .Handle<DivideByZeroException>()
-  .CircuitBreaker(2, TimeSpan.FromMinutes(1));
-```
-
-For more information on the Circuit Breaker pattern see:
-* [Making the Netflix API More Resilient](http://techblog.netflix.com/2011/12/making-netflix-api-more-resilient.html)
-* [The Circuit Breaker](http://thatextramile.be/blog/2008/05/the-circuit-breaker)
- 
-## Step 3 : Execute the policy
-
-```csharp
-// Execute an action
-var policy = Policy
-              .Handle<DivideByZeroException>()
-              .Retry();
-
-policy.Execute(() => DoSomething());
-
-// Execute an action passing arbitrary context data
-var policy = Policy
-    .Handle<DivideByZeroException>()
-    .Retry(3, (exception, retryCount, context) =>
-    {
-        var methodThatRaisedException = context["methodName"];
-		Log(exception, methodThatRaisedException);
-    });
-
-policy.Execute(
-	() => DoSomething(),
-	new Dictionary<string, object>() {{ "methodName", "some method" }}
-);
-
-// Execute a function returning a result
-var policy = Policy
-              .Handle<DivideByZeroException>()
-              .Retry();
-
-var result = policy.Execute(() => DoSomething());
-
-// Execute a function returning a result passing arbitrary context data
-var policy = Policy
-    .Handle<DivideByZeroException>()
-    .Retry(3, (exception, retryCount, context) =>
-    {
-        object methodThatRaisedException = context["methodName"];
-        Log(exception, methodThatRaisedException)
-    });
-
-var result = policy.Execute(
-    () => DoSomething(),
-    new Dictionary<string, object>() {{ "methodName", "some method" }}
-);
-
-// You can of course chain it all together
-Policy
-  .Handle<SqlException>(ex => ex.Number == 1205)
-  .Or<ArgumentException>(ex => ex.ParamName == "example")
-  .Retry()
-  .Execute(() => DoSomething());
-```
-
-Post Execution Steps
-=
-Using the `ExecuteAndCapture` method you can capture the result of executing a policy.
-
-```csharp
-var policyResult = Policy
-              .Handle<DivideByZeroException>()
-              .Retry()
-              .ExecuteAndCapture(() => DoSomething());
-/*              
-policyResult.Outcome - whether the call succeeded or failed         
-policyResult.FinalException - the final exception captured, will be null if the call succeeded
-policyResult.ExceptionType - was the final exception an exception the policy was defined to handle (like DivideByZeroException above) or an unhandled one (say Exception). Will be null if the call succeeded.
-policyResult.Result - if executing a func, the result if the call succeeded or the type's default value
-```
-
-Asynchronous Support (.NET 4.5 and PCL Only)
-=
-You can use Polly with asynchronous functions by using the asynchronous methods
-
-* `RetryAsync`
-* `RetryForeverAsync`
-* `WaitAndRetryAsync`
-* `CircuitBreakerAsync`
-* `ExecuteAsync`
-* `ExecuteAndCaptureAsync`
-
-In place of their synchronous counterparts
-
-* `Retry`
-* `RetryForever`
-* `WaitAndRetry`
-* `CircuitBreaker`
-* `Execute`
-* `ExecuteAndCapture`
-
-For example
-
-```csharp
-await Policy
-  .Handle<SqlException>(ex => ex.Number == 1205)
-  .Or<ArgumentException>(ex => ex.ParamName == "example")
-  .RetryAsync()
-  .ExecuteAsync(() => DoSomethingAsync());
-
-```
-
-3rd Party Libraries
-=
-
-* [Fluent Assertions](https://github.com/dennisdoomen/fluentassertions) - A set of .NET extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style test | [Apache License 2.0 (Apache)](https://github.com/dennisdoomen/fluentassertions/blob/develop/LICENSE)
-* [xUnit.net](https://github.com/xunit/xunit) - Free, open source, community-focused unit testing tool for the .NET Framework | [Apache License 2.0 (Apache)](https://github.com/xunit/xunit/blob/master/license.txt)
-* [Ian Griffith's TimedLock] (http://www.interact-sw.co.uk/iangblog/2004/04/26/yetmoretimedlocking)
-* [Steven van Deursen's ReadOnlyDictionary] (http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29)
-
-Acknowledgements
-=
-
-* [lokad-shared-libraries](https://github.com/Lokad/lokad-shared-libraries) - Helper assemblies for .NET 3.5 and Silverlight 2.0 that are being developed as part of the Open Source effort by Lokad.com (discontinued) | [New BSD License](https://raw.github.com/Lokad/lokad-shared-libraries/master/Lokad.Shared.License.txt)
-* [@michael-wolfenden](https://github.com/michael-wolfenden) - The creator and mastermind of Polly!
-* [@ghuntley](https://github.com/ghuntley) - Portable Class Library implementation.
-* [@mauricedb](https://github.com/mauricedb) - Async implementation.
-* [@robgibbens](https://github.com/RobGibbens) - Added existing async files to PCL project
-* [Hacko](https://github.com/hacko-bede) - Added extra `NotOnCapturedContext` call to prevent potential deadlocks when blocking on asynchronous calls
-* [@ThomasMentzel](https://github.com/ThomasMentzel) - Added ability to capture the results of executing a policy via `ExecuteAndCapture`
-
-Sample Projects
-=
-[Polly-Samples](https://github.com/App-vNext/Polly-Samples) contains practical examples for using various implementations of Polly. Please feel free to contribute to the Polly-Samples repository in order to assist others who are either learning Polly for the first time, or are seeking advanced examples and novel approaches provided by our generous community.
-
-Instructions for Contributing
-=
-Please check out our [Wiki](https://github.com/App-vNext/Polly/wiki/Git-Workflow) for contributing guidelines. We are following the excellent GitHub Flow process, and would like to make sure you have all of the information needed to be a world-class contributor!
-
-License
-=
-Licensed under the terms of the [New BSD License](http://opensource.org/licenses/BSD-3-Clause)
+Polly
+=
+Polly is a .NET 3.5 / 4.0 / 4.5 / PCL (Profile 259) library that allows developers to express transient exception handling policies such as Retry, Retry Forever, Wait and Retry or Circuit Breaker in a fluent manner.
+
+[![NuGet version](https://badge.fury.io/nu/polly.svg)](http://badge.fury.io/nu/polly) [![Build status](https://ci.appveyor.com/api/projects/status/imt7dymt50346k5u?svg=true)](https://ci.appveyor.com/project/joelhulen/polly)
+
+![](https://raw.github.com/App-vNext/Polly/master/Polly.png)
+
+Installing via NuGet
+=
+
+    Install-Package Polly
+
+You can install the Strongly Named version via: 
+
+    Install-Package Polly-Signed
+
+Usage
+=
+## Step 1 : Specify the type of exceptions you want the policy to handle ##
+
+```csharp
+// Single exception type
+Policy
+  .Handle<DivideByZeroException>()
+
+// Single exception type with condition
+Policy
+  .Handle<SqlException>(ex => ex.Number == 1205)
+
+// Multiple exception types
+Policy
+  .Handle<DivideByZeroException>()
+  .Or<ArgumentException>()
+
+// Multiple exception types with condition
+Policy
+  .Handle<SqlException>(ex => ex.Number == 1205)
+  .Or<ArgumentException>(ex => x.ParamName == "example")
+```
+
+## Step 2 : Specify how the policy should handle those exceptions
+
+### Retry ###
+
+```csharp
+// Retry once
+Policy
+  .Handle<DivideByZeroException>()
+  .Retry()
+
+// Retry multiple times
+Policy
+  .Handle<DivideByZeroException>()
+  .Retry(3)
+
+// Retry multiple times, calling an action on each retry 
+// with the current exception and retry count
+Policy
+    .Handle<DivideByZeroException>()
+    .Retry(3, (exception, retryCount) =>
+    {
+        // do something 
+    });
+
+// Retry multiple times, calling an action on each retry 
+// with the current exception, retry count and context 
+// provided to Execute()
+Policy
+    .Handle<DivideByZeroException>()
+    .Retry(3, (exception, retryCount, context) =>
+    {
+        // do something 
+    });
+```
+
+### Retry forever ###
+
+```csharp
+
+// Retry forever
+Policy
+  .Handle<DivideByZeroException>()
+  .RetryForever()
+
+// Retry forever, calling an action on each retry with the 
+// current exception
+Policy
+  .Handle<DivideByZeroException>()
+  .RetryForever(exception =>
+  {
+        // do something       
+  });
+
+// Retry forever, calling an action on each retry with the
+// current exception and context provided to Execute()
+Policy
+  .Handle<DivideByZeroException>()
+  .RetryForever((exception, context) =>
+  {
+        // do something       
+  });
+```
+
+### Retry and Wait ###
+
+```csharp
+// Retry, waiting a specified duration between each retry
+Policy
+  .Handle<DivideByZeroException>()
+  .WaitAndRetry(new[]
+  {
+    TimeSpan.FromSeconds(1),
+    TimeSpan.FromSeconds(2),
+    TimeSpan.FromSeconds(3)
+  });
+
+// Retry, waiting a specified duration between each retry, 
+// calling an action on each retry with the current exception
+// and duration
+Policy
+  .Handle<DivideByZeroException>()
+  .WaitAndRetry(new[]
+  {
+    1.Seconds(),
+    2.Seconds(),
+    3.Seconds()
+  }, (exception, timeSpan) => {
+    // do something    
+  }); 
+
+// Retry, waiting a specified duration between each retry, 
+// calling an action on each retry with the current exception, 
+// duration and context provided to Execute()
+Policy
+  .Handle<DivideByZeroException>()
+  .WaitAndRetry(new[]
+  {
+    1.Seconds(),
+    2.Seconds(),
+    3.Seconds()
+  }, (exception, timeSpan, context) => {
+    // do something    
+  });
+
+// Retry a specified number of times, using a function to 
+// calculate the duration to wait between retries based on 
+// the current retry attempt (allows for exponential backoff)
+// In this case will wait for
+//  2 ^ 1 = 2 seconds then
+//  2 ^ 2 = 4 seconds then
+//  2 ^ 3 = 8 seconds then
+//  2 ^ 4 = 16 seconds then
+//  2 ^ 5 = 32 seconds
+Policy
+  .Handle<DivideByZeroException>()
+  .WaitAndRetry(5, retryAttempt => 
+	TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) 
+  );
+
+// Retry a specified number of times, using a function to 
+// calculate the duration to wait between retries based on 
+// the current retry attempt, calling an action on each retry 
+// with the current exception, duration and context provided 
+// to Execute()
+Policy
+  .Handle<DivideByZeroException>()
+  .WaitAndRetry(
+    5, 
+    retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), 
+    (exception, timeSpan, context) => {
+      // do something
+    }
+  );
+```
+
+### Circuit Breaker ###
+```csharp
+// Break the circuit after the specified number of exceptions
+// and keep circuit broken for the specified duration
+Policy
+  .Handle<DivideByZeroException>()
+  .CircuitBreaker(2, TimeSpan.FromMinutes(1));
+```
+
+For more information on the Circuit Breaker pattern see:
+* [Making the Netflix API More Resilient](http://techblog.netflix.com/2011/12/making-netflix-api-more-resilient.html)
+* [The Circuit Breaker](http://thatextramile.be/blog/2008/05/the-circuit-breaker)
+ 
+## Step 3 : Execute the policy
+
+```csharp
+// Execute an action
+var policy = Policy
+              .Handle<DivideByZeroException>()
+              .Retry();
+
+policy.Execute(() => DoSomething());
+
+// Execute an action passing arbitrary context data
+var policy = Policy
+    .Handle<DivideByZeroException>()
+    .Retry(3, (exception, retryCount, context) =>
+    {
+        var methodThatRaisedException = context["methodName"];
+		Log(exception, methodThatRaisedException);
+    });
+
+policy.Execute(
+	() => DoSomething(),
+	new Dictionary<string, object>() {{ "methodName", "some method" }}
+);
+
+// Execute a function returning a result
+var policy = Policy
+              .Handle<DivideByZeroException>()
+              .Retry();
+
+var result = policy.Execute(() => DoSomething());
+
+// Execute a function returning a result passing arbitrary context data
+var policy = Policy
+    .Handle<DivideByZeroException>()
+    .Retry(3, (exception, retryCount, context) =>
+    {
+        object methodThatRaisedException = context["methodName"];
+        Log(exception, methodThatRaisedException)
+    });
+
+var result = policy.Execute(
+    () => DoSomething(),
+    new Dictionary<string, object>() {{ "methodName", "some method" }}
+);
+
+// You can of course chain it all together
+Policy
+  .Handle<SqlException>(ex => ex.Number == 1205)
+  .Or<ArgumentException>(ex => ex.ParamName == "example")
+  .Retry()
+  .Execute(() => DoSomething());
+```
+
+Post Execution Steps
+=
+Using the `ExecuteAndCapture` method you can capture the result of executing a policy.
+
+```csharp
+var policyResult = Policy
+              .Handle<DivideByZeroException>()
+              .Retry()
+              .ExecuteAndCapture(() => DoSomething());
+/*              
+policyResult.Outcome - whether the call succeeded or failed         
+policyResult.FinalException - the final exception captured, will be null if the call succeeded
+policyResult.ExceptionType - was the final exception an exception the policy was defined to handle (like DivideByZeroException above) or an unhandled one (say Exception). Will be null if the call succeeded.
+policyResult.Result - if executing a func, the result if the call succeeded or the type's default value
+```
+
+Asynchronous Support (.NET 4.5 and PCL Only)
+=
+You can use Polly with asynchronous functions by using the asynchronous methods
+
+* `RetryAsync`
+* `RetryForeverAsync`
+* `WaitAndRetryAsync`
+* `CircuitBreakerAsync`
+* `ExecuteAsync`
+* `ExecuteAndCaptureAsync`
+
+In place of their synchronous counterparts
+
+* `Retry`
+* `RetryForever`
+* `WaitAndRetry`
+* `CircuitBreaker`
+* `Execute`
+* `ExecuteAndCapture`
+
+For example
+
+```csharp
+await Policy
+  .Handle<SqlException>(ex => ex.Number == 1205)
+  .Or<ArgumentException>(ex => ex.ParamName == "example")
+  .RetryAsync()
+  .ExecuteAsync(() => DoSomethingAsync());
+
+```
+
+Note: By default, continuation and retry will not run on captured synchronization context. To change this behavior use respective overloads which take boolean `continueOnCapturedContext` parameter.  
+
+3rd Party Libraries
+=
+
+* [Fluent Assertions](https://github.com/dennisdoomen/fluentassertions) - A set of .NET extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style test | [Apache License 2.0 (Apache)](https://github.com/dennisdoomen/fluentassertions/blob/develop/LICENSE)
+* [xUnit.net](https://github.com/xunit/xunit) - Free, open source, community-focused unit testing tool for the .NET Framework | [Apache License 2.0 (Apache)](https://github.com/xunit/xunit/blob/master/license.txt)
+* [Ian Griffith's TimedLock] (http://www.interact-sw.co.uk/iangblog/2004/04/26/yetmoretimedlocking)
+* [Steven van Deursen's ReadOnlyDictionary] (http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29)
+
+Acknowledgements
+=
+
+* [lokad-shared-libraries](https://github.com/Lokad/lokad-shared-libraries) - Helper assemblies for .NET 3.5 and Silverlight 2.0 that are being developed as part of the Open Source effort by Lokad.com (discontinued) | [New BSD License](https://raw.github.com/Lokad/lokad-shared-libraries/master/Lokad.Shared.License.txt)
+* [@michael-wolfenden](https://github.com/michael-wolfenden) - The creator and mastermind of Polly!
+* [@ghuntley](https://github.com/ghuntley) - Portable Class Library implementation.
+* [@mauricedb](https://github.com/mauricedb) - Async implementation.
+* [@robgibbens](https://github.com/RobGibbens) - Added existing async files to PCL project
+* [Hacko](https://github.com/hacko-bede) - Added extra `NotOnCapturedContext` call to prevent potential deadlocks when blocking on asynchronous calls
+* [@ThomasMentzel](https://github.com/ThomasMentzel) - Added ability to capture the results of executing a policy via `ExecuteAndCapture`
+
+Sample Projects
+=
+[Polly-Samples](https://github.com/App-vNext/Polly-Samples) contains practical examples for using various implementations of Polly. Please feel free to contribute to the Polly-Samples repository in order to assist others who are either learning Polly for the first time, or are seeking advanced examples and novel approaches provided by our generous community.
+
+Instructions for Contributing
+=
+Please check out our [Wiki](https://github.com/App-vNext/Polly/wiki/Git-Workflow) for contributing guidelines. We are following the excellent GitHub Flow process, and would like to make sure you have all of the information needed to be a world-class contributor!
+
+License
+=
+Licensed under the terms of the [New BSD License](http://opensource.org/licenses/BSD-3-Clause)
diff --git a/src/Polly.Shared/CircuitBreaker/CircuitBreakerPolicyAsync.cs b/src/Polly.Shared/CircuitBreaker/CircuitBreakerPolicyAsync.cs
index b004cf43..096fc733 100644
--- a/src/Polly.Shared/CircuitBreaker/CircuitBreakerPolicyAsync.cs
+++ b/src/Polly.Shared/CircuitBreaker/CircuitBreakerPolicyAsync.cs
@@ -10,7 +10,7 @@ namespace Polly.CircuitBreaker
 {
     internal partial class CircuitBreakerPolicy
     {
-        internal static async Task ImplementationAsync(Func<Task> action, IEnumerable<ExceptionPredicate> shouldRetryPredicates, ICircuitBreakerState breakerState)
+        internal static async Task ImplementationAsync(bool continueOnCapturedContext, Func<Task> action, IEnumerable<ExceptionPredicate> shouldRetryPredicates, ICircuitBreakerState breakerState)
         {
             if (breakerState.IsBroken)
             {
@@ -19,7 +19,10 @@ namespace Polly.CircuitBreaker
 
             try
             {
-                await action().NotOnCapturedContext();
+                if (continueOnCapturedContext)
+                    await action();
+                else
+                    await action().NotOnCapturedContext();
 
                 breakerState.Reset();
             }
diff --git a/src/Polly.Shared/CircuitBreakerSyntaxAsync.cs b/src/Polly.Shared/CircuitBreakerSyntaxAsync.cs
index a0afe758..8cf7deb5 100644
--- a/src/Polly.Shared/CircuitBreakerSyntaxAsync.cs
+++ b/src/Polly.Shared/CircuitBreakerSyntaxAsync.cs
@@ -25,16 +25,17 @@ namespace Polly
         /// <param name="policyBuilder">The policy builder.</param>
         /// <param name="exceptionsAllowedBeforeBreaking">The number of exceptions that are allowed before opening the circuit.</param>
         /// <param name="durationOfBreak">The duration the circuit will stay open before resetting.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
         /// <returns>The policy instance.</returns>
         /// <remarks>(see "Release It!" by Michael T. Nygard fi)</remarks>
         /// <exception cref="System.ArgumentOutOfRangeException">exceptionsAllowedBeforeBreaking;Value must be greater than zero.</exception>
-        public static Policy CircuitBreakerAsync(this PolicyBuilder policyBuilder, int exceptionsAllowedBeforeBreaking, TimeSpan durationOfBreak)
+        public static Policy CircuitBreakerAsync(this PolicyBuilder policyBuilder, int exceptionsAllowedBeforeBreaking, TimeSpan durationOfBreak, bool continueOnCapturedContext = false)
         {
             if (exceptionsAllowedBeforeBreaking <= 0) throw new ArgumentOutOfRangeException("exceptionsAllowedBeforeBreaking", "Value must be greater than zero.");
 
             var policyState = new CircuitBreakerState(exceptionsAllowedBeforeBreaking, durationOfBreak);
             return new Policy(
-                action => CircuitBreakerPolicy.ImplementationAsync(action, policyBuilder.ExceptionPredicates, policyState),
+                action => CircuitBreakerPolicy.ImplementationAsync(continueOnCapturedContext, action, policyBuilder.ExceptionPredicates, policyState),
                 policyBuilder.ExceptionPredicates
             );
         }
diff --git a/src/Polly.Shared/Extensions/TaskExtensions.cs b/src/Polly.Shared/Extensions/TaskExtensions.cs
index 57344bf7..c1f15016 100644
--- a/src/Polly.Shared/Extensions/TaskExtensions.cs
+++ b/src/Polly.Shared/Extensions/TaskExtensions.cs
@@ -16,6 +16,27 @@ namespace Polly.Extensions
         {
             return task.ConfigureAwait(false);
         }
+
+        public static async Task Continue(this Task task, bool onCapturedContext)
+        {
+            if (onCapturedContext)
+            {
+                await task;
+                return;
+            }
+
+            await task.NotOnCapturedContext();
+        }
+
+        public static async Task<T> Continue<T>(this Task<T> task, bool onCapturedContext)
+        {
+            if (onCapturedContext)
+            {
+                return await task;
+            }
+
+            return await task.NotOnCapturedContext();
+        }
     }
 }
 
diff --git a/src/Polly.Shared/PolicyAsync.cs b/src/Polly.Shared/PolicyAsync.cs
index 757e994a..531d80a5 100644
--- a/src/Polly.Shared/PolicyAsync.cs
+++ b/src/Polly.Shared/PolicyAsync.cs
@@ -27,11 +27,22 @@ namespace Polly
         /// <param name="action">The action to perform.</param>
         [DebuggerStepThrough]
         public Task ExecuteAsync(Func<Task> action)
+        {
+            return ExecuteAsync(false, action);
+        }
+
+        /// <summary>
+        ///     Executes the specified asynchronous action within the policy.
+        /// </summary>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="action">The action to perform.</param>
+        [DebuggerStepThrough]
+        public Task ExecuteAsync(bool continueOnCapturedContext, Func<Task> action)
         {
             if (_asyncExceptionPolicy == null) throw new InvalidOperationException
                 ("Please use the asynchronous RetryAsync, RetryForeverAsync, WaitAndRetryAsync or CircuitBreakerAsync methods when calling the asynchronous Execute method.");
 
-            return _asyncExceptionPolicy(action);
+            return _asyncExceptionPolicy(action).Continue(continueOnCapturedContext);
         }
 
         /// <summary>
@@ -39,14 +50,25 @@ namespace Polly
         /// </summary>
         /// <param name="action">The action to perform.</param>
         [DebuggerStepThrough]
-        public async Task<PolicyResult> ExecuteAndCaptureAsync(Func<Task> action)
+        public Task<PolicyResult> ExecuteAndCaptureAsync(Func<Task> action)
+        {
+            return ExecuteAndCaptureAsync(false, action);
+        }
+
+        /// <summary>
+        ///     Executes the specified asynchronous action within the policy and returns the captured result.
+        /// </summary>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="action">The action to perform.</param>
+        [DebuggerStepThrough]
+        public async Task<PolicyResult> ExecuteAndCaptureAsync(bool continueOnCapturedContext, Func<Task> action)
         {
             if (_asyncExceptionPolicy == null) throw new InvalidOperationException
                 ("Please use the asynchronous RetryAsync, RetryForeverAsync, WaitAndRetryAsync or CircuitBreakerAsync methods when calling the asynchronous Execute method.");
 
             try
             {
-                await _asyncExceptionPolicy(action).NotOnCapturedContext();
+                await _asyncExceptionPolicy(action).Continue(continueOnCapturedContext);
                 return PolicyResult.Successful();
             }
             catch (Exception exception)
@@ -62,24 +84,62 @@ namespace Polly
         /// <param name="action">The action to perform.</param>
         /// <returns>The value returned by the action</returns>
         [DebuggerStepThrough]
-        public async Task<TResult> ExecuteAsync<TResult>(Func<Task<TResult>> action)
+        public Task<TResult> ExecuteAsync<TResult>(Func<Task<TResult>> action)
+        {
+            return ExecuteAsync(false, action);
+        }
+
+        /// <summary>
+        ///     Executes the specified asynchronous action within the policy and returns the result.
+        /// </summary>
+        /// <typeparam name="TResult">The type of the result.</typeparam>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="action">The action to perform.</param>
+        /// <returns>The value returned by the action</returns>
+        [DebuggerStepThrough]
+        public async Task<TResult> ExecuteAsync<TResult>(bool continueOnCapturedContext, Func<Task<TResult>> action)
         {
             if (_asyncExceptionPolicy == null) throw new InvalidOperationException(
                 "Please use the asynchronous RetryAsync, RetryForeverAsync, WaitAndRetryAsync or CircuitBreakerAsync methods when calling the asynchronous Execute method.");
 
             var result = default(TResult);
-            await _asyncExceptionPolicy(async () => { result = await action().NotOnCapturedContext(); }).NotOnCapturedContext();
+
+            await _asyncExceptionPolicy(async () =>
+            {
+                result = await action().Continue(continueOnCapturedContext);
+            })
+            .Continue(continueOnCapturedContext);
+
             return result;
         }
 
         /// <summary>
-        ///     Executes the specified asynchronous action within the policy and returns the result.
+        /// Executes the specified asynchronous action within the policy and returns the result.
         /// </summary>
         /// <typeparam name="TResult">The type of the result.</typeparam>
         /// <param name="action">The action to perform.</param>
-        /// <returns>The value returned by the action</returns>
+        /// <returns>
+        /// The value returned by the action
+        /// </returns>
+        /// <exception cref="System.InvalidOperationException">Please use the asynchronous RetryAsync, RetryForeverAsync, WaitAndRetryAsync or CircuitBreakerAsync methods when calling the asynchronous Execute method.</exception>
         [DebuggerStepThrough]
-        public async Task<PolicyResult<TResult>> ExecuteAndCaptureAsync<TResult>(Func<Task<TResult>> action)
+        public Task<PolicyResult<TResult>> ExecuteAndCaptureAsync<TResult>(Func<Task<TResult>> action)
+        {
+            return ExecuteAndCaptureAsync(false, action);
+        }
+
+        /// <summary>
+        /// Executes the specified asynchronous action within the policy and returns the result.
+        /// </summary>
+        /// <typeparam name="TResult">The type of the result.</typeparam>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="action">The action to perform.</param>
+        /// <returns>
+        /// The value returned by the action
+        /// </returns>
+        /// <exception cref="System.InvalidOperationException">Please use the asynchronous RetryAsync, RetryForeverAsync, WaitAndRetryAsync or CircuitBreakerAsync methods when calling the asynchronous Execute method.</exception>
+        [DebuggerStepThrough]
+        public async Task<PolicyResult<TResult>> ExecuteAndCaptureAsync<TResult>(bool continueOnCapturedContext, Func<Task<TResult>> action)
         {
             if (_asyncExceptionPolicy == null) throw new InvalidOperationException(
                 "Please use the asynchronous RetryAsync, RetryForeverAsync, WaitAndRetryAsync or CircuitBreakerAsync methods when calling the asynchronous Execute method.");
@@ -87,7 +147,13 @@ namespace Polly
             try
             {
                 var result = default(TResult);
-                await _asyncExceptionPolicy(async () => { result = await action().NotOnCapturedContext(); }).NotOnCapturedContext();
+
+                await _asyncExceptionPolicy(async () =>
+                {
+                    result = await action().Continue(continueOnCapturedContext);
+                })
+                .Continue(continueOnCapturedContext);
+
                 return PolicyResult<TResult>.Successful(result);
             }
             catch (Exception exception)
diff --git a/src/Polly.Shared/Polly.Shared.projitems b/src/Polly.Shared/Polly.Shared.projitems
index 75a963c1..ae031a9e 100644
--- a/src/Polly.Shared/Polly.Shared.projitems
+++ b/src/Polly.Shared/Polly.Shared.projitems
@@ -27,11 +27,15 @@
     <Compile Include="$(MSBuildThisFileDirectory)PolicyResult.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)RetrySyntax.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)RetrySyntaxAsync.cs" />
+    <Compile Include="$(MSBuildThisFileDirectory)Retry\IRetryPolicyStateAsync.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Retry\IRetryPolicyState.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicy.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicyAsync.cs" />
+    <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicyStateAsync.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicyState.cs" />
+    <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicyStateWithCountAsync.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicyStateWithCount.cs" />
+    <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicyStateWithSleepAsync.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Retry\RetryPolicyStateWithSleep.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Utilities\ReadOnlyDictionary.cs" />
     <Compile Include="$(MSBuildThisFileDirectory)Utilities\SystemClock.cs" />
diff --git a/src/Polly.Shared/Retry/IRetryPolicyState.cs b/src/Polly.Shared/Retry/IRetryPolicyState.cs
index d529b292..0273fc1c 100644
--- a/src/Polly.Shared/Retry/IRetryPolicyState.cs
+++ b/src/Polly.Shared/Retry/IRetryPolicyState.cs
@@ -2,7 +2,7 @@
 
 namespace Polly.Retry
 {
-    internal interface IRetryPolicyState
+    internal partial interface IRetryPolicyState
     {
         bool CanRetry(Exception ex);
     }
diff --git a/src/Polly.Shared/Retry/IRetryPolicyStateAsync.cs b/src/Polly.Shared/Retry/IRetryPolicyStateAsync.cs
new file mode 100644
index 00000000..00676e10
--- /dev/null
+++ b/src/Polly.Shared/Retry/IRetryPolicyStateAsync.cs
@@ -0,0 +1,14 @@
+﻿#if SUPPORTS_ASYNC
+
+using System;
+using System.Threading.Tasks;
+
+namespace Polly.Retry
+{
+    internal partial interface IRetryPolicyState
+    {
+        Task<bool> CanRetryAsync(Exception ex);
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/src/Polly.Shared/Retry/RetryPolicyAsync.cs b/src/Polly.Shared/Retry/RetryPolicyAsync.cs
index 8c09e225..6237ba3f 100644
--- a/src/Polly.Shared/Retry/RetryPolicyAsync.cs
+++ b/src/Polly.Shared/Retry/RetryPolicyAsync.cs
@@ -10,8 +10,7 @@ namespace Polly.Retry
 {
     internal static partial class RetryPolicy
     {
-        public static async Task ImplementationAsync(Func<Task> action,
-            IEnumerable<ExceptionPredicate> shouldRetryPredicates, Func<IRetryPolicyState> policyStateFactory)
+        public static async Task ImplementationAsync(Func<Task> action, IEnumerable<ExceptionPredicate> shouldRetryPredicates, Func<IRetryPolicyState> policyStateFactory, bool continueOnCapturedContext)
         {
             IRetryPolicyState policyState = policyStateFactory();
 
@@ -19,7 +18,10 @@ namespace Polly.Retry
             {
                 try
                 {
-                    await action().NotOnCapturedContext();
+                    if (continueOnCapturedContext)
+                        await action();
+                    else
+                        await action().NotOnCapturedContext();
 
                     return;
                 }
@@ -30,7 +32,7 @@ namespace Polly.Retry
                         throw;
                     }
 
-                    if (!policyState.CanRetry(ex))
+                    if (!(await policyState.CanRetryAsync(ex)))
                     {
                         throw;
                     }
diff --git a/src/Polly.Shared/Retry/RetryPolicyState.cs b/src/Polly.Shared/Retry/RetryPolicyState.cs
index b9be3183..8cba90c0 100644
--- a/src/Polly.Shared/Retry/RetryPolicyState.cs
+++ b/src/Polly.Shared/Retry/RetryPolicyState.cs
@@ -2,7 +2,7 @@
 
 namespace Polly.Retry
 {
-    internal class RetryPolicyState : IRetryPolicyState
+    internal partial class RetryPolicyState : IRetryPolicyState
     {
         private readonly Action<Exception, Context> _onRetry;
         private readonly Context _context;
diff --git a/src/Polly.Shared/Retry/RetryPolicyStateAsync.cs b/src/Polly.Shared/Retry/RetryPolicyStateAsync.cs
new file mode 100644
index 00000000..d6079496
--- /dev/null
+++ b/src/Polly.Shared/Retry/RetryPolicyStateAsync.cs
@@ -0,0 +1,20 @@
+﻿#if SUPPORTS_ASYNC
+
+using System;
+using System.Threading.Tasks;
+
+namespace Polly.Retry
+{
+    internal partial class RetryPolicyState : IRetryPolicyState
+    {
+        static readonly Task<bool> Done = Task.FromResult(true);
+
+        public Task<bool> CanRetryAsync(Exception ex)
+        {
+            _onRetry(ex, _context);
+            return Done;
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/src/Polly.Shared/Retry/RetryPolicyStateWithCount.cs b/src/Polly.Shared/Retry/RetryPolicyStateWithCount.cs
index a4ad71a2..0a1ec956 100644
--- a/src/Polly.Shared/Retry/RetryPolicyStateWithCount.cs
+++ b/src/Polly.Shared/Retry/RetryPolicyStateWithCount.cs
@@ -2,7 +2,7 @@
 
 namespace Polly.Retry
 {
-    internal class RetryPolicyStateWithCount : IRetryPolicyState
+    internal partial class RetryPolicyStateWithCount : IRetryPolicyState
     {
         private int _errorCount;
         private readonly int _retryCount;
diff --git a/src/Polly.Shared/Retry/RetryPolicyStateWithCountAsync.cs b/src/Polly.Shared/Retry/RetryPolicyStateWithCountAsync.cs
new file mode 100644
index 00000000..6b07815e
--- /dev/null
+++ b/src/Polly.Shared/Retry/RetryPolicyStateWithCountAsync.cs
@@ -0,0 +1,19 @@
+﻿#if SUPPORTS_ASYNC
+
+using System;
+using System.Threading.Tasks;
+
+namespace Polly.Retry
+{
+    internal partial class RetryPolicyStateWithCount : IRetryPolicyState
+    {
+        static readonly Task<bool> Done = Task.FromResult(true);
+
+        public Task<bool> CanRetryAsync(Exception ex)
+        {
+            return Task.FromResult(CanRetry(ex));
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/src/Polly.Shared/Retry/RetryPolicyStateWithSleep.cs b/src/Polly.Shared/Retry/RetryPolicyStateWithSleep.cs
index 06ac6e7a..fceda882 100644
--- a/src/Polly.Shared/Retry/RetryPolicyStateWithSleep.cs
+++ b/src/Polly.Shared/Retry/RetryPolicyStateWithSleep.cs
@@ -4,7 +4,7 @@ using Polly.Utilities;
 
 namespace Polly.Retry
 {
-    internal class RetryPolicyStateWithSleep : IRetryPolicyState
+    internal partial class RetryPolicyStateWithSleep : IRetryPolicyState
     {
         private readonly Action<Exception, TimeSpan, Context> _onRetry;
         private readonly Context _context;
diff --git a/src/Polly.Shared/Retry/RetryPolicyStateWithSleepAsync.cs b/src/Polly.Shared/Retry/RetryPolicyStateWithSleepAsync.cs
new file mode 100644
index 00000000..bfe97d91
--- /dev/null
+++ b/src/Polly.Shared/Retry/RetryPolicyStateWithSleepAsync.cs
@@ -0,0 +1,27 @@
+﻿#if SUPPORTS_ASYNC
+
+using System;
+using System.Threading.Tasks;
+using Polly.Utilities;
+
+namespace Polly.Retry
+{
+    internal partial class RetryPolicyStateWithSleep : IRetryPolicyState
+    {
+        static readonly Task<bool> Done = Task.FromResult(true);
+
+        public async Task<bool> CanRetryAsync(Exception ex)
+        {
+            if (!_sleepDurationsEnumerator.MoveNext()) return false;
+
+            var currentTimeSpan = _sleepDurationsEnumerator.Current;
+            _onRetry(ex, currentTimeSpan, _context);
+
+            await SystemClock.SleepAsync(currentTimeSpan);
+
+            return true;
+        }
+    }
+}
+
+#endif
\ No newline at end of file
diff --git a/src/Polly.Shared/RetrySyntaxAsync.cs b/src/Polly.Shared/RetrySyntaxAsync.cs
index 172b4add..71ac527f 100644
--- a/src/Polly.Shared/RetrySyntaxAsync.cs
+++ b/src/Polly.Shared/RetrySyntaxAsync.cs
@@ -18,6 +18,17 @@ namespace Polly
         /// <param name="policyBuilder">The policy builder.</param>
         /// <returns>The policy instance.</returns>
         public static Policy RetryAsync(this PolicyBuilder policyBuilder)
+        {
+            return RetryAsync(policyBuilder, false);
+        }
+
+        /// <summary>
+        /// Builds a <see cref="Policy"/> that will retry once.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <returns>The policy instance.</returns>
+        public static Policy RetryAsync(this PolicyBuilder policyBuilder, bool continueOnCapturedContext)
         {
             return policyBuilder.RetryAsync(1);
         }
@@ -29,10 +40,22 @@ namespace Polly
         /// <param name="retryCount">The retry count.</param>
         /// <returns>The policy instance.</returns>
         public static Policy RetryAsync(this PolicyBuilder policyBuilder, int retryCount)
+        {
+            return RetryAsync(policyBuilder, retryCount, false);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will retry <paramref name="retryCount" /> times.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="retryCount">The retry count.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <returns>The policy instance.</returns>
+        public static Policy RetryAsync(this PolicyBuilder policyBuilder, int retryCount, bool continueOnCapturedContext)
         {
             Action<Exception, int> doNothing = (_, __) => { };
 
-            return policyBuilder.RetryAsync(retryCount, doNothing);
+            return policyBuilder.RetryAsync(retryCount, continueOnCapturedContext, doNothing);
         }
 
         /// <summary>
@@ -46,7 +69,22 @@ namespace Polly
         /// <exception cref="System.ArgumentNullException">onRetry</exception>
         public static Policy RetryAsync(this PolicyBuilder policyBuilder, Action<Exception, int> onRetry)
         {
-            return policyBuilder.RetryAsync(1, onRetry);
+            return RetryAsync(policyBuilder, false, onRetry);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will retry once
+        ///     calling <paramref name="onRetry" /> on retry with the raised exception and retry count.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
+        /// <exception cref="System.ArgumentNullException">onRetry</exception>
+        public static Policy RetryAsync(this PolicyBuilder policyBuilder, bool continueOnCapturedContext, Action<Exception, int> onRetry)
+        {
+            return policyBuilder.RetryAsync(1, continueOnCapturedContext, onRetry);
         }
 
         /// <summary>
@@ -60,6 +98,22 @@ namespace Polly
         /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
         /// <exception cref="System.ArgumentNullException">onRetry</exception>
         public static Policy RetryAsync(this PolicyBuilder policyBuilder, int retryCount, Action<Exception, int> onRetry)
+        {
+            return RetryAsync(policyBuilder, retryCount, false, onRetry);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will retry <paramref name="retryCount" /> times
+        ///     calling <paramref name="onRetry" /> on each retry with the raised exception and retry count.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="retryCount">The retry count.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
+        /// <exception cref="System.ArgumentNullException">onRetry</exception>
+        public static Policy RetryAsync(this PolicyBuilder policyBuilder, int retryCount, bool continueOnCapturedContext, Action<Exception, int> onRetry)
         {
             if (retryCount < 0)
                 throw new ArgumentOutOfRangeException("retryCount", "Value must be equal to or greater than zero.");
@@ -69,8 +123,8 @@ namespace Polly
                 action => RetryPolicy.ImplementationAsync(
                     action,
                     policyBuilder.ExceptionPredicates,
-                    () => new RetryPolicyStateWithCount(retryCount, onRetry)
-                ),
+                    () => new RetryPolicyStateWithCount(retryCount, onRetry), 
+                    continueOnCapturedContext),
                 policyBuilder.ExceptionPredicates
             );
         }
@@ -81,10 +135,21 @@ namespace Polly
         /// <param name="policyBuilder">The policy builder.</param>
         /// <returns>The policy instance.</returns>
         public static Policy RetryForeverAsync(this PolicyBuilder policyBuilder)
+        {
+            return RetryForeverAsync(policyBuilder, false);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will retry indefinitely.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <returns>The policy instance.</returns>
+        public static Policy RetryForeverAsync(this PolicyBuilder policyBuilder, bool continueOnCapturedContext)
         {
             Action<Exception> doNothing = _ => { };
 
-            return policyBuilder.RetryForeverAsync(doNothing);
+            return policyBuilder.RetryForeverAsync(continueOnCapturedContext, doNothing);
         }
 
         /// <summary>
@@ -96,6 +161,20 @@ namespace Polly
         /// <returns>The policy instance.</returns>
         /// <exception cref="System.ArgumentNullException">onRetry</exception>
         public static Policy RetryForeverAsync(this PolicyBuilder policyBuilder, Action<Exception> onRetry)
+        {
+            return RetryForeverAsync(policyBuilder, false, onRetry);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will retry indefinitely
+        ///     calling <paramref name="onRetry" /> on each retry with the raised exception.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentNullException">onRetry</exception>
+        public static Policy RetryForeverAsync(this PolicyBuilder policyBuilder, bool continueOnCapturedContext, Action<Exception> onRetry)
         {
             if (onRetry == null) throw new ArgumentNullException("onRetry");
 
@@ -103,8 +182,8 @@ namespace Polly
                 action => RetryPolicy.ImplementationAsync(
                     action,
                     policyBuilder.ExceptionPredicates,
-                    () => new RetryPolicyState(onRetry)
-                ),
+                    () => new RetryPolicyState(onRetry), 
+                    continueOnCapturedContext),
                 policyBuilder.ExceptionPredicates
             );
         }
@@ -118,10 +197,24 @@ namespace Polly
         /// <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
         /// <returns>The policy instance.</returns>
         public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, IEnumerable<TimeSpan> sleepDurations)
+        {
+            return WaitAndRetryAsync(policyBuilder, false, sleepDurations);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will wait and retry as many times as there are provided
+        ///     <paramref name="sleepDurations" />
+        ///     On each retry, the duration to wait is the current <paramref name="sleepDurations" /> item.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, bool continueOnCapturedContext, IEnumerable<TimeSpan> sleepDurations)
         {
             Action<Exception, TimeSpan> doNothing = (_, __) => { };
 
-            return policyBuilder.WaitAndRetryAsync(sleepDurations, doNothing);
+            return policyBuilder.WaitAndRetryAsync(continueOnCapturedContext, sleepDurations, doNothing);
         }
 
         /// <summary>
@@ -134,10 +227,25 @@ namespace Polly
         /// <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
         /// <returns>The policy instance.</returns>
         public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, int retryCount, Func<int, TimeSpan> sleepDurationProvider)
+        {
+            return WaitAndRetryAsync(policyBuilder, retryCount, false, sleepDurationProvider);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy"/> that will wait and retry <paramref name="retryCount"/> times.
+        ///     On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider"/> with
+        ///     the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="retryCount">The retry count.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
+        /// <returns>The policy instance.</returns>
+        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, int retryCount, bool continueOnCapturedContext, Func<int, TimeSpan> sleepDurationProvider)
         {
             Action<Exception, TimeSpan> doNothing = (_, __) => { };
 
-            return policyBuilder.WaitAndRetryAsync(retryCount, sleepDurationProvider, doNothing);
+            return policyBuilder.WaitAndRetryAsync(retryCount, continueOnCapturedContext, sleepDurationProvider, doNothing);
         }
 
         /// <summary>
@@ -157,8 +265,30 @@ namespace Polly
         ///     or
         ///     onRetry
         /// </exception>
-        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, int retryCount,
-            Func<int, TimeSpan> sleepDurationProvider, Action<Exception, TimeSpan> onRetry)
+        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, int retryCount, Func<int, TimeSpan> sleepDurationProvider, Action<Exception, TimeSpan> onRetry)
+        {
+            return WaitAndRetryAsync(policyBuilder, retryCount, false, sleepDurationProvider, onRetry);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will wait and retry <paramref name="retryCount" /> times
+        ///     calling <paramref name="onRetry" /> on each retry with the raised exception and the current sleep duration.
+        ///     On each retry, the duration to wait is calculated by calling <paramref name="sleepDurationProvider" /> with
+        ///     the current retry attempt allowing an exponentially increasing wait time (exponential backoff).
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="retryCount">The retry count.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="sleepDurationProvider">The function that provides the duration to wait for for a particular retry attempt.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentOutOfRangeException">retryCount;Value must be greater than zero.</exception>
+        /// <exception cref="System.ArgumentNullException">
+        ///     timeSpanProvider
+        ///     or
+        ///     onRetry
+        /// </exception>
+        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, int retryCount, bool continueOnCapturedContext, Func<int, TimeSpan> sleepDurationProvider, Action<Exception, TimeSpan> onRetry)
         {
             if (retryCount < 0)
                 throw new ArgumentOutOfRangeException("retryCount", "Value must be equal to or greater than zero.");
@@ -172,8 +302,8 @@ namespace Polly
                 action => RetryPolicy.ImplementationAsync(
                     action,
                     policyBuilder.ExceptionPredicates,
-                    () => new RetryPolicyStateWithSleep(sleepDurations, onRetry)
-                ),
+                    () => new RetryPolicyStateWithSleep(sleepDurations, onRetry), 
+                    continueOnCapturedContext),
                 policyBuilder.ExceptionPredicates
             );
         }
@@ -193,8 +323,28 @@ namespace Polly
         ///     or
         ///     onRetry
         /// </exception>
-        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, IEnumerable<TimeSpan> sleepDurations,
-            Action<Exception, TimeSpan> onRetry)
+        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, IEnumerable<TimeSpan> sleepDurations, Action<Exception, TimeSpan> onRetry)
+        {
+            return WaitAndRetryAsync(policyBuilder, false, sleepDurations, onRetry);
+        }
+
+        /// <summary>
+        ///     Builds a <see cref="Policy" /> that will wait and retry as many times as there are provided
+        ///     <paramref name="sleepDurations" />
+        ///     calling <paramref name="onRetry" /> on each retry with the raised exception and the current sleep duration.
+        ///     On each retry, the duration to wait is the current <paramref name="sleepDurations" /> item.
+        /// </summary>
+        /// <param name="policyBuilder">The policy builder.</param>
+        /// <param name="continueOnCapturedContext">Whether to continue on a captured synchronization context.</param>
+        /// <param name="sleepDurations">The sleep durations to wait for on each retry.</param>
+        /// <param name="onRetry">The action to call on each retry.</param>
+        /// <returns>The policy instance.</returns>
+        /// <exception cref="System.ArgumentNullException">
+        ///     sleepDurations
+        ///     or
+        ///     onRetry
+        /// </exception>
+        public static Policy WaitAndRetryAsync(this PolicyBuilder policyBuilder, bool continueOnCapturedContext, IEnumerable<TimeSpan> sleepDurations, Action<Exception, TimeSpan> onRetry)
         {
             if (sleepDurations == null) throw new ArgumentNullException("sleepDurations");
             if (onRetry == null) throw new ArgumentNullException("onRetry");
@@ -203,8 +353,8 @@ namespace Polly
                 action => RetryPolicy.ImplementationAsync(
                     action,
                     policyBuilder.ExceptionPredicates,
-                    () => new RetryPolicyStateWithSleep(sleepDurations, onRetry)
-                ),
+                    () => new RetryPolicyStateWithSleep(sleepDurations, onRetry), 
+                    continueOnCapturedContext),
                 policyBuilder.ExceptionPredicates
             );
         }
diff --git a/src/Polly.Shared/Utilities/SystemClock.cs b/src/Polly.Shared/Utilities/SystemClock.cs
index adfb4b2a..2ec1e246 100644
--- a/src/Polly.Shared/Utilities/SystemClock.cs
+++ b/src/Polly.Shared/Utilities/SystemClock.cs
@@ -1,5 +1,8 @@
 ﻿using System;
 using System.Threading;
+#if SUPPORTS_ASYNC
+using System.Threading.Tasks;
+#endif
 
 namespace Polly.Utilities
 {
@@ -21,6 +24,13 @@ namespace Polly.Utilities
         /// By default this will be a call to <see cref="M:ManualResetEvent.WaitOne"/>
         /// </summary>
         public static Action<TimeSpan> Sleep = timespan => new ManualResetEvent(false).WaitOne(timespan);
+#endif
+#if SUPPORTS_ASYNC
+        /// <summary>
+        /// Allows the setting of a custom async Sleep implementation for testing.
+        /// By default this will be a call to <see cref="M:Task.Delay"/>
+        /// </summary>
+        public static Func<TimeSpan, Task> SleepAsync = Task.Delay;
 #endif
         /// <summary>
         /// Allows the setting of a custom DateTime.UtcNow implementation for testing.
@@ -38,6 +48,9 @@ namespace Polly.Utilities
             Sleep = Thread.Sleep;
 #else
             Sleep = timeSpan => new ManualResetEvent(false).WaitOne(timeSpan);
+#endif
+#if SUPPORTS_ASYNC
+            SleepAsync = Task.Delay;
 #endif
             UtcNow = () => DateTime.UtcNow;
         }
diff --git a/src/Polly.SharedSpecs/WaitAndRetryAsyncSpecs.cs b/src/Polly.SharedSpecs/WaitAndRetryAsyncSpecs.cs
index 5fa85d55..782b4abf 100644
--- a/src/Polly.SharedSpecs/WaitAndRetryAsyncSpecs.cs
+++ b/src/Polly.SharedSpecs/WaitAndRetryAsyncSpecs.cs
@@ -1,6 +1,7 @@
 ﻿using System;
 using System.Collections.Generic;
 using System.Linq;
+using System.Threading.Tasks;
 using FluentAssertions;
 using Polly.Specs.Helpers;
 using Polly.Utilities;
@@ -13,7 +14,7 @@ namespace Polly.Specs
         public WaitAndRetryAsyncSpecs()
         {
             // do nothing on call to sleep
-            SystemClock.Sleep = (_) => { };
+            SystemClock.SleepAsync = (_) => Task.FromResult(0);
         }
 
         [Fact]
@@ -230,7 +231,11 @@ namespace Polly.Specs
                    3.Seconds()
                 });
 
-            SystemClock.Sleep = span => totalTimeSlept += span.Seconds;
+            SystemClock.SleepAsync = span =>
+            {
+                totalTimeSlept += span.Seconds;
+                return Task.FromResult(0);
+            };
 
             policy.RaiseExceptionAsync<DivideByZeroException>(3);
 
@@ -252,7 +257,11 @@ namespace Polly.Specs
                    3.Seconds()
                 });
 
-            SystemClock.Sleep = span => totalTimeSlept += span.Seconds;
+            SystemClock.SleepAsync = span =>
+            {
+                totalTimeSlept += span.Seconds;
+                return Task.FromResult(0);
+            };
 
             policy.Awaiting(x => x.RaiseExceptionAsync<DivideByZeroException>(3 + 1))
                   .ShouldThrow<DivideByZeroException>();
@@ -275,7 +284,11 @@ namespace Polly.Specs
                    3.Seconds()
                 });
 
-            SystemClock.Sleep = span => totalTimeSlept += span.Seconds;
+            SystemClock.SleepAsync = span =>
+            {
+                totalTimeSlept += span.Seconds;
+                return Task.FromResult(0);
+            };
 
             policy.RaiseExceptionAsync<DivideByZeroException>(2);
 
@@ -292,7 +305,11 @@ namespace Polly.Specs
                 .Handle<DivideByZeroException>()
                 .WaitAndRetryAsync(Enumerable.Empty<TimeSpan>());
 
-            SystemClock.Sleep = span => totalTimeSlept += span.Seconds;
+            SystemClock.SleepAsync = span =>
+            {
+                totalTimeSlept += span.Seconds;
+                return Task.FromResult(0);
+            };
 
             policy.Awaiting(x => x.RaiseExceptionAsync<NullReferenceException>())
                   .ShouldThrow<NullReferenceException>();
diff --git a/src/Polly.SharedSpecs/WaitAndRetrySpecs.cs b/src/Polly.SharedSpecs/WaitAndRetrySpecs.cs
index 6b84b3f4..2ddf85d8 100644
--- a/src/Polly.SharedSpecs/WaitAndRetrySpecs.cs
+++ b/src/Polly.SharedSpecs/WaitAndRetrySpecs.cs
@@ -178,7 +178,8 @@ namespace Polly.Specs
             policy.Invoking(x => x.RaiseException<NullReferenceException>())
                   .ShouldThrow<NullReferenceException>();
         }
- [Fact]
+
+        [Fact]
         public void Should_throw_when_exception_thrown_is_not_the_specified_exception_type_async()
         {
             var policy = Policy
@@ -200,7 +201,8 @@ namespace Polly.Specs
             policy.Invoking(x => x.RaiseException<NullReferenceException>())
                   .ShouldThrow<NullReferenceException>();
         }
-  [Fact]
+
+        [Fact]
         public void Should_throw_when_exception_thrown_is_not_one_of_the_specified_exception_types_async()
         {
             var policy = Policy
@@ -269,7 +271,7 @@ namespace Polly.Specs
             var policy = Policy
                 .Handle<DivideByZeroException>(e => true)
                 .Or<ArgumentException>(e => true)
-               .WaitAndRetry(new[]
+                .WaitAndRetry(new[]
                 {
                    1.Seconds()
                 });
@@ -284,7 +286,7 @@ namespace Polly.Specs
             var policy = Policy
                 .Handle<DivideByZeroException>(e => true)
                 .Or<ArgumentException>(e => true)
-               .WaitAndRetryAsync(new[]
+                .WaitAndRetryAsync(new[]
                 {
                    1.Seconds()
                 });
@@ -329,7 +331,11 @@ namespace Polly.Specs
                    3.Seconds()
                 });
 
-            SystemClock.Sleep = span => totalTimeSlept += span.Seconds;
+            SystemClock.SleepAsync = span =>
+            {
+                totalTimeSlept += span.Seconds;
+                return Task.FromResult(0);
+            };
 
             await policy.RaiseExceptionAsync<DivideByZeroException>(3);
 
@@ -409,7 +415,11 @@ namespace Polly.Specs
                 .Handle<DivideByZeroException>()
                 .WaitAndRetryAsync(Enumerable.Empty<TimeSpan>());
 
-            SystemClock.Sleep = span => totalTimeSlept += span.Seconds;
+            SystemClock.SleepAsync = span =>
+            {
+                totalTimeSlept += span.Seconds;
+                return Task.FromResult(0);
+            };
 
             policy.Awaiting(x => x.RaiseExceptionAsync<NullReferenceException>())
                   .ShouldThrow<NullReferenceException>();
