diff --git a/Directory.Packages.props b/Directory.Packages.props
index 3a5e431d..ce5b24e4 100644
--- a/Directory.Packages.props
+++ b/Directory.Packages.props
@@ -22,7 +22,7 @@
     <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="17.6.3" />
     <PackageVersion Include="Microsoft.SourceLink.GitHub" Version="1.1.1" />
     <PackageVersion Include="MinVer" Version="4.3.0" />
-    <PackageVersion Include="Moq" Version="4.18.4" />
+    <PackageVersion Include="NSubstitute" Version="5.0.0" />
     <PackageVersion Include="Polly" Version="$(PollyVersion)" />
     <PackageVersion Include="Polly.Core" Version="$(PollyVersion)" />
     <PackageVersion Include="Polly.Extensions" Version="$(PollyVersion)" />
diff --git a/eng/Test.targets b/eng/Test.targets
index 2c270eac..a8baacb3 100644
--- a/eng/Test.targets
+++ b/eng/Test.targets
@@ -15,7 +15,7 @@
     <PackageReference Include="FluentAssertions" />
     <PackageReference Include="GitHubActionsTestLogger" />
     <PackageReference Include="Microsoft.NET.Test.Sdk" />
-    <PackageReference Include="Moq" />
+    <PackageReference Include="NSubstitute" />
     <PackageReference Include="ReportGenerator" PrivateAssets="all" />
     <PackageReference Include="xunit" />
     <PackageReference Include="xunit.runner.visualstudio" PrivateAssets="all" />
diff --git a/test/Polly.Core.Tests/CircuitBreaker/CircuitBreakerResilienceStrategyTests.cs b/test/Polly.Core.Tests/CircuitBreaker/CircuitBreakerResilienceStrategyTests.cs
index 0d2e75ac..1ccf2703 100644
--- a/test/Polly.Core.Tests/CircuitBreaker/CircuitBreakerResilienceStrategyTests.cs
+++ b/test/Polly.Core.Tests/CircuitBreaker/CircuitBreakerResilienceStrategyTests.cs
@@ -1,5 +1,5 @@
 using Microsoft.Extensions.Time.Testing;
-using Moq;
+using NSubstitute;
 using Polly.CircuitBreaker;
 using Polly.Telemetry;
 using Polly.Utils;
@@ -9,7 +9,7 @@ namespace Polly.Core.Tests.CircuitBreaker;
 public class CircuitBreakerResilienceStrategyTests : IDisposable
 {
     private readonly FakeTimeProvider _timeProvider;
-    private readonly Mock<CircuitBehavior> _behavior;
+    private readonly CircuitBehavior _behavior;
     private readonly ResilienceStrategyTelemetry _telemetry;
     private readonly CircuitBreakerStrategyOptions<int> _options;
     private readonly CircuitStateController<int> _controller;
@@ -17,15 +17,15 @@ public class CircuitBreakerResilienceStrategyTests : IDisposable
     public CircuitBreakerResilienceStrategyTests()
     {
         _timeProvider = new FakeTimeProvider();
-        _behavior = new Mock<CircuitBehavior>(MockBehavior.Strict);
-        _telemetry = TestUtilities.CreateResilienceTelemetry(Mock.Of<DiagnosticSource>());
+        _behavior = Substitute.For<CircuitBehavior>();
+        _telemetry = TestUtilities.CreateResilienceTelemetry(Substitute.For<DiagnosticSource>());
         _options = new CircuitBreakerStrategyOptions<int>();
         _controller = new CircuitStateController<int>(
             CircuitBreakerConstants.DefaultBreakDuration,
             null,
             null,
             null,
-            _behavior.Object,
+            _behavior,
             _timeProvider,
             _telemetry);
     }
@@ -58,16 +58,15 @@ public class CircuitBreakerResilienceStrategyTests : IDisposable
         await _options.ManualControl.IsolateAsync(CancellationToken.None);
         strategy.Invoking(s => s.Execute(_ => 0)).Should().Throw<IsolatedCircuitException>();
 
-        _behavior.Setup(v => v.OnCircuitClosed());
         await _options.ManualControl.CloseAsync(CancellationToken.None);
 
-        _behavior.Setup(v => v.OnActionSuccess(CircuitState.Closed));
         strategy.Invoking(s => s.Execute(_ => 0)).Should().NotThrow();
 
         _options.ManualControl.Dispose();
         strategy.Invoking(s => s.Execute(_ => 0)).Should().Throw<ObjectDisposedException>();
 
-        _behavior.VerifyAll();
+        _behavior.Received().OnCircuitClosed();
+        _behavior.Received().OnActionSuccess(CircuitState.Closed);
     }
 
     [Fact]
@@ -77,10 +76,12 @@ public class CircuitBreakerResilienceStrategyTests : IDisposable
         var strategy = Create();
         var shouldBreak = false;
 
-        _behavior.Setup(v => v.OnActionFailure(CircuitState.Closed, out shouldBreak));
+        _behavior.When(v => v.OnActionFailure(CircuitState.Closed, out Arg.Any<bool>()))
+                 .Do(x => x[1] = shouldBreak);
+
         strategy.Execute(_ => -1).Should().Be(-1);
 
-        _behavior.VerifyAll();
+        _behavior.Received().OnActionFailure(CircuitState.Closed, out Arg.Any<bool>());
     }
 
     [Fact]
@@ -89,10 +90,9 @@ public class CircuitBreakerResilienceStrategyTests : IDisposable
         _options.ShouldHandle = args => new ValueTask<bool>(args.Result is -1);
         var strategy = Create();
 
-        _behavior.Setup(v => v.OnActionSuccess(CircuitState.Closed));
         strategy.Execute(_ => 0).Should().Be(0);
 
-        _behavior.VerifyAll();
+        _behavior.Received(1).OnActionSuccess(CircuitState.Closed);
     }
 
     [Fact]
@@ -102,11 +102,12 @@ public class CircuitBreakerResilienceStrategyTests : IDisposable
         var strategy = Create();
         var shouldBreak = false;
 
-        _behavior.Setup(v => v.OnActionFailure(CircuitState.Closed, out shouldBreak));
+        _behavior.When(v => v.OnActionFailure(CircuitState.Closed, out Arg.Any<bool>()))
+                 .Do(x => x[1] = shouldBreak);
 
         strategy.Invoking(s => s.Execute<int>(_ => throw new InvalidOperationException())).Should().Throw<InvalidOperationException>();
 
-        _behavior.VerifyAll();
+        _behavior.Received().OnActionFailure(CircuitState.Closed, out Arg.Any<bool>());
     }
 
     [Fact]
@@ -117,7 +118,9 @@ public class CircuitBreakerResilienceStrategyTests : IDisposable
 
         strategy.Invoking(s => s.Execute(_ => throw new ArgumentException())).Should().Throw<ArgumentException>();
 
-        _behavior.VerifyNoOtherCalls();
+        _behavior.DidNotReceiveWithAnyArgs().OnActionFailure(default, out Arg.Any<bool>());
+        _behavior.DidNotReceiveWithAnyArgs().OnActionSuccess(default);
+        _behavior.DidNotReceiveWithAnyArgs().OnCircuitClosed();
     }
 
     public void Dispose() => _controller.Dispose();
@@ -126,10 +129,12 @@ public class CircuitBreakerResilienceStrategyTests : IDisposable
     public void Execute_Ok()
     {
         _options.ShouldHandle = _ => PredicateResult.False;
-        _behavior.Setup(v => v.OnActionSuccess(CircuitState.Closed));
 
         Create().Invoking(s => s.Execute(_ => 0)).Should().NotThrow();
+
+        _behavior.Received(1).OnActionSuccess(CircuitState.Closed);
     }
 
-    private ReactiveResilienceStrategyBridge<int> Create() => new(new CircuitBreakerResilienceStrategy<int>(_options.ShouldHandle!, _controller, _options.StateProvider, _options.ManualControl));
+    private ReactiveResilienceStrategyBridge<int> Create()
+        => new(new CircuitBreakerResilienceStrategy<int>(_options.ShouldHandle!, _controller, _options.StateProvider, _options.ManualControl));
 }
diff --git a/test/Polly.Core.Tests/CircuitBreaker/Controller/AdvancedCircuitBehaviorTests.cs b/test/Polly.Core.Tests/CircuitBreaker/Controller/AdvancedCircuitBehaviorTests.cs
index ff768ca7..def5bd3c 100644
--- a/test/Polly.Core.Tests/CircuitBreaker/Controller/AdvancedCircuitBehaviorTests.cs
+++ b/test/Polly.Core.Tests/CircuitBreaker/Controller/AdvancedCircuitBehaviorTests.cs
@@ -1,4 +1,4 @@
-using Moq;
+using NSubstitute;
 using Polly.CircuitBreaker;
 using Polly.CircuitBreaker.Health;
 
@@ -6,7 +6,7 @@ namespace Polly.Core.Tests.CircuitBreaker.Controller;
 
 public class AdvancedCircuitBehaviorTests
 {
-    private Mock<HealthMetrics> _metrics = new(MockBehavior.Strict, TimeProvider.System);
+    private HealthMetrics _metrics = Substitute.For<HealthMetrics>(TimeProvider.System);
 
     [InlineData(10, 10, 0.0, 0.1, false)]
     [InlineData(10, 10, 0.1, 0.1, true)]
@@ -21,15 +21,14 @@ public class AdvancedCircuitBehaviorTests
         double failureThreshold,
         bool expectedShouldBreak)
     {
-        _metrics.Setup(m => m.IncrementFailure());
-        _metrics.Setup(m => m.GetHealthInfo()).Returns(new HealthInfo(throughput, failureRate));
+        _metrics.GetHealthInfo().Returns(new HealthInfo(throughput, failureRate));
 
-        var behavior = new AdvancedCircuitBehavior(failureThreshold, minimumThruput, _metrics.Object);
+        var behavior = new AdvancedCircuitBehavior(failureThreshold, minimumThruput, _metrics);
 
         behavior.OnActionFailure(CircuitState.Closed, out var shouldBreak);
 
         shouldBreak.Should().Be(expectedShouldBreak);
-        _metrics.VerifyAll();
+        _metrics.Received(1).IncrementFailure();
     }
 
     [InlineData(CircuitState.Closed, true)]
@@ -39,7 +38,7 @@ public class AdvancedCircuitBehaviorTests
     [Theory]
     public void OnActionFailure_State_EnsureCorrectCalls(CircuitState state, bool shouldIncrementFailure)
     {
-        _metrics = new(MockBehavior.Loose, TimeProvider.System);
+        _metrics = Substitute.For<HealthMetrics>(TimeProvider.System);
 
         var sut = Create();
 
@@ -48,27 +47,27 @@ public class AdvancedCircuitBehaviorTests
         shouldBreak.Should().BeFalse();
         if (shouldIncrementFailure)
         {
-            _metrics.Verify(v => v.IncrementFailure(), Times.Once());
+            _metrics.Received(1).IncrementFailure();
         }
         else
         {
-            _metrics.Verify(v => v.IncrementFailure(), Times.Never());
+            _metrics.DidNotReceive().IncrementFailure();
         }
     }
 
     [Fact]
     public void OnCircuitClosed_Ok()
     {
-        _metrics = new(MockBehavior.Loose, TimeProvider.System);
+        _metrics = Substitute.For<HealthMetrics>(TimeProvider.System);
         var sut = Create();
 
         sut.OnCircuitClosed();
 
-        _metrics.Verify(v => v.Reset(), Times.Once());
+        _metrics.Received(1).Reset();
     }
 
     private AdvancedCircuitBehavior Create()
     {
-        return new AdvancedCircuitBehavior(CircuitBreakerConstants.DefaultFailureRatio, CircuitBreakerConstants.DefaultMinimumThroughput, _metrics.Object);
+        return new(CircuitBreakerConstants.DefaultFailureRatio, CircuitBreakerConstants.DefaultMinimumThroughput, _metrics);
     }
 }
diff --git a/test/Polly.Core.Tests/CircuitBreaker/Controller/CircuitStateControllerTests.cs b/test/Polly.Core.Tests/CircuitBreaker/Controller/CircuitStateControllerTests.cs
index 04115ef4..41e0961b 100644
--- a/test/Polly.Core.Tests/CircuitBreaker/Controller/CircuitStateControllerTests.cs
+++ b/test/Polly.Core.Tests/CircuitBreaker/Controller/CircuitStateControllerTests.cs
@@ -1,5 +1,5 @@
 using Microsoft.Extensions.Time.Testing;
-using Moq;
+using NSubstitute;
 using Polly.CircuitBreaker;
 using Polly.Telemetry;
 
@@ -10,7 +10,7 @@ public class CircuitStateControllerTests
     private readonly FakeTimeProvider _timeProvider = new();
 
     private readonly CircuitBreakerStrategyOptions<int> _options = new();
-    private readonly Mock<CircuitBehavior> _circuitBehavior = new(MockBehavior.Strict);
+    private readonly CircuitBehavior _circuitBehavior = Substitute.For<CircuitBehavior>();
     private readonly Action<TelemetryEventArguments> _onTelemetry = _ => { };
 
     [Fact]
@@ -56,9 +56,10 @@ public class CircuitStateControllerTests
         outcome.Value.Exception.Should().BeOfType<IsolatedCircuitException>();
 
         // now close it
-        _circuitBehavior.Setup(v => v.OnCircuitClosed());
         await controller.CloseCircuitAsync(ResilienceContextPool.Shared.Get());
         await controller.OnActionPreExecuteAsync(ResilienceContextPool.Shared.Get());
+
+        _circuitBehavior.Received().OnCircuitClosed();
         context.ResilienceEvents.Should().Contain(new ResilienceEvent(ResilienceEventSeverity.Error, "OnCircuitOpened"));
     }
 
@@ -82,7 +83,6 @@ public class CircuitStateControllerTests
         _timeProvider.Advance(TimeSpan.FromSeconds(1));
         using var controller = CreateController();
         await controller.IsolateCircuitAsync(ResilienceContextPool.Shared.Get());
-        _circuitBehavior.Setup(v => v.OnCircuitClosed());
         var context = ResilienceContextPool.Shared.Get();
 
         // act
@@ -92,7 +92,7 @@ public class CircuitStateControllerTests
         called.Should().BeTrue();
 
         await controller.OnActionPreExecuteAsync(ResilienceContextPool.Shared.Get());
-        _circuitBehavior.VerifyAll();
+        _circuitBehavior.Received().OnCircuitClosed();
         context.ResilienceEvents.Should().Contain(new ResilienceEvent(ResilienceEventSeverity.Information, "OnCircuitClosed"));
     }
 
@@ -146,18 +146,19 @@ public class CircuitStateControllerTests
 
         if (success)
         {
-            _circuitBehavior.Setup(v => v.OnActionSuccess(CircuitState.HalfOpen));
-            _circuitBehavior.Setup(v => v.OnCircuitClosed());
-
             await controller.OnActionSuccessAsync(Outcome.FromResult(0), ResilienceContextPool.Shared.Get());
             controller.CircuitState.Should().Be(CircuitState.Closed);
+
+            _circuitBehavior.Received().OnActionSuccess(CircuitState.HalfOpen);
+            _circuitBehavior.Received().OnCircuitClosed();
         }
         else
         {
-            var shouldBreak = true;
-            _circuitBehavior.Setup(v => v.OnActionFailure(CircuitState.HalfOpen, out shouldBreak));
             await controller.OnActionFailureAsync(Outcome.FromResult(0), ResilienceContextPool.Shared.Get());
             controller.CircuitState.Should().Be(CircuitState.Open);
+
+            _circuitBehavior.DidNotReceiveWithAnyArgs().OnActionSuccess(default);
+            _circuitBehavior.Received().OnActionFailure(CircuitState.HalfOpen, out _);
         }
     }
 
@@ -180,7 +181,7 @@ public class CircuitStateControllerTests
 
         AdvanceTime(_options.BreakDuration);
         bool shouldBreak = false;
-        _circuitBehavior.Setup(v => v.OnActionFailure(CircuitState.Closed, out shouldBreak)).Callback(() =>
+        _circuitBehavior.When(v => v.OnActionFailure(CircuitState.Closed, out shouldBreak)).Do((_) =>
         {
             executing.Set();
             verified.WaitOne();
@@ -245,21 +246,16 @@ public class CircuitStateControllerTests
 
         await TransitionToState(controller, state);
 
-        _circuitBehavior.Setup(v => v.OnActionSuccess(state));
-        if (expectedState == CircuitState.Closed && state != CircuitState.Closed)
-        {
-            _circuitBehavior.Setup(v => v.OnCircuitClosed());
-        }
-
         // act
         await controller.OnActionSuccessAsync(Outcome.FromResult(10), ResilienceContextPool.Shared.Get());
 
         // assert
         controller.CircuitState.Should().Be(expectedState);
-        _circuitBehavior.VerifyAll();
 
+        _circuitBehavior.Received().OnActionSuccess(state);
         if (expectedState == CircuitState.Closed && state != CircuitState.Closed)
         {
+            _circuitBehavior.Received().OnCircuitClosed();
             called.Should().BeTrue();
         }
     }
@@ -291,7 +287,9 @@ public class CircuitStateControllerTests
         using var controller = CreateController();
 
         await TransitionToState(controller, state);
-        _circuitBehavior.Setup(v => v.OnActionFailure(state, out shouldBreak));
+
+        _circuitBehavior.When(x => x.OnActionFailure(state, out Arg.Any<bool>()))
+                        .Do(x => x[1] = shouldBreak);
 
         // act
         await controller.OnActionFailureAsync(Outcome.FromResult(99), ResilienceContextPool.Shared.Get());
@@ -299,7 +297,7 @@ public class CircuitStateControllerTests
         // assert
         controller.LastHandledOutcome!.Value.Result.Should().Be(99);
         controller.CircuitState.Should().Be(expectedState);
-        _circuitBehavior.VerifyAll();
+        _circuitBehavior.Received().OnActionFailure(state, out Arg.Any<bool>());
 
         if (expectedState == CircuitState.Open && state != CircuitState.Open)
         {
@@ -324,7 +322,8 @@ public class CircuitStateControllerTests
 
         _timeProvider.SetUtcNow(utcNow);
 
-        _circuitBehavior.Setup(v => v.OnActionFailure(CircuitState.HalfOpen, out shouldBreak));
+        _circuitBehavior.When(v => v.OnActionFailure(CircuitState.HalfOpen, out Arg.Any<bool>()))
+                        .Do(x => x[1] = shouldBreak);
 
         // act
         await controller.OnActionFailureAsync(Outcome.FromResult(99), ResilienceContextPool.Shared.Get());
@@ -349,7 +348,9 @@ public class CircuitStateControllerTests
         using var controller = CreateController();
         bool shouldBreak = true;
         await TransitionToState(controller, CircuitState.Open);
-        _circuitBehavior.Setup(v => v.OnActionFailure(CircuitState.Open, out shouldBreak));
+
+        _circuitBehavior.When(v => v.OnActionFailure(CircuitState.Open, out Arg.Any<bool>()))
+                        .Do(x => x[1] = shouldBreak);
 
         // act
         await controller.OnActionFailureAsync(Outcome.FromResult(99), ResilienceContextPool.Shared.Get());
@@ -366,11 +367,12 @@ public class CircuitStateControllerTests
         using var controller = CreateController();
 
         await TransitionToState(controller, CircuitState.HalfOpen);
-        _circuitBehavior.Setup(v => v.OnActionSuccess(CircuitState.HalfOpen));
-        _circuitBehavior.Setup(v => v.OnCircuitClosed());
 
         await controller.OnActionSuccessAsync(Outcome.FromResult(0), ResilienceContextPool.Shared.Get());
         controller.CircuitState.Should().Be(CircuitState.Closed);
+
+        _circuitBehavior.Received().OnActionSuccess(CircuitState.HalfOpen);
+        _circuitBehavior.Received().OnCircuitClosed();
     }
 
     [Fact]
@@ -382,7 +384,9 @@ public class CircuitStateControllerTests
 
         await TransitionToState(controller, CircuitState.HalfOpen);
 
-        _circuitBehavior.Setup(v => v.OnActionFailure(CircuitState.HalfOpen, out shouldBreak));
+        _circuitBehavior.When(v => v.OnActionFailure(CircuitState.HalfOpen, out Arg.Any<bool>()))
+                        .Do(x => x[1] = shouldBreak);
+
         await controller.OnActionFailureAsync(Outcome.FromResult(0), context);
         controller.CircuitState.Should().Be(CircuitState.Open);
 
@@ -397,10 +401,11 @@ public class CircuitStateControllerTests
         controller.CircuitState.Should().Be(CircuitState.HalfOpen);
 
         // close circuit
-        _circuitBehavior.Setup(v => v.OnActionSuccess(CircuitState.HalfOpen));
-        _circuitBehavior.Setup(v => v.OnCircuitClosed());
         await controller.OnActionSuccessAsync(Outcome.FromResult(0), ResilienceContextPool.Shared.Get());
         controller.CircuitState.Should().Be(CircuitState.Closed);
+
+        _circuitBehavior.Received().OnActionSuccess(CircuitState.HalfOpen);
+        _circuitBehavior.Received().OnCircuitClosed();
     }
 
     [Fact]
@@ -446,7 +451,10 @@ public class CircuitStateControllerTests
     private async Task OpenCircuit(CircuitStateController<int> controller, Outcome<int>? outcome = null)
     {
         bool breakCircuit = true;
-        _circuitBehavior.Setup(v => v.OnActionFailure(CircuitState.Closed, out breakCircuit));
+
+        _circuitBehavior.When(v => v.OnActionFailure(CircuitState.Closed, out Arg.Any<bool>()))
+                        .Do(x => x[1] = breakCircuit);
+
         await controller.OnActionFailureAsync(outcome ?? Outcome.FromResult(10), ResilienceContextPool.Shared.Get().Initialize<int>(true));
     }
 
@@ -457,7 +465,7 @@ public class CircuitStateControllerTests
         _options.OnOpened,
         _options.OnClosed,
         _options.OnHalfOpened,
-        _circuitBehavior.Object,
+        _circuitBehavior,
         _timeProvider,
         TestUtilities.CreateResilienceTelemetry(_onTelemetry.Invoke));
 }
diff --git a/test/Polly.Core.Tests/CompositeStrategyBuilderContextTests.cs b/test/Polly.Core.Tests/CompositeStrategyBuilderContextTests.cs
index 7e4551a1..6cc38877 100644
--- a/test/Polly.Core.Tests/CompositeStrategyBuilderContextTests.cs
+++ b/test/Polly.Core.Tests/CompositeStrategyBuilderContextTests.cs
@@ -1,5 +1,5 @@
 using Microsoft.Extensions.Time.Testing;
-using Moq;
+using NSubstitute;
 
 namespace Polly.Core.Tests;
 
@@ -10,7 +10,7 @@ public class CompositeStrategyBuilderContextTests
     {
         var properties = new ResilienceProperties();
         var timeProvider = new FakeTimeProvider();
-        var context = new StrategyBuilderContext("builder-name", "instance", properties, "strategy-name", timeProvider, Mock.Of<DiagnosticSource>(), () => 1.0);
+        var context = new StrategyBuilderContext("builder-name", "instance", properties, "strategy-name", timeProvider, Substitute.For<DiagnosticSource>(), () => 1.0);
 
         context.BuilderName.Should().Be("builder-name");
         context.BuilderInstanceName.Should().Be("instance");
diff --git a/test/Polly.Core.Tests/CompositeStrategyBuilderTests.cs b/test/Polly.Core.Tests/CompositeStrategyBuilderTests.cs
index 3462bab7..2ef3d786 100644
--- a/test/Polly.Core.Tests/CompositeStrategyBuilderTests.cs
+++ b/test/Polly.Core.Tests/CompositeStrategyBuilderTests.cs
@@ -1,6 +1,6 @@
 using System.ComponentModel.DataAnnotations;
 using Microsoft.Extensions.Time.Testing;
-using Moq;
+using NSubstitute;
 using Polly.Retry;
 using Polly.Utils;
 
@@ -24,10 +24,10 @@ public class CompositeStrategyBuilderTests
     {
         var builder = new CompositeStrategyBuilder
         {
-            TimeProvider = Mock.Of<TimeProvider>(),
+            TimeProvider = Substitute.For<TimeProvider>(),
             Name = "dummy",
             Randomizer = () => 0.0,
-            DiagnosticSource = Mock.Of<DiagnosticSource>(),
+            DiagnosticSource = Substitute.For<DiagnosticSource>(),
             OnCreatingStrategy = _ => { },
         };
 
diff --git a/test/Polly.Core.Tests/Retry/RetryResilienceStrategyTests.cs b/test/Polly.Core.Tests/Retry/RetryResilienceStrategyTests.cs
index d9467bc8..6ef57f1e 100644
--- a/test/Polly.Core.Tests/Retry/RetryResilienceStrategyTests.cs
+++ b/test/Polly.Core.Tests/Retry/RetryResilienceStrategyTests.cs
@@ -1,6 +1,6 @@
 using FluentAssertions.Execution;
 using Microsoft.Extensions.Time.Testing;
-using Moq;
+using NSubstitute;
 using Polly.Retry;
 using Polly.Telemetry;
 using Polly.Utils;
@@ -11,12 +11,12 @@ public class RetryResilienceStrategyTests
 {
     private readonly RetryStrategyOptions _options = new();
     private readonly FakeTimeProvider _timeProvider = new();
-    private readonly Mock<DiagnosticSource> _diagnosticSource = new();
+    private readonly DiagnosticSource _diagnosticSource = Substitute.For<DiagnosticSource>();
     private ResilienceStrategyTelemetry _telemetry;
 
     public RetryResilienceStrategyTests()
     {
-        _telemetry = TestUtilities.CreateResilienceTelemetry(_diagnosticSource.Object);
+        _telemetry = TestUtilities.CreateResilienceTelemetry(_diagnosticSource);
         _options.ShouldHandle = _ => new ValueTask<bool>(false);
 
     }
@@ -290,7 +290,7 @@ public class RetryResilienceStrategyTests
         var attempts = new List<int>();
         var delays = new List<TimeSpan>();
 
-        _diagnosticSource.Setup(v => v.IsEnabled("OnRetry")).Returns(true);
+        _diagnosticSource.IsEnabled("OnRetry").Returns(true);
 
         _options.ShouldHandle = args => args.Outcome.ResultPredicateAsync(0);
         _options.RetryCount = 3;
@@ -300,7 +300,7 @@ public class RetryResilienceStrategyTests
 
         await ExecuteAndAdvance(sut);
 
-        _diagnosticSource.VerifyAll();
+        _diagnosticSource.Received(3).IsEnabled("OnRetry");
     }
 
     [Fact]
diff --git a/test/Polly.Core.Tests/Telemetry/ResilienceStrategyTelemetryTests.cs b/test/Polly.Core.Tests/Telemetry/ResilienceStrategyTelemetryTests.cs
index 22a736bf..446418be 100644
--- a/test/Polly.Core.Tests/Telemetry/ResilienceStrategyTelemetryTests.cs
+++ b/test/Polly.Core.Tests/Telemetry/ResilienceStrategyTelemetryTests.cs
@@ -1,30 +1,30 @@
-using Moq;
+using NSubstitute;
 using Polly.Telemetry;
 
 namespace Polly.Core.Tests.Telemetry;
 
 public class ResilienceStrategyTelemetryTests
 {
-    private readonly Mock<DiagnosticSource> _diagnosticSource = new(MockBehavior.Strict);
+    private readonly DiagnosticSource _diagnosticSource = Substitute.For<DiagnosticSource>();
 
     public ResilienceStrategyTelemetryTests() => _sut = new(new ResilienceTelemetrySource(
         "builder",
         "instance",
         new ResilienceProperties(),
-        "strategy-name"), _diagnosticSource.Object);
+        "strategy-name"), _diagnosticSource);
 
     private readonly ResilienceStrategyTelemetry _sut;
 
     [Fact]
     public void Report_NoOutcome_OK()
     {
-        _diagnosticSource.Setup(o => o.IsEnabled("dummy-event")).Returns(true);
+        _diagnosticSource.IsEnabled("dummy-event").Returns(true);
         _diagnosticSource
-            .Setup(o => o.Write("dummy-event", It.Is<object>(obj => obj is TelemetryEventArguments)))
-            .Callback<string, object>((_, obj) =>
+            .When(o => o.Write("dummy-event", Arg.Is<object>(obj => obj is TelemetryEventArguments)))
+            .Do((p) =>
             {
-                obj.Should().BeOfType<TelemetryEventArguments>();
-                var args = (TelemetryEventArguments)obj;
+                p[1].Should().BeOfType<TelemetryEventArguments>();
+                var args = (TelemetryEventArguments)p[1];
 
                 args.Event.EventName.Should().Be("dummy-event");
                 args.Event.Severity.Should().Be(ResilienceEventSeverity.Warning);
@@ -38,18 +38,17 @@ public class ResilienceStrategyTelemetryTests
 
         _sut.Report(new(ResilienceEventSeverity.Warning, "dummy-event"), ResilienceContextPool.Shared.Get(), new TestArguments());
 
-        _diagnosticSource.VerifyAll();
+        _diagnosticSource.Received().Write("dummy-event", Arg.Is<object>(obj => obj is TelemetryEventArguments));
     }
 
     [Fact]
     public void Report_NoOutcomeWhenNotSubscribed_None()
     {
-        _diagnosticSource.Setup(o => o.IsEnabled("dummy-event")).Returns(false);
+        _diagnosticSource.IsEnabled("dummy-event").Returns(false);
 
         _sut.Report(new(ResilienceEventSeverity.Warning, "dummy-event"), ResilienceContextPool.Shared.Get(), new TestArguments());
 
-        _diagnosticSource.VerifyAll();
-        _diagnosticSource.VerifyNoOtherCalls();
+        _diagnosticSource.DidNotReceiveWithAnyArgs().Write(default!, default);
     }
 
     [Fact]
@@ -66,13 +65,13 @@ public class ResilienceStrategyTelemetryTests
     [Fact]
     public void Report_Outcome_OK()
     {
-        _diagnosticSource.Setup(o => o.IsEnabled("dummy-event")).Returns(true);
+        _diagnosticSource.IsEnabled("dummy-event").Returns(true);
         _diagnosticSource
-            .Setup(o => o.Write("dummy-event", It.Is<object>(obj => obj is TelemetryEventArguments)))
-            .Callback<string, object>((_, obj) =>
+            .When(o => o.Write("dummy-event", Arg.Is<object>(obj => obj is TelemetryEventArguments)))
+            .Do((obj) =>
             {
-                obj.Should().BeOfType<TelemetryEventArguments>();
-                var args = (TelemetryEventArguments)obj;
+                obj[1].Should().BeOfType<TelemetryEventArguments>();
+                var args = (TelemetryEventArguments)obj[1];
 
                 args.Event.EventName.Should().Be("dummy-event");
                 args.Event.Severity.Should().Be(ResilienceEventSeverity.Warning);
@@ -87,30 +86,28 @@ public class ResilienceStrategyTelemetryTests
         var context = ResilienceContextPool.Shared.Get();
         _sut.Report(new(ResilienceEventSeverity.Warning, "dummy-event"), new OutcomeArguments<int, TestArguments>(context, Outcome.FromResult(99), new TestArguments()));
 
-        _diagnosticSource.VerifyAll();
+        _diagnosticSource.Received().Write("dummy-event", Arg.Is<object>(obj => obj is TelemetryEventArguments));
     }
 
     [Fact]
     public void Report_SeverityNone_Skipped()
     {
-        _diagnosticSource.Setup(o => o.IsEnabled("dummy-event")).Returns(true);
+        _diagnosticSource.IsEnabled("dummy-event").Returns(true);
 
         var context = ResilienceContextPool.Shared.Get();
         _sut.Report(new(ResilienceEventSeverity.None, "dummy-event"), new OutcomeArguments<int, TestArguments>(context, Outcome.FromResult(99), new TestArguments()));
         _sut.Report(new(ResilienceEventSeverity.None, "dummy-event"), ResilienceContextPool.Shared.Get(), new TestArguments());
 
-        _diagnosticSource.VerifyAll();
-        _diagnosticSource.VerifyNoOtherCalls();
+        _diagnosticSource.DidNotReceiveWithAnyArgs().Write(default!, default);
     }
 
     [Fact]
     public void Report_OutcomeWhenNotSubscribed_None()
     {
-        _diagnosticSource.Setup(o => o.IsEnabled("dummy-event")).Returns(false);
+        _diagnosticSource.IsEnabled("dummy-event").Returns(false);
         var context = ResilienceContextPool.Shared.Get();
         _sut.Report(new(ResilienceEventSeverity.Warning, "dummy-event"), new OutcomeArguments<int, TestArguments>(context, Outcome.FromResult(10), new TestArguments()));
 
-        _diagnosticSource.VerifyAll();
-        _diagnosticSource.VerifyNoOtherCalls();
+        _diagnosticSource.DidNotReceiveWithAnyArgs().Write(default!, default);
     }
 }
diff --git a/test/Polly.Core.Tests/Telemetry/TelemetryUtilTests.cs b/test/Polly.Core.Tests/Telemetry/TelemetryUtilTests.cs
index fd138a72..67e13f4e 100644
--- a/test/Polly.Core.Tests/Telemetry/TelemetryUtilTests.cs
+++ b/test/Polly.Core.Tests/Telemetry/TelemetryUtilTests.cs
@@ -1,4 +1,4 @@
-using Moq;
+using NSubstitute;
 using Polly.Telemetry;
 
 namespace Polly.Core.Tests.Telemetry;
@@ -20,7 +20,7 @@ public class TelemetryUtilTests
     public void CreateResilienceTelemetry_DiagnosticSourceFromProperties_Ok()
     {
         var props = new ResilienceProperties();
-        var source = Mock.Of<DiagnosticSource>();
+        var source = Substitute.For<DiagnosticSource>();
 
         var telemetry = TelemetryUtil.CreateTelemetry(source, "builder", "instance", props, "strategy-name");
 
diff --git a/test/Polly.Core.Tests/Timeout/TimeoutResilienceStrategyTests.cs b/test/Polly.Core.Tests/Timeout/TimeoutResilienceStrategyTests.cs
index 72b423b7..978bdfb1 100644
--- a/test/Polly.Core.Tests/Timeout/TimeoutResilienceStrategyTests.cs
+++ b/test/Polly.Core.Tests/Timeout/TimeoutResilienceStrategyTests.cs
@@ -1,5 +1,5 @@
 using Microsoft.Extensions.Time.Testing;
-using Moq;
+using NSubstitute;
 using Polly.Telemetry;
 using Polly.Timeout;
 
@@ -13,11 +13,11 @@ public class TimeoutResilienceStrategyTests : IDisposable
     private readonly CancellationTokenSource _cancellationSource;
     private readonly TimeSpan _delay = TimeSpan.FromSeconds(12);
 
-    private readonly Mock<DiagnosticSource> _diagnosticSource = new();
+    private readonly DiagnosticSource _diagnosticSource = Substitute.For<DiagnosticSource>();
 
     public TimeoutResilienceStrategyTests()
     {
-        _telemetry = TestUtilities.CreateResilienceTelemetry(_diagnosticSource.Object);
+        _telemetry = TestUtilities.CreateResilienceTelemetry(_diagnosticSource);
         _options = new TimeoutStrategyOptions();
         _cancellationSource = new CancellationTokenSource();
     }
@@ -52,7 +52,7 @@ public class TimeoutResilienceStrategyTests : IDisposable
     [Fact]
     public async Task Execute_EnsureOnTimeoutCalled()
     {
-        _diagnosticSource.Setup(v => v.IsEnabled("OnTimeout")).Returns(true);
+        _diagnosticSource.IsEnabled("OnTimeout").Returns(true);
 
         var called = false;
         SetTimeout(_delay);
@@ -78,7 +78,7 @@ public class TimeoutResilienceStrategyTests : IDisposable
         .AsTask()).Should().ThrowAsync<TimeoutRejectedException>();
 
         called.Should().BeTrue();
-        _diagnosticSource.VerifyAll();
+        _diagnosticSource.Received().IsEnabled("OnTimeout");
     }
 
     [MemberData(nameof(Execute_NoTimeout_Data))]
@@ -164,7 +164,7 @@ public class TimeoutResilienceStrategyTests : IDisposable
 
         onTimeoutCalled.Should().BeFalse();
 
-        _diagnosticSource.Verify(v => v.IsEnabled("OnTimeout"), Times.Never());
+        _diagnosticSource.DidNotReceive().IsEnabled("OnTimeout");
     }
 
     [Fact]
@@ -202,16 +202,15 @@ public class TimeoutResilienceStrategyTests : IDisposable
 
         var sut = CreateSut();
 
-        var mockSynchronizationContext = new Mock<SynchronizationContext>(MockBehavior.Strict);
+        var mockSynchronizationContext = Substitute.For<SynchronizationContext>();
         mockSynchronizationContext
-            .Setup(x => x.Post(It.IsAny<SendOrPostCallback>(), It.IsAny<object>()))
-            .Callback<SendOrPostCallback, object>((callback, state) => callback(state));
+            .When(x => x.Post(Arg.Any<SendOrPostCallback>(), Arg.Any<object>()))
+            .Do((p) => ((SendOrPostCallback)p[1])(p[2]));
 
-        mockSynchronizationContext
-            .Setup(x => x.CreateCopy())
-            .Returns(mockSynchronizationContext.Object);
+        mockSynchronizationContext.CreateCopy()
+            .Returns(mockSynchronizationContext);
 
-        SynchronizationContext.SetSynchronizationContext(mockSynchronizationContext.Object);
+        SynchronizationContext.SetSynchronizationContext(mockSynchronizationContext);
 
         // Act
         try
@@ -230,7 +229,7 @@ public class TimeoutResilienceStrategyTests : IDisposable
         }
 
         // Assert
-        mockSynchronizationContext.Verify(x => x.Post(It.IsAny<SendOrPostCallback>(), It.IsAny<object>()), Times.Never());
+        mockSynchronizationContext.DidNotReceiveWithAnyArgs().Post(default!, default);
     }
 
     private void SetTimeout(TimeSpan timeout) => _options.TimeoutGenerator = args => new ValueTask<TimeSpan>(timeout);
diff --git a/test/Polly.Core.Tests/Utils/CancellationTokenSourcePoolTests.cs b/test/Polly.Core.Tests/Utils/CancellationTokenSourcePoolTests.cs
index 75fe6db8..44e2433c 100644
--- a/test/Polly.Core.Tests/Utils/CancellationTokenSourcePoolTests.cs
+++ b/test/Polly.Core.Tests/Utils/CancellationTokenSourcePoolTests.cs
@@ -1,5 +1,4 @@
 using Microsoft.Extensions.Time.Testing;
-using Moq;
 using Polly.Utils;
 
 namespace Polly.Core.Tests.Utils;
@@ -93,9 +92,5 @@ public class CancellationTokenSourcePoolTests
         cts.IsCancellationRequested.Should().BeFalse();
     }
 
-    private static TimeProvider GetTimeProvider(object timeProvider) => timeProvider switch
-    {
-        Mock<TimeProvider> m => m.Object,
-        _ => (TimeProvider)timeProvider
-    };
+    private static TimeProvider GetTimeProvider(object timeProvider) => (TimeProvider)timeProvider;
 }
diff --git a/test/Polly.Core.Tests/Utils/DisposeHelperTests.cs b/test/Polly.Core.Tests/Utils/DisposeHelperTests.cs
index c7795f00..f149b35f 100644
--- a/test/Polly.Core.Tests/Utils/DisposeHelperTests.cs
+++ b/test/Polly.Core.Tests/Utils/DisposeHelperTests.cs
@@ -1,4 +1,4 @@
-using Moq;
+using NSubstitute;
 using Polly.Utils;
 
 namespace Polly.Core.Tests.Utils;
@@ -28,11 +28,13 @@ public class DisposeHelperTests
     [Theory]
     public async Task Dispose_AsyncDisposable_Ok(bool synchronous)
     {
-        var disposable = new Mock<IAsyncDisposable>();
+        var disposable = Substitute.For<IAsyncDisposable>();
         bool disposed = false;
-        disposable.Setup(v => v.DisposeAsync()).Returns(default(ValueTask)).Callback(() => disposed = true);
 
-        await DisposeHelper.TryDisposeSafeAsync(disposable.Object, synchronous);
+        disposable.When(async (p) => await p.DisposeAsync())
+                  .Do((_) => disposed = true);
+
+        await DisposeHelper.TryDisposeSafeAsync(disposable, synchronous);
 
         disposed.Should().BeTrue();
     }
@@ -42,10 +44,10 @@ public class DisposeHelperTests
     [Theory]
     public async Task Dispose_DisposeThrows_ExceptionHandled(bool synchronous)
     {
-        var disposable = new Mock<IAsyncDisposable>();
-        disposable.Setup(v => v.DisposeAsync()).Throws(new InvalidOperationException());
+        var disposable = Substitute.For<IAsyncDisposable>();
+        disposable.When(async v => await v.DisposeAsync()).Do((_) => throw new InvalidOperationException());
 
-        await disposable.Object.Invoking(async _ => await DisposeHelper.TryDisposeSafeAsync(disposable.Object, synchronous)).Should().NotThrowAsync();
+        await disposable.Invoking(async _ => await DisposeHelper.TryDisposeSafeAsync(disposable, synchronous)).Should().NotThrowAsync();
     }
 
     [InlineData(true)]
diff --git a/test/Polly.Extensions.Tests/Utils/OptionsReloadHelperTests.cs b/test/Polly.Extensions.Tests/Utils/OptionsReloadHelperTests.cs
index e0717cf9..bc410917 100644
--- a/test/Polly.Extensions.Tests/Utils/OptionsReloadHelperTests.cs
+++ b/test/Polly.Extensions.Tests/Utils/OptionsReloadHelperTests.cs
@@ -1,5 +1,5 @@
 using Microsoft.Extensions.Options;
-using Moq;
+using NSubstitute;
 using Polly.Utils;
 
 namespace Polly.Extensions.Tests.Utils;
@@ -9,14 +9,14 @@ public class OptionsReloadHelperTests
     [Fact]
     public void Ctor_NamedOptions()
     {
-        var monitor = new Mock<IOptionsMonitor<string>>();
+        var disposable = Substitute.For<IDisposable>();
+        var monitor = Substitute.For<IOptionsMonitor<string>>();
 
-        monitor
-            .Setup(m => m.OnChange(It.IsAny<Action<string, string?>>()))
-            .Returns(() => Mock.Of<IDisposable>());
+        monitor.OnChange(Arg.Any<Action<string, string?>>())
+               .Returns(disposable);
 
-        var helper = new OptionsReloadHelper<string>(monitor.Object, "name");
+        var helper = new OptionsReloadHelper<string>(monitor, "name");
 
-        monitor.VerifyAll();
+        monitor.Received().OnChange(Arg.Any<Action<string, string?>>());
     }
 }
diff --git a/test/Polly.RateLimiting.Tests/OnRateLimiterRejectedArgumentsTests.cs b/test/Polly.RateLimiting.Tests/OnRateLimiterRejectedArgumentsTests.cs
index 40dddb10..00279343 100644
--- a/test/Polly.RateLimiting.Tests/OnRateLimiterRejectedArgumentsTests.cs
+++ b/test/Polly.RateLimiting.Tests/OnRateLimiterRejectedArgumentsTests.cs
@@ -1,5 +1,5 @@
 using System.Threading.RateLimiting;
-using Moq;
+using NSubstitute;
 
 namespace Polly.RateLimiting.Tests;
 
@@ -8,7 +8,7 @@ public class OnRateLimiterRejectedArgumentsTests
     [Fact]
     public void Ctor_Ok()
     {
-        var args = new OnRateLimiterRejectedArguments(ResilienceContextPool.Shared.Get(), Mock.Of<RateLimitLease>(), TimeSpan.FromSeconds(1));
+        var args = new OnRateLimiterRejectedArguments(ResilienceContextPool.Shared.Get(), Substitute.For<RateLimitLease>(), TimeSpan.FromSeconds(1));
 
         args.Context.Should().NotBeNull();
         args.Lease.Should().NotBeNull();
diff --git a/test/Polly.RateLimiting.Tests/RateLimiterCompositeStrategyBuilderExtensionsTests.cs b/test/Polly.RateLimiting.Tests/RateLimiterCompositeStrategyBuilderExtensionsTests.cs
index 10e36ecf..c9d6689d 100644
--- a/test/Polly.RateLimiting.Tests/RateLimiterCompositeStrategyBuilderExtensionsTests.cs
+++ b/test/Polly.RateLimiting.Tests/RateLimiterCompositeStrategyBuilderExtensionsTests.cs
@@ -1,6 +1,6 @@
 using System.ComponentModel.DataAnnotations;
 using System.Threading.RateLimiting;
-using Moq;
+using NSubstitute;
 
 namespace Polly.RateLimiting.Tests;
 
@@ -26,7 +26,7 @@ public class RateLimiterCompositeStrategyBuilderExtensionsTests
         },
         builder =>
         {
-            var expected = Mock.Of<RateLimiter>();
+            var expected = Substitute.For<RateLimiter>();
             builder.AddRateLimiter(expected);
             AssertRateLimiter(builder, hasEvents: false, limiter => limiter.Should().Be(expected));
         }
@@ -123,7 +123,7 @@ public class RateLimiterCompositeStrategyBuilderExtensionsTests
         var strategy = new CompositeStrategyBuilder()
             .AddRateLimiter(new RateLimiterStrategyOptions
             {
-                RateLimiter = ResilienceRateLimiter.Create(Mock.Of<RateLimiter>())
+                RateLimiter = ResilienceRateLimiter.Create(Substitute.For<RateLimiter>())
             })
             .Build();
 
@@ -139,7 +139,7 @@ public class RateLimiterCompositeStrategyBuilderExtensionsTests
         {
             strategy.OnLeaseRejected.Should().NotBeNull();
             strategy
-                .OnLeaseRejected!(new OnRateLimiterRejectedArguments(ResilienceContextPool.Shared.Get(), Mock.Of<RateLimitLease>(), null))
+                .OnLeaseRejected!(new OnRateLimiterRejectedArguments(ResilienceContextPool.Shared.Get(), Substitute.For<RateLimitLease>(), null))
                 .Preserve().GetAwaiter().GetResult();
         }
         else
@@ -159,7 +159,7 @@ public class RateLimiterCompositeStrategyBuilderExtensionsTests
         {
             strategy.OnLeaseRejected.Should().NotBeNull();
             strategy
-                .OnLeaseRejected!(new OnRateLimiterRejectedArguments(ResilienceContextPool.Shared.Get(), Mock.Of<RateLimitLease>(), null))
+                .OnLeaseRejected!(new OnRateLimiterRejectedArguments(ResilienceContextPool.Shared.Get(), Substitute.For<RateLimitLease>(), null))
                 .Preserve().GetAwaiter().GetResult();
         }
         else
diff --git a/test/Polly.RateLimiting.Tests/RateLimiterResilienceStrategyTests.cs b/test/Polly.RateLimiting.Tests/RateLimiterResilienceStrategyTests.cs
index 53763ece..1dae568a 100644
--- a/test/Polly.RateLimiting.Tests/RateLimiterResilienceStrategyTests.cs
+++ b/test/Polly.RateLimiting.Tests/RateLimiterResilienceStrategyTests.cs
@@ -1,14 +1,13 @@
 using System.Threading.RateLimiting;
-using Moq;
-using Moq.Protected;
+using NSubstitute;
 
 namespace Polly.RateLimiting.Tests;
 
 public class RateLimiterResilienceStrategyTests
 {
-    private readonly Mock<RateLimiter> _limiter = new(MockBehavior.Strict);
-    private readonly Mock<RateLimitLease> _lease = new(MockBehavior.Strict);
-    private readonly Mock<DiagnosticSource> _diagnosticSource = new();
+    private readonly RateLimiter _limiter = Substitute.For<RateLimiter>();
+    private readonly RateLimitLease _lease = Substitute.For<RateLimitLease>();
+    private readonly DiagnosticSource _diagnosticSource = Substitute.For<DiagnosticSource>();
     private Func<OnRateLimiterRejectedArguments, ValueTask>? _event;
 
     [Fact]
@@ -18,14 +17,13 @@ public class RateLimiterResilienceStrategyTests
     }
 
     [Fact]
-    public void Execute_HappyPath()
+    public async Task Execute_HappyPath()
     {
         using var cts = new CancellationTokenSource();
 
         SetupLimiter(cts.Token);
 
-        _lease.Setup(v => v.IsAcquired).Returns(true);
-        _lease.Protected().Setup("Dispose", exactParameterMatch: true, true);
+        _lease.IsAcquired.Returns(true);
 
         Create().Should().NotBeNull();
 
@@ -33,8 +31,8 @@ public class RateLimiterResilienceStrategyTests
 
         strategy.Execute(_ => { }, cts.Token);
 
-        _limiter.VerifyAll();
-        _lease.VerifyAll();
+        await _limiter.ReceivedWithAnyArgs().AcquireAsync(default, default);
+        _lease.Received().Dispose();
     }
 
     [InlineData(false, true)]
@@ -44,8 +42,8 @@ public class RateLimiterResilienceStrategyTests
     [Theory]
     public async Task Execute_LeaseRejected(bool hasEvents, bool hasRetryAfter)
     {
-        _diagnosticSource.Setup(v => v.IsEnabled("OnRateLimiterRejected")).Returns(true);
-        _diagnosticSource.Setup(v => v.Write("OnRateLimiterRejected", It.Is<object>(obj => obj != null)));
+        _diagnosticSource.IsEnabled("OnRateLimiterRejected").Returns(true);
+        _diagnosticSource.Write("OnRateLimiterRejected", Arg.Is<object>(obj => obj != null));
 
         object? metadata = hasRetryAfter ? TimeSpan.FromSeconds(123) : null;
 
@@ -53,16 +51,20 @@ public class RateLimiterResilienceStrategyTests
         var eventCalled = false;
         SetupLimiter(cts.Token);
 
-        _lease.Setup(v => v.IsAcquired).Returns(false);
-        _lease.Protected().Setup("Dispose", exactParameterMatch: true, true);
-        _lease.Setup(v => v.TryGetMetadata("RETRY_AFTER", out metadata)).Returns(hasRetryAfter);
+        _lease.IsAcquired.Returns(false);
+        _lease.TryGetMetadata("RETRY_AFTER", out Arg.Any<object?>())
+              .Returns(x =>
+              {
+                  x[1] = hasRetryAfter ? metadata : null;
+                  return hasRetryAfter;
+              });
 
         if (hasEvents)
         {
             _event = args =>
             {
                 args.Context.Should().NotBeNull();
-                args.Lease.Should().Be(_lease.Object);
+                args.Lease.Should().Be(_lease);
                 args.RetryAfter.Should().Be((TimeSpan?)metadata);
                 eventCalled = true;
                 return default;
@@ -81,29 +83,33 @@ public class RateLimiterResilienceStrategyTests
 
         outcome.Exception!.StackTrace.Should().Contain("Execute_LeaseRejected");
 
-        _limiter.VerifyAll();
-        _lease.VerifyAll();
         eventCalled.Should().Be(hasEvents);
 
-        _diagnosticSource.VerifyAll();
+        await _limiter.ReceivedWithAnyArgs().AcquireAsync(default, default);
+        _lease.Received().Dispose();
     }
 
-    private void SetupLimiter(CancellationToken token) => _limiter
-                .Protected()
-                .Setup<ValueTask<RateLimitLease>>("AcquireAsyncCore", 1, token)
-                .Returns(new ValueTask<RateLimitLease>(_lease.Object));
+    private void SetupLimiter(CancellationToken token)
+    {
+        var result = new ValueTask<RateLimitLease>(_lease);
+        _limiter
+            .GetType()
+            .GetMethod("AcquireAsyncCore", BindingFlags.NonPublic | BindingFlags.Instance)!
+            .Invoke(_limiter, new object[] { 1, token })
+            .Returns(result);
+    }
 
     private RateLimiterResilienceStrategy Create()
     {
         var builder = new CompositeStrategyBuilder
         {
-            DiagnosticSource = _diagnosticSource.Object
+            DiagnosticSource = _diagnosticSource
         };
 
         return (RateLimiterResilienceStrategy)builder
             .AddRateLimiter(new RateLimiterStrategyOptions
             {
-                RateLimiter = ResilienceRateLimiter.Create(_limiter.Object),
+                RateLimiter = ResilienceRateLimiter.Create(_limiter),
                 OnRejected = _event
             })
             .Build();
diff --git a/test/Polly.RateLimiting.Tests/ResilienceRateLimiterTests.cs b/test/Polly.RateLimiting.Tests/ResilienceRateLimiterTests.cs
index fd3ef8a3..439657c6 100644
--- a/test/Polly.RateLimiting.Tests/ResilienceRateLimiterTests.cs
+++ b/test/Polly.RateLimiting.Tests/ResilienceRateLimiterTests.cs
@@ -1,6 +1,5 @@
 ï»¿using System.Threading.RateLimiting;
-using Moq;
-using Moq.Protected;
+using NSubstitute;
 
 namespace Polly.RateLimiting.Tests;
 
@@ -9,29 +8,40 @@ public class ResilienceRateLimiterTests
     [Fact]
     public async Task Create_RateLimiter_Ok()
     {
-        var lease = Mock.Of<RateLimitLease>();
-        var limiterMock = new Mock<RateLimiter>(MockBehavior.Strict);
-        limiterMock.Protected().Setup<ValueTask<RateLimitLease>>("AcquireAsyncCore", 1, default(CancellationToken)).ReturnsAsync(lease);
+        var lease = Substitute.For<RateLimitLease>();
+        var leaseTask = new ValueTask<RateLimitLease>(lease);
 
-        var limiter = ResilienceRateLimiter.Create(limiterMock.Object);
+        var rateLimiter = Substitute.For<RateLimiter>();
+        rateLimiter
+            .GetType()
+            .GetMethod("AcquireAsyncCore", BindingFlags.NonPublic | BindingFlags.Instance)!
+            .Invoke(rateLimiter, new object[] { 1, default(CancellationToken) })
+            .Returns(leaseTask);
+
+        var limiter = ResilienceRateLimiter.Create(rateLimiter);
 
         (await limiter.AcquireAsync(ResilienceContextPool.Shared.Get())).Should().Be(lease);
         limiter.Limiter.Should().NotBeNull();
-        limiterMock.VerifyAll();
     }
 
     [Fact]
     public async Task Create_PartitionedRateLimiter_Ok()
     {
         var context = ResilienceContextPool.Shared.Get();
-        var lease = Mock.Of<RateLimitLease>();
-        var limiterMock = new Mock<PartitionedRateLimiter<ResilienceContext>>(MockBehavior.Strict);
-        limiterMock.Protected().Setup<ValueTask<RateLimitLease>>("AcquireAsyncCore", context, 1, default(CancellationToken)).ReturnsAsync(lease);
 
-        var limiter = ResilienceRateLimiter.Create(limiterMock.Object);
+        var lease = Substitute.For<RateLimitLease>();
+        var leaseTask = new ValueTask<RateLimitLease>(lease);
+
+        var rateLimiter = Substitute.For<PartitionedRateLimiter<ResilienceContext>>();
+        rateLimiter
+            .GetType()
+            .GetMethod("AcquireAsyncCore", BindingFlags.NonPublic | BindingFlags.Instance)!
+            .Invoke(rateLimiter, new object[] { context, 1, default(CancellationToken) })
+            .Returns(leaseTask);
+
+        var limiter = ResilienceRateLimiter.Create(rateLimiter);
 
         (await limiter.AcquireAsync(context)).Should().Be(lease);
         limiter.PartitionedLimiter.Should().NotBeNull();
-        limiterMock.VerifyAll();
     }
 }
diff --git a/test/Polly.Specs/Polly.Specs.csproj b/test/Polly.Specs/Polly.Specs.csproj
index f0990bae..9f173f8b 100644
--- a/test/Polly.Specs/Polly.Specs.csproj
+++ b/test/Polly.Specs/Polly.Specs.csproj
@@ -17,7 +17,7 @@
     <Using Include="FluentAssertions" />
     <Using Include="FluentAssertions.Execution" />
     <Using Include="FluentAssertions.Extensions" />
-    <Using Include="Moq" />
+    <Using Include="NSubstitute" />
     <Using Include="Polly.Specs.Helpers" />
     <Using Include="Polly.Specs.Helpers.Bulkhead" />
     <Using Include="Polly.Specs.Helpers.Caching" />
diff --git a/test/Polly.Specs/Registry/PolicyRegistrySpecs.cs b/test/Polly.Specs/Registry/PolicyRegistrySpecs.cs
index b1e0d5c4..1fd8f1fe 100644
--- a/test/Polly.Specs/Registry/PolicyRegistrySpecs.cs
+++ b/test/Polly.Specs/Registry/PolicyRegistrySpecs.cs
@@ -442,13 +442,13 @@ public class PolicyRegistrySpecs
     [Fact]
     public void Constructor_Called_With_A_Registry_Parameter_Should_Assign_The_Passed_In_Registry_To_The_Registry_Field()
     {
-        var testDictionary = new Mock<IDictionary<string, IsPolicy>>();
-        var testRegistry = new PolicyRegistry(testDictionary.Object);
+        var testDictionary = Substitute.For<IDictionary<string, IsPolicy>>();
+        var testRegistry = new PolicyRegistry(testDictionary);
 
         // Generally, using reflection is a bad practice, but we are accepting it given we own the implementation.
         var registryField = typeof(PolicyRegistry).GetField("_registry", BindingFlags.NonPublic | BindingFlags.GetField | BindingFlags.Instance)!;
         var registryFieldValue = registryField.GetValue(testRegistry);
-        registryFieldValue.Should().Be(testDictionary.Object);
+        registryFieldValue.Should().Be(testDictionary);
     }
 
     [Fact]
diff --git a/test/Polly.Specs/Registry/ReadOnlyPolicyRegistrySpecs.cs b/test/Polly.Specs/Registry/ReadOnlyPolicyRegistrySpecs.cs
index 029ccaa8..09a09496 100644
--- a/test/Polly.Specs/Registry/ReadOnlyPolicyRegistrySpecs.cs
+++ b/test/Polly.Specs/Registry/ReadOnlyPolicyRegistrySpecs.cs
@@ -256,12 +256,12 @@ public class ReadOnlyPolicyRegistrySpecs
     [Fact]
     public void Calling_The_GetEnumerator_Method_Returning_A_IEnumerator_Of_KeyValuePair_Of_String_And_IsPolicy_Calls_The_Registrys_GetEnumerator_Method()
     {
-        var testDictionary = new Mock<IDictionary<string, IsPolicy>>();
-        var testRegistry = new PolicyRegistry(testDictionary.Object);
+        var testDictionary = Substitute.For<IDictionary<string, IsPolicy>>();
+        var testRegistry = new PolicyRegistry(testDictionary);
 
         testRegistry.GetEnumerator();
 
-        testDictionary.Verify(x => x.GetEnumerator(), Times.Once);
+        testDictionary.Received(1).GetEnumerator();
     }
 
     #endregion
diff --git a/test/Polly.TestUtils/Polly.TestUtils.csproj b/test/Polly.TestUtils/Polly.TestUtils.csproj
index a8bdb89c..e47d1495 100644
--- a/test/Polly.TestUtils/Polly.TestUtils.csproj
+++ b/test/Polly.TestUtils/Polly.TestUtils.csproj
@@ -13,6 +13,6 @@
     <Using Remove="System.Net.Http" />
     <ProjectReference Include="..\..\src\Polly.Core\Polly.Core.csproj" />
     <PackageReference Include="Microsoft.Extensions.Logging" />
-    <PackageReference Include="Moq" />
+    <PackageReference Include="NSubstitute" />
   </ItemGroup>
 </Project>
diff --git a/test/Polly.TestUtils/TestUtilities.cs b/test/Polly.TestUtils/TestUtilities.cs
index 763eb175..2e8d7839 100644
--- a/test/Polly.TestUtils/TestUtilities.cs
+++ b/test/Polly.TestUtils/TestUtilities.cs
@@ -1,6 +1,6 @@
 using System.Diagnostics.Metrics;
 using Microsoft.Extensions.Logging;
-using Moq;
+using NSubstitute;
 using Polly.Telemetry;
 
 namespace Polly.TestUtils;
@@ -46,11 +46,10 @@ public static class TestUtilities
     public static ILoggerFactory CreateLoggerFactory(out FakeLogger logger)
     {
         logger = new FakeLogger();
-        var loggerFactory = new Mock<ILoggerFactory>(MockBehavior.Strict);
-        loggerFactory.Setup(v => v.CreateLogger("Polly")).Returns(logger);
-        loggerFactory.Setup(v => v.Dispose());
+        var loggerFactory = Substitute.For<ILoggerFactory>();
+        loggerFactory.CreateLogger("Polly").Returns(logger);
 
-        return loggerFactory.Object;
+        return loggerFactory;
     }
 
     public static IDisposable EnablePollyMetering(ICollection<MeteringEvent> events)
