diff --git a/accepted/calc-constants.md b/accepted/calc-constants.md
index 637c79a..9483247 100644
--- a/accepted/calc-constants.md
+++ b/accepted/calc-constants.md
@@ -86,7 +86,7 @@ A number is _degenerate_ if its value is degenerate.
 This proposal adds <code>| [\<ident-token>]</code> to the `CalcValue`
 production.
 
-[\<calc-constant>]: https://drafts.csswg.org/css-syntax-3/#ident-token-diagram
+[\<ident-token>]: https://drafts.csswg.org/css-syntax-3/#ident-token-diagram
 
 ## Semantics
 
diff --git a/spec/types/calculation.md b/spec/types/calculation.md
index d76e92c..79ce8a9 100644
--- a/spec/types/calculation.md
+++ b/spec/types/calculation.md
@@ -12,6 +12,7 @@
     * [Calculation](#calculation)
     * [`CalculationOperation`](#calculationoperation)
     * [`CalculationInterpolation`](#calculationinterpolation)
+    * [`Number`](#number)
 * [Procedures](#procedures)
   * [Simplifying a Calculation](#simplifying-a-calculation)
   * [Simplifying a `CalculationValue`](#simplifying-a-calculationvalue)
@@ -49,9 +50,12 @@ The grammar for this production is:
 &#32;                       | FunctionExpression⁵
 &#32;                       | Number
 &#32;                       | Variable†
+&#32;                       | [\<ident-token>]
 **ParenthesizedVar**      ::= '(' 'var('¹ ArgumentInvocation ')' ')'
 </pre></x>
 
+[\<ident-token>]: https://drafts.csswg.org/css-syntax-3/#ident-token-diagram
+
 1: The strings `calc(`, `clamp(`, and `var(` are matched case-insensitively.
 
 2: A `CalcArgument` is only parsed as an `InterpolatedDeclarationValue` if it
@@ -165,6 +169,8 @@ To serialize a `CalculationOperation`:
   * the operator is `"*"` or `"-"` and the right value is a
     `CalculationOperation` with operator `"+"` or `"-"`, or
   * the operator is `"/"` and the right value is a `CalculationOperation`,
+  * the operator is `"/"` and the right value is a degenerate number with one or
+    more units.
 
   emit `"("` followed by `right` followed by `")"`. Otherwise, emit `right`.
 
@@ -172,6 +178,23 @@ To serialize a `CalculationOperation`:
 
 To serialize a `CalculationInterpolation`, emit its `value`.
 
+#### `Number`
+
+To serialize a `Number` within a `CalculationExpression`:
+
+* If the number is [degenerate]:
+
+  * If the number has more than one numerator unit, or more than zero denominator
+    units, throw an error.
+
+  * Otherwise, [convert the number to a calculation], then serialize the
+    resulting calculation's sole argument.
+
+  [degenerate]: number.md#degenerate-number
+  [convert the number to a calculation]: number.md#converting-a-number-to-a-calculation
+
+* Otherwise, serialize the number as normal.
+
 ## Procedures
 
 ### Simplifying a Calculation
@@ -374,6 +397,25 @@ To evaluate a `CalcValue` production `value` into a `CalculationValue` object:
   > transparency, so that `$var: fn(); calc($var)` works the same as
   > `calc(fn())`.
 
+* If `value` is case-insensitively equal to `pi`, return 3.141592653589793.
+
+  > This is the closest double approximation of the mathematical constant π.
+
+* If `value` is case-insensitively equal to `e`, return 2.718281828459045.
+
+  > This is the closest double approximation of the mathematical constant e.
+
+* If `value` is case-insensitively equal to `infinity`, return the double
+  `Infinity`.
+
+* If `value` is case-insensitively equal to `-infinity`, return the double
+  `-Infinity`.
+
+* If `value` is case-insensitively equal to `nan`, return the double `NaN`.
+
+* If `value` is any other `<identifier>`, return an `UnquotedString` with
+  `value` as its contents.
+
 ### `ParenthesizedVar`
 
 > If a `var()` is written directly within parentheses, it's necessary to
diff --git a/spec/types/number.md b/spec/types/number.md
index 80f5607..c849a09 100644
--- a/spec/types/number.md
+++ b/spec/types/number.md
@@ -4,6 +4,7 @@
 
 * [Definitions](#definitions)
   * [Double](#double)
+  * [Degenerate Number](#degenerate-number)
   * [Conversion Factors](#conversion-factors)
   * [Set of Units](#set-of-units)
   * [Compatible Units](#compatible-units)
@@ -24,10 +25,12 @@
     * [Multiplication](#multiplication)
     * [Modulo](#modulo)
     * [Negation](#negation)
+  * [Serialization](#serialization)
 * [Procedures](#procedures)
   * [Converting a Number to a Unit](#converting-a-number-to-a-unit)
   * [Matching Two Numbers' Units](#matching-two-numbers-units)
   * [Simplifying a Number](#simplifying-a-number)
+  * [Converting a Number to a Calculation](#converting-a-number-to-a-calculation)
 
 ## Definitions
 
@@ -46,6 +49,12 @@ as defined by [IEEE 754 2019], §3.2-3.3.
 > This is the standard 64-bit floating point representation, defined as
 > `binary64` in [IEEE 754 2019], §3.6.
 
+### Degenerate Number
+
+The doubles `Infinity`, `-Infinity`, and `NaN` are _degenerate_.
+
+A number is _degenerate_ if its value is degenerate.
+
 ### Conversion Factors
 
 Certain units have conversion factors that define how they can be converted to
@@ -360,6 +369,25 @@ Let `number` be a number. To determine `-number`, return a number whose value is
 the result of `negate(number)` as defined by [IEEE 754 2019], §5.5.1; and whose
 units are the same as `number`'s.
 
+### Serialization
+
+To serialize a number to CSS:
+
+* If the number has more than one numerator unit, or more than zero denominator
+  units, throw an error.
+
+* If the number is degenerate, [convert it to a calculation] then serialize that
+  to CSS.
+
+* Otherwise:
+
+  * Emit a string that can be parsed as a [`<number-token>`] with the
+    same value as the number.
+
+    [`<number-token>`]: https://www.w3.org/TR/css-syntax-3/#typedef-number-token
+
+  * If the number has a numerator unit, emit that unit.
+
 ## Procedures
 
 ### Converting a Number to a Unit
@@ -435,3 +463,37 @@ number with simplified units.
 * Return the result of [converting `number` to `newUnits`].
 
   [converting `number` to `newUnits`]: #converting-a-number-to-units
+
+### Converting a Number to a Calculation
+
+Given a number `number`, this procedure returns a CSS-compatible calculation
+that represents the same numeric value.
+
+* If `number`'s value is `Infinity`, let `value` be an `UnquotedString` whose
+  `value` is `'infinity'`.
+
+* Otherwise, if `number`'s value is `-Infinity`, let `value` be an
+  `UnquotedString` whose `value` is `'-infinity'`.
+
+* Otherwise, if `number`'s value is `NaN`, let `value` be an `UnquotedString`
+  whose `value` is `'NaN'`.
+
+* Otherwise, let `value` be a `CalculationValue` whose value is `number` without
+  units.
+
+* For each unit `unit` in `number`'s numerator units:
+
+  * Set `value` to a `CalculationOperation` with `operator` set to `'*'`, `left`
+    set to `value`, and `right` set to a number with value 1 and unit `unit`.
+
+* For each unit `unit` in `number`'s denominator units:
+
+  * Set `value` to a `CalculationOperation` with `operator` set to `'/'`, `left`
+    set to `value`, and `right` set to a number with value 1 and unit `unit`.
+
+* Return a `Calculation` with `name` set to `'calc'` and arguments set to
+  `[value]`.
+
+> Currently the logic for serializing multiple numerator or denominator units is
+> unused, but it's likely to be useful later when determining whether/how to
+> serialize numbers with complex units.
