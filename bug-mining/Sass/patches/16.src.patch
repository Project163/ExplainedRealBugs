diff --git a/accepted/module-system.changes.md b/accepted/module-system.changes.md
index 6e3ef37..0a681d5 100644
--- a/accepted/module-system.changes.md
+++ b/accepted/module-system.changes.md
@@ -9,6 +9,13 @@
   (including comments) to the same location, rather than splitting it up if a
   comment appeared above a `@use`.
 
+* Forbid diamond extensions from interacting with one another. That is, if two
+  modules use the same upstream modules but don't use one another, ensure that
+  they cannot extend one another's selectors.
+
+* Explicitly indicate that only selectors explicitly written by hand are exempt
+  from being optimized away when resolving extensions.
+
 * Always add `!global` variables to a module's variable set, even if those
   variable declarations aren't evaluated.
 
diff --git a/accepted/module-system.md b/accepted/module-system.md
index 52f7c7e..b806774 100644
--- a/accepted/module-system.md
+++ b/accepted/module-system.md
@@ -52,6 +52,7 @@ mindâ€”these will be called out explicitly in non-normative block-quoted asides.
   * [Determining Namespaces](#determining-namespaces)
   * [Loading Modules](#loading-modules)
   * [Resolving Extensions](#resolving-extensions)
+  * [Updating Extensions](#updating-extensions)
   * [Resolving a `file:` URL](#resolving-a-file-url)
   * [Resolving a `file:` URL for Extensions](#resolving-a-file-url-for-extensions)
 * [Semantics](#semantics)
@@ -794,35 +795,59 @@ CSS for *all* modules transitively used or forwarded by `starting-module`.
   meaning that style rules at different points in the CSS tree are always
   considered different even if their contents are the same.
 
+* Let `new-extensions` be an empty map from modules to sets of extensions.
+
 * Let `extended` be the subgraph of the [module graph](#module-graph) containing
   modules that are transitively reachable from `starting-module`.
 
 * For each module `domestic` in `extended`, in reverse [topological][] order:
 
-  * Let `foreign-modules` be the set of modules used by `domestic`, as well as
-    the set of modules transitively used or forwarded by those modules.
+  * Let `downstream` be the set of modules that use `domestic`, as well as the
+    set of modules that use a module that forwards `domestic`.
+
+    > This excludes modules that *only* forward `domestic` without using it as
+    > well. `@extend` only applies to used CSS, not forwarded CSS.
+
+  * For each style rule `rule` in `domestic`'s CSS:
+
+    * Let `selector` be the result of applying `domestic`'s extensions to
+      `rule`'s selector.
+
+    * Let `selector-lists` be an empty set of selector lists.
+
+    * For each module `foreign` in `downstream`:
+
+      * Let `extended-selector` be the result of applying
+        `new-extensions[foreign]` to `selector`.
 
-    > This excludes modules that are *only* accessible from `domestic` because
-    > it forwarded them. `@extend` only applies to used CSS, not forwarded CSS.
+        > `new-extensions[foreign]` is guaranteed to be populated at this point
+        > because `extended` is traversed in reverse topological order, which
+        > means that `foreign`'s own extensions will already have been resolved
+        > by the time we start working on modules upstream of it.
 
-  * For each module in `foreign-modules`, in reverse [topological][] order:
+      * Add `selector` to `selector-lists`.
 
-    * For each style rule `rule` in `foreign`'s CSS:
+    * Set `new-selectors[rule]` to a selector that matches the union of all
+      elements matched by selectors in `selector-lists`. This selector must obey
+      [the specificity laws of extend][] relative to the selectors from which it
+      was generated.
 
-      * Set `new-selectors[rule]` to the result of applying `domestic`'s
-        extensions to `new-selectors[rule]`.
+      [the specificity laws of extend]: ../spec/at-rules/extend#specificity
 
-        > This overwrites the previous value of `new-selectors[rule]`.
+      > Implementations are expected to trim redundant selectors from
+      > `selector-lists` as much as possible. For the purposes of the first law
+      > of extend, "the original extendee" is *only* the selectors in `rule`'s
+      > selector. The new complex selectors in `selector` generated from
+      > `domestic`'s extensions don't count as "original", and may be optimized
+      > away.
 
-        > `new-selectors[rule]` is guaranteed to exist at this point because
-        > `extended` is traversed in reverse topological order, which means that
-        > `foreign`'s own extensions will already have been resolved by the time
-        > we start working on its dependers.
+    * For every extension `extension` whose extender appears in `rule`'s
+      selector:
 
-  * For each style rule `rule` in `domestic`:
+      * For every complex selector `complex` in `new-selectors[rule]`:
 
-    * Set `new-selectors[rule]` to the result of applying `domestic`'s
-      extensions to `rule`'s selector.
+        * Add a copy of `extension` with its extender replaced by `complex` to
+          `new-extensions[domestic]`.
 
 * Let `css` be an empty CSS tree.
 
