<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 09:01:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[ZOOKEEPER-2184] Zookeeper Client should re-resolve hosts when connection attempts fail</title>
                <link>https://issues.apache.org/jira/browse/ZOOKEEPER-2184</link>
                <project id="12310801" key="ZOOKEEPER">ZooKeeper</project>
                    <description>&lt;p&gt;Testing in a Docker environment with a single Kafka instance using a single Zookeeper instance. Restarting the Zookeeper container will cause it to receive a new IP address. Kafka will never be able to reconnect to Zookeeper and will hang indefinitely. Updating DNS or /etc/hosts with the new IP address will not help the client to reconnect as the zookeeper/client/StaticHostProvider resolves the connection string hosts at creation time and never re-resolves.&lt;/p&gt;

&lt;p&gt;A solution would be for the client to notice that connection attempts fail and attempt to re-resolve the hostnames in the connectString.&lt;/p&gt;</description>
                <environment>&lt;p&gt;Ubuntu 14.04 host, Docker containers for Zookeeper &amp;amp; Kafka&lt;/p&gt;</environment>
        <key id="12828194">ZOOKEEPER-2184</key>
            <summary>Zookeeper Client should re-resolve hosts when connection attempts fail</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="andor">Andor Molnar</assignee>
                                    <reporter username="rthille">Robert P. Thille</reporter>
                        <labels>
                            <label>easyfix</label>
                            <label>patch</label>
                            <label>pull-request-available</label>
                    </labels>
                <created>Thu, 7 May 2015 23:46:12 +0000</created>
                <updated>Fri, 3 Apr 2020 22:45:57 +0000</updated>
                            <resolved>Fri, 22 Jun 2018 22:11:10 +0000</resolved>
                                    <version>3.4.6</version>
                    <version>3.4.7</version>
                    <version>3.4.8</version>
                    <version>3.4.9</version>
                    <version>3.4.10</version>
                    <version>3.5.0</version>
                    <version>3.5.1</version>
                    <version>3.5.2</version>
                    <version>3.5.3</version>
                    <version>3.4.11</version>
                                    <fixVersion>3.6.0</fixVersion>
                    <fixVersion>3.4.13</fixVersion>
                    <fixVersion>3.5.5</fixVersion>
                                    <component>java client</component>
                        <due></due>
                            <votes>16</votes>
                                    <watches>42</watches>
                                                    <progress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                            <timeestimate seconds="0">0h</timeestimate>
                            <timespent seconds="39000">10h 50m</timespent>
                                <comments>
                            <comment id="14601157" author="guy.moshkowich" created="Thu, 25 Jun 2015 13:30:12 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=bhavanki&quot; class=&quot;user-hover&quot; rel=&quot;bhavanki&quot;&gt;bhavanki&lt;/a&gt;:&lt;br/&gt;
Hi Bill,&lt;br/&gt;
I want to try and fix this defect and would like to ask you for a review on my proposal.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;What is the issue?&lt;/b&gt;&lt;br/&gt;
ZK client resolve the host name to ip&apos;s when it starts i.e., not when it tries to reconnect to the ZK cluster.&lt;br/&gt;
When restarting ZooKeeper Dockers containers - the ip address of the ZooKeeper server might change (at least this is my understanding), causing the client fail reconnecting to the cluster.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Proposed fix:&lt;/b&gt;&lt;br/&gt;
Have &lt;em&gt;StaticHostProvider.next(int)&lt;/em&gt; resolve the host addresses of  serverAddresses at the start of the method.&lt;br/&gt;
This method is called from &lt;em&gt;SendThread.startConnect()&lt;/em&gt; and &lt;em&gt;SendThread.pingRwServer()&lt;/em&gt; which are used for re-connections flow.&lt;/p&gt;

&lt;p&gt;Any thoughts?&lt;/p&gt;</comment>
                            <comment id="14969721" author="rthille" created="Thu, 22 Oct 2015 19:24:54 +0000"  >&lt;p&gt;I&apos;ve modified StaticHostProvider to track whether &apos;next()&apos; has been called twice in a row without an intervening call to &apos;onconnected()&apos; and attempt to re-resolve the IP address for the (apparent) connection failure.&lt;/p&gt;</comment>
                            <comment id="14969727" author="rthille" created="Thu, 22 Oct 2015 19:26:01 +0000"  >&lt;p&gt;The submitted patch is against the branch-3.4 branch only.&lt;/p&gt;</comment>
                            <comment id="14969869" author="hadoopqa" created="Thu, 22 Oct 2015 20:49:48 +0000"  >&lt;p&gt;-1 overall.  Here are the results of testing the latest attachment &lt;br/&gt;
  &lt;a href=&quot;http://issues.apache.org/jira/secure/attachment/12768117/ZOOKEEPER-2184.patch&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://issues.apache.org/jira/secure/attachment/12768117/ZOOKEEPER-2184.patch&lt;/a&gt;&lt;br/&gt;
  against trunk revision 1709293.&lt;/p&gt;

&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 7 new or modified tests.&lt;/p&gt;

&lt;p&gt;    -1 patch.  The patch command could not apply the patch.&lt;/p&gt;

&lt;p&gt;Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/2924//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/2924//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="14970999" author="fpj" created="Fri, 23 Oct 2015 13:45:30 +0000"  >&lt;p&gt;Hi &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rthille&quot; class=&quot;user-hover&quot; rel=&quot;rthille&quot;&gt;rthille&lt;/a&gt;, Thanks for the patch. I have a few comments and concerns about this patch:&lt;/p&gt;

&lt;ol&gt;
	&lt;li&gt;I think it would be better to not track connectedSinceNext and try to resolve addresses again after spinning over the list of servers, perhaps right after where we do a Thread.sleep(spinDelay), line 111 after applying your patch.&lt;/li&gt;
	&lt;li&gt;I&apos;m not sure why you deleted that block of code in the constructor of StaticHostProvider.&lt;/li&gt;
	&lt;li&gt;The change in ZxidRolloverTest.java doesn&apos;t seem to be part of this patch.&lt;/li&gt;
&lt;/ol&gt;
</comment>
                            <comment id="14971000" author="fpj" created="Fri, 23 Oct 2015 13:46:05 +0000"  >&lt;p&gt;Cancelling due to comments.&lt;/p&gt;</comment>
                            <comment id="14971379" author="rthille" created="Fri, 23 Oct 2015 17:10:49 +0000"  >&lt;p&gt;For &quot;1&quot; is the change you suggest in order to reduce the latency of going to the &apos;next()&apos; server?  That makes sense.  Ideally, I&apos;d love to kick off a thread to do the resolution and immediately return the next server, but I&apos;m a C/Python programmer, not a Java programmer, so I&apos;m not going there &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;For 2, I&apos;ll have to re-run through it when I get a chance (later today probably), but I believe that that code converts hostnames to IP addresses, so later on we don&apos;t have the original hostnames in order to re-resolve.&lt;/p&gt;

&lt;p&gt;For 3, yeah, I think I changed that because I was seeing the ERROR() output for something that was obviously expected and not an error and that was distracting me from the real errors I was seeing during development.  I&apos;ll remove that from the next patch.&lt;/p&gt;</comment>
                            <comment id="14995806" author="rgs" created="Sun, 8 Nov 2015 21:04:13 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fpj&quot; class=&quot;user-hover&quot; rel=&quot;fpj&quot;&gt;fpj&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rthille&quot; class=&quot;user-hover&quot; rel=&quot;rthille&quot;&gt;rthille&lt;/a&gt;: moving this to 3.4.8 (happy to help with the review when you&apos;ve sorted the above comments) &lt;/p&gt;</comment>
                            <comment id="15422598" author="rakeshr" created="Tue, 16 Aug 2016 11:13:43 +0000"  >&lt;p&gt;I am moving this out to 3.4.10 for now.&lt;/p&gt;</comment>
                            <comment id="15517160" author="fpj" created="Fri, 23 Sep 2016 18:15:30 +0000"  >&lt;p&gt;I&apos;m sorry for losing track of this issue, it is important and not hard to fix, we should do it soon.&lt;/p&gt;</comment>
                            <comment id="15517173" author="ryan p" created="Fri, 23 Sep 2016 18:22:04 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rthille&quot; class=&quot;user-hover&quot; rel=&quot;rthille&quot;&gt;rthille&lt;/a&gt; Any chance you want to pick back up on this where you left off? If not do you mind if run with it? &lt;/p&gt;</comment>
                            <comment id="15822864" author="githubbot" created="Sat, 14 Jan 2017 17:00:35 +0000"  >&lt;p&gt;GitHub user fpj opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184&quot; title=&quot;Zookeeper Client should re-resolve hosts when connection attempts fail&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2184&quot;&gt;&lt;del&gt;ZOOKEEPER-2184&lt;/del&gt;&lt;/a&gt;: Zookeeper Client should re-resolve hosts when connection attempts fail&lt;/p&gt;

&lt;p&gt;    This is a version of the patch for ZK-2184 for the 3.4 branch, compatible with Java 6.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/fpj/zookeeper&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/fpj/zookeeper&lt;/a&gt; ZK-2184&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #150&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit fbaa47e3a96f166cfae45070b0724780f13714e9&lt;br/&gt;
Author: fpj &amp;lt;fpj@apache.org&amp;gt;&lt;br/&gt;
Date:   2017-01-14T16:58:15Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184&quot; title=&quot;Zookeeper Client should re-resolve hosts when connection attempts fail&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2184&quot;&gt;&lt;del&gt;ZOOKEEPER-2184&lt;/del&gt;&lt;/a&gt;: Zookeeper Client should re-resolve hosts when connection attempts fail&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15822867" author="githubbot" created="Sat, 14 Jan 2017 17:04:50 +0000"  >&lt;p&gt;Github user fpj commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    The error is expected because we haven&apos;t setup QA to build out of the 3.4 branch.&lt;/p&gt;</comment>
                            <comment id="15822883" author="githubbot" created="Sat, 14 Jan 2017 17:58:20 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96120333&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96120333&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,12 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if ( ia != null ) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Silly nit: space around expression. &lt;/p&gt;</comment>
                            <comment id="15822884" author="githubbot" created="Sat, 14 Jan 2017 17:58:20 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96120303&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96120303&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,12 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This line could be part of the @return tag, no?&lt;/p&gt;</comment>
                            <comment id="15822885" author="githubbot" created="Sat, 14 Jan 2017 17:58:20 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96120265&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96120265&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -45,6 +45,9 @@&lt;/p&gt;

&lt;p&gt;         private int currentIndex = -1;&lt;/p&gt;

&lt;p&gt;    +    // Don&apos;t re-resolve on first next() call&lt;br/&gt;
    +    private boolean connectedSinceNext = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Sincere question: it is worth making this field &lt;b&gt;volatile&lt;/b&gt;?&lt;/p&gt;</comment>
                            <comment id="15822886" author="githubbot" created="Sat, 14 Jan 2017 17:58:20 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96120356&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96120356&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,12 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if ( ia != null ) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.indexOf( &apos;:&apos; ));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Extra space?&lt;/p&gt;</comment>
                            <comment id="15822889" author="githubbot" created="Sat, 14 Jan 2017 18:02:12 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96121135&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96121135&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,12 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if ( ia != null ) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.indexOf( &apos;:&apos; ));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) &lt;/p&gt;
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) {&lt;br/&gt;
    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);&lt;br/&gt;
    +                            if (!serverAddresses.contains(newAddr)) &lt;/p&gt;
{
    +                                serverAddresses.add(newAddr);
    +                            }
&lt;p&gt;    +                        }&lt;br/&gt;
    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) &lt;/p&gt;
{
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);
    +                }
&lt;p&gt;    +            }&lt;br/&gt;
    +        }&lt;br/&gt;
             ++currentIndex;&lt;br/&gt;
    +        connectedSinceNext = false;&lt;br/&gt;
             if (currentIndex == serverAddresses.size()) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    As `serverAddresses.size()` cannot be 0 (per constructor checking) this if condition and line 137 could be rewritten as:&lt;br/&gt;
    ``&lt;br/&gt;
       currentIndex = currentIndex % serverAddresses.size();&lt;br/&gt;
    ``&lt;/p&gt;

&lt;p&gt;    or even &lt;br/&gt;
    ``&lt;br/&gt;
    currentIndex = ++currentIndex % serverAddresses.size();&lt;br/&gt;
    ``&lt;br/&gt;
    Eliminating the need of line 137 too. &lt;/p&gt;

&lt;p&gt;    On master, branch-3.4 and branch-3.5. *&lt;b&gt;Just a silly optimization, tough.&lt;/b&gt;* &lt;/p&gt;</comment>
                            <comment id="15822976" author="githubbot" created="Sat, 14 Jan 2017 22:34:58 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96125997&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96125997&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -45,6 +45,9 @@&lt;/p&gt;

&lt;p&gt;         private int currentIndex = -1;&lt;/p&gt;

&lt;p&gt;    +    // Don&apos;t re-resolve on first next() call&lt;br/&gt;
    +    private boolean connectedSinceNext = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    All calls to `next` and `onConnected` are from the `sendThread`. I don&apos;t see a reason for making volatile, unless we are doing it defensively. Let me know if I&apos;m missing anything.&lt;/p&gt;

&lt;p&gt;    Note that this pull request is for the 3.4 branch, we need a different patch for 3.5 and master.&lt;/p&gt;</comment>
                            <comment id="15823099" author="fpj" created="Sun, 15 Jan 2017 10:34:34 +0000"  >&lt;p&gt;I took a stab at a pull request for the 3.4 branch and I&apos;d appreciate some feedback. It is easy to miss some important detail with this hostname/address manipulation, so if anyone has a chance to double check what I&apos;ve done, I&apos;d appreciate.&lt;/p&gt;

&lt;p&gt;For the 3.4 branch, we promise compatibility with Java 6, so the patch does not immediately apply because it uses &lt;tt&gt;getHostString&lt;/tt&gt;, which is available only from Java 7. Consequently, I have added some code to get around that.&lt;/p&gt;

&lt;p&gt;For the 3.5 branch, we will need a different patch because of the reconfiguration changes to &lt;tt&gt;StaticHostProvider&lt;/tt&gt;. I&apos;ll work on it once the 3.4 patch gets a +1.&lt;/p&gt;</comment>
                            <comment id="15823445" author="githubbot" created="Mon, 16 Jan 2017 04:28:28 +0000"  >&lt;p&gt;Github user rakeshadr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96163423&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96163423&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) {&lt;br/&gt;
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Please use {} instead of string concatenation. Also, for better debugging, can we pass &apos;e&apos; object as argument to the logger instead of concat the exception message.&lt;/p&gt;</comment>
                            <comment id="15823446" author="githubbot" created="Mon, 16 Jan 2017 04:28:49 +0000"  >&lt;p&gt;Github user rakeshadr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96163440&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96163440&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I failed to find any test case which covers the newly added condition, could you please point me to that. Thanks!&lt;/p&gt;</comment>
                            <comment id="15823523" author="githubbot" created="Mon, 16 Jan 2017 06:29:02 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96170041&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96170041&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) {&lt;br/&gt;
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Should we create an unresolved address like what we did on server side `recreateSocketAddresses` if we can&apos;t resolve the address? If the address is not resolvable but maybe it is still usable?&lt;/p&gt;</comment>
                            <comment id="15823525" author="githubbot" created="Mon, 16 Jan 2017 06:30:08 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96170084&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96170084&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Java 6 has getHostString, but it&apos;s package private. Use reflection can access that. Maybe we should use the library version instead?&lt;/p&gt;</comment>
                            <comment id="15823528" author="githubbot" created="Mon, 16 Jan 2017 06:37:44 +0000"  >&lt;p&gt;Github user hanm commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Does C client has similar issue?&lt;/p&gt;

&lt;p&gt;    Also, &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184&quot; title=&quot;Zookeeper Client should re-resolve hosts when connection attempts fail&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2184&quot;&gt;&lt;del&gt;ZOOKEEPER-2184&lt;/del&gt;&lt;/a&gt; looks like a dup of &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-338&quot; title=&quot;zk hosts should be resolved periodically for loadbalancing amongst zk servers.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-338&quot;&gt;ZOOKEEPER-338&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="15823951" author="githubbot" created="Mon, 16 Jan 2017 13:17:16 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96226819&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96226819&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -45,6 +45,9 @@&lt;/p&gt;

&lt;p&gt;         private int currentIndex = -1;&lt;/p&gt;

&lt;p&gt;    +    // Don&apos;t re-resolve on first next() call&lt;br/&gt;
    +    private boolean connectedSinceNext = true;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    My reasoning was only defensively, but on a 2nd look, it would be overkill. So, no problem without being volatile, imo.&lt;/p&gt;</comment>
                            <comment id="15823954" author="githubbot" created="Mon, 16 Jan 2017 13:18:27 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96227005&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96227005&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) {&lt;br/&gt;
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +1&lt;/p&gt;</comment>
                            <comment id="15826190" author="githubbot" created="Tue, 17 Jan 2017 15:12:06 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96431605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96431605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,12 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I&apos;ve added a phrase to the return tag.&lt;/p&gt;</comment>
                            <comment id="15826196" author="githubbot" created="Tue, 17 Jan 2017 15:21:27 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96433850&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96433850&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) {&lt;br/&gt;
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I don&apos;t think I can do both, see the API docs of slf4j:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://www.slf4j.org/api/org/slf4j/Logger.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.slf4j.org/api/org/slf4j/Logger.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    In the case you are, tell me which one is your favorite. I&apos;d say the curly braces.&lt;/p&gt;</comment>
                            <comment id="15826277" author="githubbot" created="Tue, 17 Jan 2017 15:45:28 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96439377&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96439377&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    We can do it, but I&apos;m not super convinced we should because we are essentially using a method with undocumented API. Perhaps it does the same as the one in Java 7, with the difference that it is public, but I&apos;m worried that there could be some correctness issue involved. Do you know more about it?&lt;/p&gt;

&lt;p&gt;    In any case, I&apos;m going to push the changes so that we see how it looks like.&lt;/p&gt;</comment>
                            <comment id="15826295" author="githubbot" created="Tue, 17 Jan 2017 15:57:01 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96442215&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96442215&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) {&lt;br/&gt;
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If the `StaticHostProvider` constructor didn&apos;t throw an `UnknownHostException`, then I&apos;d think that all names and addresses we have are good. I&apos;m not sure what could cause an `UnknownHostException` in `next()` other than some transient error. If that&apos;s right, then I&apos;m not sure we should be adding or removing anything.&lt;/p&gt;</comment>
                            <comment id="15826359" author="githubbot" created="Tue, 17 Jan 2017 16:39:37 +0000"  >&lt;p&gt;Github user rakeshadr commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96453176&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96453176&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) {&lt;br/&gt;
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    &lt;a href=&quot;https://www.slf4j.org/api/org/slf4j/Logger.html#warn(org.slf4j.Marker&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.slf4j.org/api/org/slf4j/Logger.html#warn(org.slf4j.Marker&lt;/a&gt;, java.lang.String, java.lang.Throwable)&lt;/p&gt;

&lt;p&gt;    Can we do like,&lt;br/&gt;
    LOG.warn(&quot;Cannot re-resolve server: {}, exception: &quot;, curAddr, e);&lt;/p&gt;</comment>
                            <comment id="15826844" author="githubbot" created="Tue, 17 Jan 2017 21:22:07 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96509432&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96509432&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    instead of `null` checking `ia` couldn&apos;t we use `addr.isUnresolved()`?&lt;/p&gt;</comment>
                            <comment id="15826845" author="githubbot" created="Tue, 17 Jan 2017 21:22:07 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96512625&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96512625&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    In the case where during the construction of the `StaticHostProvider` we add a host H1 which resolves to addresses A,B,C. Then at some point in the future A goes offline and the DNS system has changed H1 to resolve to hosts D,E,F. With the current code wouldn&apos;t `serverAddresses` now contain hosts B,C,D,E,F instead of only hosts D,E,F?&lt;/p&gt;

&lt;p&gt;    Is this something even worth fixing?&lt;/p&gt;</comment>
                            <comment id="15826846" author="githubbot" created="Tue, 17 Jan 2017 21:22:07 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96509843&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96509843&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,12 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: Can we swap the first two lines of this comment, as the reader does not know what class getHostString belongs to until he/she reaches line 2?&lt;/p&gt;</comment>
                            <comment id="15827498" author="githubbot" created="Wed, 18 Jan 2017 06:34:59 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96574584&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96574584&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    OK, it is a reasonable concern of using package private API via reflection and I honestly don&apos;t know the implementation difference between Java 6 / 7 regarding getHostString - let&apos;s stick to explicit implementation in this file.&lt;/p&gt;</comment>
                            <comment id="15827499" author="githubbot" created="Wed, 18 Jan 2017 06:35:36 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96574629&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96574629&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +                    }&lt;br/&gt;
    +                } catch (UnknownHostException e) {&lt;br/&gt;
    +                    LOG.warn(&quot;Cannot re-resolve server: &quot; + curAddr + &quot; UnknownHostException: &quot; + e);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    OK.&lt;/p&gt;</comment>
                            <comment id="15828145" author="githubbot" created="Wed, 18 Jan 2017 14:15:37 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96642443&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96642443&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @hanm have a look at this, please.&lt;/p&gt;</comment>
                            <comment id="15828458" author="githubbot" created="Wed, 18 Jan 2017 17:53:48 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96694626&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96694626&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yup, we could: &lt;a href=&quot;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/net/InetSocketAddress.java#258&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/net/InetSocketAddress.java#258&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15828471" author="githubbot" created="Wed, 18 Jan 2017 18:01:23 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96696184&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96696184&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +86,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    As we are adding new addresses into `serverAddresses`, would it make sense to re-shuffle the list?&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    Collections.shuffle(this.serverAddresses);&lt;br/&gt;
    ```&lt;br/&gt;
    As we did in constructor???&lt;/p&gt;</comment>
                            <comment id="15828497" author="githubbot" created="Wed, 18 Jan 2017 18:16:42 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96699234&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96699234&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It might be better to wrap the reflection in an abstraction in a static block in this file so inspection of the class will be done only once, save some runtime inspection cycles.&lt;/p&gt;</comment>
                            <comment id="15828501" author="githubbot" created="Wed, 18 Jan 2017 18:18:00 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96699514&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96699514&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try 
{
    +                Method m = InetSocketAddress.class.getDeclaredMethod(&quot;getHostString&quot;);
    +                m.setAccessible(true);
    +                resolvedAddresses = InetAddress.getAllByName((String) m.invoke(address));
    +            }
&lt;p&gt; catch (IllegalAccessException e) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Maybe we can catch multiple exceptions in a single shot - such as `catch(IllegalAccessException | NoSuchMethodException | InvocationTargetException e)` to save some typings, given the exception handling logic is exact the same.&lt;/p&gt;</comment>
                            <comment id="15828504" author="githubbot" created="Wed, 18 Jan 2017 18:18:34 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96699622&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96699622&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try 
{
    +                Method m = InetSocketAddress.class.getDeclaredMethod(&quot;getHostString&quot;);
    +                m.setAccessible(true);
    +                resolvedAddresses = InetAddress.getAllByName((String) m.invoke(address));
    +            }
&lt;p&gt; catch (IllegalAccessException e) &lt;/p&gt;
{
    +                resolvedAddresses = InetAddress.getAllByName(getHostString(address));
    +            } catch (NoSuchMethodException e) {    +                resolvedAddresses = InetAddress.getAllByName(getHostString(address));    +            }
&lt;p&gt; catch (InvocationTargetException e) &lt;/p&gt;
{
    +                resolvedAddresses = InetAddress.getAllByName(getHostString(address));
    +            }
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The signature of getDeclaredMethod said it also could throw SecurityException, not sure if we should catch it or not here.&lt;/p&gt;</comment>
                            <comment id="15828516" author="githubbot" created="Wed, 18 Jan 2017 18:28:18 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96701932&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96701932&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try 
{
    +                Method m = InetSocketAddress.class.getDeclaredMethod(&quot;getHostString&quot;);
    +                m.setAccessible(true);
    +                resolvedAddresses = InetAddress.getAllByName((String) m.invoke(address));
    +            }
&lt;p&gt; catch (IllegalAccessException e) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Nope &apos;cause JDK6 here, no?&lt;/p&gt;</comment>
                            <comment id="15828521" author="githubbot" created="Wed, 18 Jan 2017 18:30:02 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r96702291&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r96702291&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try 
{
    +                Method m = InetSocketAddress.class.getDeclaredMethod(&quot;getHostString&quot;);
    +                m.setAccessible(true);
    +                resolvedAddresses = InetAddress.getAllByName((String) m.invoke(address));
    +            }
&lt;p&gt; catch (IllegalAccessException e) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Right, I forgot the context, thanks for pointing this out @eribeiro &lt;/p&gt;</comment>
                            <comment id="15835321" author="githubbot" created="Mon, 23 Jan 2017 22:47:42 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r97435427&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r97435427&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I&apos;m still not sure we should do this. I&apos;m concerned about making that method visible while the original intention was not to expose it. Are you aware of any other project that has done this for `getHostString`?&lt;/p&gt;</comment>
                            <comment id="15835325" author="githubbot" created="Mon, 23 Jan 2017 22:51:47 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r97436195&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r97436195&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try 
{
    +                Method m = InetSocketAddress.class.getDeclaredMethod(&quot;getHostString&quot;);
    +                m.setAccessible(true);
    +                resolvedAddresses = InetAddress.getAllByName((String) m.invoke(address));
    +            }
&lt;p&gt; catch (IllegalAccessException e) &lt;/p&gt;
{
    +                resolvedAddresses = InetAddress.getAllByName(getHostString(address));
    +            } catch (NoSuchMethodException e) {    +                resolvedAddresses = InetAddress.getAllByName(getHostString(address));    +            }
&lt;p&gt; catch (InvocationTargetException e) &lt;/p&gt;
{
    +                resolvedAddresses = InetAddress.getAllByName(getHostString(address));
    +            }
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    That&apos;s possibly another issue with this way of exposing `getHostString, the presence of a security manager could prevent us from doing it as expected.&lt;/p&gt;</comment>
                            <comment id="15835327" author="githubbot" created="Mon, 23 Jan 2017 22:52:44 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r97436370&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r97436370&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    OK.&lt;/p&gt;</comment>
                            <comment id="15835335" author="githubbot" created="Mon, 23 Jan 2017 23:00:21 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r97437693&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r97437693&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +86,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;br/&gt;
    +                        for (InetAddress resolvedAddress : resolvedAddresses) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                            InetSocketAddress newAddr = new InetSocketAddress(resolvedAddress, thePort);    +                            if (!serverAddresses.contains(newAddr)) {
    +                                serverAddresses.add(newAddr);
    +                            }    +                        }&lt;/span&gt; &lt;/div&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    We shuffle initially to avoid having all clients connecting to the same server in the case they are all given the same connect string. If the array of addresses has already been shuffled (in the constructor), then the order followed in this method will be the shuffled one. I don&apos;t see a strong reason for re-shuffling, as we are not bringing it back to the original order by resolving again.&lt;/p&gt;</comment>
                            <comment id="15835402" author="githubbot" created="Tue, 24 Jan 2017 00:03:51 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r97446760&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r97446760&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +73,69 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * It evaluates to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString;&lt;br/&gt;
    +        InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +        if (ia != null) {&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!curAddr.getHostString().equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) 
{
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses[0], thePort));
    +                    }
&lt;p&gt; else {&lt;br/&gt;
    +                        serverAddresses.remove(currentIndex);&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @afine check the new changes to see if they address this and make sense.&lt;/p&gt;</comment>
                            <comment id="15839042" author="githubbot" created="Thu, 26 Jan 2017 02:11:57 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r97921838&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r97921838&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,26 +62,20 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
                 throws UnknownHostException {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia!=null) ? ia.getHostAddress():&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +            InetAddress resolvedAddresses[];&lt;br/&gt;
    +            try {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @fpj Let&apos;s not do this (expose package private JDK methods) given the concerns you raised earlier (as I also commented previously). &lt;/p&gt;</comment>
                            <comment id="15843303" author="githubbot" created="Fri, 27 Jan 2017 18:40:11 +0000"  >&lt;p&gt;Github user edwardoliveira commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98263409&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98263409&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while(i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if(getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) == getHostString(curAddr)) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Ops, are we comparing strings with `==` ?! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    Nit: space between `if` and `(`.&lt;/p&gt;</comment>
                            <comment id="15843305" author="githubbot" created="Fri, 27 Jan 2017 18:41:19 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98263678&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98263678&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while(i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if(getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) == getHostString(curAddr)) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Ops, are we comparing strings with `==` ?! &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    Nit: space between `if` and (`.&lt;/p&gt;</comment>
                            <comment id="15843306" author="githubbot" created="Fri, 27 Jan 2017 18:41:46 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98263780&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98263780&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: space between `if` and `(`. &lt;/p&gt;</comment>
                            <comment id="15843315" author="githubbot" created="Fri, 27 Jan 2017 18:48:00 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98265031&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98265031&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    okay, just me being pedant here, but it&apos;s a sincere question: would it be &lt;b&gt;worth&lt;/b&gt; to move this class to `src/java/test/org/apache/zookeeper/client/StaticHostProvider.java` and then remove the `public` modifier so that `getNextAdded()` and `getNextRemoved()` can be package protected as they are used for tests?&lt;/p&gt;

&lt;p&gt;    At first, I think it  doesn&apos;t see worth this kind of change, but I am uncomfortable with leaving those methods as public if they are used for tests by now. :thinking: &lt;/p&gt;

&lt;p&gt;    Wdyt?&lt;/p&gt;
</comment>
                            <comment id="15843410" author="githubbot" created="Fri, 27 Jan 2017 20:09:38 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98280911&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98280911&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while(i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if(getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;) == getHostString(curAddr)) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why call `getHostString(curAddr)`  (here in a loop, at line 137, 138, 141) if the `currAddr` doesn&apos;t change? Better call once between line 136 and 137 and assign to a variable, no? &lt;/p&gt;</comment>
                            <comment id="15843418" author="githubbot" created="Fri, 27 Jan 2017 20:13:52 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98281621&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98281621&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    silly refactoring:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    List&amp;lt;String&amp;gt; toRemove = new ArrayList&amp;lt;&amp;gt;(serverAddresses.size());&lt;br/&gt;
    for (String addr : serverAddresses) {&lt;br/&gt;
        if (getHostString(addr).equals(hostString) &lt;/p&gt;
{
            toRemove.add(addr);
        }
&lt;p&gt;    }&lt;br/&gt;
    LOG.debug(&quot;Removing addresses: {}&quot;, toRemove);&lt;br/&gt;
    nextRemoved += toRemove.size();&lt;br/&gt;
    serverAddresses.removeAll(toRemove);&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="15843435" author="githubbot" created="Fri, 27 Jan 2017 20:19:14 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98282550&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98282550&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    ```&lt;br/&gt;
    Line 136: String hostString = getHostString(currAddr);&lt;br/&gt;
    ```&lt;/p&gt;</comment>
                            <comment id="15844859" author="githubbot" created="Mon, 30 Jan 2017 06:42:01 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98385538&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98385538&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Although this is more Java-like, it requires the creation of an additional ArrayList, which is less efficient than creating a int counter. Unless there is something wrong with the current code, I&apos;d rather leave as is.&lt;/p&gt;</comment>
                            <comment id="15844918" author="githubbot" created="Mon, 30 Jan 2017 08:15:05 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98392957&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98392957&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,104 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You right. &lt;/p&gt;</comment>
                            <comment id="15845099" author="githubbot" created="Mon, 30 Jan 2017 12:11:10 +0000"  >&lt;p&gt;Github user fpj commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @hanm I believe we do have the same issue with the C client, I don&apos;t see it re-resolving addresses there, I need to have a closer look, though.&lt;/p&gt;</comment>
                            <comment id="15845434" author="githubbot" created="Mon, 30 Jan 2017 16:45:56 +0000"  >&lt;p&gt;Github user edwardoliveira commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98483994&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98483994&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -122,18 +122,19 @@ public int size() {&lt;br/&gt;
         private int nextAdded = 0;&lt;br/&gt;
         private int nextRemoved = 0;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNextAdded() {&lt;br/&gt;
    +    int getNextAdded() 
{
             return nextAdded;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNextRemoved() {&lt;br/&gt;
    +    int getNextRemoved() 
{
             return nextRemoved;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;br/&gt;
             // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
             if (!connectedSinceNext) {&lt;br/&gt;
                 InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
                 if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    @fpj Sorry for yet another comment, mate (my last one, I promise). I cited this previously but certainly got lost in my verbosite. &lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Replace `if (!getHostString(currAddr).equals(...)) {` by &apos;if (!curHostString.equals()` at Line 138;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Replace `getHostString(curAddr)` with `curHostString` at line 139;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Replace `getHostString(curAddr)` with `curHostString` at line 142;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    *&lt;b&gt;+1. LGTM. Really great job!.&lt;/b&gt;*&lt;/p&gt;

&lt;p&gt;    Best regards,&lt;/p&gt;
</comment>
                            <comment id="15845440" author="githubbot" created="Mon, 30 Jan 2017 16:48:48 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98484702&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98484702&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -122,18 +122,19 @@ public int size() {&lt;br/&gt;
         private int nextAdded = 0;&lt;br/&gt;
         private int nextRemoved = 0;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNextAdded() {&lt;br/&gt;
    +    int getNextAdded() 
{
             return nextAdded;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public int getNextRemoved() {&lt;br/&gt;
    +    int getNextRemoved() 
{
             return nextRemoved;
         }&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         public InetSocketAddress next(long spinDelay) {&lt;br/&gt;
             // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
             if (!connectedSinceNext) {&lt;br/&gt;
                 InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;


&lt;p&gt;    edwardoliveira just now&lt;br/&gt;
    @fpj Sorry for yet another comment, mate (my last one, I promise). I cited this previously but certainly got lost in my verbosite.&lt;/p&gt;

&lt;p&gt;    Replace if (!getHostString(currAddr).equals(...)) { by &apos;if (!curHostString.equals()` at Line 138;&lt;/p&gt;

&lt;p&gt;    Replace getHostString(curAddr) with curHostString at line 139;&lt;/p&gt;

&lt;p&gt;    Replace getHostString(curAddr) with curHostString at line 142;&lt;/p&gt;

&lt;p&gt;    *&lt;b&gt;IMHO, +1. Really great job!&lt;/b&gt;* :+1:&lt;/p&gt;

&lt;p&gt;    Best regards,&lt;/p&gt;</comment>
                            <comment id="15845952" author="githubbot" created="Mon, 30 Jan 2017 21:20:35 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98543324&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98543324&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,106 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(curAddr));&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think that this fixes the issue I described.&lt;/p&gt;

&lt;p&gt;    nit: Just wondering if it would be easier to use a map from (hoststring,port) -&amp;gt; serverAddress to make things clearer/remove a loop?&lt;/p&gt;</comment>
                            <comment id="15845953" author="githubbot" created="Mon, 30 Jan 2017 21:20:35 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98535935&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98535935&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,106 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    nit: why not use curHostString instead of calling getHostString two more times?&lt;/p&gt;</comment>
                            <comment id="15846006" author="githubbot" created="Mon, 30 Jan 2017 21:49:51 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98549400&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98549400&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,106 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    @afine &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98484702&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98484702&lt;/a&gt; :sunglasses: &lt;/p&gt;</comment>
                            <comment id="15846105" author="githubbot" created="Mon, 30 Jan 2017 23:07:00 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98564047&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98564047&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,106 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    whoops, apologies for the duplicate. &#128551;&lt;/p&gt;</comment>
                            <comment id="15846122" author="githubbot" created="Mon, 30 Jan 2017 23:14:32 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150#discussion_r98565216&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150#discussion_r98565216&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -87,15 +75,106 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses)&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if(addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!getHostString(curAddr).equals(curAddr.getAddress().getHostAddress())) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    No problem at all. &#128515; &lt;/p&gt;</comment>
                            <comment id="15849835" author="githubbot" created="Thu, 2 Feb 2017 11:59:48 +0000"  >&lt;p&gt;Github user ijuma commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for pushing this useful improvement over the line @fpj.&lt;/p&gt;</comment>
                            <comment id="15853504" author="githubbot" created="Mon, 6 Feb 2017 05:00:18 +0000"  >&lt;p&gt;Github user rakeshadr commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks everyone for the great effort &amp;amp; time in pushing this issue. I could see long discussions in the PR and I hope this work is nearing completion. Could you please update the progress and would like to know the chances of pushing this asap, thanks!.&lt;/p&gt;</comment>
                            <comment id="15873730" author="fpj" created="Sun, 19 Feb 2017 15:57:12 +0000"  >&lt;p&gt;I haven&apos;t had much time to work on this issue, but here is my current assessment.&lt;/p&gt;

&lt;p&gt;This issue seemed easy to fix at first, but it is fairly fundamental with respect to how we resolve host names. Currently, we resolve host names when we start a client and never resolve it again. This is the cause of the problem reported in the issue because in the scenario described, the zookeeper container is re-started and changes addresses, which prevents the client from connecting to the zookeeper server. &lt;/p&gt;

&lt;p&gt;The proposed patch here tries to re-resolve the hostname every time the client fails to connect to the resolved address. It kind of works, but it makes &lt;tt&gt;StaticHostProvider&lt;/tt&gt; a bit messy because the expectation with the current wiring is that we won&apos;t have to resolve again.&lt;/p&gt;

&lt;p&gt;The ideal situation for the problematic scenario is that we resolve the host name every time we try to connect to a server, but that would be a fairly fundamental change to how we resolve addresses in ZooKeeper. &lt;/p&gt;

&lt;p&gt;I was also looking at the C client and it might get a bit messy too there because I don&apos;t think we currently keep the association between the host name and the resolved address, so we don&apos;t really know what to resolve again. It might be possible to do it via the canonical name in &lt;tt&gt;getaddrinfo&lt;/tt&gt;, but I&apos;m not sure how that works with windows.&lt;/p&gt;

&lt;p&gt;One specific proposal to avoid having clients never finding a server ever again without deep changes to the current wiring is to resolve again everything in the case the client tries all and none succeeds. That would be a fairly straightforward change to both Java and C client, but it would not resolve addresses again in the case the a strict subset has changed addresses and at least one server is reachable.&lt;/p&gt;

</comment>
                            <comment id="15873747" author="breed" created="Sun, 19 Feb 2017 16:38:35 +0000"  >&lt;p&gt;another option would be to have a  background worker that periodically wakes up and re-resolves hosts every few minutes. if we ever get a connection failure we could use that to kick the background worker to run right away.&lt;/p&gt;</comment>
                            <comment id="15927537" author="geek101" created="Thu, 16 Mar 2017 05:49:57 +0000"  >&lt;p&gt;Hi All,&lt;/p&gt;

&lt;p&gt;I have worked on some other issue where I had to change StaticHostProvider to contain ServerCfg class which include the host string provided at config time, the resolved Inetaddress and SSL cert fingerprint. And also fixing all the plumbing everywhere to carry or operate upon ServerCfg. Will this be sufficient to address this issue?.&lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/zookeeper/pull/185/files#diff-1b64f5144158570491cfdec2b93b5c79&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/185/files#diff-1b64f5144158570491cfdec2b93b5c79&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I have modified this PR to fit needs of having a chance at getting SSL support committed hence I removed these changes and published a different PR:  &lt;a href=&quot;https://github.com/apache/zookeeper/pull/188&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/188&lt;/a&gt; (has the StaticHostProvider host changes removed and all the plumbing restored) for your reference to changes with and without StaticHostProvider modified.&lt;/p&gt;

&lt;p&gt;Let me know if this a direction worth while pursuing I can carve out just the StaticHostProvider changes (without the SSL cert fingerprint in ServerCfg) and publish them as a PR.&lt;/p&gt;

&lt;p&gt;thanks&lt;br/&gt;
Powell.&lt;/p&gt;</comment>
                            <comment id="15929563" author="githubbot" created="Fri, 17 Mar 2017 08:05:48 +0000"  >&lt;p&gt;GitHub user geek101 opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/199&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/199&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184&quot; title=&quot;Zookeeper Client should re-resolve hosts when connection attempts fail&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2184&quot;&gt;&lt;del&gt;ZOOKEEPER-2184&lt;/del&gt;&lt;/a&gt;: Resolve address only on demand.&lt;/p&gt;

&lt;p&gt;    Wrap hostname and port into a new ServerCfg class and fix&lt;br/&gt;
    all the places to use it instead of InetSocketAddress.&lt;/p&gt;

&lt;p&gt;    This class can be used in the future to encapsulate other&lt;br/&gt;
    nice config information for example certificate&lt;br/&gt;
    fingerprint associated with the host etc.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/geek101/zookeeper&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/geek101/zookeeper&lt;/a&gt; branch-3.5-hostname-resolve-always&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/199.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/199.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #199&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit ec219a4f40fe46a9743ad13ff910f9be9f383f3c&lt;br/&gt;
Author: Powell Molleti &amp;lt;powellm79@yahoo.com&amp;gt;&lt;br/&gt;
Date:   2017-03-17T07:59:23Z&lt;/p&gt;

&lt;p&gt;    Resolve address only on demand.&lt;/p&gt;

&lt;p&gt;    Wrap hostname and port into a new ServerCfg class and fix&lt;br/&gt;
    all the places to use it instead of InetSocketAddress.&lt;/p&gt;

&lt;p&gt;    This class can be used in the future to encapsulate other&lt;br/&gt;
    nice config information for example certificate&lt;br/&gt;
    fingerprint associated with the host etc.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15929571" author="hadoopqa" created="Fri, 17 Mar 2017 08:21:07 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 75 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    -1 release audit.  The applied patch generated 2 release audit warnings (more than the trunk&apos;s current 0 warnings).&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//testReport/&lt;/a&gt;&lt;br/&gt;
Release audit warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//artifact/trunk/patchprocess/patchReleaseAuditProblems.txt&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//artifact/trunk/patchprocess/patchReleaseAuditProblems.txt&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/440//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="15929599" author="hadoopqa" created="Fri, 17 Mar 2017 08:55:58 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 75 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/441//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/441//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/441//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/441//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/441//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/441//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="15931071" author="geek101" created="Sat, 18 Mar 2017 05:32:31 +0000"  >&lt;p&gt;not sure what the failure above is but the cpp unit tests work for me locally for that PR I submitted.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;     [exec]      [exec] *** Error in `./zktest-mt&apos;: corrupted double-linked list: 0x00000000012a5810 ***
     [exec]      [exec] Zookeeper_readOnly::testReadOnly : elapsed 4101 : OK
     [exec]      [exec] OK (74)
     [exec]      [exec] FAIL: zktest-mt
     [exec]      [exec] ==========================================
     [exec]      [exec] 1 of 2 tests failed
     [exec]      [exec] Please report to user@zookeeper.apache.org
     [exec]      [exec] ==========================================
     [exec]      [exec] make[1]: Leaving directory `/home/jenkins/jenkins-slave/workspace/PreCommit-ZOOKEEPER-github-pr-build/build/test/test-cppunit&apos;
     [exec]      [exec] /bin/bash: line 5:  8114 Aborted                 (core dumped) ZKROOT=/home/jenkins/jenkins-slave/workspace/PreCommit-ZOOKEEPER-github-pr-build/src/c/../.. CLASSPATH=$CLASSPATH:$CLOVER_HOME/lib/clover.jar ${dir}$tst
     [exec]      [exec] make[1]: *** [check-TESTS] Error 1
     [exec]      [exec] make: *** [check-am] Error 2
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</comment>
                            <comment id="16051480" author="githubbot" created="Fri, 16 Jun 2017 06:53:38 +0000"  >&lt;p&gt;Github user adyach commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/199&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/199&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @geek101 will it help to update the list of the ip address in case I use load balancer in connection string? I am asking since I have not found when zookeeper updates list of got ip address. In case we have a situation, when all ip address are not valid anymore.&lt;/p&gt;</comment>
                            <comment id="16051483" author="githubbot" created="Fri, 16 Jun 2017 06:56:28 +0000"  >&lt;p&gt;Github user adyach commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/199&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/199&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Seems like this is &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="16052089" author="githubbot" created="Fri, 16 Jun 2017 16:20:54 +0000"  >&lt;p&gt;Github user geek101 commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/199&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/199&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @adyach can you give me an example of a connection string that you are implying this will help me understand the problem better. Since the client code needs ip addresses of the ZK ensemble, does the DNS resolution of this load balancer hostname supposed to return that set of ip addresses?&lt;/p&gt;</comment>
                            <comment id="16052295" author="githubbot" created="Fri, 16 Jun 2017 19:17:01 +0000"  >&lt;p&gt;Github user adyach commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/199&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/199&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    `your.zookeeper.loadbalancer`&lt;br/&gt;
    The problem is that it is resolved only once when connected, but instances behind load balancer can be replaced.&lt;/p&gt;</comment>
                            <comment id="16052696" author="githubbot" created="Sat, 17 Jun 2017 05:24:12 +0000"  >&lt;p&gt;Github user geek101 commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/199&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/199&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @adyach this patch&apos;s goal is to make sure when ever a new connection is being established DNS lookup will be performed. If you have given a hostname in connection string then if the underlying IP is gone the TCP connection will break and new TCP connection will be attempted by Zookeeper code and at this time DNS lookup will again be performed.&lt;/p&gt;

&lt;p&gt;    I hope this helps if you can post your example of connection string it will be more helpful. Zookeeper connection string is supposed to contain the ZK ensemble set/subset hostnames/ips.&lt;/p&gt;</comment>
                            <comment id="16059402" author="githubbot" created="Thu, 22 Jun 2017 13:36:15 +0000"  >&lt;p&gt;Github user rcillo commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This feature is highly valuable for the community. It could solve the problem of every team deploying Kafka on the cloud. Kafka has a static configuration with the IP addresses of Zookeeper nodes. If you need to replace these nodes and consequently change their IP addresses, you need to change Kafka configuratino file and then restart all Kafka nodes so that they will reload the updated configuration.&lt;/p&gt;

&lt;p&gt;    If this feature is merged, everyone deploying Kafka on the cloud could configure it using a load balancer address, that would be re-resolved from time to time, so that new Zookeeper instances would be automatically reachable from Kafka without the need of restarts. This would greatly improve the availability of Kafka.&lt;/p&gt;

&lt;p&gt;    Looking forward to have this merged.&lt;/p&gt;</comment>
                            <comment id="16063628" author="githubbot" created="Mon, 26 Jun 2017 19:10:33 +0000"  >&lt;p&gt;Github user djenriquez commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Any reasons why this hasn&apos;t been merged yet or the attention given? I agree whole-heartedly with @rcillo, this is a gigantic feature for anyone depending on Zookeeper in the cloud running on immutable/disposal infrastructure.&lt;/p&gt;

&lt;p&gt;    Would love to get this merged, but it being 6 months old makes me wonder if it has been de-prioritized by project owners/collaborators? If so, can someone explain why has this been de-prioritized?&lt;/p&gt;</comment>
                            <comment id="16063713" author="githubbot" created="Mon, 26 Jun 2017 20:29:02 +0000"  >&lt;p&gt;Github user hanm commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    This PR has to be rebased first before it can be merged. Hi Flavio - will you follow up with this or you prefer someone else take this over? @fpj @rakeshadr &lt;/p&gt;

&lt;p&gt;    I&apos;ve updated the JIRA to mark it as a blocker for next release (3.4.11, 3.5.4), to prevent this issue lagging again. Good to get this in given its impact and relatively little effort given the PR is already in a good shape.&lt;/p&gt;</comment>
                            <comment id="16071340" author="hadoopqa" created="Sat, 1 Jul 2017 17:41:05 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 75 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/848//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/848//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/848//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/848//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/848//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/848//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16107958" author="githubbot" created="Mon, 31 Jul 2017 21:07:09 +0000"  >&lt;p&gt;Github user djenriquez commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Hi guys, any update for this PR? Many thanks!!&lt;/p&gt;</comment>
                            <comment id="16121951" author="githubbot" created="Thu, 10 Aug 2017 17:28:38 +0000"  >&lt;p&gt;Github user hanm commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    We need get this moving, but let&apos;s first wait for feedback from @fpj before letting someone else taking over this JIRA. &lt;/p&gt;</comment>
                            <comment id="16173124" author="githubbot" created="Wed, 20 Sep 2017 12:57:32 +0000"  >&lt;p&gt;Github user nicorevin commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @fpj any updates on it? It seems like a blocker for clustering kafka (and everyone using zkclient) in docker/kubernetes.&lt;/p&gt;</comment>
                            <comment id="16193491" author="githubbot" created="Thu, 5 Oct 2017 19:21:17 +0000"  >&lt;p&gt;Github user edvorkin commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    +1 one here. This feature is necessary for running Zookeeper in the cloud under AWS ASG. Every time node fails, ASG reassigns new IP for new zookeeper and there is no way kafka will know about it. We need to treat zookeeper servers as cattle, not pets, and kill and spin new one at will without affecting kafka. &lt;/p&gt;</comment>
                            <comment id="16200382" author="phunt" created="Wed, 11 Oct 2017 14:39:35 +0000"  >&lt;p&gt;This is the remaining blocker for 3.4.11 - any insights &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fpj&quot; class=&quot;user-hover&quot; rel=&quot;fpj&quot;&gt;fpj&lt;/a&gt; ? (see recent comments) Would be nice to get this one in.&lt;/p&gt;

&lt;p&gt;I don&apos;t believe this is a regression - if we don&apos;t see movement soon I will likely downgrade the priority and move out to the next release.&lt;/p&gt;</comment>
                            <comment id="16209978" author="phunt" created="Wed, 18 Oct 2017 20:32:50 +0000"  >&lt;p&gt;It doesn&apos;t look like anyone feels we need to block 3.4 for this - pushing to 3.4.12.&lt;/p&gt;</comment>
                            <comment id="16211123" author="githubbot" created="Thu, 19 Oct 2017 14:26:56 +0000"  >&lt;p&gt;Github user the-xs commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Should we still wait or get this moving to fix the merge conflicts?&lt;/p&gt;</comment>
                            <comment id="16235063" author="junrao" created="Thu, 2 Nov 2017 01:44:08 +0000"  >&lt;p&gt;Hi, does anyone know when this issue can be fixed? This is related to &lt;a href=&quot;https://issues.apache.org/jira/browse/KAFKA-5473&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/KAFKA-5473&lt;/a&gt;. We are wondering if we should have a short term fix in Kafka or just wait for the fix in ZK.&lt;/p&gt;</comment>
                            <comment id="16276584" author="githubbot" created="Mon, 4 Dec 2017 10:13:55 +0000"  >&lt;p&gt;Github user jorgheymans commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    just got stung by this as well, assumed zk clients would be clever enough to reresolve :-/ &lt;/p&gt;

&lt;p&gt;    Since there is a lot of interest in this why not just rebase-merge and let ppl test out the snapshot builds ? &lt;/p&gt;</comment>
                            <comment id="16276675" author="githubbot" created="Mon, 4 Dec 2017 11:59:22 +0000"  >&lt;p&gt;Github user riccardofreixo commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    We&apos;re running Kafka in Kubernetes, so this bug was biting us regularly.&lt;br/&gt;
    We applied the patch in the kafka clusters of our client and are running in prod. Solves our problem and created no additional problems for us.&lt;/p&gt;</comment>
                            <comment id="16276711" author="githubbot" created="Mon, 4 Dec 2017 12:31:42 +0000"  >&lt;p&gt;Github user sslavic commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @riccardofreixo have you tried using ClusterIP Service for ZooKeeper StatefulSet and providing that ClusterIP (or service hostname) to Kafka / ZooKeeper clients as sole ZooKeeper hostname?&lt;/p&gt;

&lt;p&gt;    StatefulSet can have multiple replicas, but to ZooKeeper clients all of the members no matter how many of them there are (1, 3, 5, ..) would be accessible under single ClusterIP.&lt;/p&gt;

&lt;p&gt;    Even when Pods of StatefulSet die and get re-scheduled for whatever reason, they will likely get new IP, but IP of ClusterIP Service remains stable so ZooKeeper clients should be able to reconnect, without need to reresolve IP address of the host.&lt;/p&gt;

&lt;p&gt;    If there&apos;s a quorum, Pod that died does not necessarily have to become available quickly, clients should still be able to connect even without losing session.&lt;/p&gt;</comment>
                            <comment id="16276730" author="githubbot" created="Mon, 4 Dec 2017 12:40:58 +0000"  >&lt;p&gt;Github user riccardofreixo commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @sslavic thanks for the suggestion.&lt;/p&gt;

&lt;p&gt;    We haven&apos;t tried that approach, and as far as I can tell it sounds like it would work. You&apos;d still have the re-resolution problem if you deleted/recreated the service, but that should be quite rare. Had we thought of that before, we probably wouldn&apos;t have patched the client. Now we have though, we&apos;ll keep it patched.&lt;/p&gt;

&lt;p&gt;    I still think this should be fixed on the zk-client, as there are other circumstances other than Kube where the IP addresses may change and you wouldn&apos;t have an easy solution such as ClusterIP.&lt;/p&gt;</comment>
                            <comment id="16281082" author="githubbot" created="Wed, 6 Dec 2017 23:05:05 +0000"  >&lt;p&gt;Github user phunt commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Given the insights from the Kafka and K8s folks this looks like a good one to focus on.&lt;/p&gt;

&lt;p&gt;    @fpj any chance you can update this PR to address the conflicts?&lt;/p&gt;
</comment>
                            <comment id="16327585" author="githubbot" created="Tue, 16 Jan 2018 18:55:36 +0000"  >&lt;p&gt;Github user jeffwidman commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Any movement on this?&lt;/p&gt;</comment>
                            <comment id="16329166" author="githubbot" created="Wed, 17 Jan 2018 18:32:29 +0000"  >&lt;p&gt;Github user bwmills commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    As noted by @rcillo back in June - this feature is highly valuable for the community. It&apos;s certainly of critical importance to our production services in K8s. Any updates are much appreciated.&lt;/p&gt;</comment>
                            <comment id="16331472" author="githubbot" created="Fri, 19 Jan 2018 00:10:21 +0000"  >&lt;p&gt;Github user phunt commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    I suspect folks were out on vacation. I was. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    It doesn&apos;t seem like @fpj has time to look at this - can someone else pick it up and address the recent comments?&lt;/p&gt;</comment>
                            <comment id="16336298" author="githubbot" created="Tue, 23 Jan 2018 19:42:40 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @phunt @afine @fpj I&apos;m happy to pick this up tomorrow.&lt;/p&gt;</comment>
                            <comment id="16337639" author="githubbot" created="Wed, 24 Jan 2018 14:16:49 +0000"  >&lt;p&gt;GitHub user anmolnar opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184&quot; title=&quot;Zookeeper Client should re-resolve hosts when connection attempts fail&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2184&quot;&gt;&lt;del&gt;ZOOKEEPER-2184&lt;/del&gt;&lt;/a&gt;: Zookeeper Client should re-resolve hosts when connection attempts fail&lt;/p&gt;

&lt;p&gt;    This one is the pick-up of @fpj &apos;s original PR: #150 &lt;br/&gt;
    Targeting and rebased on the 3.4 branch.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/anmolnar/zookeeper&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/anmolnar/zookeeper&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184&quot; title=&quot;Zookeeper Client should re-resolve hosts when connection attempts fail&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2184&quot;&gt;&lt;del&gt;ZOOKEEPER-2184&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #451&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 229760d7757f47e271a8e059c1aeac10f0847a2a&lt;br/&gt;
Author: fpj &amp;lt;fpj@...&amp;gt;&lt;br/&gt;
Date:   2017-01-14T16:58:15Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184&quot; title=&quot;Zookeeper Client should re-resolve hosts when connection attempts fail&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2184&quot;&gt;&lt;del&gt;ZOOKEEPER-2184&lt;/del&gt;&lt;/a&gt;: Zookeeper Client should re-resolve hosts when connection attempts fail&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="16337696" author="githubbot" created="Wed, 24 Jan 2018 14:58:07 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r163570637&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r163570637&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/client/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -117,8 +117,32 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             list.add(new InetSocketAddress(&quot;a&quot;, 2181));
             list.add(new InetSocketAddress(&quot;b&quot;, 2181));
             new StaticHostProvider(list);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +    @Test&lt;br/&gt;
    +    public void testReResolving() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to multiple addresses&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Common domain names like facebook.com, google.com or apache.org don&apos;t use round-robin DNS anymore for some reason, so they don&apos;t resolve to multiple addresses. As a consequence this test doesn&apos;t validate the branch related to multiple addresses anymore unfortunately.&lt;/p&gt;

&lt;p&gt;    Not sure how to address that, PowerMock would be the best to mock static `getAllByName()` method, but that would involve introducing a new test dependency.&lt;/p&gt;</comment>
                            <comment id="16340910" author="githubbot" created="Fri, 26 Jan 2018 11:02:34 +0000"  >&lt;p&gt;Github user mfenes commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Re-resolving at StaticHostProvider level may not be sufficient as InetAddress.getAllByName(String host) itself uses a Java-level cache inside InetAddress and turns to name service (e.g. DNS) only if the host could not be found in the Java-level cache.&lt;br/&gt;
    Unfortunately, when Java resolves a new host using the name service, it puts the host and its addresses in the cache with TTL cache FOREVER. &lt;br/&gt;
    This means, once a host gets resolved by Java, it will never again turn to the name service to re-resolve it. If a host&apos;s addresses get updated in DNS, the address cache in Java will still contain the old entry forever.&lt;br/&gt;
    So re-resolving at StaticHostProvider won&apos;t help in this case, as InetAddress.getAllByName(String host) will still return the old address(es) I think.&lt;br/&gt;
    Check the getCachedAddresses method inside InetAddress, the get() method of static final class Cache inside InetAddress and sun.net.InetAddressCachePolicy.get() which returns cachePolicy with default value -1 (FOREVER) if it is not overridden by Security properties &quot;networkaddress.cache.ttl&quot; and &quot;networkaddress.cache.negative.ttl&quot;.&lt;/p&gt;</comment>
                            <comment id="16341016" author="githubbot" created="Fri, 26 Jan 2018 13:00:12 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @mfenes The only solution I can think of is to set DNS cache TTL `networkaddress.cache.ttl` to a configurable, non-infinite value.&lt;/p&gt;</comment>
                            <comment id="16341046" author="githubbot" created="Fri, 26 Jan 2018 13:23:56 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Just confirmed on 3.4 branch: ZK uses 30 secs cache TTL on my mac.&lt;/p&gt;</comment>
                            <comment id="16341073" author="githubbot" created="Fri, 26 Jan 2018 13:46:28 +0000"  >&lt;p&gt;Github user mfenes commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Looking at the static initialization block in InetAddressCachePolicy more deeply, the default TTL is 30 seconds if there is no SecurityManager installed.&lt;br/&gt;
    So caching a positive lookup forever in the Java-level cache is the default only if there is a SecurityManager installed and the TTL is not overridden by &quot;networkaddress.cache.ttl&quot; to a different value.&lt;br/&gt;
    Default caching policy for a negative lookup is 0 (never cache).&lt;br/&gt;
    Now the only question is whether 30 seconds default caching is ok or too much for ZK.&lt;/p&gt;</comment>
                            <comment id="16348358" author="githubbot" created="Thu, 1 Feb 2018 10:34:54 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @phunt @afine Did you have a chance to take a look?&lt;br/&gt;
    I think we&apos;ve addressed all issues that were mentioned in the original PR.&lt;/p&gt;</comment>
                            <comment id="16349381" author="githubbot" created="Thu, 1 Feb 2018 22:20:45 +0000"  >&lt;p&gt;Github user jeffwidman commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Should this PR be targeting `branch-3.4` or target `trunk` and then backport to the 3.4 series?&lt;/p&gt;</comment>
                            <comment id="16349592" author="githubbot" created="Fri, 2 Feb 2018 00:38:17 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165525113&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165525113&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/client/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -16,7 +16,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -package org.apache.zookeeper.test;&lt;br/&gt;
    +package org.apache.zookeeper.client;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    this doesn&apos;t look right&lt;/p&gt;</comment>
                            <comment id="16349593" author="githubbot" created="Fri, 2 Feb 2018 00:38:17 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165525652&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165525652&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java &amp;#8212;&lt;br/&gt;
    @@ -239,13 +243,13 @@ public void testSessionEstablishment() throws Exception {&lt;br/&gt;
         public void testSeekForRwServer() throws Exception {&lt;/p&gt;

&lt;p&gt;             // setup the logger to capture all logs&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Layout layout = Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)&lt;br/&gt;
    +        Layout layout = org.apache.log4j.Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    why is this necessary?&lt;/p&gt;</comment>
                            <comment id="16349594" author="githubbot" created="Fri, 2 Feb 2018 00:38:17 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165527366&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165527366&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,29 +62,12 @@&lt;br/&gt;
          */&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;/li&gt;
	&lt;li&gt;for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;} catch (UnknownHostException e) {&lt;br/&gt;
    +			try {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    something is wrong with the indentation here&lt;/p&gt;</comment>
                            <comment id="16349595" author="githubbot" created="Fri, 2 Feb 2018 00:38:17 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165529085&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165529085&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -91,15 +79,106 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) &lt;/p&gt;
{
             Collections.shuffle(this.serverAddresses);
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    would you mind explaining exactly under which conditions we reresolve the hostname and under which conditions we try the next one in the host list? My reading is that this reresolves everything if the client fails to connect to two hosts in a row. Is this the desired behavior?&lt;/p&gt;

&lt;p&gt;    And do we always reresolve all serverAddresses?&lt;/p&gt;</comment>
                            <comment id="16349596" author="githubbot" created="Fri, 2 Feb 2018 00:38:17 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165524377&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165524377&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -25,6 +25,8 @@&lt;br/&gt;
     import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    +import java.lang.reflect.InvocationTargetException;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    i think these imports are unused, and there are some others elsewhere in the code&lt;/p&gt;</comment>
                            <comment id="16350397" author="githubbot" created="Fri, 2 Feb 2018 14:28:56 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @jeffwidman &lt;/p&gt;

&lt;p&gt;    &amp;gt; Should this PR be targeting branch-3.4 or target trunk and then backport to the 3.4 series?&lt;/p&gt;

&lt;p&gt;    The original PR targets 3.4 which is explained in a comment from @fpj on the jira:&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184?focusedCommentId=15823099&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15823099&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/ZOOKEEPER-2184?focusedCommentId=15823099&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15823099&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;gt; For the 3.5 branch, we will need a different patch because of the reconfiguration changes to StaticHostProvider. I&apos;ll work on it once the 3.4 patch gets a +1.&lt;/p&gt;
</comment>
                            <comment id="16350398" author="githubbot" created="Fri, 2 Feb 2018 14:30:30 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165658743&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165658743&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -25,6 +25,8 @@&lt;br/&gt;
     import java.util.Collection;&lt;br/&gt;
     import java.util.Collections;&lt;br/&gt;
     import java.util.List;&lt;br/&gt;
    +import java.lang.reflect.InvocationTargetException;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Good catch, thanks.&lt;/p&gt;</comment>
                            <comment id="16350400" author="githubbot" created="Fri, 2 Feb 2018 14:31:09 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165658965&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165658965&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -57,29 +62,12 @@&lt;br/&gt;
          */&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;/li&gt;
	&lt;li&gt;for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;} catch (UnknownHostException e) {&lt;br/&gt;
    +			try {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Fixing.&lt;/p&gt;</comment>
                            <comment id="16350447" author="githubbot" created="Fri, 2 Feb 2018 14:55:25 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165665505&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165665505&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -91,15 +79,106 @@ public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) &lt;/p&gt;
{
             Collections.shuffle(this.serverAddresses);
         }

&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It should try to re-resolve whenever the client is unable to connect to a server (connectedSinceNext == false). &lt;/p&gt;

&lt;p&gt;    @fpj gives a good explanation in the original Jira:&lt;br/&gt;
    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2184?focusedCommentId=15873730&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15873730&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/ZOOKEEPER-2184?focusedCommentId=15873730&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-15873730&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;gt; I haven&apos;t had much time to work on this issue, but here is my current assessment.&lt;/p&gt;

&lt;p&gt;    &amp;gt; This issue seemed easy to fix at first, but it is fairly fundamental with respect to how we resolve host names. Currently, we resolve host names when we start a client and never resolve it again. This is the cause of the problem reported in the issue because in the scenario described, the zookeeper container is re-started and changes addresses, which prevents the client from connecting to the zookeeper server.&lt;/p&gt;

&lt;p&gt;    &amp;gt; The proposed patch here tries to re-resolve the hostname every time the client fails to connect to the resolved address. It kind of works, but it makes StaticHostProvider a bit messy because the expectation with the current wiring is that we won&apos;t have to resolve again.&lt;/p&gt;

&lt;p&gt;    &amp;gt; The ideal situation for the problematic scenario is that we resolve the host name every time we try to connect to a server, but that would be a fairly fundamental change to how we resolve addresses in ZooKeeper.&lt;/p&gt;

&lt;p&gt;    &amp;gt; I was also looking at the C client and it might get a bit messy too there because I don&apos;t think we currently keep the association between the host name and the resolved address, so we don&apos;t really know what to resolve again. It might be possible to do it via the canonical name in getaddrinfo, but I&apos;m not sure how that works with windows.&lt;/p&gt;

&lt;p&gt;    &amp;gt; One specific proposal to avoid having clients never finding a server ever again without deep changes to the current wiring is to resolve again everything in the case the client tries all and none succeeds. That would be a fairly straightforward change to both Java and C client, but it would not resolve addresses again in the case the a strict subset has changed addresses and at least one server is reachable.&lt;/p&gt;</comment>
                            <comment id="16350461" author="githubbot" created="Fri, 2 Feb 2018 14:59:08 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r165666521&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r165666521&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/client/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -16,7 +16,7 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;limitations under the License.&lt;br/&gt;
      */&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    -package org.apache.zookeeper.test;&lt;br/&gt;
    +package org.apache.zookeeper.client;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    It was move to client package, because it uses package-private methods of StaticHostProvider. I moved back to &apos;test&apos; package and change the affected methods to public.&lt;/p&gt;</comment>
                            <comment id="16352907" author="githubbot" created="Mon, 5 Feb 2018 20:42:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166102194&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166102194&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    what happens when a host that resolves to multiple addresses changes to resolving to just one?&lt;/p&gt;</comment>
                            <comment id="16352908" author="githubbot" created="Mon, 5 Feb 2018 20:42:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166103404&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166103404&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    as i mentioned in &lt;a href=&quot;https://github.com/apache/zookeeper/pull/150/files#r98543324&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/150/files#r98543324&lt;/a&gt; this all gets a little complicated? What do you think about using a map to trap all these associations?&lt;/p&gt;</comment>
                            <comment id="16352909" author="githubbot" created="Mon, 5 Feb 2018 20:42:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166097161&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166097161&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -6,9 +6,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;to you under the Apache License, Version 2.0 (the&lt;/li&gt;
	&lt;li&gt;&quot;License&quot;); you may not use this file except in compliance&lt;/li&gt;
	&lt;li&gt;with the License.  You may obtain a copy of the License at&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;br/&gt;
    + * &amp;lt;p&amp;gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    was this accidental?&lt;/p&gt;</comment>
                            <comment id="16352910" author="githubbot" created="Mon, 5 Feb 2018 20:42:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166105622&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166105622&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -117,8 +116,32 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             list.add(new InetSocketAddress(&quot;a&quot;, 2181));
             list.add(new InetSocketAddress(&quot;b&quot;, 2181));
             new StaticHostProvider(list);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +    @Test&lt;br/&gt;
    +    public void testReResolving() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to multiple addresses&lt;br/&gt;
    +        list.add(InetSocketAddress.createUnresolved(&quot;www.apache.org&quot;, 1234));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I&apos;m wondering if it&apos;s possible to mock this out? It would be great if our unit tests were not dependent on some other infrastructure.&lt;/p&gt;</comment>
                            <comment id="16353843" author="githubbot" created="Tue, 6 Feb 2018 12:57:13 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166286530&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166286530&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java &amp;#8212;&lt;br/&gt;
    @@ -239,13 +243,13 @@ public void testSessionEstablishment() throws Exception {&lt;br/&gt;
         public void testSeekForRwServer() throws Exception {&lt;/p&gt;

&lt;p&gt;             // setup the logger to capture all logs&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Layout layout = Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)&lt;br/&gt;
    +        Layout layout = org.apache.log4j.Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I few lines above there&apos;re org.apache.log4j references which conflicts with the &apos;Logger&apos; class, hence it needs to be explicitly referenced.&lt;/p&gt;</comment>
                            <comment id="16353845" author="githubbot" created="Tue, 6 Feb 2018 12:57:31 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166286605&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166286605&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -6,9 +6,9 @@&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;to you under the Apache License, Version 2.0 (the&lt;/li&gt;
	&lt;li&gt;&quot;License&quot;); you may not use this file except in compliance&lt;/li&gt;
	&lt;li&gt;with the License.  You may obtain a copy of the License at&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;/li&gt;
	&lt;li&gt;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0&lt;/a&gt;&lt;/li&gt;
	&lt;li&gt;*&lt;br/&gt;
    + * &amp;lt;p&amp;gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yes it was.&lt;/p&gt;</comment>
                            <comment id="16353965" author="githubbot" created="Tue, 6 Feb 2018 14:57:46 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166328583&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166328583&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    That&apos;s actually a very good point. I&apos;m looking into that you suggested below (using a Map instead of Array) which will probably solve this issue too.&lt;/p&gt;</comment>
                            <comment id="16353975" author="githubbot" created="Tue, 6 Feb 2018 15:01:11 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166329760&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166329760&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -117,8 +116,32 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             list.add(new InetSocketAddress(&quot;a&quot;, 2181));
             list.add(new InetSocketAddress(&quot;b&quot;, 2181));
             new StaticHostProvider(list);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +    @Test&lt;br/&gt;
    +    public void testReResolving() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to multiple addresses&lt;br/&gt;
    +        list.add(InetSocketAddress.createUnresolved(&quot;www.apache.org&quot;, 1234));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Good point I spent hours finding a way for it. Unfortunately static members can&apos;t be mocked with Mockito. We should use PowerMock for it (as described here &lt;a href=&quot;https://blog.codecentric.de/en/2016/03/junit-testing-using-mockito-powermock/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://blog.codecentric.de/en/2016/03/junit-testing-using-mockito-powermock/&lt;/a&gt;), but that&apos;d be a new dependency not sure if it&apos;s acceptable here.&lt;/p&gt;</comment>
                            <comment id="16354016" author="githubbot" created="Tue, 6 Feb 2018 15:36:30 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166341540&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166341540&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It seems that this change makes things a little a bit even more complicated, because `next()` method needs to have a list of IP addresses to iterate on. Maintenance is easier with a Map, but I need to find a way to use it as a list.&lt;/p&gt;</comment>
                            <comment id="16354716" author="githubbot" created="Tue, 6 Feb 2018 23:27:20 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166476047&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166476047&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java &amp;#8212;&lt;br/&gt;
    @@ -239,13 +243,13 @@ public void testSessionEstablishment() throws Exception {&lt;br/&gt;
         public void testSeekForRwServer() throws Exception {&lt;/p&gt;

&lt;p&gt;             // setup the logger to capture all logs&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Layout layout = Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)&lt;br/&gt;
    +        Layout layout = org.apache.log4j.Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    not going to push too hard on this, but I think you can just use log4j everywhere like in `QuorumPeerMainTest`&lt;/p&gt;</comment>
                            <comment id="16354726" author="githubbot" created="Tue, 6 Feb 2018 23:30:15 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166476703&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166476703&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Not sure I understand this point. I believe there are implementations of HashMap that provide predictable ordering of the keys, so you should still be able to use next. Let me know if I am misunderstanding you here. &lt;/p&gt;</comment>
                            <comment id="16354738" author="githubbot" created="Tue, 6 Feb 2018 23:47:36 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166479687&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166479687&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -117,8 +116,32 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             list.add(new InetSocketAddress(&quot;a&quot;, 2181));
             list.add(new InetSocketAddress(&quot;b&quot;, 2181));
             new StaticHostProvider(list);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +    @Test&lt;br/&gt;
    +    public void testReResolving() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to multiple addresses&lt;br/&gt;
    +        list.add(InetSocketAddress.createUnresolved(&quot;www.apache.org&quot;, 1234));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yeah, this is annoying. Although, another possibility would be to put the dns calls in a method and then subclass `StaticHostProvider` for the tests and overriding this method to return what you want. &lt;/p&gt;</comment>
                            <comment id="16355652" author="githubbot" created="Wed, 7 Feb 2018 16:17:08 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166669488&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166669488&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java &amp;#8212;&lt;br/&gt;
    @@ -239,13 +243,13 @@ public void testSessionEstablishment() throws Exception {&lt;br/&gt;
         public void testSeekForRwServer() throws Exception {&lt;/p&gt;

&lt;p&gt;             // setup the logger to capture all logs&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Layout layout = Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)&lt;br/&gt;
    +        Layout layout = org.apache.log4j.Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    slf4j&apos;s string formatter feature is being used in these tests. I wouldn&apos;t refactor them to be honest.&lt;/p&gt;</comment>
                            <comment id="16355654" author="githubbot" created="Wed, 7 Feb 2018 16:18:56 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166670125&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166670125&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    How to shuffle the elements?&lt;/p&gt;</comment>
                            <comment id="16355661" author="githubbot" created="Wed, 7 Feb 2018 16:23:08 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r166671671&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r166671671&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It might be easier to just remove the special case of `resolvedAddresses.length == 1` and let the other part iterate over the list and remove the affected elements.&lt;/p&gt;</comment>
                            <comment id="16357289" author="githubbot" created="Thu, 8 Feb 2018 17:43:42 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r167013851&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r167013851&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    You could put the `keySet` in a list and shuffle?&lt;/p&gt;</comment>
                            <comment id="16357356" author="githubbot" created="Thu, 8 Feb 2018 18:23:58 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r167024767&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r167024767&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    The key is the hoststring which is like `issues.apache.org` and could have multiple InetAddresses which are the values of the key in the map. If I shuffle only the keys, I can iterate on only the keys and not sure how to choose from the addresses.&lt;/p&gt;</comment>
                            <comment id="16357361" author="githubbot" created="Thu, 8 Feb 2018 18:27:36 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Going one step back I wonder why we try to deal with multiple addresses at all.&lt;/p&gt;

&lt;p&gt;    HostProvider should just make a transformation from unresolved InetSocketAddresses to resolved InetSocketAddresses. The easiest way as I can see it is to create a new instance of InetSocketAddress if the input is unresolved every time `next()` is called. Otherwise just pass it through.&lt;/p&gt;

&lt;p&gt;    JVM will deal with the rest: resolution, caching and re-resolution once the cache is expires (30 secs).&lt;/p&gt;</comment>
                            <comment id="16357370" author="githubbot" created="Thu, 8 Feb 2018 18:34:39 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r167027624&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r167027624&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -117,8 +116,32 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             list.add(new InetSocketAddress(&quot;a&quot;, 2181));
             list.add(new InetSocketAddress(&quot;b&quot;, 2181));
             new StaticHostProvider(list);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +    @Test&lt;br/&gt;
    +    public void testReResolving() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to multiple addresses&lt;br/&gt;
    +        list.add(InetSocketAddress.createUnresolved(&quot;www.apache.org&quot;, 1234));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Makes sense, I&apos;m working on it.&lt;/p&gt;</comment>
                            <comment id="16365806" author="githubbot" created="Thu, 15 Feb 2018 16:12:16 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168524336&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168524336&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -117,8 +116,32 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             list.add(new InetSocketAddress(&quot;a&quot;, 2181));
             list.add(new InetSocketAddress(&quot;b&quot;, 2181));
             new StaticHostProvider(list);
    +	}
&lt;p&gt;    +&lt;br/&gt;
    +    @Test&lt;br/&gt;
    +    public void testReResolving() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to multiple addresses&lt;br/&gt;
    +        list.add(InetSocketAddress.createUnresolved(&quot;www.apache.org&quot;, 1234));&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    This is done.&lt;/p&gt;</comment>
                            <comment id="16366059" author="githubbot" created="Thu, 15 Feb 2018 18:24:40 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168564981&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168564981&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -18,6 +18,10 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.zookeeper.client;&lt;/p&gt;

&lt;p&gt;    +import org.apache.yetus.audience.InterfaceAudience;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: move this back&lt;/p&gt;</comment>
                            <comment id="16366131" author="githubbot" created="Thu, 15 Feb 2018 19:13:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168565039&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168565039&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -18,6 +18,10 @@&lt;/p&gt;

&lt;p&gt;     package org.apache.zookeeper.client;&lt;/p&gt;

&lt;p&gt;    +import org.apache.yetus.audience.InterfaceAudience;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    nit: move this back&lt;/p&gt;</comment>
                            <comment id="16366132" author="githubbot" created="Thu, 15 Feb 2018 19:13:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168578617&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168578617&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why don&apos;t we simplify things and just do this always? In other words, always remove all serverAddresses that correspond to the curHostString. That way if curHostString goes from resolving to many addresses to just 1, we remove all of them?&lt;/p&gt;</comment>
                            <comment id="16366133" author="githubbot" created="Thu, 15 Feb 2018 19:13:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168568596&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168568596&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -47,59 +51,169 @@&lt;/p&gt;

&lt;p&gt;         private int currentIndex = -1;&lt;/p&gt;

&lt;p&gt;    +    // Don&apos;t re-resolve on first next() call&lt;br/&gt;
    +    private boolean connectedSinceNext = true;&lt;br/&gt;
    +&lt;br/&gt;
    +    private Resolver resolver;&lt;br/&gt;
    +&lt;br/&gt;
         /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs a SimpleHostSet.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
    +     *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param serverAddresses&lt;/li&gt;
	&lt;li&gt;possibly unresolved ZooKeeper server addresses&lt;/li&gt;
	&lt;li&gt;@throws IllegalArgumentException&lt;/li&gt;
	&lt;li&gt;if serverAddresses is empty or resolves to an empty list&lt;br/&gt;
          */&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
    +        this.resolver = new Resolver() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +            @Override    +            public InetAddress[] getAllByName(String name) throws UnknownHostException {
    +                return InetAddress.getAllByName(name);
    +            }    +        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
    +        init(serverAddresses);&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     * Introduced for testing purposes. getAllByName() is a static method of InetAddress, therefore cannot be easily mocked.&lt;br/&gt;
    +     * By abstraction of Resolver interface we can easily inject a mocked implementation in tests.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param serverAddresses&lt;br/&gt;
    +     *            possibly unresolved ZooKeeper server addresses&lt;br/&gt;
    +     * @param resolver&lt;br/&gt;
    +     *            custom resolver implementation&lt;br/&gt;
    +     * @throws IllegalArgumentException&lt;br/&gt;
    +     *             if serverAddresses is empty or resolves to an empty list&lt;br/&gt;
    +     */&lt;br/&gt;
    +    public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses, Resolver resolver) &lt;/p&gt;
{
    +        this.resolver = resolver;
    +        init(serverAddresses);
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     * Common init method for all constructors.&lt;br/&gt;
    +     * Resolve all unresolved server addresses, put them in a list and shuffle.&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private void init(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = this.resolver.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;    +&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    can we save a call to `getHostString` by using `curHostString`?&lt;/p&gt;</comment>
                            <comment id="16366134" author="githubbot" created="Thu, 15 Feb 2018 19:13:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168572502&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168572502&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/ClientPortBindTest.java &amp;#8212;&lt;br/&gt;
    @@ -104,7 +104,7 @@ public void testBindByAddress() throws Exception {&lt;br/&gt;
             try {&lt;br/&gt;
                 startSignal.await(CONNECTION_TIMEOUT,&lt;br/&gt;
                         TimeUnit.MILLISECONDS);&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Assert.assertTrue(&quot;count == 0&quot;, startSignal.getCount() == 0);&lt;br/&gt;
    +            Assert.assertTrue(&quot;count == &quot; + startSignal.getCount(), startSignal.getCount() == 0);
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I&apos;m not a huge fan of calling `getCount` more than once, since I think the value could change between invocations. Why not just use the return value from `await` in the line above? &lt;/p&gt;</comment>
                            <comment id="16366135" author="githubbot" created="Thu, 15 Feb 2018 19:13:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168576884&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168576884&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -119,6 +120,68 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             new StaticHostProvider(list);
         }

&lt;p&gt;    +    @Test&lt;br/&gt;
    +    public void testReResolvingSingle() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to a single address&lt;br/&gt;
    +        list.clear();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    do we need this?&lt;/p&gt;</comment>
                            <comment id="16366136" author="githubbot" created="Thu, 15 Feb 2018 19:13:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168575513&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168575513&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java &amp;#8212;&lt;br/&gt;
    @@ -239,13 +243,13 @@ public void testSessionEstablishment() throws Exception {&lt;br/&gt;
         public void testSeekForRwServer() throws Exception {&lt;/p&gt;

&lt;p&gt;             // setup the logger to capture all logs&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Layout layout = Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)&lt;br/&gt;
    +        Layout layout = org.apache.log4j.Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I guess my real question is, do we need any of the changes in this file?&lt;/p&gt;</comment>
                            <comment id="16366137" author="githubbot" created="Thu, 15 Feb 2018 19:13:49 +0000"  >&lt;p&gt;Github user afine commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168576090&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168576090&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -47,59 +51,169 @@&lt;/p&gt;

&lt;p&gt;         private int currentIndex = -1;&lt;/p&gt;

&lt;p&gt;    +    // Don&apos;t re-resolve on first next() call&lt;br/&gt;
    +    private boolean connectedSinceNext = true;&lt;br/&gt;
    +&lt;br/&gt;
    +    private Resolver resolver;&lt;br/&gt;
    +&lt;br/&gt;
         /**&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Constructs a SimpleHostSet.&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;*&lt;br/&gt;
    +     *&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
	&lt;li&gt;@param serverAddresses&lt;/li&gt;
	&lt;li&gt;possibly unresolved ZooKeeper server addresses&lt;/li&gt;
	&lt;li&gt;@throws IllegalArgumentException&lt;/li&gt;
	&lt;li&gt;if serverAddresses is empty or resolves to an empty list&lt;br/&gt;
          */&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
    +        this.resolver = new Resolver() 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +            @Override    +            public InetAddress[] getAllByName(String name) throws UnknownHostException {
    +                return InetAddress.getAllByName(name);
    +            }    +        }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;&lt;br/&gt;
    +        init(serverAddresses);&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     * Introduced for testing purposes. getAllByName() is a static method of InetAddress, therefore cannot be easily mocked.&lt;br/&gt;
    +     * By abstraction of Resolver interface we can easily inject a mocked implementation in tests.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param serverAddresses&lt;br/&gt;
    +     *            possibly unresolved ZooKeeper server addresses&lt;br/&gt;
    +     * @param resolver&lt;br/&gt;
    +     *            custom resolver implementation&lt;br/&gt;
    +     * @throws IllegalArgumentException&lt;br/&gt;
    +     *             if serverAddresses is empty or resolves to an empty list&lt;br/&gt;
    +     */&lt;br/&gt;
    +    public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses, Resolver resolver) &lt;/p&gt;
{
    +        this.resolver = resolver;
    +        init(serverAddresses);
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    /**&lt;br/&gt;
    +     * Common init method for all constructors.&lt;br/&gt;
    +     * Resolve all unresolved server addresses, put them in a list and shuffle.&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private void init(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = this.resolver.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;    +&lt;br/&gt;
             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    instead of exposing all these metrics, which involve making changes to application logic. Why don&apos;t we just expose the `serverAddresses` to the test?&lt;/p&gt;</comment>
                            <comment id="16366143" author="githubbot" created="Thu, 15 Feb 2018 19:19:17 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168580127&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168580127&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/client/StaticHostProvider.java &amp;#8212;&lt;br/&gt;
    @@ -58,48 +61,122 @@&lt;br/&gt;
         public StaticHostProvider(Collection&amp;lt;InetSocketAddress&amp;gt; serverAddresses) {&lt;br/&gt;
             for (InetSocketAddress address : serverAddresses) {&lt;br/&gt;
                 try {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;InetAddress ia = address.getAddress();&lt;/li&gt;
	&lt;li&gt;InetAddress resolvedAddresses[] = InetAddress.getAllByName((ia != null) ? ia.getHostAddress() :&lt;/li&gt;
	&lt;li&gt;address.getHostName());&lt;br/&gt;
    +                InetAddress resolvedAddresses[] = InetAddress.getAllByName(getHostString(address));&lt;br/&gt;
                     for (InetAddress resolvedAddress : resolvedAddresses) {&lt;/li&gt;
	&lt;li&gt;// If hostName is null but the address is not, we can tell that&lt;/li&gt;
	&lt;li&gt;// the hostName is an literal IP address. Then we can set the host string as the hostname&lt;/li&gt;
	&lt;li&gt;// safely to avoid reverse DNS lookup.&lt;/li&gt;
	&lt;li&gt;// As far as i know, the only way to check if the hostName is null is use toString().&lt;/li&gt;
	&lt;li&gt;// Both the two implementations of InetAddress are final class, so we can trust the return value of&lt;/li&gt;
	&lt;li&gt;// the toString() method.&lt;/li&gt;
	&lt;li&gt;if (resolvedAddress.toString().startsWith(&quot;/&quot;)&lt;/li&gt;
	&lt;li&gt;&amp;amp;&amp;amp; resolvedAddress.getAddress() != null) 
{
    -                        this.serverAddresses.add(
    -                                new InetSocketAddress(InetAddress.getByAddress(
    -                                        address.getHostName(),
    -                                        resolvedAddress.getAddress()),
    -                                        address.getPort()));
    -                    }
&lt;p&gt; else &lt;/p&gt;
{
    -                        this.serverAddresses.add(new InetSocketAddress(resolvedAddress.getHostAddress(), address.getPort()));
    -                    }
&lt;p&gt;    +                    this.serverAddresses.add(new InetSocketAddress(resolvedAddress, address.getPort()));&lt;br/&gt;
                     }&lt;br/&gt;
                 } catch (UnknownHostException e) {&lt;br/&gt;
                     LOG.error(&quot;Unable to connect to server: {}&quot;, address, e);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;&lt;p&gt;    +&lt;br/&gt;
             if (this.serverAddresses.isEmpty()) &lt;/p&gt;
{
                 throw new IllegalArgumentException(
                         &quot;A HostProvider may not be empty!&quot;);
             }
&lt;p&gt;             Collections.shuffle(this.serverAddresses);&lt;br/&gt;
         }&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    +    /**&lt;br/&gt;
    +     * Evaluate to a hostname if one is available and otherwise it returns the&lt;br/&gt;
    +     * string representation of the IP address.&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * In Java 7, we have a method getHostString, but earlier versions do not support it.&lt;br/&gt;
    +     * This method is to provide a replacement for InetSocketAddress.getHostString().&lt;br/&gt;
    +     *&lt;br/&gt;
    +     * @param addr&lt;br/&gt;
    +     * @return Hostname string of address parameter&lt;br/&gt;
    +     */&lt;br/&gt;
    +    private String getHostString(InetSocketAddress addr) {&lt;br/&gt;
    +        String hostString = &quot;&quot;;&lt;br/&gt;
    +&lt;br/&gt;
    +        if (addr == null) &lt;/p&gt;
{
    +            return hostString;
    +        }
&lt;p&gt;    +        if (!addr.isUnresolved()) {&lt;br/&gt;
    +            InetAddress ia = addr.getAddress();&lt;br/&gt;
    +&lt;br/&gt;
    +            // If the string starts with &apos;/&apos;, then it has no hostname&lt;br/&gt;
    +            // and we want to avoid the reverse lookup, so we return&lt;br/&gt;
    +            // the string representation of the address.&lt;br/&gt;
    +            if (ia.toString().startsWith(&quot;/&quot;)) &lt;/p&gt;
{
    +                hostString = ia.getHostAddress();
    +            }
&lt;p&gt; else &lt;/p&gt;
{
    +                hostString = addr.getHostName();
    +            }
&lt;p&gt;    +        } else &lt;/p&gt;
{
    +            // According to the Java 6 documentation, if the hostname is
    +            // unresolved, then the string before the colon is the hostname.
    +            String addrString = addr.toString();
    +            hostString = addrString.substring(0, addrString.lastIndexOf(&apos;:&apos;));
    +        }
&lt;p&gt;    +&lt;br/&gt;
    +        return hostString;&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
         public int size() &lt;/p&gt;
{
             return serverAddresses.size();
         }

&lt;p&gt;    +    // Counts the number of addresses added and removed during&lt;br/&gt;
    +    // the last call to next. Used mainly for test purposes.&lt;br/&gt;
    +    // See StasticHostProviderTest.&lt;br/&gt;
    +    private int nextAdded = 0;&lt;br/&gt;
    +    private int nextRemoved = 0;&lt;br/&gt;
    +&lt;br/&gt;
    +    public int getNextAdded() &lt;/p&gt;
{
    +        return nextAdded;
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    public int getNextRemoved() &lt;/p&gt;
{
    +        return nextRemoved;
    +    }
&lt;p&gt;    +&lt;br/&gt;
         public InetSocketAddress next(long spinDelay) {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;++currentIndex;&lt;/li&gt;
	&lt;li&gt;if (currentIndex == serverAddresses.size()) {&lt;/li&gt;
	&lt;li&gt;currentIndex = 0;&lt;br/&gt;
    +        // Handle possible connection error by re-resolving hostname if possible&lt;br/&gt;
    +        if (!connectedSinceNext) {&lt;br/&gt;
    +            InetSocketAddress curAddr = serverAddresses.get(currentIndex);&lt;br/&gt;
    +            String curHostString = getHostString(curAddr);&lt;br/&gt;
    +            if (!curHostString.equals(curAddr.getAddress().getHostAddress())) {&lt;br/&gt;
    +                LOG.info(&quot;Resolving again hostname: {}&quot;, getHostString(curAddr));&lt;br/&gt;
    +                try {&lt;br/&gt;
    +                    int thePort = curAddr.getPort();&lt;br/&gt;
    +                    InetAddress resolvedAddresses[] = InetAddress.getAllByName(curHostString);&lt;br/&gt;
    +                    nextAdded = 0;&lt;br/&gt;
    +                    nextRemoved = 0;&lt;br/&gt;
    +                    if (resolvedAddresses.length == 1) {&lt;br/&gt;
    +                        serverAddresses.set(currentIndex, new InetSocketAddress(resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;, thePort));&lt;br/&gt;
    +                        nextAdded = nextRemoved = 1;&lt;br/&gt;
    +                        LOG.debug(&quot;Newly resolved address: {}&quot;, resolvedAddresses&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;);&lt;br/&gt;
    +                    } else {&lt;br/&gt;
    +                        int i = 0;&lt;br/&gt;
    +                        while (i &amp;lt; serverAddresses.size()) {&lt;br/&gt;
    +                            if (getHostString(serverAddresses.get&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/information.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;).equals(curHostString) &amp;amp;&amp;amp;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    That&apos;s exactly the point. &lt;br/&gt;
    (think I&apos;ve already suggested the same thing in an outdated post)&lt;/p&gt;</comment>
                            <comment id="16367329" author="githubbot" created="Fri, 16 Feb 2018 14:03:58 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168763559&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168763559&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/ReadOnlyModeTest.java &amp;#8212;&lt;br/&gt;
    @@ -239,13 +243,13 @@ public void testSessionEstablishment() throws Exception {&lt;br/&gt;
         public void testSeekForRwServer() throws Exception {&lt;/p&gt;

&lt;p&gt;             // setup the logger to capture all logs&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Layout layout = Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)&lt;br/&gt;
    +        Layout layout = org.apache.log4j.Logger.getRootLogger().getAppender(&quot;CONSOLE&quot;)
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Makes sense. I revert the changes.&lt;/p&gt;</comment>
                            <comment id="16367332" author="githubbot" created="Fri, 16 Feb 2018 14:07:31 +0000"  >&lt;p&gt;Github user anmolnar commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451#discussion_r168764368&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451#discussion_r168764368&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/org/apache/zookeeper/test/StaticHostProviderTest.java &amp;#8212;&lt;br/&gt;
    @@ -119,6 +120,68 @@ public void testTwoInvalidHostAddresses() &lt;/p&gt;
{
             new StaticHostProvider(list);
         }

&lt;p&gt;    +    @Test&lt;br/&gt;
    +    public void testReResolvingSingle() {&lt;br/&gt;
    +        byte size = 1;&lt;br/&gt;
    +        ArrayList&amp;lt;InetSocketAddress&amp;gt; list = new ArrayList&amp;lt;InetSocketAddress&amp;gt;(size);&lt;br/&gt;
    +&lt;br/&gt;
    +        // Test a hostname that resolves to a single address&lt;br/&gt;
    +        list.clear();&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Removed.&lt;/p&gt;</comment>
                            <comment id="16369422" author="eronwright" created="Mon, 19 Feb 2018 19:03:44 +0000"  >&lt;p&gt;Linking to an earlier related issue.&lt;/p&gt;</comment>
                            <comment id="16392126" author="githubbot" created="Thu, 8 Mar 2018 23:49:22 +0000"  >&lt;p&gt;Github user ijuma commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Thanks for picking this up @anmolnar, looking forward to this being fixed. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16393545" author="githubbot" created="Fri, 9 Mar 2018 21:02:08 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @ijuma Sure, no problem.&lt;br/&gt;
    I&apos;m waiting for some feedback from the community here and on the mailing list and I hope I can commit soon.&lt;/p&gt;</comment>
                            <comment id="16406541" author="githubbot" created="Tue, 20 Mar 2018 15:52:19 +0000"  >&lt;p&gt;Github user ijuma commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @anmolnar, it&apos;s been more than 1 month since the last comment on this PR. Is there anything that still needs to be addressed? The original PR was submitted in January 2017 and it got stalled after a while, I&apos;m hoping the same doesn&apos;t happen here. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="16406585" author="githubbot" created="Tue, 20 Mar 2018 16:17:02 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @ijuma I feel your pain. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
    No worries, I&apos;m on it. Doing my best to push committers and others to review changes.&lt;/p&gt;

&lt;p&gt;    Additionally I&apos;d like to make a small refactoring to the proposed logic before committing, because I&apos;m not entirely convinced about this manual caching/shuffling logic that was implemented originally.&lt;/p&gt;

&lt;p&gt;    You can see the details in one of my comments above and on the `dev` mailing list.&lt;/p&gt;</comment>
                            <comment id="16411243" author="githubbot" created="Fri, 23 Mar 2018 11:18:10 +0000"  >&lt;p&gt;Github user anmolnar commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/451&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/451&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @afine @ijuma I&apos;ve finished refactoring of StaticHostProvider.&lt;/p&gt;

&lt;p&gt;    The implementation follows that I explained in my email as *&lt;b&gt;Option-3&lt;/b&gt;*:&lt;/p&gt;

&lt;p&gt;    &amp;gt; - Do not cache IPs, &lt;br/&gt;
    &amp;gt; - Shuffle the names and resolve with getAllByName() every time when next() is called,&lt;br/&gt;
    &amp;gt; - Use getAllByName(), but shuffle the list and return the first IP to properly handle hostnames associated with multiple IPs,&lt;br/&gt;
    &amp;gt; - JDK&apos;s built-in caching will prevent name servers from being flooded and will do the re-resolution automatically when cache expires,&lt;/p&gt;

&lt;p&gt;    The `Resolver` interface which is also introduced in this patch is the solution for the problem that @afine raised: to properly mock out the `getAllByName()` call in unit tests.&lt;/p&gt;</comment>
                            <comment id="16490566" author="hadoopqa" created="Fri, 25 May 2018 11:05:51 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 9 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1756//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1756//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1756//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1756//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1756//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1756//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16490741" author="hadoopqa" created="Fri, 25 May 2018 13:39:26 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 9 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1757//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1757//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1757//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1757//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1757//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1757//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16492555" author="hadoopqa" created="Mon, 28 May 2018 11:14:33 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 9 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1759//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1759//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1759//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1759//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1759//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1759//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16492825" author="hanm" created="Mon, 28 May 2018 16:51:32 +0000"  >&lt;p&gt;Patch committed to branch-3.4 as &lt;a href=&quot;https://github.com/apache/zookeeper/commit/2e26c8836edc800c60b204a1d3da0285edb415d6&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/commit/2e26c8836edc800c60b204a1d3da0285edb415d6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This Jira will be resolved after the patch is ported to branch-3.5 and master.&lt;/p&gt;</comment>
                            <comment id="16493723" author="hadoopqa" created="Tue, 29 May 2018 15:40:43 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1765//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1765//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1765//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1765//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1765//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1765//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16493732" author="hadoopqa" created="Tue, 29 May 2018 15:44:47 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1766//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1766//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1766//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1766//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1766//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1766//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16500027" author="hadoopqa" created="Mon, 4 Jun 2018 10:38:44 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1787//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1787//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1787//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1787//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1787//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1787//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16500057" author="hadoopqa" created="Mon, 4 Jun 2018 10:53:37 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1788//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1788//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1788//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1788//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1788//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1788//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16500128" author="hadoopqa" created="Mon, 4 Jun 2018 12:05:56 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1789//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1789//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1789//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1789//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1789//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1789//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16515635" author="hadoopqa" created="Mon, 18 Jun 2018 12:17:06 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1842//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1842//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1842//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1842//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1842//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1842//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16520003" author="hanm" created="Fri, 22 Jun 2018 04:30:06 +0000"  >&lt;p&gt;Temporary resolve issue for 3.4.13 so we can generate release note. Will reopen issue for 3.5 and 3.6.&lt;/p&gt;</comment>
                            <comment id="16520818" author="hanm" created="Fri, 22 Jun 2018 22:11:10 +0000"  >&lt;p&gt;again need to temporarily resolve the issue to get the right release notes for 3.4.13.&lt;/p&gt;</comment>
                            <comment id="16540221" author="hadoopqa" created="Wed, 11 Jul 2018 15:07:20 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 1 new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    -1 contrib tests.  The patch failed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1924//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1924//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1924//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1924//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1924//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1924//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16540621" author="hadoopqa" created="Wed, 11 Jul 2018 20:40:26 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 1 new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1927//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1927//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1927//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1927//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1927//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1927//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16541853" author="hadoopqa" created="Thu, 12 Jul 2018 15:55:37 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 1 new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1930//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1930//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1930//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1930//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1930//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1930//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16542903" author="hadoopqa" created="Fri, 13 Jul 2018 11:19:05 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1934//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1934//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1934//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1934//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1934//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/1934//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="16544766" author="hanm" created="Mon, 16 Jul 2018 03:48:41 +0000"  >&lt;p&gt;committed to master: &lt;a href=&quot;https://github.com/apache/zookeeper/commit/0a311873deb1847703c9b62716c626ce43d4ba48&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/commit/0a311873deb1847703c9b62716c626ce43d4ba48&lt;/a&gt;&lt;br/&gt;
branch-3.5: &lt;br/&gt;
&lt;a href=&quot;https://github.com/apache/zookeeper/commit/1e65b9f4873fc995308972433ea8a664e98fe41f&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/commit/1e65b9f4873fc995308972433ea8a664e98fe41f&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310660">
                    <name>Completes</name>
                                            <outwardlinks description="fixes">
                                        <issuelink>
            <issuekey id="12951319">SOLR-8868</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="12310000">
                    <name>Duplicate</name>
                                            <outwardlinks description="duplicates">
                                        <issuelink>
            <issuekey id="12417097">ZOOKEEPER-338</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="12310560">
                    <name>Problem/Incident</name>
                                            <outwardlinks description="causes">
                                        <issuelink>
            <issuekey id="12997352">KAFKA-4041</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13174640">MESOS-9113</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12597797">ZOOKEEPER-1506</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12636955">ZOOKEEPER-1666</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12768117" name="ZOOKEEPER-2184.patch" size="7797" author="rthille" created="Thu, 22 Oct 2015 19:26:01 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 18 weeks, 2 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2eg9z:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>