<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 08:59:03 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF Jira</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[ZOOKEEPER-2628] Investigate and fix findbug warnings</title>
                <link>https://issues.apache.org/jira/browse/ZOOKEEPER-2628</link>
                <project id="12310801" key="ZOOKEEPER">ZooKeeper</project>
                    <description>&lt;p&gt;Findbug tool used by Jenkins bot is upgraded to 3.0.1 from 2.0.3 according to Infra team, and this leads to 20 new warnings produced by findbug. The warning reports can be found on &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-Build/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;pre commit builds&lt;/a&gt; with build number &amp;gt;= 3513. These warnings need to be triaged and fixed if they are legitimate.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13018325">ZOOKEEPER-2628</key>
            <summary>Investigate and fix findbug warnings</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="hanm">Michael Han</assignee>
                                    <reporter username="hanm">Michael Han</reporter>
                        <labels>
                    </labels>
                <created>Sat, 5 Nov 2016 00:49:49 +0000</created>
                <updated>Thu, 18 May 2017 03:44:02 +0000</updated>
                            <resolved>Thu, 24 Nov 2016 16:21:27 +0000</resolved>
                                    <version>3.5.2</version>
                                    <fixVersion>3.5.3</fixVersion>
                    <fixVersion>3.6.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="15645632" author="githubbot" created="Mon, 7 Nov 2016 22:11:59 +0000"  >&lt;p&gt;GitHub user hanm opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;: Fix findbug warnings.&lt;/p&gt;

&lt;p&gt;    This PR fixed 19 find bug warnings except this one, which might require interface change that potentially could break client side apps.&lt;/p&gt;

&lt;p&gt;    Malicious code vulnerability Warnings&lt;br/&gt;
    org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE is a mutable collection&lt;br/&gt;
    Bug type MS_MUTABLE_COLLECTION (click for details) &lt;br/&gt;
    In class org.apache.zookeeper.ZooDefs$Ids&lt;br/&gt;
    Field org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE&lt;br/&gt;
    At ZooDefs.java:&lt;span class=&quot;error&quot;&gt;&amp;#91;line 116&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/hanm/zookeeper&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/hanm/zookeeper&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #102&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit d6e059ef11dea0de725b7bebd14e7bba626bdf53&lt;br/&gt;
Author: Michael Han &amp;lt;hanm@cloudera.com&amp;gt;&lt;br/&gt;
Date:   2016-11-07T22:09:10Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;: Fix findbug warnings.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15645695" author="githubbot" created="Mon, 7 Nov 2016 22:37:02 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r86885871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r86885871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/CGenerator.java &amp;#8212;&lt;br/&gt;
    @@ -61,70 +61,88 @@ void genCode() throws IOException &lt;/p&gt;
{
                             + outputDirectory);
                 }
&lt;p&gt;             }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;FileWriter c = new FileWriter(new File(outputDirectory, mName+&quot;.c&quot;));&lt;/li&gt;
	&lt;li&gt;FileWriter h = new FileWriter(new File(outputDirectory, mName+&quot;.h&quot;));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;\n&quot;);&lt;br/&gt;
    +        FileWriter c = null, h = null;&lt;br/&gt;
    +        try {&lt;br/&gt;
    +            c = new FileWriter(new File(outputDirectory, mName + &quot;.c&quot;));&lt;br/&gt;
    +            h = new FileWriter(new File(outputDirectory, mName + &quot;.h&quot;));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;c.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;\n&quot;);&lt;br/&gt;
    +            h.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            h.write(&quot;*\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            h.write(&quot;\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;#ifndef _&lt;em&gt;&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;/em&gt;&apos;)&lt;/ins&gt;&quot;__\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;#define _&lt;em&gt;&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;/em&gt;&apos;)&lt;/ins&gt;&quot;__\n&quot;);&lt;br/&gt;
    +            c.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            c.write(&quot;*\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            c.write(&quot;\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;#include \&quot;recordio.h\&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JFile&amp;gt; i = mInclFiles.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JFile f = i.next();
    -            h.write(&quot;#include \&quot;&quot;+f.getName()+&quot;.h\&quot;\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;// required for compilation from C++&lt;/li&gt;
	&lt;li&gt;h.write(&quot;\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#ifndef _&lt;em&gt;&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;/em&gt;&apos;) + &quot;__\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#define _&lt;em&gt;&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;/em&gt;&apos;) + &quot;__\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;c.write(&quot;#include &amp;lt;stdlib.h&amp;gt;\n&quot;); // need it for calloc() &amp;amp; free()&lt;/li&gt;
	&lt;li&gt;c.write(&quot;#include \&quot;&quot;&lt;ins&gt;mName&lt;/ins&gt;&quot;.h\&quot;\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#include \&quot;recordio.h\&quot;\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JFile&amp;gt; i = mInclFiles.iterator(); i.hasNext(); ) 
{
    +                JFile f = i.next();
    +                h.write(&quot;#include \&quot;&quot; + f.getName() + &quot;.h\&quot;\n&quot;);
    +            }
&lt;p&gt;    +            // required for compilation from C++&lt;br/&gt;
    +            h.write(&quot;\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (Iterator&amp;lt;JRecord&amp;gt; i = mRecList.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JRecord jr = i.next();
    -            jr.genCCode(h, c);
    -        }
&lt;p&gt;    +            c.write(&quot;#include &amp;lt;stdlib.h&amp;gt;\n&quot;); // need it for calloc() &amp;amp; free()&lt;br/&gt;
    +            c.write(&quot;#include \&quot;&quot; + mName + &quot;.h\&quot;\n\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;\n#ifdef __cplusplus\n}\n#endif\n\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;#endif //&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;em&gt;&apos;)&lt;/ins&gt;&quot;&lt;/em&gt;_\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JRecord&amp;gt; i = mRecList.iterator(); i.hasNext(); ) 
{
    +                JRecord jr = i.next();
    +                jr.genCCode(h, c);
    +            }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.close();&lt;/li&gt;
	&lt;li&gt;c.close();&lt;br/&gt;
    +            h.write(&quot;\n#ifdef __cplusplus\n}\n#endif\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#endif //&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;em&gt;&apos;) + &quot;&lt;/em&gt;_\n&quot;);&lt;br/&gt;
    +        } catch (IOException e) 
{
    +            throw e;
    +        }
&lt;p&gt; finally {&lt;br/&gt;
    +            if (h != null) {&lt;br/&gt;
    +                try &lt;/p&gt;
{
    +                    h.close();
    +                }
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +                    throw ex;
    +                }
&lt;p&gt; finally &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                    if (c != null) {
    +                        c.close();
    +                    }    +                }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            }&lt;br/&gt;
    +            if (c != null) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    It&apos;s sad that we have to close c twice (one here, one in the finally block earlier.). Findbugs is not happy if either of them is missing. It could be that the flow sensitive engine of findbug need an improvement.&lt;/p&gt;</comment>
                            <comment id="15646021" author="githubbot" created="Tue, 8 Nov 2016 00:57:36 +0000"  >&lt;p&gt;Github user breed commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r86903124&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r86903124&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/version/util/VerGen.java &amp;#8212;&lt;br/&gt;
    @@ -93,6 +93,14 @@ public static void generateFile(File outputDir, Version version, int rev, String&lt;br/&gt;
             } catch (IOException e) {&lt;br/&gt;
                 System.out.println(&quot;Unable to generate version.Info file: &quot;&lt;br/&gt;
                         + e.getMessage());&lt;br/&gt;
    +            if (w != null) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    wow this is a weird one... we have it in the finally... try with resources would make this a bit nicer too...&lt;/p&gt;</comment>
                            <comment id="15646022" author="githubbot" created="Tue, 8 Nov 2016 00:57:36 +0000"  >&lt;p&gt;Github user breed commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r86902626&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r86902626&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/cli/DeleteCommand.java &amp;#8212;&lt;br/&gt;
    @@ -59,11 +59,6 @@ private void retainCompatibility(String[] cmdArgs) throws CliParseException {&lt;br/&gt;
             // delete path &lt;span class=&quot;error&quot;&gt;&amp;#91;version&amp;#93;&lt;/span&gt;&lt;br/&gt;
             if (args.length &amp;gt; 2) {&lt;br/&gt;
                 // rewrite to option&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    you can remove the comment too &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15646023" author="githubbot" created="Tue, 8 Nov 2016 00:57:36 +0000"  >&lt;p&gt;Github user breed commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r86902396&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r86902396&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/CGenerator.java &amp;#8212;&lt;br/&gt;
    @@ -61,70 +61,88 @@ void genCode() throws IOException &lt;/p&gt;
{
                             + outputDirectory);
                 }
&lt;p&gt;             }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;FileWriter c = new FileWriter(new File(outputDirectory, mName+&quot;.c&quot;));&lt;/li&gt;
	&lt;li&gt;FileWriter h = new FileWriter(new File(outputDirectory, mName+&quot;.h&quot;));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;\n&quot;);&lt;br/&gt;
    +        FileWriter c = null, h = null;&lt;br/&gt;
    +        try {&lt;br/&gt;
    +            c = new FileWriter(new File(outputDirectory, mName + &quot;.c&quot;));&lt;br/&gt;
    +            h = new FileWriter(new File(outputDirectory, mName + &quot;.h&quot;));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;c.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;\n&quot;);&lt;br/&gt;
    +            h.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            h.write(&quot;*\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            h.write(&quot;\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;#ifndef _&lt;em&gt;&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;/em&gt;&apos;)&lt;/ins&gt;&quot;__\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;#define _&lt;em&gt;&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;/em&gt;&apos;)&lt;/ins&gt;&quot;__\n&quot;);&lt;br/&gt;
    +            c.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            c.write(&quot;*\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            c.write(&quot;\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;#include \&quot;recordio.h\&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JFile&amp;gt; i = mInclFiles.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JFile f = i.next();
    -            h.write(&quot;#include \&quot;&quot;+f.getName()+&quot;.h\&quot;\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;// required for compilation from C++&lt;/li&gt;
	&lt;li&gt;h.write(&quot;\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#ifndef _&lt;em&gt;&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;/em&gt;&apos;) + &quot;__\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#define _&lt;em&gt;&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;/em&gt;&apos;) + &quot;__\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;c.write(&quot;#include &amp;lt;stdlib.h&amp;gt;\n&quot;); // need it for calloc() &amp;amp; free()&lt;/li&gt;
	&lt;li&gt;c.write(&quot;#include \&quot;&quot;&lt;ins&gt;mName&lt;/ins&gt;&quot;.h\&quot;\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#include \&quot;recordio.h\&quot;\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JFile&amp;gt; i = mInclFiles.iterator(); i.hasNext(); ) 
{
    +                JFile f = i.next();
    +                h.write(&quot;#include \&quot;&quot; + f.getName() + &quot;.h\&quot;\n&quot;);
    +            }
&lt;p&gt;    +            // required for compilation from C++&lt;br/&gt;
    +            h.write(&quot;\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (Iterator&amp;lt;JRecord&amp;gt; i = mRecList.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JRecord jr = i.next();
    -            jr.genCCode(h, c);
    -        }
&lt;p&gt;    +            c.write(&quot;#include &amp;lt;stdlib.h&amp;gt;\n&quot;); // need it for calloc() &amp;amp; free()&lt;br/&gt;
    +            c.write(&quot;#include \&quot;&quot; + mName + &quot;.h\&quot;\n\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;\n#ifdef __cplusplus\n}\n#endif\n\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;#endif //&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;em&gt;&apos;)&lt;/ins&gt;&quot;&lt;/em&gt;_\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JRecord&amp;gt; i = mRecList.iterator(); i.hasNext(); ) 
{
    +                JRecord jr = i.next();
    +                jr.genCCode(h, c);
    +            }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.close();&lt;/li&gt;
	&lt;li&gt;c.close();&lt;br/&gt;
    +            h.write(&quot;\n#ifdef __cplusplus\n}\n#endif\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#endif //&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;em&gt;&apos;) + &quot;&lt;/em&gt;_\n&quot;);&lt;br/&gt;
    +        } catch (IOException e) 
{
    +            throw e;
    +        }
&lt;p&gt; finally {&lt;br/&gt;
    +            if (h != null) {&lt;br/&gt;
    +                try &lt;/p&gt;
{
    +                    h.close();
    +                }
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +                    throw ex;
    +                }
&lt;p&gt; finally &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                    if (c != null) {
    +                        c.close();
    +                    }    +                }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            }&lt;br/&gt;
    +            if (c != null) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    i think try with resources would clean this up. we are on java7 now right?&lt;/p&gt;</comment>
                            <comment id="15646036" author="githubbot" created="Tue, 8 Nov 2016 01:06:25 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r86905102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r86905102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/CGenerator.java &amp;#8212;&lt;br/&gt;
    @@ -61,70 +61,88 @@ void genCode() throws IOException &lt;/p&gt;
{
                             + outputDirectory);
                 }
&lt;p&gt;             }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;FileWriter c = new FileWriter(new File(outputDirectory, mName+&quot;.c&quot;));&lt;/li&gt;
	&lt;li&gt;FileWriter h = new FileWriter(new File(outputDirectory, mName+&quot;.h&quot;));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;\n&quot;);&lt;br/&gt;
    +        FileWriter c = null, h = null;&lt;br/&gt;
    +        try {&lt;br/&gt;
    +            c = new FileWriter(new File(outputDirectory, mName + &quot;.c&quot;));&lt;br/&gt;
    +            h = new FileWriter(new File(outputDirectory, mName + &quot;.h&quot;));&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;c.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;\n&quot;);&lt;br/&gt;
    +            h.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            h.write(&quot;*\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            h.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            h.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            h.write(&quot;\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;#ifndef _&lt;em&gt;&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;/em&gt;&apos;)&lt;/ins&gt;&quot;__\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;#define _&lt;em&gt;&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;/em&gt;&apos;)&lt;/ins&gt;&quot;__\n&quot;);&lt;br/&gt;
    +            c.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            c.write(&quot;*\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            c.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            c.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            c.write(&quot;\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;#include \&quot;recordio.h\&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JFile&amp;gt; i = mInclFiles.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JFile f = i.next();
    -            h.write(&quot;#include \&quot;&quot;+f.getName()+&quot;.h\&quot;\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;// required for compilation from C++&lt;/li&gt;
	&lt;li&gt;h.write(&quot;\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#ifndef _&lt;em&gt;&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;/em&gt;&apos;) + &quot;__\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#define _&lt;em&gt;&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;/em&gt;&apos;) + &quot;__\n&quot;);&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;c.write(&quot;#include &amp;lt;stdlib.h&amp;gt;\n&quot;); // need it for calloc() &amp;amp; free()&lt;/li&gt;
	&lt;li&gt;c.write(&quot;#include \&quot;&quot;&lt;ins&gt;mName&lt;/ins&gt;&quot;.h\&quot;\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#include \&quot;recordio.h\&quot;\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JFile&amp;gt; i = mInclFiles.iterator(); i.hasNext(); ) 
{
    +                JFile f = i.next();
    +                h.write(&quot;#include \&quot;&quot; + f.getName() + &quot;.h\&quot;\n&quot;);
    +            }
&lt;p&gt;    +            // required for compilation from C++&lt;br/&gt;
    +            h.write(&quot;\n#ifdef __cplusplus\nextern \&quot;C\&quot; {\n#endif\n\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (Iterator&amp;lt;JRecord&amp;gt; i = mRecList.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JRecord jr = i.next();
    -            jr.genCCode(h, c);
    -        }
&lt;p&gt;    +            c.write(&quot;#include &amp;lt;stdlib.h&amp;gt;\n&quot;); // need it for calloc() &amp;amp; free()&lt;br/&gt;
    +            c.write(&quot;#include \&quot;&quot; + mName + &quot;.h\&quot;\n\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.write(&quot;\n#ifdef __cplusplus\n}\n#endif\n\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;#endif //&quot;&lt;ins&gt;mName.toUpperCase().replace(&apos;.&apos;,&apos;&lt;em&gt;&apos;)&lt;/ins&gt;&quot;&lt;/em&gt;_\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JRecord&amp;gt; i = mRecList.iterator(); i.hasNext(); ) 
{
    +                JRecord jr = i.next();
    +                jr.genCCode(h, c);
    +            }&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;h.close();&lt;/li&gt;
	&lt;li&gt;c.close();&lt;br/&gt;
    +            h.write(&quot;\n#ifdef __cplusplus\n}\n#endif\n\n&quot;);&lt;br/&gt;
    +            h.write(&quot;#endif //&quot; + mName.toUpperCase().replace(&apos;.&apos;, &apos;&lt;em&gt;&apos;) + &quot;&lt;/em&gt;_\n&quot;);&lt;br/&gt;
    +        } catch (IOException e) 
{
    +            throw e;
    +        }
&lt;p&gt; finally {&lt;br/&gt;
    +            if (h != null) {&lt;br/&gt;
    +                try &lt;/p&gt;
{
    +                    h.close();
    +                }
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
    +                    throw ex;
    +                }
&lt;p&gt; finally &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                    if (c != null) {
    +                        c.close();
    +                    }    +                }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            }&lt;br/&gt;
    +            if (c != null) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Yeah I thought about using try / with  - for some reasons I had the impression that we also need to support JDK 1.6 (that&apos;s probably only for 3.4.x). I&apos;ll update with try / with.&lt;/p&gt;</comment>
                            <comment id="15646038" author="githubbot" created="Tue, 8 Nov 2016 01:07:12 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r86905174&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r86905174&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/version/util/VerGen.java &amp;#8212;&lt;br/&gt;
    @@ -93,6 +93,14 @@ public static void generateFile(File outputDir, Version version, int rev, String&lt;br/&gt;
             } catch (IOException e) {&lt;br/&gt;
                 System.out.println(&quot;Unable to generate version.Info file: &quot;&lt;br/&gt;
                         + e.getMessage());&lt;br/&gt;
    +            if (w != null) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Findbug complains here because we use System.exit in catch block - in that case it is not guaranteed that the finally block will be executed.&lt;/p&gt;</comment>
                            <comment id="15646614" author="githubbot" created="Tue, 8 Nov 2016 05:56:05 +0000"  >&lt;p&gt;Github user hanm commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Updated PR to address review comments from @breed.&lt;/p&gt;
</comment>
                            <comment id="15648175" author="githubbot" created="Tue, 8 Nov 2016 17:25:26 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87028116&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87028116&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/server/DataTree.java &amp;#8212;&lt;br/&gt;
    @@ -1293,13 +1293,12 @@ public synchronized WatchesSummary getWatchesSummary() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param pwriter the output to write to&lt;br/&gt;
          */&lt;br/&gt;
         public void dumpEphemerals(PrintWriter pwriter) {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Set&amp;lt;Long&amp;gt; keys = ephemerals.keySet();&lt;br/&gt;
             pwriter.println(&quot;Sessions with Ephemerals (&quot;&lt;/li&gt;
	&lt;li&gt;+ keys.size() + &quot;):&quot;);&lt;/li&gt;
	&lt;li&gt;for (long k : keys) {&lt;/li&gt;
	&lt;li&gt;pwriter.print(&quot;0x&quot; + Long.toHexString(k));&lt;br/&gt;
    +                + ephemerals.keySet().size() + &quot;):&quot;);&lt;br/&gt;
    +        for (Entry&amp;lt;Long, HashSet&amp;lt;String&amp;gt;&amp;gt; entry : ephemerals.entrySet()) {&lt;br/&gt;
    +            pwriter.print(&quot;0x&quot; + Long.toHexString(entry.getKey()));&lt;br/&gt;
                 pwriter.println(&quot;:&quot;);&lt;/li&gt;
	&lt;li&gt;HashSet&amp;lt;String&amp;gt; tmp = ephemerals.get(k);&lt;br/&gt;
    +            HashSet&amp;lt;String&amp;gt; tmp = entry.getValue();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Could we define `tmp` as `Set` instead of `HashSet`?&lt;/p&gt;</comment>
                            <comment id="15648176" author="githubbot" created="Tue, 8 Nov 2016 17:25:26 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87027160&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87027160&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java &amp;#8212;&lt;br/&gt;
    @@ -344,9 +345,10 @@ public boolean containsQuorum(Set&amp;lt;Long&amp;gt; set){&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Check if all groups have majority&lt;br/&gt;
              */&lt;br/&gt;
             int majGroupCounter = 0;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for(long gid : expansion.keySet()) {&lt;/li&gt;
	&lt;li&gt;LOG.debug(&quot;Group info: &quot; + expansion.get(gid) + &quot;, &quot; + gid + &quot;, &quot; + groupWeight.get(gid));&lt;/li&gt;
	&lt;li&gt;if(expansion.get(gid) &amp;gt; (groupWeight.get(gid) / 2) )&lt;br/&gt;
    +        for (Entry&amp;lt;Long, Long&amp;gt; entry : expansion.entrySet()) {&lt;br/&gt;
    +            Long gid = entry.getKey();&lt;br/&gt;
    +            LOG.debug(&quot;Group info: &quot; + entry.getValue() + &quot;, &quot; + gid + &quot;, &quot; + groupWeight.get(gid));
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    We could use modern LOG printing here: &lt;/p&gt;

&lt;p&gt;    ``&lt;br/&gt;
    LOG.debug(&quot;Group info: {}, {}, {}&quot;, entry.getValue(), gid, groupWeight.get(gid));&lt;br/&gt;
    ``&lt;/p&gt;</comment>
                            <comment id="15648177" author="githubbot" created="Tue, 8 Nov 2016 17:25:26 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87027302&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87027302&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java &amp;#8212;&lt;br/&gt;
    @@ -344,9 +345,10 @@ public boolean containsQuorum(Set&amp;lt;Long&amp;gt; set){&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;Check if all groups have majority&lt;br/&gt;
              */&lt;br/&gt;
             int majGroupCounter = 0;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for(long gid : expansion.keySet()) {&lt;/li&gt;
	&lt;li&gt;LOG.debug(&quot;Group info: &quot; + expansion.get(gid) + &quot;, &quot; + gid + &quot;, &quot; + groupWeight.get(gid));&lt;/li&gt;
	&lt;li&gt;if(expansion.get(gid) &amp;gt; (groupWeight.get(gid) / 2) )&lt;br/&gt;
    +        for (Entry&amp;lt;Long, Long&amp;gt; entry : expansion.entrySet()) {&lt;br/&gt;
    +            Long gid = entry.getKey();&lt;br/&gt;
    +            LOG.debug(&quot;Group info: &quot; + entry.getValue() + &quot;, &quot; + gid + &quot;, &quot; + groupWeight.get(gid));&lt;br/&gt;
    +            if(entry.getValue() &amp;gt; (groupWeight.get(gid) / 2) )
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    nit: add space after the `if` and remove space before the last parenthesis.&lt;/p&gt;</comment>
                            <comment id="15648178" author="githubbot" created="Tue, 8 Nov 2016 17:25:26 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87038798&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87038798&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/JRecord.java &amp;#8212;&lt;br/&gt;
    @@ -141,109 +141,128 @@ public String genCsharpWriteWrapper(String fname, String tag) {&lt;/p&gt;

&lt;p&gt;         static HashMap&amp;lt;String, String&amp;gt; vectorStructs = new HashMap&amp;lt;String, String&amp;gt;();&lt;br/&gt;
         public void genCCode(FileWriter h, FileWriter c) throws IOException {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;for (JField f : mFields) {&lt;/li&gt;
	&lt;li&gt;if (f.getType() instanceof JVector) {&lt;/li&gt;
	&lt;li&gt;JVector jv = (JVector)f.getType();&lt;/li&gt;
	&lt;li&gt;JType jvType = jv.getElementType();&lt;/li&gt;
	&lt;li&gt;String struct_name = JVector.extractVectorName(jvType);&lt;/li&gt;
	&lt;li&gt;if (vectorStructs.get(struct_name) == null) {&lt;/li&gt;
	&lt;li&gt;vectorStructs.put(struct_name, struct_name);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;struct &quot; + struct_name + &quot; 
{\n    int32_t count;\n&quot; + jv.getElementType().genCDecl(&quot;*data&quot;) + &quot;\n};\n&quot;);&lt;br/&gt;
    -                    h.write(&quot;int serialize_&quot; + struct_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + struct_name + &quot; *v);\n&quot;);&lt;br/&gt;
    -                    h.write(&quot;int deserialize_&quot; + struct_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + struct_name + &quot; *v);\n&quot;);&lt;br/&gt;
    -                    h.write(&quot;int allocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v, int32_t len);\n&quot;);&lt;br/&gt;
    -                    h.write(&quot;int deallocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v);\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;int allocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v, int32_t len) {\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    if (!len) {\n&quot;);
    -                    c.write(&quot;        v-&amp;gt;count = 0;\n&quot;);
    -                    c.write(&quot;        v-&amp;gt;data = 0;\n&quot;);
    -                    c.write(&quot;    } else {\n&quot;);
    -                    c.write(&quot;        v-&amp;gt;count = len;\n&quot;);
    -                    c.write(&quot;        v-&amp;gt;data = calloc(sizeof(*v-&amp;gt;data), len);\n&quot;);
    -                    c.write(&quot;    }\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    return 0;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;}\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;int deallocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v) {\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    if (v-&amp;gt;data) {\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;        int32_t i;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;        for(i=0;i&amp;lt;v-&amp;gt;count; i++) {\n&quot;);
    -                    c.write(&quot;            deallocate_&quot;+JRecord.extractMethodSuffix(jvType)+&quot;(&amp;amp;v-&amp;gt;data[i]);\n&quot;);
    -                    c.write(&quot;        }\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;        free(v-&amp;gt;data);\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;        v-&amp;gt;data = 0;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    }\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    return 0;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;}\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;int serialize_&quot; + struct_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + struct_name + &quot; *v)\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;{\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    int32_t count = v-&amp;gt;count;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    int rc = 0;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    int32_t i;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    rc = out-&amp;gt;start_vector(out, tag, &amp;amp;count);\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    for(i=0;i&amp;lt;v-&amp;gt;count;i++) {\n&quot;);
    -                    genSerialize(c, jvType, &quot;data&quot;, &quot;data[i]&quot;);
    -                    c.write(&quot;    }\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    rc = rc ? rc : out-&amp;gt;end_vector(out, tag);\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    return rc;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;}\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;int deserialize_&quot; + struct_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + struct_name + &quot; *v)\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;{\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    int rc = 0;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    int32_t i;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    rc = in-&amp;gt;start_vector(in, tag, &amp;amp;v-&amp;gt;count);\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    v-&amp;gt;data = calloc(v-&amp;gt;count, sizeof(*v-&amp;gt;data));\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    for(i=0;i&amp;lt;v-&amp;gt;count;i++) {\n&quot;);
    -                    genDeserialize(c, jvType, &quot;value&quot;, &quot;data[i]&quot;);
    -                    c.write(&quot;    }\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    rc = in-&amp;gt;end_vector(in, tag);\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;    return rc;\n&quot;);&lt;br/&gt;
    -                    c.write(&quot;}\n&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    +        try {&lt;br/&gt;
    +            for (JField f : mFields) {&lt;br/&gt;
    +                if (f.getType() instanceof JVector) {&lt;br/&gt;
    +                    JVector jv = (JVector) f.getType();&lt;br/&gt;
    +                    JType jvType = jv.getElementType();&lt;br/&gt;
    +                    String struct_name = JVector.extractVectorName(jvType);&lt;br/&gt;
    +                    if (vectorStructs.get(struct_name) == null) {&lt;br/&gt;
    +                        vectorStructs.put(struct_name, struct_name);&lt;br/&gt;
    +                        h.write(&quot;struct &quot; + struct_name + &quot; {n    int32_t count;n&quot; + jv.getElementType().genCDecl(&quot;*data&quot;) + &quot;n}
&lt;p&gt;;\n&quot;);&lt;br/&gt;
    +                        h.write(&quot;int serialize_&quot; + struct_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + struct_name + &quot; *v);\n&quot;);&lt;br/&gt;
    +                        h.write(&quot;int deserialize_&quot; + struct_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + struct_name + &quot; *v);\n&quot;);&lt;br/&gt;
    +                        h.write(&quot;int allocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v, int32_t len);\n&quot;);&lt;br/&gt;
    +                        h.write(&quot;int deallocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v);\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;int allocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v, int32_t len) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +                        c.write(&amp;quot;    if (!len) {\n&quot;);
    +                        c.write(&quot;        v-&amp;gt;count = 0;\n&quot;);
    +                        c.write(&quot;        v-&amp;gt;data = 0;\n&quot;);
    +                        c.write(&quot;    } else {\n&quot;);
    +                        c.write(&quot;        v-&amp;gt;count = len;\n&quot;);
    +                        c.write(&quot;        v-&amp;gt;data = calloc(sizeof(*v-&amp;gt;data), len);\n&quot;);
    +                        c.write(&quot;    }n&amp;quot;);    +                        c.write(&amp;quot;    return 0;n&amp;quot;);    +                        c.write(&amp;quot;}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;int deallocate_&quot; + struct_name + &quot;(struct &quot; + struct_name + &quot; *v) {\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;    if (v-&amp;gt;data) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +                        c.write(&amp;quot;        int32_t i;n&amp;quot;);    +                        c.write(&amp;quot;        for(i=0;i&amp;lt;v-&amp;gt;count; i++) {\n&quot;);
    +                        c.write(&quot;            deallocate_&quot; + JRecord.extractMethodSuffix(jvType) + &quot;(&amp;amp;v-&amp;gt;data[i]);\n&quot;);
    +                        c.write(&quot;        }n&amp;quot;);    +                        c.write(&amp;quot;        free(v-&amp;gt;data);n&amp;quot;);    +                        c.write(&amp;quot;        v-&amp;gt;data = 0;n&amp;quot;);    +                        c.write(&amp;quot;    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;    return 0;\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;}\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;int serialize_&quot; + struct_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + struct_name + &quot; *v)\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +                        c.write(&amp;quot;    int32_t count = v-&amp;gt;count;n&amp;quot;);    +                        c.write(&amp;quot;    int rc = 0;n&amp;quot;);    +                        c.write(&amp;quot;    int32_t i;n&amp;quot;);    +                        c.write(&amp;quot;    rc = out-&amp;gt;start_vector(out, tag, &amp;amp;count);n&amp;quot;);    +                        c.write(&amp;quot;    for(i=0;i&amp;lt;v-&amp;gt;count;i++) {\n&quot;);
    +                        genSerialize(c, jvType, &quot;data&quot;, &quot;data[i]&quot;);
    +                        c.write(&quot;    }n&amp;quot;);    +                        c.write(&amp;quot;    rc = rc ? rc }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;int deserialize_&quot; + struct_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + struct_name + &quot; *v)\n&quot;);&lt;br/&gt;
    +                        c.write(&quot;&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +                        c.write(&amp;quot;    int rc = 0;n&amp;quot;);    +                        c.write(&amp;quot;    int32_t i;n&amp;quot;);    +                        c.write(&amp;quot;    rc = in-&amp;gt;start_vector(in, tag, &amp;amp;v-&amp;gt;count);n&amp;quot;);    +                        c.write(&amp;quot;    v-&amp;gt;data = calloc(v-&amp;gt;count, sizeof(*v-&amp;gt;data));n&amp;quot;);    +                        c.write(&amp;quot;    for(i=0;i&amp;lt;v-&amp;gt;count;i++) {\n&quot;);
    +                        genDeserialize(c, jvType, &quot;value&quot;, &quot;data[i]&quot;);
    +                        c.write(&quot;    }n&amp;quot;);    +                        c.write(&amp;quot;    rc = in-&amp;gt;end_vector(in, tag);n&amp;quot;);    +                        c.write(&amp;quot;    return rc;n&amp;quot;);    +                        c.write(&amp;quot;}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +                    }&lt;br/&gt;
                     }&lt;br/&gt;
                 }&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;String rec_name = getName();&lt;/li&gt;
	&lt;li&gt;h.write(&quot;struct &quot; + rec_name + &quot; {\n&quot;);&lt;/li&gt;
	&lt;li&gt;for (JField f : mFields) 
{
    -            h.write(f.genCDecl());
    -        }&lt;/li&gt;
	&lt;li&gt;h.write(&quot;};\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;int serialize_&quot; + rec_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + rec_name + &quot; *v);\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;int deserialize_&quot; + rec_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + rec_name + &quot;*v);\n&quot;);&lt;/li&gt;
	&lt;li&gt;h.write(&quot;void deallocate_&quot; + rec_name + &quot;(struct &quot; + rec_name + &quot;*);\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;int serialize_&quot; + rec_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + rec_name + &quot; *v)&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;{\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    int rc;\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    rc = out-&amp;gt;start_record(out, tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;for(JField f : mFields) 
{
    -            genSerialize(c, f.getType(), f.getTag(), f.getName());
    -        }&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    rc = rc ? rc : out-&amp;gt;end_record(out, tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    return rc;\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;}\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;int deserialize_&quot; + rec_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + rec_name + &quot;*v)&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;{\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    int rc;\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    rc = in-&amp;gt;start_record(in, tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;for(JField f : mFields) 
{
    -            genDeserialize(c, f.getType(), f.getTag(), f.getName());
    -        }&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    rc = rc ? rc : in-&amp;gt;end_record(in, tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    return rc;\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;}\n&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;void deallocate_&quot; + rec_name + &quot;(struct &quot; + rec_name + &quot;*v)&quot;);&lt;/li&gt;
	&lt;li&gt;c.write(&quot;{\n&quot;);&lt;/li&gt;
	&lt;li&gt;for(JField f : mFields) {&lt;/li&gt;
	&lt;li&gt;if (f.getType() instanceof JRecord) 
{
    -                c.write(&quot;    deallocate_&quot; + extractStructName(f.getType()) + &quot;(&amp;amp;v-&amp;gt;&quot; + f.getName() + &quot;);\n&quot;);
    -            }
&lt;p&gt; else if (f.getType() instanceof JVector) &lt;/p&gt;
{
    -                JVector vt = (JVector)f.getType();
    -                c.write(&quot;    deallocate_&quot; + JVector.extractVectorName(vt.getElementType())+ &quot;(&amp;amp;v-&amp;gt;&quot;+f.getName()+&quot;);\n&quot;);
    -            }
&lt;p&gt; else if (f.getType() instanceof JCompType) {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;c.write(&quot;    deallocate_&quot; + extractMethodSuffix(f.getType()) + &quot;(&amp;amp;v-&amp;gt;&quot;&lt;ins&gt;f.getName()&lt;/ins&gt;&quot;);\n&quot;);&lt;br/&gt;
    +            String rec_name = getName();&lt;br/&gt;
    +            h.write(&quot;struct &quot; + rec_name + &quot; 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            for (JField f }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;;\n&quot;);&lt;br/&gt;
    +            h.write(&quot;int serialize_&quot; + rec_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + rec_name + &quot; *v);\n&quot;);&lt;br/&gt;
    +            h.write(&quot;int deserialize_&quot; + rec_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + rec_name + &quot;*v);\n&quot;);&lt;br/&gt;
    +            h.write(&quot;void deallocate_&quot; + rec_name + &quot;(struct &quot; + rec_name + &quot;*);\n&quot;);&lt;br/&gt;
    +            c.write(&quot;int serialize_&quot; + rec_name + &quot;(struct oarchive *out, const char *tag, struct &quot; + rec_name + &quot; *v)&quot;);&lt;br/&gt;
    +            c.write(&quot;&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            c.write(&amp;quot;    int rc;n&amp;quot;);    +            c.write(&amp;quot;    rc = out-&amp;gt;start_record(out, tag);n&amp;quot;);    +            for (JField f }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            c.write(&quot;int deserialize_&quot; + rec_name + &quot;(struct iarchive *in, const char *tag, struct &quot; + rec_name + &quot;*v)&quot;);&lt;br/&gt;
    +            c.write(&quot;&lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            c.write(&amp;quot;    int rc;n&amp;quot;);    +            c.write(&amp;quot;    rc = in-&amp;gt;start_record(in, tag);n&amp;quot;);    +            for (JField f }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            c.write(&quot;void deallocate_&quot; + rec_name + &quot;(struct &quot; + rec_name + &quot;*v)&quot;);&lt;br/&gt;
    +            c.write(&quot;{\n&quot;);&lt;br/&gt;
    +            for (JField f : mFields) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                if (f.getType() instanceof JRecord) {
    +                    c.write(&quot;    deallocate_&quot; + extractStructName(f.getType()) + &quot;(&amp;amp;v-&amp;gt;&quot; + f.getName() + &quot;);\n&quot;);
    +                } else if (f.getType() instanceof JVector) {
    +                    JVector vt = (JVector) f.getType();
    +                    c.write(&quot;    deallocate_&quot; + JVector.extractVectorName(vt.getElementType()) + &quot;(&amp;amp;v-&amp;gt;&quot; + f.getName() + &quot;);\n&quot;);
    +                } else if (f.getType() instanceof JCompType) {
    +                    c.write(&quot;    deallocate_&quot; + extractMethodSuffix(f.getType()) + &quot;(&amp;amp;v-&amp;gt;&quot; + f.getName() + &quot;);\n&quot;);
    +                }    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            c.write(&quot;}\n&quot;);&lt;br/&gt;
    +        } catch (IOException e) &lt;/p&gt;
{
    +            throw e;
    +        }
&lt;p&gt; finally {&lt;br/&gt;
    +            if (h != null) {&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Just speculating here: couldn&apos;t we write this snippet as:&lt;/p&gt;

&lt;p&gt;    ```&lt;br/&gt;
    private IOException maybeClose(FileWriter file) {&lt;br/&gt;
           IOException t = null;&lt;br/&gt;
           if (file != null) {&lt;br/&gt;
                 try &lt;/p&gt;
{
                         file.close();
                 }
&lt;p&gt; catch (IOException ex) &lt;/p&gt;
{
                       t = ex;
                 }
&lt;p&gt;          &lt;br/&gt;
         }&lt;br/&gt;
        return t;&lt;br/&gt;
    }&lt;/p&gt;

&lt;p&gt;    (...)&lt;/p&gt;

&lt;p&gt;    } finally {&lt;/p&gt;

&lt;p&gt;        IOException e1 = maybeClose(h);&lt;br/&gt;
        IOException e2 = maybeClose(c);&lt;/p&gt;

&lt;p&gt;        if (e1 != null) &lt;/p&gt;
{
            throw e1;
        }

&lt;p&gt;       if (e2 != null) &lt;/p&gt;
{
           throw e2;
       }
&lt;p&gt;    }&lt;/p&gt;


&lt;p&gt;    ```&lt;/p&gt;</comment>
                            <comment id="15648179" author="githubbot" created="Tue, 8 Nov 2016 17:25:27 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87026194&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87026194&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/version/util/VerGen.java &amp;#8212;&lt;br/&gt;
    @@ -50,10 +50,8 @@ public static void generateFile(File outputDir, Version version, int rev, String&lt;br/&gt;
                 System.out.println(path + &quot; is not a directory.&quot;);&lt;br/&gt;
                 System.exit(1);&lt;br/&gt;
             }&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;File file = new File(pkgdir, TYPE_NAME + &quot;.java&quot;);&lt;/li&gt;
	&lt;li&gt;FileWriter w = null;&lt;/li&gt;
	&lt;li&gt;try {&lt;/li&gt;
	&lt;li&gt;w = new FileWriter(file);&lt;br/&gt;
    +&lt;br/&gt;
    +        try (FileWriter w = new FileWriter(new File(pkgdir, TYPE_NAME + &quot;.java&quot;))&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; {
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    nit: spurious &quot;;&quot;&lt;/p&gt;</comment>
                            <comment id="15648697" author="githubbot" created="Tue, 8 Nov 2016 20:22:49 +0000"  >&lt;p&gt;Github user hanm commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Updated PR to address review comments from @eribeiro.&lt;/p&gt;</comment>
                            <comment id="15651880" author="githubbot" created="Wed, 9 Nov 2016 19:54:29 +0000"  >&lt;p&gt;Github user lvfangmin commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87265113&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87265113&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java &amp;#8212;&lt;br/&gt;
    @@ -151,9 +153,13 @@&lt;br/&gt;
          */&lt;br/&gt;
         public final static int telnetCloseCmd = 0xfff4fffd;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public final static HashMap&amp;lt;Integer, String&amp;gt; cmd2String =&lt;br/&gt;
    +    final static HashMap&amp;lt;Integer, String&amp;gt; cmd2String =
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Same here, we can also define this as Map to keep consistent with the others.&lt;/p&gt;</comment>
                            <comment id="15651881" author="githubbot" created="Wed, 9 Nov 2016 19:54:29 +0000"  >&lt;p&gt;Github user lvfangmin commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87264725&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87264725&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/server/DataTree.java &amp;#8212;&lt;br/&gt;
    @@ -1293,13 +1293,12 @@ public synchronized WatchesSummary getWatchesSummary() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param pwriter the output to write to&lt;br/&gt;
          */&lt;br/&gt;
         public void dumpEphemerals(PrintWriter pwriter) {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Set&amp;lt;Long&amp;gt; keys = ephemerals.keySet();&lt;br/&gt;
             pwriter.println(&quot;Sessions with Ephemerals (&quot;&lt;/li&gt;
	&lt;li&gt;+ keys.size() + &quot;):&quot;);&lt;/li&gt;
	&lt;li&gt;for (long k : keys) {&lt;/li&gt;
	&lt;li&gt;pwriter.print(&quot;0x&quot; + Long.toHexString(k));&lt;br/&gt;
    +                + ephemerals.keySet().size() + &quot;):&quot;);&lt;br/&gt;
    +        for (Entry&amp;lt;Long, HashSet&amp;lt;String&amp;gt;&amp;gt; entry : ephemerals.entrySet()) {&lt;br/&gt;
    +            pwriter.print(&quot;0x&quot; + Long.toHexString(entry.getKey()));&lt;br/&gt;
                 pwriter.println(&quot;:&quot;);&lt;/li&gt;
	&lt;li&gt;HashSet&amp;lt;String&amp;gt; tmp = ephemerals.get(k);&lt;br/&gt;
    +            HashSet&amp;lt;String&amp;gt; tmp = entry.getValue();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Usually, prefer to use the interface if we only use the methods defined in the interface, which makes it flexible (or less change needed) in case we want to use another Set implementation. &lt;/p&gt;

&lt;p&gt;    There is a best practice defined in Effective Java 2nd Edition, Item 52: Refer to objects by their interfaces:&lt;br/&gt;
    If appropriate interface types exist, then parameters, return values, and fields should all be declared using interface types. If you get into the habit of using interface types, your program will be much more flexible. It is entirely appropriate to refer to an object by a class if no appropriate interface exists.&lt;/p&gt;</comment>
                            <comment id="15654879" author="githubbot" created="Thu, 10 Nov 2016 19:23:04 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r87466839&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r87466839&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/server/DataTree.java &amp;#8212;&lt;br/&gt;
    @@ -1293,13 +1293,12 @@ public synchronized WatchesSummary getWatchesSummary() {&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@param pwriter the output to write to&lt;br/&gt;
          */&lt;br/&gt;
         public void dumpEphemerals(PrintWriter pwriter) {&lt;/li&gt;
&lt;/ul&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;Set&amp;lt;Long&amp;gt; keys = ephemerals.keySet();&lt;br/&gt;
             pwriter.println(&quot;Sessions with Ephemerals (&quot;&lt;/li&gt;
	&lt;li&gt;+ keys.size() + &quot;):&quot;);&lt;/li&gt;
	&lt;li&gt;for (long k : keys) {&lt;/li&gt;
	&lt;li&gt;pwriter.print(&quot;0x&quot; + Long.toHexString(k));&lt;br/&gt;
    +                + ephemerals.keySet().size() + &quot;):&quot;);&lt;br/&gt;
    +        for (Entry&amp;lt;Long, HashSet&amp;lt;String&amp;gt;&amp;gt; entry : ephemerals.entrySet()) {&lt;br/&gt;
    +            pwriter.print(&quot;0x&quot; + Long.toHexString(entry.getKey()));&lt;br/&gt;
                 pwriter.println(&quot;:&quot;);&lt;/li&gt;
	&lt;li&gt;HashSet&amp;lt;String&amp;gt; tmp = ephemerals.get(k);&lt;br/&gt;
    +            HashSet&amp;lt;String&amp;gt; tmp = entry.getValue();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Ya @lvfangmin, one of my favourite books on Java, and was the reference to my comment above. Thanks pointing out. :smiley:&lt;/p&gt;

&lt;p&gt;    Agree with @hanm, better to create a separate issue for dealing with this legacy technical debt. :+1: &lt;/p&gt;</comment>
                            <comment id="15668655" author="githubbot" created="Tue, 15 Nov 2016 22:58:20 +0000"  >&lt;p&gt;Github user hanm closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15668685" author="githubbot" created="Tue, 15 Nov 2016 23:09:53 +0000"  >&lt;p&gt;GitHub user hanm reopened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;: Fix findbug warnings.&lt;/p&gt;

&lt;p&gt;    This PR fixed 19 find bug warnings except this one, which might require interface change that potentially could break client side apps.&lt;/p&gt;

&lt;p&gt;    Malicious code vulnerability Warnings&lt;br/&gt;
    org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE is a mutable collection&lt;br/&gt;
    Bug type MS_MUTABLE_COLLECTION (click for details) &lt;br/&gt;
    In class org.apache.zookeeper.ZooDefs$Ids&lt;br/&gt;
    Field org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE&lt;br/&gt;
    At ZooDefs.java:&lt;span class=&quot;error&quot;&gt;&amp;#91;line 116&amp;#93;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/hanm/zookeeper&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/hanm/zookeeper&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #102&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit fbb0957167f42ba64ab3eab15fae4b8dce9b0f4b&lt;br/&gt;
Author: Michael Han &amp;lt;hanm@cloudera.com&amp;gt;&lt;br/&gt;
Date:   2016-11-15T23:09:02Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;: Fix findbug warnings.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15668696" author="githubbot" created="Tue, 15 Nov 2016 23:14:54 +0000"  >&lt;p&gt;Github user hanm commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Update: disable &quot;Malicious code vulnerability Warnings&quot; appertains to org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE, and we will use &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-1362&quot; title=&quot;ZooDefs.Ids ACL lists not immutable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-1362&quot;&gt;ZOOKEEPER-1362&lt;/a&gt; for this work.&lt;/p&gt;

&lt;p&gt;    Can we get this merged? Would be good to have findbug clean again for pre-commit builds.&lt;/p&gt;</comment>
                            <comment id="15668708" author="hadoopqa" created="Tue, 15 Nov 2016 23:20:04 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +0 tests included.  The patch appears to be a documentation patch that doesn&apos;t require tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    -1 findbugs.  The patch appears to introduce 20 new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/72//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="15668763" author="hadoopqa" created="Tue, 15 Nov 2016 23:39:53 +0000"  >&lt;p&gt;-1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +1 tests included.  The patch appears to include 3 new or modified tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    -1 core tests.  The patch failed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/73//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                            <comment id="15689655" author="githubbot" created="Wed, 23 Nov 2016 10:13:56 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89283699&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89283699&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/cli/DeleteCommand.java &amp;#8212;&lt;br/&gt;
    @@ -56,14 +56,7 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;         private void retainCompatibility(String[] cmdArgs) throws CliParseException {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// delete path &lt;span class=&quot;error&quot;&gt;&amp;#91;version&amp;#93;&lt;/span&gt;&lt;br/&gt;
             if (args.length &amp;gt; 2) {&lt;/li&gt;
	&lt;li&gt;// rewrite to option&lt;/li&gt;
	&lt;li&gt;String [] newCmd = new String&lt;span class=&quot;error&quot;&gt;&amp;#91;4&amp;#93;&lt;/span&gt;;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why are we removing this rewrite?&lt;/p&gt;</comment>
                            <comment id="15689656" author="githubbot" created="Wed, 23 Nov 2016 10:13:56 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89284431&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89284431&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/config/findbugsExcludeFile.xml &amp;#8212;&lt;br/&gt;
    @@ -144,4 +144,10 @@&lt;br/&gt;
         &amp;lt;Bug pattern=&quot;DM_DEFAULT_ENCODING&quot; /&amp;gt;&lt;br/&gt;
       &amp;lt;/Match&amp;gt;&lt;/p&gt;

&lt;p&gt;    +  &amp;lt;!-- Disable &apos;Malicious code vulnerability warnings&apos; due to mutable collection types in interface.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    We probably want to leave a note in &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-1362&quot; title=&quot;ZooDefs.Ids ACL lists not immutable&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-1362&quot;&gt;ZOOKEEPER-1362&lt;/a&gt; to remind ourselves to do it.&lt;/p&gt;</comment>
                            <comment id="15689657" author="githubbot" created="Wed, 23 Nov 2016 10:13:56 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89285632&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89285632&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/JRecord.java &amp;#8212;&lt;br/&gt;
    @@ -576,174 +580,174 @@ public void genCsharpCode(File outputDirectory) throws IOException {&lt;br/&gt;
             } else if (!outputDirectory.isDirectory()) &lt;/p&gt;
{
                 throw new IOException(outputDirectory + &quot; is not a directory.&quot;);
             }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;File csharpFile = new File(outputDirectory, getName()+&quot;.cs&quot;);&lt;/li&gt;
	&lt;li&gt;FileWriter cs = new FileWriter(csharpFile);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;using System;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;using Org.Apache.Jute;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;namespace &quot;&lt;ins&gt;getCsharpNameSpace()&lt;/ins&gt;&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;{\n&quot;);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String className = getCsharpName();&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;public class &quot;&lt;ins&gt;className&lt;/ins&gt;&quot; : IRecord, IComparable \n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;{\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public &quot;+ className +&quot;() 
{\n&quot;);
    -        cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public &quot;&lt;ins&gt;className&lt;/ins&gt;&quot;(\n&quot;);&lt;/li&gt;
	&lt;li&gt;int fIdx = 0;&lt;/li&gt;
	&lt;li&gt;int fLen = mFields.size();&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
    -            cs.write((fLen-1 == fIdx)?&quot;&quot;:&quot;,\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  }\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {&lt;/li&gt;
	&lt;li&gt;JField jf = i.next();&lt;/li&gt;
	&lt;li&gt;cs.write(jf.genCsharpGetSet(fIdx));&lt;br/&gt;
    +&lt;br/&gt;
    +        try (FileWriter cs = new FileWriter(new File(outputDirectory, getName() + &quot;.cs&quot;))&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    +            cs.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);
    +            cs.write(&quot;/**\n&quot;);
    +            cs.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);
    +            cs.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);
    +            cs.write(&quot;* distributed with this work for additional information\n&quot;);
    +            cs.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);
    +            cs.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);
    +            cs.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);
    +            cs.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);
    +            cs.write(&quot;*\n&quot;);
    +            cs.write(&quot;*     http://www.apache.org/licenses/LICENSE-2.0\n&quot;);
    +            cs.write(&quot;*\n&quot;);
    +            cs.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);
    +            cs.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);
    +            cs.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);
    +            cs.write(&quot;* See the License for the specific language governing permissions and\n&quot;);
    +            cs.write(&quot;* limitations under the License.\n&quot;);
    +            cs.write(&quot;*/\n&quot;);
                 cs.write(&quot;\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public void Serialize(IOutputArchive a_, String tag) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    a_.StartRecord(this,tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpWriteMethodName());
    -        }&lt;br/&gt;
    -        cs.write(&quot;    a_.EndRecord(this,tag);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;using System;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;using Org.Apache.Jute;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;namespace &quot; + getCsharpNameSpace() + &quot;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;{\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            String className = getCsharpName();&lt;br/&gt;
    +            cs.write(&quot;public class &quot; + className + &quot; : IRecord, IComparable \n&quot;);&lt;br/&gt;
    +            cs.write(&quot;{\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;  public &quot; + className + &quot;() {\n&quot;);
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public &quot; + className + &quot;(\n&quot;);&lt;br/&gt;
    +            int fIdx = 0;&lt;br/&gt;
    +            int fLen = mFields.size();&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
    +                cs.write((fLen - 1 == fIdx) ? &quot;&quot; : &quot;,\n&quot;);
    +            }&lt;br/&gt;
    +            cs.write(&quot;) {\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
    +            }&lt;br/&gt;
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpGetSet(fIdx));
    +                cs.write(&quot;\n&quot;);
    +            }&lt;br/&gt;
    +            cs.write(&quot;  public void Serialize(IOutputArchive a_, String tag) {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    a_.StartRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpWriteMethodName());
    +            }&lt;br/&gt;
    +            cs.write(&quot;    a_.EndRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
     &lt;br/&gt;
    -        cs.write(&quot;  public void Deserialize(IInputArchive a_, String tag) {\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;    a_.StartRecord(tag);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpReadMethodName());
    -        }&lt;br/&gt;
    -        cs.write(&quot;    a_.EndRecord(tag);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;}\n&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -        cs.write(&quot;  public override String ToString() {\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;    try {\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      System.IO.MemoryStream ms = new System.IO.MemoryStream();\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      MiscUtil.IO.EndianBinaryWriter writer =\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      BinaryOutputArchive a_ = \n&quot;);&lt;br/&gt;
    -        cs.write(&quot;        new BinaryOutputArchive(writer);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      a_.StartRecord(this,\&quot;\&quot;);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {    -            JField jf = i.next();    -            cs.write(jf.genCsharpWriteMethodName());    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;      a_.EndRecord(this,\&quot;\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;      ms.Position = 0;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    } catch (Exception ex) 
{\n&quot;);
    -        cs.write(&quot;      Console.WriteLine(ex.StackTrace);\n&quot;);
    -        cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public void Write(MiscUtil.IO.EndianBinaryWriter writer) 
{\n&quot;);
    -        cs.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n&quot;);
    -        cs.write(&quot;    Serialize(archive, \&quot;\&quot;);\n&quot;);
    -        cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) 
{\n&quot;);
    -        cs.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(reader);\n&quot;);
    -        cs.write(&quot;    Deserialize(archive, \&quot;\&quot;);\n&quot;);
    -        cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public int CompareTo (object peer_) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;boolean unimplemented = false;&lt;/li&gt;
	&lt;li&gt;for (JField f : mFields) {&lt;/li&gt;
	&lt;li&gt;if ((f.getType() instanceof JMap)&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; (f.getType() instanceof JVector))&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;{&lt;/li&gt;
	&lt;li&gt;unimplemented = true;&lt;br/&gt;
    +            cs.write(&quot;  public void Deserialize(IInputArchive a_, String tag) {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    a_.StartRecord(tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpReadMethodName());
                 }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (unimplemented) 
{
    -            cs.write(&quot;    throw new InvalidOperationException(\&quot;comparing &quot;
    -                    + getCsharpName() + &quot; is unimplemented\&quot;);\n&quot;);
    -        }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    if (!(peer_ is &quot;&lt;ins&gt;getCsharpName()&lt;/ins&gt;&quot;)) 
{\n&quot;);
    -            cs.write(&quot;      throw new InvalidOperationException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +            cs.write(&quot;    a_.EndRecord(tag);\n&quot;);
    +            cs.write(&quot;}
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public override String ToString() {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    try &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            cs.write(&amp;quot;      System.IO.MemoryStream ms = new System.IO.MemoryStream();n&amp;quot;);    +            cs.write(&amp;quot;      MiscUtil.IO.EndianBinaryWriter writer =n&amp;quot;);    +            cs.write(&amp;quot;        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);n&amp;quot;);    +            cs.write(&amp;quot;      BinaryOutputArchive a_ = n&amp;quot;);    +            cs.write(&amp;quot;        new BinaryOutputArchive(writer);n&amp;quot;);    +            cs.write(&amp;quot;      a_.StartRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            fIdx = 0;    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpWriteMethodName());
    +            }    +            cs.write(&amp;quot;      a_.EndRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            cs.write(&amp;quot;      ms.Position = 0;n&amp;quot;);    +            cs.write(&amp;quot;      return System.Text.Encoding.UTF8.GetString(ms.ToArray());n&amp;quot;);    +            cs.write(&amp;quot;    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (Exception ex) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;      Console.WriteLine(ex.StackTrace);\n&quot;);
                 cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    &quot;&lt;ins&gt;getCsharpName()&lt;/ins&gt;&quot; peer = (&quot;&lt;ins&gt;getCsharpName()&lt;/ins&gt;&quot;) peer_;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    int ret = 0;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public void Write(MiscUtil.IO.EndianBinaryWriter writer) 
{\n&quot;);
    +            cs.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n&quot;);
    +            cs.write(&quot;    Serialize(archive, \&quot;\&quot;);\n&quot;);
    +            cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(reader);\n&quot;);
    +            cs.write(&quot;    Deserialize(archive, \&quot;\&quot;);\n&quot;);
    +            cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public int CompareTo (object peer_) {\n&quot;);&lt;br/&gt;
    +            boolean unimplemented = false;&lt;br/&gt;
    +            for (JField f : mFields) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                if ((f.getType() instanceof JMap)    +                        || (f.getType() instanceof JVector)) {
    +                    unimplemented = true;
    +                }    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            if (unimplemented) &lt;/p&gt;
{
    +                cs.write(&quot;    throw new InvalidOperationException(\&quot;comparing &quot;
    +                        + getCsharpName() + &quot; is unimplemented\&quot;);\n&quot;);
    +            }
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                cs.write(&amp;quot;    if (!(peer_ is &amp;quot; + getCsharpName() + &amp;quot;)) {\n&quot;);
    +                cs.write(&quot;      throw new InvalidOperationException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +                cs.write(&quot;    }n&amp;quot;);    +                cs.write(&amp;quot;    &amp;quot; + getCsharpName() + &amp;quot; peer = (&amp;quot; + getCsharpName() + &amp;quot;) peer_;n&amp;quot;);    +                cs.write(&amp;quot;    int ret = 0;n&amp;quot;);    +                for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                    JField jf = i.next();
    +                    cs.write(jf.genCsharpCompareTo());
    +                    cs.write(&quot;    if (ret != 0) return ret;\n&quot;);
    +                }    +                cs.write(&amp;quot;     return ret;n&amp;quot;);    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public override bool Equals(object peer_) {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    if (!(peer_ is &quot; + getCsharpName() + &quot;)) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;      return false;\n&quot;);
    +            cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    if (peer_ == this) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;      return true;\n&quot;);
    +            cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    bool ret = false;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    &quot; + getCsharpName() + &quot; peer = (&quot; + getCsharpName() + &quot;)peer_;\n&quot;);&lt;br/&gt;
                 for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {&lt;br/&gt;
                     JField jf = i.next();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(jf.genCsharpCompareTo());&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    if (ret != 0) return ret;\n&quot;);&lt;br/&gt;
    +                cs.write(jf.genCsharpEquals());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    What&apos;s the reason for changing to `genCsharpEquals`? I suppose is is the same reason for changing to `genJavaEquals`...&lt;/p&gt;</comment>
                            <comment id="15689658" author="githubbot" created="Wed, 23 Nov 2016 10:13:56 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89264869&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89264869&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/JRecord.java &amp;#8212;&lt;br/&gt;
    @@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {&lt;br/&gt;
             } else if (!pkgdir.isDirectory()) &lt;/p&gt;
{
                 throw new IOException(pkgpath + &quot; is not a directory.&quot;);
             }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;File jfile = new File(pkgdir, getName()+&quot;.java&quot;);&lt;/li&gt;
	&lt;li&gt;FileWriter jj = new FileWriter(jfile);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;package &quot;&lt;ins&gt;getJavaPackage()&lt;/ins&gt;&quot;;\n\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;import org.apache.jute.*;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;public class &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot; implements Record {\n&quot;);&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaDecl());
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;() 
{\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+&quot;.java&quot;))) {&lt;br/&gt;
    +            jj.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            jj.write(&quot;*\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;package &quot; + getJavaPackage() + &quot;;\n\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;import org.apache.jute.*;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;public class &quot; + getName() + &quot; implements Record {\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); ) &lt;/p&gt;
{
    +                JField jf = i.next();
    +                jj.write(jf.genJavaDecl());
    +            }
&lt;p&gt;    +            jj.write(&quot;  public &quot; + getName() + &quot;() &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;jj.write(&quot;  public &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;(\n&quot;);&lt;/li&gt;
	&lt;li&gt;int fIdx = 0;&lt;/li&gt;
	&lt;li&gt;int fLen = mFields.size();&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaConstructorParam(jf.getName()));
    -            jj.write((fLen-1 == fIdx)?&quot;&quot;:&quot;,\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaConstructorSet(jf.getName()));
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  }\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaGetSet(fIdx));
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    a_.startRecord(this,tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaWriteMethodName());
    -        }&lt;br/&gt;
    -        jj.write(&quot;    a_.endRecord(this,tag);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  public &quot; + getName() + &quot;(\n&quot;);&lt;br/&gt;
    +            int fIdx = 0;&lt;br/&gt;
    +            int fLen = mFields.size();&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaConstructorParam(jf.getName()));
    +                jj.write((fLen - 1 == fIdx) ? &quot;&quot; : &quot;,\n&quot;);
    +            }&lt;br/&gt;
    +            jj.write(&quot;) {\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaConstructorSet(jf.getName()));
    +            }&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaGetSet(fIdx));
    +            }&lt;br/&gt;
    +            jj.write(&quot;  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    a_.startRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaWriteMethodName());
    +            }&lt;br/&gt;
    +            jj.write(&quot;    a_.endRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
     &lt;br/&gt;
    -        jj.write(&quot;  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;    a_.startRecord(tag);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    -            JField jf = i.next();
    -            jj.write(jf.genJavaReadMethodName());
    -        }&lt;br/&gt;
    -        jj.write(&quot;    a_.endRecord(tag);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;}\n&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -        jj.write(&quot;  public String toString() {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;    try {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      java.io.ByteArrayOutputStream s =\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;        new java.io.ByteArrayOutputStream();\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      CsvOutputArchive a_ = \n&quot;);&lt;br/&gt;
    -        jj.write(&quot;        new CsvOutputArchive(s);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      a_.startRecord(this,\&quot;\&quot;);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {    -            JField jf = i.next();    -            jj.write(jf.genJavaWriteMethodName());    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;      a_.endRecord(this,\&quot;\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;      return new String(s.toByteArray(), \&quot;UTF-8\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    } catch (Throwable ex) 
{\n&quot;);
    -        jj.write(&quot;      ex.printStackTrace();\n&quot;);
    -        jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void write(java.io.DataOutput out) throws java.io.IOException 
{\n&quot;);
    -        jj.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n&quot;);
    -        jj.write(&quot;    serialize(archive, \&quot;\&quot;);\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void readFields(java.io.DataInput in) throws java.io.IOException 
{\n&quot;);
    -        jj.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(in);\n&quot;);
    -        jj.write(&quot;    deserialize(archive, \&quot;\&quot;);\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public int compareTo (Object peer_) throws ClassCastException {\n&quot;);&lt;/li&gt;
	&lt;li&gt;boolean unimplemented = false;&lt;/li&gt;
	&lt;li&gt;for (JField f : mFields) {&lt;/li&gt;
	&lt;li&gt;if ((f.getType() instanceof JMap)&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; (f.getType() instanceof JVector))&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;{&lt;/li&gt;
	&lt;li&gt;unimplemented = true;&lt;br/&gt;
    +            jj.write(&quot;  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    a_.startRecord(tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    +                JField jf = i.next();
    +                jj.write(jf.genJavaReadMethodName());
                 }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (unimplemented) 
{
    -            jj.write(&quot;    throw new UnsupportedOperationException(\&quot;comparing &quot;
    -                    + getName() + &quot; is unimplemented\&quot;);\n&quot;);
    -        }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    if (!(peer_ instanceof &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;)) 
{\n&quot;);
    -            jj.write(&quot;      throw new ClassCastException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +            jj.write(&quot;    a_.endRecord(tag);\n&quot;);
    +            jj.write(&quot;}
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public String toString() {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    try &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            jj.write(&amp;quot;      java.io.ByteArrayOutputStream s =n&amp;quot;);    +            jj.write(&amp;quot;        new java.io.ByteArrayOutputStream();n&amp;quot;);    +            jj.write(&amp;quot;      CsvOutputArchive a_ = n&amp;quot;);    +            jj.write(&amp;quot;        new CsvOutputArchive(s);n&amp;quot;);    +            jj.write(&amp;quot;      a_.startRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            fIdx = 0;    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaWriteMethodName());
    +            }    +            jj.write(&amp;quot;      a_.endRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            jj.write(&amp;quot;      return new String(s.toByteArray(), &amp;quot;UTF-8&amp;quot;);n&amp;quot;);    +            jj.write(&amp;quot;    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (Throwable ex) &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;      ex.printStackTrace();\n&quot;);
                 jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot; peer = (&quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;) peer_;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    int ret = 0;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public void write(java.io.DataOutput out) throws java.io.IOException 
{\n&quot;);
    +            jj.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n&quot;);
    +            jj.write(&quot;    serialize(archive, \&quot;\&quot;);\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public void readFields(java.io.DataInput in) throws java.io.IOException &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(in);\n&quot;);
    +            jj.write(&quot;    deserialize(archive, \&quot;\&quot;);\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public int compareTo (Object peer_) throws ClassCastException {\n&quot;);&lt;br/&gt;
    +            boolean unimplemented = false;&lt;br/&gt;
    +            for (JField f : mFields) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                if ((f.getType() instanceof JMap)    +                        || (f.getType() instanceof JVector)) {
    +                    unimplemented = true;
    +                }    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            if (unimplemented) &lt;/p&gt;
{
    +                jj.write(&quot;    throw new UnsupportedOperationException(\&quot;comparing &quot;
    +                        + getName() + &quot; is unimplemented\&quot;);\n&quot;);
    +            }
&lt;p&gt; else {&lt;br/&gt;
    +                jj.write(&quot;    if (!(peer_ instanceof &quot; + getName() + &quot;)) &lt;/p&gt;
{\n&quot;);
    +                jj.write(&quot;      throw new ClassCastException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +                jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +                jj.write(&quot;    &quot; + getName() + &quot; peer = (&quot; + getName() + &quot;) peer_;\n&quot;);&lt;br/&gt;
    +                jj.write(&quot;    int ret = 0;\n&quot;);&lt;br/&gt;
    +                for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {&lt;br/&gt;
    +                    JField jf = i.next();&lt;br/&gt;
    +                    jj.write(jf.genJavaCompareTo());&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why are we changing to `genJavaEquals` below and not here?&lt;/p&gt;</comment>
                            <comment id="15689660" author="githubbot" created="Wed, 23 Nov 2016 10:13:56 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89283922&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89283922&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java &amp;#8212;&lt;br/&gt;
    @@ -151,9 +153,13 @@&lt;br/&gt;
          */&lt;br/&gt;
         public final static int telnetCloseCmd = 0xfff4fffd;&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;public final static HashMap&amp;lt;Integer, String&amp;gt; cmd2String =&lt;br/&gt;
    +    final static HashMap&amp;lt;Integer, String&amp;gt; cmd2String =
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If we can remove this `public`, then I think we should. Also agree with the consistent `Map` declaration comment.&lt;/p&gt;</comment>
                            <comment id="15689659" author="githubbot" created="Wed, 23 Nov 2016 10:13:56 +0000"  >&lt;p&gt;Github user fpj commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89264584&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89264584&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/JRecord.java &amp;#8212;&lt;br/&gt;
    @@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {&lt;br/&gt;
             } else if (!pkgdir.isDirectory()) &lt;/p&gt;
{
                 throw new IOException(pkgpath + &quot; is not a directory.&quot;);
             }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;File jfile = new File(pkgdir, getName()+&quot;.java&quot;);&lt;/li&gt;
	&lt;li&gt;FileWriter jj = new FileWriter(jfile);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;package &quot;&lt;ins&gt;getJavaPackage()&lt;/ins&gt;&quot;;\n\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;import org.apache.jute.*;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;public class &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot; implements Record {\n&quot;);&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaDecl());
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;() 
{\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+&quot;.java&quot;))) {&lt;br/&gt;
    +            jj.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            jj.write(&quot;*\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;package &quot; + getJavaPackage() + &quot;;\n\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;import org.apache.jute.*;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;public class &quot; + getName() + &quot; implements Record {\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); ) &lt;/p&gt;
{
    +                JField jf = i.next();
    +                jj.write(jf.genJavaDecl());
    +            }
&lt;p&gt;    +            jj.write(&quot;  public &quot; + getName() + &quot;() &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;jj.write(&quot;  public &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;(\n&quot;);&lt;/li&gt;
	&lt;li&gt;int fIdx = 0;&lt;/li&gt;
	&lt;li&gt;int fLen = mFields.size();&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaConstructorParam(jf.getName()));
    -            jj.write((fLen-1 == fIdx)?&quot;&quot;:&quot;,\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaConstructorSet(jf.getName()));
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  }\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaGetSet(fIdx));
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    a_.startRecord(this,tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaWriteMethodName());
    -        }&lt;br/&gt;
    -        jj.write(&quot;    a_.endRecord(this,tag);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  public &quot; + getName() + &quot;(\n&quot;);&lt;br/&gt;
    +            int fIdx = 0;&lt;br/&gt;
    +            int fLen = mFields.size();&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaConstructorParam(jf.getName()));
    +                jj.write((fLen - 1 == fIdx) ? &quot;&quot; : &quot;,\n&quot;);
    +            }&lt;br/&gt;
    +            jj.write(&quot;) {\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaConstructorSet(jf.getName()));
    +            }&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaGetSet(fIdx));
    +            }&lt;br/&gt;
    +            jj.write(&quot;  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    a_.startRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaWriteMethodName());
    +            }&lt;br/&gt;
    +            jj.write(&quot;    a_.endRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
     &lt;br/&gt;
    -        jj.write(&quot;  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;    a_.startRecord(tag);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    -            JField jf = i.next();
    -            jj.write(jf.genJavaReadMethodName());
    -        }&lt;br/&gt;
    -        jj.write(&quot;    a_.endRecord(tag);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;}\n&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -        jj.write(&quot;  public String toString() {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;    try {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      java.io.ByteArrayOutputStream s =\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;        new java.io.ByteArrayOutputStream();\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      CsvOutputArchive a_ = \n&quot;);&lt;br/&gt;
    -        jj.write(&quot;        new CsvOutputArchive(s);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      a_.startRecord(this,\&quot;\&quot;);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {    -            JField jf = i.next();    -            jj.write(jf.genJavaWriteMethodName());    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;      a_.endRecord(this,\&quot;\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;      return new String(s.toByteArray(), \&quot;UTF-8\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    } catch (Throwable ex) 
{\n&quot;);
    -        jj.write(&quot;      ex.printStackTrace();\n&quot;);
    -        jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void write(java.io.DataOutput out) throws java.io.IOException 
{\n&quot;);
    -        jj.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n&quot;);
    -        jj.write(&quot;    serialize(archive, \&quot;\&quot;);\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void readFields(java.io.DataInput in) throws java.io.IOException 
{\n&quot;);
    -        jj.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(in);\n&quot;);
    -        jj.write(&quot;    deserialize(archive, \&quot;\&quot;);\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public int compareTo (Object peer_) throws ClassCastException {\n&quot;);&lt;/li&gt;
	&lt;li&gt;boolean unimplemented = false;&lt;/li&gt;
	&lt;li&gt;for (JField f : mFields) {&lt;/li&gt;
	&lt;li&gt;if ((f.getType() instanceof JMap)&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; (f.getType() instanceof JVector))&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;{&lt;/li&gt;
	&lt;li&gt;unimplemented = true;&lt;br/&gt;
    +            jj.write(&quot;  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    a_.startRecord(tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    +                JField jf = i.next();
    +                jj.write(jf.genJavaReadMethodName());
                 }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (unimplemented) 
{
    -            jj.write(&quot;    throw new UnsupportedOperationException(\&quot;comparing &quot;
    -                    + getName() + &quot; is unimplemented\&quot;);\n&quot;);
    -        }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    if (!(peer_ instanceof &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;)) 
{\n&quot;);
    -            jj.write(&quot;      throw new ClassCastException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +            jj.write(&quot;    a_.endRecord(tag);\n&quot;);
    +            jj.write(&quot;}
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public String toString() {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    try &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            jj.write(&amp;quot;      java.io.ByteArrayOutputStream s =n&amp;quot;);    +            jj.write(&amp;quot;        new java.io.ByteArrayOutputStream();n&amp;quot;);    +            jj.write(&amp;quot;      CsvOutputArchive a_ = n&amp;quot;);    +            jj.write(&amp;quot;        new CsvOutputArchive(s);n&amp;quot;);    +            jj.write(&amp;quot;      a_.startRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            fIdx = 0;    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaWriteMethodName());
    +            }    +            jj.write(&amp;quot;      a_.endRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            jj.write(&amp;quot;      return new String(s.toByteArray(), &amp;quot;UTF-8&amp;quot;);n&amp;quot;);    +            jj.write(&amp;quot;    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (Throwable ex) &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;      ex.printStackTrace();\n&quot;);
                 jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot; peer = (&quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;) peer_;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    int ret = 0;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public void write(java.io.DataOutput out) throws java.io.IOException 
{\n&quot;);
    +            jj.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n&quot;);
    +            jj.write(&quot;    serialize(archive, \&quot;\&quot;);\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public void readFields(java.io.DataInput in) throws java.io.IOException &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(in);\n&quot;);
    +            jj.write(&quot;    deserialize(archive, \&quot;\&quot;);\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public int compareTo (Object peer_) throws ClassCastException {\n&quot;);&lt;br/&gt;
    +            boolean unimplemented = false;&lt;br/&gt;
    +            for (JField f : mFields) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                if ((f.getType() instanceof JMap)    +                        || (f.getType() instanceof JVector)) {
    +                    unimplemented = true;
    +                }    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            if (unimplemented) &lt;/p&gt;
{
    +                jj.write(&quot;    throw new UnsupportedOperationException(\&quot;comparing &quot;
    +                        + getName() + &quot; is unimplemented\&quot;);\n&quot;);
    +            }
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                jj.write(&amp;quot;    if (!(peer_ instanceof &amp;quot; + getName() + &amp;quot;)) {\n&quot;);
    +                jj.write(&quot;      throw new ClassCastException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +                jj.write(&quot;    }n&amp;quot;);    +                jj.write(&amp;quot;    &amp;quot; + getName() + &amp;quot; peer = (&amp;quot; + getName() + &amp;quot;) peer_;n&amp;quot;);    +                jj.write(&amp;quot;    int ret = 0;n&amp;quot;);    +                for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                    JField jf = i.next();
    +                    jj.write(jf.genJavaCompareTo());
    +                    jj.write(&quot;    if (ret != 0) return ret;\n&quot;);
    +                }    +                jj.write(&amp;quot;     return ret;n&amp;quot;);    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public boolean equals(Object peer_) {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    if (!(peer_ instanceof &quot; + getName() + &quot;)) &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;      return false;\n&quot;);
    +            jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    if (peer_ == this) &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;      return true;\n&quot;);
    +            jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    &quot; + getName() + &quot; peer = (&quot; + getName() + &quot;) peer_;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    boolean ret = false;\n&quot;);&lt;br/&gt;
                 for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {&lt;br/&gt;
                     JField jf = i.next();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(jf.genJavaCompareTo());&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    if (ret != 0) return ret;\n&quot;);&lt;br/&gt;
    +                jj.write(jf.genJavaEquals());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    What&apos;s the reason for changing to `genJavaEquals`?&lt;/p&gt;</comment>
                            <comment id="15689664" author="githubbot" created="Wed, 23 Nov 2016 10:15:16 +0000"  >&lt;p&gt;Github user fpj commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @hanm I&apos;ve left a few comments, but in general looks pretty good. I noticed that there are also unaddressed comments from @lvfangmin and @eribeiro . Could you take care of those so that we can check this in, please?&lt;/p&gt;</comment>
                            <comment id="15689676" author="githubbot" created="Wed, 23 Nov 2016 10:21:55 +0000"  >&lt;p&gt;Github user eribeiro commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89287398&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89287398&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/test/config/findbugsExcludeFile.xml &amp;#8212;&lt;br/&gt;
    @@ -144,4 +144,10 @@&lt;br/&gt;
         &amp;lt;Bug pattern=&quot;DM_DEFAULT_ENCODING&quot; /&amp;gt;&lt;br/&gt;
       &amp;lt;/Match&amp;gt;&lt;/p&gt;

&lt;p&gt;    +  &amp;lt;!-- Disable &apos;Malicious code vulnerability warnings&apos; due to mutable collection types in interface.&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Gonna say that! At least a TODO mark I guess...&lt;/p&gt;</comment>
                            <comment id="15690675" author="githubbot" created="Wed, 23 Nov 2016 16:46:48 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89355986&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89355986&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/JRecord.java &amp;#8212;&lt;br/&gt;
    @@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {&lt;br/&gt;
             } else if (!pkgdir.isDirectory()) &lt;/p&gt;
{
                 throw new IOException(pkgpath + &quot; is not a directory.&quot;);
             }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;File jfile = new File(pkgdir, getName()+&quot;.java&quot;);&lt;/li&gt;
	&lt;li&gt;FileWriter jj = new FileWriter(jfile);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;package &quot;&lt;ins&gt;getJavaPackage()&lt;/ins&gt;&quot;;\n\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;import org.apache.jute.*;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;public class &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot; implements Record {\n&quot;);&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext()&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaDecl());
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;() 
{\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+&quot;.java&quot;))) {&lt;br/&gt;
    +            jj.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;/**\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* distributed with this work for additional information\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;br/&gt;
    +            jj.write(&quot;*\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;* limitations under the License.\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;*/\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;package &quot; + getJavaPackage() + &quot;;\n\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;import org.apache.jute.*;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;public class &quot; + getName() + &quot; implements Record {\n&quot;);&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); ) &lt;/p&gt;
{
    +                JField jf = i.next();
    +                jj.write(jf.genJavaDecl());
    +            }
&lt;p&gt;    +            jj.write(&quot;  public &quot; + getName() + &quot;() &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;jj.write(&quot;  public &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;(\n&quot;);&lt;/li&gt;
	&lt;li&gt;int fIdx = 0;&lt;/li&gt;
	&lt;li&gt;int fLen = mFields.size();&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaConstructorParam(jf.getName()));
    -            jj.write((fLen-1 == fIdx)?&quot;&quot;:&quot;,\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaConstructorSet(jf.getName()));
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  }\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaGetSet(fIdx));
    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    a_.startRecord(this,tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            jj.write(jf.genJavaWriteMethodName());
    -        }&lt;br/&gt;
    -        jj.write(&quot;    a_.endRecord(this,tag);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  public &quot; + getName() + &quot;(\n&quot;);&lt;br/&gt;
    +            int fIdx = 0;&lt;br/&gt;
    +            int fLen = mFields.size();&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaConstructorParam(jf.getName()));
    +                jj.write((fLen - 1 == fIdx) ? &quot;&quot; : &quot;,\n&quot;);
    +            }&lt;br/&gt;
    +            jj.write(&quot;) {\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaConstructorSet(jf.getName()));
    +            }&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaGetSet(fIdx));
    +            }&lt;br/&gt;
    +            jj.write(&quot;  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    a_.startRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaWriteMethodName());
    +            }&lt;br/&gt;
    +            jj.write(&quot;    a_.endRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
     &lt;br/&gt;
    -        jj.write(&quot;  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;    a_.startRecord(tag);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    -            JField jf = i.next();
    -            jj.write(jf.genJavaReadMethodName());
    -        }&lt;br/&gt;
    -        jj.write(&quot;    a_.endRecord(tag);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;}\n&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -        jj.write(&quot;  public String toString() {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;    try {\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      java.io.ByteArrayOutputStream s =\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;        new java.io.ByteArrayOutputStream();\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      CsvOutputArchive a_ = \n&quot;);&lt;br/&gt;
    -        jj.write(&quot;        new CsvOutputArchive(s);\n&quot;);&lt;br/&gt;
    -        jj.write(&quot;      a_.startRecord(this,\&quot;\&quot;);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {    -            JField jf = i.next();    -            jj.write(jf.genJavaWriteMethodName());    -        }&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;      a_.endRecord(this,\&quot;\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;      return new String(s.toByteArray(), \&quot;UTF-8\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    } catch (Throwable ex) 
{\n&quot;);
    -        jj.write(&quot;      ex.printStackTrace();\n&quot;);
    -        jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void write(java.io.DataOutput out) throws java.io.IOException 
{\n&quot;);
    -        jj.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n&quot;);
    -        jj.write(&quot;    serialize(archive, \&quot;\&quot;);\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public void readFields(java.io.DataInput in) throws java.io.IOException 
{\n&quot;);
    -        jj.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(in);\n&quot;);
    -        jj.write(&quot;    deserialize(archive, \&quot;\&quot;);\n&quot;);
    -        jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;  public int compareTo (Object peer_) throws ClassCastException {\n&quot;);&lt;/li&gt;
	&lt;li&gt;boolean unimplemented = false;&lt;/li&gt;
	&lt;li&gt;for (JField f : mFields) {&lt;/li&gt;
	&lt;li&gt;if ((f.getType() instanceof JMap)&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; (f.getType() instanceof JVector))&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;{&lt;/li&gt;
	&lt;li&gt;unimplemented = true;&lt;br/&gt;
    +            jj.write(&quot;  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    a_.startRecord(tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    +                JField jf = i.next();
    +                jj.write(jf.genJavaReadMethodName());
                 }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (unimplemented) 
{
    -            jj.write(&quot;    throw new UnsupportedOperationException(\&quot;comparing &quot;
    -                    + getName() + &quot; is unimplemented\&quot;);\n&quot;);
    -        }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    if (!(peer_ instanceof &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;)) 
{\n&quot;);
    -            jj.write(&quot;      throw new ClassCastException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +            jj.write(&quot;    a_.endRecord(tag);\n&quot;);
    +            jj.write(&quot;}
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public String toString() {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    try &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            jj.write(&amp;quot;      java.io.ByteArrayOutputStream s =n&amp;quot;);    +            jj.write(&amp;quot;        new java.io.ByteArrayOutputStream();n&amp;quot;);    +            jj.write(&amp;quot;      CsvOutputArchive a_ = n&amp;quot;);    +            jj.write(&amp;quot;        new CsvOutputArchive(s);n&amp;quot;);    +            jj.write(&amp;quot;      a_.startRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            fIdx = 0;    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                jj.write(jf.genJavaWriteMethodName());
    +            }    +            jj.write(&amp;quot;      a_.endRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            jj.write(&amp;quot;      return new String(s.toByteArray(), &amp;quot;UTF-8&amp;quot;);n&amp;quot;);    +            jj.write(&amp;quot;    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (Throwable ex) &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;      ex.printStackTrace();\n&quot;);
                 jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    &quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot; peer = (&quot;&lt;ins&gt;getName()&lt;/ins&gt;&quot;) peer_;\n&quot;);&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    int ret = 0;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public void write(java.io.DataOutput out) throws java.io.IOException 
{\n&quot;);
    +            jj.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n&quot;);
    +            jj.write(&quot;    serialize(archive, \&quot;\&quot;);\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public void readFields(java.io.DataInput in) throws java.io.IOException &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(in);\n&quot;);
    +            jj.write(&quot;    deserialize(archive, \&quot;\&quot;);\n&quot;);
    +            jj.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public int compareTo (Object peer_) throws ClassCastException {\n&quot;);&lt;br/&gt;
    +            boolean unimplemented = false;&lt;br/&gt;
    +            for (JField f : mFields) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                if ((f.getType() instanceof JMap)    +                        || (f.getType() instanceof JVector)) {
    +                    unimplemented = true;
    +                }    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            if (unimplemented) &lt;/p&gt;
{
    +                jj.write(&quot;    throw new UnsupportedOperationException(\&quot;comparing &quot;
    +                        + getName() + &quot; is unimplemented\&quot;);\n&quot;);
    +            }
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                jj.write(&amp;quot;    if (!(peer_ instanceof &amp;quot; + getName() + &amp;quot;)) {\n&quot;);
    +                jj.write(&quot;      throw new ClassCastException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +                jj.write(&quot;    }n&amp;quot;);    +                jj.write(&amp;quot;    &amp;quot; + getName() + &amp;quot; peer = (&amp;quot; + getName() + &amp;quot;) peer_;n&amp;quot;);    +                jj.write(&amp;quot;    int ret = 0;n&amp;quot;);    +                for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                    JField jf = i.next();
    +                    jj.write(jf.genJavaCompareTo());
    +                    jj.write(&quot;    if (ret != 0) return ret;\n&quot;);
    +                }    +                jj.write(&amp;quot;     return ret;n&amp;quot;);    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            jj.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            jj.write(&quot;  public boolean equals(Object peer_) {\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    if (!(peer_ instanceof &quot; + getName() + &quot;)) &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;      return false;\n&quot;);
    +            jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    if (peer_ == this) &lt;/p&gt;
{\n&quot;);
    +            jj.write(&quot;      return true;\n&quot;);
    +            jj.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    &quot; + getName() + &quot; peer = (&quot; + getName() + &quot;) peer_;\n&quot;);&lt;br/&gt;
    +            jj.write(&quot;    boolean ret = false;\n&quot;);&lt;br/&gt;
                 for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {&lt;br/&gt;
                     JField jf = i.next();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;jj.write(jf.genJavaCompareTo());&lt;/li&gt;
	&lt;li&gt;jj.write(&quot;    if (ret != 0) return ret;\n&quot;);&lt;br/&gt;
    +                jj.write(jf.genJavaEquals());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Similarly, there is no actual change here.&lt;/p&gt;</comment>
                            <comment id="15690676" author="githubbot" created="Wed, 23 Nov 2016 16:46:56 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89356018&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89356018&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/jute/compiler/JRecord.java &amp;#8212;&lt;br/&gt;
    @@ -576,174 +580,174 @@ public void genCsharpCode(File outputDirectory) throws IOException {&lt;br/&gt;
             } else if (!outputDirectory.isDirectory()) &lt;/p&gt;
{
                 throw new IOException(outputDirectory + &quot; is not a directory.&quot;);
             }
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;File csharpFile = new File(outputDirectory, getName()+&quot;.cs&quot;);&lt;/li&gt;
	&lt;li&gt;FileWriter cs = new FileWriter(csharpFile);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;/**\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* distributed with this work for additional information\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*     &lt;a href=&quot;http://www.apache.org/licenses/LICENSE-2.0n&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.apache.org/licenses/LICENSE-2.0\n&lt;/a&gt;&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* See the License for the specific language governing permissions and\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;* limitations under the License.\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;*/\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;using System;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;using Org.Apache.Jute;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;namespace &quot;&lt;ins&gt;getCsharpNameSpace()&lt;/ins&gt;&quot;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;{\n&quot;);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;String className = getCsharpName();&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;public class &quot;&lt;ins&gt;className&lt;/ins&gt;&quot; : IRecord, IComparable \n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;{\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public &quot;+ className +&quot;() 
{\n&quot;);
    -        cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public &quot;&lt;ins&gt;className&lt;/ins&gt;&quot;(\n&quot;);&lt;/li&gt;
	&lt;li&gt;int fIdx = 0;&lt;/li&gt;
	&lt;li&gt;int fLen = mFields.size();&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
    -            cs.write((fLen-1 == fIdx)?&quot;&quot;:&quot;,\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  }\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {&lt;/li&gt;
	&lt;li&gt;JField jf = i.next();&lt;/li&gt;
	&lt;li&gt;cs.write(jf.genCsharpGetSet(fIdx));&lt;br/&gt;
    +&lt;br/&gt;
    +        try (FileWriter cs = new FileWriter(new File(outputDirectory, getName() + &quot;.cs&quot;))&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; 
{
    +            cs.write(&quot;// File generated by hadoop record compiler. Do not edit.\n&quot;);
    +            cs.write(&quot;/**\n&quot;);
    +            cs.write(&quot;* Licensed to the Apache Software Foundation (ASF) under one\n&quot;);
    +            cs.write(&quot;* or more contributor license agreements.  See the NOTICE file\n&quot;);
    +            cs.write(&quot;* distributed with this work for additional information\n&quot;);
    +            cs.write(&quot;* regarding copyright ownership.  The ASF licenses this file\n&quot;);
    +            cs.write(&quot;* to you under the Apache License, Version 2.0 (the\n&quot;);
    +            cs.write(&quot;* \&quot;License\&quot;); you may not use this file except in compliance\n&quot;);
    +            cs.write(&quot;* with the License.  You may obtain a copy of the License at\n&quot;);
    +            cs.write(&quot;*\n&quot;);
    +            cs.write(&quot;*     http://www.apache.org/licenses/LICENSE-2.0\n&quot;);
    +            cs.write(&quot;*\n&quot;);
    +            cs.write(&quot;* Unless required by applicable law or agreed to in writing, software\n&quot;);
    +            cs.write(&quot;* distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n&quot;);
    +            cs.write(&quot;* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&quot;);
    +            cs.write(&quot;* See the License for the specific language governing permissions and\n&quot;);
    +            cs.write(&quot;* limitations under the License.\n&quot;);
    +            cs.write(&quot;*/\n&quot;);
                 cs.write(&quot;\n&quot;);
    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public void Serialize(IOutputArchive a_, String tag) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    a_.StartRecord(this,tag);\n&quot;);&lt;/li&gt;
	&lt;li&gt;fIdx = 0;&lt;/li&gt;
	&lt;li&gt;for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpWriteMethodName());
    -        }&lt;br/&gt;
    -        cs.write(&quot;    a_.EndRecord(this,tag);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;using System;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;using Org.Apache.Jute;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;namespace &quot; + getCsharpNameSpace() + &quot;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;{\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            String className = getCsharpName();&lt;br/&gt;
    +            cs.write(&quot;public class &quot; + className + &quot; : IRecord, IComparable \n&quot;);&lt;br/&gt;
    +            cs.write(&quot;{\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;  public &quot; + className + &quot;() {\n&quot;);
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public &quot; + className + &quot;(\n&quot;);&lt;br/&gt;
    +            int fIdx = 0;&lt;br/&gt;
    +            int fLen = mFields.size();&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
    +                cs.write((fLen - 1 == fIdx) ? &quot;&quot; : &quot;,\n&quot;);
    +            }&lt;br/&gt;
    +            cs.write(&quot;) {\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
    +            }&lt;br/&gt;
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpGetSet(fIdx));
    +                cs.write(&quot;\n&quot;);
    +            }&lt;br/&gt;
    +            cs.write(&quot;  public void Serialize(IOutputArchive a_, String tag) {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    a_.StartRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpWriteMethodName());
    +            }&lt;br/&gt;
    +            cs.write(&quot;    a_.EndRecord(this,tag);\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
     &lt;br/&gt;
    -        cs.write(&quot;  public void Deserialize(IInputArchive a_, String tag) {\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;    a_.StartRecord(tag);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    -            JField jf = i.next();
    -            cs.write(jf.genCsharpReadMethodName());
    -        }&lt;br/&gt;
    -        cs.write(&quot;    a_.EndRecord(tag);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;}\n&quot;);&lt;br/&gt;
    -&lt;br/&gt;
    -        cs.write(&quot;  public override String ToString() {\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;    try {\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      System.IO.MemoryStream ms = new System.IO.MemoryStream();\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      MiscUtil.IO.EndianBinaryWriter writer =\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      BinaryOutputArchive a_ = \n&quot;);&lt;br/&gt;
    -        cs.write(&quot;        new BinaryOutputArchive(writer);\n&quot;);&lt;br/&gt;
    -        cs.write(&quot;      a_.StartRecord(this,\&quot;\&quot;);\n&quot;);&lt;br/&gt;
    -        fIdx = 0;&lt;br/&gt;
    -        for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {    -            JField jf = i.next();    -            cs.write(jf.genCsharpWriteMethodName());    -        }&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;      a_.EndRecord(this,\&quot;\&quot;);\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;      ms.Position = 0;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    } catch (Exception ex) 
{\n&quot;);
    -        cs.write(&quot;      Console.WriteLine(ex.StackTrace);\n&quot;);
    -        cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    -&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public void Write(MiscUtil.IO.EndianBinaryWriter writer) 
{\n&quot;);
    -        cs.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n&quot;);
    -        cs.write(&quot;    Serialize(archive, \&quot;\&quot;);\n&quot;);
    -        cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) 
{\n&quot;);
    -        cs.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(reader);\n&quot;);
    -        cs.write(&quot;    Deserialize(archive, \&quot;\&quot;);\n&quot;);
    -        cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    -&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;  public int CompareTo (object peer_) {\n&quot;);&lt;/li&gt;
	&lt;li&gt;boolean unimplemented = false;&lt;/li&gt;
	&lt;li&gt;for (JField f : mFields) {&lt;/li&gt;
	&lt;li&gt;if ((f.getType() instanceof JMap)&lt;/li&gt;
	&lt;li&gt;&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; (f.getType() instanceof JVector))&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;
	&lt;li&gt;{&lt;/li&gt;
	&lt;li&gt;unimplemented = true;&lt;br/&gt;
    +            cs.write(&quot;  public void Deserialize(IInputArchive a_, String tag) {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    a_.StartRecord(tag);\n&quot;);&lt;br/&gt;
    +            fIdx = 0;&lt;br/&gt;
    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) 
{
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpReadMethodName());
                 }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (unimplemented) 
{
    -            cs.write(&quot;    throw new InvalidOperationException(\&quot;comparing &quot;
    -                    + getCsharpName() + &quot; is unimplemented\&quot;);\n&quot;);
    -        }
&lt;p&gt; else {&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    if (!(peer_ is &quot;&lt;ins&gt;getCsharpName()&lt;/ins&gt;&quot;)) 
{\n&quot;);
    -            cs.write(&quot;      throw new InvalidOperationException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +            cs.write(&quot;    a_.EndRecord(tag);\n&quot;);
    +            cs.write(&quot;}
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public override String ToString() {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    try &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {n&amp;quot;);    +            cs.write(&amp;quot;      System.IO.MemoryStream ms = new System.IO.MemoryStream();n&amp;quot;);    +            cs.write(&amp;quot;      MiscUtil.IO.EndianBinaryWriter writer =n&amp;quot;);    +            cs.write(&amp;quot;        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);n&amp;quot;);    +            cs.write(&amp;quot;      BinaryOutputArchive a_ = n&amp;quot;);    +            cs.write(&amp;quot;        new BinaryOutputArchive(writer);n&amp;quot;);    +            cs.write(&amp;quot;      a_.StartRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            fIdx = 0;    +            for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                JField jf = i.next();
    +                cs.write(jf.genCsharpWriteMethodName());
    +            }    +            cs.write(&amp;quot;      a_.EndRecord(this,&amp;quot;&amp;quot;);n&amp;quot;);    +            cs.write(&amp;quot;      ms.Position = 0;n&amp;quot;);    +            cs.write(&amp;quot;      return System.Text.Encoding.UTF8.GetString(ms.ToArray());n&amp;quot;);    +            cs.write(&amp;quot;    }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt; catch (Exception ex) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;      Console.WriteLine(ex.StackTrace);\n&quot;);
                 cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    &quot;&lt;ins&gt;getCsharpName()&lt;/ins&gt;&quot; peer = (&quot;&lt;ins&gt;getCsharpName()&lt;/ins&gt;&quot;) peer_;\n&quot;);&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    int ret = 0;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    return \&quot;ERROR\&quot;;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public void Write(MiscUtil.IO.EndianBinaryWriter writer) 
{\n&quot;);
    +            cs.write(&quot;    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n&quot;);
    +            cs.write(&quot;    Serialize(archive, \&quot;\&quot;);\n&quot;);
    +            cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;    BinaryInputArchive archive = new BinaryInputArchive(reader);\n&quot;);
    +            cs.write(&quot;    Deserialize(archive, \&quot;\&quot;);\n&quot;);
    +            cs.write(&quot;  }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public int CompareTo (object peer_) {\n&quot;);&lt;br/&gt;
    +            boolean unimplemented = false;&lt;br/&gt;
    +            for (JField f : mFields) &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                if ((f.getType() instanceof JMap)    +                        || (f.getType() instanceof JVector)) {
    +                    unimplemented = true;
    +                }    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            if (unimplemented) &lt;/p&gt;
{
    +                cs.write(&quot;    throw new InvalidOperationException(\&quot;comparing &quot;
    +                        + getCsharpName() + &quot; is unimplemented\&quot;);\n&quot;);
    +            }
&lt;p&gt; else &lt;/p&gt;
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {    +                cs.write(&amp;quot;    if (!(peer_ is &amp;quot; + getCsharpName() + &amp;quot;)) {\n&quot;);
    +                cs.write(&quot;      throw new InvalidOperationException(\&quot;Comparing different types of records.\&quot;);\n&quot;);
    +                cs.write(&quot;    }n&amp;quot;);    +                cs.write(&amp;quot;    &amp;quot; + getCsharpName() + &amp;quot; peer = (&amp;quot; + getCsharpName() + &amp;quot;) peer_;n&amp;quot;);    +                cs.write(&amp;quot;    int ret = 0;n&amp;quot;);    +                for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {
    +                    JField jf = i.next();
    +                    cs.write(jf.genCsharpCompareTo());
    +                    cs.write(&quot;    if (ret != 0) return ret;\n&quot;);
    +                }    +                cs.write(&amp;quot;     return ret;n&amp;quot;);    +            }&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;    +            cs.write(&quot;  }\n&quot;);&lt;br/&gt;
    +&lt;br/&gt;
    +            cs.write(&quot;  public override bool Equals(object peer_) {\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    if (!(peer_ is &quot; + getCsharpName() + &quot;)) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;      return false;\n&quot;);
    +            cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    if (peer_ == this) &lt;/p&gt;
{\n&quot;);
    +            cs.write(&quot;      return true;\n&quot;);
    +            cs.write(&quot;    }
&lt;p&gt;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    bool ret = false;\n&quot;);&lt;br/&gt;
    +            cs.write(&quot;    &quot; + getCsharpName() + &quot; peer = (&quot; + getCsharpName() + &quot;)peer_;\n&quot;);&lt;br/&gt;
                 for (Iterator&amp;lt;JField&amp;gt; i = mFields.iterator(); i.hasNext(); fIdx++) {&lt;br/&gt;
                     JField jf = i.next();&lt;/p&gt;&lt;/li&gt;
	&lt;li&gt;cs.write(jf.genCsharpCompareTo());&lt;/li&gt;
	&lt;li&gt;cs.write(&quot;    if (ret != 0) return ret;\n&quot;);&lt;br/&gt;
    +                cs.write(jf.genCsharpEquals());
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Similarly, there is no actual change here. &lt;/p&gt;</comment>
                            <comment id="15690680" author="githubbot" created="Wed, 23 Nov 2016 16:48:21 +0000"  >&lt;p&gt;Github user hanm commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102#discussion_r89356303&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102#discussion_r89356303&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/java/main/org/apache/zookeeper/cli/DeleteCommand.java &amp;#8212;&lt;br/&gt;
    @@ -56,14 +56,7 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {&lt;br/&gt;
         }&lt;/p&gt;

&lt;p&gt;         private void retainCompatibility(String[] cmdArgs) throws CliParseException {&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;// delete path &lt;span class=&quot;error&quot;&gt;&amp;#91;version&amp;#93;&lt;/span&gt;&lt;br/&gt;
             if (args.length &amp;gt; 2) {&lt;/li&gt;
	&lt;li&gt;// rewrite to option&lt;/li&gt;
	&lt;li&gt;String [] newCmd = new String&lt;span class=&quot;error&quot;&gt;&amp;#91;4&amp;#93;&lt;/span&gt;;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    These are dead code. newCmd was declared but not used so it&apos;s better to remove them. &lt;/p&gt;</comment>
                            <comment id="15690710" author="githubbot" created="Wed, 23 Nov 2016 16:58:38 +0000"  >&lt;p&gt;Github user hanm commented on the issue:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    @fpj Thank you for taking time to double check the patch.&lt;/p&gt;

&lt;p&gt;    &amp;gt;&amp;gt; I noticed that there are also unaddressed comments from @lvfangmin and @eribeiro .&lt;br/&gt;
    The comments were about using Interface type instead of implementation type, and I addressed the comments by creating &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2630&quot; title=&quot;Use interface type instead of implementation type when appropriate.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2630&quot;&gt;&lt;del&gt;ZOOKEEPER-2630&lt;/del&gt;&lt;/a&gt; because this issue is not a regression and is not specifically about findbug warnings, and I think it might be better to address them separately.&lt;/p&gt;

&lt;p&gt;    I&apos;ve left replies on your other comments in PR, please take a look.&lt;/p&gt;</comment>
                            <comment id="15693655" author="githubbot" created="Thu, 24 Nov 2016 16:18:55 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/102&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/102&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15693663" author="fpj" created="Thu, 24 Nov 2016 16:21:27 +0000"  >&lt;p&gt;+1, thanks for the patch &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=hanm&quot; class=&quot;user-hover&quot; rel=&quot;hanm&quot;&gt;hanm&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="15693858" author="hudson" created="Thu, 24 Nov 2016 17:31:05 +0000"  >&lt;p&gt;FAILURE: Integrated in Jenkins build ZooKeeper-trunk #3169 (See &lt;a href=&quot;https://builds.apache.org/job/ZooKeeper-trunk/3169/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/ZooKeeper-trunk/3169/&lt;/a&gt;)&lt;br/&gt;
&lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;: Fix findbug warnings. (fpj: rev b9beabf5cfbb8e447f67a8050486ca2821132f61)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/server/DataTree.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/jute/compiler/CGenerator.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/version/util/VerGen.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/cli/DeleteCommand.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/jute/compiler/CppGenerator.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/test/config/findbugsExcludeFile.xml&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/zookeeper/ZooKeeperMain.java&lt;/li&gt;
	&lt;li&gt;(edit) src/java/main/org/apache/jute/compiler/JRecord.java&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="15694253" author="githubbot" created="Thu, 24 Nov 2016 21:35:23 +0000"  >&lt;p&gt;GitHub user hanm opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/114&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/114&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Fix C client build break caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;    JIRA: &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2636&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/ZOOKEEPER-2636&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    Fix build break by reverting the changes made to JRecord.genCCode in &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2686&quot; title=&quot;Flaky Test: org.apache.zookeeper.test.WatcherTest.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2686&quot;&gt;&lt;del&gt;ZOOKEEPER-2686&lt;/del&gt;&lt;/a&gt;, which prematurely closed the file writers that prevents zookeeper.jute.h and zookeeper.jute.c files from complete generation.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/hanm/zookeeper&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/hanm/zookeeper&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2636&quot; title=&quot;Fix C build break.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2636&quot;&gt;&lt;del&gt;ZOOKEEPER-2636&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/114.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/114.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #114&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 8b2df1dca353946cd265c217e4010d3f080943ba&lt;br/&gt;
Author: Michael Han &amp;lt;hanm@cloudera.com&amp;gt;&lt;br/&gt;
Date:   2016-11-24T21:32:16Z&lt;/p&gt;

&lt;p&gt;    Fix C client build break caused by &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2628&quot; title=&quot;Investigate and fix findbug warnings&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2628&quot;&gt;&lt;del&gt;ZOOKEEPER-2628&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15694255" author="githubbot" created="Thu, 24 Nov 2016 21:35:47 +0000"  >&lt;p&gt;Github user hanm closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/zookeeper/pull/114&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/zookeeper/pull/114&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15694265" author="hanm" created="Thu, 24 Nov 2016 21:41:04 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=fpj&quot; class=&quot;user-hover&quot; rel=&quot;fpj&quot;&gt;fpj&lt;/a&gt; Thanks for reviewing and merging this patch. Unfortunately I just noticed C client build was broken because of one change in the patch. Created &lt;a href=&quot;https://issues.apache.org/jira/browse/ZOOKEEPER-2636&quot; title=&quot;Fix C build break.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;ZOOKEEPER-2636&quot;&gt;&lt;del&gt;ZOOKEEPER-2636&lt;/del&gt;&lt;/a&gt; where I did post mortem analysis and the fix to the broken build.&lt;/p&gt;</comment>
                            <comment id="15694286" author="hadoopqa" created="Thu, 24 Nov 2016 21:54:41 +0000"  >&lt;p&gt;+1 overall.  GitHub Pull Request  Build&lt;/p&gt;


&lt;p&gt;    +1 @author.  The patch does not contain any @author tags.&lt;/p&gt;

&lt;p&gt;    +0 tests included.  The patch appears to be a documentation patch that doesn&apos;t require tests.&lt;/p&gt;

&lt;p&gt;    +1 javadoc.  The javadoc tool did not generate any warning messages.&lt;/p&gt;

&lt;p&gt;    +1 javac.  The applied patch does not increase the total number of javac compiler warnings.&lt;/p&gt;

&lt;p&gt;    +1 findbugs.  The patch does not introduce any new Findbugs (version 3.0.1) warnings.&lt;/p&gt;

&lt;p&gt;    +1 release audit.  The applied patch does not increase the total number of release audit warnings.&lt;/p&gt;

&lt;p&gt;    +1 core tests.  The patch passed core unit tests.&lt;/p&gt;

&lt;p&gt;    +1 contrib tests.  The patch passed contrib unit tests.&lt;/p&gt;

&lt;p&gt;Test results: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//testReport/&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//testReport/&lt;/a&gt;&lt;br/&gt;
Findbugs warnings: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//artifact/trunk/build/test/findbugs/newPatchFindbugsWarnings.html&lt;/a&gt;&lt;br/&gt;
Console output: &lt;a href=&quot;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//console&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://builds.apache.org/job/PreCommit-ZOOKEEPER-github-pr-build/86//console&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This message is automatically generated.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="12310050">
                    <name>Regression</name>
                                            <outwardlinks description="breaks">
                                        <issuelink>
            <issuekey id="13023262">ZOOKEEPER-2636</issuekey>
        </issuelink>
                            </outwardlinks>
                                                        </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                    <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            8 years, 51 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i35x0n:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </customfields>
    </item>
</channel>
</rss>