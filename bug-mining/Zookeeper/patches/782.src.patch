diff --git a/src/java/main/org/apache/jute/compiler/CGenerator.java b/src/java/main/org/apache/jute/compiler/CGenerator.java
index 4bfdcadc9..af931c9a8 100644
--- a/src/java/main/org/apache/jute/compiler/CGenerator.java
+++ b/src/java/main/org/apache/jute/compiler/CGenerator.java
@@ -61,70 +61,69 @@ void genCode() throws IOException {
                         + outputDirectory);
             }
         }
-        FileWriter c = new FileWriter(new File(outputDirectory, mName+".c"));
-        FileWriter h = new FileWriter(new File(outputDirectory, mName+".h"));
 
-        h.write("/**\n");
-        h.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
-        h.write("* or more contributor license agreements.  See the NOTICE file\n");
-        h.write("* distributed with this work for additional information\n");
-        h.write("* regarding copyright ownership.  The ASF licenses this file\n");
-        h.write("* to you under the Apache License, Version 2.0 (the\n");
-        h.write("* \"License\"); you may not use this file except in compliance\n");
-        h.write("* with the License.  You may obtain a copy of the License at\n");
-        h.write("*\n");
-        h.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
-        h.write("*\n");
-        h.write("* Unless required by applicable law or agreed to in writing, software\n");
-        h.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
-        h.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
-        h.write("* See the License for the specific language governing permissions and\n");
-        h.write("* limitations under the License.\n");
-        h.write("*/\n");
-        h.write("\n");
+        try (FileWriter c = new FileWriter(new File(outputDirectory, mName + ".c"));
+             FileWriter h = new FileWriter(new File(outputDirectory, mName + ".h"));
+        ) {
+            h.write("/**\n");
+            h.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
+            h.write("* or more contributor license agreements.  See the NOTICE file\n");
+            h.write("* distributed with this work for additional information\n");
+            h.write("* regarding copyright ownership.  The ASF licenses this file\n");
+            h.write("* to you under the Apache License, Version 2.0 (the\n");
+            h.write("* \"License\"); you may not use this file except in compliance\n");
+            h.write("* with the License.  You may obtain a copy of the License at\n");
+            h.write("*\n");
+            h.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
+            h.write("*\n");
+            h.write("* Unless required by applicable law or agreed to in writing, software\n");
+            h.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
+            h.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
+            h.write("* See the License for the specific language governing permissions and\n");
+            h.write("* limitations under the License.\n");
+            h.write("*/\n");
+            h.write("\n");
 
-        c.write("/**\n");
-        c.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
-        c.write("* or more contributor license agreements.  See the NOTICE file\n");
-        c.write("* distributed with this work for additional information\n");
-        c.write("* regarding copyright ownership.  The ASF licenses this file\n");
-        c.write("* to you under the Apache License, Version 2.0 (the\n");
-        c.write("* \"License\"); you may not use this file except in compliance\n");
-        c.write("* with the License.  You may obtain a copy of the License at\n");
-        c.write("*\n");
-        c.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
-        c.write("*\n");
-        c.write("* Unless required by applicable law or agreed to in writing, software\n");
-        c.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
-        c.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
-        c.write("* See the License for the specific language governing permissions and\n");
-        c.write("* limitations under the License.\n");
-        c.write("*/\n");
-        c.write("\n");
+            c.write("/**\n");
+            c.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
+            c.write("* or more contributor license agreements.  See the NOTICE file\n");
+            c.write("* distributed with this work for additional information\n");
+            c.write("* regarding copyright ownership.  The ASF licenses this file\n");
+            c.write("* to you under the Apache License, Version 2.0 (the\n");
+            c.write("* \"License\"); you may not use this file except in compliance\n");
+            c.write("* with the License.  You may obtain a copy of the License at\n");
+            c.write("*\n");
+            c.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
+            c.write("*\n");
+            c.write("* Unless required by applicable law or agreed to in writing, software\n");
+            c.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
+            c.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
+            c.write("* See the License for the specific language governing permissions and\n");
+            c.write("* limitations under the License.\n");
+            c.write("*/\n");
+            c.write("\n");
 
-        h.write("#ifndef __"+mName.toUpperCase().replace('.','_')+"__\n");
-        h.write("#define __"+mName.toUpperCase().replace('.','_')+"__\n");
+            h.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");
+            h.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");
 
-        h.write("#include \"recordio.h\"\n");
-        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {
-            JFile f = i.next();
-            h.write("#include \""+f.getName()+".h\"\n");
-        }
-        // required for compilation from C++
-        h.write("\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");
-
-        c.write("#include <stdlib.h>\n"); // need it for calloc() & free()
-        c.write("#include \""+mName+".h\"\n\n");
+            h.write("#include \"recordio.h\"\n");
+            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {
+                JFile f = i.next();
+                h.write("#include \"" + f.getName() + ".h\"\n");
+            }
+            // required for compilation from C++
+            h.write("\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");
 
-        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {
-            JRecord jr = i.next();
-            jr.genCCode(h, c);
-        }
+            c.write("#include <stdlib.h>\n"); // need it for calloc() & free()
+            c.write("#include \"" + mName + ".h\"\n\n");
 
-        h.write("\n#ifdef __cplusplus\n}\n#endif\n\n");
-        h.write("#endif //"+mName.toUpperCase().replace('.','_')+"__\n");
+            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {
+                JRecord jr = i.next();
+                jr.genCCode(h, c);
+            }
 
-        h.close();
-        c.close();
+            h.write("\n#ifdef __cplusplus\n}\n#endif\n\n");
+            h.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");
+        }
     }
 }
diff --git a/src/java/main/org/apache/jute/compiler/CppGenerator.java b/src/java/main/org/apache/jute/compiler/CppGenerator.java
index 16d44ce0e..9b1227871 100644
--- a/src/java/main/org/apache/jute/compiler/CppGenerator.java
+++ b/src/java/main/org/apache/jute/compiler/CppGenerator.java
@@ -61,65 +61,64 @@ void genCode() throws IOException {
                         + outputDirectory);
             }
         }
-        FileWriter cc = new FileWriter(new File(outputDirectory, mName+".cc"));
-        FileWriter hh = new FileWriter(new File(outputDirectory, mName+".hh"));
 
-        hh.write("/**\n");
-        hh.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
-        hh.write("* or more contributor license agreements.  See the NOTICE file\n");
-        hh.write("* distributed with this work for additional information\n");
-        hh.write("* regarding copyright ownership.  The ASF licenses this file\n");
-        hh.write("* to you under the Apache License, Version 2.0 (the\n");
-        hh.write("* \"License\"); you may not use this file except in compliance\n");
-        hh.write("* with the License.  You may obtain a copy of the License at\n");
-        hh.write("*\n");
-        hh.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
-        hh.write("*\n");
-        hh.write("* Unless required by applicable law or agreed to in writing, software\n");
-        hh.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
-        hh.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
-        hh.write("* See the License for the specific language governing permissions and\n");
-        hh.write("* limitations under the License.\n");
-        hh.write("*/\n");
-        hh.write("\n");
+        try (FileWriter cc = new FileWriter(new File(outputDirectory, mName + ".cc"));
+             FileWriter hh = new FileWriter(new File(outputDirectory, mName + ".hh"));
+        ) {
+            hh.write("/**\n");
+            hh.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
+            hh.write("* or more contributor license agreements.  See the NOTICE file\n");
+            hh.write("* distributed with this work for additional information\n");
+            hh.write("* regarding copyright ownership.  The ASF licenses this file\n");
+            hh.write("* to you under the Apache License, Version 2.0 (the\n");
+            hh.write("* \"License\"); you may not use this file except in compliance\n");
+            hh.write("* with the License.  You may obtain a copy of the License at\n");
+            hh.write("*\n");
+            hh.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
+            hh.write("*\n");
+            hh.write("* Unless required by applicable law or agreed to in writing, software\n");
+            hh.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
+            hh.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
+            hh.write("* See the License for the specific language governing permissions and\n");
+            hh.write("* limitations under the License.\n");
+            hh.write("*/\n");
+            hh.write("\n");
 
-        cc.write("/**\n");
-        cc.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
-        cc.write("* or more contributor license agreements.  See the NOTICE file\n");
-        cc.write("* distributed with this work for additional information\n");
-        cc.write("* regarding copyright ownership.  The ASF licenses this file\n");
-        cc.write("* to you under the Apache License, Version 2.0 (the\n");
-        cc.write("* \"License\"); you may not use this file except in compliance\n");
-        cc.write("* with the License.  You may obtain a copy of the License at\n");
-        cc.write("*\n");
-        cc.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
-        cc.write("*\n");
-        cc.write("* Unless required by applicable law or agreed to in writing, software\n");
-        cc.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
-        cc.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
-        cc.write("* See the License for the specific language governing permissions and\n");
-        cc.write("* limitations under the License.\n");
-        cc.write("*/\n");
-        cc.write("\n");
+            cc.write("/**\n");
+            cc.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
+            cc.write("* or more contributor license agreements.  See the NOTICE file\n");
+            cc.write("* distributed with this work for additional information\n");
+            cc.write("* regarding copyright ownership.  The ASF licenses this file\n");
+            cc.write("* to you under the Apache License, Version 2.0 (the\n");
+            cc.write("* \"License\"); you may not use this file except in compliance\n");
+            cc.write("* with the License.  You may obtain a copy of the License at\n");
+            cc.write("*\n");
+            cc.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
+            cc.write("*\n");
+            cc.write("* Unless required by applicable law or agreed to in writing, software\n");
+            cc.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
+            cc.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
+            cc.write("* See the License for the specific language governing permissions and\n");
+            cc.write("* limitations under the License.\n");
+            cc.write("*/\n");
+            cc.write("\n");
 
-        hh.write("#ifndef __"+mName.toUpperCase().replace('.','_')+"__\n");
-        hh.write("#define __"+mName.toUpperCase().replace('.','_')+"__\n");
+            hh.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");
+            hh.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");
 
-        hh.write("#include \"recordio.hh\"\n");
-        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {
-            JFile f = i.next();
-            hh.write("#include \""+f.getName()+".hh\"\n");
-        }
-        cc.write("#include \""+mName+".hh\"\n");
-
-        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {
-            JRecord jr = i.next();
-            jr.genCppCode(hh, cc);
-        }
+            hh.write("#include \"recordio.hh\"\n");
+            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {
+                JFile f = i.next();
+                hh.write("#include \"" + f.getName() + ".hh\"\n");
+            }
+            cc.write("#include \"" + mName + ".hh\"\n");
 
-        hh.write("#endif //"+mName.toUpperCase().replace('.','_')+"__\n");
+            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {
+                JRecord jr = i.next();
+                jr.genCppCode(hh, cc);
+            }
 
-        hh.close();
-        cc.close();
+            hh.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");
+        }
     }
 }
diff --git a/src/java/main/org/apache/jute/compiler/JRecord.java b/src/java/main/org/apache/jute/compiler/JRecord.java
index 01ba2989a..65bccccbb 100644
--- a/src/java/main/org/apache/jute/compiler/JRecord.java
+++ b/src/java/main/org/apache/jute/compiler/JRecord.java
@@ -141,109 +141,116 @@ public String genCsharpWriteWrapper(String fname, String tag) {
 
     static HashMap<String, String> vectorStructs = new HashMap<String, String>();
     public void genCCode(FileWriter h, FileWriter c) throws IOException {
-        for (JField f : mFields) {
-            if (f.getType() instanceof JVector) {
-                JVector jv = (JVector)f.getType();
-                JType jvType = jv.getElementType();
-                String struct_name = JVector.extractVectorName(jvType);
-                if (vectorStructs.get(struct_name) == null) {
-                    vectorStructs.put(struct_name, struct_name);
-                    h.write("struct " + struct_name + " {\n    int32_t count;\n" + jv.getElementType().genCDecl("*data") + "\n};\n");
-                    h.write("int serialize_" + struct_name + "(struct oarchive *out, const char *tag, struct " + struct_name + " *v);\n");
-                    h.write("int deserialize_" + struct_name + "(struct iarchive *in, const char *tag, struct " + struct_name + " *v);\n");
-                    h.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int32_t len);\n");
-                    h.write("int deallocate_" + struct_name + "(struct " + struct_name + " *v);\n");
-                    c.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int32_t len) {\n");
-                    c.write("    if (!len) {\n");
-                    c.write("        v->count = 0;\n");
-                    c.write("        v->data = 0;\n");
-                    c.write("    } else {\n");
-                    c.write("        v->count = len;\n");
-                    c.write("        v->data = calloc(sizeof(*v->data), len);\n");
-                    c.write("    }\n");
-                    c.write("    return 0;\n");
-                    c.write("}\n");
-                    c.write("int deallocate_" + struct_name + "(struct " + struct_name + " *v) {\n");
-                    c.write("    if (v->data) {\n");
-                    c.write("        int32_t i;\n");
-                    c.write("        for(i=0;i<v->count; i++) {\n");
-                    c.write("            deallocate_"+JRecord.extractMethodSuffix(jvType)+"(&v->data[i]);\n");
-                    c.write("        }\n");
-                    c.write("        free(v->data);\n");
-                    c.write("        v->data = 0;\n");
-                    c.write("    }\n");
-                    c.write("    return 0;\n");
-                    c.write("}\n");
-                    c.write("int serialize_" + struct_name + "(struct oarchive *out, const char *tag, struct " + struct_name + " *v)\n");
-                    c.write("{\n");
-                    c.write("    int32_t count = v->count;\n");
-                    c.write("    int rc = 0;\n");
-                    c.write("    int32_t i;\n");
-                    c.write("    rc = out->start_vector(out, tag, &count);\n");
-                    c.write("    for(i=0;i<v->count;i++) {\n");
-                    genSerialize(c, jvType, "data", "data[i]");
-                    c.write("    }\n");
-                    c.write("    rc = rc ? rc : out->end_vector(out, tag);\n");
-                    c.write("    return rc;\n");
-                    c.write("}\n");
-                    c.write("int deserialize_" + struct_name + "(struct iarchive *in, const char *tag, struct " + struct_name + " *v)\n");
-                    c.write("{\n");
-                    c.write("    int rc = 0;\n");
-                    c.write("    int32_t i;\n");
-                    c.write("    rc = in->start_vector(in, tag, &v->count);\n");
-                    c.write("    v->data = calloc(v->count, sizeof(*v->data));\n");
-                    c.write("    for(i=0;i<v->count;i++) {\n");
-                    genDeserialize(c, jvType, "value", "data[i]");
-                    c.write("    }\n");
-                    c.write("    rc = in->end_vector(in, tag);\n");
-                    c.write("    return rc;\n");
-                    c.write("}\n");
-
+        try {
+            for (JField f : mFields) {
+                if (f.getType() instanceof JVector) {
+                    JVector jv = (JVector) f.getType();
+                    JType jvType = jv.getElementType();
+                    String struct_name = JVector.extractVectorName(jvType);
+                    if (vectorStructs.get(struct_name) == null) {
+                        vectorStructs.put(struct_name, struct_name);
+                        h.write("struct " + struct_name + " {\n    int32_t count;\n" + jv.getElementType().genCDecl("*data") + "\n};\n");
+                        h.write("int serialize_" + struct_name + "(struct oarchive *out, const char *tag, struct " + struct_name + " *v);\n");
+                        h.write("int deserialize_" + struct_name + "(struct iarchive *in, const char *tag, struct " + struct_name + " *v);\n");
+                        h.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int32_t len);\n");
+                        h.write("int deallocate_" + struct_name + "(struct " + struct_name + " *v);\n");
+                        c.write("int allocate_" + struct_name + "(struct " + struct_name + " *v, int32_t len) {\n");
+                        c.write("    if (!len) {\n");
+                        c.write("        v->count = 0;\n");
+                        c.write("        v->data = 0;\n");
+                        c.write("    } else {\n");
+                        c.write("        v->count = len;\n");
+                        c.write("        v->data = calloc(sizeof(*v->data), len);\n");
+                        c.write("    }\n");
+                        c.write("    return 0;\n");
+                        c.write("}\n");
+                        c.write("int deallocate_" + struct_name + "(struct " + struct_name + " *v) {\n");
+                        c.write("    if (v->data) {\n");
+                        c.write("        int32_t i;\n");
+                        c.write("        for(i=0;i<v->count; i++) {\n");
+                        c.write("            deallocate_" + JRecord.extractMethodSuffix(jvType) + "(&v->data[i]);\n");
+                        c.write("        }\n");
+                        c.write("        free(v->data);\n");
+                        c.write("        v->data = 0;\n");
+                        c.write("    }\n");
+                        c.write("    return 0;\n");
+                        c.write("}\n");
+                        c.write("int serialize_" + struct_name + "(struct oarchive *out, const char *tag, struct " + struct_name + " *v)\n");
+                        c.write("{\n");
+                        c.write("    int32_t count = v->count;\n");
+                        c.write("    int rc = 0;\n");
+                        c.write("    int32_t i;\n");
+                        c.write("    rc = out->start_vector(out, tag, &count);\n");
+                        c.write("    for(i=0;i<v->count;i++) {\n");
+                        genSerialize(c, jvType, "data", "data[i]");
+                        c.write("    }\n");
+                        c.write("    rc = rc ? rc : out->end_vector(out, tag);\n");
+                        c.write("    return rc;\n");
+                        c.write("}\n");
+                        c.write("int deserialize_" + struct_name + "(struct iarchive *in, const char *tag, struct " + struct_name + " *v)\n");
+                        c.write("{\n");
+                        c.write("    int rc = 0;\n");
+                        c.write("    int32_t i;\n");
+                        c.write("    rc = in->start_vector(in, tag, &v->count);\n");
+                        c.write("    v->data = calloc(v->count, sizeof(*v->data));\n");
+                        c.write("    for(i=0;i<v->count;i++) {\n");
+                        genDeserialize(c, jvType, "value", "data[i]");
+                        c.write("    }\n");
+                        c.write("    rc = in->end_vector(in, tag);\n");
+                        c.write("    return rc;\n");
+                        c.write("}\n");
+
+                    }
                 }
             }
-        }
-        String rec_name = getName();
-        h.write("struct " + rec_name + " {\n");
-        for (JField f : mFields) {
-            h.write(f.genCDecl());
-        }
-        h.write("};\n");
-        h.write("int serialize_" + rec_name + "(struct oarchive *out, const char *tag, struct " + rec_name + " *v);\n");
-        h.write("int deserialize_" + rec_name + "(struct iarchive *in, const char *tag, struct " + rec_name + "*v);\n");
-        h.write("void deallocate_" + rec_name + "(struct " + rec_name + "*);\n");
-        c.write("int serialize_" + rec_name + "(struct oarchive *out, const char *tag, struct " + rec_name + " *v)");
-        c.write("{\n");
-        c.write("    int rc;\n");
-        c.write("    rc = out->start_record(out, tag);\n");
-        for(JField f : mFields) {
-            genSerialize(c, f.getType(), f.getTag(), f.getName());
-        }
-        c.write("    rc = rc ? rc : out->end_record(out, tag);\n");
-        c.write("    return rc;\n");
-        c.write("}\n");
-        c.write("int deserialize_" + rec_name + "(struct iarchive *in, const char *tag, struct " + rec_name + "*v)");
-        c.write("{\n");
-        c.write("    int rc;\n");
-        c.write("    rc = in->start_record(in, tag);\n");
-        for(JField f : mFields) {
-            genDeserialize(c, f.getType(), f.getTag(), f.getName());
-        }
-        c.write("    rc = rc ? rc : in->end_record(in, tag);\n");
-        c.write("    return rc;\n");
-        c.write("}\n");
-        c.write("void deallocate_" + rec_name + "(struct " + rec_name + "*v)");
-        c.write("{\n");
-        for(JField f : mFields) {
-            if (f.getType() instanceof JRecord) {
-                c.write("    deallocate_" + extractStructName(f.getType()) + "(&v->" + f.getName() + ");\n");
-            } else if (f.getType() instanceof JVector) {
-                JVector vt = (JVector)f.getType();
-                c.write("    deallocate_" + JVector.extractVectorName(vt.getElementType())+ "(&v->"+f.getName()+");\n");
-            } else if (f.getType() instanceof JCompType) {
-                c.write("    deallocate_" + extractMethodSuffix(f.getType()) + "(&v->"+f.getName()+");\n");
+            String rec_name = getName();
+            h.write("struct " + rec_name + " {\n");
+            for (JField f : mFields) {
+                h.write(f.genCDecl());
+            }
+            h.write("};\n");
+            h.write("int serialize_" + rec_name + "(struct oarchive *out, const char *tag, struct " + rec_name + " *v);\n");
+            h.write("int deserialize_" + rec_name + "(struct iarchive *in, const char *tag, struct " + rec_name + "*v);\n");
+            h.write("void deallocate_" + rec_name + "(struct " + rec_name + "*);\n");
+            c.write("int serialize_" + rec_name + "(struct oarchive *out, const char *tag, struct " + rec_name + " *v)");
+            c.write("{\n");
+            c.write("    int rc;\n");
+            c.write("    rc = out->start_record(out, tag);\n");
+            for (JField f : mFields) {
+                genSerialize(c, f.getType(), f.getTag(), f.getName());
+            }
+            c.write("    rc = rc ? rc : out->end_record(out, tag);\n");
+            c.write("    return rc;\n");
+            c.write("}\n");
+            c.write("int deserialize_" + rec_name + "(struct iarchive *in, const char *tag, struct " + rec_name + "*v)");
+            c.write("{\n");
+            c.write("    int rc;\n");
+            c.write("    rc = in->start_record(in, tag);\n");
+            for (JField f : mFields) {
+                genDeserialize(c, f.getType(), f.getTag(), f.getName());
+            }
+            c.write("    rc = rc ? rc : in->end_record(in, tag);\n");
+            c.write("    return rc;\n");
+            c.write("}\n");
+            c.write("void deallocate_" + rec_name + "(struct " + rec_name + "*v)");
+            c.write("{\n");
+            for (JField f : mFields) {
+                if (f.getType() instanceof JRecord) {
+                    c.write("    deallocate_" + extractStructName(f.getType()) + "(&v->" + f.getName() + ");\n");
+                } else if (f.getType() instanceof JVector) {
+                    JVector vt = (JVector) f.getType();
+                    c.write("    deallocate_" + JVector.extractVectorName(vt.getElementType()) + "(&v->" + f.getName() + ");\n");
+                } else if (f.getType() instanceof JCompType) {
+                    c.write("    deallocate_" + extractMethodSuffix(f.getType()) + "(&v->" + f.getName() + ");\n");
+                }
             }
+            c.write("}\n");
+        } catch (IOException e) {
+            throw e;
+        } finally {
+            h.close();
+            c.close();
         }
-        c.write("}\n");
     }
 
     private void genSerialize(FileWriter c, JType type, String tag, String name) throws IOException {
@@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {
         } else if (!pkgdir.isDirectory()) {
             throw new IOException(pkgpath + " is not a directory.");
         }
-        File jfile = new File(pkgdir, getName()+".java");
-        FileWriter jj = new FileWriter(jfile);
-        jj.write("// File generated by hadoop record compiler. Do not edit.\n");
-        jj.write("/**\n");
-        jj.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
-        jj.write("* or more contributor license agreements.  See the NOTICE file\n");
-        jj.write("* distributed with this work for additional information\n");
-        jj.write("* regarding copyright ownership.  The ASF licenses this file\n");
-        jj.write("* to you under the Apache License, Version 2.0 (the\n");
-        jj.write("* \"License\"); you may not use this file except in compliance\n");
-        jj.write("* with the License.  You may obtain a copy of the License at\n");
-        jj.write("*\n");
-        jj.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
-        jj.write("*\n");
-        jj.write("* Unless required by applicable law or agreed to in writing, software\n");
-        jj.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
-        jj.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
-        jj.write("* See the License for the specific language governing permissions and\n");
-        jj.write("* limitations under the License.\n");
-        jj.write("*/\n");
-        jj.write("\n");
-        jj.write("package "+getJavaPackage()+";\n\n");
-        jj.write("import org.apache.jute.*;\n");
-        jj.write("public class "+getName()+" implements Record {\n");
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {
-            JField jf = i.next();
-            jj.write(jf.genJavaDecl());
-        }
-        jj.write("  public "+getName()+"() {\n");
-        jj.write("  }\n");
+        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+".java"))) {
+            jj.write("// File generated by hadoop record compiler. Do not edit.\n");
+            jj.write("/**\n");
+            jj.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
+            jj.write("* or more contributor license agreements.  See the NOTICE file\n");
+            jj.write("* distributed with this work for additional information\n");
+            jj.write("* regarding copyright ownership.  The ASF licenses this file\n");
+            jj.write("* to you under the Apache License, Version 2.0 (the\n");
+            jj.write("* \"License\"); you may not use this file except in compliance\n");
+            jj.write("* with the License.  You may obtain a copy of the License at\n");
+            jj.write("*\n");
+            jj.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
+            jj.write("*\n");
+            jj.write("* Unless required by applicable law or agreed to in writing, software\n");
+            jj.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
+            jj.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
+            jj.write("* See the License for the specific language governing permissions and\n");
+            jj.write("* limitations under the License.\n");
+            jj.write("*/\n");
+            jj.write("\n");
+            jj.write("package " + getJavaPackage() + ";\n\n");
+            jj.write("import org.apache.jute.*;\n");
+            jj.write("public class " + getName() + " implements Record {\n");
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {
+                JField jf = i.next();
+                jj.write(jf.genJavaDecl());
+            }
+            jj.write("  public " + getName() + "() {\n");
+            jj.write("  }\n");
 
-        jj.write("  public "+getName()+"(\n");
-        int fIdx = 0;
-        int fLen = mFields.size();
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaConstructorParam(jf.getName()));
-            jj.write((fLen-1 == fIdx)?"":",\n");
-        }
-        jj.write(") {\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaConstructorSet(jf.getName()));
-        }
-        jj.write("  }\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaGetSet(fIdx));
-        }
-        jj.write("  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n");
-        jj.write("    a_.startRecord(this,tag);\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaWriteMethodName());
-        }
-        jj.write("    a_.endRecord(this,tag);\n");
-        jj.write("  }\n");
+            jj.write("  public " + getName() + "(\n");
+            int fIdx = 0;
+            int fLen = mFields.size();
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaConstructorParam(jf.getName()));
+                jj.write((fLen - 1 == fIdx) ? "" : ",\n");
+            }
+            jj.write(") {\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaConstructorSet(jf.getName()));
+            }
+            jj.write("  }\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaGetSet(fIdx));
+            }
+            jj.write("  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\n");
+            jj.write("    a_.startRecord(this,tag);\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaWriteMethodName());
+            }
+            jj.write("    a_.endRecord(this,tag);\n");
+            jj.write("  }\n");
 
-        jj.write("  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n");
-        jj.write("    a_.startRecord(tag);\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaReadMethodName());
-        }
-        jj.write("    a_.endRecord(tag);\n");
-        jj.write("}\n");
-
-        jj.write("  public String toString() {\n");
-        jj.write("    try {\n");
-        jj.write("      java.io.ByteArrayOutputStream s =\n");
-        jj.write("        new java.io.ByteArrayOutputStream();\n");
-        jj.write("      CsvOutputArchive a_ = \n");
-        jj.write("        new CsvOutputArchive(s);\n");
-        jj.write("      a_.startRecord(this,\"\");\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaWriteMethodName());
-        }
-        jj.write("      a_.endRecord(this,\"\");\n");
-        jj.write("      return new String(s.toByteArray(), \"UTF-8\");\n");
-        jj.write("    } catch (Throwable ex) {\n");
-        jj.write("      ex.printStackTrace();\n");
-        jj.write("    }\n");
-        jj.write("    return \"ERROR\";\n");
-        jj.write("  }\n");
-
-        jj.write("  public void write(java.io.DataOutput out) throws java.io.IOException {\n");
-        jj.write("    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n");
-        jj.write("    serialize(archive, \"\");\n");
-        jj.write("  }\n");
-
-        jj.write("  public void readFields(java.io.DataInput in) throws java.io.IOException {\n");
-        jj.write("    BinaryInputArchive archive = new BinaryInputArchive(in);\n");
-        jj.write("    deserialize(archive, \"\");\n");
-        jj.write("  }\n");
-
-        jj.write("  public int compareTo (Object peer_) throws ClassCastException {\n");
-        boolean unimplemented = false;
-        for (JField f : mFields) {
-            if ((f.getType() instanceof JMap)
-                    || (f.getType() instanceof JVector))
-            {
-                unimplemented = true;
+            jj.write("  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\n");
+            jj.write("    a_.startRecord(tag);\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaReadMethodName());
             }
-        }
-        if (unimplemented) {
-            jj.write("    throw new UnsupportedOperationException(\"comparing "
-                    + getName() + " is unimplemented\");\n");
-        } else {
-            jj.write("    if (!(peer_ instanceof "+getName()+")) {\n");
-            jj.write("      throw new ClassCastException(\"Comparing different types of records.\");\n");
+            jj.write("    a_.endRecord(tag);\n");
+            jj.write("}\n");
+
+            jj.write("  public String toString() {\n");
+            jj.write("    try {\n");
+            jj.write("      java.io.ByteArrayOutputStream s =\n");
+            jj.write("        new java.io.ByteArrayOutputStream();\n");
+            jj.write("      CsvOutputArchive a_ = \n");
+            jj.write("        new CsvOutputArchive(s);\n");
+            jj.write("      a_.startRecord(this,\"\");\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaWriteMethodName());
+            }
+            jj.write("      a_.endRecord(this,\"\");\n");
+            jj.write("      return new String(s.toByteArray(), \"UTF-8\");\n");
+            jj.write("    } catch (Throwable ex) {\n");
+            jj.write("      ex.printStackTrace();\n");
             jj.write("    }\n");
-            jj.write("    "+getName()+" peer = ("+getName()+") peer_;\n");
-            jj.write("    int ret = 0;\n");
+            jj.write("    return \"ERROR\";\n");
+            jj.write("  }\n");
+
+            jj.write("  public void write(java.io.DataOutput out) throws java.io.IOException {\n");
+            jj.write("    BinaryOutputArchive archive = new BinaryOutputArchive(out);\n");
+            jj.write("    serialize(archive, \"\");\n");
+            jj.write("  }\n");
+
+            jj.write("  public void readFields(java.io.DataInput in) throws java.io.IOException {\n");
+            jj.write("    BinaryInputArchive archive = new BinaryInputArchive(in);\n");
+            jj.write("    deserialize(archive, \"\");\n");
+            jj.write("  }\n");
+
+            jj.write("  public int compareTo (Object peer_) throws ClassCastException {\n");
+            boolean unimplemented = false;
+            for (JField f : mFields) {
+                if ((f.getType() instanceof JMap)
+                        || (f.getType() instanceof JVector)) {
+                    unimplemented = true;
+                }
+            }
+            if (unimplemented) {
+                jj.write("    throw new UnsupportedOperationException(\"comparing "
+                        + getName() + " is unimplemented\");\n");
+            } else {
+                jj.write("    if (!(peer_ instanceof " + getName() + ")) {\n");
+                jj.write("      throw new ClassCastException(\"Comparing different types of records.\");\n");
+                jj.write("    }\n");
+                jj.write("    " + getName() + " peer = (" + getName() + ") peer_;\n");
+                jj.write("    int ret = 0;\n");
+                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                    JField jf = i.next();
+                    jj.write(jf.genJavaCompareTo());
+                    jj.write("    if (ret != 0) return ret;\n");
+                }
+                jj.write("     return ret;\n");
+            }
+            jj.write("  }\n");
+
+            jj.write("  public boolean equals(Object peer_) {\n");
+            jj.write("    if (!(peer_ instanceof " + getName() + ")) {\n");
+            jj.write("      return false;\n");
+            jj.write("    }\n");
+            jj.write("    if (peer_ == this) {\n");
+            jj.write("      return true;\n");
+            jj.write("    }\n");
+            jj.write("    " + getName() + " peer = (" + getName() + ") peer_;\n");
+            jj.write("    boolean ret = false;\n");
             for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                 JField jf = i.next();
-                jj.write(jf.genJavaCompareTo());
-                jj.write("    if (ret != 0) return ret;\n");
+                jj.write(jf.genJavaEquals());
+                jj.write("    if (!ret) return ret;\n");
             }
             jj.write("     return ret;\n");
-        }
-        jj.write("  }\n");
-
-        jj.write("  public boolean equals(Object peer_) {\n");
-        jj.write("    if (!(peer_ instanceof "+getName()+")) {\n");
-        jj.write("      return false;\n");
-        jj.write("    }\n");
-        jj.write("    if (peer_ == this) {\n");
-        jj.write("      return true;\n");
-        jj.write("    }\n");
-        jj.write("    "+getName()+" peer = ("+getName()+") peer_;\n");
-        jj.write("    boolean ret = false;\n");
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaEquals());
-            jj.write("    if (!ret) return ret;\n");
-        }
-        jj.write("     return ret;\n");
-        jj.write("  }\n");
+            jj.write("  }\n");
 
-        jj.write("  public int hashCode() {\n");
-        jj.write("    int result = 17;\n");
-        jj.write("    int ret;\n");
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            jj.write(jf.genJavaHashCode());
-            jj.write("    result = 37*result + ret;\n");
-        }
-        jj.write("    return result;\n");
-        jj.write("  }\n");
-        jj.write("  public static String signature() {\n");
-        jj.write("    return \""+getSignature()+"\";\n");
-        jj.write("  }\n");
-
-        jj.write("}\n");
+            jj.write("  public int hashCode() {\n");
+            jj.write("    int result = 17;\n");
+            jj.write("    int ret;\n");
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                jj.write(jf.genJavaHashCode());
+                jj.write("    result = 37*result + ret;\n");
+            }
+            jj.write("    return result;\n");
+            jj.write("  }\n");
+            jj.write("  public static String signature() {\n");
+            jj.write("    return \"" + getSignature() + "\";\n");
+            jj.write("  }\n");
 
-        jj.close();
+            jj.write("}\n");
+        }
     }
 
     public void genCsharpCode(File outputDirectory) throws IOException {
@@ -576,174 +580,174 @@ public void genCsharpCode(File outputDirectory) throws IOException {
         } else if (!outputDirectory.isDirectory()) {
             throw new IOException(outputDirectory + " is not a directory.");
         }
-        File csharpFile = new File(outputDirectory, getName()+".cs");
-        FileWriter cs = new FileWriter(csharpFile);
-        cs.write("// File generated by hadoop record compiler. Do not edit.\n");
-        cs.write("/**\n");
-        cs.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
-        cs.write("* or more contributor license agreements.  See the NOTICE file\n");
-        cs.write("* distributed with this work for additional information\n");
-        cs.write("* regarding copyright ownership.  The ASF licenses this file\n");
-        cs.write("* to you under the Apache License, Version 2.0 (the\n");
-        cs.write("* \"License\"); you may not use this file except in compliance\n");
-        cs.write("* with the License.  You may obtain a copy of the License at\n");
-        cs.write("*\n");
-        cs.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
-        cs.write("*\n");
-        cs.write("* Unless required by applicable law or agreed to in writing, software\n");
-        cs.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
-        cs.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
-        cs.write("* See the License for the specific language governing permissions and\n");
-        cs.write("* limitations under the License.\n");
-        cs.write("*/\n");
-        cs.write("\n");
-        cs.write("using System;\n");
-        cs.write("using Org.Apache.Jute;\n");
-        cs.write("\n");        
-        cs.write("namespace "+getCsharpNameSpace()+"\n");
-        cs.write("{\n");
-
-        String className = getCsharpName();
-        cs.write("public class "+className+" : IRecord, IComparable \n");
-        cs.write("{\n");
-        cs.write("  public "+ className +"() {\n");
-        cs.write("  }\n");
-
-        cs.write("  public "+className+"(\n");
-        int fIdx = 0;
-        int fLen = mFields.size();
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
-            cs.write((fLen-1 == fIdx)?"":",\n");
-        }
-        cs.write(") {\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
-        }
-        cs.write("  }\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpGetSet(fIdx));
+
+        try (FileWriter cs = new FileWriter(new File(outputDirectory, getName() + ".cs"));) {
+            cs.write("// File generated by hadoop record compiler. Do not edit.\n");
+            cs.write("/**\n");
+            cs.write("* Licensed to the Apache Software Foundation (ASF) under one\n");
+            cs.write("* or more contributor license agreements.  See the NOTICE file\n");
+            cs.write("* distributed with this work for additional information\n");
+            cs.write("* regarding copyright ownership.  The ASF licenses this file\n");
+            cs.write("* to you under the Apache License, Version 2.0 (the\n");
+            cs.write("* \"License\"); you may not use this file except in compliance\n");
+            cs.write("* with the License.  You may obtain a copy of the License at\n");
+            cs.write("*\n");
+            cs.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");
+            cs.write("*\n");
+            cs.write("* Unless required by applicable law or agreed to in writing, software\n");
+            cs.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");
+            cs.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");
+            cs.write("* See the License for the specific language governing permissions and\n");
+            cs.write("* limitations under the License.\n");
+            cs.write("*/\n");
             cs.write("\n");
-        }
-        cs.write("  public void Serialize(IOutputArchive a_, String tag) {\n");
-        cs.write("    a_.StartRecord(this,tag);\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpWriteMethodName());
-        }
-        cs.write("    a_.EndRecord(this,tag);\n");
-        cs.write("  }\n");
+            cs.write("using System;\n");
+            cs.write("using Org.Apache.Jute;\n");
+            cs.write("\n");
+            cs.write("namespace " + getCsharpNameSpace() + "\n");
+            cs.write("{\n");
+
+            String className = getCsharpName();
+            cs.write("public class " + className + " : IRecord, IComparable \n");
+            cs.write("{\n");
+            cs.write("  public " + className + "() {\n");
+            cs.write("  }\n");
+
+            cs.write("  public " + className + "(\n");
+            int fIdx = 0;
+            int fLen = mFields.size();
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));
+                cs.write((fLen - 1 == fIdx) ? "" : ",\n");
+            }
+            cs.write(") {\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));
+            }
+            cs.write("  }\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpGetSet(fIdx));
+                cs.write("\n");
+            }
+            cs.write("  public void Serialize(IOutputArchive a_, String tag) {\n");
+            cs.write("    a_.StartRecord(this,tag);\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpWriteMethodName());
+            }
+            cs.write("    a_.EndRecord(this,tag);\n");
+            cs.write("  }\n");
 
-        cs.write("  public void Deserialize(IInputArchive a_, String tag) {\n");
-        cs.write("    a_.StartRecord(tag);\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpReadMethodName());
-        }
-        cs.write("    a_.EndRecord(tag);\n");
-        cs.write("}\n");
-
-        cs.write("  public override String ToString() {\n");
-        cs.write("    try {\n");
-        cs.write("      System.IO.MemoryStream ms = new System.IO.MemoryStream();\n");
-        cs.write("      MiscUtil.IO.EndianBinaryWriter writer =\n");
-        cs.write("        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\n");
-        cs.write("      BinaryOutputArchive a_ = \n");
-        cs.write("        new BinaryOutputArchive(writer);\n");
-        cs.write("      a_.StartRecord(this,\"\");\n");
-        fIdx = 0;
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpWriteMethodName());
-        }
-        cs.write("      a_.EndRecord(this,\"\");\n");
-        cs.write("      ms.Position = 0;\n");
-        cs.write("      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\n");
-        cs.write("    } catch (Exception ex) {\n");
-        cs.write("      Console.WriteLine(ex.StackTrace);\n");
-        cs.write("    }\n");
-        cs.write("    return \"ERROR\";\n");
-        cs.write("  }\n");
-
-        cs.write("  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\n");
-        cs.write("    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n");
-        cs.write("    Serialize(archive, \"\");\n");
-        cs.write("  }\n");
-
-        cs.write("  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\n");
-        cs.write("    BinaryInputArchive archive = new BinaryInputArchive(reader);\n");
-        cs.write("    Deserialize(archive, \"\");\n");
-        cs.write("  }\n");
-
-        cs.write("  public int CompareTo (object peer_) {\n");
-        boolean unimplemented = false;
-        for (JField f : mFields) {
-            if ((f.getType() instanceof JMap)
-                    || (f.getType() instanceof JVector))
-            {
-                unimplemented = true;
+            cs.write("  public void Deserialize(IInputArchive a_, String tag) {\n");
+            cs.write("    a_.StartRecord(tag);\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpReadMethodName());
             }
-        }
-        if (unimplemented) {
-            cs.write("    throw new InvalidOperationException(\"comparing "
-                    + getCsharpName() + " is unimplemented\");\n");
-        } else {
-            cs.write("    if (!(peer_ is "+getCsharpName()+")) {\n");
-            cs.write("      throw new InvalidOperationException(\"Comparing different types of records.\");\n");
+            cs.write("    a_.EndRecord(tag);\n");
+            cs.write("}\n");
+
+            cs.write("  public override String ToString() {\n");
+            cs.write("    try {\n");
+            cs.write("      System.IO.MemoryStream ms = new System.IO.MemoryStream();\n");
+            cs.write("      MiscUtil.IO.EndianBinaryWriter writer =\n");
+            cs.write("        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\n");
+            cs.write("      BinaryOutputArchive a_ = \n");
+            cs.write("        new BinaryOutputArchive(writer);\n");
+            cs.write("      a_.StartRecord(this,\"\");\n");
+            fIdx = 0;
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpWriteMethodName());
+            }
+            cs.write("      a_.EndRecord(this,\"\");\n");
+            cs.write("      ms.Position = 0;\n");
+            cs.write("      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\n");
+            cs.write("    } catch (Exception ex) {\n");
+            cs.write("      Console.WriteLine(ex.StackTrace);\n");
             cs.write("    }\n");
-            cs.write("    "+getCsharpName()+" peer = ("+getCsharpName()+") peer_;\n");
-            cs.write("    int ret = 0;\n");
+            cs.write("    return \"ERROR\";\n");
+            cs.write("  }\n");
+
+            cs.write("  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\n");
+            cs.write("    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\n");
+            cs.write("    Serialize(archive, \"\");\n");
+            cs.write("  }\n");
+
+            cs.write("  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\n");
+            cs.write("    BinaryInputArchive archive = new BinaryInputArchive(reader);\n");
+            cs.write("    Deserialize(archive, \"\");\n");
+            cs.write("  }\n");
+
+            cs.write("  public int CompareTo (object peer_) {\n");
+            boolean unimplemented = false;
+            for (JField f : mFields) {
+                if ((f.getType() instanceof JMap)
+                        || (f.getType() instanceof JVector)) {
+                    unimplemented = true;
+                }
+            }
+            if (unimplemented) {
+                cs.write("    throw new InvalidOperationException(\"comparing "
+                        + getCsharpName() + " is unimplemented\");\n");
+            } else {
+                cs.write("    if (!(peer_ is " + getCsharpName() + ")) {\n");
+                cs.write("      throw new InvalidOperationException(\"Comparing different types of records.\");\n");
+                cs.write("    }\n");
+                cs.write("    " + getCsharpName() + " peer = (" + getCsharpName() + ") peer_;\n");
+                cs.write("    int ret = 0;\n");
+                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                    JField jf = i.next();
+                    cs.write(jf.genCsharpCompareTo());
+                    cs.write("    if (ret != 0) return ret;\n");
+                }
+                cs.write("     return ret;\n");
+            }
+            cs.write("  }\n");
+
+            cs.write("  public override bool Equals(object peer_) {\n");
+            cs.write("    if (!(peer_ is " + getCsharpName() + ")) {\n");
+            cs.write("      return false;\n");
+            cs.write("    }\n");
+            cs.write("    if (peer_ == this) {\n");
+            cs.write("      return true;\n");
+            cs.write("    }\n");
+            cs.write("    bool ret = false;\n");
+            cs.write("    " + getCsharpName() + " peer = (" + getCsharpName() + ")peer_;\n");
             for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
                 JField jf = i.next();
-                cs.write(jf.genCsharpCompareTo());
-                cs.write("    if (ret != 0) return ret;\n");
+                cs.write(jf.genCsharpEquals());
+                cs.write("    if (!ret) return ret;\n");
             }
             cs.write("     return ret;\n");
-        }
-        cs.write("  }\n");
-
-        cs.write("  public override bool Equals(object peer_) {\n");
-        cs.write("    if (!(peer_ is "+getCsharpName()+")) {\n");
-        cs.write("      return false;\n");
-        cs.write("    }\n");
-        cs.write("    if (peer_ == this) {\n");
-        cs.write("      return true;\n");
-        cs.write("    }\n");
-        cs.write("    bool ret = false;\n");
-        cs.write("    " + getCsharpName() + " peer = (" + getCsharpName() + ")peer_;\n");
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpEquals());
-            cs.write("    if (!ret) return ret;\n");
-        }
-        cs.write("     return ret;\n");
-        cs.write("  }\n");
+            cs.write("  }\n");
 
-        cs.write("  public override int GetHashCode() {\n");
-        cs.write("    int result = 17;\n");
-        cs.write("    int ret;\n");
-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
-            JField jf = i.next();
-            cs.write(jf.genCsharpHashCode());
-            cs.write("    result = 37*result + ret;\n");
-        }
-        cs.write("    return result;\n");
-        cs.write("  }\n");
-        cs.write("  public static string Signature() {\n");
-        cs.write("    return \""+getSignature()+"\";\n");
-        cs.write("  }\n");
+            cs.write("  public override int GetHashCode() {\n");
+            cs.write("    int result = 17;\n");
+            cs.write("    int ret;\n");
+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {
+                JField jf = i.next();
+                cs.write(jf.genCsharpHashCode());
+                cs.write("    result = 37*result + ret;\n");
+            }
+            cs.write("    return result;\n");
+            cs.write("  }\n");
+            cs.write("  public static string Signature() {\n");
+            cs.write("    return \"" + getSignature() + "\";\n");
+            cs.write("  }\n");
 
-        cs.write("}\n");
-        cs.write("}\n");
+            cs.write("}\n");
+            cs.write("}\n");
 
-        cs.close();
+            cs.close();
+        }
     }
 
     public static String getCsharpFQName(String name) {
diff --git a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
index a72c5bf75..8e39022b4 100644
--- a/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
+++ b/src/java/main/org/apache/zookeeper/ZooKeeperMain.java
@@ -74,8 +74,8 @@
  */
 public class ZooKeeperMain {
     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperMain.class);
-    protected static final Map<String,String> commandMap = new HashMap<String,String>( );
-    protected static final Map<String,CliCommand> commandMapCli = 
+    static final Map<String,String> commandMap = new HashMap<String,String>( );
+    static final Map<String,CliCommand> commandMapCli =
             new HashMap<String,CliCommand>( );
 
     protected MyCommandOptions cl = new MyCommandOptions();
diff --git a/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java b/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java
index 1a0d02abc..e2be21430 100644
--- a/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java
+++ b/src/java/main/org/apache/zookeeper/cli/DeleteCommand.java
@@ -56,14 +56,7 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {
     }
 
     private void retainCompatibility(String[] cmdArgs) throws CliParseException {
-        // delete path [version]
         if (args.length > 2) {
-            // rewrite to option
-            String [] newCmd = new String[4];
-            newCmd[0] = cmdArgs[0];
-            newCmd[1] = "-v";
-            newCmd[2] = cmdArgs[2]; // version
-            newCmd[3] = cmdArgs[1]; // path            
             err.println("'delete path [version]' has been deprecated. "
                     + "Please use 'delete [-v version] path' instead.");
             Parser parser = new PosixParser();
diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 9be80f95f..65c30ef4b 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1301,13 +1301,12 @@ public synchronized WatchesSummary getWatchesSummary() {
      * @param pwriter the output to write to
      */
     public void dumpEphemerals(PrintWriter pwriter) {
-        Set<Long> keys = ephemerals.keySet();
         pwriter.println("Sessions with Ephemerals ("
-                + keys.size() + "):");
-        for (long k : keys) {
-            pwriter.print("0x" + Long.toHexString(k));
+                + ephemerals.keySet().size() + "):");
+        for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {
+            pwriter.print("0x" + Long.toHexString(entry.getKey()));
             pwriter.println(":");
-            HashSet<String> tmp = ephemerals.get(k);
+            HashSet<String> tmp = entry.getValue();
             if (tmp != null) {
                 synchronized (tmp) {
                     for (String path : tmp) {
diff --git a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
index 0e6dd9b6c..f2f225c81 100644
--- a/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java
@@ -478,7 +478,7 @@ private boolean checkFourLetterWord(final SelectionKey k, final int len)
     {
         // We take advantage of the limited size of the length to look
         // for cmds. They are all 4-bytes which fits inside of an int
-        String cmd = FourLetterCommands.cmd2String.get(len);
+        String cmd = FourLetterCommands.getCmdMapView().get(len);
         if (cmd == null) {
             return false;
         }
diff --git a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
index e1c29d997..c48f6b1af 100644
--- a/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
+++ b/src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java
@@ -267,7 +267,7 @@ private boolean checkFourLetterWord(final Channel channel,
     {
         // We take advantage of the limited size of the length to look
         // for cmds. They are all 4-bytes which fits inside of an int
-        String cmd = FourLetterCommands.cmd2String.get(len);
+        String cmd = FourLetterCommands.getCmdMapView().get(len);
         if (cmd == null) {
             return false;
         }
diff --git a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
index 37d198420..d3cdfbb6a 100644
--- a/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
+++ b/src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java
@@ -100,11 +100,18 @@ public boolean accept(File f){
             }
         }
         // add all non-excluded log files
-        List<File> files = new ArrayList<File>(Arrays.asList(txnLog
-                .getDataDir().listFiles(new MyFileFilter(PREFIX_LOG))));
+        File[] logs = txnLog.getDataDir().listFiles(new MyFileFilter(PREFIX_LOG));
+        List<File> files = new ArrayList<>();
+        if (logs != null) {
+            files.addAll(Arrays.asList(logs));
+        }
+
         // add all non-excluded snapshot files to the deletion list
-        files.addAll(Arrays.asList(txnLog.getSnapDir().listFiles(
-                new MyFileFilter(PREFIX_SNAPSHOT))));
+        File[] snapshots = txnLog.getSnapDir().listFiles(new MyFileFilter(PREFIX_SNAPSHOT));
+        if (snapshots != null) {
+            files.addAll(Arrays.asList(snapshots));
+        }
+
         // remove the old files
         for(File f: files)
         {
diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index d4e9f3d39..079d80930 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -333,8 +333,11 @@ public long getLogDirSize() {
     private long getDirSize(File file) {
         long size = 0L;
         if (file.isDirectory()) {
-            for (File f: file.listFiles()) {
-                size += getDirSize(f);
+            File[] files = file.listFiles();
+            if (files != null) {
+                for (File f : files) {
+                    size += getDirSize(f);
+                }
             }
         } else {
             size = file.length();
diff --git a/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java b/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
index d236eccd6..0364f44c0 100644
--- a/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
+++ b/src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java
@@ -19,7 +19,9 @@
 package org.apache.zookeeper.server.command;
 
 import java.nio.ByteBuffer;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.Map;
 
 /**
  * This class contains constants for all the four letter commands
@@ -151,9 +153,13 @@ public class FourLetterCommands {
      */
     public final static int telnetCloseCmd = 0xfff4fffd;
 
-    public final static HashMap<Integer, String> cmd2String =
+    final static HashMap<Integer, String> cmd2String =
         new HashMap<Integer, String>();
 
+    public static Map<Integer, String> getCmdMapView() {
+        return Collections.unmodifiableMap(cmd2String);
+    }
+
     // specify all of the commands that are available
     static {
         cmd2String.put(confCmd, "conf");
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
index b03081a20..404aa8cea 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java
@@ -102,16 +102,16 @@ public boolean equals(Object o){
            QuorumServer qso = qm.getAllMembers().get(qs.id);
            if (qso == null || !qs.equals(qso)) return false;
        }
-       for (Long sid: serverWeight.keySet()){
-           if (!serverWeight.get(sid).equals(qm.serverWeight.get(sid)))
+       for (Entry<Long, Long> entry : serverWeight.entrySet()) {
+           if (!entry.getValue().equals(qm.serverWeight.get(entry.getKey())))
                return false;
        }
-       for (Long sid: groupWeight.keySet()){
-           if (!groupWeight.get(sid).equals(qm.groupWeight.get(sid)))
+       for (Entry<Long, Long> entry : groupWeight.entrySet()) {
+           if (!entry.getValue().equals(qm.groupWeight.get(entry.getKey())))
                return false;
        }
-       for (Long sid: serverGroup.keySet()){
-           if (!serverGroup.get(sid).equals(qm.serverGroup.get(sid)))
+       for (Entry<Long, Long> entry : serverGroup.entrySet()) {
+           if (!entry.getValue().equals(qm.serverGroup.get(entry.getKey())))
                return false;
        }
        return true;
@@ -295,15 +295,16 @@ public String toString(){
      * different places, so we have a separate method.
      */
     private void computeGroupWeight(){
-        for(long sid : serverGroup.keySet()){
-            Long gid = serverGroup.get(sid);
+        for (Entry<Long, Long> entry : serverGroup.entrySet()) {
+            Long sid = entry.getKey();
+            Long gid = entry.getValue();
             if(!groupWeight.containsKey(gid))
                 groupWeight.put(gid, serverWeight.get(sid));
             else {
                 long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);
                 groupWeight.put(gid, totalWeight);
-            } 
-        }    
+            }
+        }
         
         /*
          * Do not consider groups with weight zero
@@ -344,27 +345,27 @@ public boolean containsQuorum(Set<Long> set){
          * Check if all groups have majority
          */
         int majGroupCounter = 0;
-        for(long gid : expansion.keySet()) {
-            LOG.debug("Group info: " + expansion.get(gid) + ", " + gid + ", " + groupWeight.get(gid));
-            if(expansion.get(gid) > (groupWeight.get(gid) / 2) )
+        for (Entry<Long, Long> entry : expansion.entrySet()) {
+            Long gid = entry.getKey();
+            LOG.debug("Group info: {}, {}, {}", entry.getValue(), gid, groupWeight.get(gid));
+            if (entry.getValue() > (groupWeight.get(gid) / 2))
                 majGroupCounter++;
         }
-        
-        LOG.debug("Majority group counter: " + majGroupCounter + ", " + numGroups); 
-        if((majGroupCounter > (numGroups / 2))){
-            LOG.debug("Positive set size: " + set.size());
+
+        LOG.debug("Majority group counter: {}, {}", majGroupCounter, numGroups);
+        if ((majGroupCounter > (numGroups / 2))){
+            LOG.debug("Positive set size: {}", set.size());
             return true;
-        }
-        else {
-            LOG.debug("Negative set size: " + set.size());
+        } else {
+            LOG.debug("Negative set size: {}", set.size());
             return false;
         }
-    }  
-    public Map<Long, QuorumServer> getVotingMembers() {        
+    }
+    public Map<Long, QuorumServer> getVotingMembers() {
        return participatingMembers;
    }
 
-   public Map<Long, QuorumServer> getObservingMembers() {      
+   public Map<Long, QuorumServer> getObservingMembers() {
        return observingMembers;
    }
 
diff --git a/src/java/main/org/apache/zookeeper/version/util/VerGen.java b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
index d4cbeb64e..d3e973102 100644
--- a/src/java/main/org/apache/zookeeper/version/util/VerGen.java
+++ b/src/java/main/org/apache/zookeeper/version/util/VerGen.java
@@ -50,10 +50,8 @@ public static void generateFile(File outputDir, Version version, int rev, String
             System.out.println(path + " is not a directory.");
             System.exit(1);
         }
-        File file = new File(pkgdir, TYPE_NAME + ".java");
-        FileWriter w = null;
-        try {
-            w = new FileWriter(file);
+
+        try (FileWriter w = new FileWriter(new File(pkgdir, TYPE_NAME + ".java"))) {
             w.write("// Do not edit!\n// File generated by org.apache.zookeeper"
                     + ".version.util.VerGen.\n");
             w.write("/**\n");
@@ -94,15 +92,6 @@ public static void generateFile(File outputDir, Version version, int rev, String
             System.out.println("Unable to generate version.Info file: "
                     + e.getMessage());
             System.exit(1);
-        } finally {
-            if (w != null) {
-                try {
-                    w.close();
-                } catch (IOException e) {
-                    System.out.println("Unable to close file writer"
-                            + e.getMessage());
-                }
-            }
         }
     }
 
diff --git a/src/java/test/config/findbugsExcludeFile.xml b/src/java/test/config/findbugsExcludeFile.xml
index e88e5f20f..7a7fa4b49 100644
--- a/src/java/test/config/findbugsExcludeFile.xml
+++ b/src/java/test/config/findbugsExcludeFile.xml
@@ -144,4 +144,10 @@
     <Bug pattern="DM_DEFAULT_ENCODING" />
   </Match>
 
+  <!-- Disable 'Malicious code vulnerability warnings' due to mutable collection types in interface.
+       Undo this when ZOOKEEPER-1362 is done. -->
+  <Match>
+    <Class name="org.apache.zookeeper.ZooDefs$Ids"/>
+      <Bug pattern="MS_MUTABLE_COLLECTION" />
+  </Match>
 </FindBugsFilter>
