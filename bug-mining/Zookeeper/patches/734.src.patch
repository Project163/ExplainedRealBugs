diff --git a/CHANGES.txt b/CHANGES.txt
index dd239631c..6ab440fa1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -244,6 +244,9 @@ BUGFIXES:
   ZOOKEEPER-2252: Random test case failure in
   org.apache.zookeeper.test.StaticHostProviderTest (Timothy Ward via cnauroth)
 
+  ZOOKEEPER-1029: C client bug in zookeeper_init (if bad hostname is given)
+  (fpj via cnauroth)
+
 IMPROVEMENTS:
   ZOOKEEPER-1660 Documentation for Dynamic Reconfiguration (Reed Wanderman-Milne via shralex)  
 
diff --git a/src/c/src/mt_adaptor.c b/src/c/src/mt_adaptor.c
index 23038fa7a..fe4792a17 100644
--- a/src/c/src/mt_adaptor.c
+++ b/src/c/src/mt_adaptor.c
@@ -44,30 +44,30 @@
 #include <sys/time.h>
 #endif
 
-void zoo_lock_auth(zhandle_t *zh)
+int zoo_lock_auth(zhandle_t *zh)
 {
-    pthread_mutex_lock(&zh->auth_h.lock);
+    return pthread_mutex_lock(&zh->auth_h.lock);
 }
-void zoo_unlock_auth(zhandle_t *zh)
+int zoo_unlock_auth(zhandle_t *zh)
 {
-    pthread_mutex_unlock(&zh->auth_h.lock);
+    return pthread_mutex_unlock(&zh->auth_h.lock);
 }
-void lock_buffer_list(buffer_head_t *l)
+int lock_buffer_list(buffer_head_t *l)
 {
-    pthread_mutex_lock(&l->lock);
+    return pthread_mutex_lock(&l->lock);
 }
-void unlock_buffer_list(buffer_head_t *l)
+int unlock_buffer_list(buffer_head_t *l)
 {
-    pthread_mutex_unlock(&l->lock);
+    return pthread_mutex_unlock(&l->lock);
 }
-void lock_completion_list(completion_head_t *l)
+int lock_completion_list(completion_head_t *l)
 {
-    pthread_mutex_lock(&l->lock);
+    return pthread_mutex_lock(&l->lock);
 }
-void unlock_completion_list(completion_head_t *l)
+int unlock_completion_list(completion_head_t *l)
 {
     pthread_cond_broadcast(&l->cond);
-    pthread_mutex_unlock(&l->lock);
+    return pthread_mutex_unlock(&l->lock);
 }
 struct sync_completion *alloc_sync_completion(void)
 {
@@ -512,29 +512,41 @@ __attribute__((constructor)) int32_t get_xid()
     return fetch_and_add(&xid,1);
 }
 
-void lock_reconfig(struct _zhandle *zh)
+int lock_reconfig(struct _zhandle *zh)
 {
     struct adaptor_threads *adaptor = zh->adaptor_priv;
-    if(adaptor)
-        pthread_mutex_lock(&adaptor->reconfig_lock);
+    if (adaptor) {
+        return pthread_mutex_lock(&adaptor->reconfig_lock);
+    } else {
+        return 0;
+    }
 }
-void unlock_reconfig(struct _zhandle *zh)
+int unlock_reconfig(struct _zhandle *zh)
 {
     struct adaptor_threads *adaptor = zh->adaptor_priv;
-    if(adaptor)
-        pthread_mutex_unlock(&adaptor->reconfig_lock);
+    if (adaptor) {
+        return pthread_mutex_unlock(&adaptor->reconfig_lock);
+    } else {
+        return 0;
+    }
 }
 
-void enter_critical(zhandle_t* zh)
+int enter_critical(zhandle_t* zh)
 {
     struct adaptor_threads *adaptor = zh->adaptor_priv;
-    if(adaptor)
-        pthread_mutex_lock(&adaptor->zh_lock);
+    if (adaptor) {
+        return pthread_mutex_lock(&adaptor->zh_lock);
+    } else {
+        return 0;
+    }
 }
 
-void leave_critical(zhandle_t* zh)
+int leave_critical(zhandle_t* zh)
 {
     struct adaptor_threads *adaptor = zh->adaptor_priv;
-    if(adaptor)
-        pthread_mutex_unlock(&adaptor->zh_lock);    
+    if (adaptor) {
+        return pthread_mutex_unlock(&adaptor->zh_lock);
+    } else {
+        return 0;
+    }
 }
diff --git a/src/c/src/st_adaptor.c b/src/c/src/st_adaptor.c
index 54c938257..0f62966bd 100644
--- a/src/c/src/st_adaptor.c
+++ b/src/c/src/st_adaptor.c
@@ -24,23 +24,29 @@
 #include <stdlib.h>
 #include <time.h>
 
-void zoo_lock_auth(zhandle_t *zh)
+int zoo_lock_auth(zhandle_t *zh)
 {
+    return 0;
 }
-void zoo_unlock_auth(zhandle_t *zh)
+int zoo_unlock_auth(zhandle_t *zh)
 {
+    return 0;
 }
-void lock_buffer_list(buffer_head_t *l)
+int lock_buffer_list(buffer_head_t *l)
 {
+    return 0;
 }
-void unlock_buffer_list(buffer_head_t *l)
+int unlock_buffer_list(buffer_head_t *l)
 {
+    return 0;
 }
-void lock_completion_list(completion_head_t *l)
+int lock_completion_list(completion_head_t *l)
 {
+    return 0;
 }
-void unlock_completion_list(completion_head_t *l)
+int unlock_completion_list(completion_head_t *l)
 {
+    return 0;
 }
 struct sync_completion *alloc_sync_completion(void)
 {
@@ -96,8 +102,22 @@ int32_t get_xid()
     return xid++;
 }
 
-void lock_reconfig(struct _zhandle *zh){}
-void unlock_reconfig(struct _zhandle *zh){}
+int lock_reconfig(struct _zhandle *zh)
+{
+    return 0;
+}
+
+int unlock_reconfig(struct _zhandle *zh)
+{
+    return 0;
+}
+
+int enter_critical(zhandle_t* zh)
+{
+    return 0;
+}
 
-void enter_critical(zhandle_t* zh){}
-void leave_critical(zhandle_t* zh){}
+int leave_critical(zhandle_t* zh)
+{
+    return 0;
+}
diff --git a/src/c/src/zk_adaptor.h b/src/c/src/zk_adaptor.h
index a4626e998..2039fb32a 100644
--- a/src/c/src/zk_adaptor.h
+++ b/src/c/src/zk_adaptor.h
@@ -77,10 +77,10 @@ typedef struct _completion_head {
 #endif
 } completion_head_t;
 
-void lock_buffer_list(buffer_head_t *l);
-void unlock_buffer_list(buffer_head_t *l);
-void lock_completion_list(completion_head_t *l);
-void unlock_completion_list(completion_head_t *l);
+int lock_buffer_list(buffer_head_t *l);
+int unlock_buffer_list(buffer_head_t *l);
+int lock_completion_list(completion_head_t *l);
+int unlock_completion_list(completion_head_t *l);
 
 struct sync_completion {
     int rc;
@@ -278,16 +278,16 @@ void process_completions(zhandle_t *zh);
 int flush_send_queue(zhandle_t*zh, int timeout);
 char* sub_string(zhandle_t *zh, const char* server_path);
 void free_duplicate_path(const char* free_path, const char* path);
-void zoo_lock_auth(zhandle_t *zh);
-void zoo_unlock_auth(zhandle_t *zh);
+int zoo_lock_auth(zhandle_t *zh);
+int zoo_unlock_auth(zhandle_t *zh);
 
 // ensemble reconfigure access guards
-void lock_reconfig(struct _zhandle *zh);
-void unlock_reconfig(struct _zhandle *zh);
+int lock_reconfig(struct _zhandle *zh);
+int unlock_reconfig(struct _zhandle *zh);
 
 // critical section guards
-void enter_critical(zhandle_t* zh);
-void leave_critical(zhandle_t* zh);
+int enter_critical(zhandle_t* zh);
+int leave_critical(zhandle_t* zh);
 
 // zhandle object reference counting
 void api_prolog(zhandle_t* zh);
diff --git a/src/c/src/zookeeper.c b/src/c/src/zookeeper.c
index 7fa8681a5..7549d4897 100644
--- a/src/c/src/zookeeper.c
+++ b/src/c/src/zookeeper.c
@@ -1614,52 +1614,56 @@ void free_completions(zhandle_t *zh,int callCompletion,int reason)
     void_completion_t auth_completion = NULL;
     auth_completion_list_t a_list, *a_tmp;
 
-    lock_completion_list(&zh->sent_requests);
-    tmp_list = zh->sent_requests;
-    zh->sent_requests.head = 0;
-    zh->sent_requests.last = 0;
-    unlock_completion_list(&zh->sent_requests);
-    while (tmp_list.head) {
-        completion_list_t *cptr = tmp_list.head;
-
-        tmp_list.head = cptr->next;
-        if (cptr->c.data_result == SYNCHRONOUS_MARKER) {
-            struct sync_completion
-                        *sc = (struct sync_completion*)cptr->data;
-            sc->rc = reason;
-            notify_sync_completion(sc);
-            zh->outstanding_sync--;
-            destroy_completion_entry(cptr);
-        } else if (callCompletion) {
-            // Fake the response
-            buffer_list_t *bptr;
-            h.xid = cptr->xid;
-            h.zxid = -1;
-            h.err = reason;
-            oa = create_buffer_oarchive();
-            serialize_ReplyHeader(oa, "header", &h);
-            bptr = calloc(sizeof(*bptr), 1);
-            assert(bptr);
-            bptr->len = get_buffer_len(oa);
-            bptr->buffer = get_buffer(oa);
-            close_buffer_oarchive(&oa, 0);
-            cptr->buffer = bptr;
-            queue_completion(&zh->completions_to_process, cptr, 0);
+    if (lock_completion_list(&zh->sent_requests) == 0) {
+        tmp_list = zh->sent_requests;
+        zh->sent_requests.head = 0;
+        zh->sent_requests.last = 0;
+        unlock_completion_list(&zh->sent_requests);
+        while (tmp_list.head) {
+            completion_list_t *cptr = tmp_list.head;
+
+            tmp_list.head = cptr->next;
+            if (cptr->c.data_result == SYNCHRONOUS_MARKER) {
+                struct sync_completion
+                            *sc = (struct sync_completion*)cptr->data;
+                sc->rc = reason;
+                notify_sync_completion(sc);
+                zh->outstanding_sync--;
+                destroy_completion_entry(cptr);
+            } else if (callCompletion) {
+                // Fake the response
+                buffer_list_t *bptr;
+                h.xid = cptr->xid;
+                h.zxid = -1;
+                h.err = reason;
+                oa = create_buffer_oarchive();
+                serialize_ReplyHeader(oa, "header", &h);
+                bptr = calloc(sizeof(*bptr), 1);
+                assert(bptr);
+                bptr->len = get_buffer_len(oa);
+                bptr->buffer = get_buffer(oa);
+                close_buffer_oarchive(&oa, 0);
+                cptr->buffer = bptr;
+                queue_completion(&zh->completions_to_process, cptr, 0);
+            }
         }
     }
-    a_list.completion = NULL;
-    a_list.next = NULL;
-    zoo_lock_auth(zh);
-    get_auth_completions(&zh->auth_h, &a_list);
-    zoo_unlock_auth(zh);
-    a_tmp = &a_list;
-    // chain call user's completion function
-    while (a_tmp->completion != NULL) {
-        auth_completion = a_tmp->completion;
-        auth_completion(reason, a_tmp->auth_data);
-        a_tmp = a_tmp->next;
-        if (a_tmp == NULL)
-            break;
+    if (zoo_lock_auth(zh) == 0) {
+        a_list.completion = NULL;
+        a_list.next = NULL;
+
+        get_auth_completions(&zh->auth_h, &a_list);
+        zoo_unlock_auth(zh);
+    
+        a_tmp = &a_list;
+        // chain call user's completion function
+        while (a_tmp->completion != NULL) {
+            auth_completion = a_tmp->completion;
+            auth_completion(reason, a_tmp->auth_data);
+            a_tmp = a_tmp->next;
+            if (a_tmp == NULL)
+                break;
+        }
     }
     free_auth_completion(&a_list);
 }
