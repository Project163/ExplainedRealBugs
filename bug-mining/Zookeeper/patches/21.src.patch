diff --git a/src/c/include/zookeeper.h b/src/c/include/zookeeper.h
index 15abce283..aea4d1273 100644
--- a/src/c/include/zookeeper.h
+++ b/src/c/include/zookeeper.h
@@ -100,23 +100,23 @@ extern "C" {
 /**
 *  @name Debug levels
 */
-typedef enum {LOG_LEVEL_ERROR=1,LOG_LEVEL_WARN=2,LOG_LEVEL_INFO=3,LOG_LEVEL_DEBUG=4} ZooLogLevel;
+typedef enum {ZOO_LOG_LEVEL_ERROR=1,ZOO_LOG_LEVEL_WARN=2,ZOO_LOG_LEVEL_INFO=3,ZOO_LOG_LEVEL_DEBUG=4} ZooLogLevel;
 /**
  * @name ACL Consts
  */
-extern ZOOAPI const int PERM_READ;
-extern ZOOAPI const int PERM_WRITE;
-extern ZOOAPI const int PERM_CREATE;
-extern ZOOAPI const int PERM_DELETE;
-extern ZOOAPI const int PERM_ADMIN;
-extern ZOOAPI const int PERM_ALL;
+extern ZOOAPI const int ZOO_PERM_READ;
+extern ZOOAPI const int ZOO_PERM_WRITE;
+extern ZOOAPI const int ZOO_PERM_CREATE;
+extern ZOOAPI const int ZOO_PERM_DELETE;
+extern ZOOAPI const int ZOO_PERM_ADMIN;
+extern ZOOAPI const int ZOO_PERM_ALL;
 
-extern ZOOAPI struct Id ANYONE_ID_UNSAFE;
-extern ZOOAPI struct Id AUTH_IDS;
+extern ZOOAPI struct Id ZOO_ANYONE_ID_UNSAFE;
+extern ZOOAPI struct Id ZOO_AUTH_IDS;
 
-extern ZOOAPI struct ACL_vector OPEN_ACL_UNSAFE;
-extern ZOOAPI struct ACL_vector READ_ACL_UNSAFE;
-extern ZOOAPI struct ACL_vector CREATOR_ALL_ACL;
+extern ZOOAPI struct ACL_vector ZOO_OPEN_ACL_UNSAFE;
+extern ZOOAPI struct ACL_vector ZOO_READ_ACL_UNSAFE;
+extern ZOOAPI struct ACL_vector ZOO_CREATOR_ALL_ACL;
 
 /**
  * @name Interest Consts
@@ -138,23 +138,23 @@ extern ZOOAPI const int ZOOKEEPER_READ;
  * be ORed together to combine effects.
  */
 // @{
-extern ZOOAPI const int EPHEMERAL;
-extern ZOOAPI const int SEQUENCE;
+extern ZOOAPI const int ZOO_EPHEMERAL;
+extern ZOOAPI const int ZOO_SEQUENCE;
 // @}
 
 /**
  * @name State Consts
  * These constants represent the states of a zookeeper connection. They are
  * possible parameters of the watcher callback. If a connection moves from
- * the CONNECTED_STATE to the CONNECTING_STATE, all outstanding watches will
- * be removed.
+ * the ZOO_CONNECTED_STATE to the ZOO_CONNECTING_STATE, all outstanding 
+ * watches will be removed.
  */
 // @{
-extern ZOOAPI const int EXPIRED_SESSION_STATE;
-extern ZOOAPI const int AUTH_FAILED_STATE;
-extern ZOOAPI const int CONNECTING_STATE;
-extern ZOOAPI const int ASSOCIATING_STATE;
-extern ZOOAPI const int CONNECTED_STATE;
+extern ZOOAPI const int ZOO_EXPIRED_SESSION_STATE;
+extern ZOOAPI const int ZOO_AUTH_FAILED_STATE;
+extern ZOOAPI const int ZOO_CONNECTING_STATE;
+extern ZOOAPI const int ZOO_ASSOCIATING_STATE;
+extern ZOOAPI const int ZOO_CONNECTED_STATE;
 // @}
 
 /**
@@ -169,34 +169,34 @@ extern ZOOAPI const int CONNECTED_STATE;
  * This is only generated by watches on non-existent nodes. These watches
  * are set using \ref zoo_exists.
  */
-extern ZOOAPI const int CREATED_EVENT;
+extern ZOOAPI const int ZOO_CREATED_EVENT;
 /**
  * \brief a node has been deleted.
  * 
  * This is only generated by watches on nodes. These watches
  * are set using \ref zoo_exists and \ref zoo_get.
  */
-extern ZOOAPI const int DELETED_EVENT;
+extern ZOOAPI const int ZOO_DELETED_EVENT;
 /**
  * \brief a node has changed.
  * 
  * This is only generated by watches on nodes. These watches
  * are set using \ref zoo_exists and \ref zoo_get.
  */
-extern ZOOAPI const int CHANGED_EVENT;
+extern ZOOAPI const int ZOO_CHANGED_EVENT;
 /**
  * \brief a change as occurred in the list of children.
  * 
  * This is only generated by watches on the child list of a node. These watches
  * are set using \ref zoo_get_children.
  */
-extern ZOOAPI const int CHILD_EVENT;
+extern ZOOAPI const int ZOO_CHILD_EVENT;
 /**
  * \brief a session has been lost.
  * 
  * This is generated when a client loses contact or reconnects with a server.
  */
-extern ZOOAPI const int SESSION_EVENT;
+extern ZOOAPI const int ZOO_SESSION_EVENT;
 
 /**
  * \brief a watch has been removed.
@@ -204,7 +204,7 @@ extern ZOOAPI const int SESSION_EVENT;
  * This is generated when the server for some reason, probably a resource
  * constraint, will no longer watch a node for a client.
  */
-extern ZOOAPI const int NOTWATCHING_EVENT;
+extern ZOOAPI const int ZOO_NOTWATCHING_EVENT;
 // @}
 
 /**
@@ -249,10 +249,10 @@ typedef struct {
  * 
  * \param zh zookeeper handle
  * \param type event type. This is one of the *_EVENT constants. 
- * \param state connection state. If the type is SESSION_EVENT, the state value 
+ * \param state connection state. If the type is ZOO_SESSION_EVENT, the state value 
  * will be one of the *_STATE constants, otherwise -1.
  * \param path znode path for which the watcher is triggered. NULL if the event 
- * type is SESSION_EVENT
+ * type is ZOO_SESSION_EVENT
  * \param watcherCtx watcher context.
  */
 typedef void (*watcher_fn)(zhandle_t *zh, int type, 
@@ -336,7 +336,7 @@ ZOOAPI watcher_fn zoo_set_watcher(zhandle_t *zh,watcher_fn newFn);
  * \return a result code.
  * ZOK - success
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZCONNECTIONLOSS - a network error occured while attempting to establish 
  * a connection to the server
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
@@ -355,7 +355,7 @@ ZOOAPI int zookeeper_interest(zhandle_t *zh, int *fd, int *interest,
  * \return a result code. 
  * ZOK - success
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZCONNECTIONLOSS - a network error occured while attempting to send request to server
  * ZSESSIONEXPIRED - connection attempt failed -- the session's expired
  * ZAUTHFAILED - authentication request failed, e.i. invalid credentials
@@ -519,8 +519,8 @@ ZOOAPI int zoo_state(zhandle_t *zh);
  * 
  * This method will create a node in ZooKeeper. A node can only be created if
  * it does not already exists. The Create Flags affect the creation of nodes.
- * If EPHEMERAL flag is set, the node will automatically get removed if the
- * client session goes away. If the SEQUENCE flag is set, a unique
+ * If ZOO_EPHEMERAL flag is set, the node will automatically get removed if the
+ * client session goes away. If the ZOO_SEQUENCE flag is set, a unique
  * monotonically increasing sequence number is appended to the path name.
  * 
  * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
@@ -543,7 +543,7 @@ ZOOAPI int zoo_state(zhandle_t *zh);
  * function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_acreate(zhandle_t *zh, const char *path, const char *value, 
@@ -570,7 +570,7 @@ ZOOAPI int zoo_acreate(zhandle_t *zh, const char *path, const char *value,
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_adelete(zhandle_t *zh, const char *path, int version, 
@@ -594,7 +594,7 @@ ZOOAPI int zoo_adelete(zhandle_t *zh, const char *path, int version,
  * function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_aexists(zhandle_t *zh, const char *path, int watch, 
@@ -626,7 +626,7 @@ ZOOAPI int zoo_aexists(zhandle_t *zh, const char *path, int watch,
  * function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_awexists(zhandle_t *zh, const char *path, 
@@ -650,7 +650,7 @@ ZOOAPI int zoo_awexists(zhandle_t *zh, const char *path,
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either in SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either in ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_aget(zhandle_t *zh, const char *path, int watch, 
@@ -679,7 +679,7 @@ ZOOAPI int zoo_aget(zhandle_t *zh, const char *path, int watch,
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either in SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either in ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_awget(zhandle_t *zh, const char *path, 
@@ -709,7 +709,7 @@ ZOOAPI int zoo_awget(zhandle_t *zh, const char *path,
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_aset(zhandle_t *zh, const char *path, const char *buffer, int buflen, 
@@ -732,7 +732,7 @@ ZOOAPI int zoo_aset(zhandle_t *zh, const char *path, const char *buffer, int buf
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_aget_children(zhandle_t *zh, const char *path, int watch, 
@@ -761,7 +761,7 @@ ZOOAPI int zoo_aget_children(zhandle_t *zh, const char *path, int watch,
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_awget_children(zhandle_t *zh, const char *path,
@@ -783,7 +783,7 @@ ZOOAPI int zoo_awget_children(zhandle_t *zh, const char *path,
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 
@@ -806,7 +806,7 @@ ZOOAPI int zoo_async(zhandle_t *zh, const char *path,
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_aget_acl(zhandle_t *zh, const char *path, acl_completion_t completion, 
@@ -831,7 +831,7 @@ ZOOAPI int zoo_aget_acl(zhandle_t *zh, const char *path, acl_completion_t comple
  * the function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_aset_acl(zhandle_t *zh, const char *path, int version, 
@@ -853,7 +853,7 @@ ZOOAPI const char* zerror(int c);
  * the scheme parameter to authenticate the client connection. If the 
  * authentication request has failed:
  * - the server connection is dropped
- * - the watcher is called with the AUTH_FAILED_STATE value as the state 
+ * - the watcher is called with the ZOO_AUTH_FAILED_STATE value as the state 
  * parameter.
  * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
  * \param scheme the id of authentication scheme. Natively supported:
@@ -868,7 +868,7 @@ ZOOAPI const char* zerror(int c);
  * function completes.
  * \return ZOK on success or one of the following errcodes on failure:
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  * ZSYSTEMERROR - a system error occured
  */
@@ -915,8 +915,8 @@ ZOOAPI void zoo_deterministic_conn_order(int yesOrNo);
  * 
  * This method will create a node in ZooKeeper. A node can only be created if
  * it does not already exists. The Create Flags affect the creation of nodes.
- * If EPHEMERAL flag is set, the node will automatically get removed if the
- * client session goes away. If the SEQUENCE flag is set, a unique
+ * If ZOO_EPHEMERAL flag is set, the node will automatically get removed if the
+ * client session goes away. If the ZOO_SEQUENCE flag is set, a unique
  * monotonically increasing sequence number is appended to the path name.
  * 
  * \param zh the zookeeper handle obtained by a call to \ref zookeeper_init
@@ -929,7 +929,7 @@ ZOOAPI void zoo_deterministic_conn_order(int yesOrNo);
  * \param flags this parameter can be set to 0 for normal create or an OR
  *    of the Create Flags
  * \param realpath the real path that is created (this might be different than the
- *    path to create because of the SEQUENCE flag.
+ *    path to create because of the ZOO_SEQUENCE flag.
  * \param the maximum length of real path you would want.
  * \return  one of the following codes are returned:
  * ZOK operation completed succesfully
@@ -938,7 +938,7 @@ ZOOAPI void zoo_deterministic_conn_order(int yesOrNo);
  * ZNOAUTH the client does not have permission.
  * ZNOCHILDRENFOREPHEMERALS cannot create children of ephemeral nodes.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_create(zhandle_t *zh, const char *path, const char *value,
@@ -961,7 +961,7 @@ ZOOAPI int zoo_create(zhandle_t *zh, const char *path, const char *value,
  * ZBADVERSION expected version does not match actual version.
  * ZNOTEMPTY children are present; node cannot be deleted.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_delete(zhandle_t *zh, const char *path, int version);
@@ -982,7 +982,7 @@ ZOOAPI int zoo_delete(zhandle_t *zh, const char *path, int version);
  * ZNONODE the node does not exist.
  * ZNOAUTH the client does not have permission.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_exists(zhandle_t *zh, const char *path, int watch, struct Stat *stat);
@@ -1008,7 +1008,7 @@ ZOOAPI int zoo_exists(zhandle_t *zh, const char *path, int watch, struct Stat *s
  * ZNONODE the node does not exist.
  * ZNOAUTH the client does not have permission.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_wexists(zhandle_t *zh, const char *path,
@@ -1031,7 +1031,7 @@ ZOOAPI int zoo_wexists(zhandle_t *zh, const char *path,
  * ZNONODE the node does not exist.
  * ZNOAUTH the client does not have permission.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either in SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either in ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_get(zhandle_t *zh, const char *path, int watch, char *buffer,   
@@ -1060,7 +1060,7 @@ ZOOAPI int zoo_get(zhandle_t *zh, const char *path, int watch, char *buffer,
  * ZNONODE the node does not exist.
  * ZNOAUTH the client does not have permission.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either in SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either in ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_wget(zhandle_t *zh, const char *path, 
@@ -1084,7 +1084,7 @@ ZOOAPI int zoo_wget(zhandle_t *zh, const char *path,
  * ZNOAUTH the client does not have permission.
  * ZBADVERSION expected version does not match actual version.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_set(zhandle_t *zh, const char *path, const char *buffer, int buflen,
@@ -1105,7 +1105,7 @@ ZOOAPI int zoo_set(zhandle_t *zh, const char *path, const char *buffer, int bufl
  * ZNONODE the node does not exist.
  * ZNOAUTH the client does not have permission.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_get_children(zhandle_t *zh, const char *path, int watch,
@@ -1131,7 +1131,7 @@ ZOOAPI int zoo_get_children(zhandle_t *zh, const char *path, int watch,
  * ZNONODE the node does not exist.
  * ZNOAUTH the client does not have permission.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_wget_children(zhandle_t *zh, const char *path, 
@@ -1151,7 +1151,7 @@ ZOOAPI int zoo_wget_children(zhandle_t *zh, const char *path,
  * ZNONODE the node does not exist.
  * ZNOAUTH the client does not have permission.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_get_acl(zhandle_t *zh, const char *path, struct ACL_vector *acl,
@@ -1172,7 +1172,7 @@ ZOOAPI int zoo_get_acl(zhandle_t *zh, const char *path, struct ACL_vector *acl,
  * ZINVALIDACL invalid ACL specified
  * ZBADVERSION expected version does not match actual version.
  * ZBADARGUMENTS - invalid input parameters
- * ZINVALIDSTATE - zhandle state is either SESSION_EXPIRED_STATE or AUTH_FAILED_STATE
+ * ZINVALIDSTATE - zhandle state is either ZOO_SESSION_EXPIRED_STATE or ZOO_AUTH_FAILED_STATE
  * ZMARSHALLINGERROR - failed to marshall a request; possibly, out of memory
  */
 ZOOAPI int zoo_set_acl(zhandle_t *zh, const char *path, int version,
diff --git a/src/c/src/cli.c b/src/c/src/cli.c
index 227cf7d5e..596c16bb2 100644
--- a/src/c/src/cli.c
+++ b/src/c/src/cli.c
@@ -57,8 +57,8 @@ printProfileInfo(struct timeval start, struct timeval end,int thres,const char*
 
 void watcher(zhandle_t *zzh, int type, int state, const char *path,void* context) {
     fprintf(stderr,"Watcher %d state = %d for %s\n", type, state, (path ? path: "null"));
-    if (type == SESSION_EVENT) {
-        if (state == CONNECTED_STATE) {
+    if (type == ZOO_SESSION_EVENT) {
+        if (state == ZOO_CONNECTED_STATE) {
             const clientid_t *id = zoo_client_id(zh);
             if (myid.client_id == 0|| myid.client_id != id->client_id) {
                 myid = *id;
@@ -73,12 +73,12 @@ void watcher(zhandle_t *zzh, int type, int state, const char *path,void* context
                     }
                 }
             }
-        } else if (state == AUTH_FAILED_STATE) {
+        } else if (state == ZOO_AUTH_FAILED_STATE) {
             fprintf(stderr, "Authentication failure. Shutting down...\n");
             zookeeper_close(zh);
             shutdownThisThing=1;
             zh=0;
-        } else if (state == EXPIRED_SESSION_STATE) {
+        } else if (state == ZOO_EXPIRED_SESSION_STATE) {
             fprintf(stderr, "Session expired. Shutting down...\n");
             zookeeper_close(zh);
             shutdownThisThing=1;
@@ -284,11 +284,11 @@ void processline(char *line) {
         if (line[0] == '+') {
             line++;
             if (line[0] == 'e') {
-                flags |= EPHEMERAL;
+                flags |= ZOO_EPHEMERAL;
                 line++;
             }
             if (line[0] == 's') {
-                flags |= SEQUENCE;
+                flags |= ZOO_SEQUENCE;
                 line++;
             }
             line++;
@@ -299,12 +299,12 @@ void processline(char *line) {
         }
         fprintf(stderr, "Creating [%s] node\n", line);
 //        {
-//            struct ACL _CREATE_ONLY_ACL_ACL[] = {{PERM_CREATE, ANYONE_ID_UNSAFE}};
+//            struct ACL _CREATE_ONLY_ACL_ACL[] = {{ZOO_PERM_CREATE, ZOO_ANYONE_ID_UNSAFE}};
 //            struct ACL_vector CREATE_ONLY_ACL = {1,_CREATE_ONLY_ACL_ACL};
 //            rc = zoo_acreate(zh, line, "new", 3, &CREATE_ONLY_ACL, flags,
 //                    my_string_completion, strdup(line));
 //        }
-        rc = zoo_acreate(zh, line, "new", 3, &OPEN_ACL_UNSAFE, flags,
+        rc = zoo_acreate(zh, line, "new", 3, &ZOO_OPEN_ACL_UNSAFE, flags,
                 my_string_completion, strdup(line));
         if (rc) {
             fprintf(stderr, "Error %d for %s\n", rc, line);
@@ -415,7 +415,7 @@ int main(int argc, char **argv) {
 #else
     strcpy(p, "dummy");
 #endif
-    zoo_set_debug_level(LOG_LEVEL_DEBUG);
+    zoo_set_debug_level(ZOO_LOG_LEVEL_DEBUG);
     zoo_deterministic_conn_order(1); // enable deterministic order
     hostPort = argv[1];
     zh = zookeeper_init(hostPort, watcher, 10000, &myid, 0, 0);
diff --git a/src/c/src/load_gen.c b/src/c/src/load_gen.c
index 4571192a1..2731986a7 100644
--- a/src/c/src/load_gen.c
+++ b/src/c/src/load_gen.c
@@ -40,7 +40,7 @@ static int counter;
 
 void ensureConnected(){
     pthread_mutex_lock(&lock);
-    while (zoo_state(zh)!=CONNECTED_STATE) {
+    while (zoo_state(zh)!=ZOO_CONNECTED_STATE) {
         pthread_cond_wait(&cond,&lock);
     }
     pthread_mutex_unlock(&lock);
@@ -69,8 +69,8 @@ void waitCounter(){
 }
 
 void listener(zhandle_t *zzh, int type, int state, const char *path,void* ctx) {
-    if(type == SESSION_EVENT){
-        if(state == CONNECTED_STATE){
+    if(type == ZOO_SESSION_EVENT){
+        if(state == ZOO_CONNECTED_STATE){
             pthread_mutex_lock(&lock);
             pthread_cond_broadcast(&cond);
             pthread_mutex_unlock(&lock);
@@ -92,7 +92,7 @@ int doCreateNodes(const char* root, int count){
     for(i=0; i<count;i++){
         snprintf(nodeName, sizeof(nodeName),"%s/%d",root,i);
         incCounter(1);
-        int rc=zoo_acreate(zh, nodeName, "first", 5, &OPEN_ACL_UNSAFE, 0,
+        int rc=zoo_acreate(zh, nodeName, "first", 5, &ZOO_OPEN_ACL_UNSAFE, 0,
                             create_completion, 0);
         if(i%1000==0){
             LOG_INFO(("Created %s",nodeName));
@@ -103,7 +103,7 @@ int doCreateNodes(const char* root, int count){
 
 int createRoot(const char* root){
     char realpath[1024];
-    return zoo_create(zh,root,"root",4,&OPEN_ACL_UNSAFE,0,realpath,sizeof(realpath)-1);
+    return zoo_create(zh,root,"root",4,&ZOO_OPEN_ACL_UNSAFE,0,realpath,sizeof(realpath)-1);
 }
 
 void write_completion(int rc, const struct Stat *stat, const void *data) {
@@ -227,7 +227,7 @@ int main(int argc, char **argv) {
     if(strcmp("clean",argv[3])==0){
         cleaning=1;
     }
-    zoo_set_debug_level(LOG_LEVEL_INFO);
+    zoo_set_debug_level(ZOO_LOG_LEVEL_INFO);
     zoo_deterministic_conn_order(1); // enable deterministic order
 
     zh = zookeeper_init(argv[1], listener, 10000, 0, 0, 0);
diff --git a/src/c/src/zk_adaptor.h b/src/c/src/zk_adaptor.h
index c121fdf58..76482c019 100644
--- a/src/c/src/zk_adaptor.h
+++ b/src/c/src/zk_adaptor.h
@@ -228,7 +228,7 @@ int queue_session_event(zhandle_t *zh, int state);
 #define PROCESS_SESSION_EVENT(zh,newstate) queue_session_event(zh,newstate)
 #else
 // in single-threaded mode process session event immediately
-#define PROCESS_SESSION_EVENT(zh,newstate) deliverWatchers(zh,SESSION_EVENT,newstate,0)
+#define PROCESS_SESSION_EVENT(zh,newstate) deliverWatchers(zh,ZOO_SESSION_EVENT,newstate,0)
 #endif
 
 #ifdef __cplusplus
diff --git a/src/c/src/zk_hashtable.c b/src/c/src/zk_hashtable.c
index 209459b38..944fc3c27 100644
--- a/src/c/src/zk_hashtable.c
+++ b/src/c/src/zk_hashtable.c
@@ -385,9 +385,9 @@ void deliver_znode_event(zk_hashtable* ht,zhandle_t* zh,const char* path,int typ
 void deliverWatchers(zhandle_t* zh,int type,int state, const char* path)
 {
     zk_hashtable *ht;
-    if(type==SESSION_EVENT){
+    if(type==ZOO_SESSION_EVENT){
         watcher_object_t defWatcher;
-        if(state==CONNECTED_STATE){
+        if(state==ZOO_CONNECTED_STATE){
             clean_zk_hashtable(zh->active_node_watchers);
             clean_zk_hashtable(zh->active_child_watchers);
             // unconditionally call back the default watcher only
diff --git a/src/c/src/zk_log.c b/src/c/src/zk_log.c
index c7a5ca58b..9551e5bfc 100644
--- a/src/c/src/zk_log.c
+++ b/src/c/src/zk_log.c
@@ -75,7 +75,7 @@ char* get_format_log_buffer(){
 
 #endif
 
-ZooLogLevel logLevel=LOG_LEVEL_INFO;
+ZooLogLevel logLevel=ZOO_LOG_LEVEL_INFO;
 
 static FILE* logStream=0;
 FILE* getLogStream(){
@@ -137,8 +137,8 @@ void zoo_set_debug_level(ZooLogLevel level)
         logLevel=(ZooLogLevel)0;
         return;
     }
-    if(level<LOG_LEVEL_ERROR)level=LOG_LEVEL_ERROR;
-    if(level>LOG_LEVEL_DEBUG)level=LOG_LEVEL_DEBUG;
+    if(level<ZOO_LOG_LEVEL_ERROR)level=ZOO_LOG_LEVEL_ERROR;
+    if(level>ZOO_LOG_LEVEL_DEBUG)level=ZOO_LOG_LEVEL_DEBUG;
     logLevel=level;
 }
 
diff --git a/src/c/src/zk_log.h b/src/c/src/zk_log.h
index efd45c5b3..e5917cbc6 100644
--- a/src/c/src/zk_log.h
+++ b/src/c/src/zk_log.h
@@ -28,14 +28,14 @@ extern "C" {
 extern ZOOAPI ZooLogLevel logLevel;
 #define LOGSTREAM getLogStream()
 
-#define LOG_ERROR(x) if(logLevel>=LOG_LEVEL_ERROR) \
-    log_message(LOG_LEVEL_ERROR,__LINE__,__func__,format_log_message x)
-#define LOG_WARN(x) if(logLevel>=LOG_LEVEL_WARN) \
-    log_message(LOG_LEVEL_WARN,__LINE__,__func__,format_log_message x)
-#define LOG_INFO(x) if(logLevel>=LOG_LEVEL_INFO) \
-    log_message(LOG_LEVEL_INFO,__LINE__,__func__,format_log_message x)
-#define LOG_DEBUG(x) if(logLevel==LOG_LEVEL_DEBUG) \
-    log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
+#define LOG_ERROR(x) if(logLevel>=ZOO_LOG_LEVEL_ERROR) \
+    log_message(ZOO_LOG_LEVEL_ERROR,__LINE__,__func__,format_log_message x)
+#define LOG_WARN(x) if(logLevel>=ZOO_LOG_LEVEL_WARN) \
+    log_message(ZOO_LOG_LEVEL_WARN,__LINE__,__func__,format_log_message x)
+#define LOG_INFO(x) if(logLevel>=ZOO_LOG_LEVEL_INFO) \
+    log_message(ZOO_LOG_LEVEL_INFO,__LINE__,__func__,format_log_message x)
+#define LOG_DEBUG(x) if(logLevel==ZOO_LOG_LEVEL_DEBUG) \
+    log_message(ZOO_LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
 
 ZOOAPI void log_message(ZooLogLevel curLevel, int line,const char* funcName,
     const char* message);
diff --git a/src/c/src/zookeeper.c b/src/c/src/zookeeper.c
index 378ade1e4..c0f10d391 100644
--- a/src/c/src/zookeeper.c
+++ b/src/c/src/zookeeper.c
@@ -49,77 +49,77 @@
 #include <stdarg.h>
 #include <limits.h>
 
-#define IF_DEBUG(x) if(logLevel==LOG_LEVEL_DEBUG) {x;}
+#define IF_DEBUG(x) if(logLevel==ZOO_LOG_LEVEL_DEBUG) {x;}
 
 const int ZOOKEEPER_WRITE = 1 << 0;
 const int ZOOKEEPER_READ = 1 << 1;
 
-const int EPHEMERAL = 1 << 0;
-const int SEQUENCE = 1 << 1;
+const int ZOO_EPHEMERAL = 1 << 0;
+const int ZOO_SEQUENCE = 1 << 1;
 
-const int EXPIRED_SESSION_STATE = EXPIRED_SESSION_STATE_DEF;
-const int AUTH_FAILED_STATE = AUTH_FAILED_STATE_DEF;
-const int CONNECTING_STATE = CONNECTING_STATE_DEF;
-const int ASSOCIATING_STATE = ASSOCIATING_STATE_DEF;
-const int CONNECTED_STATE = CONNECTED_STATE_DEF;
+const int ZOO_EXPIRED_SESSION_STATE = EXPIRED_SESSION_STATE_DEF;
+const int ZOO_AUTH_FAILED_STATE = AUTH_FAILED_STATE_DEF;
+const int ZOO_CONNECTING_STATE = CONNECTING_STATE_DEF;
+const int ZOO_ASSOCIATING_STATE = ASSOCIATING_STATE_DEF;
+const int ZOO_CONNECTED_STATE = CONNECTED_STATE_DEF;
 static __attribute__ ((unused)) const char* state2String(int state){
     switch(state){
     case 0:
-        return "CLOSED_STATE";
+        return "ZOO_CLOSED_STATE";
     case CONNECTING_STATE_DEF:
-        return "CONNECTING_STATE";
+        return "ZOO_CONNECTING_STATE";
     case ASSOCIATING_STATE_DEF:
-        return "ASSOCIATING_STATE";
+        return "ZOO_ASSOCIATING_STATE";
     case CONNECTED_STATE_DEF:
-        return "CONNECTED_STATE";
+        return "ZOO_CONNECTED_STATE";
     case EXPIRED_SESSION_STATE_DEF:
-        return "EXPIRED_SESSION_STATE";
+        return "ZOO_EXPIRED_SESSION_STATE";
     case AUTH_FAILED_STATE_DEF:
-        return "AUTH_FAILED_STATE";
+        return "ZOO_AUTH_FAILED_STATE";
     }
     return "INVALID_STATE";
 }
 
-const int CREATED_EVENT = CREATED_EVENT_DEF;
-const int DELETED_EVENT = DELETED_EVENT_DEF;
-const int CHANGED_EVENT = CHANGED_EVENT_DEF;
-const int CHILD_EVENT = CHILD_EVENT_DEF;
-const int SESSION_EVENT = SESSION_EVENT_DEF;
-const int NOTWATCHING_EVENT = NOTWATCHING_EVENT_DEF;
+const int ZOO_CREATED_EVENT = CREATED_EVENT_DEF;
+const int ZOO_DELETED_EVENT = DELETED_EVENT_DEF;
+const int ZOO_CHANGED_EVENT = CHANGED_EVENT_DEF;
+const int ZOO_CHILD_EVENT = CHILD_EVENT_DEF;
+const int ZOO_SESSION_EVENT = SESSION_EVENT_DEF;
+const int ZOO_NOTWATCHING_EVENT = NOTWATCHING_EVENT_DEF;
 static __attribute__ ((unused)) const char* watcherEvent2String(int ev){
     switch(ev){
     case 0:
-        return "ERROR_EVENT";
+        return "ZOO_ERROR_EVENT";
     case CREATED_EVENT_DEF:
-        return "CREATED_EVENT";
+        return "ZOO_CREATED_EVENT";
     case DELETED_EVENT_DEF:
-        return "DELETED_EVENT";
+        return "ZOO_DELETED_EVENT";
     case CHANGED_EVENT_DEF:
-        return "CHANGED_EVENT";
+        return "ZOO_CHANGED_EVENT";
     case CHILD_EVENT_DEF:
-        return "CHILD_EVENT";
+        return "ZOO_CHILD_EVENT";
     case SESSION_EVENT_DEF:
-        return "SESSION_EVENT";
+        return "ZOO_SESSION_EVENT";
     case NOTWATCHING_EVENT_DEF:
-        return "NOTWATCHING_EVENT";
+        return "ZOO_NOTWATCHING_EVENT";
     }
     return "INVALID_EVENT";
 }
 
-const int PERM_READ = 1 << 0;
-const int PERM_WRITE = 1 << 1;
-const int PERM_CREATE = 1 << 2;
-const int PERM_DELETE = 1 << 3;
-const int PERM_ADMIN = 1 << 4;
-const int PERM_ALL = 0x1f;
-struct Id ANYONE_ID_UNSAFE = {"world", "anyone"};
-struct Id AUTH_IDS = {"auth", ""};
+const int ZOO_PERM_READ = 1 << 0;
+const int ZOO_PERM_WRITE = 1 << 1;
+const int ZOO_PERM_CREATE = 1 << 2;
+const int ZOO_PERM_DELETE = 1 << 3;
+const int ZOO_PERM_ADMIN = 1 << 4;
+const int ZOO_PERM_ALL = 0x1f;
+struct Id ZOO_ANYONE_ID_UNSAFE = {"world", "anyone"};
+struct Id ZOO_AUTH_IDS = {"auth", ""};
 static struct ACL _OPEN_ACL_UNSAFE_ACL[] = {{0x1f, {"world", "anyone"}}};
 static struct ACL _READ_ACL_UNSAFE_ACL[] = {{0x01, {"world", "anyone"}}};
 static struct ACL _CREATOR_ALL_ACL_ACL[] = {{0x1f, {"auth", ""}}};
-struct ACL_vector OPEN_ACL_UNSAFE = { 1, _OPEN_ACL_UNSAFE_ACL};
-struct ACL_vector READ_ACL_UNSAFE = { 1, _READ_ACL_UNSAFE_ACL};
-struct ACL_vector CREATOR_ALL_ACL = { 1, _CREATOR_ALL_ACL_ACL};
+struct ACL_vector ZOO_OPEN_ACL_UNSAFE = { 1, _OPEN_ACL_UNSAFE_ACL};
+struct ACL_vector ZOO_READ_ACL_UNSAFE = { 1, _READ_ACL_UNSAFE_ACL};
+struct ACL_vector ZOO_CREATOR_ALL_ACL = { 1, _CREATOR_ALL_ACL_ACL};
 
 #define COMPLETION_VOID 0
 #define COMPLETION_STAT 1
@@ -723,12 +723,12 @@ static void handle_error(zhandle_t *zh,int rc)
 {
     close(zh->fd);
     if (is_unrecoverable(zh)) {
-        LOG_DEBUG(("Calling a watcher for a SESSION_EVENT and the state=%s",
+        LOG_DEBUG(("Calling a watcher for a ZOO_SESSION_EVENT and the state=%s",
                 state2String(zh->state)));
         PROCESS_SESSION_EVENT(zh, zh->state);
-    } else if (zh->state == CONNECTED_STATE) {
-        LOG_DEBUG(("Calling a watcher for a SESSION_EVENT and the state=CONNECTING_STATE"));
-        PROCESS_SESSION_EVENT(zh, CONNECTING_STATE);
+    } else if (zh->state == ZOO_CONNECTED_STATE) {
+        LOG_DEBUG(("Calling a watcher for a ZOO_SESSION_EVENT and the state=CONNECTING_STATE"));
+        PROCESS_SESSION_EVENT(zh, ZOO_CONNECTING_STATE);
     }
     cleanup_bufs(zh,1,rc);
     zh->fd = -1;
@@ -741,12 +741,12 @@ static void handle_error(zhandle_t *zh,int rc)
 static int handle_socket_error_msg(zhandle_t *zh, int line, int rc,
         const char* format, ...)
 {
-    if(logLevel>=LOG_LEVEL_ERROR){
+    if(logLevel>=ZOO_LOG_LEVEL_ERROR){
         va_list va;
         char buf[1024];
         va_start(va,format);
         vsnprintf(buf, sizeof(buf)-1,format,va);
-        log_message(LOG_LEVEL_ERROR,line,__func__,
+        log_message(ZOO_LOG_LEVEL_ERROR,line,__func__,
             format_log_message("Socket [%s] zk retcode=%d, errno=%d(%s): %s",
             format_current_endpoint_info(zh),rc,errno,strerror(errno),buf));
         va_end(va);
@@ -763,7 +763,7 @@ static void auth_completion_func(int rc, zhandle_t* zh)
     if(rc!=0){
         LOG_ERROR(("Authentication scheme %s failed. Connection closed.",
                 zh->auth.scheme));
-        zh->state=AUTH_FAILED_STATE;
+        zh->state=ZOO_AUTH_FAILED_STATE;
     }else{
         zh->auth.state=1;  // active
         LOG_INFO(("Authentication scheme %s succeeded", zh->auth.scheme));
@@ -879,7 +879,7 @@ static int prime_connection(zhandle_t *zh)
         return handle_socket_error_msg(zh, __LINE__, ZCONNECTIONLOSS,
                 "failed to send a handshake packet: %s", strerror(errno));
     }
-    zh->state = ASSOCIATING_STATE;
+    zh->state = ZOO_ASSOCIATING_STATE;
 
     zh->input_buffer = &zh->primer_buffer;
     /* This seems a bit weird to to set the offset to 4, but we already have a
@@ -967,7 +967,7 @@ static struct timeval get_timeval(int interval)
                     sizeof(struct sockaddr));
             if (rc == -1) {
                 if (errno == EWOULDBLOCK || errno == EINPROGRESS)
-                    zh->state = CONNECTING_STATE;
+                    zh->state = ZOO_CONNECTING_STATE;
                 else
                     return api_epilog(zh,handle_socket_error_msg(zh,__LINE__,
                             ZCONNECTIONLOSS,"connect() call failed"));
@@ -1002,7 +1002,7 @@ static struct timeval get_timeval(int interval)
         }
         // We only allow 1/3 of our timeout time to expire before sending
         // a PING
-        if (zh->state==CONNECTED_STATE) {
+        if (zh->state==ZOO_CONNECTED_STATE) {
             send_to = zh->recv_timeout/3 - idle_send;
             if (send_to <= 0) {
 //                LOG_DEBUG(("Sending PING to %s (exceeded idle by %dms)",
@@ -1024,7 +1024,7 @@ static struct timeval get_timeval(int interval)
             zh->next_deadline.tv_usec = zh->next_deadline.tv_usec % 1000000;
         }
         *interest = ZOOKEEPER_READ;
-        if (zh->to_send.head || zh->state == CONNECTING_STATE) {
+        if (zh->to_send.head || zh->state == ZOO_CONNECTING_STATE) {
             *interest |= ZOOKEEPER_WRITE;
         }
     }
@@ -1035,7 +1035,7 @@ static int check_events(zhandle_t *zh, int events)
 {
     if (zh->fd == -1)
         return ZINVALIDSTATE;
-    if ((events&ZOOKEEPER_WRITE)&&(zh->state == CONNECTING_STATE)) {
+    if ((events&ZOOKEEPER_WRITE)&&(zh->state == ZOO_CONNECTING_STATE)) {
         int rc, error;
         socklen_t len = sizeof(error);
         rc = getsockopt(zh->fd, SOL_SOCKET, SO_ERROR, &error, &len);
@@ -1082,7 +1082,7 @@ static int check_events(zhandle_t *zh, int events)
                 oldid = zh->client_id.client_id;
                 newid = zh->primer_storage.sessionId;
                 if (oldid != 0 && oldid != newid) {
-                    zh->state = EXPIRED_SESSION_STATE;
+                    zh->state = ZOO_EXPIRED_SESSION_STATE;
                     errno = ESTALE;
                     return handle_socket_error_msg(zh,__LINE__,ZSESSIONEXPIRED,
                             "session %llx has expired.",oldid);
@@ -1091,14 +1091,14 @@ static int check_events(zhandle_t *zh, int events)
                     zh->client_id.client_id = newid;
                  
                     memcpy(zh->client_id.passwd, &zh->primer_storage.passwd, sizeof(zh->client_id.passwd));
-                    zh->state = CONNECTED_STATE;
+                    zh->state = ZOO_CONNECTED_STATE;
                     LOG_INFO(("connected to server [%s] with session id=%llx",
                             format_endpoint_info(&zh->addrs[zh->connect_index]),newid));
                     /* send the authentication packet now */
                     send_auth_info(zh);
-                    LOG_DEBUG(("Calling a watcher for a SESSION_EVENT and the state=CONNECTED_STATE"));
+                    LOG_DEBUG(("Calling a watcher for a ZOO_SESSION_EVENT and the state=ZOO_CONNECTED_STATE"));
                     zh->input_buffer = 0; // just in case the watcher calls zookeeper_process() again
-                    PROCESS_SESSION_EVENT(zh, CONNECTED_STATE);
+                    PROCESS_SESSION_EVENT(zh, ZOO_CONNECTED_STATE);
                 }
             }
             zh->input_buffer = 0;
@@ -1127,7 +1127,7 @@ static __attribute__((unused)) void print_completion_queue(zhandle_t *zh)
 {
     completion_list_t* cptr;
     
-    if(logLevel<LOG_LEVEL_DEBUG) return;
+    if(logLevel<ZOO_LOG_LEVEL_DEBUG) return;
         
     fprintf(LOGSTREAM,"Completion queue: ");
     if (zh->sent_requests.head==0) {
@@ -1148,7 +1148,7 @@ static __attribute__((unused)) void print_completion_queue(zhandle_t *zh)
 int queue_session_event(zhandle_t *zh, int state)
 {
     int rc;
-    struct WatcherEvent evt = { SESSION_EVENT, state, "" };
+    struct WatcherEvent evt = { ZOO_SESSION_EVENT, state, "" };
     struct ReplyHeader hdr = { WATCHER_EVENT_XID, 0, 0 };
     struct oarchive *oa;
     completion_list_t *cptr;
@@ -1642,7 +1642,7 @@ int zookeeper_close(zhandle_t *zh)
         adaptor_finish(zh);
         return ZOK;
     }
-    if(zh->state==CONNECTED_STATE){
+    if(zh->state==ZOO_CONNECTED_STATE){
         struct oarchive *oa;
         struct RequestHeader h = { .xid = get_xid(), .type = CLOSE_OP};
         LOG_INFO(("Closing zookeeper session %llx to [%s]\n",
@@ -2007,7 +2007,7 @@ int flush_send_queue(zhandle_t*zh, int timeout)
     // we use a recursive lock instead and only dequeue the buffer if a send was
     // successful
     lock_buffer_list(&zh->to_send);
-    while (zh->to_send.head != 0&& zh->state == CONNECTED_STATE) {
+    while (zh->to_send.head != 0&& zh->state == ZOO_CONNECTED_STATE) {
         if(timeout!=0){
             int elapsed;
             struct pollfd fds;
@@ -2126,7 +2126,7 @@ int zoo_add_auth(zhandle_t *zh,const char* scheme,const char* cert,
     
     zh->auth.completion=completion;
     zh->auth.data=data;
-    if(zh->state == CONNECTED_STATE || zh->state == ASSOCIATING_STATE)
+    if(zh->state == ZOO_CONNECTED_STATE || zh->state == ZOO_ASSOCIATING_STATE)
         return send_auth_info(zh);
     
     return ZOK;
diff --git a/src/c/tests/TestOperations.cc b/src/c/tests/TestOperations.cc
index b7b1cf31f..606a90d12 100644
--- a/src/c/tests/TestOperations.cc
+++ b/src/c/tests/TestOperations.cc
@@ -292,7 +292,7 @@ public:
         timeMock.tick(tv);
         timeMock.tick(-1); // set the clock to a millisecond before a ping is due
         // trigger a watch now
-        zkServer.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/x/y/z"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHANGED_EVENT,"/x/y/z"));
         rc=zookeeper_process(zh,interest);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);
         // arrival of a watch sets the last_recv to the current time
@@ -351,7 +351,7 @@ public:
         // no response from the server yet -- waiting in the select() call
         now.tick(tv);
         // a watch has arrived, thus preventing the connection from timing out 
-        zkServer.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/x/y/z"));        
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHANGED_EVENT,"/x/y/z"));        
         rc=zookeeper_process(zh,interest);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc); // read the watch message
         CPPUNIT_ASSERT_EQUAL(0,zkServer.pingCount_); // not yet!
@@ -473,7 +473,7 @@ public:
                 ensureCondition(ClientConnected(zh),5000)<5000);
         
         char realpath[1024];
-        int rc=zoo_create(lzh,"/xyz","1",1,&OPEN_ACL_UNSAFE,0,realpath,sizeof(realpath)-1);
+        int rc=zoo_create(lzh,"/xyz","1",1,&ZOO_OPEN_ACL_UNSAFE,0,realpath,sizeof(realpath)-1);
         CPPUNIT_ASSERT(rc==ZOK || rc==ZNODEEXISTS);
         zookeeper_close(lzh); 
   
@@ -591,7 +591,7 @@ public:
         virtual void statCompl(int rc, const Stat *stat){
             // we received a server response, now enqueue a watcher event
             // to trigger the watcher
-            zkServer_.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/x/y/z"));
+            zkServer_.addRecvResponse(new ZNodeEvent(ZOO_CHANGED_EVENT,"/x/y/z"));
         }
         ZookeeperServer& zkServer_;
     };
diff --git a/src/c/tests/TestWatchers.cc b/src/c/tests/TestWatchers.cc
index ecf7e08a4..bc7e91fac 100644
--- a/src/c/tests/TestWatchers.cc
+++ b/src/c/tests/TestWatchers.cc
@@ -137,16 +137,16 @@ public:
         // open the socket
         int rc=zookeeper_interest(zh,&fd,&interest,&tv);        
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
-        CPPUNIT_ASSERT_EQUAL(CONNECTING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_CONNECTING_STATE,zoo_state(zh));
         // send the handshake packet to the server
         rc=zookeeper_process(zh,interest);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
-        CPPUNIT_ASSERT_EQUAL(ASSOCIATING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_ASSOCIATING_STATE,zoo_state(zh));
         // receive the server handshake response
         rc=zookeeper_process(zh,interest);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);
         // verify connected
-        CPPUNIT_ASSERT_EQUAL(CONNECTED_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_CONNECTED_STATE,zoo_state(zh));
         CPPUNIT_ASSERT(watcher.connected_);
         CPPUNIT_ASSERT_EQUAL(1,watcher.counter_);
     }
@@ -307,8 +307,8 @@ public:
         CPPUNIT_ASSERT_EQUAL(ZNOTHING,rc);
 
         // we are all set now; let's trigger the watches
-        zkServer.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/a/b/c"));
-        zkServer.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/x/y/z"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHANGED_EVENT,"/a/b/c"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHANGED_EVENT,"/x/y/z"));
         // make sure all watchers have been processed
         while((rc=zookeeper_process(zh,ZOOKEEPER_READ))==ZOK);
         CPPUNIT_ASSERT_EQUAL(ZNOTHING,rc);
@@ -355,7 +355,7 @@ public:
         CPPUNIT_ASSERT_EQUAL(ZNOTHING,rc);
 
         // we are all set now; let's trigger the watches
-        zkServer.addRecvResponse(new ZNodeEvent(DELETED_EVENT,"/a"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_DELETED_EVENT,"/a"));
         // make sure the watchers have been processed
         while((rc=zookeeper_process(zh,ZOOKEEPER_READ))==ZOK);
         CPPUNIT_ASSERT_EQUAL(ZNOTHING,rc);
@@ -365,7 +365,7 @@ public:
         CPPUNIT_ASSERT_EQUAL(0,defWatcher.counter_);
     }
 
-    // testcase: create both a child and data watch on the node /a, send a CHILD_EVENT
+    // testcase: create both a child and data watch on the node /a, send a ZOO_CHILD_EVENT
     // verify: only the child watch triggered
     void testChildWatcher2(){
         Mock_gettimeofday timeMock;
@@ -401,7 +401,7 @@ public:
         CPPUNIT_ASSERT_EQUAL(ZNOTHING,rc);
 
         // we are all set now; let's trigger the watches
-        zkServer.addRecvResponse(new ZNodeEvent(CHILD_EVENT,"/a"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHILD_EVENT,"/a"));
         // make sure the watchers have been processed
         while((rc=zookeeper_process(zh,ZOOKEEPER_READ))==ZOK);
         CPPUNIT_ASSERT_EQUAL(ZNOTHING,rc);
@@ -418,7 +418,7 @@ public:
         // zookeeper simulator
         ZookeeperServer zkServer;
         // detects when all watchers have been delivered
-        WatcherDeliveryTracker deliveryTracker(SESSION_EVENT,CONNECTED_STATE);
+        WatcherDeliveryTracker deliveryTracker(ZOO_SESSION_EVENT,ZOO_CONNECTED_STATE);
         Mock_poll pollMock(&zkServer,ZookeeperServer::FD);
         // must call zookeeper_close() while all the mocks are in the scope!
         CloseFinally guard(&zh);
@@ -449,7 +449,7 @@ public:
         CloseFinally guard(&zh);
         
         // detects when all watchers have been delivered
-        WatcherDeliveryTracker deliveryTracker(SESSION_EVENT,CONNECTING_STATE);
+        WatcherDeliveryTracker deliveryTracker(ZOO_SESSION_EVENT,ZOO_CONNECTING_STATE);
         DisconnectWatcher watcher;
         zh=zookeeper_init("localhost:2121",activeWatcher,10000,TEST_CLIENT_ID,
                 &watcher,0);
@@ -486,7 +486,7 @@ public:
         CloseFinally guard(&zh);
         
         // detects when all watchers have been delivered
-        WatcherDeliveryTracker deliveryTracker(SESSION_EVENT,CONNECTING_STATE);
+        WatcherDeliveryTracker deliveryTracker(ZOO_SESSION_EVENT,ZOO_CONNECTING_STATE);
         DisconnectWatcher defWatcher;
         // use the tracker to find out when the watcher has been activated
         WatcherActivationTracker activationTracker;
@@ -537,7 +537,7 @@ public:
         CloseFinally guard(&zh);
         
         // detects when all watchers have been delivered
-        WatcherDeliveryTracker deliveryTracker(SESSION_EVENT,CONNECTING_STATE);
+        WatcherDeliveryTracker deliveryTracker(ZOO_SESSION_EVENT,ZOO_CONNECTING_STATE);
         DisconnectWatcher defWatcher;
         // use the tracker to find out when the watcher has been activated
         WatcherActivationTracker activationTracker;
@@ -596,7 +596,7 @@ public:
         CloseFinally guard(&zh);
         
         // detects when all watchers have been delivered
-        WatcherDeliveryTracker deliveryTracker(CHANGED_EVENT,0,false);
+        WatcherDeliveryTracker deliveryTracker(ZOO_CHANGED_EVENT,0,false);
         CountingDataWatcher defWatcher;
         // use the tracker to find out when the watcher has been activated
         WatcherActivationTracker activationTracker;
@@ -631,8 +631,8 @@ public:
         CPPUNIT_ASSERT(ensureCondition(activationTracker.isWatcherActivated(),1000)<1000);
 
         // we are all set now; let's trigger the watches
-        zkServer.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/a/b/c"));
-        zkServer.addRecvResponse(new ZNodeEvent(CHANGED_EVENT,"/x/y/z"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHANGED_EVENT,"/a/b/c"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHANGED_EVENT,"/x/y/z"));
         // make sure all watchers have been processed
         CPPUNIT_ASSERT(ensureCondition(
                 deliveryTracker.deliveryCounterEquals(2),1000)<1000);
@@ -654,7 +654,7 @@ public:
         CloseFinally guard(&zh);
         
         // detects when all watchers have been delivered
-        WatcherDeliveryTracker deliveryTracker(DELETED_EVENT,0);
+        WatcherDeliveryTracker deliveryTracker(ZOO_DELETED_EVENT,0);
         DeletionCountingDataWatcher defWatcher;
         zh=zookeeper_init("localhost:2121",activeWatcher,10000,TEST_CLIENT_ID,
                 &defWatcher,0);
@@ -681,7 +681,7 @@ public:
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);
         
         // we are all set now; let's trigger the watches
-        zkServer.addRecvResponse(new ZNodeEvent(DELETED_EVENT,"/a"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_DELETED_EVENT,"/a"));
         // make sure the watchers have been processed
         CPPUNIT_ASSERT(ensureCondition(
                 deliveryTracker.isWatcherProcessingCompleted(),1000)<1000);
@@ -691,7 +691,7 @@ public:
         CPPUNIT_ASSERT_EQUAL(0,defWatcher.counter_);
     }
     
-    // testcase: create both a child and data watch on the node /a, send a CHILD_EVENT
+    // testcase: create both a child and data watch on the node /a, send a ZOO_CHILD_EVENT
     // verify: only the child watch triggered
     void testChildWatcher2(){
         Mock_gettimeofday timeMock;
@@ -702,7 +702,7 @@ public:
         CloseFinally guard(&zh);
         
         // detects when all watchers have been delivered
-        WatcherDeliveryTracker deliveryTracker(CHILD_EVENT,0);
+        WatcherDeliveryTracker deliveryTracker(ZOO_CHILD_EVENT,0);
         ChildEventCountingWatcher defWatcher;
         zh=zookeeper_init("localhost:2121",activeWatcher,10000,TEST_CLIENT_ID,
                 &defWatcher,0);
@@ -729,7 +729,7 @@ public:
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);
 
         // we are all set now; let's trigger the watches
-        zkServer.addRecvResponse(new ZNodeEvent(CHILD_EVENT,"/a"));
+        zkServer.addRecvResponse(new ZNodeEvent(ZOO_CHILD_EVENT,"/a"));
         // make sure the watchers have been processed
         CPPUNIT_ASSERT(ensureCondition(
                 deliveryTracker.isWatcherProcessingCompleted(),1000)<1000);
diff --git a/src/c/tests/TestZookeeperClose.cc b/src/c/tests/TestZookeeperClose.cc
index 8dfcd2708..2fa7a5396 100644
--- a/src/c/tests/TestZookeeperClose.cc
+++ b/src/c/tests/TestZookeeperClose.cc
@@ -96,7 +96,7 @@ public:
         CPPUNIT_ASSERT(zh!=0);
         // simulate connected state 
         zh->fd=ZookeeperServer::FD;
-        zh->state=CONNECTED_STATE;
+        zh->state=ZOO_CONNECTED_STATE;
         Mock_flush_send_queue zkMock;
         // do not actually free the memory while in zookeeper_close()
         Mock_free_noop freeMock;
@@ -134,18 +134,18 @@ public:
         int rc=zookeeper_interest(zh,&fd,&interest,&tv);
         
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
-        CPPUNIT_ASSERT_EQUAL(CONNECTING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_CONNECTING_STATE,zoo_state(zh));
         CPPUNIT_ASSERT_EQUAL(ZOOKEEPER_READ|ZOOKEEPER_WRITE,interest);
         
         rc=zookeeper_process(zh,interest);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
-        CPPUNIT_ASSERT_EQUAL(ASSOCIATING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_ASSOCIATING_STATE,zoo_state(zh));
         
         rc=zookeeper_interest(zh,&fd,&interest,&tv);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);
         rc=zookeeper_process(zh,interest);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
-        CPPUNIT_ASSERT_EQUAL(CONNECTED_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_CONNECTED_STATE,zoo_state(zh));
         // do not actually free the memory while in zookeeper_close()
         Mock_free_noop freeMock;
         // make a copy of zhandle before close() overwrites some of 
@@ -183,23 +183,23 @@ public:
         // initiate connection
         int rc=zookeeper_interest(zh,&fd,&interest,&tv);        
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
-        CPPUNIT_ASSERT_EQUAL(CONNECTING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_CONNECTING_STATE,zoo_state(zh));
         CPPUNIT_ASSERT_EQUAL(ZOOKEEPER_READ|ZOOKEEPER_WRITE,interest);
         rc=zookeeper_process(zh,interest);
         // make sure the handshake in progress 
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);        
-        CPPUNIT_ASSERT_EQUAL(ASSOCIATING_STATE,zoo_state(zh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_ASSOCIATING_STATE,zoo_state(zh));
         rc=zookeeper_interest(zh,&fd,&interest,&tv);
         CPPUNIT_ASSERT_EQUAL(ZOK,rc);
         
         // do not actually free the memory while in zookeeper_close()
         Mock_free_noop freeMock;
-        // should call the watcher with EXPIRED_SESSION_STATE state
+        // should call the watcher with ZOO_EXPIRED_SESSION_STATE state
         rc=zookeeper_process(zh,interest);
         zhandle_t* savezh=zh; zh=0;
         freeMock.disable(); // disable mock's fake free()- use libc's free() instead
         
-        CPPUNIT_ASSERT_EQUAL(EXPIRED_SESSION_STATE,zoo_state(savezh));
+        CPPUNIT_ASSERT_EQUAL(ZOO_EXPIRED_SESSION_STATE,zoo_state(savezh));
         // memory
         CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(savezh));
         CPPUNIT_ASSERT_EQUAL(1,freeMock.getFreeCount(closeAction.lzh.hostname));
diff --git a/src/c/tests/Util.h b/src/c/tests/Util.h
index 064b6eac5..f0d14ea33 100644
--- a/src/c/tests/Util.h
+++ b/src/c/tests/Util.h
@@ -37,7 +37,7 @@
 
 // must include "src/zk_log.h" to be able to use this macro
 #define TEST_TRACE(x) \
-    log_message(LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
+    log_message(ZOO_LOG_LEVEL_DEBUG,__LINE__,__func__,format_log_message x)
 
 extern const std::string EMPTY_STRING;
 
diff --git a/src/c/tests/ZKMocks.cc b/src/c/tests/ZKMocks.cc
index 124849dbd..d7ba05971 100644
--- a/src/c/tests/ZKMocks.cc
+++ b/src/c/tests/ZKMocks.cc
@@ -70,18 +70,18 @@ void activeWatcher(zhandle_t *zh, int type, int state, const char *path,void* ct
     if(zh==0 || ctx==0) return;
     WatcherAction* action=(WatcherAction*)ctx;
     
-    if(type==SESSION_EVENT){
-        if(state==EXPIRED_SESSION_STATE)
+    if(type==ZOO_SESSION_EVENT){
+        if(state==ZOO_EXPIRED_SESSION_STATE)
             action->onSessionExpired(zh);
-        else if(state==CONNECTING_STATE)
+        else if(state==ZOO_CONNECTING_STATE)
             action->onConnectionLost(zh);
-        else if(state==CONNECTED_STATE)
+        else if(state==ZOO_CONNECTED_STATE)
             action->onConnectionEstablished(zh);
-    }else if(type==CHANGED_EVENT)
+    }else if(type==ZOO_CHANGED_EVENT)
         action->onNodeValueChanged(zh,path);
-    else if(type==DELETED_EVENT)
+    else if(type==ZOO_DELETED_EVENT)
         action->onNodeDeleted(zh,path);
-    else if(type==CHILD_EVENT)
+    else if(type==ZOO_CHILD_EVENT)
         action->onChildChanged(zh,path);
     // TODO: implement for the rest of the event types
     // ...
@@ -498,7 +498,7 @@ void ZookeeperServer::notifyBufferSent(const std::string& buffer){
 
 void forceConnected(zhandle_t* zh){
     // simulate connected state
-    zh->state=CONNECTED_STATE;
+    zh->state=ZOO_CONNECTED_STATE;
     zh->fd=ZookeeperServer::FD;
     zh->input_buffer=0;
     gettimeofday(&zh->last_recv,0);    
diff --git a/src/c/tests/ZKMocks.h b/src/c/tests/ZKMocks.h
index 1cef9862b..a919c0b99 100644
--- a/src/c/tests/ZKMocks.h
+++ b/src/c/tests/ZKMocks.h
@@ -94,7 +94,7 @@ void asyncCompletion(int rc, const void *data);
 struct ClientConnected{
     ClientConnected(zhandle_t* zh):zh_(zh){}
     bool operator()() const{
-        return zoo_state(zh_)==CONNECTED_STATE;
+        return zoo_state(zh_)==ZOO_CONNECTED_STATE;
     }
     zhandle_t* zh_;
 };
@@ -102,7 +102,7 @@ struct ClientConnected{
 struct SessionExpired{
     SessionExpired(zhandle_t* zh):zh_(zh){}
     bool operator()() const{
-        return zoo_state(zh_)==EXPIRED_SESSION_STATE;
+        return zoo_state(zh_)==ZOO_EXPIRED_SESSION_STATE;
     }
     zhandle_t* zh_;
 };
diff --git a/src/contrib/zkfuse/configure.ac b/src/contrib/zkfuse/configure.ac
index 9513d2ef9..ae2996bc5 100644
--- a/src/contrib/zkfuse/configure.ac
+++ b/src/contrib/zkfuse/configure.ac
@@ -67,67 +67,4 @@ AC_CHECK_FUNCS([gettimeofday memset mkdir rmdir strdup strerror strstr strtol st
 AC_CONFIG_FILES([Makefile])
 AC_CONFIG_FILES([src/Makefile])
 AC_OUTPUT
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_PREREQ(2.59)
-
-AC_INIT([zkfuse], [2.2.0])
-AM_INIT_AUTOMAKE(foreign)
-
-AC_CONFIG_SRCDIR([src/zkadapter.h])
-AM_CONFIG_HEADER([config.h])
-
-PACKAGE=zkfuse
-VERSION=1.0
-
-AC_SUBST(PACKAGE)
-AC_SUBST(VERSION)
-
-BUILD_PATH="`pwd`"
-
-# Checks for programs.
-AC_LANG_CPLUSPLUS
-AC_PROG_CXX
-
-# Checks for libraries.
-AC_CHECK_LIB([fuse], [main])
-AC_CHECK_LIB([log4cxx], [main])
-AC_CHECK_LIB([thread], [thr_create])
-AC_CHECK_LIB([pthread], [pthread_create])
-AC_CHECK_LIB([rt], [clock_gettime])
-AC_CHECK_LIB([socket], [socket])
-AC_CHECK_LIB([nsl], [gethostbyname])
-AC_CHECK_LIB([ulockmgr], [ulockmgr_op])
-
-ZOOKEEPER_PATH=${BUILD_PATH}/../../c
-AC_CHECK_LIB(zookeeper_mt, main, [ZOOKEEPER_LD="-L${ZOOKEEPER_PATH}/.libs -lzookeeper_mt"],,["-L${ZOOKEEPER_PATH}/.libs"])
-
-AC_SUBST(ZOOKEEPER_PATH)
-AC_SUBST(ZOOKEEPER_LD)
-
-# Checks for header files.
-AC_HEADER_DIRENT
-AC_HEADER_STDC
-AC_CHECK_HEADERS([fcntl.h stdlib.h string.h sys/time.h unistd.h])
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_HEADER_STDBOOL
-AC_C_CONST
-AC_TYPE_UID_T
-AC_C_INLINE
-AC_TYPE_MODE_T
-AC_TYPE_OFF_T
-AC_TYPE_SIZE_T
-AC_CHECK_MEMBERS([struct stat.st_blksize])
-AC_STRUCT_ST_BLOCKS
-AC_HEADER_TIME
 AC_C_VOLATILE
-
-# Checks for library functions.
-AC_FUNC_UTIME_NULL
-AC_CHECK_FUNCS([gettimeofday memset mkdir rmdir strdup strerror strstr strtol strtoul strtoull utime])
-
-AC_CONFIG_FILES([Makefile])
-AC_CONFIG_FILES([src/Makefile])
-AC_OUTPUT
diff --git a/src/contrib/zkfuse/src/zkadapter.cc b/src/contrib/zkfuse/src/zkadapter.cc
index d98732242..c3c80766b 100644
--- a/src/contrib/zkfuse/src/zkadapter.cc
+++ b/src/contrib/zkfuse/src/zkadapter.cc
@@ -42,13 +42,13 @@ class InitZooKeeperLogging
 #endif
             ) 
         {
-            zoo_set_debug_level( LOG_LEVEL_DEBUG );
+            zoo_set_debug_level( ZOO_LOG_LEVEL_DEBUG );
         } else if (ZK_LOG->isInfoEnabled()) {
-            zoo_set_debug_level( LOG_LEVEL_INFO );
+            zoo_set_debug_level( ZOO_LOG_LEVEL_INFO );
         } else if (ZK_LOG->isWarnEnabled()) {
-            zoo_set_debug_level( LOG_LEVEL_WARN );
+            zoo_set_debug_level( ZOO_LOG_LEVEL_WARN );
         } else {
-            zoo_set_debug_level( LOG_LEVEL_ERROR );
+            zoo_set_debug_level( ZOO_LOG_LEVEL_ERROR );
         }
     }
 };
@@ -123,15 +123,16 @@ class RetryHandler
     
     
 //the implementation of the global ZK event watcher
-void zkWatcher(zhandle_t *zh, int type, int state, const char *path)
+void zkWatcher(zhandle_t *zh, int type, int state, const char *path,
+               void *watcherCtx)
 {
     TRACE( LOG, "zkWatcher" );
 
     //a workaround for buggy ZK API
     string sPath = 
         (path == NULL || 
-         state == SESSION_EVENT || 
-         state == NOTWATCHING_EVENT)
+         state == ZOO_SESSION_EVENT || 
+         state == ZOO_NOTWATCHING_EVENT)
         ? "" 
         : string(path);
     LOG_INFO( LOG,
@@ -280,10 +281,10 @@ ZooKeeperAdapter::handleEvent(int type, int state, const string &path)
                type, state, path.c_str() );
     Listener2Context context, context2;
     //ignore internal ZK events
-    if (type != SESSION_EVENT && type != NOTWATCHING_EVENT) {
+    if (type != ZOO_SESSION_EVENT && type != ZOO_NOTWATCHING_EVENT) {
         m_zkContextsMutex.Acquire();
         //check if the user context is available
-        if (type == CHANGED_EVENT || type == DELETED_EVENT) {
+        if (type == ZOO_CHANGED_EVENT || type == ZOO_DELETED_EVENT) {
             //we may have two types of interest here, 
             //in this case lets try to notify twice
             context = findAndRemoveListenerContext( GET_NODE_DATA, path );
@@ -294,9 +295,9 @@ ZooKeeperAdapter::handleEvent(int type, int state, const string &path)
                 context = context2;
                 context2.clear();
             }
-        } else if (type == CHILD_EVENT) {
+        } else if (type == ZOO_CHILD_EVENT) {
             context = findAndRemoveListenerContext( GET_NODE_CHILDREN, path );
-        } else if (type == CREATED_EVENT) {
+        } else if (type == ZOO_CREATED_EVENT) {
             context = findAndRemoveListenerContext( NODE_EXISTS, path );
         }
         m_zkContextsMutex.Release();
@@ -351,19 +352,19 @@ ZooKeeperAdapter::processEvents()
         bool timedOut = false;
         ZKWatcherEvent source = m_events.take( 100, &timedOut );
         if (!timedOut) {
-            if (source.getType() == SESSION_EVENT) {
+            if (source.getType() == ZOO_SESSION_EVENT) {
                 LOG_INFO( LOG,
                           "Received SESSION event, state: %d. Adapter state: %d",
                           source.getState(), m_state );
                 m_stateLock.lock();
-                if (source.getState() == CONNECTED_STATE) {
+                if (source.getState() == ZOO_CONNECTED_STATE) {
                     m_connected = true;
                     resetRemainingConnectTimeout();
                     setState( AS_CONNECTED );
-                } else if (source.getState() == CONNECTING_STATE) {
+                } else if (source.getState() == ZOO_CONNECTING_STATE) {
                     m_connected = false;
                     setState( AS_CONNECTING );
-                } else if (source.getState() == EXPIRED_SESSION_STATE) {
+                } else if (source.getState() == ZOO_EXPIRED_SESSION_STATE) {
                     LOG_INFO( LOG, "Received EXPIRED_SESSION event" );
                     setState( AS_SESSION_EXPIRED );
                 }
@@ -551,7 +552,7 @@ ZooKeeperAdapter::createNode(const string &path,
                          path.c_str(), 
                          value.c_str(),
                          value.length(),
-                         &OPEN_ACL_UNSAFE,
+                         &ZOO_OPEN_ACL_UNSAFE,
                          flags,
                          realPath,
                          MAX_PATH_LENGTH );
@@ -620,7 +621,7 @@ ZooKeeperAdapter::createSequence(const string &path,
     string createdPath;    
     bool result = createNode( path,
                               value,
-                              flags | SEQUENCE,
+                              flags | ZOO_SEQUENCE,
                               createAncestors,
                               createdPath );
     if (!result) {
diff --git a/src/contrib/zkfuse/src/zkadapter.h b/src/contrib/zkfuse/src/zkadapter.h
index a9bd7ce92..8d4d1d57f 100644
--- a/src/contrib/zkfuse/src/zkadapter.h
+++ b/src/contrib/zkfuse/src/zkadapter.h
@@ -221,16 +221,16 @@ class ZKWatcherEvent
     private:
         
         /**
-         * The type of this event. It can be either CREATED_EVENT, DELETED_EVENT,
-         * CHANGED_EVENT, CHILD_EVENT, SESSION_EVENT or NOTWATCHING_EVENT. 
+         * The type of this event. It can be either ZOO_CREATED_EVENT, ZOO_DELETED_EVENT,
+         * ZOO_CHANGED_EVENT, ZOO_CHILD_EVENT, ZOO_SESSION_EVENT or ZOO_NOTWATCHING_EVENT. 
          * See zookeeper.h for more details.
          */
         const int m_type;
         
         /**
          * The state of ZK at the time of sending this event.
-         * It can be either CONNECTING_STATE, ASSOCIATING_STATE, 
-         * CONNECTED_STATE, EXPIRED_SESSION_STATE or AUTH_FAILED_STATE.
+         * It can be either ZOO_CONNECTING_STATE, ZOO_ASSOCIATING_STATE, 
+         * ZOO_CONNECTED_STATE, ZOO_EXPIRED_SESSION_STATE or AUTH_FAILED_STATE.
          * See {@file zookeeper.h} for more details.
          */
         const int m_state;
@@ -268,7 +268,7 @@ class ZooKeeperAdapter
         /**
          * \brief The global function that handles all ZK asynchronous notifications.
          */
-        friend void zkWatcher(zhandle_t *, int, int, const char *);
+        friend void zkWatcher(zhandle_t *, int, int, const char *, void *watcherCtx);
         
         /**
          * \brief The type representing the user's context.
diff --git a/src/contrib/zkfuse/src/zkfuse.cc b/src/contrib/zkfuse/src/zkfuse.cc
index ecb134c73..fdef80717 100644
--- a/src/contrib/zkfuse/src/zkfuse.cc
+++ b/src/contrib/zkfuse/src/zkfuse.cc
@@ -2356,7 +2356,7 @@ class ZkFuseFile : boost::noncopyable
         /*
           IMPORTANT: 
           
-          Do not mark ZkFuseFile instance as deleted when a DELETED_EVENT 
+          Do not mark ZkFuseFile instance as deleted when a ZOO_DELETED_EVENT 
           is received without checking with ZooKeeper. An example of 
           problematic sequence would be:
 
@@ -2411,7 +2411,7 @@ class ZkFuseFile : boost::noncopyable
              * the data cache in-sync with ZooKeeper.
              */ 
             if (_initializedData && 
-                eventState == CONNECTED_STATE 
+                eventState == ZOO_CONNECTED_STATE 
                ) {
                 try {
                     LOG_DEBUG(LOG, "register data watcher");
@@ -2463,7 +2463,7 @@ class ZkFuseFile : boost::noncopyable
              * re-register children watch.
              */
             if (_initializedChildren && 
-                (_isZombie() || eventState != CONNECTED_STATE)) {
+                (_isZombie() || eventState != ZOO_CONNECTED_STATE)) {
                 LOG_DEBUG(LOG, "invalidate children");
                 _clearChildren();
             }
@@ -2494,7 +2494,7 @@ class ZkFuseFile : boost::noncopyable
              * keep the children information cache in-sync with ZooKeeper.
              */ 
             if (_initializedChildren && 
-                eventState == CONNECTED_STATE 
+                eventState == ZOO_CONNECTED_STATE 
                ) {
                 /* Should try to keep the cache in-sync, register call 
                  * callback again and get current children.
@@ -3118,9 +3118,9 @@ void ZkFuseHandleManager::eventReceived(const ZKWatcherEvent & event)
     LOG_DEBUG(LOG, "eventReceived() eventType %d, eventState %d, path %s",
               eventType, eventState, path.c_str());
 
-    if (eventType == DELETED_EVENT ||
-        eventType == CHANGED_EVENT ||
-        eventType == CHILD_EVENT) {
+    if (eventType == ZOO_DELETED_EVENT ||
+        eventType == ZOO_CHANGED_EVENT ||
+        eventType == ZOO_CHILD_EVENT) {
         {
             AutoLock lock(_mutex);
             Map::iterator it = _map.find(path);
@@ -3142,14 +3142,14 @@ void ZkFuseHandleManager::eventReceived(const ZKWatcherEvent & event)
                 {
                     /* _mutex is unlocked in this scope */
                     AutoUnlockTemp autoUnlockTemp(lock);
-                    if (eventType == CHILD_EVENT) {
+                    if (eventType == ZOO_CHILD_EVENT) {
                         file->childrenEventReceived(event);
                     }
-                    else if (eventType == CHANGED_EVENT) {
+                    else if (eventType == ZOO_CHANGED_EVENT) {
                         file->dataEventReceived(event);
                     }
                     else {
-                        assert(eventType == DELETED_EVENT);
+                        assert(eventType == ZOO_DELETED_EVENT);
                         file->dataEventReceived(event);
                         // file->childrenEventReceived(event);
                     }
@@ -3164,8 +3164,8 @@ void ZkFuseHandleManager::eventReceived(const ZKWatcherEvent & event)
             }
         }
     } 
-    else if (eventType == SESSION_EVENT) {
-        if (eventState == CONNECTING_STATE) {
+    else if (eventType == ZOO_SESSION_EVENT) {
+        if (eventState == ZOO_CONNECTING_STATE) {
             LOG_TRACE(LOG, "*** CONNECTING ***");
             {
                 AutoLock lock(_mutex);
@@ -3195,7 +3195,7 @@ void ZkFuseHandleManager::eventReceived(const ZKWatcherEvent & event)
                 }
             }
         }
-        else if (eventState == CONNECTED_STATE) {
+        else if (eventState == ZOO_CONNECTED_STATE) {
             LOG_TRACE(LOG, "*** CONNECTED ***");
         }
     }
