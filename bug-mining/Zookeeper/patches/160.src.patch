diff --git a/CHANGES.txt b/CHANGES.txt
index c0aeae3c4..7314574ef 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -84,6 +84,9 @@ BUGFIXES:
 
   ZOOKEEPER-542. c-client can spin when server unresponsive (Christian
   Wiedmann via mahadev)
+
+  ZOOKEEEPER-510. zkpython lumps all exceptions as IOError, needs specialized
+  exceptions for KeeperException types (henry & pat via mahadev)
  
 IMPROVEMENTS:
   ZOOKEEPER-473. cleanup junit tests to eliminate false positives due to
diff --git a/src/contrib/zkpython/build.xml b/src/contrib/zkpython/build.xml
index d534afff0..9f5edf353 100644
--- a/src/contrib/zkpython/build.xml
+++ b/src/contrib/zkpython/build.xml
@@ -22,7 +22,7 @@
   <property name="python.src.dir" value="src/python"/>
   <property name="test.build.dir" value="build/test/" />
   <property name="test.src.dir" value="src/test"/>
-  <property name="test.log.dir" value="${test.build.dir}/logs" />
+  <property name="test.log.dir" value="${build.test}/logs" />
   <property name="test.output" value="no" />
   <property name="test.timeout" value="900000" />
 
@@ -53,6 +53,7 @@
     <target name="python-test">
       <exec executable="${test.src.dir}/run_tests.sh" failonerror="true">
         <arg value="${test.src.dir}"/>
+        <arg value="${test.log.dir}"/>
       </exec>
     </target>
 
diff --git a/src/contrib/zkpython/src/c/zookeeper.c b/src/contrib/zkpython/src/c/zookeeper.c
index 5a545f799..1814dbdab 100644
--- a/src/contrib/zkpython/src/c/zookeeper.c
+++ b/src/contrib/zkpython/src/c/zookeeper.c
@@ -24,10 +24,91 @@
 static zhandle_t* zhandles[MAX_ZHANDLES];
 static int num_zhandles = 0;
 
-#define CHECK_ZHANDLE(z) if ( (z) < 0 || (z) >= num_zhandles ) { \
-  PyErr_SetString( PyExc_ValueError, "zhandle out of range" ); \
-  return NULL; \
-  }
+//////////////////////////////////////////////
+// EXCEPTIONS
+PyObject *ZooKeeperException = NULL;
+PyObject *SystemErrorException;
+PyObject *RuntimeInconsistencyException;
+PyObject *DataInconsistencyException;
+PyObject *ConnectionLossException;
+PyObject *MarshallingErrorException;
+PyObject *UnimplementedException;
+PyObject *OperationTimeoutException;
+PyObject *BadArgumentsException;
+PyObject *InvalidStateException;
+
+PyObject *ApiErrorException;
+PyObject *NoNodeException;
+PyObject *NoAuthException;
+PyObject *NodeExistsException;
+PyObject *BadVersionException;
+PyObject *NoChildrenForEphemeralsException;
+PyObject *NotEmptyException;
+PyObject *SessionExpiredException;
+PyObject *SessionMovedException;
+PyObject *InvalidCallbackException;
+PyObject *InvalidACLException;
+PyObject *AuthFailedException;
+PyObject *ClosingException;
+PyObject *NothingException;
+
+PyObject *err_to_exception(int errcode) {
+  switch (errcode) {
+    case ZSYSTEMERROR:
+      return SystemErrorException;
+    case ZRUNTIMEINCONSISTENCY:
+      return RuntimeInconsistencyException;
+    case ZDATAINCONSISTENCY:
+      return DataInconsistencyException;
+    case ZCONNECTIONLOSS:
+      return ConnectionLossException;
+    case ZMARSHALLINGERROR:
+      return MarshallingErrorException;
+    case ZUNIMPLEMENTED:
+      return UnimplementedException;
+    case ZOPERATIONTIMEOUT:
+      return OperationTimeoutException;
+    case ZBADARGUMENTS:
+      return BadArgumentsException;
+    case ZAPIERROR:
+      return ApiErrorException;
+    case ZNONODE:
+      return NoNodeException;
+    case ZNOAUTH:
+      return NoAuthException;
+    case ZBADVERSION:
+      return BadVersionException;
+    case ZNOCHILDRENFOREPHEMERALS:
+      return NoChildrenForEphemeralsException;
+    case ZNODEEXISTS:
+      return NodeExistsException;
+    case ZINVALIDACL:
+      return InvalidACLException;
+    case ZAUTHFAILED:
+      return AuthFailedException;
+    case ZNOTEMPTY:
+      return NotEmptyException;
+    case ZSESSIONEXPIRED:
+      return SessionExpiredException;
+    case ZINVALIDCALLBACK:
+      return InvalidCallbackException;
+    case ZSESSIONMOVED:
+      return SessionMovedException;
+      
+    case ZOK:
+    default:
+      return NULL;
+    }
+}
+
+
+#define CHECK_ZHANDLE(z) if ( (z) < 0 || (z) >= num_zhandles) {			\
+  PyErr_SetString( ZooKeeperException, "zhandle out of range" ); \	
+return NULL;																											\
+} else if ( zhandles[(z)] == NULL ) {															\
+		PyErr_SetString(ZooKeeperException, "zhandle already freed"); \
+		return NULL;																									\
+	}
 
 /////////////////////////////////////////////
 // HELPER FUNCTIONS
@@ -78,6 +159,9 @@ PyObject *build_stat( const struct Stat *stat )
 
 PyObject *build_string_vector(const struct String_vector *sv)
 {
+	if (!sv) {
+		return PyList_New(0);
+	}
   PyObject *ret = PyList_New(sv->count);
   int i;
   for (i=0;i<sv->count;++i) 
@@ -166,14 +250,13 @@ static PyObject *pyzookeeper_init(PyObject *self, PyObject *args)
   const char *passwd;
 
   if (num_zhandles >= MAX_ZHANDLES) {
-    PyErr_SetString( PyExc_ValueError, "Too many ZooKeeper handles created, max is 256" );
+    PyErr_SetString( ZooKeeperException, "Too many ZooKeeper handles created, max is 256" );
     return NULL;
   }
 
   if (!PyArg_ParseTuple(args, "s|Oi(Ls)", &host, &watcherfn, &recv_timeout, &cid.client_id, &passwd)) 
     return NULL;
   
-
   if (cid.client_id != -1) {
     strncpy(cid.passwd, passwd, 16*sizeof(char));
   }
@@ -189,7 +272,7 @@ static PyObject *pyzookeeper_init(PyObject *self, PyObject *args)
 
   if (zh == NULL)
     {
-      PyErr_SetString( PyExc_IOError, "Unknown error" );
+      PyErr_SetString( ZooKeeperException, "Unknown error" );
       return NULL;
     }
 
@@ -317,7 +400,7 @@ PyObject *pyzoo_acreate(PyObject *self, PyObject *args)
   free_acls(&acl);
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);;
@@ -341,7 +424,7 @@ PyObject *pyzoo_adelete(PyObject *self, PyObject *args)
     
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);
@@ -366,7 +449,7 @@ PyObject *pyzoo_aexists(PyObject *self, PyObject *args)
     
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);;
@@ -392,7 +475,7 @@ PyObject *pyzoo_aget(PyObject *self, PyObject *args)
     
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);
@@ -418,7 +501,7 @@ PyObject *pyzoo_aset(PyObject *self, PyObject *args)
     
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);
@@ -443,7 +526,7 @@ PyObject *pyzoo_aget_children(PyObject *self, PyObject *args)
 				create_pywatcher(zkhid, completion_callback,0) : NULL );    
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);;
@@ -465,7 +548,7 @@ PyObject *pyzoo_async(PyObject *self, PyObject *args)
 		       create_pywatcher(zkhid, completion_callback,0) : NULL );    
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);;
@@ -488,7 +571,7 @@ PyObject *pyzoo_aget_acl(PyObject *self, PyObject *args)
     
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);;
@@ -515,7 +598,7 @@ PyObject *pyzoo_aset_acl(PyObject *self, PyObject *args)
   free_acls(&aclv);
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);;
@@ -540,7 +623,7 @@ PyObject *pyzoo_add_auth(PyObject *self, PyObject *args)
 			  completion_callback != Py_None ? create_pywatcher(zkhid, completion_callback,0) : NULL );
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);
@@ -568,7 +651,7 @@ static PyObject *pyzoo_create(PyObject *self, PyObject *args)
   int err = zoo_create(zh, path, values, valuelen, &aclv, flags, realbuf, maxbuf_len);
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
 
@@ -587,12 +670,13 @@ static PyObject *pyzoo_delete(PyObject *self, PyObject *args)
   int err = zoo_delete(zh, path, version);
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err));
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);
 }
 
+// Returns None if the node does not exists
 static PyObject *pyzoo_exists(PyObject *self, PyObject *args)
 {
   int zkhid; char *path; PyObject *watcherfn = Py_None;
@@ -607,7 +691,7 @@ static PyObject *pyzoo_exists(PyObject *self, PyObject *args)
   int err = zoo_wexists(zh,  path, watcherfn != Py_None ? watcher_dispatch : NULL, pw, &stat);
   if (err != ZOK && err != ZNONODE)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err) );
+      PyErr_SetString(err_to_exception(err), zerror(err));
       free_pywatcher( pw );
       return NULL;
     }
@@ -632,13 +716,13 @@ static PyObject *pyzoo_get_children(PyObject *self, PyObject *args)
   pywatcher_t *pw = NULL;
   if (watcherfn != Py_None)
     pw = create_pywatcher( zkhid, watcherfn, 0 );
-  int err = zoo_wget_children( zhandles[zkhid], path, 
+  int err = zoo_wget_children(zhandles[zkhid], path, 
 			       watcherfn != Py_None ? watcher_dispatch : NULL, 
 			       pw, &strings );
 
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err) );
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
 
@@ -666,7 +750,7 @@ static PyObject *pyzoo_set(PyObject *self, PyObject *args)
   int err = zoo_set(zhandles[zkhid], path, buffer, buflen, version);
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err) );
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
 
@@ -687,7 +771,7 @@ static PyObject *pyzoo_set2(PyObject *self, PyObject *args)
   int err = zoo_set2(zhandles[zkhid], path, buffer, buflen, version, stat);
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err) );
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
 
@@ -716,7 +800,7 @@ static PyObject *pyzoo_get(PyObject *self, PyObject *args)
   PyObject *stat_dict = build_stat( &stat );
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err) );
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
 
@@ -735,7 +819,7 @@ PyObject *pyzoo_get_acl(PyObject *self, PyObject *args)
   int err = zoo_get_acl( zhandles[zkhid], path, &acl, &stat );
   if (err != ZOK) 
     { 
-      PyErr_SetString( PyExc_IOError, zerror(err) ); 
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL; 
     }
   PyObject *pystat = build_stat( &stat );
@@ -758,7 +842,7 @@ PyObject *pyzoo_set_acl(PyObject *self, PyObject *args)
   free_acls(&acl);
   if (err != ZOK)
     {
-      PyErr_SetString( PyExc_IOError, zerror(err) );
+      PyErr_SetString(err_to_exception(err), zerror(err));
       return NULL;
     }
   return Py_BuildValue("i", err);;
@@ -773,6 +857,7 @@ PyObject *pyzoo_close(PyObject *self, PyObject *args)
     return NULL;
   CHECK_ZHANDLE(zkhid);
   int ret = zookeeper_close(zhandles[zkhid]);
+	zhandles[zkhid] = NULL; // The zk C client frees the zhandle
   return Py_BuildValue("i", ret);
 }
 
@@ -959,9 +1044,23 @@ static PyMethodDef ZooKeeperMethods[] = {
 #define ADD_INTCONSTANT(x) PyModule_AddIntConstant(module, #x, ZOO_##x)
 #define ADD_INTCONSTANTZ(x) PyModule_AddIntConstant(module, #x, Z##x)
 
+
+
+#define ADD_EXCEPTION(x) x = PyErr_NewException("zookeeper."#x, ZooKeeperException, NULL); \
+  PyModule_AddObject(module, #x, x);
+
+
 PyMODINIT_FUNC initzookeeper() {
   PyEval_InitThreads();
   PyObject *module = Py_InitModule("zookeeper", ZooKeeperMethods );
+
+  ZooKeeperException = PyErr_NewException("zookeeper.ZooKeeperException",
+					  PyExc_Exception,
+					  NULL);
+
+  PyModule_AddObject(module, "ZooKeeperException", ZooKeeperException);
+  
+
   ADD_INTCONSTANT(PERM_READ);
   ADD_INTCONSTANT(PERM_WRITE);
   ADD_INTCONSTANT(PERM_CREATE);
@@ -1000,6 +1099,16 @@ PyMODINIT_FUNC initzookeeper() {
   ADD_INTCONSTANTZ(BADARGUMENTS);
   ADD_INTCONSTANTZ(INVALIDSTATE);
 
+  ADD_EXCEPTION(SystemErrorException);
+  ADD_EXCEPTION(RuntimeInconsistencyException);
+  ADD_EXCEPTION(DataInconsistencyException);
+  ADD_EXCEPTION(ConnectionLossException);
+  ADD_EXCEPTION(MarshallingErrorException);
+  ADD_EXCEPTION(UnimplementedException);
+  ADD_EXCEPTION(OperationTimeoutException);
+  ADD_EXCEPTION(BadArgumentsException);
+  ADD_EXCEPTION(InvalidStateException);  
+
   ADD_INTCONSTANTZ(OK);  
   ADD_INTCONSTANTZ(APIERROR);
   ADD_INTCONSTANTZ(NONODE);
@@ -1014,6 +1123,22 @@ PyMODINIT_FUNC initzookeeper() {
   ADD_INTCONSTANTZ(AUTHFAILED);
   ADD_INTCONSTANTZ(CLOSING);
   ADD_INTCONSTANTZ(NOTHING);
+  ADD_INTCONSTANTZ(SESSIONMOVED);
+
+  ADD_EXCEPTION(ApiErrorException);
+  ADD_EXCEPTION(NoNodeException);
+  ADD_EXCEPTION(NoAuthException);
+  ADD_EXCEPTION(BadVersionException);
+  ADD_EXCEPTION(NoChildrenForEphemeralsException);
+  ADD_EXCEPTION(NodeExistsException);
+  ADD_EXCEPTION(NotEmptyException);
+  ADD_EXCEPTION(SessionExpiredException);
+  ADD_EXCEPTION(InvalidCallbackException);
+  ADD_EXCEPTION(InvalidACLException);
+  ADD_EXCEPTION(AuthFailedException);
+  ADD_EXCEPTION(ClosingException);
+  ADD_EXCEPTION(NothingException);
+  ADD_EXCEPTION(SessionMovedException);
 }
 
 int main(int argc, char **argv)
diff --git a/src/contrib/zkpython/src/test/connection_test.py b/src/contrib/zkpython/src/test/connection_test.py
index 86412a6e3..71ee56aeb 100755
--- a/src/contrib/zkpython/src/test/connection_test.py
+++ b/src/contrib/zkpython/src/test/connection_test.py
@@ -24,14 +24,15 @@ class ConnectionTest(zktestbase.TestBase):
     """Test whether we can make a connection"""
     def setUp(self):
         pass
-    
+
     def testconnection(self):
-        print "testconnection"
         cv = threading.Condition()
         self.connected = False
         def connection_watcher(handle, type, state, path):
             cv.acquire()
             self.connected = True
+            self.assertEqual(zookeeper.CONNECTED_STATE, state)
+            self.handle = handle
             cv.notify()
             cv.release()
 
@@ -40,9 +41,22 @@ def connection_watcher(handle, type, state, path):
         cv.wait(15.0)
         cv.release()
         self.assertEqual(self.connected, True, "Connection timed out to " + self.host)
-        
+        self.assertEqual(zookeeper.CONNECTED_STATE, zookeeper.state(self.handle))
+
+        self.assertEqual(zookeeper.close(self.handle), zookeeper.OK)
+        # Trying to close the same handle twice is an error, and the C library will segfault on it
+        # so make sure this is caught at the Python module layer
+        self.assertRaises(zookeeper.ZooKeeperException,
+                          zookeeper.close,
+                          self.handle)
+
+        self.assertRaises(zookeeper.ZooKeeperException,
+                          zookeeper.get,
+                          self.handle,
+                          "/")
+
     def tearDown(self):
         pass
-        
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/src/contrib/zkpython/src/test/create_test.py b/src/contrib/zkpython/src/test/create_test.py
index a80f879ee..8ab80f956 100755
--- a/src/contrib/zkpython/src/test/create_test.py
+++ b/src/contrib/zkpython/src/test/create_test.py
@@ -18,10 +18,12 @@
 
 import zookeeper, zktestbase, unittest, threading
 
+ZOO_OPEN_ACL_UNSAFE = {"perms":0x1f, "scheme":"world", "id" :"anyone"}
+
 class CreationTest(zktestbase.TestBase):
     """Test whether we can create znodes"""
     # to do: startup and teardown via scripts?
-    def setUp( self ):
+    def setUp(self):
         zktestbase.TestBase.setUp(self)
         try:
             zookeeper.delete(self.handle, "/zk-python-createtest")
@@ -30,21 +32,59 @@ def setUp( self ):
             pass
 
     def test_sync_create(self):
-        ZOO_OPEN_ACL_UNSAFE = {"perms":0x1f, "scheme":"world", "id" :"anyone"}
         self.assertEqual(self.connected, True)
         ret = zookeeper.create(self.handle, "/zk-python-createtest", "nodecontents", [ZOO_OPEN_ACL_UNSAFE], zookeeper.EPHEMERAL)
         self.assertEqual(ret, "/zk-python-createtest")
-        
+        self.assertRaises(zookeeper.NoChildrenForEphemeralsException,
+                          zookeeper.create,
+                          self.handle,
+                          "/zk-python-createtest/invalid-child",
+                          "",
+                          [ZOO_OPEN_ACL_UNSAFE],
+                          zookeeper.EPHEMERAL)
+
+    def test_sync_create_existing(self):
+        self.assertEqual(self.connected, True)
+        ret = zookeeper.create(self.handle, "/zk-python-createtest-existing", "nodecontents", [ZOO_OPEN_ACL_UNSAFE], zookeeper.EPHEMERAL)
+        self.assertEqual(ret, "/zk-python-createtest-existing")
+
+        self.assertRaises(zookeeper.NodeExistsException,
+                          zookeeper.create,
+                          self.handle,
+                          "/zk-python-createtest-existing",
+                          "nodecontents",
+                          [ZOO_OPEN_ACL_UNSAFE],
+                          zookeeper.EPHEMERAL)
+
+
+    def test_exception_paths(self):
+        """
+        Make sure common exceptions due to API misuse are correctly propogated
+        """
+        self.assertRaises(zookeeper.BadArgumentsException,
+                          zookeeper.create,
+                          self.handle,
+                          "/zk-python-badargs-test",
+                          "",
+                          [ZOO_OPEN_ACL_UNSAFE],
+                          -1)
+        self.assertRaises(zookeeper.InvalidACLException,
+                          zookeeper.create,
+                          self.handle,
+                          "/zk-python-invalidacl-test",
+                          "",
+                          ZOO_OPEN_ACL_UNSAFE) # Error - not a list
+
+
     def test_async_create(self):
         self.cv = threading.Condition()
         def callback(handle, rc, value):
             self.cv.acquire()
-            self.callback_flag = True   
-            self.rc = rc         
+            self.callback_flag = True
+            self.rc = rc
             self.cv.notify()
             self.cv.release()
 
-        ZOO_OPEN_ACL_UNSAFE = {"perms":0x1f, "scheme":"world", "id" :"anyone"}
         self.assertEqual(self.connected, True, "Not connected!")
         self.cv.acquire()
 
@@ -59,6 +99,6 @@ def callback(handle, rc, value):
         self.assertEqual(self.callback_flag, True, "acreate timed out")
         self.assertEqual(self.rc, zookeeper.OK)
 
-        
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/src/contrib/zkpython/src/test/delete_test.py b/src/contrib/zkpython/src/test/delete_test.py
index 7bc531e4b..913b6a9a9 100755
--- a/src/contrib/zkpython/src/test/delete_test.py
+++ b/src/contrib/zkpython/src/test/delete_test.py
@@ -30,19 +30,25 @@ def test_sync_delete(self):
         self.assertEqual(ret, zookeeper.OK)
         children = zookeeper.get_children(self.handle, "/")
         self.assertEqual(False, "zk-python-deletetest" in children)
-    
+
+        # test exception
+        self.assertRaises(zookeeper.NoNodeException,
+                          zookeeper.delete,
+                          self.handle,
+                          "/zk-python-deletetest")
+
     def test_async_delete(self):
         ZOO_OPEN_ACL_UNSAFE = {"perms":0x1f, "scheme":"world", "id" :"anyone"}
         self.assertEqual(self.connected, True)
         ret = zookeeper.create(self.handle, "/zk-python-adeletetest", "nodecontents", [ZOO_OPEN_ACL_UNSAFE], zookeeper.EPHEMERAL)
         self.assertEqual(ret, "/zk-python-adeletetest")
-        
+
         self.cv = threading.Condition()
         self.callback_flag = False
         self.rc = -1
         def callback(handle, rc):
             self.cv.acquire()
-            self.callback_flag = True            
+            self.callback_flag = True
             self.cv.notify()
             self.rc = rc # don't assert this here, as if the assertion fails, the test will block
             self.cv.release()
@@ -57,6 +63,6 @@ def callback(handle, rc):
         self.assertEqual(self.callback_flag, True, "adelete timed out")
         self.assertEqual(self.rc, zookeeper.OK)
 
-        
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/src/contrib/zkpython/src/test/exists_test.py b/src/contrib/zkpython/src/test/exists_test.py
index 95e4a7144..ddc6ef368 100755
--- a/src/contrib/zkpython/src/test/exists_test.py
+++ b/src/contrib/zkpython/src/test/exists_test.py
@@ -32,19 +32,23 @@ def test_sync_exists(self):
         self.assertEqual(self.connected, True)
         ret = zookeeper.exists(self.handle, "/zk-python-existstest", None)
         self.assertNotEqual(ret, None, "/zk-python-existstest does not exist (possibly means creation failure)")
-        
+
+    def test_sync_nexists(self):
+        self.assertEqual(None, zookeeper.exists(self.handle, "/i-dont-exist", None))
+
+
     def test_async_exists(self):
         self.cv = threading.Condition()
         def callback(handle, rc, stat):
             self.cv.acquire()
-            self.callback_flag = True            
+            self.callback_flag = True
             self.cv.notify()
             self.cv.release()
             self.rc = rc
-            
+
         self.assertEqual(self.connected, True)
 
-        self.cv.acquire()        
+        self.cv.acquire()
         ret = zookeeper.aexists(self.handle, "/zk-python-aexiststest", None,
                                 callback )
         self.assertEqual(ret, zookeeper.OK)
diff --git a/src/contrib/zkpython/src/test/get_set_test.py b/src/contrib/zkpython/src/test/get_set_test.py
index e865bdf62..23b892c62 100755
--- a/src/contrib/zkpython/src/test/get_set_test.py
+++ b/src/contrib/zkpython/src/test/get_set_test.py
@@ -36,17 +36,23 @@ def test_sync_getset(self):
         ret = zookeeper.set(self.handle, "/zk-python-getsettest",
                             "off", stat["version"])
         (data,stat) = zookeeper.get(self.handle, "/zk-python-getsettest", None)
-        self.assertEqual(data, "off", "Data is not 'off' as expected: " + data)        
+        self.assertEqual(data, "off", "Data is not 'off' as expected: " + data)
+        self.assertRaises(zookeeper.BadVersionException,
+                          zookeeper.set,
+                          self.handle,
+                          "/zk-python-getsettest",
+                          "test",
+                          stat["version"]+1)
 
     def test_async_getset(self):
-        self.cv = threading.Condition()        
+        self.cv = threading.Condition()
         def get_callback(handle, rc, value, stat):
             self.cv.acquire()
             self.callback_flag = True
             self.rc = rc
             self.value = (value,stat)
             self.cv.notify()
-            self.cv.release()            
+            self.cv.release()
 
         def set_callback(handle, rc, stat):
             self.cv.acquire()
@@ -56,8 +62,8 @@ def set_callback(handle, rc, stat):
             self.cv.notify()
             self.cv.release()
 
-        self.assertEqual(self.connected, True, "Not connected!")            
-        
+        self.assertEqual(self.connected, True, "Not connected!")
+
         self.cv.acquire()
         self.callback_flag = False
         ret = zookeeper.aset(self.handle, "/zk-python-agetsettest", "off", -1, set_callback)
@@ -66,16 +72,42 @@ def set_callback(handle, rc, stat):
             self.cv.wait(15)
         self.cv.release()
         self.assertEqual(self.callback_flag, True, "aset timed out")
-        
+
         self.cv.acquire()
         self.callback_flag = False
-        ret = zookeeper.aget(self.handle, "/zk-python-agetsettest", None, get_callback)        
+        ret = zookeeper.aget(self.handle, "/zk-python-agetsettest", None, get_callback)
         self.assertEqual(ret, zookeeper.OK, "aget failed")
-        while not self.callback_flag:
-            self.cv.wait(15)
+        self.cv.wait(15)
         self.cv.release()
         self.assertEqual(self.callback_flag, True, "aget timed out")
         self.assertEqual(self.value[0], "off", "Data is not 'off' as expected: " + self.value[0])
-        
+
+    def test_sync_getchildren(self):
+        self.ensureCreated("/zk-python-getchildrentest", flags=0)
+        self.ensureCreated("/zk-python-getchildrentest/child")
+        children = zookeeper.get_children(self.handle, "/zk-python-getchildrentest")
+        self.assertEqual(len(children), 1, "Expected to find 1 child, got " + str(len(children)))
+
+    def test_async_getchildren(self):
+        self.ensureCreated("/zk-python-getchildrentest", flags=0)
+        self.ensureCreated("/zk-python-getchildrentest/child")
+
+        def gc_callback(handle, rc, children):
+            self.cv.acquire()
+            self.rc = rc
+            self.children = children
+            self.callback_flag = True
+            self.cv.notify()
+            self.cv.release()
+
+        self.cv.acquire()
+        self.callback_flag = False
+        zookeeper.aget_children(self.handle, "/zk-python-getchildrentest", None, gc_callback)
+        self.cv.wait(15)
+        self.assertEqual(self.callback_flag, True, "aget_children timed out")
+        self.assertEqual(self.rc, zookeeper.OK, "Return code for aget_children was not OK - %s" % zookeeper.zerror(self.rc))
+        self.assertEqual(len(self.children), 1, "Expected to find 1 child, got " + str(len(self.children)))
+
+
 if __name__ == '__main__':
     unittest.main()
diff --git a/src/contrib/zkpython/src/test/run_tests.sh b/src/contrib/zkpython/src/test/run_tests.sh
index 2da6e891f..18d924085 100755
--- a/src/contrib/zkpython/src/test/run_tests.sh
+++ b/src/contrib/zkpython/src/test/run_tests.sh
@@ -16,6 +16,19 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+# Usage: run_tests.sh testdir [logdir]
+# logdir is optional, defaults to cwd
+
+# get the number of command-line arguments given
+ARGC=$#
+
+# check to make sure enough arguments were given or exit
+if [ $ARGC -lt 2 ]; then
+    export ZKPY_LOG_DIR="."
+else
+    export ZKPY_LOG_DIR=$2
+fi
+
 # Find the build directory containing zookeeper.so
 SO_PATH=`find ../../../build/ -name "zookeeper.so" | head -1`
 PYTHONPATH=`dirname $SO_PATH`
diff --git a/src/contrib/zkpython/src/test/zktestbase.py b/src/contrib/zkpython/src/test/zktestbase.py
index 1b44cba43..54a69aef6 100755
--- a/src/contrib/zkpython/src/test/zktestbase.py
+++ b/src/contrib/zkpython/src/test/zktestbase.py
@@ -16,7 +16,9 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+import os
 import unittest, threading, zookeeper
+ZOO_OPEN_ACL_UNSAFE = {"perms":0x1f, "scheme":"world", "id" :"anyone"}
 
 class TestBase(unittest.TestCase):
     def __init__(self,methodName='runTest'):
@@ -24,13 +26,15 @@ def __init__(self,methodName='runTest'):
         self.host = "localhost:22182"
         self.connected = False
         self.handle = -1
+        logdir = os.environ.get("ZKPY_LOG_DIR")
+        logfile = os.path.join(logdir, self.__class__.__name__ + ".log")
         try:
-            f = open("build/test/logs/" + self.__class__.__name__ +".log","w")
+            f = open(logfile,"w")
             zookeeper.set_log_stream(f)
         except IOError:
-            print "Couldn't open build/test/logs/" + self.__class__.__name__ +".log for writing"
+            print "Couldn't open " + logfile + " for writing"
+
 
-    
     def setUp(self):
         self.callback_flag = False
         self.cv = threading.Condition()
@@ -48,12 +52,11 @@ def connection_watcher(handle, type, state, path):
 
         if not self.connected:
             raise Exception("Couldn't connect to host -", self.host)
-            
+
     def newConnection(self):
         cv = threading.Condition()
         self.pending_connection = False
         def connection_watcher(handle, type, state, path):
-            print "CONNECTION WATCHER"
             cv.acquire()
             self.pending_connection = True
             cv.notify()
@@ -67,9 +70,24 @@ def connection_watcher(handle, type, state, path):
         if not self.pending_connection:
             raise Exception("Couldn't connect to host -", self.host)
         return handle
-    
-        
+
+    def ensureDeleted(self,path):
+        self.assertEqual(zookeeper.STATE_CONNECTED, zookeeper.state(self.handle), "Not connected!")
+        try:
+            self.assertEqual(zookeeper.OK, zookeeper.delete(self.handle, path))
+        except zookeeper.NoNodeException:
+            pass
+
+    def ensureCreated(self,path,data="",flags=zookeeper.EPHEMERAL):
+        """
+        It's possible not to get the flags you want here if the node already exists
+        """
+        self.assertEqual(zookeeper.CONNECTED_STATE, zookeeper.state(self.handle), "Not connected!")
+        try:
+            self.assertEqual(path, zookeeper.create(self.handle, path, data, [ZOO_OPEN_ACL_UNSAFE], flags))
+        except zookeeper.NodeExistsException:
+            pass
+
     def tearDown(self):
         if self.connected:
             zookeeper.close(self.handle)
-    
