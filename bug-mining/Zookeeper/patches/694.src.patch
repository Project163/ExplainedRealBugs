diff --git a/CHANGES.txt b/CHANGES.txt
index fe3f7dc18..cfa59fa98 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -122,6 +122,9 @@ BUGFIXES:
   ZOOKEEPER-2204: LearnerSnapshotThrottlerTest.testHighContentionWithTimeout fails occasionally
   (Donny Nadolny via rgs)
 
+  ZOOKEEPER-2201: Network issues can cause cluster to hang due to near-deadlock
+  (Donny Nadolny via rgs)
+
 IMPROVEMENTS:
   ZOOKEEPER-1660 Documentation for Dynamic Reconfiguration (Reed Wanderman-Milne via shralex)  
 
diff --git a/src/java/main/org/apache/zookeeper/server/DataTree.java b/src/java/main/org/apache/zookeeper/server/DataTree.java
index 912045802..d82825815 100644
--- a/src/java/main/org/apache/zookeeper/server/DataTree.java
+++ b/src/java/main/org/apache/zookeeper/server/DataTree.java
@@ -1174,14 +1174,20 @@ void serializeNode(OutputArchive oa, StringBuilder path) throws IOException {
             return;
         }
         String children[] = null;
+        DataNode nodeCopy;
         synchronized (node) {
-            oa.writeString(pathString, "path");
-            oa.writeRecord(node, "node");
+            StatPersisted statCopy = new StatPersisted();
+            copyStatPersisted(node.stat, statCopy);
+            //we do not need to make a copy of node.data because the contents
+            //are never changed
+            nodeCopy = new DataNode(node.data, node.acl, statCopy);
             Set<String> childs = node.getChildren();
             if (childs != null) {
                 children = childs.toArray(new String[childs.size()]);
             }
         }
+        oa.writeString(pathString, "path");
+        oa.writeRecord(nodeCopy, "node");
         path.append('/');
         int off = path.length();
         if (children != null) {
diff --git a/src/java/test/org/apache/zookeeper/server/DataTreeTest.java b/src/java/test/org/apache/zookeeper/server/DataTreeTest.java
index ebc2fca0c..d7266437f 100644
--- a/src/java/test/org/apache/zookeeper/server/DataTreeTest.java
+++ b/src/java/test/org/apache/zookeeper/server/DataTreeTest.java
@@ -34,14 +34,19 @@
 import org.apache.zookeeper.server.DataNode;
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 
 import org.apache.zookeeper.Quotas;
 import org.apache.jute.BinaryInputArchive;
 import org.apache.jute.BinaryOutputArchive;
+import org.apache.jute.Record;
 import org.apache.zookeeper.common.PathTrie;
 import java.lang.reflect.*;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 public class DataTreeTest extends ZKTestCase {
@@ -145,18 +150,18 @@ public void testIncrementCversion() throws Exception {
                 newCversion + ", " + newPzxid + ">",
                 (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));
     }
-   
+
     @Test(timeout = 60000)
     public void testPathTrieClearOnDeserialize() throws Exception {
 
         //Create a DataTree with quota nodes so PathTrie get updated
         DataTree dserTree = new DataTree();
-        
+
         dserTree.createNode("/bug", new byte[20], null, -1, 1, 1, 1);
         dserTree.createNode(Quotas.quotaZookeeper+"/bug", null, null, -1, 1, 1, 1);
         dserTree.createNode(Quotas.quotaPath("/bug"), new byte[20], null, -1, 1, 1, 1);
         dserTree.createNode(Quotas.statPath("/bug"), new byte[20], null, -1, 1, 1, 1);
-        
+
         //deserialize a DataTree; this should clear the old /bug nodes and pathTrie
         DataTree tree = new DataTree();
 
@@ -176,4 +181,55 @@ public void testPathTrieClearOnDeserialize() throws Exception {
         //Check that the node path is removed from pTrie
         Assert.assertEquals("/bug is still in pTrie", "", pTrie.findMaxPrefix("/bug"));       
     }
+
+    /*
+     * ZOOKEEPER-2201 - OutputArchive.writeRecord can block for long periods of
+     * time, we must call it outside of the node lock.
+     * We call tree.serialize, which calls our modified writeRecord method that
+     * blocks until it can verify that a separate thread can lock the DataNode
+     * currently being written, i.e. that DataTree.serializeNode does not hold
+     * the DataNode lock while calling OutputArchive.writeRecord.
+     */
+    @Test(timeout = 60000)
+    public void testSerializeDoesntLockDataNodeWhileWriting() throws Exception {
+        DataTree tree = new DataTree();
+        tree.createNode("/marker", new byte[] {42}, null, -1, 1, 1, 1);
+        final DataNode markerNode = tree.getNode("/marker");
+        final AtomicBoolean ranTestCase = new AtomicBoolean();
+        DataOutputStream out = new DataOutputStream(new ByteArrayOutputStream());
+        BinaryOutputArchive oa = new BinaryOutputArchive(out) {
+            @Override
+            public void writeRecord(Record r, String tag) throws IOException {
+                DataNode node = (DataNode) r;
+                if (node.data.length == 1 && node.data[0] == 42) {
+                    final Semaphore semaphore = new Semaphore(0);
+                    new Thread(new Runnable() {
+                        @Override
+                        public void run() {
+                            synchronized (markerNode) {
+                                //When we lock markerNode, allow writeRecord to continue
+                                semaphore.release();
+                            }
+                        }
+                    }).start();
+
+                    try {
+                        boolean acquired = semaphore.tryAcquire(30, TimeUnit.SECONDS);
+                        //This is the real assertion - could another thread lock
+                        //the DataNode we're currently writing
+                        Assert.assertTrue("Couldn't acquire a lock on the DataNode while we were calling tree.serialize", acquired);
+                    } catch (InterruptedException e1) {
+                        throw new RuntimeException(e1);
+                    }
+                    ranTestCase.set(true);
+                }
+                super.writeRecord(r, tag);
+            }
+        };
+
+        tree.serialize(oa, "test");
+
+        //Let's make sure that we hit the code that ran the real assertion above
+        Assert.assertTrue("Didn't find the expected node", ranTestCase.get());
+    }
 }
