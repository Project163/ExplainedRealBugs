diff --git a/CHANGES.txt b/CHANGES.txt
index a1254a632..f91e1a179 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -288,6 +288,8 @@ BUGFIXES:
   ZOOKEEPER-121_4. SyncRequestProcessor is not closing log stream during
   shutdown (mahadev via breed)
 
+  ZOOKEEPER-586. c client does not compile under cygwin (phunt, mahadev, breed via breed)
+
 IMPROVEMENTS:
   ZOOKEEPER-473. cleanup junit tests to eliminate false positives due to
   "socket reuse" and failure to close client (phunt via mahadev)
diff --git a/src/c/src/zookeeper.c b/src/c/src/zookeeper.c
index 81cc6cc19..0bba0361f 100644
--- a/src/c/src/zookeeper.c
+++ b/src/c/src/zookeeper.c
@@ -15,7 +15,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
- 
+
 #ifndef DLL_EXPORT
 #  define USE_STATIC_LIB
 #endif
@@ -171,7 +171,7 @@ static const char* format_endpoint_info(const struct sockaddr_storage* ep);
 static const char* format_current_endpoint_info(zhandle_t* zh);
 
 /* completion routine forward declarations */
-static int add_completion(zhandle_t *zh, int xid, int completion_type, 
+static int add_completion(zhandle_t *zh, int xid, int completion_type,
         const void *dc, const void *data, int add_to_front,watcher_registration_t* wo);
 static completion_list_t* create_completion_entry(int xid, int completion_type,
         const void *dc, const void *data,watcher_registration_t* wo);
@@ -189,9 +189,8 @@ static __attribute__((unused)) void print_completion_queue(zhandle_t *zh);
 
 static void *SYNCHRONOUS_MARKER = (void*)&SYNCHRONOUS_MARKER;
 static int isValidPath(const char* path, const int flags);
-static int getaddrinfo_errno(int rc);
 
-const void *zoo_get_context(zhandle_t *zh) 
+const void *zoo_get_context(zhandle_t *zh)
 {
     return zh->context;
 }
@@ -208,7 +207,7 @@ int zoo_recv_timeout(zhandle_t *zh)
     return zh->recv_timeout;
 }
 
-/** these functions are thread unsafe, so make sure that 
+/** these functions are thread unsafe, so make sure that
     zoo_lock_auth is called before you access them **/
 static auth_info* get_last_auth(auth_list_head_t *auth_list) {
     auth_info *element;
@@ -240,7 +239,7 @@ static void free_auth_completion(auth_completion_list_t *a_list) {
     a_list->next = NULL;
     return;
 }
-        
+
 static void add_auth_completion(auth_completion_list_t* a_list, void_completion_t* completion,
                                 const char *data) {
     auth_completion_list_t *element;
@@ -279,11 +278,11 @@ static void get_auth_completions(auth_list_head_t *auth_list, auth_completion_li
     }
     return;
 }
-        
+
 static void add_last_auth(auth_list_head_t *auth_list, auth_info *add_el) {
     auth_info  *element;
     element = auth_list->auth;
-    if (element == NULL) { 
+    if (element == NULL) {
         //first element in the list
         auth_list->auth = add_el;
         return;
@@ -382,7 +381,7 @@ static void destroy(zhandle_t *zh)
         free(zh->chroot);
         zh->chroot = NULL;
     }
-    
+
     free_auth_info(&zh->auth_h);
     destroy_zk_hashtable(zh->active_node_watchers);
     destroy_zk_hashtable(zh->active_exist_watchers);
@@ -403,6 +402,7 @@ static void setup_random()
     srandom(seed);
 }
 
+#ifndef __CYGWIN__
 /**
  * get the errno from the return code 
  * of get addrinfo. Errno is not set
@@ -420,6 +420,7 @@ static int getaddrinfo_errno(int rc) {
         return EINVAL;
     }
 }
+#endif
 
 /**
  * fill in the addrs array of the zookeeper servers in the zhandle. after filling
@@ -427,15 +428,14 @@ static int getaddrinfo_errno(int rc) {
  */
 int getaddrs(zhandle_t *zh)
 {
-    struct addrinfo hints, *res, *res0;
-    struct sockaddr_storage *addr;
     char *hosts = strdup(zh->hostname);
     char *host;
     char *strtok_last;
+    struct sockaddr_storage *addr;
     int i;
     int rc;
     int alen = 0; /* the allocated length of the addrs array */
-    
+
     zh->addrs_count = 0;
     if (zh->addrs) {
         free(zh->addrs);
@@ -467,6 +467,65 @@ int getaddrs(zhandle_t *zh)
             rc=ZBADARGUMENTS;
             goto fail;
         }
+#if defined(__CYGWIN__)
+        // sadly CYGWIN doesn't have getaddrinfo
+        // but happily gethostbyname is threadsafe in windows
+        {
+        struct hostent *he;
+        char **ptr;
+        struct sockaddr_in *addr4;
+
+        he = gethostbyname(host);
+        if (!he) {
+            LOG_ERROR(("could not resolve %s", host));
+            errno=ENOENT;
+            rc=ZBADARGUMENTS;
+            goto fail;
+        }
+
+        /* Setup the address array */
+        for(ptr = he->h_addr_list;*ptr != 0; ptr++) {
+            if (zh->addrs_count == alen) {
+                alen += 16;
+                zh->addrs = realloc(zh->addrs, sizeof(*zh->addrs)*alen);
+                if (zh->addrs == 0) {
+                    LOG_ERROR(("out of memory"));
+                    errno=ENOMEM;
+                    rc=ZSYSTEMERROR;
+                    goto fail;
+                }
+            }
+            addr = &zh->addrs[zh->addrs_count];
+            addr4 = (struct sockaddr_in*)addr;
+            addr->ss_family = he->h_addrtype;
+            if (addr->ss_family == AF_INET) {
+                addr4->sin_port = htons(port);
+                memset(&addr4->sin_zero, 0, sizeof(addr4->sin_zero));
+                memcpy(&addr4->sin_addr, *ptr, he->h_length);
+                zh->addrs_count++;
+            }
+#if defined(AF_INET6)
+            else if (addr->ss_family == AF_INET6) {
+                struct sockaddr_in6 *addr6;
+
+                addr6 = (struct sockaddr_in6*)addr;
+                addr6->sin6_port = htons(port);
+                addr6->sin6_scope_id = 0;
+                addr6->sin6_flowinfo = 0;
+                memcpy(&addr6->sin6_addr, *ptr, he->h_length);
+                zh->addrs_count++;
+            }
+#endif
+            else {
+                LOG_WARN(("skipping unknown address family %x for %s",
+                         addr->ss_family, zh->hostname));
+            }
+        }
+        host = strtok_r(0, ",", &strtok_last);
+        }
+#else
+        {
+        struct addrinfo hints, *res, *res0;
 
         memset(&hints, 0, sizeof(hints));
 #ifdef AI_ADDRCONFIG
@@ -535,6 +594,8 @@ int getaddrs(zhandle_t *zh)
         freeaddrinfo(res0);
 
         host = strtok_r(0, ",", &strtok_last);
+        }
+#endif
     }
     free(hosts);
 
@@ -560,7 +621,7 @@ fail:
     if (hosts) {
         free(hosts);
     }
-    return rc;    
+    return rc;
 }
 
 const clientid_t *zoo_client_id(zhandle_t *zh)
@@ -682,7 +743,7 @@ zhandle_t *zookeeper_init(const char *host, watcher_fn watcher,
         errno=EINVAL;
         goto abort;
     }
-    //parse the host to get the chroot if 
+    //parse the host to get the chroot if
     //available
     index_chroot = strchr(host, '/');
     if (index_chroot) {
@@ -696,12 +757,12 @@ zhandle_t *zookeeper_init(const char *host, watcher_fn watcher,
         zh->hostname = strncpy(zh->hostname, host, (index_chroot - host));
         //strncpy does not null terminate
         *(zh->hostname + (index_chroot - host)) = '\0';
-        
+
     } else {
         zh->chroot = NULL;
         zh->hostname = strdup(host);
     }
-    if (zh->chroot && !isValidPath(zh->chroot, 0)) { 
+    if (zh->chroot && !isValidPath(zh->chroot, 0)) {
         errno = EINVAL;
         goto abort;
     }
@@ -723,15 +784,15 @@ zhandle_t *zookeeper_init(const char *host, watcher_fn watcher,
     zh->primer_buffer.next = 0;
     zh->last_zxid = 0;
     zh->next_deadline.tv_sec=zh->next_deadline.tv_usec=0;
-    zh->socket_readable.tv_sec=zh->socket_readable.tv_usec=0; 
+    zh->socket_readable.tv_sec=zh->socket_readable.tv_usec=0;
     zh->active_node_watchers=create_zk_hashtable();
     zh->active_exist_watchers=create_zk_hashtable();
     zh->active_child_watchers=create_zk_hashtable();
-    
+
     if (adaptor_init(zh) == -1) {
         goto abort;
     }
-    
+
     return zh;
 abort:
     errnosave=errno;
@@ -756,17 +817,17 @@ void free_duplicate_path(const char *free_path, const char* path) {
 */
 static char* prepend_string(zhandle_t *zh, const char* client_path) {
     char *ret_str;
-    if (zh->chroot == NULL) 
+    if (zh->chroot == NULL)
         return (char *) client_path;
     // handle the chroot itself, client_path = "/"
-    if (strlen(client_path) == 1) { 
+    if (strlen(client_path) == 1) {
         return strdup(zh->chroot);
-    } 
+    }
     ret_str = (char *) malloc(strlen(zh->chroot) + strlen(client_path) + 1);
     strcpy(ret_str, zh->chroot);
     return strcat(ret_str, client_path);
 }
-    
+
 /**
    strip off the chroot string from the server path
    if there is one else return the exact path
@@ -776,7 +837,7 @@ char* sub_string(zhandle_t *zh, const char* server_path) {
     if (zh->chroot == NULL)
         return (char *) server_path;
     if (strncmp(server_path, zh->chroot, strlen(zh->chroot) != 0)) {
-        LOG_ERROR(("server path %s does not include chroot path %s", 
+        LOG_ERROR(("server path %s does not include chroot path %s",
                    server_path, zh->chroot));
         return NULL;
     }
@@ -787,12 +848,12 @@ char* sub_string(zhandle_t *zh, const char* server_path) {
     }
     ret_str = strdup(server_path + strlen(zh->chroot));
     return ret_str;
-} 
+}
 
 static buffer_list_t *allocate_buffer(char *buff, int len)
 {
     buffer_list_t *buffer = calloc(1, sizeof(*buffer));
-    if (buffer == 0) 
+    if (buffer == 0)
         return 0;
 
     buffer->len = len==0?sizeof(*buffer):len;
@@ -892,7 +953,7 @@ static __attribute__ ((unused)) int get_queue_len(buffer_head_t *list)
     return i;
 }
 /* returns:
- * -1 if send failed, 
+ * -1 if send failed,
  * 0 if send would block while sending the buffer (or a send was incomplete),
  * 1 if success
  */
@@ -901,7 +962,7 @@ static int send_buffer(int fd, buffer_list_t *buff)
     int len = buff->len;
     int off = buff->curr_offset;
     int rc = -1;
-    
+
     if (off < 4) {
         /* we need to send the length at the beginning */
         int nlen = htonl(len);
@@ -934,7 +995,7 @@ static int send_buffer(int fd, buffer_list_t *buff)
 }
 
 /* returns:
- * -1 if recv call failed, 
+ * -1 if recv call failed,
  * 0 if recv would block,
  * 1 if success
  */
@@ -943,7 +1004,7 @@ static int recv_buffer(int fd, buffer_list_t *buff)
     int off = buff->curr_offset;
     int rc = 0;
     //fprintf(LOGSTREAM, "rc = %d, off = %d, line %d\n", rc, off, __LINE__);
-                
+
     /* if buffer is less than 4, we are reading in the length */
     if (off < 4) {
         char *buffer = (char*)&(buff->len);
@@ -969,7 +1030,7 @@ static int recv_buffer(int fd, buffer_list_t *buff)
     if (buff->buffer) {
         /* want off to now represent the offset into the buffer */
         off -= sizeof(buff->len);
-        
+
         rc = recv(fd, buff->buffer+off, buff->len-off, 0);
         switch(rc) {
         case 0:
@@ -992,14 +1053,14 @@ void free_buffers(buffer_head_t *list)
         ;
 }
 
-void free_completions(zhandle_t *zh,int callCompletion,int reason) 
+void free_completions(zhandle_t *zh,int callCompletion,int reason)
 {
     completion_head_t tmp_list;
     struct oarchive *oa;
     struct ReplyHeader h;
     void_completion_t auth_completion = NULL;
     auth_completion_list_t a_list, *a_tmp;
-    
+
     lock_completion_list(&zh->sent_requests);
     tmp_list = zh->sent_requests;
     zh->sent_requests.head = 0;
@@ -1007,7 +1068,7 @@ void free_completions(zhandle_t *zh,int callCompletion,int reason)
     unlock_completion_list(&zh->sent_requests);
     while (tmp_list.head) {
         completion_list_t *cptr = tmp_list.head;
-        
+
         tmp_list.head = cptr->next;
         if (cptr->c.data_result == SYNCHRONOUS_MARKER) {
             struct sync_completion
@@ -1020,7 +1081,7 @@ void free_completions(zhandle_t *zh,int callCompletion,int reason)
             if(cptr->xid == PING_XID){
                 // Nothing to do with a ping response
                 destroy_completion_entry(cptr);
-            } else { 
+            } else {
                 // Fake the response
                 buffer_list_t *bptr;
                 h.xid = cptr->xid;
@@ -1049,7 +1110,7 @@ void free_completions(zhandle_t *zh,int callCompletion,int reason)
         auth_completion = a_tmp->completion;
         auth_completion(reason, a_tmp->auth_data);
         a_tmp = a_tmp->next;
-        if (a_tmp == NULL) 
+        if (a_tmp == NULL)
             break;
     }
     free_auth_completion(&a_list);
@@ -1112,12 +1173,12 @@ static void auth_completion_func(int rc, zhandle_t* zh)
     void_completion_t auth_completion = NULL;
     auth_completion_list_t a_list;
     auth_completion_list_t *a_tmp;
-    
+
     if(zh==NULL)
         return;
 
     zoo_lock_auth(zh);
-    
+
     if(rc!=0){
         zh->state=ZOO_AUTH_FAILED_STATE;
     }else{
@@ -1141,7 +1202,7 @@ static void auth_completion_func(int rc, zhandle_t* zh)
         auth_completion = a_tmp->completion;
         auth_completion(rc, a_tmp->auth_data);
         a_tmp = a_tmp->next;
-        if (a_tmp == NULL) 
+        if (a_tmp == NULL)
             break;
     }
     free_auth_completion(&a_list);
@@ -1161,7 +1222,7 @@ static int send_info_packet(zhandle_t *zh, auth_info* auth) {
     /* add this buffer to the head of the send queue */
     rc = rc < 0 ? rc : queue_front_buffer_bytes(&zh->to_send, get_buffer(oa),
             get_buffer_len(oa));
-    /* We queued the buffer, so don't free it */   
+    /* We queued the buffer, so don't free it */
     close_buffer_oarchive(&oa, 0);
 
     return rc;
@@ -1215,16 +1276,16 @@ static void free_key_list(char **list, int count)
 }
 
 static int send_set_watches(zhandle_t *zh)
-{    
+{
     struct oarchive *oa;
     struct RequestHeader h = { .xid = SET_WATCHES_XID, .type = SETWATCHES_OP};
     struct SetWatches req;
     int rc;
 
     req.relativeZxid = zh->last_zxid;
-    req.dataWatches.data = collect_keys(zh->active_node_watchers, &req.dataWatches.count);
-    req.existWatches.data = collect_keys(zh->active_exist_watchers, &req.existWatches.count);
-    req.childWatches.data = collect_keys(zh->active_child_watchers, &req.childWatches.count);
+    req.dataWatches.data = collect_keys(zh->active_node_watchers, (int*)&req.dataWatches.count);
+    req.existWatches.data = collect_keys(zh->active_exist_watchers, (int*)&req.existWatches.count);
+    req.childWatches.data = collect_keys(zh->active_child_watchers, (int*)&req.childWatches.count);
 
     // return if there are no pending watches
     if (!req.dataWatches.count && !req.existWatches.count &&
@@ -1257,50 +1318,50 @@ static int serialize_prime_connect(struct connect_req *req, char* buffer){
     req->protocolVersion = htonl(req->protocolVersion);
     memcpy(buffer + offset, &req->protocolVersion, sizeof(req->protocolVersion));
     offset = offset +  sizeof(req->protocolVersion);
-    
+
     req->lastZxidSeen = htonll(req->lastZxidSeen);
     memcpy(buffer + offset, &req->lastZxidSeen, sizeof(req->lastZxidSeen));
     offset = offset +  sizeof(req->lastZxidSeen);
-    
+
     req->timeOut = htonl(req->timeOut);
     memcpy(buffer + offset, &req->timeOut, sizeof(req->timeOut));
     offset = offset +  sizeof(req->timeOut);
-    
+
     req->sessionId = htonll(req->sessionId);
     memcpy(buffer + offset, &req->sessionId, sizeof(req->sessionId));
     offset = offset +  sizeof(req->sessionId);
-    
+
     req->passwd_len = htonl(req->passwd_len);
     memcpy(buffer + offset, &req->passwd_len, sizeof(req->passwd_len));
     offset = offset +  sizeof(req->passwd_len);
-    
+
     memcpy(buffer + offset, req->passwd, sizeof(req->passwd));
-    
+
     return 0;
 }
 
  static int deserialize_prime_response(struct prime_struct *req, char* buffer){
-     //this should be the order of deserialization 
+     //this should be the order of deserialization
      int offset = 0;
      memcpy(&req->len, buffer + offset, sizeof(req->len));
      offset = offset +  sizeof(req->len);
-     
+
      req->len = ntohl(req->len);
      memcpy(&req->protocolVersion, buffer + offset, sizeof(req->protocolVersion));
      offset = offset +  sizeof(req->protocolVersion);
-     
+
      req->protocolVersion = ntohl(req->protocolVersion);
      memcpy(&req->timeOut, buffer + offset, sizeof(req->timeOut));
      offset = offset +  sizeof(req->timeOut);
-     
+
      req->timeOut = ntohl(req->timeOut);
      memcpy(&req->sessionId, buffer + offset, sizeof(req->sessionId));
      offset = offset +  sizeof(req->sessionId);
-     
+
      req->sessionId = htonll(req->sessionId);
      memcpy(&req->passwd_len, buffer + offset, sizeof(req->passwd_len));
      offset = offset +  sizeof(req->passwd_len);
-     
+
      req->passwd_len = ntohl(req->passwd_len);
      memcpy(req->passwd, buffer + offset, sizeof(req->passwd));
      return 0;
@@ -1310,7 +1371,7 @@ static int prime_connection(zhandle_t *zh)
 {
     int rc;
     /*this is the size of buffer to serialize req into*/
-    char buffer_req[HANDSHAKE_REQ_SIZE]; 
+    char buffer_req[HANDSHAKE_REQ_SIZE];
     int len = sizeof(buffer_req);
     int hlen = 0;
     struct connect_req req;
@@ -1340,7 +1401,7 @@ static int prime_connection(zhandle_t *zh)
     return ZOK;
 }
 
-static inline int calculate_interval(const struct timeval *start, 
+static inline int calculate_interval(const struct timeval *start,
         const struct timeval *end)
 {
     int interval;
@@ -1367,7 +1428,7 @@ static struct timeval get_timeval(int interval)
  static int add_string_completion(zhandle_t *zh, int xid,
      string_completion_t dc, const void *data);
 
- int send_ping(zhandle_t* zh) 
+ int send_ping(zhandle_t* zh)
  {
     int rc;
     struct oarchive *oa = create_buffer_oarchive();
@@ -1383,7 +1444,7 @@ static struct timeval get_timeval(int interval)
     close_buffer_oarchive(&oa, 0);
     return rc<0 ? rc : adaptor_send_queue(zh, 0);
 }
- 
+
  int zookeeper_interest(zhandle_t *zh, int *fd, int *interest,
      struct timeval *tv)
 {
@@ -1410,7 +1471,7 @@ static struct timeval get_timeval(int interval)
         }else {
             int rc;
             int on = 1;
-            
+
             zh->fd = socket(zh->addrs[zh->connect_index].ss_family, SOCK_STREAM, 0);
             if (zh->fd < 0) {
                 return api_epilog(zh,handle_socket_error_msg(zh,__LINE__,
@@ -1418,9 +1479,13 @@ static struct timeval get_timeval(int interval)
             }
             setsockopt(zh->fd, IPPROTO_TCP, TCP_NODELAY, &on, sizeof(int));
             fcntl(zh->fd, F_SETFL, O_NONBLOCK|fcntl(zh->fd, F_GETFL, 0));
+#if defined(AF_INET6)
             if (zh->addrs[zh->connect_index].ss_family == AF_INET6) {
                 rc = connect(zh->fd, (struct sockaddr*) &zh->addrs[zh->connect_index], sizeof(struct sockaddr_in6));
             } else {
+#else
+            {
+#endif
                 rc = connect(zh->fd, (struct sockaddr*) &zh->addrs[zh->connect_index], sizeof(struct sockaddr_in));
             }
             if (rc == -1) {
@@ -1436,7 +1501,7 @@ static struct timeval get_timeval(int interval)
                 if((rc=prime_connection(zh))!=0)
                     return api_epilog(zh,rc);
 
-                LOG_INFO(("Initiated connection to server [%s]", 
+                LOG_INFO(("Initiated connection to server [%s]",
                         format_endpoint_info(&zh->addrs[zh->connect_index])));
             }
         }
@@ -1454,7 +1519,7 @@ static struct timeval get_timeval(int interval)
         // have we exceeded the receive timeout threshold?
         if (recv_to <= 0) {
             // We gotta cut our losses and connect to someone else
-            errno = ETIMEDOUT;               
+            errno = ETIMEDOUT;
             *fd=-1;
             *interest=0;
             *tv = get_timeval(0);
@@ -1489,7 +1554,7 @@ static struct timeval get_timeval(int interval)
         /* we are interested in a write if we are connected and have something
          * to send, or we are waiting for a connect to finish. */
         if ((zh->to_send.head && (zh->state == ZOO_CONNECTED_STATE))
-	    || zh->state == ZOO_CONNECTING_STATE) {
+        || zh->state == ZOO_CONNECTING_STATE) {
             *interest |= ZOOKEEPER_WRITE;
         }
     }
@@ -1515,7 +1580,7 @@ static int check_events(zhandle_t *zh, int events)
         }
         if((rc=prime_connection(zh))!=0)
             return rc;
-        LOG_INFO(("initiated connection to server [%s]", 
+        LOG_INFO(("initiated connection to server [%s]",
                 format_endpoint_info(&zh->addrs[zh->connect_index])));
         return ZOK;
     }
@@ -1533,7 +1598,7 @@ static int check_events(zhandle_t *zh, int events)
         }
 
         rc = recv_buffer(zh->fd, zh->input_buffer);
-        if (rc < 0) { 
+        if (rc < 0) {
             return handle_socket_error_msg(zh, __LINE__,ZCONNECTIONLOSS,
                 "failed while receiving a server response");
         }
@@ -1576,7 +1641,7 @@ static int check_events(zhandle_t *zh, int events)
             }
             zh->input_buffer = 0;
         } else {
-            // zookeeper_process was called but there was nothing to read 
+            // zookeeper_process was called but there was nothing to read
             // from the socket
             return ZNOTHING;
         }
@@ -1586,7 +1651,7 @@ static int check_events(zhandle_t *zh, int events)
 
 void api_prolog(zhandle_t* zh)
 {
-    inc_ref_counter(zh,1); 
+    inc_ref_counter(zh,1);
 }
 
 int api_epilog(zhandle_t *zh,int rc)
@@ -1599,21 +1664,21 @@ int api_epilog(zhandle_t *zh,int rc)
 static __attribute__((unused)) void print_completion_queue(zhandle_t *zh)
 {
     completion_list_t* cptr;
-    
+
     if(logLevel<ZOO_LOG_LEVEL_DEBUG) return;
-        
+
     fprintf(LOGSTREAM,"Completion queue: ");
     if (zh->sent_requests.head==0) {
         fprintf(LOGSTREAM,"empty\n");
         return;
     }
-    
+
     cptr=zh->sent_requests.head;
     while(cptr){
         fprintf(LOGSTREAM,"%d,",cptr->xid);
         cptr=cptr->next;
     }
-    fprintf(LOGSTREAM,"end\n");    
+    fprintf(LOGSTREAM,"end\n");
 }
 
 //#ifdef THREADED
@@ -1625,7 +1690,7 @@ static int queue_session_event(zhandle_t *zh, int state)
     struct ReplyHeader hdr = { WATCHER_EVENT_XID, 0, 0 };
     struct oarchive *oa;
     completion_list_t *cptr;
-    
+
     if ((oa=create_buffer_oarchive())==NULL) {
         LOG_ERROR(("out of memory"));
         goto error;
@@ -1654,7 +1719,7 @@ static int queue_session_event(zhandle_t *zh, int state)
     return ZOK;
 error:
     errno=ENOMEM;
-    return ZSYSTEMERROR;    
+    return ZSYSTEMERROR;
 }
 //#endif
 
@@ -1793,7 +1858,7 @@ static void isSocketReadable(zhandle_t* zh)
         // socket not readable -- no more responses to process
         zh->socket_readable.tv_sec=zh->socket_readable.tv_usec=0;
     }else{
-        gettimeofday(&zh->socket_readable,0);        
+        gettimeofday(&zh->socket_readable,0);
     }
 }
 
@@ -1801,19 +1866,19 @@ static void checkResponseLatency(zhandle_t* zh)
 {
     int delay;
     struct timeval now;
-    
-    if(zh->socket_readable.tv_sec==0) 
+
+    if(zh->socket_readable.tv_sec==0)
         return;
-    
+
     gettimeofday(&now,0);
     delay=calculate_interval(&zh->socket_readable, &now);
     if(delay>20)
         LOG_DEBUG(("The following server response has spent at least %dms sitting in the client socket recv buffer",delay));
-    
+
     zh->socket_readable.tv_sec=zh->socket_readable.tv_usec=0;
 }
 
-int zookeeper_process(zhandle_t *zh, int events) 
+int zookeeper_process(zhandle_t *zh, int events)
 {
     buffer_list_t *bptr;
     int rc;
@@ -1829,7 +1894,7 @@ int zookeeper_process(zhandle_t *zh, int events)
         return api_epilog(zh, rc);
 
     IF_DEBUG(isSocketReadable(zh));
-    
+
     while (rc >= 0 && (bptr=dequeue_buffer(&zh->to_process))) {
         struct ReplyHeader hdr;
         struct iarchive *ia = create_buffer_iarchive(
@@ -1840,7 +1905,7 @@ int zookeeper_process(zhandle_t *zh, int events)
         } else {
             // fprintf(stderr, "Got %#x for %#x\n", hdr.zxid, hdr.xid);
         }
-        
+
         if (hdr.xid == WATCHER_EVENT_XID) {
             struct WatcherEvent evt;
             int type = 0;
@@ -1866,18 +1931,18 @@ int zookeeper_process(zhandle_t *zh, int events)
         } else if (hdr.xid == AUTH_XID){
             LOG_DEBUG(("Processing AUTH_XID"));
 
-            /* special handling for the AUTH response as it may come back 
+            /* special handling for the AUTH response as it may come back
              * out-of-band */
             auth_completion_func(hdr.err,zh);
             free_buffer(bptr);
-            /* authentication completion may change the connection state to 
+            /* authentication completion may change the connection state to
              * unrecoverable */
             if(is_unrecoverable(zh)){
                 handle_error(zh, ZAUTHFAILED);
                 close_buffer_iarchive(&ia);
                 return api_epilog(zh, ZAUTHFAILED);
             }
-        } else { 
+        } else {
             int rc = hdr.err;
             /* Find the request corresponding to the response */
             completion_list_t *cptr = dequeue_completion(&zh->sent_requests);
@@ -1889,7 +1954,7 @@ int zookeeper_process(zhandle_t *zh, int events)
                 // received unexpected (or out-of-order) response
                 close_buffer_iarchive(&ia);
                 free_buffer(bptr);
-                // put the completion back on the queue (so it gets properly 
+                // put the completion back on the queue (so it gets properly
                 // signaled and deallocated) and disconnect from the server
                 queue_completion(&zh->sent_requests,cptr,1);
                 return handle_socket_error_msg(zh, __LINE__,ZRUNTIMEINCONSISTENCY,
@@ -1910,7 +1975,7 @@ int zookeeper_process(zhandle_t *zh, int events)
                     // Nothing to do with a ping response
                     free_buffer(bptr);
                     destroy_completion_entry(cptr);
-                } else { 
+                } else {
                     LOG_DEBUG(("Queueing asynchronous response"));
 
                     cptr->buffer = bptr;
@@ -1934,8 +1999,8 @@ int zookeeper_process(zhandle_t *zh, int events)
                             len = sc->u.data.buff_len;
                         }
                         sc->u.data.buff_len = len;
-                        // check if len is negative 
-                        // just of NULL which is -1 int 
+                        // check if len is negative
+                        // just of NULL which is -1 int
                         if (len == -1) {
                             sc->u.data.buffer = NULL;
                         } else {
@@ -2059,7 +2124,7 @@ static void destroy_watcher_registration(watcher_registration_t* wo){
     }
 }
 
-static completion_list_t* create_completion_entry(int xid, int completion_type, 
+static completion_list_t* create_completion_entry(int xid, int completion_type,
         const void *dc, const void *data,watcher_registration_t* wo)
 {
     completion_list_t *c = calloc(1,sizeof(completion_list_t));
@@ -2138,7 +2203,7 @@ static int add_completion(zhandle_t *zh, int xid, int completion_type,
 {
     completion_list_t *c =create_completion_entry(xid, completion_type, dc,
             data,wo);
-    if (!c) 
+    if (!c)
         return ZSYSTEMERROR;
     queue_completion(&zh->sent_requests, c, add_to_front);
     if (dc == SYNCHRONOUS_MARKER) {
@@ -2193,8 +2258,8 @@ int zookeeper_close(zhandle_t *zh)
 {
     int rc=ZOK;
     if (zh==0)
-        return ZBADARGUMENTS; 
-    
+        return ZBADARGUMENTS;
+
     zh->close_requested=1;
     if (inc_ref_counter(zh,0)!=0) {
         adaptor_finish(zh);
@@ -2216,14 +2281,14 @@ int zookeeper_close(zhandle_t *zh)
             goto finish;
         }
 
-        /* make sure the close request is sent; we set timeout to an arbitrary 
+        /* make sure the close request is sent; we set timeout to an arbitrary
          * (but reasonable) number of milliseconds since we want the call to block*/
         rc=adaptor_send_queue(zh, 3000);
     }else{
         LOG_INFO(("Freeing zookeeper resources for sessionId=%#llx\n",
                 zh->client_id.client_id));
         rc = ZOK;
-    } 
+    }
 
 finish:
     destroy(zh);
@@ -2253,7 +2318,7 @@ static int isValidPath(const char* path, const int flags) {
   i = 1;
   for (; i < len; lastc = path[i], i++) {
     c = path[i];
-            
+
     if (c == 0) {
       return 0;
     } else if (c == '/' && lastc == '/') {
@@ -2282,16 +2347,16 @@ int zoo_aget(zhandle_t *zh, const char *path, int watch, data_completion_t dc,
     return zoo_awget(zh,path,watch?zh->watcher:0,zh->context,dc,data);
 }
 
-int zoo_awget(zhandle_t *zh, const char *path, 
-        watcher_fn watcher, void* watcherCtx, 
+int zoo_awget(zhandle_t *zh, const char *path,
+        watcher_fn watcher, void* watcherCtx,
         data_completion_t dc, const void *data)
 {
-    struct oarchive *oa; 
+    struct oarchive *oa;
     char *server_path = prepend_string(zh, path);
     struct RequestHeader h = { .xid = get_xid(), .type = GETDATA_OP};
     struct GetDataRequest req =  { (char*)server_path, watcher!=0 };
     int rc;
-            
+
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
         return ZBADARGUMENTS;
@@ -2312,7 +2377,7 @@ int zoo_awget(zhandle_t *zh, const char *path,
     free_duplicate_path(server_path, path);
     /* We queued the buffer, so don't free it */
     close_buffer_oarchive(&oa, 0);
-    
+
     LOG_DEBUG(("Sending request xid=%#x for path [%s] to %s",h.xid,path,
             format_current_endpoint_info(zh)));
     /* make a best (non-blocking) effort to send the requests asap */
@@ -2329,7 +2394,7 @@ int zoo_aset(zhandle_t *zh, const char *path, const char *buffer, int buflen,
     int rc;
     char *server_path;
     server_path = prepend_string(zh, path);
-    
+
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
         return ZBADARGUMENTS;
@@ -2370,7 +2435,7 @@ int zoo_acreate(zhandle_t *zh, const char *path, const char *value,
     struct CreateRequest req;
     int rc;
     char *server_path;
-    
+
     server_path = prepend_string(zh, path);
     if (zh==0 || !isValidPath(server_path, flags)) {
         free_duplicate_path(server_path, path);
@@ -2401,7 +2466,7 @@ int zoo_acreate(zhandle_t *zh, const char *path, const char *value,
     free_duplicate_path(server_path, path);
     /* We queued the buffer, so don't free it */
     close_buffer_oarchive(&oa, 0);
-    
+
     LOG_DEBUG(("Sending request xid=%#x for path [%s] to %s",h.xid,path,
             format_current_endpoint_info(zh)));
     /* make a best (non-blocking) effort to send the requests asap */
@@ -2417,7 +2482,7 @@ int zoo_adelete(zhandle_t *zh, const char *path, int version,
     struct DeleteRequest req;
     int rc;
     char *server_path;
-    
+
     server_path = prepend_string(zh, path);
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
@@ -2454,16 +2519,16 @@ int zoo_aexists(zhandle_t *zh, const char *path, int watch,
     return zoo_awexists(zh,path,watch?zh->watcher:0,zh->context,sc,data);
 }
 
-int zoo_awexists(zhandle_t *zh, const char *path, 
+int zoo_awexists(zhandle_t *zh, const char *path,
         watcher_fn watcher, void* watcherCtx,
         stat_completion_t completion, const void *data)
 {
     struct oarchive *oa;
     struct RequestHeader h = { .xid = get_xid(), .type = EXISTS_OP };
     char *server_path = prepend_string(zh, path);
-    struct ExistsRequest req  = {(char*)server_path, watcher!=0 }; 
+    struct ExistsRequest req  = {(char*)server_path, watcher!=0 };
     int rc;
-    
+
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
         return ZBADARGUMENTS;
@@ -2494,16 +2559,16 @@ int zoo_awexists(zhandle_t *zh, const char *path,
 }
 
 static int zoo_awget_children_(zhandle_t *zh, const char *path,
-         watcher_fn watcher, void* watcherCtx, 
+         watcher_fn watcher, void* watcherCtx,
          strings_completion_t sc,
          const void *data)
 {
     struct oarchive *oa;
     struct RequestHeader h = { .xid = get_xid(), .type = GETCHILDREN_OP};
     char * server_path = prepend_string(zh, path);
-    struct GetChildrenRequest req = {(char*)server_path, watcher!=0 }; 
+    struct GetChildrenRequest req = {(char*)server_path, watcher!=0 };
     int rc;
-        
+
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
         return ZBADARGUMENTS;
@@ -2539,7 +2604,7 @@ int zoo_aget_children(zhandle_t *zh, const char *path, int watch,
 }
 
 int zoo_awget_children(zhandle_t *zh, const char *path,
-         watcher_fn watcher, void* watcherCtx, 
+         watcher_fn watcher, void* watcherCtx,
          strings_completion_t dc,
          const void *data)
 {
@@ -2547,7 +2612,7 @@ int zoo_awget_children(zhandle_t *zh, const char *path,
 }
 
 static int zoo_awget_children2_(zhandle_t *zh, const char *path,
-         watcher_fn watcher, void* watcherCtx, 
+         watcher_fn watcher, void* watcherCtx,
          strings_stat_completion_t ssc,
          const void *data)
 {
@@ -2555,9 +2620,9 @@ static int zoo_awget_children2_(zhandle_t *zh, const char *path,
     struct oarchive *oa;
     struct RequestHeader h = { .xid = get_xid(), .type = GETCHILDREN2_OP};
     char * server_path = prepend_string(zh, path);
-    struct GetChildren2Request req2 = {(char*)server_path, watcher!=0 }; 
+    struct GetChildren2Request req2 = {(char*)server_path, watcher!=0 };
     int rc;
-        
+
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
         return ZBADARGUMENTS;
@@ -2593,7 +2658,7 @@ int zoo_aget_children2(zhandle_t *zh, const char *path, int watch,
 }
 
 int zoo_awget_children2(zhandle_t *zh, const char *path,
-         watcher_fn watcher, void* watcherCtx, 
+         watcher_fn watcher, void* watcherCtx,
          strings_stat_completion_t dc,
          const void *data)
 {
@@ -2608,7 +2673,7 @@ int zoo_async(zhandle_t *zh, const char *path,
     struct SyncRequest req;
     int rc;
     char *server_path;
-    
+
     server_path = prepend_string(zh, path);
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
@@ -2647,7 +2712,7 @@ int zoo_aget_acl(zhandle_t *zh, const char *path, acl_completion_t completion,
     struct GetACLRequest req;
     int rc;
     char *server_path;
-    
+
     server_path = prepend_string(zh, path);
     if (zh==0 || !isValidPath(server_path, 0)) {
         free_duplicate_path(server_path, path);
@@ -2724,7 +2789,7 @@ int flush_send_queue(zhandle_t*zh, int timeout)
     int rc= ZOK;
     struct timeval started;
     gettimeofday(&started,0);
-    // we can't use dequeue_buffer() here because if (non-blocking) send_buffer() 
+    // we can't use dequeue_buffer() here because if (non-blocking) send_buffer()
     // returns EWOULDBLOCK we'd have to put the buffer back on the queue.
     // we use a recursive lock instead and only dequeue the buffer if a send was
     // successful
@@ -2746,7 +2811,7 @@ int flush_send_queue(zhandle_t*zh, int timeout)
             rc = poll(&fds, 1, timeout-elapsed);
             if (rc<=0) {
                 /* timed out or an error or POLLERR */
-                rc = rc==0 ? ZOPERATIONTIMEOUT : ZSYSTEMERROR; 
+                rc = rc==0 ? ZOPERATIONTIMEOUT : ZSYSTEMERROR;
                 break;
             }
         }
@@ -2829,17 +2894,17 @@ const char* zerror(int c)
     return "unknown error";
 }
 
-int zoo_add_auth(zhandle_t *zh,const char* scheme,const char* cert, 
+int zoo_add_auth(zhandle_t *zh,const char* scheme,const char* cert,
         int certLen,void_completion_t completion, const void *data)
 {
     struct buffer auth;
     auth_info *authinfo;
     if(scheme==NULL || zh==NULL)
         return ZBADARGUMENTS;
-    
+
     if (is_unrecoverable(zh))
         return ZINVALIDSTATE;
-    
+
     if(cert!=NULL && certLen!=0){
         auth.buff=calloc(1,certLen);
         if(auth.buff==0) {
@@ -2861,10 +2926,10 @@ int zoo_add_auth(zhandle_t *zh,const char* scheme,const char* cert,
     authinfo->next = NULL;
     add_last_auth(&zh->auth_h, authinfo);
     zoo_unlock_auth(zh);
-    
+
     if(zh->state == ZOO_CONNECTED_STATE || zh->state == ZOO_ASSOCIATING_STATE)
         return send_last_auth_info(zh);
-    
+
     return ZOK;
 }
 
@@ -2964,7 +3029,7 @@ int zoo_wexists(zhandle_t *zh, const char *path,
         }
     }
     free_sync_completion(sc);
-    return rc;    
+    return rc;
 }
 
 int zoo_get(zhandle_t *zh, const char *path, int watch, char *buffer,
@@ -2974,8 +3039,8 @@ int zoo_get(zhandle_t *zh, const char *path, int watch, char *buffer,
             buffer,buffer_len,stat);
 }
 
-int zoo_wget(zhandle_t *zh, const char *path, 
-        watcher_fn watcher, void* watcherCtx, 
+int zoo_wget(zhandle_t *zh, const char *path,
+        watcher_fn watcher, void* watcherCtx,
         char *buffer, int* buffer_len, struct Stat *stat)
 {
     struct sync_completion *sc;
@@ -3028,7 +3093,7 @@ int zoo_set2(zhandle_t *zh, const char *path, const char *buffer, int buflen,
     return rc;
 }
 
-static int zoo_wget_children_(zhandle_t *zh, const char *path, 
+static int zoo_wget_children_(zhandle_t *zh, const char *path,
         watcher_fn watcher, void* watcherCtx,
         struct String_vector *strings)
 {
@@ -3053,7 +3118,7 @@ static int zoo_wget_children_(zhandle_t *zh, const char *path,
     return rc;
 }
 
-static int zoo_wget_children2_(zhandle_t *zh, const char *path, 
+static int zoo_wget_children2_(zhandle_t *zh, const char *path,
         watcher_fn watcher, void* watcherCtx,
         struct String_vector *strings, struct Stat *stat)
 {
@@ -3086,7 +3151,7 @@ int zoo_get_children(zhandle_t *zh, const char *path, int watch,
     return zoo_wget_children_(zh,path,watch?zh->watcher:0,zh->context,strings);
 }
 
-int zoo_wget_children(zhandle_t *zh, const char *path, 
+int zoo_wget_children(zhandle_t *zh, const char *path,
         watcher_fn watcher, void* watcherCtx,
         struct String_vector *strings)
 {
@@ -3099,7 +3164,7 @@ int zoo_get_children2(zhandle_t *zh, const char *path, int watch,
     return zoo_wget_children2_(zh,path,watch?zh->watcher:0,zh->context,strings,stat);
 }
 
-int zoo_wget_children2(zhandle_t *zh, const char *path, 
+int zoo_wget_children2(zhandle_t *zh, const char *path,
         watcher_fn watcher, void* watcherCtx,
         struct String_vector *strings, struct Stat *stat)
 {
diff --git a/src/c/tests/LibCSymTable.h b/src/c/tests/LibCSymTable.h
index 8c225a1a7..2f7e0c291 100644
--- a/src/c/tests/LibCSymTable.h
+++ b/src/c/tests/LibCSymTable.h
@@ -35,7 +35,11 @@
 
 // TODO: move all these macros to config.h (generated by autoconf) 
 #ifdef __CYGWIN__
+#if (CYGWIN_VERSION_DLL_MAJOR < 1007)
 #define RANDOM_RET_TYPE int
+#else
+#define RANDOM_RET_TYPE long int
+#endif
 #define GETTIMEOFDAY_ARG2_TYPE void*
 #else
 #define RANDOM_RET_TYPE long int
diff --git a/src/c/tests/TestClient.cc b/src/c/tests/TestClient.cc
index 047f67f97..9a82185c4 100644
--- a/src/c/tests/TestClient.cc
+++ b/src/c/tests/TestClient.cc
@@ -67,7 +67,7 @@ static int Stat_eq(struct Stat* a, struct Stat* b)
         int events;
         struct timeval tv;
         int rc;
-        time_t expires = time(0) + seconds; 
+        time_t expires = time(0) + seconds;
         time_t timeLeft = seconds;
         fd_set rfds, wfds, efds;
         FD_ZERO(&rfds);
@@ -172,7 +172,7 @@ public:
         }
         return !connected;
     }
-} watchctx_t; 
+} watchctx_t;
 
 class Zookeeper_simpleSystem : public CPPUNIT_NS::TestFixture
 {
@@ -252,7 +252,7 @@ public:
     {
         zoo_set_log_stream(logfile);
     }
-    
+
 
     void startServer() {
         char cmd[1024];
@@ -269,7 +269,7 @@ public:
     void tearDown()
     {
     }
-    
+
     void testPing()
     {
         watchctx_t ctxIdle;
@@ -317,11 +317,11 @@ public:
     }
 
 #define COUNT 100
-    
+
     static zhandle_t *async_zk;
     static volatile int count;
     static const char* hp_chroot;
-    
+
     static void statCompletion(int rc, const struct Stat *stat, const void *data) {
         int tmp = (int) (long) data;
         CPPUNIT_ASSERT_EQUAL(tmp, rc);
@@ -329,7 +329,7 @@ public:
 
     static void stringCompletion(int rc, const char *value, const void *data) {
         char *path = (char*)data;
-        
+
         if (rc == ZCONNECTIONLOSS && path) {
             // Try again
             rc = zoo_acreate(async_zk, path, "", 0,  &ZOO_OPEN_ACL_UNSAFE, 0, stringCompletion, 0);
@@ -340,12 +340,12 @@ public:
             free(path);
         }
     }
-    
+
     static void create_completion_fn(int rc, const char* value, const void *data) {
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         count++;
     }
-    
+
     static void waitForCreateCompletion(int seconds) {
         time_t expires = time(0) + seconds;
         while(count == 0 && time(0) < expires) {
@@ -361,7 +361,7 @@ public:
         CPPUNIT_ASSERT(strcmp(client_path, path) == 0);
         count ++;
     }
-    
+
     static void waitForChrootWatch(int seconds) {
         time_t expires = time(0) + seconds;
         while (count == 0 && time(0) < expires) {
@@ -377,34 +377,34 @@ public:
         }
         count--;
     }
-    
+
     static void voidCompletion(int rc, const void *data) {
         int tmp = (int) (long) data;
         CPPUNIT_ASSERT_EQUAL(tmp, rc);
         count++;
     }
-    
+
     static void verifyCreateFails(const char *path, zhandle_t *zk) {
       CPPUNIT_ASSERT_EQUAL((int)ZBADARGUMENTS, zoo_create(zk,
           path, "", 0, &ZOO_OPEN_ACL_UNSAFE, 0, 0, 0));
     }
-    
+
     static void verifyCreateOk(const char *path, zhandle_t *zk) {
       CPPUNIT_ASSERT_EQUAL((int)ZOK, zoo_create(zk,
           path, "", 0, &ZOO_OPEN_ACL_UNSAFE, 0, 0, 0));
     }
-    
+
     static void verifyCreateFailsSeq(const char *path, zhandle_t *zk) {
       CPPUNIT_ASSERT_EQUAL((int)ZBADARGUMENTS, zoo_create(zk,
           path, "", 0, &ZOO_OPEN_ACL_UNSAFE, ZOO_SEQUENCE, 0, 0));
     }
-    
+
     static void verifyCreateOkSeq(const char *path, zhandle_t *zk) {
       CPPUNIT_ASSERT_EQUAL((int)ZOK, zoo_create(zk,
           path, "", 0, &ZOO_OPEN_ACL_UNSAFE, ZOO_SEQUENCE, 0, 0));
     }
-    
-            
+
+
     /**
        returns false if the vectors dont match
     **/
@@ -434,7 +434,7 @@ public:
         struct Stat stat;
         watchctx_t ctx;
         zhandle_t *zk = createClient(&ctx);
-        rc = zoo_create(zk, "/acl", "", 0, 
+        rc = zoo_create(zk, "/acl", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, 0, 0);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
         rc = zoo_get_acl(zk, "/acl", &aclvec, &stat  );
@@ -459,18 +459,18 @@ public:
         struct ACL acl_val;
         rc = zoo_add_auth(0, "", 0, 0, voidCompletion, (void*)-1);
         CPPUNIT_ASSERT_EQUAL((int) ZBADARGUMENTS, rc);
-        
+
         rc = zoo_add_auth(zk, 0, 0, 0, voidCompletion, (void*)-1);
         CPPUNIT_ASSERT_EQUAL((int) ZBADARGUMENTS, rc);
-        
+
         // auth as pat, create /tauth1, close session
         rc = zoo_add_auth(zk, "digest", "pat:passwd", 10, voidCompletion,
                           (void*)ZOK);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         waitForVoidCompletion(3);
-                
+
         CPPUNIT_ASSERT(count == 0);
-        
+
         rc = zoo_create(zk, "/tauth1", "", 0, &ZOO_CREATOR_ALL_ACL, 0, 0, 0);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
 
@@ -496,7 +496,7 @@ public:
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         waitForVoidCompletion(3);
         CPPUNIT_ASSERT(count == 0);
-                
+
         char buf[1024];
         int blen = sizeof(buf);
         struct Stat stat;
@@ -505,7 +505,7 @@ public:
         // add auth pat w/correct pass verify success
         rc = zoo_add_auth(zk, "digest", "pat:passwd", 10, voidCompletion,
                           (void*)ZOK);
-        
+
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         rc = zoo_get(zk, "/tauth1", 0, buf, &blen, &stat);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
@@ -520,7 +520,7 @@ public:
         //make the server forget the auths
         waitForVoidCompletion(3);
         CPPUNIT_ASSERT(count == 0);
-     
+
         stopServer();
         CPPUNIT_ASSERT(ctx3.waitForDisconnected(zk));
         startServer();
@@ -532,7 +532,7 @@ public:
         rc = zoo_get_acl(zk, "/", &nodeAcl, &stat);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
         // check if the acl has all the perms
-        CPPUNIT_ASSERT_EQUAL((int)1, nodeAcl.count);
+        CPPUNIT_ASSERT_EQUAL((int)1, (int)nodeAcl.count);
         acl_val = *(nodeAcl.data);
         CPPUNIT_ASSERT_EQUAL((int) acl_val.perms, ZOO_PERM_ALL);
         // verify on root node
@@ -591,7 +591,7 @@ public:
         zhandle_t *zk = createClient(&ctx);
         CPPUNIT_ASSERT(zk);
         int rc = 0;
-        rc = zoo_create(zk, "/mahadev", NULL, -1, 
+        rc = zoo_create(zk, "/mahadev", NULL, -1,
                         &ZOO_OPEN_ACL_UNSAFE, 0, 0, 0);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         char buffer[512];
@@ -615,32 +615,32 @@ public:
         int rc = 0;
 
         memset(pathbuf, 'X', 20);
-        rc = zoo_create(zk, "/testpathpath0", "", 0, 
+        rc = zoo_create(zk, "/testpathpath0", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, 0);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         CPPUNIT_ASSERT_EQUAL('X', pathbuf[0]);
 
-        rc = zoo_create(zk, "/testpathpath1", "", 0, 
+        rc = zoo_create(zk, "/testpathpath1", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, 1);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         CPPUNIT_ASSERT(strlen(pathbuf) == 0);
 
-        rc = zoo_create(zk, "/testpathpath2", "", 0, 
+        rc = zoo_create(zk, "/testpathpath2", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, 2);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         CPPUNIT_ASSERT(strcmp(pathbuf, "/") == 0);
 
-        rc = zoo_create(zk, "/testpathpath3", "", 0, 
+        rc = zoo_create(zk, "/testpathpath3", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, 3);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         CPPUNIT_ASSERT(strcmp(pathbuf, "/t") == 0);
 
-        rc = zoo_create(zk, "/testpathpath7", "", 0, 
+        rc = zoo_create(zk, "/testpathpath7", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, 15);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         CPPUNIT_ASSERT(strcmp(pathbuf, "/testpathpath7") == 0);
 
-        rc = zoo_create(zk, "/testpathpath8", "", 0, 
+        rc = zoo_create(zk, "/testpathpath8", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, pathbuf, 16);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         CPPUNIT_ASSERT(strcmp(pathbuf, "/testpathpath8") == 0);
@@ -696,10 +696,10 @@ public:
         verifyCreateOk("/f/.f/f", zk);
         verifyCreateOk("/f/f./f", zk);
     }
-    
+
     void testChroot() {
-        // the c client async callbacks do 
-        // not callback with the path, so 
+        // the c client async callbacks do
+        // not callback with the path, so
         // we dont need to test taht for now
         // we should fix that though soon!
         watchctx_t ctx, ctx_ch;
@@ -708,7 +708,7 @@ public:
         int rc, len;
         struct Stat stat;
         const char* data = "garbage";
-        const char* retStr = "/chroot"; 
+        const char* retStr = "/chroot";
         const char* root= "/";
         zk_ch = createchClient(&ctx_ch, "127.0.0.1:22181/testch1/mahadev");
         CPPUNIT_ASSERT(zk_ch != NULL);
@@ -723,9 +723,9 @@ public:
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
         //check if the data is the same
         CPPUNIT_ASSERT(strncmp(buf, data, 7) == 0);
-        //check for watches 
+        //check for watches
         rc = zoo_wexists(zk_ch, "/chroot", watcher_chroot_fn, (void *) retStr, &stat);
-        //now check if we can do create/delete/get/sets/acls/getChildren and others 
+        //now check if we can do create/delete/get/sets/acls/getChildren and others
         //check create
         rc = zoo_create(zk_ch, "/chroot", "", 0, &ZOO_OPEN_ACL_UNSAFE, 0, 0,0);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
@@ -735,7 +735,7 @@ public:
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         rc = zoo_exists(zk, "/testch1/mahadev/chroot/child", 0, &stat);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
-        
+
         rc = zoo_delete(zk_ch, "/chroot/child", -1);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         rc = zoo_exists(zk, "/testch1/mahadev/chroot/child", 0, &stat);
@@ -751,15 +751,15 @@ public:
         struct String_vector children;
         rc = zoo_get_children(zk_ch, "/", 0, &children);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
-        CPPUNIT_ASSERT_EQUAL((int)1, children.count);
+        CPPUNIT_ASSERT_EQUAL((int)1, (int)children.count);
         //check if te child if chroot
         CPPUNIT_ASSERT(strcmp((retStr+1), children.data[0]) == 0);
         // check for get/set acl
         struct ACL_vector acl;
         rc = zoo_get_acl(zk_ch, "/", &acl, &stat);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
-        CPPUNIT_ASSERT_EQUAL((int)1, acl.count);
-        CPPUNIT_ASSERT_EQUAL(ZOO_PERM_ALL, acl.data->perms);
+        CPPUNIT_ASSERT_EQUAL((int)1, (int)acl.count);
+        CPPUNIT_ASSERT_EQUAL((int)ZOO_PERM_ALL, (int)acl.data->perms);
         // set acl
         rc = zoo_set_acl(zk_ch, "/chroot", -1,  &ZOO_READ_ACL_UNSAFE);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
@@ -769,14 +769,14 @@ public:
         //add wget children test
         rc = zoo_wget_children(zk_ch, "/", watcher_chroot_fn, (char*) root, &children);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
-        
+
         //now create a node
         rc = zoo_create(zk_ch, "/child2", "",0, &ZOO_OPEN_ACL_UNSAFE, 0, 0, 0);
         CPPUNIT_ASSERT_EQUAL((int) ZOK, rc);
         waitForChrootWatch(3);
         CPPUNIT_ASSERT(count == 0);
         //check for one async call just to make sure
-        rc = zoo_acreate(zk_ch, "/child3", "", 0, &ZOO_OPEN_ACL_UNSAFE, 0, 
+        rc = zoo_acreate(zk_ch, "/child3", "", 0, &ZOO_OPEN_ACL_UNSAFE, 0,
                          create_completion_fn, 0);
         waitForCreateCompletion(3);
         CPPUNIT_ASSERT(count == 0);
@@ -821,7 +821,7 @@ public:
             rc = zoo_acreate(zk, path, "", 0,  &ZOO_OPEN_ACL_UNSAFE, 0, stringCompletion, strdup(path));
             CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
         }
-        
+
         yield(zk, 1);
         stopServer();
         CPPUNIT_ASSERT(ctx.waitForDisconnected(zk));
@@ -837,7 +837,7 @@ public:
         }
     }
 
-    void testWatcherAutoReset(zhandle_t *zk, watchctx_t *ctxGlobal, 
+    void testWatcherAutoReset(zhandle_t *zk, watchctx_t *ctxGlobal,
                               watchctx_t *ctxLocal)
     {
         bool isGlobal = (ctxGlobal == ctxLocal);
@@ -848,7 +848,7 @@ public:
         struct String_vector strings;
         const char *testName;
 
-        rc = zoo_create(zk, "/watchtest", "", 0, 
+        rc = zoo_create(zk, "/watchtest", "", 0,
                         &ZOO_OPEN_ACL_UNSAFE, 0, 0, 0);
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
         rc = zoo_create(zk, "/watchtest/child", "", 0,
@@ -879,7 +879,7 @@ public:
                             &stat);
             CPPUNIT_ASSERT_EQUAL((int)ZNONODE, rc);
         }
-        
+
         CPPUNIT_ASSERT(ctxLocal->countEvents() == 0);
 
         stopServer();
@@ -904,7 +904,7 @@ public:
         CPPUNIT_ASSERT_EQUAL((int)ZOK, rc);
 
         CPPUNIT_ASSERT_MESSAGE(testName, waitForEvent(zk, ctxLocal, 5));
-        
+
         evt_t evt = ctxLocal->getEvent();
         CPPUNIT_ASSERT_EQUAL_MESSAGE(evt.path, ZOO_CHANGED_EVENT, evt.type);
         CPPUNIT_ASSERT_EQUAL(string("/watchtest/child"), evt.path);
@@ -924,7 +924,7 @@ public:
         sleep(5);
 
         CPPUNIT_ASSERT(ctxLocal->countEvents() == 0);
-        
+
         stopServer();
         CPPUNIT_ASSERT_MESSAGE(testName, ctxGlobal->waitForDisconnected(zk));
         startServer();
@@ -958,11 +958,11 @@ public:
         zoo_delete(zk, "/watchtest/child2", -1);
 
         CPPUNIT_ASSERT_MESSAGE(testName, waitForEvent(zk, ctxLocal, 5));
-        
+
         evt = ctxLocal->getEvent();
         CPPUNIT_ASSERT_EQUAL_MESSAGE(evt.path, ZOO_DELETED_EVENT, evt.type);
         CPPUNIT_ASSERT_EQUAL(string("/watchtest/child2"), evt.path);
-        
+
         CPPUNIT_ASSERT_MESSAGE(testName, waitForEvent(zk, ctxLocal, 5));
         evt = ctxLocal->getEvent();
         CPPUNIT_ASSERT_EQUAL_MESSAGE(evt.path, ZOO_CHILD_EVENT, evt.type);
@@ -977,7 +977,7 @@ public:
         zoo_delete(zk, "/watchtest", -1);
 
         CPPUNIT_ASSERT_MESSAGE(testName, waitForEvent(zk, ctxLocal, 5));
-        
+
         evt = ctxLocal->getEvent();
         CPPUNIT_ASSERT_EQUAL_MESSAGE(evt.path, ZOO_DELETED_EVENT, evt.type);
         CPPUNIT_ASSERT_EQUAL(string("/watchtest/child"), evt.path);
@@ -985,7 +985,7 @@ public:
         // Make sure nothing is straggling
         sleep(1);
         CPPUNIT_ASSERT(ctxLocal->countEvents() == 0);
-    }        
+    }
 
     void testWatcherAutoResetWithGlobal()
     {
diff --git a/src/c/tests/TestZookeeperInit.cc b/src/c/tests/TestZookeeperInit.cc
index 3ae780565..a9078ce1f 100644
--- a/src/c/tests/TestZookeeperInit.cc
+++ b/src/c/tests/TestZookeeperInit.cc
@@ -35,8 +35,8 @@ using namespace std;
 
 class Zookeeper_init : public CPPUNIT_NS::TestFixture
 {
-	CPPUNIT_TEST_SUITE(Zookeeper_init);
-	CPPUNIT_TEST(testBasic);
+    CPPUNIT_TEST_SUITE(Zookeeper_init);
+    CPPUNIT_TEST(testBasic);
     CPPUNIT_TEST(testAddressResolution);
     CPPUNIT_TEST(testMultipleAddressResolution);
     CPPUNIT_TEST(testNullAddressString);
@@ -48,14 +48,16 @@ class Zookeeper_init : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST(testNonexistentHost);
     CPPUNIT_TEST(testOutOfMemory_init);
     CPPUNIT_TEST(testOutOfMemory_getaddrs1);
+#if !defined(__CYGWIN__) // not valid for cygwin
     CPPUNIT_TEST(testOutOfMemory_getaddrs2);
+#endif
     CPPUNIT_TEST(testPermuteAddrsList);
-	CPPUNIT_TEST_SUITE_END();
+    CPPUNIT_TEST_SUITE_END();
     zhandle_t *zh;
-    MockPthreadsNull* pthreadMock;   
+    MockPthreadsNull* pthreadMock;
     static void watcher(zhandle_t *, int , int , const char *,void*){}
     FILE *logfile;
-public: 
+public:
     Zookeeper_init():zh(0),pthreadMock(0){
       logfile = openlogfile("Zookeeper_init");
     }
@@ -76,10 +78,10 @@ public:
 #ifdef THREADED
         // disable threading
         pthreadMock=new MockPthreadZKNull;
-#endif        
+#endif
         zh=0;
     }
-    
+
     void tearDown()
     {
         zookeeper_close(zh);
@@ -90,20 +92,20 @@ public:
 
     void testBasic()
     {
-    	const string EXPECTED_HOST("127.0.0.1:2121");
-    	const int EXPECTED_ADDRS_COUNT =1;
-    	const int EXPECTED_RECV_TIMEOUT=10000;
+        const string EXPECTED_HOST("127.0.0.1:2121");
+        const int EXPECTED_ADDRS_COUNT =1;
+        const int EXPECTED_RECV_TIMEOUT=10000;
         clientid_t cid;
-    	memset(&cid,0xFE,sizeof(cid));
-        
-    	zh=zookeeper_init(EXPECTED_HOST.c_str(),watcher,EXPECTED_RECV_TIMEOUT,
-    	        &cid,(void*)1,0);
-        
+        memset(&cid,0xFE,sizeof(cid));
+
+        zh=zookeeper_init(EXPECTED_HOST.c_str(),watcher,EXPECTED_RECV_TIMEOUT,
+                &cid,(void*)1,0);
+
         CPPUNIT_ASSERT(zh!=0);
-    	CPPUNIT_ASSERT(zh->fd == -1);
-    	CPPUNIT_ASSERT(zh->hostname!=0);
-    	CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDRS_COUNT,zh->addrs_count);
-    	CPPUNIT_ASSERT_EQUAL(EXPECTED_HOST,string(zh->hostname));
+        CPPUNIT_ASSERT(zh->fd == -1);
+        CPPUNIT_ASSERT(zh->hostname!=0);
+        CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDRS_COUNT,zh->addrs_count);
+        CPPUNIT_ASSERT_EQUAL(EXPECTED_HOST,string(zh->hostname));
         CPPUNIT_ASSERT(zh->state == 0);
         CPPUNIT_ASSERT(zh->context == (void*)1);
         CPPUNIT_ASSERT_EQUAL(EXPECTED_RECV_TIMEOUT,zh->recv_timeout);
@@ -138,7 +140,7 @@ public:
 
         zoo_deterministic_conn_order(1);
         zh=zookeeper_init("127.0.0.1:2121",0,10000,0,0,0);
-        
+
         CPPUNIT_ASSERT(zh!=0);
         CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDRS_COUNT,zh->addrs_count);
         for(int i=0;i<zh->addrs_count;i++){
@@ -233,9 +235,9 @@ public:
     void testNonexistentHost()
     {
         const string EXPECTED_HOST("host1.blabadibla.bla.:1111");
-        
+
         zh=zookeeper_init(EXPECTED_HOST.c_str(),0,0,0,0,0);
-        
+
         CPPUNIT_ASSERT(zh==0);
         //With the switch to thread safe getaddrinfo, we don't get
         //these global variables
@@ -246,9 +248,9 @@ public:
     {
         Mock_calloc mock;
         mock.callsBeforeFailure=0; // fail first calloc in init()
-        
+
         zh=zookeeper_init("ahost:123",watcher,10000,0,0,0);
-        
+
         CPPUNIT_ASSERT(zh==0);
         CPPUNIT_ASSERT_EQUAL(ENOMEM,errno);
     }
@@ -258,7 +260,7 @@ public:
         reallocMock.callsBeforeFailure=0; // fail on first call to realloc
 
         zh=zookeeper_init("127.0.0.1:123",0,0,0,0,0);
-        
+
         CPPUNIT_ASSERT(zh==0);
         CPPUNIT_ASSERT_EQUAL(ENOMEM,errno);
     }
@@ -268,7 +270,7 @@ public:
         reallocMock.callsBeforeFailure=1; // fail on the second call to realloc
 
         zh=zookeeper_init("127.0.0.1:123,127.0.0.2:123,127.0.0.3:123,127.0.0.4:123,127.0.0.5:123,127.0.0.6:123,127.0.0.7:123,127.0.0.8:123,127.0.0.9:123,127.0.0.10:123,127.0.0.11:123,127.0.0.12:123,127.0.0.13:123,127.0.0.14:123,127.0.0.15:123,127.0.0.16:123,127.0.0.17:123",0,0,0,0,0);
-        
+
         CPPUNIT_ASSERT(zh==0);
         CPPUNIT_ASSERT_EQUAL(ENOMEM,errno);
     }
@@ -276,13 +278,13 @@ public:
     {
         const char EXPECTED[][5]={"\0\0\0\0","\1\1\1\1","\2\2\2\2","\3\3\3\3"};
         const int EXPECTED_ADDR_COUNT=COUNTOF(EXPECTED);
-        
+
         const int RAND_SEQ[]={0,1,2,3,1,3,2,0,-1};
         const int RAND_SIZE=COUNTOF(RAND_SEQ);
         Mock_random randomMock;
         randomMock.randomReturns.assign(RAND_SEQ,RAND_SEQ+RAND_SIZE-1);
         zh=zookeeper_init("0.0.0.0:123,1.1.1.1:123,2.2.2.2:123,3.3.3.3:123",0,1000,0,0,0);
-        
+
         CPPUNIT_ASSERT(zh!=0);
         CPPUNIT_ASSERT_EQUAL(EXPECTED_ADDR_COUNT,zh->addrs_count);
         const string EXPECTED_SEQ("3210");
diff --git a/src/c/tests/zkServer.sh b/src/c/tests/zkServer.sh
index 6387d9a52..6ea3f0e21 100755
--- a/src/c/tests/zkServer.sh
+++ b/src/c/tests/zkServer.sh
@@ -18,36 +18,49 @@
 
 if [ "x$1" == "x" ]
 then
-	echo "USAGE: $0 startClean|start|stop hostPorts"
-	exit 2
+    echo "USAGE: $0 startClean|start|stop hostPorts"
+    exit 2
 fi
 
+case "`uname`" in
+    CYGWIN*) cygwin=true ;;
+    *) cygwin=false ;;
+esac
+
 if [ "x$1" == "xstartClean" ]
 then
-    if [ "x${base_dir}" == "x" ]	
+    if [ "x${base_dir}" == "x" ]
     then
     rm -rf /tmp/zkdata
     else
-    rm -rf ${base_dir}/build/tmp
+    rm -rf "${base_dir}/build/tmp"
     fi
 fi
 
+if $cygwin
+then
+    # cygwin has a "kill" in the shell itself, gets confused
+    KILL=/bin/kill
+else
+    KILL=kill
+fi
+
 # Make sure nothing is left over from before
 if [ -r "/tmp/zk.pid" ]
 then
 pid=`cat /tmp/zk.pid`
-kill -9 $pid
+$KILL -9 $pid
 rm -f /tmp/zk.pid
 fi
 
 if [ -r "${base_dir}/build/tmp/zk.pid" ]
 then
-pid=`cat ${base_dir}/build/tmp/zk.pid`
-kill -9 $pid
-rm -f ${base_dir}/build/tmp/zk.pid
+pid=`cat "${base_dir}/build/tmp/zk.pid"`
+$KILL -9 $pid
+rm -f "${base_dir}/build/tmp/zk.pid"
 fi
 
-if [ "x${base_dir}" == "x" ]	
+if [ "x${base_dir}" == "x" ]
 then
 zk_base="../../"
 else
@@ -69,26 +82,64 @@ done
 
 CLASSPATH="$CLASSPATH:${CLOVER_HOME}/lib/clover.jar"
 
+if $cygwin
+then
+    CLASSPATH=`cygpath -wp "$CLASSPATH"`
+fi
+
 case $1 in
 start|startClean)
-	if [ "x${base_dir}" == "x" ]
+    if [ "x${base_dir}" == "x" ]
         then
-      	mkdir -p /tmp/zkdata
-        java -cp $CLASSPATH org.apache.zookeeper.server.ZooKeeperServerMain 22181 /tmp/zkdata 3000 $ZKMAXCNXNS &> /tmp/zk.log &
+        mkdir -p /tmp/zkdata
+        java -cp "$CLASSPATH" org.apache.zookeeper.server.ZooKeeperServerMain 22181 /tmp/zkdata 3000 $ZKMAXCNXNS &> /tmp/zk.log &
         pid=$!
-        echo $! > /tmp/zk.pid        
+        echo -n $! > /tmp/zk.pid
         else
-        mkdir -p ${base_dir}/build/tmp/zkdata
-        java -cp $CLASSPATH org.apache.zookeeper.server.ZooKeeperServerMain 22181 ${base_dir}/build/tmp/zkdata 3000 $ZKMAXCNXNS &> ${base_dir}/build/tmp/zk.log &
-        echo $! > ${base_dir}/build/tmp/zk.pid
-	fi
-        sleep 5
-	;;
+        mkdir -p "${base_dir}/build/tmp/zkdata"
+        java -cp "$CLASSPATH" org.apache.zookeeper.server.ZooKeeperServerMain 22181 "${base_dir}/build/tmp/zkdata" 3000 $ZKMAXCNXNS &> "${base_dir}/build/tmp/zk.log" &
+        pid=$!
+        echo -n $pid > "${base_dir}/build/tmp/zk.pid"
+    fi
+
+    # wait max 120 seconds for server to be ready to server clients
+    # this handles testing on slow hosts
+    success=false
+    for i in {1..40}
+    do
+        if ps -p $pid > /dev/null
+        then
+            if java -cp "$CLASSPATH" org.apache.zookeeper.ZooKeeperMain -server localhost:22181 ls / > /dev/null 2>&1
+            then
+                # server not up yet - wait
+                sleep 5
+            else
+                # server is up and serving client connections
+                success=true
+                break
+            fi
+        else
+            # server died - exit now
+            echo -n " ZooKeeper server process failed"
+            break
+        fi
+    done
+
+    if $success
+    then
+        ## in case for debug, but generally don't use as it messes up the
+        ## console test output
+        echo -n " ZooKeeper server started"
+    else
+        echo -n " ZooKeeper server NOT started"
+    fi
+
+    ;;
 stop)
-	# Already killed above
-	;;
+    # Already killed above
+    ;;
 *)
-	echo "Unknown command " + $1
-	exit 2
+    echo "Unknown command " + $1
+    exit 2
 esac
 
