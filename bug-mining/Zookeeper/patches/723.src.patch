diff --git a/CHANGES.txt b/CHANGES.txt
index 17a8966c4..4a4c4416c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -214,6 +214,9 @@ BUGFIXES:
   ZOOKEEPER-1929: std::length_error on update children
   (Charles Strahan via rgs)
 
+  ZOOKEEPER-1371: Remove dependency on log4j in the source code
+  (Arshad Mohammad via rgs)
+
 IMPROVEMENTS:
   ZOOKEEPER-1660 Documentation for Dynamic Reconfiguration (Reed Wanderman-Milne via shralex)  
 
diff --git a/build.xml b/build.xml
index fae030b94..8c4addba4 100644
--- a/build.xml
+++ b/build.xml
@@ -241,7 +241,14 @@ xmlns:maven="antlib:org.apache.maven.artifact.ant">
       </fileset>
       <path refid="java.classpath"/>
     </path>
-
+	<path id="test.java.classpath.without.log4j">
+        <pathelement location="${test.java.classes}" />
+        <fileset dir="${ivy.test.lib}">
+            <include name="**/*.jar" />
+            <exclude name="**/*log4j*.jar"/>
+        </fileset>
+        <path refid="java.classpath"/>
+    </path>
     <path id="package.classpath">
       <fileset dir="${ivy.package.lib}">
         <include name="**/jdeb*.jar" />
@@ -1340,15 +1347,46 @@ xmlns:maven="antlib:org.apache.maven.artifact.ant">
       <fileset id="quicktest.files" dir="${test.src.dir}">
         <include name="**/*${test.category}Test.java" />
         <exclude name="**/*HammerTest.java" />
+        <exclude name="**/*${test.category}NoLog4j*.java"/>
       </fileset>
       <fileset id="fulltest.files" dir="${test.src.dir}">
         <include name="**/*${test.category}Test.java" />
+        <exclude name="**/*${test.category}NoLog4j*.java"/>
       </fileset>
       <fileset id="testcase.files" dir="${test.src.dir}">
         <include name="**/${testcase}.java" />
+        <exclude name="**/*${test.category}NoLog4j*.java"/>
       </fileset>
     </target>
 
+    <target name="junit.run.nolog4j">
+        <junit showoutput="${test.output}"
+               printsummary="${test.junit.printsummary}"
+               haltonfailure="${test.junit.haltonfailure}"
+               fork="yes"
+               forkmode="${test.junit.fork.mode}"
+               maxmemory="${test.junit.maxmem}"
+               dir="${basedir}" timeout="${test.timeout}"
+               errorProperty="tests.failed.nolog4j"
+               failureProperty="tests.failed.nolog4j">
+            <sysproperty key="build.test.dir" value="${test.tmp.dir}"/>
+            <sysproperty key="test.data.dir" value="${test.data.dir}"/>
+            <!-- superDigest is used by the tests/main code. If this is not set
+                 as part of starting the jvm there is no guarantee that the static
+                 initializers in the java code will see this (esp when running
+                 with junit fork mode set to "once")-->
+            <sysproperty key="zookeeper.DigestAuthenticationProvider.superDigest"
+                         value="super:D/InIHSb7yEEbrWz8b9l71RjZJU="/>
+            <classpath refid="test.java.classpath.without.log4j"/>
+            <formatter type="${test.junit.output.format}"/>
+            <batchtest todir="${test.log.dir}" if="fulltest">
+                <fileset dir="${test.src.dir}">
+                    <include name="**/*${test.category}NoLog4j*.java"/>
+                </fileset>
+            </batchtest>
+        </junit>
+        <fail if="tests.failed.nolog4j">Tests failed!</fail>
+    </target>
     <target name="junit.run" depends="junit-init,junit.run-single,junit.run-concurrent" />
 
     <target name="junit.run-concurrent" if="ant.supports.concurrent.junit.processes">
@@ -1499,11 +1537,13 @@ xmlns:maven="antlib:org.apache.maven.artifact.ant">
 	<!-- yet to implement -->
     </target>
     
-    <target name="test-core-java" depends="test-init, test-category, junit.run"/> 
+    <target name="test-core-java" depends="test-init, test-category, junit.run"/>
+
+    <target name="test-core-java-nolog4j" depends="test-init, test-category, junit.run.nolog4j"/>
 
-    <target name="test-core-cppunit" depends="test-init, test-category, call-test-cppunit"/> 
+    <target name="test-core-cppunit" depends="test-init, test-category, call-test-cppunit"/>
 
-    <target name="test-core" depends="test-core-java, test-core-cppunit"/> 
+    <target name="test-core" depends="test-core-java, test-core-java-nolog4j, test-core-cppunit"/>
 
     <!-- ====================================================== -->
     <!-- Run optional third-party tool targets                  -->
diff --git a/ivy.xml b/ivy.xml
index 41fc4f4a4..b3780b86b 100644
--- a/ivy.xml
+++ b/ivy.xml
@@ -42,13 +42,13 @@
 
   <dependencies>
     <dependency org="org.slf4j" name="slf4j-api" rev="1.7.5"/>
-    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.7.5" transitive="false"/>
+    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.7.5" transitive="false" conf="test->default"/>
     <dependency org="commons-cli" name="commons-cli" rev="1.2" />
   
     <dependency org="org.apache.maven.wagon" name="wagon-http" rev="2.4" conf="mvn-ant-task->default"/>
     <dependency org="org.apache.maven" name="maven-ant-tasks" rev="2.1.3" conf="mvn-ant-task->master"/>
     <!-- transitive false turns off dependency checking, log4j deps seem borked -->
-    <dependency org="log4j" name="log4j" rev="1.2.16" transitive="false" conf="default"/>
+    <dependency org="log4j" name="log4j" rev="1.2.17" transitive="false" conf="test->default"/>
     <dependency org="jline" name="jline" rev="2.11" transitive="false" conf="optional->default"/>
 
     <dependency org="io.netty" name="netty" conf="default" rev="3.7.0.Final">
diff --git a/src/contrib/loggraph/ivy.xml b/src/contrib/loggraph/ivy.xml
index d6fa9d6d7..605118f04 100644
--- a/src/contrib/loggraph/ivy.xml
+++ b/src/contrib/loggraph/ivy.xml
@@ -31,11 +31,11 @@
   </configurations>
 
   <dependencies>
-    <dependency org="org.slf4j" name="slf4j-api" rev="1.6.1"/>
-    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.6.1" transitive="false"/>
+    <dependency org="org.slf4j" name="slf4j-api" rev="1.7.5"/>
+    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.7.5" transitive="false" conf="test->default" />
   
     <!-- transitive false turns off dependency checking, log4j deps seem borked -->
-    <dependency org="log4j" name="log4j" rev="1.2.15" transitive="false"/>
+    <dependency org="log4j" name="log4j" rev="1.2.17" transitive="false" conf="test->default" />
     <dependency org="org.eclipse.jetty" name="jetty-server" rev="7.0.1.v20091125" />
     <dependency org="org.eclipse.jetty" name="jetty-servlet" rev="7.0.1.v20091125" />
     <dependency org="com.googlecode.json-simple" name="json-simple" rev="1.1" />
diff --git a/src/contrib/rest/ivy.xml b/src/contrib/rest/ivy.xml
index 010fdb282..e70704159 100644
--- a/src/contrib/rest/ivy.xml
+++ b/src/contrib/rest/ivy.xml
@@ -31,11 +31,11 @@
   </configurations>
 
   <dependencies>
-    <dependency org="org.slf4j" name="slf4j-api" rev="1.6.1"/>
-    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.6.1" transitive="false"/>
+    <dependency org="org.slf4j" name="slf4j-api" rev="1.7.5"/>
+    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.7.5" transitive="false" conf="test->default" />
   
     <!-- transitive false turns off dependency checking, log4j deps seem borked -->
-    <dependency org="log4j" name="log4j" rev="1.2.15" transitive="false"/>
+    <dependency org="log4j" name="log4j" rev="1.2.17" transitive="false" conf="test->default" />
     <dependency org="asm" name="asm" rev="3.1" />
     <dependency org="com.sun.grizzly" name="grizzly-servlet-webserver" rev="1.9.8" />
     <dependency org="com.sun.jersey" name="jersey-server" rev="1.1.5.1" />
diff --git a/src/contrib/zooinspector/ivy.xml b/src/contrib/zooinspector/ivy.xml
index 9b9498a54..283d4184e 100644
--- a/src/contrib/zooinspector/ivy.xml
+++ b/src/contrib/zooinspector/ivy.xml
@@ -32,10 +32,10 @@
   </configurations>
 
   <dependencies>
-    <dependency org="org.slf4j" name="slf4j-api" rev="1.6.1"/>
-    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.6.1" transitive="false"/>
+    <dependency org="org.slf4j" name="slf4j-api" rev="1.7.5"/>
+    <dependency org="org.slf4j" name="slf4j-log4j12" rev="1.7.5" transitive="false" conf="test->default" />
             
-    <dependency org="log4j" name="log4j" rev="1.2.15" transitive="false"/>
+    <dependency org="log4j" name="log4j" rev="1.2.17" transitive="false" conf="test->default" />
     <dependency org="junit" name="junit" rev="4.12" conf="test->default"/>
         <dependency org="org.apache.rat" name="apache-rat-tasks" 
                 rev="0.6" conf="releaseaudit->default"/>
diff --git a/src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml b/src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml
index 4736f2135..28b87cb70 100644
--- a/src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml
+++ b/src/docs/src/documentation/content/xdocs/zookeeperAdmin.xml
@@ -560,13 +560,24 @@ server.3=zoo3:2888:3888</programlisting>
     <section id="sc_logging">
       <title>Logging</title>
 
-      <para>ZooKeeper uses <emphasis role="bold">log4j</emphasis> version 1.2 as 
-      its logging infrastructure. The  ZooKeeper default <filename>log4j.properties</filename> 
-      file resides in the <filename>conf</filename> directory. Log4j requires that 
-      <filename>log4j.properties</filename> either be in the working directory 
-      (the directory from which ZooKeeper is run) or be accessible from the classpath.</para>
-
-      <para>For more information, see 
+    <para>
+        ZooKeeper uses <emphasis role="bold"><ulink url="http://www.slf4j.org">SLF4J</ulink></emphasis>
+        version 1.7 as its logging infrastructure. For backward compatibility it is bound to
+        <emphasis role="bold">LOG4J</emphasis> but you can use
+        <emphasis role="bold"><ulink url="http://logback.qos.ch/">LOGBack</ulink></emphasis>
+        or any other supported logging framework of your choice.
+    </para>
+    <para>
+        The ZooKeeper default <filename>log4j.properties</filename>
+        file resides in the <filename>conf</filename> directory. Log4j requires that
+        <filename>log4j.properties</filename> either be in the working directory
+        (the directory from which ZooKeeper is run) or be accessible from the classpath.
+    </para>
+
+    <para>For more information about SLF4J, see
+      <ulink url="http://www.slf4j.org/manual.html">its manual</ulink>.</para>
+
+    <para>For more information about LOG4J, see
       <ulink url="http://logging.apache.org/log4j/1.2/manual.html#defaultInit">Log4j Default Initialization Procedure</ulink> 
       of the log4j manual.</para>
       
diff --git a/src/java/main/org/apache/zookeeper/Login.java b/src/java/main/org/apache/zookeeper/Login.java
index 44b0bdfb8..f88e5afe9 100644
--- a/src/java/main/org/apache/zookeeper/Login.java
+++ b/src/java/main/org/apache/zookeeper/Login.java
@@ -32,18 +32,20 @@
 import javax.security.auth.login.LoginException;
 import javax.security.auth.callback.CallbackHandler;
 
-import org.apache.log4j.Logger;
 import org.apache.zookeeper.client.ZooKeeperSaslClient;
 import org.apache.zookeeper.common.Time;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import javax.security.auth.kerberos.KerberosTicket;
 import javax.security.auth.Subject;
+
 import java.util.Date;
 import java.util.Random;
 import java.util.Set;
 
 public class Login {
-    private static final Logger LOG = Logger.getLogger(Login.class);
+    private static final Logger LOG = LoggerFactory.getLogger(Login.class);
     public CallbackHandler callbackHandler;
 
     // LoginThread will sleep until 80% of time from last refresh to
@@ -130,19 +132,20 @@ public void run() {
                     if (tgt == null) {
                         nextRefresh = now + MIN_TIME_BEFORE_RELOGIN;
                         nextRefreshDate = new Date(nextRefresh);
-                        LOG.warn("No TGT found: will try again at " + nextRefreshDate);
+                        LOG.warn("No TGT found: will try again at {}", nextRefreshDate);
                     } else {
                         nextRefresh = getRefreshTime(tgt);
                         long expiry = tgt.getEndTime().getTime();
                         Date expiryDate = new Date(expiry);
                         if ((isUsingTicketCache) && (tgt.getEndTime().equals(tgt.getRenewTill()))) {
-                            LOG.error("The TGT cannot be renewed beyond the next expiry date: " + expiryDate + "." +
+                            Object[] logPayload = {expiryDate, principal, principal};
+                            LOG.error("The TGT cannot be renewed beyond the next expiry date: {}." +
                                     "This process will not be able to authenticate new SASL connections after that " +
                                     "time (for example, it will not be authenticate a new connection with a Zookeeper " +
                                     "Quorum member).  Ask your system administrator to either increase the " +
-                                    "'renew until' time by doing : 'modprinc -maxrenewlife " + principal + "' within " +
-                                    "kadmin, or instead, to generate a keytab for " + principal + ". Because the TGT's " +
-                                    "expiry cannot be further extended by refreshing, exiting refresh thread now.");
+                                    "'renew until' time by doing : 'modprinc -maxrenewlife {}' within " +
+                                    "kadmin, or instead, to generate a keytab for {}. Because the TGT's " +
+                                    "expiry cannot be further extended by refreshing, exiting refresh thread now.", logPayload);
                             return;
                         }
                         // determine how long to sleep from looking at ticket's expiry.
@@ -159,23 +162,25 @@ public void run() {
                                 // next scheduled refresh is sooner than (now + MIN_TIME_BEFORE_LOGIN).
                                 Date until = new Date(nextRefresh);
                                 Date newuntil = new Date(now + MIN_TIME_BEFORE_RELOGIN);
-                                LOG.warn("TGT refresh thread time adjusted from : " + until + " to : " + newuntil + " since "
+                                Object[] logPayload = {until, newuntil, (MIN_TIME_BEFORE_RELOGIN / 1000)};
+                                LOG.warn("TGT refresh thread time adjusted from : {} to : {} since "
                                         + "the former is sooner than the minimum refresh interval ("
-                                        + MIN_TIME_BEFORE_RELOGIN / 1000 + " seconds) from now.");
+                                        + "{} seconds) from now.", logPayload);
                             }
                             nextRefresh = Math.max(nextRefresh, now + MIN_TIME_BEFORE_RELOGIN);
                         }
                         nextRefreshDate = new Date(nextRefresh);
                         if (nextRefresh > expiry) {
-                            LOG.error("next refresh: " + nextRefreshDate + " is later than expiry " + expiryDate
-                                    + ". This may indicate a clock skew problem. Check that this host and the KDC's "
-                                    + "hosts' clocks are in sync. Exiting refresh thread.");
+                            Object[] logPayload = {nextRefreshDate, expiryDate};
+                            LOG.error("next refresh: {} is later than expiry {}."
+                                    + " This may indicate a clock skew problem. Check that this host and the KDC's "
+                                    + "hosts' clocks are in sync. Exiting refresh thread.", logPayload);
                             return;
                         }
                     }
                     if (now < nextRefresh) {
                         Date until = new Date(nextRefresh);
-                        LOG.info("TGT refresh sleeping until: " + until.toString());
+                        LOG.info("TGT refresh sleeping until: {}", until.toString());
                         try {
                             Thread.sleep(nextRefresh - now);
                         } catch (InterruptedException ie) {
@@ -184,10 +189,10 @@ public void run() {
                         }
                     }
                     else {
-                        LOG.error("nextRefresh:" + nextRefreshDate + " is in the past: exiting refresh thread. Check"
+                        LOG.error("nextRefresh:{} is in the past: exiting refresh thread. Check"
                                 + " clock sync between this host and KDC - (KDC's clock is likely ahead of this host)."
                                 + " Manual intervention will be required for this client to successfully authenticate."
-                                + " Exiting refresh thread.");
+                                + " Exiting refresh thread.", nextRefreshDate);
                         return;
                     }
                     if (isUsingTicketCache) {
@@ -199,7 +204,7 @@ public void run() {
                         int retry = 1;
                         while (retry >= 0) {
                             try {
-                                LOG.debug("running ticket cache refresh command: " + cmd + " " + kinitArgs);
+                                LOG.debug("running ticket cache refresh command: {} {}", cmd, kinitArgs);
                                 Shell.execCommand(cmd, kinitArgs);
                                 break;
                             } catch (Exception e) {
@@ -213,8 +218,9 @@ public void run() {
                                         return;
                                     }
                                 } else {
-                                    LOG.warn("Could not renew TGT due to problem running shell command: '" + cmd
-                                            + " " + kinitArgs + "'" + "; exception was:" + e + ". Exiting refresh thread.",e);
+                                    Object[] logPayload = {cmd, kinitArgs, e.toString(), e};
+                                    LOG.warn("Could not renew TGT due to problem running shell command: '{}"
+                                            + " {}'; exception was:{}. Exiting refresh thread.", logPayload);
                                     return;
                                 }
                             }
@@ -237,7 +243,7 @@ public void run() {
                                         throw le;
                                     }
                                 } else {
-                                    LOG.error("Could not refresh TGT for principal: " + principal + ".", le);
+                                    LOG.error("Could not refresh TGT for principal: {}.", principal, le);
                                 }
                             }
                         }
@@ -264,7 +270,7 @@ public void shutdown() {
             try {
                 t.join();
             } catch (InterruptedException e) {
-                LOG.warn("error while waiting for Login thread to shutdown: " + e);
+                LOG.warn("error while waiting for Login thread to shutdown: ", e);
             }
         }
     }
@@ -295,8 +301,8 @@ private synchronized LoginContext login(final String loginContextName) throws Lo
     private long getRefreshTime(KerberosTicket tgt) {
         long start = tgt.getStartTime().getTime();
         long expires = tgt.getEndTime().getTime();
-        LOG.info("TGT valid starting at:        " + tgt.getStartTime().toString());
-        LOG.info("TGT expires:                  " + tgt.getEndTime().toString());
+        LOG.info("TGT valid starting at:        {}", tgt.getStartTime().toString());
+        LOG.info("TGT expires:                  {}", tgt.getEndTime().toString());
         long proposedRefresh = start + (long) ((expires - start) *
                 (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));
         if (proposedRefresh > expires) {
@@ -313,7 +319,7 @@ private synchronized KerberosTicket getTGT() {
         for(KerberosTicket ticket: tickets) {
             KerberosPrincipal server = ticket.getServer();
             if (server.getName().equals("krbtgt/" + server.getRealm() + "@" + server.getRealm())) {
-                LOG.debug("Found tgt " + ticket + ".");
+                LOG.debug("Found tgt {}.", ticket);
                 return ticket;
             }
         }
@@ -323,9 +329,9 @@ private synchronized KerberosTicket getTGT() {
     private boolean hasSufficientTimeElapsed() {
         long now = Time.currentElapsedTime();
         if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN ) {
-            LOG.warn("Not attempting to re-login since the last re-login was " +
-                    "attempted less than " + (MIN_TIME_BEFORE_RELOGIN/1000) + " seconds"+
-                    " before.");
+            LOG.warn("Not attempting to re-login since the last re-login was "
+                    + "attempted less than {} seconds before.",
+                    (MIN_TIME_BEFORE_RELOGIN / 1000));
             return false;
         }
         // register most recent relogin attempt
@@ -382,7 +388,7 @@ private synchronized void reLogin()
         if (!hasSufficientTimeElapsed()) {
             return;
         }
-        LOG.info("Initiating logout for " + principal);
+        LOG.info("Initiating logout for {}", principal);
         synchronized (Login.class) {
             //clear up the kerberos state. But the tokens are not cleared! As per
             //the Java kerberos login module code, only the kerberos credentials
@@ -391,7 +397,7 @@ private synchronized void reLogin()
             //login and also update the subject field of this instance to
             //have the new credentials (pass it to the LoginContext constructor)
             login = new LoginContext(loginContextName, getSubject());
-            LOG.info("Initiating re-login for " + principal);
+            LOG.info("Initiating re-login for {}", principal);
             login.login();
             setLogin(login);
         }
diff --git a/src/java/main/org/apache/zookeeper/Shell.java b/src/java/main/org/apache/zookeeper/Shell.java
index e9e85b9b9..1e6763f19 100644
--- a/src/java/main/org/apache/zookeeper/Shell.java
+++ b/src/java/main/org/apache/zookeeper/Shell.java
@@ -38,8 +38,10 @@
 import java.util.Timer;
 import java.util.TimerTask;
 import java.util.concurrent.atomic.AtomicBoolean;
-import org.apache.log4j.Logger;
+
 import org.apache.zookeeper.common.Time;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * A base class for running a Unix command.
@@ -50,7 +52,7 @@
  */
 abstract public class Shell {
   
-  private static final Logger LOG = Logger.getLogger(Shell.class);
+    private static final Logger LOG = LoggerFactory.getLogger(Shell.class);
   
   /** a Unix command to get the current user's name */
   public final static String USER_NAME_COMMAND = "whoami";
diff --git a/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
index e4be47c68..19b45ba13 100644
--- a/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
+++ b/src/java/main/org/apache/zookeeper/client/FourLetterWordMain.java
@@ -31,14 +31,15 @@
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 
-import org.apache.log4j.Logger;
 import org.apache.zookeeper.common.X509Exception.SSLContextException;
 import org.apache.zookeeper.common.X509Util;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class FourLetterWordMain {
     //in milliseconds, socket should connect/read within this period otherwise SocketTimeoutException
     private static final int DEFAULT_SOCKET_TIMEOUT = 5000;
-    protected static final Logger LOG = Logger.getLogger(FourLetterWordMain.class);
+    protected static final Logger LOG = LoggerFactory.getLogger(FourLetterWordMain.class);
     /**
      * Send the 4letterword
      * @param host the destination host
@@ -81,7 +82,7 @@ public static String send4LetterWord(String host, int port, String cmd, boolean
      */
     public static String send4LetterWord(String host, int port, String cmd, boolean secure, int timeout)
             throws IOException, SSLContextException {
-        LOG.info("connecting to " + host + " " + port);
+        LOG.info("connecting to {} {}", host, port);
         Socket sock;
         InetSocketAddress hostaddress= host != null ? new InetSocketAddress(host, port) :
             new InetSocketAddress(InetAddress.getByName(null), port);
diff --git a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
index 64e1942bd..1ce4faa2f 100644
--- a/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
+++ b/src/java/main/org/apache/zookeeper/jmx/ManagedUtil.java
@@ -24,47 +24,96 @@
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
-import org.apache.log4j.LogManager;
-import org.apache.log4j.Logger;
-import org.apache.log4j.jmx.HierarchyDynamicMBean;
-import org.apache.log4j.spi.LoggerRepository;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Shared utilities
  */
 public class ManagedUtil {
+    private static final Logger LOG = LoggerFactory.getLogger(ManagedUtil.class);
+
+    private static final boolean isLog4jJmxEnabled() {
+        boolean enabled = false;
+
+        try {
+            Class.forName("org.apache.log4j.spi.LoggerRepository");
+
+            if (Boolean.getBoolean("zookeeper.jmx.log4j.disable") == true) {
+                LOG.info("Log4j found but jmx support is disabled.");
+            } else {
+                enabled = true;
+                LOG.info("Log4j found with jmx enabled.");
+            }
+
+        } catch (ClassNotFoundException e) {
+            LOG.info("Log4j not found.");
+        }
+
+        return enabled;
+    }
+
+
     /**
      * Register the log4j JMX mbeans. Set environment variable
      * "zookeeper.jmx.log4j.disable" to true to disable registration.
      * @see http://logging.apache.org/log4j/1.2/apidocs/index.html?org/apache/log4j/jmx/package-summary.html
      * @throws JMException if registration fails
      */
+    @SuppressWarnings("rawtypes")
     public static void registerLog4jMBeans() throws JMException {
-        if (Boolean.getBoolean("zookeeper.jmx.log4j.disable") == true) {
-            return;
-        }
-        
-        MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();
+        if (isLog4jJmxEnabled()) {
+            LOG.debug("registerLog4jMBeans()");
+            MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();
+
+            try {
+                // Create and Register the top level Log4J MBean
+                // org.apache.log4j.jmx.HierarchyDynamicMBean hdm = new org.apache.log4j.jmx.HierarchyDynamicMBean();
+                Object hdm = Class.forName("org.apache.log4j.jmx.HierarchyDynamicMBean").newInstance();
+
+                ObjectName mbo = new ObjectName("log4j:hiearchy=default");
+                mbs.registerMBean(hdm, mbo);
 
-        // Create and Register the top level Log4J MBean
-        HierarchyDynamicMBean hdm = new HierarchyDynamicMBean();
+                // Add the root logger to the Hierarchy MBean
+                // org.apache.log4j.Logger rootLogger =
+                // org.apache.log4j.Logger.getRootLogger();
+                Object rootLogger = Class.forName("org.apache.log4j.Logger")
+                        .getMethod("getRootLogger", (Class<?>[]) null)
+                        .invoke(null, (Object[]) null);
 
-        ObjectName mbo = new ObjectName("log4j:hiearchy=default");
-        mbs.registerMBean(hdm, mbo);
+                // hdm.addLoggerMBean(rootLogger.getName());
+                Object rootLoggerName = rootLogger.getClass()
+                        .getMethod("getName", (Class<?>[]) null)
+                        .invoke(rootLogger, (Object[]) null);
+                hdm.getClass().getMethod("addLoggerMBean", String.class)
+                        .invoke(hdm, rootLoggerName);
 
-        // Add the root logger to the Hierarchy MBean
-        Logger rootLogger = Logger.getRootLogger();
-        hdm.addLoggerMBean(rootLogger.getName());
+                // Get each logger from the Log4J Repository and add it to the
+                // Hierarchy MBean created above.
+                // org.apache.log4j.spi.LoggerRepository r =
+                // org.apache.log4j.LogManager.getLoggerRepository();
+                Object r = Class.forName("org.apache.log4j.LogManager")
+                        .getMethod("getLoggerRepository", (Class<?>[]) null)
+                        .invoke(null, (Object[]) null);
 
-        // Get each logger from the Log4J Repository and add it to
-        // the Hierarchy MBean created above.
-        LoggerRepository r = LogManager.getLoggerRepository();
-        Enumeration enumer = r.getCurrentLoggers();
-        Logger logger = null;
+                // Enumeration enumer = r.getCurrentLoggers();
+                Enumeration enumer = (Enumeration) r.getClass()
+                        .getMethod("getCurrentLoggers", (Class<?>[]) null)
+                        .invoke(r, (Object[]) null);
 
-        while (enumer.hasMoreElements()) {
-           logger = (Logger) enumer.nextElement();
-           hdm.addLoggerMBean(logger.getName());
+                while (enumer.hasMoreElements()) {
+                    Object logger = enumer.nextElement();
+                    // hdm.addLoggerMBean(logger.getName());
+                    Object loggerName = logger.getClass()
+                            .getMethod("getName", (Class<?>[]) null)
+                            .invoke(logger, (Object[]) null);
+                    hdm.getClass().getMethod("addLoggerMBean", String.class)
+                            .invoke(hdm, loggerName);
+                }
+            } catch (Exception e) {
+                LOG.error("Problems while registering log4j jmx beans!", e);
+                throw new JMException(e.toString());
+            }
         }
     }
 
diff --git a/src/java/test/org/apache/zookeeper/server/ZxidRolloverTest.java b/src/java/test/org/apache/zookeeper/server/ZxidRolloverTest.java
index 5a6a92ebd..838b0a809 100644
--- a/src/java/test/org/apache/zookeeper/server/ZxidRolloverTest.java
+++ b/src/java/test/org/apache/zookeeper/server/ZxidRolloverTest.java
@@ -19,7 +19,6 @@
 package org.apache.zookeeper.server;
 
 
-import org.apache.log4j.Logger;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.ConnectionLossException;
@@ -35,12 +34,14 @@
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Verify ZOOKEEPER-1277 - ensure that we handle epoch rollover correctly.
  */
 public class ZxidRolloverTest extends ZKTestCase {
-    private static final Logger LOG = Logger.getLogger(ZxidRolloverTest.class);
+    private static final Logger LOG = LoggerFactory.getLogger(ZxidRolloverTest.class);
 
     private QuorumUtil qu;
     private ZooKeeperServer zksLeader;
@@ -223,7 +224,7 @@ public void tearDown() throws Exception {
      * wait for the clients to be re-connected after the re-election
      */
     private int createNodes(ZooKeeper zk, int start, int count) throws Exception {
-        LOG.info("Creating nodes " + start + " thru " + (start + count));
+        LOG.info("Creating nodes {} thru {}", start, (start + count));
         int j = 0;
         try {
             for (int i = start; i < start + count; i++) {
@@ -242,10 +243,10 @@ private int createNodes(ZooKeeper zk, int start, int count) throws Exception {
      * caused the roll-over, did not.
      */
     private void checkNodes(ZooKeeper zk, int start, int count) throws Exception {
-        LOG.info("Validating nodes " + start + " thru " + (start + count));
+        LOG.info("Validating nodes {} thru {}", start, (start + count));
         for (int i = start; i < start + count; i++) {
             Assert.assertNotNull(zk.exists("/foo" + i, false));
-            LOG.error("Exists zxid:" + Long.toHexString(zk.exists("/foo" + i, false).getCzxid()));
+            LOG.error("Exists zxid:{}", Long.toHexString(zk.exists("/foo" + i, false).getCzxid()));
         }
         Assert.assertNull(zk.exists("/foo" + (start + count), false));
     }
diff --git a/src/java/test/org/apache/zookeeper/test/FollowerResyncConcurrencyTest.java b/src/java/test/org/apache/zookeeper/test/FollowerResyncConcurrencyTest.java
index e6dd653ce..508671136 100644
--- a/src/java/test/org/apache/zookeeper/test/FollowerResyncConcurrencyTest.java
+++ b/src/java/test/org/apache/zookeeper/test/FollowerResyncConcurrencyTest.java
@@ -108,7 +108,7 @@ public void testLaggingFollowerResyncsUnderNewEpoch() throws Exception {
 
         ZooKeeper zk1 =
                 createClient(qu.getPeer(1).peer.getClientPort(), watcher1);
-        LOG.info("zk1 has session id 0x" + Long.toHexString(zk1.getSessionId()));
+        LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));
 
         final String resyncPath = "/resyncundernewepoch";
         zk1.create(resyncPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
@@ -133,19 +133,19 @@ public void testLaggingFollowerResyncsUnderNewEpoch() throws Exception {
                 + qu.getPeer(3).clientPort, ClientBase.CONNECTION_TIMEOUT));
 
         zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);
-        LOG.info("zk1 has session id 0x" + Long.toHexString(zk1.getSessionId()));
+        LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));
         
         assertNotNull("zk1 has data", zk1.exists(resyncPath, false));
 
         final ZooKeeper zk2 =
                 createClient(qu.getPeer(2).peer.getClientPort(), watcher2);
-        LOG.info("zk2 has session id 0x" + Long.toHexString(zk2.getSessionId()));
+        LOG.info("zk2 has session id 0x{}", Long.toHexString(zk2.getSessionId()));
 
         assertNotNull("zk2 has data", zk2.exists(resyncPath, false));
 
         final ZooKeeper zk3 =
             createClient(qu.getPeer(3).peer.getClientPort(), watcher3);
-        LOG.info("zk3 has session id 0x" + Long.toHexString(zk3.getSessionId()));
+        LOG.info("zk3 has session id 0x{}", Long.toHexString(zk3.getSessionId()));
 
         assertNotNull("zk3 has data", zk3.exists(resyncPath, false));
 
@@ -224,13 +224,13 @@ public void followerResyncCrashTest(boolean useTxnLogResync)
 
         /* Reusing the index variable to select a follower to connect to */
         index = (index == 1) ? 2 : 1;
-        LOG.info("Connecting to follower:" + index);
+        LOG.info("Connecting to follower: {}", index);
 
         qu.shutdown(index);
 
         final ZooKeeper zk3 =
             createClient(qu.getPeer(3).peer.getClientPort(), watcher3);
-        LOG.info("zk3 has session id 0x" + Long.toHexString(zk3.getSessionId()));
+        LOG.info("zk3 has session id 0x{}", Long.toHexString(zk3.getSessionId()));
 
         zk3.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
 
@@ -238,11 +238,11 @@ public void followerResyncCrashTest(boolean useTxnLogResync)
 
         final ZooKeeper zk1 =
             createClient(qu.getPeer(index).peer.getClientPort(), watcher1);
-        LOG.info("zk1 has session id 0x" + Long.toHexString(zk1.getSessionId()));
+        LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));
 
         final ZooKeeper zk2 =
             createClient(qu.getPeer(index).peer.getClientPort(), watcher2);
-        LOG.info("zk2 has session id 0x" + Long.toHexString(zk2.getSessionId()));
+        LOG.info("zk2 has session id 0x{}", Long.toHexString(zk2.getSessionId()));
 
         zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
         
@@ -309,15 +309,15 @@ public void processResult(int rc, String path, Object ctx, String name) {
                 // should use txnlog to catchup. For subsequent restart, the
                 // follower should use a diff to catchup.
                 mytestfooThread.start();
-                LOG.info("Restarting follower " + index);
+                LOG.info("Restarting follower: {}", index);
                 qu.restart(index);
                 Thread.sleep(300);
-                LOG.info("Shutdown follower " + index);
+                LOG.info("Shutdown follower: {}", index);
                 qu.shutdown(index);
                 Thread.sleep(300);
-                LOG.info("Restarting follower " + index);
+                LOG.info("Restarting follower: {}", index);
                 qu.restart(index);
-                LOG.info("Setting up server: " + index);
+                LOG.info("Setting up server: {}", index);
             }
             if((i % 1000) == 0){
                 Thread.sleep(1000);
@@ -407,19 +407,19 @@ public void testResyncByDiffAfterFollowerCrashes()
 
         /* Reusing the index variable to select a follower to connect to */
         index = (index == 1) ? 2 : 1;
-        LOG.info("Connecting to follower:" + index);
+        LOG.info("Connecting to follower: {}", index);
 
         final ZooKeeper zk1 =
             createClient(qu.getPeer(index).peer.getClientPort(), watcher1);
-        LOG.info("zk1 has session id 0x" + Long.toHexString(zk1.getSessionId()));
+        LOG.info("zk1 has session id 0x{}", Long.toHexString(zk1.getSessionId()));
 
         final ZooKeeper zk2 =
             createClient(qu.getPeer(index).peer.getClientPort(), watcher2);
-        LOG.info("zk2 has session id 0x" + Long.toHexString(zk2.getSessionId()));
+        LOG.info("zk2 has session id 0x{}", Long.toHexString(zk2.getSessionId()));
 
         final ZooKeeper zk3 =
             createClient(qu.getPeer(3).peer.getClientPort(), watcher3);
-        LOG.info("zk3 has session id 0x" + Long.toHexString(zk3.getSessionId()));
+        LOG.info("zk3 has session id 0x{}", Long.toHexString(zk3.getSessionId()));
 
         zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
         zk2.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
@@ -490,7 +490,7 @@ public void processResult(int rc, String path, Object ctx, String name) {
                 qu.startThenShutdown(index);
                 runNow.set(true);
                 qu.restart(index);
-                LOG.info("Setting up server: " + index);
+                LOG.info("Setting up server: {}", index);
             }
 
             if(i>=1000 &&  i%2== 0) {
@@ -553,14 +553,14 @@ private static DisconnectableZooKeeper createClient(int port,
      * verifying the state
      */
     private boolean waitForPendingRequests(int timeout) throws InterruptedException {
-        LOG.info("Wait for pending requests: " + pending.get());
+        LOG.info("Wait for pending requests: {}", pending.get());
         for (int i = 0; i < timeout; ++i) {
             Thread.sleep(1000);
             if (pending.get() == 0) {
                 return true;
             }
         }
-        LOG.info("Timeout waiting for pending requests: " + pending.get());
+        LOG.info("Timeout waiting for pending requests: {}", pending.get());
         return false;
     }
 
@@ -585,9 +585,10 @@ private boolean waitForSync(QuorumUtil qu, int index, int timeout) throws Interr
             }
             Thread.sleep(1000);
         }
-        LOG.info("Timeout waiting for zxid to sync: leader 0x" + Long.toHexString(leadZxid)+
-                 "clean 0x" + Long.toHexString(cleanZxid) +
-                 "restarted 0x" + Long.toHexString(restartedZxid));
+        LOG.info("Timeout waiting for zxid to sync: leader 0x{}" +
+                 "clean 0x{}" +
+                 "restarted 0x{}", Long.toHexString(leadZxid), Long.toHexString(cleanZxid),
+                Long.toHexString(restartedZxid));
         return false;
     }
 
@@ -628,7 +629,7 @@ private void verifyState(QuorumUtil qu, int index, Leader leader) {
         ZKDatabase clean =  qu.getPeer(3).peer.getActiveServer().getZKDatabase();
         ZKDatabase lead = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();
         for(Long l : sessionsRestarted) {
-            LOG.info("Validating ephemeral for session id 0x" + Long.toHexString(l));
+            LOG.info("Validating ephemeral for session id 0x{}", Long.toHexString(l));
             assertTrue("Should have same set of sessions in both servers, did not expect: " + l, sessionsNotRestarted.contains(l));
             Set<String> ephemerals = restarted.getEphemerals(l);
             Set<String> cleanEphemerals = clean.getEphemerals(l);
@@ -674,7 +675,7 @@ public void testFollowerSendsLastZxid() throws Exception {
         while(qu.getPeer(index).peer.follower == null) {
             index++;
         }
-        LOG.info("Connecting to follower:" + index);
+        LOG.info("Connecting to follower: {}", index);
 
         TestableZooKeeper zk =
                 createTestableClient("localhost:" + qu.getPeer(index).peer.getClientPort());
@@ -716,7 +717,7 @@ public void testFollowerWatcherResync() throws Exception {
         while(qu.getPeer(index).peer.follower == null) {
             index++;
         }
-        LOG.info("Connecting to follower:" + index);
+        LOG.info("Connecting to follower: {}", index);
 
         TestableZooKeeper zk1 = createTestableClient(
                 "localhost:" + qu.getPeer(index).peer.getClientPort());
diff --git a/src/java/test/org/apache/zookeeper/test/MultiTransactionTest.java b/src/java/test/org/apache/zookeeper/test/MultiTransactionTest.java
index e2163b54e..fb864f59f 100644
--- a/src/java/test/org/apache/zookeeper/test/MultiTransactionTest.java
+++ b/src/java/test/org/apache/zookeeper/test/MultiTransactionTest.java
@@ -27,7 +27,6 @@
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
-import org.apache.log4j.Logger;
 import org.apache.zookeeper.AsyncCallback;
 import org.apache.zookeeper.AsyncCallback.MultiCallback;
 import org.apache.zookeeper.CreateMode;
@@ -53,11 +52,13 @@
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 import org.junit.runners.Parameterized.Parameters;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 @RunWith(Parameterized.class)
 @Parameterized.UseParametersRunnerFactory(ZKParameterized.RunnerFactory.class)
 public class MultiTransactionTest extends ClientBase {
-    private static final Logger LOG = Logger.getLogger(MultiTransactionTest.class);
+    private static final Logger LOG = LoggerFactory.getLogger(MultiTransactionTest.class);
     private ZooKeeper zk;
     private ZooKeeper zk_chroot;
 
@@ -543,7 +544,7 @@ public void testUpdateConflict() throws Exception {
             Assert.fail("Should have thrown a KeeperException for invalid version");
         } catch (KeeperException e) {
             //PASS
-            LOG.error("STACKTRACE: " + e);
+            LOG.error("STACKTRACE: ", e);
         }
 
         Assert.assertNull(zk.exists("/multi", null));
@@ -623,10 +624,10 @@ public void processResult(int rc, String path, Object ctx,
 
         Assert.assertNotNull(results);
         for (OpResult r : results) {
-            LOG.info("RESULT==> " + r);
+            LOG.info("RESULT==> {}", r);
             if (r instanceof ErrorResult) {
                 ErrorResult er = (ErrorResult) r;
-                LOG.info("ERROR RESULT: " + er + " ERR=>" + KeeperException.Code.get(er.getErr()));
+                LOG.info("ERROR RESULT: {} ERR=>{}", er, KeeperException.Code.get(er.getErr()));
             }
         }
     }
diff --git a/src/java/test/org/apache/zookeeper/test/RestoreCommittedLogTest.java b/src/java/test/org/apache/zookeeper/test/RestoreCommittedLogTest.java
index 9c70387c0..837a71ea7 100644
--- a/src/java/test/org/apache/zookeeper/test/RestoreCommittedLogTest.java
+++ b/src/java/test/org/apache/zookeeper/test/RestoreCommittedLogTest.java
@@ -21,7 +21,6 @@
 import java.io.File;
 import java.util.List;
 
-import org.apache.log4j.Logger;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.PortAssignment;
 import org.apache.zookeeper.WatchedEvent;
@@ -35,12 +34,14 @@
 import org.apache.zookeeper.server.ZooKeeperServer;
 import org.junit.Assert;
 import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /** After a replica starts, it should load commits in its committedLog list.
  *  This test checks if committedLog != 0 after replica restarted.
  */
 public class RestoreCommittedLogTest extends ZKTestCase implements  Watcher {
-    private static final Logger LOG = Logger.getLogger(RestoreCommittedLogTest.class);
+    private static final Logger LOG = LoggerFactory.getLogger(RestoreCommittedLogTest.class);
     private static final String HOSTPORT = "127.0.0.1:" + PortAssignment.unique();
     private static final int CONNECTION_TIMEOUT = 3000;
     /**
@@ -77,7 +78,7 @@ public void testRestoreCommittedLog() throws Exception {
         zks.startdata();
         List<Proposal> committedLog = zks.getZKDatabase().getCommittedLog();
         int logsize = committedLog.size();
-        LOG.info("committedLog size = " + logsize);
+        LOG.info("committedLog size = {}", logsize);
         Assert.assertTrue("log size != 0", (logsize != 0));
         zks.shutdown();
     }
