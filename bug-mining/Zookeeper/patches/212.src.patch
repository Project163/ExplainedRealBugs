diff --git a/CHANGES.txt b/CHANGES.txt
index eb45e854b..5807bf4ec 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -212,6 +212,9 @@ BUGFIXES:
   ZOOKEEPER-413. two flaws need addressing in the c tests that can cause false
   positive failures (phunt via mahadev)
 
+  ZOOKEEPER-495. c client logs an invalid error when zookeeper_init is called
+  with chroot (phunt via mahadev)
+
 IMPROVEMENTS:
   ZOOKEEPER-473. cleanup junit tests to eliminate false positives due to
   "socket reuse" and failure to close client (phunt via mahadev)
diff --git a/src/c/src/zk_adaptor.h b/src/c/src/zk_adaptor.h
index 93f93b8d2..c7122c0a5 100644
--- a/src/c/src/zk_adaptor.h
+++ b/src/c/src/zk_adaptor.h
@@ -229,7 +229,7 @@ int process_async(int outstanding_sync);
 void process_completions(zhandle_t *zh);
 int flush_send_queue(zhandle_t*zh, int timeout);
 char* sub_string(zhandle_t *zh, const char* server_path);
-void free_duplicate_path(char* free_path, const char* path);
+void free_duplicate_path(const char* free_path, const char* path);
 void zoo_lock_auth(zhandle_t *zh);
 void zoo_unlock_auth(zhandle_t *zh);
 
diff --git a/src/c/src/zk_hashtable.c b/src/c/src/zk_hashtable.c
index a7ffacfd4..6ac80044b 100644
--- a/src/c/src/zk_hashtable.c
+++ b/src/c/src/zk_hashtable.c
@@ -268,7 +268,9 @@ static void add_for_event(zk_hashtable *ht, char *path, watcher_object_list_t **
 static void do_foreach_watcher(watcher_object_t* wo,zhandle_t* zh,
         const char* path,int type,int state)
 {
-    char *client_path = sub_string(zh, path);
+    // session event's don't have paths
+    const char *client_path =
+        (type != ZOO_SESSION_EVENT ? sub_string(zh, path) : path);
     while(wo!=0){
         wo->watcher(zh,type,state,client_path,wo->context);
         wo=wo->next;
diff --git a/src/c/src/zookeeper.c b/src/c/src/zookeeper.c
index f751f63c0..52154314b 100644
--- a/src/c/src/zookeeper.c
+++ b/src/c/src/zookeeper.c
@@ -713,9 +713,9 @@ abort:
  * deallocated the free_path only its beeen allocated
  * and not equal to path
  */
-void free_duplicate_path(char *free_path, const char* path) {
+void free_duplicate_path(const char *free_path, const char* path) {
     if (free_path != path) {
-        free(free_path);
+        free((void*)free_path);
     }
 }
 
