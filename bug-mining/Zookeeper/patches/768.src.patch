diff --git a/CHANGES.txt b/CHANGES.txt
index 2acbd30c7..debd20954 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -349,6 +349,9 @@ BUGFIXES:
 
   Fix command handling in the C client shell (phunt via fpj)
 
+  ZOOKEEPER-2247: Zookeeper service becomes unavailable when leader
+  fails to write transaction log (Rakesh via fpj)
+
 IMPROVEMENTS:
   ZOOKEEPER-2024 Major throughput improvement with mixed workloads (Kfir Lev-Ari via shralex)
 
diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
index a82eb5104..d4f150b27 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java
@@ -102,8 +102,8 @@ public class ZooKeeperServer implements SessionExpirer, ServerStats.Provider {
     protected RequestProcessor firstProcessor;
     protected volatile State state = State.INITIAL;
 
-    enum State {
-        INITIAL, RUNNING, SHUTDOWN;
+    protected enum State {
+        INITIAL, RUNNING, SHUTDOWN, ERROR;
     }
 
     /**
@@ -122,7 +122,9 @@ enum State {
     protected ServerCnxnFactory secureServerCnxnFactory;
 
     private final ServerStats serverStats;
-    private final ZooKeeperServerListener listener = new ZooKeeperServerListenerImpl();
+    private final ZooKeeperServerListener listener;
+    private ZooKeeperServerShutdownHandler zkShutdownHandler;
+
     void removeCnxn(ServerCnxn cnxn) {
         zkDb.removeCnxn(cnxn);
     }
@@ -136,6 +138,7 @@ void removeCnxn(ServerCnxn cnxn) {
      */
     public ZooKeeperServer() {
         serverStats = new ServerStats(this);
+        listener = new ZooKeeperServerListenerImpl(this);
     }
 
     /**
@@ -152,7 +155,7 @@ public ZooKeeperServer(FileTxnSnapLog txnLogFactory, int tickTime,
         this.tickTime = tickTime;
         setMinSessionTimeout(minSessionTimeout);
         setMaxSessionTimeout(maxSessionTimeout);
-
+        listener = new ZooKeeperServerListenerImpl(this);
         LOG.info("Created server with tickTime " + tickTime
                 + " minSessionTimeout " + getMinSessionTimeout()
                 + " maxSessionTimeout " + getMaxSessionTimeout()
@@ -446,7 +449,7 @@ public synchronized void startup() {
 
         registerJMX();
 
-        state = State.RUNNING;
+        setState(State.RUNNING);
         notifyAll();
     }
 
@@ -463,20 +466,6 @@ public ZooKeeperServerListener getZooKeeperServerListener() {
         return listener;
     }
 
-    /**
-     * Default listener implementation, which will do a graceful shutdown on
-     * notification
-     */
-    private class ZooKeeperServerListenerImpl implements
-            ZooKeeperServerListener {
-
-        @Override
-        public void notifyStopping(String threadName, int exitCode) {
-            LOG.info("Thread {} exits, error code {}", threadName, exitCode);
-            shutdown();
-        }
-    }
-
     protected void createSessionTracker() {
         sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(),
                 tickTime, 1, getZooKeeperServerListener());
@@ -486,19 +475,61 @@ protected void startSessionTracker() {
         ((SessionTrackerImpl)sessionTracker).start();
     }
 
+    /**
+     * Sets the state of ZooKeeper server. After changing the state, it notifies
+     * the server state change to a registered shutdown handler, if any.
+     * <p>
+     * The following are the server state transitions:
+     * <li>During startup the server will be in the INITIAL state.</li>
+     * <li>After successfully starting, the server sets the state to RUNNING.
+     * </li>
+     * <li>The server transitions to the ERROR state if it hits an internal
+     * error. {@link ZooKeeperServerListenerImpl} notifies any critical resource
+     * error events, e.g., SyncRequestProcessor not being able to write a txn to
+     * disk.</li>
+     * <li>During shutdown the server sets the state to SHUTDOWN, which
+     * corresponds to the server not running.</li>
+     *
+     * @param state new server state.
+     */
+    protected void setState(State state) {
+        this.state = state;
+        // Notify server state changes to the registered shutdown handler, if any.
+        if (zkShutdownHandler != null) {
+            zkShutdownHandler.handle(state);
+        } else {
+            LOG.error("ZKShutdownHandler is not registered, so ZooKeeper server "
+                    + "won't take any action on ERROR or SHUTDOWN server state changes");
+        }
+    }
+
+    /**
+     * This can be used while shutting down the server to see whether the server
+     * is already shutdown or not.
+     *
+     * @return true if the server is running or server hits an error, false
+     *         otherwise.
+     */
+    protected boolean canShutdown() {
+        return state == State.RUNNING || state == State.ERROR;
+    }
+
+    /**
+     * @return true if the server is running, false otherwise.
+     */
     public boolean isRunning() {
         return state == State.RUNNING;
     }
 
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");
             return;
         }
         LOG.info("shutting down");
 
         // new RuntimeException("Calling shutdown").printStackTrace();
-        state = State.SHUTDOWN;
+        setState(State.SHUTDOWN);
         // Since sessionTracker and syncThreads poll we just have to
         // set running to false and they will detect it during the poll
         // interval.
@@ -1142,4 +1173,15 @@ public Map<Long, Set<Long>> getSessionExpiryMap() {
         return sessionTracker.getSessionExpiryMap();
     }
 
+    /**
+     * This method is used to register the ZooKeeperServerShutdownHandler to get
+     * server's error or shutdown state change notifications.
+     * {@link ZooKeeperServerShutdownHandler#handle(State)} will be called for
+     * every server state changes {@link #setState(State)}.
+     *
+     * @param zkShutdownHandler shutdown handler
+     */
+    void registerServerShutdownHandler(ZooKeeperServerShutdownHandler zkShutdownHandler) {
+        this.zkShutdownHandler = zkShutdownHandler;
+    }
 }
diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerListenerImpl.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerListenerImpl.java
new file mode 100644
index 000000000..08f493405
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerListenerImpl.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import org.apache.zookeeper.server.ZooKeeperServer.State;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Default listener implementation, which will be used to notify internal
+ * errors. For example, if some critical thread has stopped due to fatal errors,
+ * then it will get notifications and will change the state of ZooKeeper server
+ * to ERROR representing an error status.
+ */
+class ZooKeeperServerListenerImpl implements ZooKeeperServerListener {
+    private static final Logger LOG = LoggerFactory
+            .getLogger(ZooKeeperServerListenerImpl.class);
+
+    private final ZooKeeperServer zkServer;
+
+    ZooKeeperServerListenerImpl(ZooKeeperServer zkServer) {
+        this.zkServer = zkServer;
+    }
+
+    @Override
+    public void notifyStopping(String threadName, int exitCode) {
+        LOG.info("Thread {} exits, error code {}", threadName, exitCode);
+        zkServer.setState(State.ERROR);
+    }
+}
diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
index 7f21561df..885a5e16e 100644
--- a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerMain.java
@@ -19,6 +19,7 @@
 package org.apache.zookeeper.server;
 
 import java.io.IOException;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 import javax.management.JMException;
@@ -118,9 +119,15 @@ public void runFromConfig(ServerConfig config) throws IOException, AdminServerEx
             // run() in this thread.
             // create a file logger url from the command line args
             txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);
-            ZooKeeperServer zkServer = new ZooKeeperServer( txnLog,
+            final ZooKeeperServer zkServer = new ZooKeeperServer(txnLog,
                     config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, null);
 
+            // Registers shutdown handler which will be used to know the
+            // server error or shutdown state changes.
+            final CountDownLatch shutdownLatch = new CountDownLatch(1);
+            zkServer.registerServerShutdownHandler(
+                    new ZooKeeperServerShutdownHandler(shutdownLatch));
+
             // Start Admin server
             adminServer = AdminServerFactory.createAdminServer();
             adminServer.setZooKeeperServer(zkServer);
@@ -146,14 +153,19 @@ public void runFromConfig(ServerConfig config) throws IOException, AdminServerEx
             );
             containerManager.start();
 
+            // Watch status of ZooKeeper server. It will do a graceful shutdown
+            // if the server is not running or hits an internal error.
+            shutdownLatch.await();
+
+            shutdown();
+
             if (cnxnFactory != null) {
                 cnxnFactory.join();
             }
             if (secureCnxnFactory != null) {
                 secureCnxnFactory.join();
             }
-
-            if (zkServer.isRunning()) {
+            if (zkServer.canShutdown()) {
                 zkServer.shutdown();
             }
         } catch (InterruptedException e) {
@@ -180,9 +192,16 @@ protected void shutdown() {
             secureCnxnFactory.shutdown();
         }
         try {
-            adminServer.shutdown();
+            if (adminServer != null) {
+                adminServer.shutdown();
+            }
         } catch (AdminServerException e) {
             LOG.warn("Problem stopping AdminServer", e);
         }
     }
+
+    // VisibleForTesting
+    ServerCnxnFactory getCnxnFactory() {
+        return cnxnFactory;
+    }
 }
diff --git a/src/java/main/org/apache/zookeeper/server/ZooKeeperServerShutdownHandler.java b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerShutdownHandler.java
new file mode 100644
index 000000000..499cacb25
--- /dev/null
+++ b/src/java/main/org/apache/zookeeper/server/ZooKeeperServerShutdownHandler.java
@@ -0,0 +1,46 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.server;
+
+import java.util.concurrent.CountDownLatch;
+
+import org.apache.zookeeper.server.ZooKeeperServer.State;
+
+/**
+ * ZooKeeper server shutdown handler which will be used to handle ERROR or
+ * SHUTDOWN server state transitions, which in turn releases the associated
+ * shutdown latch.
+ */
+class ZooKeeperServerShutdownHandler {
+    private final CountDownLatch shutdownLatch;
+
+    ZooKeeperServerShutdownHandler(CountDownLatch shutdownLatch) {
+        this.shutdownLatch = shutdownLatch;
+    }
+
+    /**
+     * This will be invoked when the server transition to a new server state.
+     *
+     * @param state new server state
+     */
+    void handle(State state) {
+        if (state == State.ERROR || state == State.SHUTDOWN) {
+            shutdownLatch.countDown();
+        }
+    }
+}
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
index 64ec4591b..d0f1a72d6 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Follower.java
@@ -85,7 +85,7 @@ void followLeader() throws InterruptedException {
                 }
                 syncWithLeader(newEpochZxid);                
                 QuorumPacket qp = new QuorumPacket();
-                while (self.isRunning()) {
+                while (this.isRunning()) {
                     readPacket(qp);
                     processPacket(qp);
                 }
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
index c53641107..db3011438 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Leader.java
@@ -586,6 +586,12 @@ void lead() throws IOException, InterruptedException {
                         }
                     }
 
+                    // check leader running status
+                    if (!this.isRunning()) {
+                        shutdown("Unexpected internal error");
+                        return;
+                    }
+
                     if (!tickSkip && !syncedAckSet.hasAllQuorums()) {
                         // Lost quorum of last committed and/or last proposed
                         // config, set shutdown flag
@@ -1380,4 +1386,8 @@ public static String getPacketType(int packetType) {
             return "UNKNOWN";
         }
     }
+
+    private boolean isRunning() {
+        return self.isRunning() && zk.isRunning();
+    }
 }
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
index 362eef4c9..8527af51d 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Learner.java
@@ -622,4 +622,8 @@ public void shutdown() {
             zk.shutdown();
         }
     }
+
+    boolean isRunning() {
+        return self.isRunning() && zk.isRunning();
+    }
 }
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
index 45ae41616..1d4e8c8ab 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java
@@ -158,7 +158,7 @@ protected void unregisterJMX(Learner peer) {
 
     @Override
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");
             return;
         }
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
index 9a8ef0625..27368c752 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/Observer.java
@@ -23,13 +23,8 @@
 import java.nio.ByteBuffer;
 
 import org.apache.jute.Record;
-import org.apache.zookeeper.ZooDefs.OpCode;
 import org.apache.zookeeper.server.ObserverBean;
 import org.apache.zookeeper.server.Request;
-import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;
-import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;
-import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
-import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;
 import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;
 import org.apache.zookeeper.server.util.SerializeUtils;
 import org.apache.zookeeper.txn.SetDataTxn;
@@ -78,7 +73,7 @@ void observeLeader() throws Exception {
  
                 syncWithLeader(newLeaderZxid);
                 QuorumPacket qp = new QuorumPacket();
-                while (self.isRunning()) {
+                while (this.isRunning()) {
                     readPacket(qp);
                     processPacket(qp);
                 }
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
index 123a14984..bd2bcc079 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ObserverZooKeeperServer.java
@@ -132,7 +132,7 @@ public String getState() {
 
     @Override
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");
             return;
         }
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
index 52d8765eb..df7b40707 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/QuorumZooKeeperServer.java
@@ -156,4 +156,9 @@ public void dumpConf(PrintWriter pwriter) {
         pwriter.println("membership: ");
         pwriter.print(new String(self.getQuorumVerifier().toString().getBytes()));
     }
+
+    @Override
+    protected void setState(State state) {
+        this.state = state;
+    }
 }
diff --git a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
index bd8754b4d..2ef8a5e3e 100644
--- a/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
+++ b/src/java/main/org/apache/zookeeper/server/quorum/ReadOnlyZooKeeperServer.java
@@ -137,7 +137,7 @@ public long getServerId() {
 
     @Override
     public synchronized void shutdown() {
-        if (!isRunning()) {
+        if (!canShutdown()) {
             LOG.debug("ZooKeeper server is not running, so not proceeding to shutdown!");
             return;
         }
@@ -172,4 +172,9 @@ public void dumpConf(PrintWriter pwriter) {
         pwriter.print("peerType=");
         pwriter.println(self.getLearnerType().ordinal());
     }
+
+    @Override
+    protected void setState(State state) {
+        this.state = state;
+    }
 }
diff --git a/src/java/test/org/apache/zookeeper/server/ZooKeeperServerMainTest.java b/src/java/test/org/apache/zookeeper/server/ZooKeeperServerMainTest.java
index 29019d13a..9ab996cf7 100644
--- a/src/java/test/org/apache/zookeeper/server/ZooKeeperServerMainTest.java
+++ b/src/java/test/org/apache/zookeeper/server/ZooKeeperServerMainTest.java
@@ -19,6 +19,7 @@
 package org.apache.zookeeper.server;
 
 import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.fail;
 
 import java.io.File;
 import java.io.FileWriter;
@@ -124,6 +125,10 @@ void delete(File f) throws IOException {
                     throw new IOException("Failed to delete file: " + f);
                 }
         }
+
+        ServerCnxnFactory getCnxnFactory() {
+            return main.getCnxnFactory();
+        }
     }
 
     public static  class TestZKSMain extends ZooKeeperServerMain {
@@ -132,6 +137,63 @@ public void shutdown() {
         }
     }
 
+    /**
+     * Test case for https://issues.apache.org/jira/browse/ZOOKEEPER-2247.
+     * Test to verify that even after non recoverable error (error while
+     * writing transaction log), ZooKeeper is still available.
+     */
+    @Test(timeout = 30000)
+    public void testNonRecoverableError() throws Exception {
+        ClientBase.setupTestEnv();
+
+        final int CLIENT_PORT = PortAssignment.unique();
+
+        MainThread main = new MainThread(CLIENT_PORT, true, null);
+        main.start();
+
+        Assert.assertTrue("waiting for server being up",
+                ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT,
+                        CONNECTION_TIMEOUT));
+
+
+        ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT,
+                ClientBase.CONNECTION_TIMEOUT, this);
+
+        zk.create("/foo1", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+        Assert.assertEquals(new String(zk.getData("/foo1", null, null)), "foobar");
+
+        // inject problem in server
+        ZooKeeperServer zooKeeperServer = main.getCnxnFactory()
+                .getZooKeeperServer();
+        FileTxnSnapLog snapLog = zooKeeperServer.getTxnLogFactory();
+        FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(
+                snapLog.getDataDir(), snapLog.getSnapDir()) {
+            @Override
+            public void commit() throws IOException {
+                throw new IOException("Input/output error");
+            }
+        };
+        ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);
+        zooKeeperServer.setZKDatabase(newDB);
+
+        try {
+            // do create operation, so that injected IOException is thrown
+            zk.create("/foo2", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE,
+                    CreateMode.PERSISTENT);
+            fail("IOException is expected as error is injected in transaction log commit funtionality");
+        } catch (Exception e) {
+            // do nothing
+        }
+        zk.close();
+        Assert.assertTrue("waiting for server down",
+                ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT,
+                        ClientBase.CONNECTION_TIMEOUT));
+        fileTxnSnapLogWithError.close();
+        main.shutdown();
+        main.deleteDirs();
+    }
+
     /**
      * Verify the ability to start a standalone server instance.
      */
diff --git a/src/java/test/org/apache/zookeeper/test/NonRecoverableErrorTest.java b/src/java/test/org/apache/zookeeper/test/NonRecoverableErrorTest.java
new file mode 100644
index 000000000..31790d2ea
--- /dev/null
+++ b/src/java/test/org/apache/zookeeper/test/NonRecoverableErrorTest.java
@@ -0,0 +1,185 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.zookeeper.test;
+
+import static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+import java.util.UUID;
+
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.PortAssignment;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.server.ZKDatabase;
+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;
+import org.apache.zookeeper.server.quorum.QuorumPeer;
+import org.apache.zookeeper.server.quorum.QuorumPeer.ServerState;
+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;
+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;
+import org.junit.Assert;
+import org.junit.Test;
+
+/**
+ * This class tests the non-recoverable error behavior of quorum server.
+ */
+public class NonRecoverableErrorTest extends QuorumPeerTestBase {
+    private static final String NODE_PATH = "/noLeaderIssue";
+
+    /**
+     * Test case for https://issues.apache.org/jira/browse/ZOOKEEPER-2247.
+     * Test to verify that even after non recoverable error (error while
+     * writing transaction log), ZooKeeper is still available.
+     */
+    @Test(timeout = 30000)
+    public void testZooKeeperServiceAvailableOnLeader() throws Exception {
+        int SERVER_COUNT = 3;
+        final int clientPorts[] = new int[SERVER_COUNT];
+        StringBuilder sb = new StringBuilder();
+        String server;
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            clientPorts[i] = PortAssignment.unique();
+            server = "server." + i + "=127.0.0.1:" + PortAssignment.unique()
+                    + ":" + PortAssignment.unique() + ":participant;127.0.0.1:"
+                    + clientPorts[i];
+            sb.append(server + "\n");
+        }
+        String currentQuorumCfgSection = sb.toString();
+        MainThread mt[] = new MainThread[SERVER_COUNT];
+
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection,
+                    false);
+            mt[i].start();
+        }
+
+        // ensure server started
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            Assert.assertTrue("waiting for server " + i + " being up",
+                    ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i],
+                            CONNECTION_TIMEOUT));
+        }
+
+        CountdownWatcher watcher = new CountdownWatcher();
+        ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[0],
+                ClientBase.CONNECTION_TIMEOUT, watcher);
+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);
+
+        String data = "originalData";
+        zk.create(NODE_PATH, data.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                CreateMode.PERSISTENT);
+
+        // get information of current leader
+        QuorumPeer leader = getLeaderQuorumPeer(mt);
+        assertNotNull("Leader must have been elected by now", leader);
+
+        // inject problem in leader
+        FileTxnSnapLog snapLog = leader.getActiveServer().getTxnLogFactory();
+        FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(
+                snapLog.getDataDir(), snapLog.getSnapDir()) {
+            @Override
+            public void commit() throws IOException {
+                throw new IOException("Input/output error");
+            }
+        };
+        ZKDatabase originalZKDatabase = leader.getActiveServer()
+                .getZKDatabase();
+        long leaderCurrentEpoch = leader.getCurrentEpoch();
+
+        ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);
+        leader.getActiveServer().setZKDatabase(newDB);
+
+        try {
+            // do create operation, so that injected IOException is thrown
+            zk.create(uniqueZnode(), data.getBytes(), Ids.OPEN_ACL_UNSAFE,
+                    CreateMode.PERSISTENT);
+            fail("IOException is expected due to error injected to transaction log commit");
+        } catch (Exception e) {
+            // do nothing
+        }
+
+        // resetting watcher so that this watcher can be again used to ensure
+        // that the zkClient is able to re-establish connection with the
+        // newly elected zookeeper quorum.
+        watcher.reset();
+        waitForNewLeaderElection(leader, leaderCurrentEpoch);
+
+        // ensure server started, give enough time, so that new leader election
+        // takes place
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            Assert.assertTrue("waiting for server " + i + " being up",
+                    ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i],
+                            CONNECTION_TIMEOUT));
+        }
+
+        // revert back the error
+        leader.getActiveServer().setZKDatabase(originalZKDatabase);
+
+        // verify that now ZooKeeper service is up and running
+        leader = getLeaderQuorumPeer(mt);
+        assertNotNull("New leader must have been elected by now", leader);
+
+        String uniqueNode = uniqueZnode();
+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);
+        String createNode = zk.create(uniqueNode, data.getBytes(),
+                Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
+        // if node is created successfully then it means that ZooKeeper service
+        // is available
+        assertEquals("Failed to create znode", uniqueNode, createNode);
+        zk.close();
+        // stop all severs
+        for (int i = 0; i < SERVER_COUNT; i++) {
+            mt[i].shutdown();
+        }
+    }
+
+    private void waitForNewLeaderElection(QuorumPeer peer,
+            long leaderCurrentEpoch) throws IOException, InterruptedException {
+        LOG.info("Waiting for new LE cycle..");
+        int count = 100; // giving a grace period of 10seconds
+        while (count > 0) {
+            if (leaderCurrentEpoch == peer.getCurrentEpoch()) {
+                Thread.sleep(100);
+            }
+            count--;
+        }
+        Assert.assertNotEquals("New LE cycle must have triggered",
+                leaderCurrentEpoch, peer.getCurrentEpoch());
+    }
+
+    private QuorumPeer getLeaderQuorumPeer(MainThread[] mt) {
+        for (int i = mt.length - 1; i >= 0; i--) {
+            QuorumPeer quorumPeer = mt[i].getQuorumPeer();
+            if (null != quorumPeer
+                    && ServerState.LEADING == quorumPeer.getPeerState()) {
+                return quorumPeer;
+            }
+        }
+        return null;
+    }
+
+    private String uniqueZnode() {
+        UUID randomUUID = UUID.randomUUID();
+        String node = NODE_PATH + "/" + randomUUID.toString();
+        return node;
+    }
+}
