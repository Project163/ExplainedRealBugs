diff --git a/CHANGES.txt b/CHANGES.txt
index 4a9fbff32..69f68b936 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -55,6 +55,9 @@ BUGFIXES:
 
   ZOOKEEPER-251. NullPointerException stopping and starting Zookeeper servers
   (mahadev via phunt)
+
+  ZOOKEEPER-250. isvalidsnapshot should handle the case of 0 snapshot
+  files better. (mahadev via phunt)
   
 IMPROVEMENTS:
    
@@ -68,7 +71,8 @@ IMPROVEMENTS:
   (breed via phunt)
    
    ZOOKEEPER-247. fix formatting of C API in ACL section of programmer guide.
-(patrick hunt via mahadev)
+   (patrick hunt via mahadev)
+
 
 Release 3.0.0 - 2008-10-21
 
diff --git a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
index 059ea80f1..420619875 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/FileSnap.java
@@ -109,8 +109,15 @@ protected void deserialize(DataTree dt, Map<Long, Integer> sessions,
     public File findMostRecentSnapshot() throws IOException {
         List<File> files = Util.sortDataDir(snapDir.listFiles(), "snapshot", false);
         for (File f : files) {
-            if(Util.isValidSnapshot(f))
-                return f;
+            // we should catch the exceptions from 
+            // the valid snapshot and continue
+            // until we find a valid one
+            try {
+                if(Util.isValidSnapshot(f))
+                    return f;
+            } catch(IOException e) {
+                LOG.info("invalid snapshot " + f, e);
+            }
         }
         return null;
     }
diff --git a/src/java/main/org/apache/zookeeper/server/persistence/Util.java b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
index 1414f7c78..c20456a0f 100644
--- a/src/java/main/org/apache/zookeeper/server/persistence/Util.java
+++ b/src/java/main/org/apache/zookeeper/server/persistence/Util.java
@@ -162,6 +162,11 @@ public static boolean isValidSnapshot(File f) throws IOException {
 
         // Check for a valid snapshot
         RandomAccessFile raf = new RandomAccessFile(f, "r");
+        // including the header and the last / bytes
+        // the snapshot should be atleast 10 bytes
+        if (raf.length() < 10) {
+            return false;
+        }
         try {
             raf.seek(raf.length() - 5);
             byte bytes[] = new byte[5];
diff --git a/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java b/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
index 5e62d153c..c92aacb55 100644
--- a/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
+++ b/src/java/main/org/apache/zookeeper/server/upgrade/UpgradeSnapShotV1.java
@@ -224,8 +224,12 @@ private File findMostRecentSnapshot() throws IOException {
         List<File> files = Util.sortDataDir(snapShotDir.listFiles(),
                 "snapshot", false);
         for (File f: files) {
-            if (Util.isValidSnapshot(f))
-                return f;
+            try {
+                if (Util.isValidSnapshot(f))
+                    return f;
+            } catch(IOException e) {
+                LOG.info("Invalid snapshot " + f, e);
+            }
         }
         return null;
     }
diff --git a/src/java/test/org/apache/zookeeper/server/InvalidSnapshotTest.java b/src/java/test/org/apache/zookeeper/server/InvalidSnapshotTest.java
new file mode 100644
index 000000000..2ea78191c
--- /dev/null
+++ b/src/java/test/org/apache/zookeeper/server/InvalidSnapshotTest.java
@@ -0,0 +1,105 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.zookeeper.server;
+
+import java.io.File;
+import java.io.RandomAccessFile;
+
+import org.apache.log4j.Logger;
+import org.apache.zookeeper.CreateMode;
+import org.apache.zookeeper.WatchedEvent;
+import org.apache.zookeeper.Watcher;
+import org.apache.zookeeper.ZooKeeper;
+import org.apache.zookeeper.ZooDefs.Ids;
+import org.apache.zookeeper.test.ClientBase;
+
+import junit.framework.TestCase;
+
+/**
+ * this test checks that the server works 
+ * even if the last snapshot is invalidated
+ * by corruption or if the server crashes 
+ * while generating the snapshot.
+ */
+public class InvalidSnapshotTest extends TestCase implements Watcher {
+    private static final Logger LOG = Logger.getLogger(InvalidSnapshotTest.class);
+    private static String HOSTPORT = "127.0.0.1:2357";
+    ZooKeeperServer zks = null;
+    private static final int CONNECTION_TIMEOUT = 3000;
+    
+    @Override
+    protected void setUp() throws Exception {
+        ServerStats.registerAsConcrete();
+    }
+    
+    @Override
+    protected void tearDown() throws Exception {
+        ServerStats.unregister();
+    }
+    
+   
+    /**
+     * this test does the main work of testing 
+     * an invalid snapshot
+     * @throws Exception
+     */
+    public void testInvalidSnapshot() throws Exception {
+       File tmpDir = ClientBase.createTmpDir();
+       ClientBase.setupTestEnv();
+       zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+       SyncRequestProcessor.snapCount = 100;
+       final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);
+       NIOServerCnxn.Factory f = new NIOServerCnxn.Factory(PORT);
+       f.startup(zks);
+       assertTrue("waiting for server being up ", 
+               ClientBase.waitForServerUp(HOSTPORT,CONNECTION_TIMEOUT));
+       ZooKeeper zk = new ZooKeeper(HOSTPORT, 20000, this);
+       for (int i=0; i< 2000; i++) {
+           zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, 
+                   CreateMode.PERSISTENT);
+       }
+       f.shutdown();
+       assertTrue("waiting for server to shutdown",
+               ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));
+       // now corrupt the snapshot
+       File snapFile = zks.getTxnLogFactory().findMostRecentSnapshot();
+       RandomAccessFile raf = new RandomAccessFile(snapFile, "rws");
+       raf.setLength(3);
+       raf.close();
+       // now restart the server and see if it starts
+       zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);
+       SyncRequestProcessor.snapCount = 100;
+       f = new NIOServerCnxn.Factory(PORT);
+       f.startup(zks);
+       assertTrue("waiting for server being up ", 
+               ClientBase.waitForServerUp(HOSTPORT,CONNECTION_TIMEOUT));
+       // the server should come up
+       zk = new ZooKeeper(HOSTPORT, 20000, this);
+       assertTrue("the node should exist", (zk.exists("/invalidsnap-1999", false) != null));
+       f.shutdown();
+       assertTrue("waiting for server to shutdown",
+               ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));
+       
+    }
+    
+    public void process(WatchedEvent event) {
+        // do nothing for now
+    }
+    
+}
\ No newline at end of file
