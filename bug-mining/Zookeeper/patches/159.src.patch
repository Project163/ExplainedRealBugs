diff --git a/CHANGES.txt b/CHANGES.txt
index 0bf94f8a4..c0aeae3c4 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -82,6 +82,9 @@ BUGFIXES:
   ZOOKEEPER-538. zookeeper.async causes python to segfault
   (henry robinson via phunt)
 
+  ZOOKEEPER-542. c-client can spin when server unresponsive (Christian
+  Wiedmann via mahadev)
+ 
 IMPROVEMENTS:
   ZOOKEEPER-473. cleanup junit tests to eliminate false positives due to
   "socket reuse" and failure to close client (phunt via mahadev)
diff --git a/src/c/src/zookeeper.c b/src/c/src/zookeeper.c
index e9671c9c5..f55b4c009 100644
--- a/src/c/src/zookeeper.c
+++ b/src/c/src/zookeeper.c
@@ -1353,6 +1353,9 @@ static struct timeval get_timeval(int interval)
             rc = connect(zh->fd, &zh->addrs[zh->connect_index],
                     sizeof(struct sockaddr));
             if (rc == -1) {
+                /* we are handling the non-blocking connect according to
+                 * the description in section 16.3 "Non-blocking connect"
+                 * in UNIX Network Programming vol 1, 3rd edition */
                 if (errno == EWOULDBLOCK || errno == EINPROGRESS)
                     zh->state = ZOO_CONNECTING_STATE;
                 else
@@ -1412,7 +1415,10 @@ static struct timeval get_timeval(int interval)
             zh->next_deadline.tv_usec = zh->next_deadline.tv_usec % 1000000;
         }
         *interest = ZOOKEEPER_READ;
-        if (zh->to_send.head || zh->state == ZOO_CONNECTING_STATE) {
+        /* we are interested in a write if we are connected and have something
+         * to send, or we are waiting for a connect to finish. */
+        if ((zh->to_send.head && (zh->state == ZOO_CONNECTED_STATE))
+	    || zh->state == ZOO_CONNECTING_STATE) {
             *interest |= ZOOKEEPER_WRITE;
         }
     }
@@ -1427,6 +1433,9 @@ static int check_events(zhandle_t *zh, int events)
         int rc, error;
         socklen_t len = sizeof(error);
         rc = getsockopt(zh->fd, SOL_SOCKET, SO_ERROR, &error, &len);
+        /* the description in section 16.4 "Non-blocking connect"
+         * in UNIX Network Programming vol 1, 3rd edition, points out
+         * that sometimes the error is in errno and sometimes in error */
         if (rc < 0 || error) {
             if (rc == 0)
                 errno = error;
