diff --git a/src/recipes/lock/src/c/src/zoo_lock.c b/src/recipes/lock/src/c/src/zoo_lock.c
index 8a6d81763..74a115f79 100644
--- a/src/recipes/lock/src/c/src/zoo_lock.c
+++ b/src/recipes/lock/src/c/src/zoo_lock.c
@@ -93,7 +93,7 @@ ZOOAPI int zkr_lock_unlock(zkr_lock_mutex_t *mutex) {
         while (ret == ZCONNECTIONLOSS && (count < 3)) {
             ret = zoo_delete(zh, buf, -1);
             if (ret == ZCONNECTIONLOSS) {
-                LOG_DEBUG(("connectionloss while deleting the node"));
+                LOG_DEBUG(LOGCALLBACK(zh), ("connectionloss while deleting the node"));
                 nanosleep(&ts, 0);
                 count++;
             }
@@ -109,7 +109,7 @@ ZOOAPI int zkr_lock_unlock(zkr_lock_mutex_t *mutex) {
             pthread_mutex_unlock(&(mutex->pmutex));
             return 0;
         }
-        LOG_WARN(("not able to connect to server - giving up"));
+        LOG_WARN(LOGCALLBACK(zh), ("not able to connect to server - giving up"));
         pthread_mutex_unlock(&(mutex->pmutex));
         return ZCONNECTIONLOSS;
     }
@@ -176,7 +176,7 @@ static int retry_getchildren(zhandle_t *zh, char* path, struct String_vector *ve
     while (ret == ZCONNECTIONLOSS && count < retry) {
         ret = zoo_get_children(zh, path, 0, vector);
         if (ret == ZCONNECTIONLOSS) {
-            LOG_DEBUG(("connection loss to the server"));
+            LOG_DEBUG(LOGCALLBACK(zh), ("connection loss to the server"));
             nanosleep(ts, 0);
             count++;
         }
@@ -212,7 +212,7 @@ static int retry_zoowexists(zhandle_t *zh, char* path, watcher_fn watcher, void*
     while (ret == ZCONNECTIONLOSS && count < retry) {
         ret = zoo_wexists(zh, path, watcher, ctx, stat);
         if (ret == ZCONNECTIONLOSS) {
-            LOG_DEBUG(("connectionloss while setting watch on my predecessor"));
+            LOG_DEBUG(LOGCALLBACK(zh), ("connectionloss while setting watch on my predecessor"));
             nanosleep(ts, 0);
             count++;
         }
@@ -267,7 +267,7 @@ static int zkr_lock_operation(zkr_lock_mutex_t *mutex, struct timespec *ts) {
             // do not want to retry the create since 
             // we would end up creating more than one child
             if (ret != ZOK) {
-                LOG_WARN(("could not create zoo node %s", buf));
+                LOG_WARN(LOGCALLBACK(zh), ("could not create zoo node %s", buf));
                 return ret;
             }
             mutex->id = getName(retbuf);
@@ -277,7 +277,7 @@ static int zkr_lock_operation(zkr_lock_mutex_t *mutex, struct timespec *ts) {
             ret = ZCONNECTIONLOSS;
             ret = retry_getchildren(zh, path, vector, ts, retry);
             if (ret != ZOK) {
-                LOG_WARN(("could not connect to server"));
+                LOG_WARN(LOGCALLBACK(zh), ("could not connect to server"));
                 return ret;
             }
             //sort this list
@@ -299,7 +299,7 @@ static int zkr_lock_operation(zkr_lock_mutex_t *mutex, struct timespec *ts) {
                 // will keep waiting
                 if (ret != ZOK) {
                     free_String_vector(vector);
-                    LOG_WARN(("unable to watch my predecessor"));
+                    LOG_WARN(LOGCALLBACK(zh), ("unable to watch my predecessor"));
                     ret = zkr_lock_unlock(mutex);
                     while (ret == 0) {
                         //we have to give up our leadership
@@ -315,7 +315,7 @@ static int zkr_lock_operation(zkr_lock_mutex_t *mutex, struct timespec *ts) {
                 // this is the case when we are the owner 
                 // of the lock
                 if (strcmp(mutex->id, owner_id) == 0) {
-                    LOG_DEBUG(("got the zoo lock owner - %s", mutex->id));
+                    LOG_DEBUG(LOGCALLBACK(zh), ("got the zoo lock owner - %s", mutex->id));
                     mutex->isOwner = 1;
                     if (mutex->completion != NULL) {
                         mutex->completion(0, mutex->cbdata);
diff --git a/src/recipes/queue/src/c/include/zoo_queue.h b/src/recipes/queue/src/c/include/zoo_queue.h
index ccc4602f6..dccc7635d 100644
--- a/src/recipes/queue/src/c/include/zoo_queue.h
+++ b/src/recipes/queue/src/c/include/zoo_queue.h
@@ -100,7 +100,7 @@ ZOOAPI int zkr_queue_remove(zkr_queue_t *queue, char *buffer, int *buffer_len);
  * \param buffer_len a pointer to the length of the buffer
  * \return returns 0 (ZOK) and sets *buffer_len to the length of data written if successful. Otherwise it will set *buffer_len to -1 and return a zookeeper error code. 
  */
-ZOOAPI int zkr_queue_take(zkr_queue_t *queue, char *buffer, int *buffer_len);
+ZOOAPI int zkr_queue_take(zhandle_t *zh, zkr_queue_t *queue, char *buffer, int *buffer_len);
 
 /**
  * \brief destroys a zookeeper queue structure 
diff --git a/src/recipes/queue/src/c/src/zoo_queue.c b/src/recipes/queue/src/c/src/zoo_queue.c
index 89ec24b6e..d7cc5707e 100644
--- a/src/recipes/queue/src/c/src/zoo_queue.c
+++ b/src/recipes/queue/src/c/src/zoo_queue.c
@@ -292,7 +292,7 @@ static void take_latch_destroy_synchronized(take_latch_t *latch){
     pthread_mutex_unlock(mutex);
 }
 
-static void take_latch_setter_trigger_latch(take_latch_t *latch){
+static void take_latch_setter_trigger_latch(zhandle_t *zh, take_latch_t *latch){
     pthread_mutex_t *mutex = &(latch->queue->pmutex);
     pthread_mutex_lock(mutex);
     switch(latch->state){
@@ -303,7 +303,7 @@ static void take_latch_setter_trigger_latch(take_latch_t *latch){
         take_latch_destroy_unsafe(latch);
         break;
     case take_triggered:
-        LOG_DEBUG(("Error! Latch was triggered twice."));
+        LOG_DEBUG(LOGCALLBACK(zh), ("Error! Latch was triggered twice."));
         break;
     case take_waiting:
         pthread_cond_signal(&(latch->latch_condition));
@@ -312,7 +312,7 @@ static void take_latch_setter_trigger_latch(take_latch_t *latch){
     pthread_mutex_unlock(mutex);
 }
 
-static void take_latch_waiter_await(take_latch_t *latch){
+static void take_latch_waiter_await(zhandle_t *zh, take_latch_t *latch){
     pthread_mutex_t *mutex = &(latch->queue->pmutex);
     pthread_mutex_lock(mutex);
     switch(latch->state){
@@ -323,10 +323,10 @@ static void take_latch_waiter_await(take_latch_t *latch){
         take_latch_destroy_unsafe(latch);
         break;
     case take_waiting:
-        LOG_DEBUG(("Error! Called await twice."));
+        LOG_DEBUG(LOGCALLBACK(zh), ("Error! Called await twice."));
         break;
     case take_not_needed:
-        LOG_DEBUG(("Error! Waiting after marking not needed."));
+        LOG_DEBUG(LOGCALLBACK(zh), ("Error! Waiting after marking not needed."));
         break;
     case take_triggered:
         take_latch_destroy_unsafe(latch);
@@ -335,7 +335,7 @@ static void take_latch_waiter_await(take_latch_t *latch){
     pthread_mutex_unlock(mutex);
 }
 
-static void take_latch_waiter_mark_unneeded(take_latch_t *latch){
+static void take_latch_waiter_mark_unneeded(zhandle_t *zh, take_latch_t *latch){
     pthread_mutex_t *mutex = &(latch->queue->pmutex);
     pthread_mutex_lock(mutex);
     switch(latch->state){
@@ -343,10 +343,10 @@ static void take_latch_waiter_mark_unneeded(take_latch_t *latch){
         latch->state = take_not_needed;
         break;
     case take_waiting:
-        LOG_DEBUG(("Error! Can't mark unneeded after waiting."));
+        LOG_DEBUG(LOGCALLBACK(zh), ("Error! Can't mark unneeded after waiting."));
         break;
     case take_not_needed:
-        LOG_DEBUG(("Marked unneeded twice."));
+        LOG_DEBUG(LOGCALLBACK(zh), ("Marked unneeded twice."));
         break;
     case take_triggered:
         take_latch_destroy_unsafe(latch);
@@ -357,12 +357,12 @@ static void take_latch_waiter_mark_unneeded(take_latch_t *latch){
 
 static void take_watcher(zhandle_t *zh, int type, int state, const char *path, void *watcherCtx){
     take_latch_t *latch = (take_latch_t *) watcherCtx;
-    take_latch_setter_trigger_latch(latch);
+    take_latch_setter_trigger_latch(zh, latch);
 }
 
 
 
-ZOOAPI int zkr_queue_take(zkr_queue_t *queue, char *buffer, int *buffer_len){
+ZOOAPI int zkr_queue_take(zhandle_t *zh, zkr_queue_t *queue, char *buffer, int *buffer_len){
     int path_length = strlen(queue->path);
 take_attempt:    
     for(;;){
@@ -392,9 +392,9 @@ take_attempt:
             return get_children_rc;
         }
         if(stvector.count == 0){
-            take_latch_waiter_await(take_latch);
+            take_latch_waiter_await(zh, take_latch);
         }else{
-            take_latch_waiter_mark_unneeded(take_latch);
+            take_latch_waiter_mark_unneeded(zh, take_latch);
         }
 
         sort_children(vector);
