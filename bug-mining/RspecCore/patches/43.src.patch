diff --git a/features/example_groups/shared_example_group.feature b/features/example_groups/shared_example_group.feature
index 49838075..6a4c03d4 100644
--- a/features/example_groups/shared_example_group.feature
+++ b/features/example_groups/shared_example_group.feature
@@ -104,32 +104,36 @@ Feature: Shared example group
   Scenario: Passing parameters to a shared example group
     Given a file named "shared_example_group_params_spec.rb" with:
     """
-    shared_examples_for "a measurable object" do |measurement_method, measurement|
-      it "should return #{measurement} from ##{measurement_method}" do
-        subject.send(measurement_method).should == measurement
+    shared_examples_for "a measurable object" do |measurement, measurement_methods|
+      measurement_methods.each do |measurement_method|
+        it "should return #{measurement} from ##{measurement_method}" do
+          subject.send(measurement_method).should == measurement
+        end
       end
     end
 
     describe Array, "with 3 items" do
       subject { [1, 2, 3] }
-      it_should_behave_like "a measurable object", :size, 3
+      it_should_behave_like "a measurable object", 3, [:size, :length]
     end
 
     describe String, "of 6 characters" do
       subject { "FooBar" }
-      it_should_behave_like "a measurable object", :length, 6
+      it_should_behave_like "a measurable object", 6, [:size, :length]
     end
     """
     When I run "rspec shared_example_group_params_spec.rb --format documentation"
-    Then the output should contain "2 examples, 0 failures"
+    Then the output should contain "4 examples, 0 failures"
     And the output should contain:
       """
       Array with 3 items
         it should behave like a measurable object
           should return 3 from #size
+          should return 3 from #length
 
       String of 6 characters
         it should behave like a measurable object
+          should return 6 from #size
           should return 6 from #length
       """
 
diff --git a/lib/rspec/core/extensions/module_eval_with_args.rb b/lib/rspec/core/extensions/module_eval_with_args.rb
index d37621ba..864fe48a 100644
--- a/lib/rspec/core/extensions/module_eval_with_args.rb
+++ b/lib/rspec/core/extensions/module_eval_with_args.rb
@@ -11,42 +11,22 @@ module RSpec
           # If there are no args and the block doesn't expect any, there's no
           # need to fake module_exec with our hack below.
           # Notes:
-          #   * lambda { }.arity # => -1
-          #   * lambda { || }.arity # => 0
-          #   * lambda { |*a| }.arity # -1
+          #   * lambda {      }.arity # => -1
+          #   * lambda { ||   }.arity # =>  0
+          #   * lambda { |*a| }.arity # => -1
           return module_eval(&block) if block.arity < 1 && args.size.zero?
 
+          orig_singleton_methods = singleton_methods
           instance_eval_with_args(*args, &block)
 
           # The only difference between instance_eval and module_eval is static method defs.
           #   * `def foo` in instance_eval defines a singleton method on the instance
           #   * `def foo` in class/module_eval defines an instance method for the class/module
-          # Here we deal with this difference by defining instance methods on the
-          # class/module and removing the singleton definitions.
-          singleton_class = class << self; self; end
-          extract_static_instance_method_defs_from(block).each do |m_name, m_def|
-            define_method(m_name, &m_def)
-            singleton_class.send(:remove_method, m_name)
-          end
-        end
-
-        private
-
-        def extract_static_instance_method_defs_from(block)
-          klass = Class.new do
-            # swallow any missing class method errors;
-            # we only care to capture the raw method definitions here.
-            def self.method_missing(*a); end
-
-            # skip any dynamic method definitions
-            def self.define_method(*a); end
-
-            # run the block so our instance methods get defined
-            class_eval(&block)
-          end
-
-          instance = klass.new
-          klass.instance_methods(false).inject({}) { |h, m| h[m] = instance.method(m); h }
+          # Here we deal with this difference by defining an instance method for
+          # each new singleton method.
+          # This has the side effect of duplicating methods (all new class methods will
+          # become instance methods and vice versa), but I don't see a way around it...
+          (singleton_methods - orig_singleton_methods).each { |m| define_method(m, &method(m)) }
         end
       end
     end
diff --git a/spec/rspec/core/shared_example_group_spec.rb b/spec/rspec/core/shared_example_group_spec.rb
index 27aa696c..fc959c17 100644
--- a/spec/rspec/core/shared_example_group_spec.rb
+++ b/spec/rspec/core/shared_example_group_spec.rb
@@ -98,6 +98,23 @@ module RSpec::Core
 
           passed_params.should == { :param1 => :value1, :param2 => :value2 }
         end
+
+        it "adds shared instance methods to nested group" do
+          shared_examples_for("thing") do |param1|
+            def foo; end
+          end
+          group = ExampleGroup.describe('fake group')
+          shared_group = group.it_should_behave_like("thing", :a)
+          shared_group.public_instance_methods.map{|m| m.to_s}.should include("foo")
+        end
+
+        it "evals the shared example group only once" do
+          eval_count = 0
+          shared_examples_for("thing") { |p| eval_count += 1 }
+          group = ExampleGroup.describe('fake group')
+          shared_group = group.it_should_behave_like("thing", :a)
+          eval_count.should == 1
+        end
       end
 
       context "given a block" do
