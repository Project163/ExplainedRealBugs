diff --git a/lib/rspec/core/example_group.rb b/lib/rspec/core/example_group.rb
index dc473eed..603dd98e 100644
--- a/lib/rspec/core/example_group.rb
+++ b/lib/rspec/core/example_group.rb
@@ -17,7 +17,6 @@ module RSpec
 
       include MemoizedHelpers
       include Pending
-      include SharedExampleGroup
       extend SharedExampleGroup
 
       # @private
diff --git a/spec/rspec/core/shared_context_spec.rb b/spec/rspec/core/shared_context_spec.rb
index 9e39390d..d9bdf389 100644
--- a/spec/rspec/core/shared_context_spec.rb
+++ b/spec/rspec/core/shared_context_spec.rb
@@ -34,6 +34,8 @@ describe RSpec::SharedContext do
     expect(after_all_hook).to be_truthy
   end
 
+  include RSpec::Core::SharedExampleGroup::TopLevelDSL
+
   it "runs the before each hooks in configuration before those of the shared context" do
     ordered_hooks = []
     RSpec.configure do |c|
diff --git a/spec/rspec/core/shared_example_group_spec.rb b/spec/rspec/core/shared_example_group_spec.rb
index 3b665e12..282fa1f9 100644
--- a/spec/rspec/core/shared_example_group_spec.rb
+++ b/spec/rspec/core/shared_example_group_spec.rb
@@ -32,19 +32,24 @@ module RSpec::Core
 
     %w[share_examples_for shared_examples_for shared_examples shared_context].each do |shared_method_name|
       describe shared_method_name do
+        let(:group) { ExampleGroup.describe('example group') }
+
+        define_method :define_shared_group do |*args, &block|
+          group.send(shared_method_name, *args, &block)
+        end
+
         it "is exposed to the global namespace" do
           expect(Kernel).to respond_to(shared_method_name)
         end
 
         it "displays a warning when adding a second shared example group with the same name" do
-          group = ExampleGroup.describe('example group')
-          group.send(shared_method_name, 'some shared group') {}
+          define_shared_group('some shared group') {}
           original_declaration = [__FILE__, __LINE__ - 1].join(':')
 
           warning = nil
           Kernel.stub(:warn) { |msg| warning = msg }
 
-          group.send(shared_method_name, 'some shared group') {}
+          define_shared_group('some shared group') {}
           second_declaration = [__FILE__, __LINE__ - 1].join(':')
           expect(warning).to include('some shared group', original_declaration, second_declaration)
         end
@@ -59,8 +64,8 @@ module RSpec::Core
           context "given a #{type}" do
             it "captures the given #{type} and block in the collection of shared example groups" do
               implementation = lambda {}
-              send(shared_method_name, object, &implementation)
-              expect(SharedExampleGroup.registry.shared_example_groups[self][object]).to eq implementation
+              define_shared_group(object, &implementation)
+              expect(SharedExampleGroup.registry.shared_example_groups[group][object]).to eq implementation
             end
           end
         end
@@ -68,7 +73,7 @@ module RSpec::Core
         context "given a hash" do
           it "delegates extend on configuration" do
             implementation = Proc.new { def bar; 'bar'; end }
-            send(shared_method_name, :foo => :bar, &implementation)
+            define_shared_group(:foo => :bar, &implementation)
             a = RSpec.configuration.include_or_extend_modules.first
             expect(a[0]).to eq(:extend)
             expect(Class.new.extend(a[1]).new.bar).to eq('bar')
@@ -79,13 +84,13 @@ module RSpec::Core
         context "given a string and a hash" do
           it "captures the given string and block in the World's collection of shared example groups" do
             implementation = lambda {}
-            send(shared_method_name, "name", :foo => :bar, &implementation)
-            expect(SharedExampleGroup.registry.shared_example_groups[self]["name"]).to eq implementation
+            define_shared_group("name", :foo => :bar, &implementation)
+            expect(SharedExampleGroup.registry.shared_example_groups[group]["name"]).to eq implementation
           end
 
           it "delegates extend on configuration" do
             implementation = Proc.new { def bar; 'bar'; end }
-            send(shared_method_name, "name", :foo => :bar, &implementation)
+            define_shared_group("name", :foo => :bar, &implementation)
             a = RSpec.configuration.include_or_extend_modules.first
             expect(a[0]).to eq(:extend)
             expect(Class.new.extend(a[1]).new.bar).to eq('bar')
