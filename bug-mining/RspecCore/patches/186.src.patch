diff --git a/Changelog.md b/Changelog.md
index 7868768f..f6c90bbc 100644
--- a/Changelog.md
+++ b/Changelog.md
@@ -9,6 +9,9 @@ Enhancements
 * Add `subject!` that is the analog to `let!`. It defines an
   explicit subject and sets a `before` hook that will invoke
   the subject (Zubin Henner).
+* Fix `let` and `subject` declaration so that `super`
+  and `return` can be used in them, just like in a normal
+  method. (Myron Marston)
 
 Bug fixes
 
diff --git a/lib/rspec/core/let.rb b/lib/rspec/core/let.rb
index b3ab7c08..a5f024b1 100644
--- a/lib/rspec/core/let.rb
+++ b/lib/rspec/core/let.rb
@@ -2,6 +2,60 @@ module RSpec
   module Core
     module Let
 
+      # @api private
+      #
+      # Gets the LetDefinitions module. The module is mixed into
+      # the example group and is used to hold all let definitions.
+      # This is done so that the block passed to `let` can be
+      # forwarded directly on to `define_method`, so that all method
+      # constructs (including `super` and `return`) can be used in
+      # a `let` block.
+      #
+      # The memoization is provided by a method definition on the
+      # example group that supers to the LetDefinitions definition
+      # in order to get the value to memoize.
+      def self.module_for(example_group)
+        get_constant_or_yield(example_group, :LetDefinitions) do
+          # Expose `define_method` as a public method, so we can
+          # easily use it below.
+          mod = Module.new { public_class_method :define_method }
+          example_group.__send__(:include, mod)
+          example_group.const_set(:LetDefinitions, mod)
+          mod
+        end
+      end
+
+      if Module.method(:const_defined?).arity == 1 # for 1.8
+        # @api private
+        #
+        # Gets the named constant or yields.
+        # On 1.8, const_defined? / const_get do not take into
+        # account the inheritance hierarchy.
+        def self.get_constant_or_yield(example_group, name)
+          if example_group.const_defined?(name)
+            example_group.const_get(name)
+          else
+            yield
+          end
+        end
+      else
+        # @api private
+        #
+        # Gets the named constant or yields.
+        # On 1.9, const_defined? / const_get take into account the
+        # the inheritance by default, and accept an argument to
+        # disable this behavior. It's important that we don't
+        # consider inheritance here; each example group level that
+        # uses a `let` should get its own `LetDefinitions` module.
+        def self.get_constant_or_yield(example_group, name)
+          if example_group.const_defined?(name, (check_ancestors = false))
+            example_group.const_get(name, (check_ancestors = false))
+          else
+            yield
+          end
+        end
+      end
+
       module ExampleGroupMethods
         # Generates a method whose return value is memoized after the first
         # call. Useful for reducing duplication between examples that assign
@@ -29,8 +83,14 @@ module RSpec
         #     end
         #   end
         def let(name, &block)
+          # We have to pass the block directly to `define_method` to
+          # allow it to use method constructs like `super` and `return`.
+          ::RSpec::Core::Let.module_for(self).define_method(name, &block)
+
+          # Apply the memoization. The method has been defined in an ancestor
+          # module so we can use `super` here to get the value.
           define_method(name) do
-            __memoized.fetch(name) {|k| __memoized[k] = instance_eval(&block) }
+            __memoized.fetch(name) { |k| __memoized[k] = super() }
           end
         end
 
diff --git a/lib/rspec/core/subject.rb b/lib/rspec/core/subject.rb
index f2781425..249f8fee 100644
--- a/lib/rspec/core/subject.rb
+++ b/lib/rspec/core/subject.rb
@@ -192,12 +192,8 @@ module RSpec
         # @see ExampleMethods#subject
         # @see ExampleMethods#should
         def subject(name=nil, &block)
-          if name
-            let(name, &block)
-            subject { send name }
-          else
-            let(:subject, &block)
-          end
+          let(:subject, &block)
+          alias_method name, :subject if name
         end
 
         # Just like `subject`, except the block is invoked by an implicit `before`
diff --git a/spec/rspec/core/let_spec.rb b/spec/rspec/core/let_spec.rb
index f6ceab9e..174dd344 100644
--- a/spec/rspec/core/let_spec.rb
+++ b/spec/rspec/core/let_spec.rb
@@ -33,6 +33,33 @@ describe "#let" do
 
     @nil_value_count.should eq(1)
   end
+
+  let(:a_value) { "a string" }
+
+  context 'when overriding let in a nested context' do
+    let(:a_value) { super() + " (modified)" }
+
+    it 'can use `super` to reference the parent context value' do
+      expect(a_value).to eq("a string (modified)")
+    end
+  end
+
+  context 'when the declaration uses `return`' do
+    let(:value) do
+      return :early_exit if @early_exit
+      :late_exit
+    end
+
+    it 'can exit the let declaration early' do
+      @early_exit = true
+      expect(value).to eq(:early_exit)
+    end
+
+    it 'can get past a conditional `return` statement' do
+      @early_exit = false
+      expect(value).to eq(:late_exit)
+    end
+  end
 end
 
 describe "#let!" do
diff --git a/spec/rspec/core/subject_spec.rb b/spec/rspec/core/subject_spec.rb
index c5475cb3..2f5471a2 100644
--- a/spec/rspec/core/subject_spec.rb
+++ b/spec/rspec/core/subject_spec.rb
@@ -38,6 +38,22 @@ module RSpec::Core
         end
       end
 
+      it "can be overriden and super'd to from a nested group" do
+        outer_subject_value = inner_subject_value = nil
+
+        ExampleGroup.describe(Array) do
+          subject { super() << :parent_group }
+          example { outer_subject_value = subject }
+
+          context "nested" do
+            subject { super() << :child_group }
+            example { inner_subject_value = subject }
+          end
+        end.run
+
+        expect(outer_subject_value).to eq([:parent_group])
+        expect(inner_subject_value).to eq([:parent_group, :child_group])
+      end
     end
 
     describe "explicit subject" do
@@ -95,6 +111,16 @@ module RSpec::Core
 
           expect(subject_value).to eq([4, 5, 6])
         end
+
+        it "can be overriden and super'd to from a nested group" do
+          subject_value = nil
+          group.describe("Nested") do
+            subject { super() + [:override] }
+            example { subject_value = subject }
+          end.run
+
+          expect(subject_value).to eq([4, 5, 6, :override])
+        end
       end
 
       describe "with a name" do
@@ -131,6 +157,20 @@ module RSpec::Core
 
           expect(inner_subject_value).to eq(1)
         end
+
+        it 'can correctly use `super` in a nested context' do
+          inner_subject_value = nil
+
+          ExampleGroup.describe do
+            subject(:list) { [1, 2, 3] }
+            describe 'first' do
+              subject(:first_element) { super().first }
+              example { inner_subject_value = subject }
+            end
+          end.run
+
+          expect(inner_subject_value).to eq(1)
+        end
       end
     end
 
