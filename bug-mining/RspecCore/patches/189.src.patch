diff --git a/lib/rspec/core/memoized_helpers.rb b/lib/rspec/core/memoized_helpers.rb
index 3354c00f..4c4571d2 100644
--- a/lib/rspec/core/memoized_helpers.rb
+++ b/lib/rspec/core/memoized_helpers.rb
@@ -214,8 +214,18 @@ module RSpec
         #
         # @see MemoizedHelpers#should
         def subject(name=nil, &block)
-          let(:subject, &block)
-          alias_method name, :subject if name
+          if name
+            # Ensure `super()` within a named subject acts correctly...
+            mod = ::RSpec::Core::MemoizedHelpers.module_for(self, :NamedSubjectSuper)
+            mod.define_method(name) do
+              self.class.superclass.instance_method(:subject).bind(self).call
+            end
+
+            let(name, &block)
+            subject { __send__ name }
+          else
+            let(:subject, &block)
+          end
         end
 
         # Just like `subject`, except the block is invoked by an implicit `before`
@@ -379,13 +389,13 @@ module RSpec
       # The memoization is provided by a method definition on the
       # example group that supers to the LetDefinitions definition
       # in order to get the value to memoize.
-      def self.module_for(example_group)
-        get_constant_or_yield(example_group, :LetDefinitions) do
+      def self.module_for(example_group, const_name = :LetDefinitions)
+        get_constant_or_yield(example_group, const_name) do
           # Expose `define_method` as a public method, so we can
           # easily use it below.
           mod = Module.new { public_class_method :define_method }
           example_group.__send__(:include, mod)
-          example_group.const_set(:LetDefinitions, mod)
+          example_group.const_set(const_name, mod)
           mod
         end
       end
diff --git a/spec/rspec/core/memoized_helpers_spec.rb b/spec/rspec/core/memoized_helpers_spec.rb
index 93f70e5a..95a026c5 100644
--- a/spec/rspec/core/memoized_helpers_spec.rb
+++ b/spec/rspec/core/memoized_helpers_spec.rb
@@ -157,6 +157,42 @@ module RSpec::Core
           expect(inner_subject_value).to eq(1)
         end
 
+        it 'can continue to be referenced by the name even when an inner group redefines the subject' do
+          named_value = nil
+
+          ExampleGroup.describe do
+            subject(:named) { :outer }
+
+            describe "inner" do
+              subject { :inner }
+              example do
+                subject # so the inner subject method is run and memoized
+                named_value = self.named
+              end
+            end
+          end.run
+
+          expect(named_value).to eq(:outer)
+        end
+
+        it 'can continue to reference an inner subject after the outer subject name is referenced' do
+          subject_value = nil
+
+          ExampleGroup.describe do
+            subject(:named) { :outer }
+
+            describe "inner" do
+              subject { :inner }
+              example do
+                named # so the outer subject method is run and memoized
+                subject_value = self.subject
+              end
+            end
+          end.run
+
+          expect(subject_value).to eq(:inner)
+        end
+
         context 'when `super` is used' do
           it "delegates to the parent context's `subject`, not the named mehtod" do
             inner_subject_value = nil
