diff --git a/black.py b/black.py
index e55e4fe..ff4f098 100644
--- a/black.py
+++ b/black.py
@@ -1,5 +1,7 @@
 import ast
 import asyncio
+from abc import ABC, abstractmethod
+from collections import defaultdict
 from concurrent.futures import Executor, ProcessPoolExecutor
 from contextlib import contextmanager
 from datetime import datetime
@@ -33,6 +35,7 @@
     Sequence,
     Set,
     Tuple,
+    Type,
     TypeVar,
     Union,
     cast,
@@ -61,6 +64,8 @@
 DEFAULT_INCLUDES = r"\.pyi?$"
 CACHE_DIR = Path(user_cache_dir("black", version=__version__))
 
+STRING_PREFIX_CHARS: Final = "furbFURB"  # All possible string prefix characters.
+
 
 # types
 FileContent = str
@@ -68,11 +73,13 @@
 NewLine = str
 Depth = int
 NodeType = int
+ParserState = int
 LeafID = int
+StringID = int
 Priority = int
 Index = int
 LN = Union[Leaf, Node]
-SplitFunc = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
+Transformer = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
 Timestamp = float
 FileSize = int
 CacheInfo = Tuple[Timestamp, FileSize]
@@ -88,7 +95,11 @@ class NothingChanged(UserWarning):
     """Raised when reformatted code is the same as source."""
 
 
-class CannotSplit(Exception):
+class CannotTransform(Exception):
+    """Base class for errors raised by Transformers."""
+
+
+class CannotSplit(CannotTransform):
     """A readable split that fits the allotted line length is impossible."""
 
 
@@ -96,6 +107,34 @@ class InvalidInput(ValueError):
     """Raised when input source code fails all parse attempts."""
 
 
+T = TypeVar("T")
+E = TypeVar("E", bound=Exception)
+
+
+class Ok(Generic[T]):
+    def __init__(self, value: T) -> None:
+        self._value = value
+
+    def ok(self) -> T:
+        return self._value
+
+
+class Err(Generic[E]):
+    def __init__(self, e: E) -> None:
+        self._e = e
+
+    def err(self) -> E:
+        return self._e
+
+
+# The 'Result' return type is used to implement an error-handling model heavily
+# influenced by that used by the Rust programming language
+# (see https://doc.rust-lang.org/book/ch09-00-error-handling.html).
+Result = Union[Ok[T], Err[E]]
+TResult = Result[T, CannotTransform]  # (T)ransform Result
+TMatchResult = TResult[Index]
+
+
 class WriteBack(Enum):
     NO = 0
     YES = 1
@@ -294,26 +333,25 @@ def target_version_option_callback(
     callback=target_version_option_callback,
     multiple=True,
     help=(
-        "Python versions that should be supported by Black's output. [default: "
-        "per-file auto-detection]"
+        "Python versions that should be supported by Black's output. [default: per-file"
+        " auto-detection]"
     ),
 )
 @click.option(
     "--py36",
     is_flag=True,
     help=(
-        "Allow using Python 3.6-only syntax on all input files.  This will put "
-        "trailing commas in function signatures and calls also after *args and "
-        "**kwargs. Deprecated; use --target-version instead. "
-        "[default: per-file auto-detection]"
+        "Allow using Python 3.6-only syntax on all input files.  This will put trailing"
+        " commas in function signatures and calls also after *args and **kwargs."
+        " Deprecated; use --target-version instead. [default: per-file auto-detection]"
     ),
 )
 @click.option(
     "--pyi",
     is_flag=True,
     help=(
-        "Format all input files like typing stubs regardless of file extension "
-        "(useful when piping source on standard input)."
+        "Format all input files like typing stubs regardless of file extension (useful"
+        " when piping source on standard input)."
     ),
 )
 @click.option(
@@ -326,9 +364,9 @@ def target_version_option_callback(
     "--check",
     is_flag=True,
     help=(
-        "Don't write the files back, just return the status.  Return code 0 "
-        "means nothing would change.  Return code 1 means some files would be "
-        "reformatted.  Return code 123 means there was an internal error."
+        "Don't write the files back, just return the status.  Return code 0 means"
+        " nothing would change.  Return code 1 means some files would be reformatted."
+        " Return code 123 means there was an internal error."
     ),
 )
 @click.option(
@@ -346,11 +384,10 @@ def target_version_option_callback(
     type=str,
     default=DEFAULT_INCLUDES,
     help=(
-        "A regular expression that matches files and directories that should be "
-        "included on recursive searches.  An empty value means all files are "
-        "included regardless of the name.  Use forward slashes for directories on "
-        "all platforms (Windows, too).  Exclusions are calculated first, inclusions "
-        "later."
+        "A regular expression that matches files and directories that should be"
+        " included on recursive searches.  An empty value means all files are included"
+        " regardless of the name.  Use forward slashes for directories on all platforms"
+        " (Windows, too).  Exclusions are calculated first, inclusions later."
     ),
     show_default=True,
 )
@@ -359,10 +396,10 @@ def target_version_option_callback(
     type=str,
     default=DEFAULT_EXCLUDES,
     help=(
-        "A regular expression that matches files and directories that should be "
-        "excluded on recursive searches.  An empty value means no paths are excluded. "
-        "Use forward slashes for directories on all platforms (Windows, too).  "
-        "Exclusions are calculated first, inclusions later."
+        "A regular expression that matches files and directories that should be"
+        " excluded on recursive searches.  An empty value means no paths are excluded."
+        " Use forward slashes for directories on all platforms (Windows, too). "
+        " Exclusions are calculated first, inclusions later."
     ),
     show_default=True,
 )
@@ -371,8 +408,8 @@ def target_version_option_callback(
     "--quiet",
     is_flag=True,
     help=(
-        "Don't emit non-error messages to stderr. Errors are still emitted; "
-        "silence those with 2>/dev/null."
+        "Don't emit non-error messages to stderr. Errors are still emitted; silence"
+        " those with 2>/dev/null."
     ),
 )
 @click.option(
@@ -380,8 +417,8 @@ def target_version_option_callback(
     "--verbose",
     is_flag=True,
     help=(
-        "Also emit messages to stderr about files that were not changed or were "
-        "ignored due to --exclude=."
+        "Also emit messages to stderr about files that were not changed or were ignored"
+        " due to --exclude=."
     ),
 )
 @click.version_option(version=__version__)
@@ -436,8 +473,8 @@ def main(
             versions = set(target_version)
     elif py36:
         err(
-            "--py36 is deprecated and will be removed in a future version. "
-            "Use --target-version py36 instead."
+            "--py36 is deprecated and will be removed in a future version. Use"
+            " --target-version py36 instead."
         )
         versions = PY36_VERSIONS
     else:
@@ -802,8 +839,11 @@ def f(
         dst_contents.append(str(empty_line) * after)
         before, after = elt.maybe_empty_lines(current_line)
         dst_contents.append(str(empty_line) * before)
-        for line in split_line(
-            current_line, line_length=mode.line_length, features=split_line_features
+        for line in transform_line(
+            current_line,
+            line_length=mode.line_length,
+            normalize_strings=mode.string_normalization,
+            features=split_line_features,
         ):
             dst_contents.append(str(line))
     return "".join(dst_contents)
@@ -898,9 +938,6 @@ def lib2to3_unparse(node: Node) -> str:
     return code
 
 
-T = TypeVar("T")
-
-
 class Visitor(Generic[T]):
     """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
 
@@ -1592,6 +1629,13 @@ def is_complex_subscript(self, leaf: Leaf) -> bool:
             n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
         )
 
+    def clone(self) -> "Line":
+        return Line(
+            depth=self.depth,
+            inside_brackets=self.inside_brackets,
+            should_explode=self.should_explode,
+        )
+
     def __str__(self) -> str:
         """Render the line."""
         if not self:
@@ -1605,6 +1649,7 @@ def __str__(self) -> str:
             res += str(leaf)
         for comment in itertools.chain.from_iterable(self.comments.values()):
             res += str(comment)
+
         return res + "\n"
 
     def __bool__(self) -> bool:
@@ -2429,18 +2474,15 @@ def make_comment(content: str) -> str:
     return "#" + content
 
 
-def split_line(
+def transform_line(
     line: Line,
     line_length: int,
-    inner: bool = False,
+    normalize_strings: bool,
     features: Collection[Feature] = (),
 ) -> Iterator[Line]:
-    """Split a `line` into potentially many lines.
+    """Transform a `line`, potentially splitting it into many lines.
 
     They should fit in the allotted `line_length` but might not be able to.
-    `inner` signifies that there were a pair of brackets somewhere around the
-    current `line`, possibly transitively. This means we can fallback to splitting
-    by delimiters if the LHS/RHS don't yield any results.
 
     `features` are syntactical features that may be used in the output.
     """
@@ -2448,8 +2490,18 @@ def split_line(
         yield line
         return
 
-    line_str = str(line).strip("\n")
+    line_str = line_to_string(line)
+
+    def init_st(ST: Type[StringTransformer]) -> StringTransformer:
+        """Initialize StringTransformer"""
+        return ST(line_length, normalize_strings)
 
+    string_merge = init_st(StringMerger)
+    string_paren_strip = init_st(StringParenStripper)
+    string_split = init_st(StringSplitter)
+    string_paren_wrap = init_st(StringParenWrapper)
+
+    transformers: List[Transformer]
     if (
         not line.contains_uncollapsable_type_comments()
         and not line.should_explode
@@ -2459,12 +2511,10 @@ def split_line(
             or line.contains_unsplittable_type_ignore()
         )
     ):
-        yield line
-        return
-
-    split_funcs: List[SplitFunc]
-    if line.is_def:
-        split_funcs = [left_hand_split]
+        # Only apply basic string preprocessing, since lines shouldn't be split here.
+        transformers = [string_merge, string_paren_strip]
+    elif line.is_def:
+        transformers = [left_hand_split]
     else:
 
         def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:
@@ -2482,27 +2532,46 @@ def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:
             yield from right_hand_split(line, line_length=1, features=features)
 
         if line.inside_brackets:
-            split_funcs = [delimiter_split, standalone_comment_split, rhs]
+            transformers = [
+                string_merge,
+                string_paren_strip,
+                delimiter_split,
+                standalone_comment_split,
+                string_split,
+                string_paren_wrap,
+                rhs,
+            ]
         else:
-            split_funcs = [rhs]
-    for split_func in split_funcs:
+            transformers = [
+                string_merge,
+                string_paren_strip,
+                string_split,
+                string_paren_wrap,
+                rhs,
+            ]
+
+    for transform in transformers:
         # We are accumulating lines in `result` because we might want to abort
         # mission and return the original line in the end, or attempt a different
         # split altogether.
         result: List[Line] = []
         try:
-            for l in split_func(line, features):
+            for l in transform(line, features):
                 if str(l).strip("\n") == line_str:
-                    raise CannotSplit("Split function returned an unchanged result")
+                    raise CannotTransform(
+                        "Line transformer returned an unchanged result"
+                    )
 
                 result.extend(
-                    split_line(
-                        l, line_length=line_length, inner=True, features=features
+                    transform_line(
+                        l,
+                        line_length=line_length,
+                        normalize_strings=normalize_strings,
+                        features=features,
                     )
                 )
-        except CannotSplit:
+        except CannotTransform:
             continue
-
         else:
             yield from result
             break
@@ -2511,7 +2580,1938 @@ def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:
         yield line
 
 
-def left_hand_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
+@dataclass  # type: ignore
+class StringTransformer(ABC):
+    """
+    An implementation of the Transformer protocol that relies on its
+    subclasses overriding the template methods `do_match(...)` and
+    `do_transform(...)`.
+
+    This Transformer works exclusively on strings (for example, by merging
+    or splitting them).
+
+    The following sections can be found among the docstrings of each concrete
+    StringTransformer subclass.
+
+    Requirements:
+        Which requirements must be met of the given Line for this
+        StringTransformer to be applied?
+
+    Transformations:
+        If the given Line meets all of the above requirments, which string
+        transformations can you expect to be applied to it by this
+        StringTransformer?
+
+    Collaborations:
+        What contractual agreements does this StringTransformer have with other
+        StringTransfomers? Such collaborations should be eliminated/minimized
+        as much as possible.
+    """
+
+    line_length: int
+    normalize_strings: bool
+
+    @abstractmethod
+    def do_match(self, line: Line) -> TMatchResult:
+        """
+        Returns:
+            * Ok(string_idx) such that `line.leaves[string_idx]` is our target
+            string, if a match was able to be made.
+                OR
+            * Err(CannotTransform), if a match was not able to be made.
+        """
+
+    @abstractmethod
+    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
+        """
+        Yields:
+            * Ok(new_line) where new_line is the new transformed line.
+                OR
+            * Err(CannotTransform) if the transformation failed for some reason. The
+            `do_match(...)` template method should usually be used to reject
+            the form of the given Line, but in some cases it is difficult to
+            know whether or not a Line meets the StringTransformer's
+            requirements until the transformation is already midway.
+
+        Side Effects:
+            This method should NOT mutate @line directly, but it MAY mutate the
+            Line's underlying Node structure. (WARNING: If the underlying Node
+            structure IS altered, then this method should NOT be allowed to
+            yield an CannotTransform after that point.)
+        """
+
+    def __call__(self, line: Line, _features: Collection[Feature]) -> Iterator[Line]:
+        """
+        StringTransformer instances have a call signature that mirrors that of
+        the Transformer type.
+
+        Raises:
+            CannotTransform(...) if the concrete StringTransformer class is unable
+            to transform @line.
+        """
+        # Optimization to avoid calling `self.do_match(...)` when the line does
+        # not contain any string.
+        if not any(leaf.type == token.STRING for leaf in line.leaves):
+            raise CannotTransform("There are no strings in this line.")
+
+        match_result = self.do_match(line)
+
+        if isinstance(match_result, Err):
+            cant_transform = match_result.err()
+            raise CannotTransform(
+                f"The string transformer {self.__class__.__name__} does not recognize"
+                " this line as one that it can transform."
+            ) from cant_transform
+
+        string_idx = match_result.ok()
+
+        for line_result in self.do_transform(line, string_idx):
+            if isinstance(line_result, Err):
+                cant_transform = line_result.err()
+                raise CannotTransform(
+                    "StringTransformer failed while attempting to transform string."
+                ) from cant_transform
+            line = line_result.ok()
+            yield line
+
+
+@dataclass
+class CustomSplit:
+    """A custom (i.e. manual) string split.
+
+    A single CustomSplit instance represents a single substring.
+
+    Examples:
+        Consider the following string:
+        ```
+        "Hi there friend."
+        " This is a custom"
+        f" string {split}."
+        ```
+
+        This string will correspond to the following three CustomSplit instances:
+        ```
+        CustomSplit(False, 16)
+        CustomSplit(False, 17)
+        CustomSplit(True, 16)
+        ```
+    """
+
+    has_prefix: bool
+    break_idx: int
+
+
+class CustomSplitMapMixin:
+    """
+    This mixin class is used to map merged strings to a sequence of
+    CustomSplits, which will then be used to re-split the strings iff none of
+    the resultant substrings go over the configured max line length.
+    """
+
+    _Key = Tuple[StringID, str]
+    _CUSTOM_SPLIT_MAP: Dict[_Key, Tuple[CustomSplit, ...]] = defaultdict(tuple)
+
+    @staticmethod
+    def _get_key(string: str) -> "CustomSplitMapMixin._Key":
+        """
+        Returns:
+            A unique identifier that is used internally to map @string to a
+            group of custom splits.
+        """
+        return (id(string), string)
+
+    def add_custom_splits(
+        self, string: str, custom_splits: Iterable[CustomSplit]
+    ) -> None:
+        """Custom Split Map Setter Method
+
+        Side Effects:
+            Adds a mapping from @string to the custom splits @custom_splits.
+        """
+        key = self._get_key(string)
+        self._CUSTOM_SPLIT_MAP[key] = tuple(custom_splits)
+
+    def pop_custom_splits(self, string: str) -> List[CustomSplit]:
+        """Custom Split Map Getter Method
+
+        Returns:
+            * A list of the custom splits that are mapped to @string, if any
+            exist.
+                OR
+            * [], otherwise.
+
+        Side Effects:
+            Deletes the mapping between @string and its associated custom
+            splits (which are returned to the caller).
+        """
+        key = self._get_key(string)
+
+        custom_splits = self._CUSTOM_SPLIT_MAP[key]
+        del self._CUSTOM_SPLIT_MAP[key]
+
+        return list(custom_splits)
+
+    def has_custom_splits(self, string: str) -> bool:
+        """
+        Returns:
+            True iff @string is associated with a set of custom splits.
+        """
+        key = self._get_key(string)
+        return key in self._CUSTOM_SPLIT_MAP
+
+
+class StringMerger(CustomSplitMapMixin, StringTransformer):
+    """StringTransformer that merges strings together.
+
+    Requirements:
+        (A) The line contains adjacent strings such that at most one substring
+        has inline comments AND none of those inline comments are pragmas AND
+        the set of all substring prefixes is either of length 1 or equal to
+        {"", "f"} AND none of the substrings are raw strings (i.e. are prefixed
+        with 'r').
+            OR
+        (B) The line contains a string which uses line continuation backslashes.
+
+    Transformations:
+        Depending on which of the two requirements above where met, either:
+
+        (A) The string group associated with the target string is merged.
+            OR
+        (B) All line-continuation backslashes are removed from the target string.
+
+    Collaborations:
+        StringMerger provides custom split information to StringSplitter.
+    """
+
+    def do_match(self, line: Line) -> TMatchResult:
+        LL = line.leaves
+
+        is_valid_index = is_valid_index_factory(LL)
+
+        for (i, leaf) in enumerate(LL):
+            if (
+                leaf.type == token.STRING
+                and is_valid_index(i + 1)
+                and LL[i + 1].type == token.STRING
+            ):
+                return Ok(i)
+
+            if leaf.type == token.STRING and "\\\n" in leaf.value:
+                return Ok(i)
+
+        return TErr("This line has no strings that need merging.")
+
+    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
+        new_line = line
+        rblc_result = self.__remove_backslash_line_continuation_chars(
+            new_line, string_idx
+        )
+        if isinstance(rblc_result, Ok):
+            new_line = rblc_result.ok()
+
+        msg_result = self.__merge_string_group(new_line, string_idx)
+        if isinstance(msg_result, Ok):
+            new_line = msg_result.ok()
+
+        if isinstance(rblc_result, Err) and isinstance(msg_result, Err):
+            msg_cant_transform = msg_result.err()
+            rblc_cant_transform = rblc_result.err()
+            cant_transform = CannotTransform(
+                "StringMerger failed to merge any strings in this line."
+            )
+
+            # Chain the errors together using `__cause__`.
+            msg_cant_transform.__cause__ = rblc_cant_transform
+            cant_transform.__cause__ = msg_cant_transform
+
+            yield Err(cant_transform)
+        else:
+            yield Ok(new_line)
+
+    @staticmethod
+    def __remove_backslash_line_continuation_chars(
+        line: Line, string_idx: int
+    ) -> TResult[Line]:
+        """
+        Merge strings that were split across multiple lines using
+        line-continuation backslashes.
+
+        Returns:
+            Ok(new_line), if @line contains backslash line-continuation
+            characters.
+                OR
+            Err(CannotTransform), otherwise.
+        """
+        LL = line.leaves
+
+        string_leaf = LL[string_idx]
+        if not (
+            string_leaf.type == token.STRING
+            and "\\\n" in string_leaf.value
+            and not has_triple_quotes(string_leaf.value)
+        ):
+            return TErr(
+                f"String leaf {string_leaf} does not contain any backslash line"
+                " continuation characters."
+            )
+
+        new_line = line.clone()
+        new_line.comments = line.comments
+        append_leaves(new_line, line, LL)
+
+        new_string_leaf = new_line.leaves[string_idx]
+        new_string_leaf.value = new_string_leaf.value.replace("\\\n", "")
+
+        return Ok(new_line)
+
+    def __merge_string_group(self, line: Line, string_idx: int) -> TResult[Line]:
+        """
+        Merges string group (i.e. set of adjacent strings) where the first
+        string in the group is `line.leaves[string_idx]`.
+
+        Returns:
+            Ok(new_line), if ALL of the validation checks found in
+            __validate_msg(...) pass.
+                OR
+            Err(CannotTransform), otherwise.
+        """
+        LL = line.leaves
+
+        is_valid_index = is_valid_index_factory(LL)
+
+        vresult = self.__validate_msg(line, string_idx)
+        if isinstance(vresult, Err):
+            return vresult
+
+        # If the string group is wrapped inside an Atom node, we must make sure
+        # to later replace that Atom with our new (merged) string leaf.
+        atom_node = LL[string_idx].parent
+
+        # We will place BREAK_MARK in between every two substrings that we
+        # merge. We will then later go through our final result and use the
+        # various instances of BREAK_MARK we find to add the right values to
+        # the custom split map.
+        BREAK_MARK = "@@@@@ BLACK BREAKPOINT MARKER @@@@@"
+
+        QUOTE = LL[string_idx].value[-1]
+
+        def make_naked(string: str, string_prefix: str) -> str:
+            """Strip @string (i.e. make it a "naked" string)
+
+            Pre-conditions:
+                * assert_is_leaf_string(@string)
+
+            Returns:
+                A string that is identical to @string except that
+                @string_prefix has been stripped, the surrounding QUOTE
+                characters have been removed, and any remaining QUOTE
+                characters have been escaped.
+            """
+            assert_is_leaf_string(string)
+
+            RE_EVEN_BACKSLASHES = r"(?:(?<!\\)(?:\\\\)*)"
+            naked_string = string[len(string_prefix) + 1 : -1]
+            naked_string = re.sub(
+                "(" + RE_EVEN_BACKSLASHES + ")" + QUOTE, r"\1\\" + QUOTE, naked_string
+            )
+            return naked_string
+
+        # Holds the CustomSplit objects that will later be added to the custom
+        # split map.
+        custom_splits = []
+
+        # Temporary storage for the 'has_prefix' part of the CustomSplit objects.
+        prefix_tracker = []
+
+        # Sets the 'prefix' variable. This is the prefix that the final merged
+        # string will have.
+        next_str_idx = string_idx
+        prefix = ""
+        while (
+            not prefix
+            and is_valid_index(next_str_idx)
+            and LL[next_str_idx].type == token.STRING
+        ):
+            prefix = get_string_prefix(LL[next_str_idx].value)
+            next_str_idx += 1
+
+        # The next loop merges the string group. The final string will be
+        # contained in 'S'.
+        #
+        # The following convenience variables are used:
+        #
+        #   S: string
+        #   NS: naked string
+        #   SS: next string
+        #   NSS: naked next string
+        S = ""
+        NS = ""
+        num_of_strings = 0
+        next_str_idx = string_idx
+        while is_valid_index(next_str_idx) and LL[next_str_idx].type == token.STRING:
+            num_of_strings += 1
+
+            SS = LL[next_str_idx].value
+            next_prefix = get_string_prefix(SS)
+
+            # If this is an f-string group but this substring is not prefixed
+            # with 'f'...
+            if "f" in prefix and "f" not in next_prefix:
+                # Then we must escape any braces contained in this substring.
+                SS = re.subf(r"(\{|\})", "{1}{1}", SS)
+
+            NSS = make_naked(SS, next_prefix)
+
+            has_prefix = bool(next_prefix)
+            prefix_tracker.append(has_prefix)
+
+            S = prefix + QUOTE + NS + NSS + BREAK_MARK + QUOTE
+            NS = make_naked(S, prefix)
+
+            next_str_idx += 1
+
+        S_leaf = Leaf(token.STRING, S)
+        if self.normalize_strings:
+            normalize_string_quotes(S_leaf)
+
+        # Fill the 'custom_splits' list with the appropriate CustomSplit objects.
+        temp_string = S_leaf.value[len(prefix) + 1 : -1]
+        for has_prefix in prefix_tracker:
+            mark_idx = temp_string.find(BREAK_MARK)
+            assert (
+                mark_idx >= 0
+            ), "Logic error while filling the custom string breakpoint cache."
+
+            temp_string = temp_string[mark_idx + len(BREAK_MARK) :]
+            breakpoint_idx = mark_idx + (len(prefix) if has_prefix else 0) + 1
+            custom_splits.append(CustomSplit(has_prefix, breakpoint_idx))
+
+        string_leaf = Leaf(token.STRING, S_leaf.value.replace(BREAK_MARK, ""))
+
+        if atom_node is not None:
+            replace_child(atom_node, string_leaf)
+
+        # Build the final line ('new_line') that this method will later return.
+        new_line = line.clone()
+        for (i, leaf) in enumerate(LL):
+            if i == string_idx:
+                new_line.append(string_leaf)
+
+            if string_idx <= i < string_idx + num_of_strings:
+                for comment_leaf in line.comments_after(LL[i]):
+                    new_line.append(comment_leaf, preformatted=True)
+                continue
+
+            append_leaves(new_line, line, [leaf])
+
+        self.add_custom_splits(string_leaf.value, custom_splits)
+        return Ok(new_line)
+
+    @staticmethod
+    def __validate_msg(line: Line, string_idx: int) -> TResult[None]:
+        """Validate (M)erge (S)tring (G)roup
+
+        Transform-time string validation logic for __merge_string_group(...).
+
+        Returns:
+            * Ok(None), if ALL validation checks (listed below) pass.
+                OR
+            * Err(CannotTransform), if any of the following are true:
+                - The target string is not in a string group (i.e. it has no
+                  adjacent strings).
+                - The string group has more than one inline comment.
+                - The string group has an inline comment that appears to be a pragma.
+                - The set of all string prefixes in the string group is of
+                  length greater than one and is not equal to {"", "f"}.
+                - The string group consists of raw strings.
+        """
+        num_of_inline_string_comments = 0
+        set_of_prefixes = set()
+        num_of_strings = 0
+        for leaf in line.leaves[string_idx:]:
+            if leaf.type != token.STRING:
+                # If the string group is trailed by a comma, we count the
+                # comments trailing the comma to be one of the string group's
+                # comments.
+                if leaf.type == token.COMMA and id(leaf) in line.comments:
+                    num_of_inline_string_comments += 1
+                break
+
+            if has_triple_quotes(leaf.value):
+                return TErr("StringMerger does NOT merge multiline strings.")
+
+            num_of_strings += 1
+            prefix = get_string_prefix(leaf.value)
+            if "r" in prefix:
+                return TErr("StringMerger does NOT merge raw strings.")
+
+            set_of_prefixes.add(prefix)
+
+            if id(leaf) in line.comments:
+                num_of_inline_string_comments += 1
+                if contains_pragma_comment(line.comments[id(leaf)]):
+                    return TErr("Cannot merge strings which have pragma comments.")
+
+        if num_of_strings < 2:
+            return TErr(
+                f"Not enough strings to merge (num_of_strings={num_of_strings})."
+            )
+
+        if num_of_inline_string_comments > 1:
+            return TErr(
+                f"Too many inline string comments ({num_of_inline_string_comments})."
+            )
+
+        if len(set_of_prefixes) > 1 and set_of_prefixes != {"", "f"}:
+            return TErr(f"Too many different prefixes ({set_of_prefixes}).")
+
+        return Ok(None)
+
+
+class StringParenStripper(StringTransformer):
+    """StringTransformer that strips surrounding parentheses from strings.
+
+    Requirements:
+        The line contains a string which is surrounded by parentheses and:
+            - The target string is NOT the only argument to a function call).
+            - The RPAR is NOT followed by an attribute access (i.e. a dot).
+
+    Transformations:
+        The parentheses mentioned in the 'Requirements' section are stripped.
+
+    Collaborations:
+        StringParenStripper has its own inherent usefulness, but it is also
+        relied on to clean up the parentheses created by StringParenWrapper (in
+        the event that they are no longer needed).
+    """
+
+    def do_match(self, line: Line) -> TMatchResult:
+        LL = line.leaves
+
+        is_valid_index = is_valid_index_factory(LL)
+
+        for (idx, leaf) in enumerate(LL):
+            # Should be a string...
+            if leaf.type != token.STRING:
+                continue
+
+            # Should be preceded by a non-empty LPAR...
+            if (
+                not is_valid_index(idx - 1)
+                or LL[idx - 1].type != token.LPAR
+                or is_empty_lpar(LL[idx - 1])
+            ):
+                continue
+
+            # That LPAR should NOT be preceded by a function name or a closing
+            # bracket (which could be a function which returns a function or a
+            # list/dictionary that contains a function)...
+            if is_valid_index(idx - 2) and (
+                LL[idx - 2].type == token.NAME or LL[idx - 2].type in CLOSING_BRACKETS
+            ):
+                continue
+
+            string_idx = idx
+
+            # Skip the string trailer, if one exists.
+            string_parser = StringParser()
+            next_idx = string_parser.parse(LL, string_idx)
+
+            # Should be followed by a non-empty RPAR...
+            if (
+                is_valid_index(next_idx)
+                and LL[next_idx].type == token.RPAR
+                and not is_empty_rpar(LL[next_idx])
+            ):
+                # That RPAR should NOT be followed by a '.' symbol.
+                if is_valid_index(next_idx + 1) and LL[next_idx + 1].type == token.DOT:
+                    continue
+
+                return Ok(string_idx)
+
+        return TErr("This line has no strings wrapped in parens.")
+
+    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
+        LL = line.leaves
+
+        string_parser = StringParser()
+        rpar_idx = string_parser.parse(LL, string_idx)
+
+        for leaf in (LL[string_idx - 1], LL[rpar_idx]):
+            if line.comments_after(leaf):
+                yield TErr(
+                    "Will not strip parentheses which have comments attached to them."
+                )
+
+        new_line = line.clone()
+        new_line.comments = line.comments.copy()
+
+        append_leaves(new_line, line, LL[: string_idx - 1])
+
+        string_leaf = Leaf(token.STRING, LL[string_idx].value)
+        LL[string_idx - 1].remove()
+        replace_child(LL[string_idx], string_leaf)
+        new_line.append(string_leaf)
+
+        append_leaves(
+            new_line, line, LL[string_idx + 1 : rpar_idx] + LL[rpar_idx + 1 :],
+        )
+
+        LL[rpar_idx].remove()
+
+        yield Ok(new_line)
+
+
+class BaseStringSplitter(StringTransformer):
+    """
+    Abstract class for StringTransformers which transform a Line's strings by splitting
+    them or placing them on their own lines where necessary to avoid going over
+    the configured line length.
+
+    Requirements:
+        * The target string value is responsible for the line going over the
+        line length limit. It follows that after all of black's other line
+        split methods have been exhausted, this line (or one of the resulting
+        lines after all line splits are performed) would still be over the
+        line_length limit unless we split this string.
+            AND
+        * The target string is NOT a "pointless" string (i.e. a string that has
+        no parent or siblings).
+            AND
+        * The target string is not followed by an inline comment that appears
+        to be a pragma.
+            AND
+        * The target string is not a multiline (i.e. triple-quote) string.
+    """
+
+    @abstractmethod
+    def do_splitter_match(self, line: Line) -> TMatchResult:
+        """
+        BaseStringSplitter asks its clients to override this method instead of
+        `StringTransformer.do_match(...)`.
+
+        Follows the same protocol as `StringTransformer.do_match(...)`.
+
+        Refer to `help(StringTransformer.do_match)` for more information.
+        """
+
+    def do_match(self, line: Line) -> TMatchResult:
+        match_result = self.do_splitter_match(line)
+        if isinstance(match_result, Err):
+            return match_result
+
+        string_idx = match_result.ok()
+        vresult = self.__validate(line, string_idx)
+        if isinstance(vresult, Err):
+            return vresult
+
+        return match_result
+
+    def __validate(self, line: Line, string_idx: int) -> TResult[None]:
+        """
+        Checks that @line meets all of the requirements listed in this classes'
+        docstring. Refer to `help(BaseStringSplitter)` for a detailed
+        description of those requirements.
+
+        Returns:
+            * Ok(None), if ALL of the requirements are met.
+                OR
+            * Err(CannotTransform), if ANY of the requirements are NOT met.
+        """
+        LL = line.leaves
+
+        string_leaf = LL[string_idx]
+
+        max_string_length = self.__get_max_string_length(line, string_idx)
+        if len(string_leaf.value) <= max_string_length:
+            return TErr(
+                "The string itself is not what is causing this line to be too long."
+            )
+
+        if not string_leaf.parent or [L.type for L in string_leaf.parent.children] == [
+            token.STRING,
+            token.NEWLINE,
+        ]:
+            return TErr(
+                f"This string ({string_leaf.value}) appears to be pointless (i.e. has"
+                " no parent)."
+            )
+
+        if id(line.leaves[string_idx]) in line.comments and contains_pragma_comment(
+            line.comments[id(line.leaves[string_idx])]
+        ):
+            return TErr(
+                "Line appears to end with an inline pragma comment. Splitting the line"
+                " could modify the pragma's behavior."
+            )
+
+        if has_triple_quotes(string_leaf.value):
+            return TErr("We cannot split multiline strings.")
+
+        return Ok(None)
+
+    def __get_max_string_length(self, line: Line, string_idx: int) -> int:
+        """
+        Calculates the max string length used when attempting to determine
+        whether or not the target string is responsible for causing the line to
+        go over the line length limit.
+
+        WARNING: This method is tightly coupled to both StringSplitter and
+        (especially) StringParenWrapper. There is probably a better way to
+        accomplish what is being done here.
+
+        Returns:
+            max_string_length: such that `line.leaves[string_idx].value >
+            max_string_length` implies that the target string IS responsible
+            for causing this line to exceed the line length limit.
+        """
+        LL = line.leaves
+
+        is_valid_index = is_valid_index_factory(LL)
+
+        # We use the shorthand "WMA4" in comments to abbreviate "We must
+        # account for". When giving examples, we use STRING to mean some/any
+        # valid string.
+        #
+        # Finally, we use the following convenience variables:
+        #
+        #   P:  The leaf that is before the target string leaf.
+        #   N:  The leaf that is after the target string leaf.
+        #   NN: The leaf that is after N.
+
+        # WMA4 the whitespace at the beginning of the line.
+        offset = line.depth * 4
+
+        if is_valid_index(string_idx - 1):
+            p_idx = string_idx - 1
+            if (
+                LL[string_idx - 1].type == token.LPAR
+                and LL[string_idx - 1].value == ""
+                and string_idx >= 2
+            ):
+                # If the previous leaf is an empty LPAR placeholder, we should skip it.
+                p_idx -= 1
+
+            P = LL[p_idx]
+            if P.type == token.PLUS:
+                # WMA4 a space and a '+' character (e.g. `+ STRING`).
+                offset += 2
+
+            if P.type == token.COMMA:
+                # WMA4 a space, a comma, and a closing bracket [e.g. `), STRING`].
+                offset += 3
+
+            if P.type in [token.COLON, token.EQUAL, token.NAME]:
+                # This conditional branch is meant to handle dictionary keys,
+                # variable assignments, 'return STRING' statement lines, and
+                # 'else STRING' ternary expression lines.
+
+                # WMA4 a single space.
+                offset += 1
+
+                # WMA4 the lengths of any leaves that came before that space.
+                for leaf in LL[: p_idx + 1]:
+                    offset += len(str(leaf))
+
+        if is_valid_index(string_idx + 1):
+            N = LL[string_idx + 1]
+            if N.type == token.RPAR and N.value == "" and len(LL) > string_idx + 2:
+                # If the next leaf is an empty RPAR placeholder, we should skip it.
+                N = LL[string_idx + 2]
+
+            if N.type == token.COMMA:
+                # WMA4 a single comma at the end of the string (e.g `STRING,`).
+                offset += 1
+
+            if is_valid_index(string_idx + 2):
+                NN = LL[string_idx + 2]
+
+                if N.type == token.DOT and NN.type == token.NAME:
+                    # This conditional branch is meant to handle method calls invoked
+                    # off of a string literal up to and including the LPAR character.
+
+                    # WMA4 the '.' character.
+                    offset += 1
+
+                    if (
+                        is_valid_index(string_idx + 3)
+                        and LL[string_idx + 3].type == token.LPAR
+                    ):
+                        # WMA4 the left parenthesis character.
+                        offset += 1
+
+                    # WMA4 the length of the method's name.
+                    offset += len(NN.value)
+
+        has_comments = False
+        for comment_leaf in line.comments_after(LL[string_idx]):
+            if not has_comments:
+                has_comments = True
+                # WMA4 two spaces before the '#' character.
+                offset += 2
+
+            # WMA4 the length of the inline comment.
+            offset += len(comment_leaf.value)
+
+        max_string_length = self.line_length - offset
+        return max_string_length
+
+
+class StringSplitter(CustomSplitMapMixin, BaseStringSplitter):
+    """
+    StringTransformer that splits "atom" strings (i.e. strings which exist on
+    lines by themselves).
+
+    Requirements:
+        * The line consists ONLY of a single string (with the exception of a
+        '+' symbol which MAY exist at the start of the line), MAYBE a string
+        trailer, and MAYBE a trailing comma.
+            AND
+        * All of the requirements listed in BaseStringSplitter's docstring.
+
+    Transformations:
+        The string mentioned in the 'Requirements' section is split into as
+        many substrings as necessary to adhere to the configured line length.
+
+        In the final set of substrings, no substring should be smaller than
+        MIN_SUBSTR_SIZE characters.
+
+        The string will ONLY be split on spaces (i.e. each new substring should
+        start with a space).
+
+        If the string is an f-string, it will NOT be split in the middle of an
+        f-expression (e.g. in f"FooBar: {foo() if x else bar()}", {foo() if x
+        else bar()} is an f-expression).
+
+        If the string that is being split has an associated set of custom split
+        records and those custom splits will NOT result in any line going over
+        the configured line length, those custom splits are used. Otherwise the
+        string is split as late as possible (from left-to-right) while still
+        adhering to the transformation rules listed above.
+
+    Collaborations:
+        StringSplitter relies on StringMerger to construct the appropriate
+        CustomSplit objects and add them to the custom split map.
+    """
+
+    MIN_SUBSTR_SIZE = 6
+    # Matches an "f-expression" (e.g. {var}) that might be found in an f-string.
+    RE_FEXPR = r"""
+    (?<!\{)\{
+        (?:
+            [^\{\}]
+            | \{\{
+            | \}\}
+        )+?
+    (?<!\})(?:\}\})*\}(?!\})
+    """
+
+    def do_splitter_match(self, line: Line) -> TMatchResult:
+        LL = line.leaves
+
+        is_valid_index = is_valid_index_factory(LL)
+
+        idx = 0
+
+        # The first leaf MAY be a '+' symbol...
+        if is_valid_index(idx) and LL[idx].type == token.PLUS:
+            idx += 1
+
+        # The next/first leaf MAY be an empty LPAR...
+        if is_valid_index(idx) and is_empty_lpar(LL[idx]):
+            idx += 1
+
+        # The next/first leaf MUST be a string...
+        if not is_valid_index(idx) or LL[idx].type != token.STRING:
+            return TErr("Line does not start with a string.")
+
+        string_idx = idx
+
+        # Skip the string trailer, if one exists.
+        string_parser = StringParser()
+        idx = string_parser.parse(LL, string_idx)
+
+        # That string MAY be followed by an empty RPAR...
+        if is_valid_index(idx) and is_empty_rpar(LL[idx]):
+            idx += 1
+
+        # That string / empty RPAR leaf MAY be followed by a comma...
+        if is_valid_index(idx) and LL[idx].type == token.COMMA:
+            idx += 1
+
+        # But no more leaves are allowed...
+        if is_valid_index(idx):
+            return TErr("This line does not end with a string.")
+
+        return Ok(string_idx)
+
+    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
+        LL = line.leaves
+
+        QUOTE = LL[string_idx].value[-1]
+
+        is_valid_index = is_valid_index_factory(LL)
+        insert_str_child = insert_str_child_factory(LL[string_idx])
+
+        prefix = get_string_prefix(LL[string_idx].value)
+
+        # We MAY choose to drop the 'f' prefix from substrings that don't
+        # contain any f-expressions, but ONLY if the original f-string
+        # containes at least one f-expression. Otherwise, we will alter the AST
+        # of the program.
+        drop_pointless_f_prefix = ("f" in prefix) and re.search(
+            self.RE_FEXPR, LL[string_idx].value, re.VERBOSE
+        )
+
+        first_string_line = True
+        starts_with_plus = LL[0].type == token.PLUS
+
+        def line_needs_plus() -> bool:
+            return first_string_line and starts_with_plus
+
+        def maybe_append_plus(new_line: Line) -> None:
+            """
+            Side Effects:
+                If @line starts with a plus and this is the first line we are
+                constructing, this function appends a PLUS leaf to @new_line
+                and replaces the old PLUS leaf in the node structure. Otherwise
+                this function does nothing.
+            """
+            if line_needs_plus():
+                plus_leaf = Leaf(token.PLUS, "+")
+                replace_child(LL[0], plus_leaf)
+                new_line.append(plus_leaf)
+
+        ends_with_comma = (
+            is_valid_index(string_idx + 1) and LL[string_idx + 1].type == token.COMMA
+        )
+
+        def max_last_string() -> int:
+            """
+            Returns:
+                The max allowed length of the string value used for the last
+                line we will construct.
+            """
+            result = self.line_length
+            result -= line.depth * 4
+            result -= 1 if ends_with_comma else 0
+            result -= 2 if line_needs_plus() else 0
+            return result
+
+        # --- Calculate Max Break Index (for string value)
+        # We start with the line length limit
+        max_break_idx = self.line_length
+        # The last index of a string of length N is N-1.
+        max_break_idx -= 1
+        # Leading whitespace is not present in the string value (e.g. Leaf.value).
+        max_break_idx -= line.depth * 4
+        if max_break_idx < 0:
+            yield TErr(
+                f"Unable to split {LL[string_idx].value} at such high of a line depth:"
+                f" {line.depth}"
+            )
+            return
+
+        # Check if StringMerger registered any custom splits.
+        custom_splits = self.pop_custom_splits(LL[string_idx].value)
+        # We use them ONLY if none of them would produce lines that exceed the
+        # line limit.
+        use_custom_breakpoints = bool(
+            custom_splits
+            and all(csplit.break_idx <= max_break_idx for csplit in custom_splits)
+        )
+
+        # Temporary storage for the remaining chunk of the string line that
+        # can't fit onto the line currently being constructed.
+        rest_value = LL[string_idx].value
+
+        def more_splits_should_be_made() -> bool:
+            """
+            Returns:
+                True iff `rest_value` (the remaining string value from the last
+                split), should be split again.
+            """
+            if use_custom_breakpoints:
+                return len(custom_splits) > 1
+            else:
+                return len(rest_value) > max_last_string()
+
+        string_line_results: List[Ok[Line]] = []
+        while more_splits_should_be_made():
+            if use_custom_breakpoints:
+                # Custom User Split (manual)
+                csplit = custom_splits.pop(0)
+                break_idx = csplit.break_idx
+            else:
+                # Algorithmic Split (automatic)
+                max_bidx = max_break_idx - 2 if line_needs_plus() else max_break_idx
+                maybe_break_idx = self.__get_break_idx(rest_value, max_bidx)
+                if maybe_break_idx is None:
+                    # If we are unable to algorthmically determine a good split
+                    # and this string has custom splits registered to it, we
+                    # fall back to using them--which means we have to start
+                    # over from the beginning.
+                    if custom_splits:
+                        rest_value = LL[string_idx].value
+                        string_line_results = []
+                        first_string_line = True
+                        use_custom_breakpoints = True
+                        continue
+
+                    # Otherwise, we stop splitting here.
+                    break
+
+                break_idx = maybe_break_idx
+
+            # --- Construct `next_value`
+            next_value = rest_value[:break_idx] + QUOTE
+            if (
+                # Are we allowed to try to drop a pointless 'f' prefix?
+                drop_pointless_f_prefix
+                # If we are, will we be successful?
+                and next_value != self.__normalize_f_string(next_value, prefix)
+            ):
+                # If the current custom split did NOT originally use a prefix,
+                # then `csplit.break_idx` will be off by one after removing
+                # the 'f' prefix.
+                break_idx = (
+                    break_idx + 1
+                    if use_custom_breakpoints and not csplit.has_prefix
+                    else break_idx
+                )
+                next_value = rest_value[:break_idx] + QUOTE
+                next_value = self.__normalize_f_string(next_value, prefix)
+
+            # --- Construct `next_leaf`
+            next_leaf = Leaf(token.STRING, next_value)
+            insert_str_child(next_leaf)
+            self.__maybe_normalize_string_quotes(next_leaf)
+
+            # --- Construct `next_line`
+            next_line = line.clone()
+            maybe_append_plus(next_line)
+            next_line.append(next_leaf)
+            string_line_results.append(Ok(next_line))
+
+            rest_value = prefix + QUOTE + rest_value[break_idx:]
+            first_string_line = False
+
+        yield from string_line_results
+
+        if drop_pointless_f_prefix:
+            rest_value = self.__normalize_f_string(rest_value, prefix)
+
+        rest_leaf = Leaf(token.STRING, rest_value)
+        insert_str_child(rest_leaf)
+
+        # NOTE: I could not find a test case that verifies that the following
+        # line is actually necessary, but it seems to be. Otherwise we risk
+        # not normalizing the last substring, right?
+        self.__maybe_normalize_string_quotes(rest_leaf)
+
+        last_line = line.clone()
+        maybe_append_plus(last_line)
+
+        # If there are any leaves to the right of the target string...
+        if is_valid_index(string_idx + 1):
+            # We use `temp_value` here to determine how long the last line
+            # would be if we were to append all the leaves to the right of the
+            # target string to the last string line.
+            temp_value = rest_value
+            for leaf in LL[string_idx + 1 :]:
+                temp_value += str(leaf)
+                if leaf.type == token.LPAR:
+                    break
+
+            # Try to fit them all on the same line with the last substring...
+            if (
+                len(temp_value) <= max_last_string()
+                or LL[string_idx + 1].type == token.COMMA
+            ):
+                last_line.append(rest_leaf)
+                append_leaves(last_line, line, LL[string_idx + 1 :])
+                yield Ok(last_line)
+            # Otherwise, place the last substring on one line and everything
+            # else on a line below that...
+            else:
+                last_line.append(rest_leaf)
+                yield Ok(last_line)
+
+                non_string_line = line.clone()
+                append_leaves(non_string_line, line, LL[string_idx + 1 :])
+                yield Ok(non_string_line)
+        # Else the target string was the last leaf...
+        else:
+            last_line.append(rest_leaf)
+            last_line.comments = line.comments.copy()
+            yield Ok(last_line)
+
+    def __get_break_idx(self, string: str, max_break_idx: int) -> Optional[int]:
+        """
+        This method contains the algorithm that StringSplitter uses to
+        determine which character to split each string at.
+
+        Args:
+            @string: The substring that we are attempting to split.
+            @max_break_idx: The ideal break index. We will return this value if it
+            meets all the necessary conditions. In the likely event that it
+            doesn't we will try to find the closest index BELOW @max_break_idx
+            that does. If that fails, we will expand our search by also
+            considering all valid indices ABOVE @max_break_idx.
+
+        Pre-Conditions:
+            * assert_is_leaf_string(@string)
+            * 0 <= @max_break_idx < len(@string)
+
+        Returns:
+            break_idx, if an index is able to be found that meets all of the
+            conditions listed in the 'Transformations' section of this classes'
+            docstring.
+                OR
+            None, otherwise.
+        """
+        is_valid_index = is_valid_index_factory(string)
+
+        assert is_valid_index(max_break_idx)
+        assert_is_leaf_string(string)
+
+        _fexpr_slices: Optional[List[Tuple[Index, Index]]] = None
+
+        def fexpr_slices() -> Iterator[Tuple[Index, Index]]:
+            """
+            Yields:
+                All ranges of @string which, if @string were to be split there,
+                would result in the splitting of an f-expression (which is NOT
+                allowed).
+            """
+            nonlocal _fexpr_slices
+
+            if _fexpr_slices is None:
+                _fexpr_slices = []
+                for match in re.finditer(self.RE_FEXPR, string, re.VERBOSE):
+                    _fexpr_slices.append(match.span())
+
+            yield from _fexpr_slices
+
+        is_fstring = "f" in get_string_prefix(string)
+
+        def breaks_fstring_expression(i: Index) -> bool:
+            """
+            Returns:
+                True iff returning @i would result in the splitting of an
+                f-expression (which is NOT allowed).
+            """
+            if not is_fstring:
+                return False
+
+            for (start, end) in fexpr_slices():
+                if start <= i < end:
+                    return True
+
+            return False
+
+        def passes_all_checks(i: Index) -> bool:
+            """
+            Returns:
+                True iff ALL of the conditions listed in the 'Transformations'
+                section of this classes' docstring would be be met by returning @i.
+            """
+            is_space = string[i] == " "
+            is_big_enough = (
+                len(string[i:]) >= self.MIN_SUBSTR_SIZE
+                and len(string[:i]) >= self.MIN_SUBSTR_SIZE
+            )
+            return is_space and is_big_enough and not breaks_fstring_expression(i)
+
+        # First, we check all indices BELOW @max_break_idx.
+        break_idx = max_break_idx
+        while is_valid_index(break_idx - 1) and not passes_all_checks(break_idx):
+            break_idx -= 1
+
+        if not passes_all_checks(break_idx):
+            # If that fails, we check all indices ABOVE @max_break_idx.
+            #
+            # If we are able to find a valid index here, the next line is going
+            # to be longer than the specified line length, but it's probably
+            # better than doing nothing at all.
+            break_idx = max_break_idx + 1
+            while is_valid_index(break_idx + 1) and not passes_all_checks(break_idx):
+                break_idx += 1
+
+            if not is_valid_index(break_idx) or not passes_all_checks(break_idx):
+                return None
+
+        return break_idx
+
+    def __maybe_normalize_string_quotes(self, leaf: Leaf) -> None:
+        if self.normalize_strings:
+            normalize_string_quotes(leaf)
+
+    def __normalize_f_string(self, string: str, prefix: str) -> str:
+        """
+        Pre-Conditions:
+            * assert_is_leaf_string(@string)
+
+        Returns:
+            * If @string is an f-string that contains no f-expressions, we
+            return a string identical to @string except that the 'f' prefix
+            has been stripped and all double braces (i.e. '{{' or '}}') have
+            been normalized (i.e. turned into '{' or '}').
+                OR
+            * Otherwise, we return @string.
+        """
+        assert_is_leaf_string(string)
+
+        if "f" in prefix and not re.search(self.RE_FEXPR, string, re.VERBOSE):
+            new_prefix = prefix.replace("f", "")
+
+            temp = string[len(prefix) :]
+            temp = re.sub(r"\{\{", "{", temp)
+            temp = re.sub(r"\}\}", "}", temp)
+            new_string = temp
+
+            return f"{new_prefix}{new_string}"
+        else:
+            return string
+
+
+class StringParenWrapper(CustomSplitMapMixin, BaseStringSplitter):
+    """
+    StringTransformer that splits non-"atom" strings (i.e. strings that do not
+    exist on lines by themselves).
+
+    Requirements:
+        All of the requirements listed in BaseStringSplitter's docstring in
+        addition to the requirements listed below:
+
+        * The line is a return/yield statement, which returns/yields a string.
+            OR
+        * The line is part of a ternary expression (e.g. `x = y if cond else
+        z`) such that the line starts with `else <string>`, where <string> is
+        some string.
+            OR
+        * The line is an assert statement, which ends with a string.
+            OR
+        * The line is an assignment statement (e.g. `x = <string>` or `x +=
+        <string>`) such that the variable is being assigned the value of some
+        string.
+            OR
+        * The line is a dictionary key assignment where some valid key is being
+        assigned the value of some string.
+
+    Transformations:
+        The chosen string is wrapped in parentheses and then split at the LPAR.
+
+        We then have one line which ends with an LPAR and another line that
+        starts with the chosen string. The latter line is then split again at
+        the RPAR. This results in the RPAR (and possibly a trailing comma)
+        being placed on its own line.
+
+        NOTE: If any leaves exist to the right of the chosen string (except
+        for a trailing comma, which would be placed after the RPAR), those
+        leaves are placed inside the parentheses.  In effect, the chosen
+        string is not necessarily being "wrapped" by parentheses. We can,
+        however, count on the LPAR being placed directly before the chosen
+        string.
+
+        In other words, StringParenWrapper creates "atom" strings. These
+        can then be split again by StringSplitter, if necessary.
+
+    Collaborations:
+        In the event that a string line split by StringParenWrapper is
+        changed such that it no longer needs to be given its own line,
+        StringParenWrapper relies on StringParenStripper to clean up the
+        parentheses it created.
+    """
+
+    def do_splitter_match(self, line: Line) -> TMatchResult:
+        LL = line.leaves
+
+        string_idx = None
+        string_idx = string_idx or self._return_match(LL)
+        string_idx = string_idx or self._else_match(LL)
+        string_idx = string_idx or self._assert_match(LL)
+        string_idx = string_idx or self._assign_match(LL)
+        string_idx = string_idx or self._dict_match(LL)
+
+        if string_idx is not None:
+            string_value = line.leaves[string_idx].value
+            # If the string has no spaces...
+            if " " not in string_value:
+                # And will still violate the line length limit when split...
+                max_string_length = self.line_length - ((line.depth + 1) * 4)
+                if len(string_value) > max_string_length:
+                    # And has no associated custom splits...
+                    if not self.has_custom_splits(string_value):
+                        # Then we should NOT put this string on its own line.
+                        return TErr(
+                            "We do not wrap long strings in parentheses when the"
+                            " resultant line would still be over the specified line"
+                            " length and can't be split further by StringSplitter."
+                        )
+            return Ok(string_idx)
+
+        return TErr("This line does not contain any non-atomic strings.")
+
+    @staticmethod
+    def _return_match(LL: List[Leaf]) -> Optional[int]:
+        """
+        Returns:
+            string_idx such that @LL[string_idx] is equal to our target (i.e.
+            matched) string, if this line matches the return/yield statement
+            requirements listed in the 'Requirements' section of this classes'
+            docstring.
+                OR
+            None, otherwise.
+        """
+        # If this line is apart of a return/yield statement and the first leaf
+        # contains either the "return" or "yield" keywords...
+        if parent_type(LL[0]) in [syms.return_stmt, syms.yield_expr] and LL[
+            0
+        ].value in ["return", "yield"]:
+            is_valid_index = is_valid_index_factory(LL)
+
+            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1
+            # The next visible leaf MUST contain a string...
+            if is_valid_index(idx) and LL[idx].type == token.STRING:
+                return idx
+
+        return None
+
+    @staticmethod
+    def _else_match(LL: List[Leaf]) -> Optional[int]:
+        """
+        Returns:
+            string_idx such that @LL[string_idx] is equal to our target (i.e.
+            matched) string, if this line matches the ternary expression
+            requirements listed in the 'Requirements' section of this classes'
+            docstring.
+                OR
+            None, otherwise.
+        """
+        # If this line is apart of a ternary expression and the first leaf
+        # contains the "else" keyword...
+        if (
+            parent_type(LL[0]) == syms.test
+            and LL[0].type == token.NAME
+            and LL[0].value == "else"
+        ):
+            is_valid_index = is_valid_index_factory(LL)
+
+            idx = 2 if is_valid_index(1) and is_empty_par(LL[1]) else 1
+            # The next visible leaf MUST contain a string...
+            if is_valid_index(idx) and LL[idx].type == token.STRING:
+                return idx
+
+        return None
+
+    @staticmethod
+    def _assert_match(LL: List[Leaf]) -> Optional[int]:
+        """
+        Returns:
+            string_idx such that @LL[string_idx] is equal to our target (i.e.
+            matched) string, if this line matches the assert statement
+            requirements listed in the 'Requirements' section of this classes'
+            docstring.
+                OR
+            None, otherwise.
+        """
+        # If this line is apart of an assert statement and the first leaf
+        # contains the "assert" keyword...
+        if parent_type(LL[0]) == syms.assert_stmt and LL[0].value == "assert":
+            is_valid_index = is_valid_index_factory(LL)
+
+            for (i, leaf) in enumerate(LL):
+                # We MUST find a comma...
+                if leaf.type == token.COMMA:
+                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1
+
+                    # That comma MUST be followed by a string...
+                    if is_valid_index(idx) and LL[idx].type == token.STRING:
+                        string_idx = idx
+
+                        # Skip the string trailer, if one exists.
+                        string_parser = StringParser()
+                        idx = string_parser.parse(LL, string_idx)
+
+                        # But no more leaves are allowed...
+                        if not is_valid_index(idx):
+                            return string_idx
+
+        return None
+
+    @staticmethod
+    def _assign_match(LL: List[Leaf]) -> Optional[int]:
+        """
+        Returns:
+            string_idx such that @LL[string_idx] is equal to our target (i.e.
+            matched) string, if this line matches the assignment statement
+            requirements listed in the 'Requirements' section of this classes'
+            docstring.
+                OR
+            None, otherwise.
+        """
+        # If this line is apart of an expression statement or is a function
+        # argument AND the first leaf contains a variable name...
+        if (
+            parent_type(LL[0]) in [syms.expr_stmt, syms.argument, syms.power]
+            and LL[0].type == token.NAME
+        ):
+            is_valid_index = is_valid_index_factory(LL)
+
+            for (i, leaf) in enumerate(LL):
+                # We MUST find either an '=' or '+=' symbol...
+                if leaf.type in [token.EQUAL, token.PLUSEQUAL]:
+                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1
+
+                    # That symbol MUST be followed by a string...
+                    if is_valid_index(idx) and LL[idx].type == token.STRING:
+                        string_idx = idx
+
+                        # Skip the string trailer, if one exists.
+                        string_parser = StringParser()
+                        idx = string_parser.parse(LL, string_idx)
+
+                        # The next leaf MAY be a comma iff this line is apart
+                        # of a function argument...
+                        if (
+                            parent_type(LL[0]) == syms.argument
+                            and is_valid_index(idx)
+                            and LL[idx].type == token.COMMA
+                        ):
+                            idx += 1
+
+                        # But no more leaves are allowed...
+                        if not is_valid_index(idx):
+                            return string_idx
+
+        return None
+
+    @staticmethod
+    def _dict_match(LL: List[Leaf]) -> Optional[int]:
+        """
+        Returns:
+            string_idx such that @LL[string_idx] is equal to our target (i.e.
+            matched) string, if this line matches the dictionary key assignment
+            statement requirements listed in the 'Requirements' section of this
+            classes' docstring.
+                OR
+            None, otherwise.
+        """
+        # If this line is apart of a dictionary key assignment...
+        if syms.dictsetmaker in [parent_type(LL[0]), parent_type(LL[0].parent)]:
+            is_valid_index = is_valid_index_factory(LL)
+
+            for (i, leaf) in enumerate(LL):
+                # We MUST find a colon...
+                if leaf.type == token.COLON:
+                    idx = i + 2 if is_empty_par(LL[i + 1]) else i + 1
+
+                    # That colon MUST be followed by a string...
+                    if is_valid_index(idx) and LL[idx].type == token.STRING:
+                        string_idx = idx
+
+                        # Skip the string trailer, if one exists.
+                        string_parser = StringParser()
+                        idx = string_parser.parse(LL, string_idx)
+
+                        # That string MAY be followed by a comma...
+                        if is_valid_index(idx) and LL[idx].type == token.COMMA:
+                            idx += 1
+
+                        # But no more leaves are allowed...
+                        if not is_valid_index(idx):
+                            return string_idx
+
+        return None
+
+    def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:
+        LL = line.leaves
+
+        is_valid_index = is_valid_index_factory(LL)
+        insert_str_child = insert_str_child_factory(LL[string_idx])
+
+        comma_idx = len(LL) - 1
+        ends_with_comma = False
+        if LL[comma_idx].type == token.COMMA:
+            ends_with_comma = True
+
+        leaves_to_steal_comments_from = [LL[string_idx]]
+        if ends_with_comma:
+            leaves_to_steal_comments_from.append(LL[comma_idx])
+
+        # --- First Line
+        first_line = line.clone()
+        left_leaves = LL[:string_idx]
+
+        # We have to remember to account for (possibly invisible) LPAR and RPAR
+        # leaves that already wrapped the target string. If these leaves do
+        # exist, we will replace them with our own LPAR and RPAR leaves.
+        old_parens_exist = False
+        if left_leaves and left_leaves[-1].type == token.LPAR:
+            old_parens_exist = True
+            leaves_to_steal_comments_from.append(left_leaves[-1])
+            left_leaves.pop()
+
+        append_leaves(first_line, line, left_leaves)
+
+        lpar_leaf = Leaf(token.LPAR, "(")
+        if old_parens_exist:
+            replace_child(LL[string_idx - 1], lpar_leaf)
+        else:
+            insert_str_child(lpar_leaf)
+        first_line.append(lpar_leaf)
+
+        # We throw inline comments that were originally to the right of the
+        # target string to the top line. They will now be shown to the right of
+        # the LPAR.
+        for leaf in leaves_to_steal_comments_from:
+            for comment_leaf in line.comments_after(leaf):
+                first_line.append(comment_leaf, preformatted=True)
+
+        yield Ok(first_line)
+
+        # --- Middle (String) Line
+        # We only need to yield one (possibly too long) string line, since the
+        # `StringSplitter` will break it down further if necessary.
+        string_value = LL[string_idx].value
+        string_line = Line(
+            depth=line.depth + 1,
+            inside_brackets=True,
+            should_explode=line.should_explode,
+        )
+        string_leaf = Leaf(token.STRING, string_value)
+        insert_str_child(string_leaf)
+        string_line.append(string_leaf)
+
+        old_rpar_leaf = None
+        if is_valid_index(string_idx + 1):
+            right_leaves = LL[string_idx + 1 :]
+            if ends_with_comma:
+                right_leaves.pop()
+
+            if old_parens_exist:
+                assert (
+                    right_leaves and right_leaves[-1].type == token.RPAR
+                ), "Apparently, old parentheses do NOT exist?!"
+                old_rpar_leaf = right_leaves.pop()
+
+            append_leaves(string_line, line, right_leaves)
+
+        yield Ok(string_line)
+
+        # --- Last Line
+        last_line = line.clone()
+        last_line.bracket_tracker = first_line.bracket_tracker
+
+        new_rpar_leaf = Leaf(token.RPAR, ")")
+        if old_rpar_leaf is not None:
+            replace_child(old_rpar_leaf, new_rpar_leaf)
+        else:
+            insert_str_child(new_rpar_leaf)
+        last_line.append(new_rpar_leaf)
+
+        # If the target string ended with a comma, we place this comma to the
+        # right of the RPAR on the last line.
+        if ends_with_comma:
+            comma_leaf = Leaf(token.COMMA, ",")
+            replace_child(LL[comma_idx], comma_leaf)
+            last_line.append(comma_leaf)
+
+        yield Ok(last_line)
+
+
+class StringParser:
+    """
+    A state machine that aids in parsing a string's "trailer", which can be
+    either non-existant, an old-style formatting sequence (e.g. `% varX` or `%
+    (varX, varY)`), or a method-call / attribute access (e.g. `.format(varX,
+    varY)`).
+
+    NOTE: A new StringParser object MUST be instantiated for each string
+    trailer we need to parse.
+
+    Examples:
+        We shall assume that `line` equals the `Line` object that corresponds
+        to the following line of python code:
+        ```
+        x = "Some {}.".format("String") + some_other_string
+        ```
+
+        Furthermore, we will assume that `string_idx` is some index such that:
+        ```
+        assert line.leaves[string_idx].value == "Some {}."
+        ```
+
+        The following code snippet then holds:
+        ```
+        string_parser = StringParser()
+        idx = string_parser.parse(line.leaves, string_idx)
+        assert line.leaves[idx].type == token.PLUS
+        ```
+    """
+
+    DEFAULT_TOKEN = -1
+
+    # String Parser States
+    START = 1
+    DOT = 2
+    NAME = 3
+    PERCENT = 4
+    SINGLE_FMT_ARG = 5
+    LPAR = 6
+    RPAR = 7
+    DONE = 8
+
+    # Lookup Table for Next State
+    _goto: Dict[Tuple[ParserState, NodeType], ParserState] = {
+        # A string trailer may start with '.' OR '%'.
+        (START, token.DOT): DOT,
+        (START, token.PERCENT): PERCENT,
+        (START, DEFAULT_TOKEN): DONE,
+        # A '.' MUST be followed by an attribute or method name.
+        (DOT, token.NAME): NAME,
+        # A method name MUST be followed by an '(', whereas an attribute name
+        # is the last symbol in the string trailer.
+        (NAME, token.LPAR): LPAR,
+        (NAME, DEFAULT_TOKEN): DONE,
+        # A '%' symbol can be followed by an '(' or a single argument (e.g. a
+        # string or variable name).
+        (PERCENT, token.LPAR): LPAR,
+        (PERCENT, DEFAULT_TOKEN): SINGLE_FMT_ARG,
+        # If a '%' symbol is followed by a single argument, that argument is
+        # the last leaf in the string trailer.
+        (SINGLE_FMT_ARG, DEFAULT_TOKEN): DONE,
+        # If present, a ')' symbol is the last symbol in a string trailer.
+        # (NOTE: LPARS and nested RPARS are not included in this lookup table,
+        # since they are treated as a special case by the parsing logic in this
+        # classes' implementation.)
+        (RPAR, DEFAULT_TOKEN): DONE,
+    }
+
+    def __init__(self) -> None:
+        self._state = self.START
+        self._unmatched_lpars = 0
+
+    def parse(self, leaves: List[Leaf], string_idx: int) -> int:
+        """
+        Pre-conditions:
+            * @leaves[@string_idx].type == token.STRING
+
+        Returns:
+            The index directly after the last leaf which is apart of the string
+            trailer, if a "trailer" exists.
+                OR
+            @string_idx + 1, if no string "trailer" exists.
+        """
+        assert leaves[string_idx].type == token.STRING
+
+        idx = string_idx + 1
+        while idx < len(leaves) and self._next_state(leaves[idx]):
+            idx += 1
+        return idx
+
+    def _next_state(self, leaf: Leaf) -> bool:
+        """
+        Pre-conditions:
+            * On the first call to this function, @leaf MUST be the leaf that
+            was directly after the string leaf in question (e.g. if our target
+            string is `line.leaves[i]` then the first call to this method must
+            be `line.leaves[i + 1]`).
+            * On the next call to this function, the leaf paramater passed in
+            MUST be the leaf directly following @leaf.
+
+        Returns:
+            True iff @leaf is apart of the string's trailer.
+        """
+        # We ignore empty LPAR or RPAR leaves.
+        if is_empty_par(leaf):
+            return True
+
+        next_token = leaf.type
+        if next_token == token.LPAR:
+            self._unmatched_lpars += 1
+
+        current_state = self._state
+
+        # The LPAR parser state is a special case. We will return True until we
+        # find the matching RPAR token.
+        if current_state == self.LPAR:
+            if next_token == token.RPAR:
+                self._unmatched_lpars -= 1
+                if self._unmatched_lpars == 0:
+                    self._state = self.RPAR
+        # Otherwise, we use a lookup table to determine the next state.
+        else:
+            # If the lookup table matches the current state to the next
+            # token, we use the lookup table.
+            if (current_state, next_token) in self._goto:
+                self._state = self._goto[current_state, next_token]
+            else:
+                # Otherwise, we check if a the current state was assigned a
+                # default.
+                if (current_state, self.DEFAULT_TOKEN) in self._goto:
+                    self._state = self._goto[current_state, self.DEFAULT_TOKEN]
+                # If no default has been assigned, then this parser has a logic
+                # error.
+                else:
+                    raise RuntimeError(f"{self.__class__.__name__} LOGIC ERROR!")
+
+            if self._state == self.DONE:
+                return False
+
+        return True
+
+
+def TErr(err_msg: str) -> Err[CannotTransform]:
+    """(T)ransform Err
+
+    Convenience function used when working with the TResult type.
+    """
+    cant_transform = CannotTransform(err_msg)
+    return Err(cant_transform)
+
+
+def contains_pragma_comment(comment_list: List[Leaf]) -> bool:
+    """
+    Returns:
+        True iff one of the comments in @comment_list is a pragma used by one
+        of the more common static analysis tools for python (e.g. mypy, flake8,
+        pylint).
+    """
+    for comment in comment_list:
+        if comment.value.startswith(("# type:", "# noqa", "# pylint:")):
+            return True
+
+    return False
+
+
+def insert_str_child_factory(string_leaf: Leaf) -> Callable[[LN], None]:
+    """
+    Factory for a convenience function that is used to orphan @string_leaf
+    and then insert multiple new leaves into the same part of the node
+    structure that @string_leaf had originally occupied.
+
+    Examples:
+        Let `string_leaf = Leaf(token.STRING, '"foo"')` and `N =
+        string_leaf.parent`. Assume the node `N` has the following
+        original structure:
+
+        Node(
+            expr_stmt, [
+                Leaf(NAME, 'x'),
+                Leaf(EQUAL, '='),
+                Leaf(STRING, '"foo"'),
+            ]
+        )
+
+        We then run the code snippet shown below.
+        ```
+        insert_str_child = insert_str_child_factory(string_leaf)
+
+        lpar = Leaf(token.LPAR, '(')
+        insert_str_child(lpar)
+
+        bar = Leaf(token.STRING, '"bar"')
+        insert_str_child(bar)
+
+        rpar = Leaf(token.RPAR, ')')
+        insert_str_child(rpar)
+        ```
+
+        After which point, it follows that `string_leaf.parent is None` and
+        the node `N` now has the following structure:
+
+        Node(
+            expr_stmt, [
+                Leaf(NAME, 'x'),
+                Leaf(EQUAL, '='),
+                Leaf(LPAR, '('),
+                Leaf(STRING, '"bar"'),
+                Leaf(RPAR, ')'),
+            ]
+        )
+    """
+    string_parent = string_leaf.parent
+    string_child_idx = string_leaf.remove()
+
+    def insert_str_child(child: LN) -> None:
+        nonlocal string_child_idx
+
+        assert string_parent is not None
+        assert string_child_idx is not None
+
+        string_parent.insert_child(string_child_idx, child)
+        string_child_idx += 1
+
+    return insert_str_child
+
+
+def has_triple_quotes(string: str) -> bool:
+    """
+    Returns:
+        True iff @string starts with three quotation characters.
+    """
+    raw_string = string.lstrip(STRING_PREFIX_CHARS)
+    return raw_string[:3] in {'"""', "'''"}
+
+
+def parent_type(node: Optional[LN]) -> Optional[NodeType]:
+    """
+    Returns:
+        @node.parent.type, if @node is not None and has a parent.
+            OR
+        None, otherwise.
+    """
+    if node is None or node.parent is None:
+        return None
+
+    return node.parent.type
+
+
+def is_empty_par(leaf: Leaf) -> bool:
+    return is_empty_lpar(leaf) or is_empty_rpar(leaf)
+
+
+def is_empty_lpar(leaf: Leaf) -> bool:
+    return leaf.type == token.LPAR and leaf.value == ""
+
+
+def is_empty_rpar(leaf: Leaf) -> bool:
+    return leaf.type == token.RPAR and leaf.value == ""
+
+
+def is_valid_index_factory(seq: Sequence[Any]) -> Callable[[int], bool]:
+    """
+    Examples:
+        ```
+        my_list = [1, 2, 3]
+
+        is_valid_index = is_valid_index_factory(my_list)
+
+        assert is_valid_index(0)
+        assert is_valid_index(2)
+
+        assert not is_valid_index(3)
+        assert not is_valid_index(-1)
+        ```
+    """
+
+    def is_valid_index(idx: int) -> bool:
+        """
+        Returns:
+            True iff @idx is positive AND seq[@idx] does NOT raise an
+            IndexError.
+        """
+        return 0 <= idx < len(seq)
+
+    return is_valid_index
+
+
+def line_to_string(line: Line) -> str:
+    """Returns the string representation of @line.
+
+    WARNING: This is known to be computationally expensive.
+    """
+    return str(line).strip("\n")
+
+
+def append_leaves(new_line: Line, old_line: Line, leaves: List[Leaf]) -> None:
+    """
+    Append leaves (taken from @old_line) to @new_line, making sure to fix the
+    underlying Node structure where appropriate.
+
+    All of the leaves in @leaves are duplicated. The duplicates are then
+    appended to @new_line and used to replace their originals in the underlying
+    Node structure. Any comments attatched to the old leaves are reattached to
+    the new leaves.
+
+    Pre-conditions:
+        set(@leaves) is a subset of set(@old_line.leaves).
+    """
+    for old_leaf in leaves:
+        assert old_leaf in old_line.leaves
+
+        new_leaf = Leaf(old_leaf.type, old_leaf.value)
+        replace_child(old_leaf, new_leaf)
+        new_line.append(new_leaf)
+
+        for comment_leaf in old_line.comments_after(old_leaf):
+            new_line.append(comment_leaf, preformatted=True)
+
+
+def replace_child(old_child: LN, new_child: LN) -> None:
+    """
+    Side Effects:
+        * If @old_child.parent is set, replace @old_child with @new_child in
+        @old_child's underlying Node structure.
+            OR
+        * Otherwise, this function does nothing.
+    """
+    parent = old_child.parent
+    if not parent:
+        return
+
+    child_idx = old_child.remove()
+    if child_idx is not None:
+        parent.insert_child(child_idx, new_child)
+
+
+def get_string_prefix(string: str) -> str:
+    """
+    Pre-conditions:
+        * assert_is_leaf_string(@string)
+
+    Returns:
+        @string's prefix (e.g. '', 'r', 'f', or 'rf').
+    """
+    assert_is_leaf_string(string)
+
+    prefix = ""
+    prefix_idx = 0
+    while string[prefix_idx] in STRING_PREFIX_CHARS:
+        prefix += string[prefix_idx].lower()
+        prefix_idx += 1
+
+    return prefix
+
+
+def assert_is_leaf_string(string: str) -> None:
+    """
+    Checks the pre-condition that @string has the format that you would expect
+    of `leaf.value` where `leaf` is some Leaf such that `leaf.type ==
+    token.STRING`. A more precise description of the pre-conditions that are
+    checked are listed below.
+
+    Pre-conditions:
+        * @string starts with either ', ", <prefix>', or <prefix>" where
+        `set(<prefix>)` is some subset of `set(STRING_PREFIX_CHARS)`.
+        * @string ends with a quote character (' or ").
+
+    Raises:
+        AssertionError(...) if the pre-conditions listed above are not
+        satisfied.
+    """
+    dquote_idx = string.find('"')
+    squote_idx = string.find("'")
+    if -1 in [dquote_idx, squote_idx]:
+        quote_idx = max(dquote_idx, squote_idx)
+    else:
+        quote_idx = min(squote_idx, dquote_idx)
+
+    assert (
+        0 <= quote_idx < len(string) - 1
+    ), f"{string!r} is missing a starting quote character (' or \")."
+    assert string[-1] in (
+        "'",
+        '"',
+    ), f"{string!r} is missing an ending quote character (' or \")."
+    assert set(string[:quote_idx]).issubset(
+        set(STRING_PREFIX_CHARS)
+    ), f"{set(string[:quote_idx])} is NOT a subset of {set(STRING_PREFIX_CHARS)}."
+
+
+def left_hand_split(line: Line, _features: Collection[Feature] = ()) -> Iterator[Line]:
     """Split line into many lines, starting with the first matching bracket pair.
 
     Note: this usually looks weird, only use this for function definitions.
@@ -2623,10 +4623,10 @@ def right_hand_split(
 
             elif head.contains_multiline_strings() or tail.contains_multiline_strings():
                 raise CannotSplit(
-                    "The current optional pair of parentheses is bound to fail to "
-                    "satisfy the splitting algorithm because the head or the tail "
-                    "contains multiline strings which by definition never fit one "
-                    "line."
+                    "The current optional pair of parentheses is bound to fail to"
+                    " satisfy the splitting algorithm because the head or the tail"
+                    " contains multiline strings which by definition never fit one"
+                    " line."
                 )
 
     ensure_visible(opening_bracket)
@@ -2657,8 +4657,8 @@ def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None
 
         elif tail_len < 3:
             raise CannotSplit(
-                f"Splitting brackets on an empty body to save "
-                f"{tail_len} characters is not worth it"
+                f"Splitting brackets on an empty body to save {tail_len} characters is"
+                " not worth it"
             )
 
 
@@ -2704,7 +4704,7 @@ def bracket_split_build_line(
     return result
 
 
-def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
+def dont_increase_indentation(split_func: Transformer) -> Transformer:
     """Normalize prefix of the first leaf in every line returned by `split_func`.
 
     This is a decorator over relevant split functions.
@@ -2867,7 +4867,7 @@ def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
 
     Note: Mutates its argument.
     """
-    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
+    match = re.match(r"^([" + STRING_PREFIX_CHARS + r"]*)(.*)$", leaf.value, re.DOTALL)
     assert match is not None, f"failed to match string {leaf.value!r}"
     orig_prefix = match.group(1)
     new_prefix = orig_prefix.replace("F", "f").replace("B", "b").replace("U", "u")
@@ -2884,7 +4884,7 @@ def normalize_string_quotes(leaf: Leaf) -> None:
 
     Note: Mutates its argument.
     """
-    value = leaf.value.lstrip("furbFURB")
+    value = leaf.value.lstrip(STRING_PREFIX_CHARS)
     if value[:3] == '"""':
         return
 
@@ -3012,6 +5012,11 @@ def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
             return
     check_lpar = False
     for index, child in enumerate(list(node.children)):
+        # Fixes a bug where invisible parens are not properly stripped from
+        # assignment statements that contain type annotations.
+        if isinstance(child, Node) and child.type == syms.annassign:
+            normalize_invisible_parens(child, parens_after=parens_after)
+
         # Add parentheses around long tuple unpacking in assignments.
         if (
             index == 0
@@ -3325,8 +5330,7 @@ def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:
 
 def is_multiline_string(leaf: Leaf) -> bool:
     """Return True if `leaf` is a multiline string that actually spans many lines."""
-    value = leaf.value.lstrip("furbFURB")
-    return value[:3] in {'"""', "'''"} and "\n" in value
+    return has_triple_quotes(leaf.value) and "\n" in leaf.value
 
 
 def is_stub_suite(node: Node) -> bool:
@@ -3846,8 +5850,8 @@ def _v(node: Union[ast.AST, ast3.AST, ast27.AST], depth: int = 0) -> Iterator[st
         src_ast = parse_ast(src)
     except Exception as exc:
         raise AssertionError(
-            f"cannot use --safe with this file; failed to parse source file.  "
-            f"AST error message: {exc}"
+            "cannot use --safe with this file; failed to parse source file.  AST"
+            f" error message: {exc}"
         )
 
     try:
@@ -3855,9 +5859,9 @@ def _v(node: Union[ast.AST, ast3.AST, ast27.AST], depth: int = 0) -> Iterator[st
     except Exception as exc:
         log = dump_to_file("".join(traceback.format_tb(exc.__traceback__)), dst)
         raise AssertionError(
-            f"INTERNAL ERROR: Black produced invalid code: {exc}. "
-            f"Please report a bug on https://github.com/psf/black/issues.  "
-            f"This invalid output might be helpful: {log}"
+            f"INTERNAL ERROR: Black produced invalid code: {exc}. Please report a bug"
+            " on https://github.com/psf/black/issues.  This invalid output might be"
+            f" helpful: {log}"
         ) from None
 
     src_ast_str = "\n".join(_v(src_ast))
@@ -3865,10 +5869,9 @@ def _v(node: Union[ast.AST, ast3.AST, ast27.AST], depth: int = 0) -> Iterator[st
     if src_ast_str != dst_ast_str:
         log = dump_to_file(diff(src_ast_str, dst_ast_str, "src", "dst"))
         raise AssertionError(
-            f"INTERNAL ERROR: Black produced code that is not equivalent to "
-            f"the source.  "
-            f"Please report a bug on https://github.com/psf/black/issues.  "
-            f"This diff might be helpful: {log}"
+            "INTERNAL ERROR: Black produced code that is not equivalent to the"
+            " source.  Please report a bug on https://github.com/psf/black/issues. "
+            f" This diff might be helpful: {log}"
         ) from None
 
 
@@ -3881,10 +5884,9 @@ def assert_stable(src: str, dst: str, mode: Mode) -> None:
             diff(dst, newdst, "first pass", "second pass"),
         )
         raise AssertionError(
-            f"INTERNAL ERROR: Black produced different code on the second pass "
-            f"of the formatter.  "
-            f"Please report a bug on https://github.com/psf/black/issues.  "
-            f"This diff might be helpful: {log}"
+            "INTERNAL ERROR: Black produced different code on the second pass of the"
+            " formatter.  Please report a bug on https://github.com/psf/black/issues."
+            f"  This diff might be helpful: {log}"
         ) from None
 
 
@@ -4010,7 +6012,7 @@ def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") ->
     Uses the provided `line_str` rendering, if any, otherwise computes a new one.
     """
     if not line_str:
-        line_str = str(line).strip("\n")
+        line_str = line_to_string(line)
     return (
         len(line_str) <= line_length
         and "\n" not in line_str  # multiline strings
diff --git a/blib2to3/pgen2/pgen.py b/blib2to3/pgen2/pgen.py
index 774cffc..13ec51d 100644
--- a/blib2to3/pgen2/pgen.py
+++ b/blib2to3/pgen2/pgen.py
@@ -167,8 +167,8 @@ def calcfirst(self, name: Text) -> None:
             for symbol in itsfirst:
                 if symbol in inverse:
                     raise ValueError(
-                        "rule %s is ambiguous; %s is in the"
-                        " first sets of %s as well as %s"
+                        "rule %s is ambiguous; %s is in the first sets of %s as well"
+                        " as %s"
                         % (name, symbol, label, inverse[symbol])
                     )
                 inverse[symbol] = label
diff --git a/blib2to3/pgen2/tokenize.py b/blib2to3/pgen2/tokenize.py
index 2683570..bad79b2 100644
--- a/blib2to3/pgen2/tokenize.py
+++ b/blib2to3/pgen2/tokenize.py
@@ -78,7 +78,9 @@ def _combinations(*l):
 Whitespace = r"[ \f\t]*"
 Comment = r"#[^\r\n]*"
 Ignore = Whitespace + any(r"\\\r?\n" + Whitespace) + maybe(Comment)
-Name = r"\w+"  # this is invalid but it's fine because Name comes after Number in all groups
+Name = (  # this is invalid but it's fine because Name comes after Number in all groups
+    r"\w+"
+)
 
 Binnumber = r"0[bB]_?[01]+(?:_[01]+)*"
 Hexnumber = r"0[xX]_?[\da-fA-F]+(?:_[\da-fA-F]+)*[lL]?"
diff --git a/gallery/gallery.py b/gallery/gallery.py
index 87a305f..9758f8f 100755
--- a/gallery/gallery.py
+++ b/gallery/gallery.py
@@ -268,8 +268,7 @@ def main() -> None:
         "-v",
         "--version",
         help=(
-            "Version for given PyPI package. "
-            "Will be discarded if used with -t option."
+            "Version for given PyPI package. Will be discarded if used with -t option."
         ),
     )
     parser.add_argument(
diff --git a/tests/data/cantfit.py b/tests/data/cantfit.py
index 317a38f..ef9b78e 100644
--- a/tests/data/cantfit.py
+++ b/tests/data/cantfit.py
@@ -35,7 +35,7 @@
 """.split():
     if key in self.connect_kwargs:
         raise ValueError(err.format(key))
-concatenated_strings = "some strings that are" "concatenated implicitly, so if you put them on separate" "lines it will fit"
+concatenated_strings = "some strings that are " "concatenated implicitly, so if you put them on separate " "lines it will fit"
 del concatenated_strings, string_variable_name, normal_function_name, normal_name, need_more_to_make_the_line_long_enough
 
 
@@ -75,8 +75,10 @@
 )
 # long arguments
 normal_name = normal_function_name(
-    "but with super long string arguments that on their own exceed the line limit so there's no way it can ever fit",
-    "eggs with spam and eggs and spam with eggs with spam and eggs and spam with eggs with spam and eggs and spam with eggs",
+    "but with super long string arguments that on their own exceed the line limit so"
+    " there's no way it can ever fit",
+    "eggs with spam and eggs and spam with eggs with spam and eggs and spam with eggs"
+    " with spam and eggs and spam with eggs",
     this_is_a_ridiculously_long_name_and_nobody_in_their_right_mind_would_use_one_like_it=0,
 )
 string_variable_name = "a string that is waaaaaaaayyyyyyyy too long, even in parens, there's nothing you can do"  # noqa
@@ -88,8 +90,8 @@
     if key in self.connect_kwargs:
         raise ValueError(err.format(key))
 concatenated_strings = (
-    "some strings that are"
-    "concatenated implicitly, so if you put them on separate"
+    "some strings that are "
+    "concatenated implicitly, so if you put them on separate "
     "lines it will fit"
 )
 del (
diff --git a/tests/data/comments4.py b/tests/data/comments4.py
index c0db5b1..2147d41 100644
--- a/tests/data/comments4.py
+++ b/tests/data/comments4.py
@@ -13,49 +13,39 @@ class C:
             # metadata_version errors.
             (
                 {},
-                "None is an invalid value for Metadata-Version. "
-                "Error: This field is required. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                "None is an invalid value for Metadata-Version. Error: This field is"
+                " required. see"
+                " https://packaging.python.org/specifications/core-metadata",
             ),
             (
                 {"metadata_version": "-1"},
-                "'-1' is an invalid value for Metadata-Version. "
-                "Error: Unknown Metadata Version "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                "'-1' is an invalid value for Metadata-Version. Error: Unknown Metadata"
+                " Version see"
+                " https://packaging.python.org/specifications/core-metadata",
             ),
             # name errors.
             (
                 {"metadata_version": "1.2"},
-                "'' is an invalid value for Name. "
-                "Error: This field is required. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                "'' is an invalid value for Name. Error: This field is required. see"
+                " https://packaging.python.org/specifications/core-metadata",
             ),
             (
                 {"metadata_version": "1.2", "name": "foo-"},
-                "'foo-' is an invalid value for Name. "
-                "Error: Must start and end with a letter or numeral and "
-                "contain only ascii numeric and '.', '_' and '-'. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                "'foo-' is an invalid value for Name. Error: Must start and end with a"
+                " letter or numeral and contain only ascii numeric and '.', '_' and"
+                " '-'. see https://packaging.python.org/specifications/core-metadata",
             ),
             # version errors.
             (
                 {"metadata_version": "1.2", "name": "example"},
-                "'' is an invalid value for Version. "
-                "Error: This field is required. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                "'' is an invalid value for Version. Error: This field is required. see"
+                " https://packaging.python.org/specifications/core-metadata",
             ),
             (
                 {"metadata_version": "1.2", "name": "example", "version": "dog"},
-                "'dog' is an invalid value for Version. "
-                "Error: Must start and end with a letter or numeral and "
-                "contain only ascii numeric and '.', '_' and '-'. "
-                "see "
-                "https://packaging.python.org/specifications/core-metadata",
+                "'dog' is an invalid value for Version. Error: Must start and end with"
+                " a letter or numeral and contain only ascii numeric and '.', '_' and"
+                " '-'. see https://packaging.python.org/specifications/core-metadata",
             ),
         ],
     )
diff --git a/tests/data/comments6.py b/tests/data/comments6.py
index abfd96e..735c6aa 100644
--- a/tests/data/comments6.py
+++ b/tests/data/comments6.py
@@ -104,7 +104,9 @@ def func(
     )
 
 
-result = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # aaa
+result = (  # aaa
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+)
 
 AAAAAAAAAAAAA = [AAAAAAAAAAAAA] + SHARED_AAAAAAAAAAAAA + USER_AAAAAAAAAAAAA + AAAAAAAAAAAAA  # type: ignore
 
diff --git a/tests/data/comments7.py b/tests/data/comments7.py
index 4095125..436df1a 100644
--- a/tests/data/comments7.py
+++ b/tests/data/comments7.py
@@ -87,9 +87,13 @@ def func():
 
 result = 1  # look ma, no comment migration xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
 
-result = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # aaa
+result = (  # aaa
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+)
 
-result = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # aaa
+result = (  # aaa
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+)
 
 
 def func():
diff --git a/tests/data/composition.py b/tests/data/composition.py
index ac63e46..e429f15 100644
--- a/tests/data/composition.py
+++ b/tests/data/composition.py
@@ -10,13 +10,13 @@ def test(self) -> None:
             )
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 1 file left unchanged, "
-                "1 file failed to reformat.",
+                "2 files reformatted, 1 file left unchanged, 1 file failed to"
+                " reformat.",
             )
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             for i in (a,):
                 if (
@@ -40,8 +40,7 @@ def test(self) -> None:
             items=items[:num_items]
         )
         return (
-            "Utterly failed doctest test for %s\n"
-            '  File "%s", line %s, in %s\n\n%s'
+            'Utterly failed doctest test for %s\n   File "%s", line %s, in %s\n\n%s'
             % (test.name, test.filename, lineno, lname, err)
         )
 
@@ -150,8 +149,8 @@ def tricky_asserts(self) -> None:
             key8: value8,
             key9: value9,
         }, (
-            "Not what we expected and the message is too long to fit "
-            "in one line because it's too long"
+            "Not what we expected and the message is too long to fit in one line"
+            " because it's too long"
         )
 
         dis_c_instance_method = """\
diff --git a/tests/data/long_strings.py b/tests/data/long_strings.py
new file mode 100644
index 0000000..5da460b
--- /dev/null
+++ b/tests/data/long_strings.py
@@ -0,0 +1,563 @@
+x = "This is a really long string that can't possibly be expected to fit all together on one line. In fact it may even take up three or more lines... like four or five... but probably just three."
+
+x += "This is a really long string that can't possibly be expected to fit all together on one line. In fact it may even take up three or more lines... like four or five... but probably just three."
+
+y = (
+    'Short string'
+)
+
+print('This is a really long string inside of a print statement with extra arguments attached at the end of it.', x, y, z)
+
+print("This is a really long string inside of a print statement with no extra arguments attached at the end of it.")
+
+D1 = {"The First": "This is a really long string that can't possibly be expected to fit all together on one line. Also it is inside a dictionary, so formatting is more difficult.", "The Second": "This is another really really (not really) long string that also can't be expected to fit on one line and is, like the other string, inside a dictionary."}
+
+D2 = {1.0: "This is a really long string that can't possibly be expected to fit all together on one line. Also it is inside a dictionary, so formatting is more difficult.", 2.0: "This is another really really (not really) long string that also can't be expected to fit on one line and is, like the other string, inside a dictionary."}
+
+D3 = {x: "This is a really long string that can't possibly be expected to fit all together on one line. Also it is inside a dictionary, so formatting is more difficult.", y: "This is another really really (not really) long string that also can't be expected to fit on one line and is, like the other string, inside a dictionary."}
+
+D4 = {"A long and ridiculous {}".format(string_key): "This is a really really really long string that has to go i,side of a dictionary. It is soooo bad.", some_func("calling", "some", "stuff"): "This is a really really really long string that has to go inside of a dictionary. It is {soooo} bad (#{x}).".format(sooo="soooo", x=2), "A %s %s" % ("formatted", "string"): "This is a really really really long string that has to go inside of a dictionary. It is %s bad (#%d)." % ("soooo", 2)}
+
+func_with_keywords(my_arg, my_kwarg="Long keyword strings also need to be wrapped, but they will probably need to be handled a little bit differently.")
+
+bad_split1 = (
+    'But what should happen when code has already been formatted but in the wrong way? Like'
+    " with a space at the end instead of the beginning. Or what about when it is split too soon?"
+)
+
+bad_split2 = "But what should happen when code has already " \
+             "been formatted but in the wrong way? Like " \
+             "with a space at the end instead of the " \
+             "beginning. Or what about when it is split too " \
+             "soon? In the case of a split that is too " \
+             "short, black will try to honer the custom " \
+             "split."
+
+bad_split3 = (
+    "What if we have inline comments on "  # First Comment
+    "each line of a bad split? In that "  # Second Comment
+    "case, we should just leave it alone."  # Third Comment
+)
+
+bad_split_func1(
+    "But what should happen when code has already "
+    "been formatted but in the wrong way? Like "
+    "with a space at the end instead of the "
+    "beginning. Or what about when it is split too "
+    "soon? In the case of a split that is too "
+    "short, black will try to honer the custom "
+    "split.",
+    xxx, yyy, zzz
+)
+
+bad_split_func2(
+    xxx, yyy, zzz,
+    long_string_kwarg="But what should happen when code has already been formatted but in the wrong way? Like "
+                      "with a space at the end instead of the beginning. Or what about when it is split too "
+                      "soon?",
+)
+
+bad_split_func3(
+    (
+        "But what should happen when code has already "
+        r"been formatted but in the wrong way? Like "
+        "with a space at the end instead of the "
+        r"beginning. Or what about when it is split too "
+        r"soon? In the case of a split that is too "
+        "short, black will try to honer the custom "
+        "split."
+    ),
+    xxx,
+    yyy,
+    zzz,
+)
+
+raw_string = r"This is a long raw string. When re-formatting this string, black needs to make sure it prepends the 'r' onto the new string."
+
+fmt_string1 = "We also need to be sure to preserve any and all {} which may or may not be attached to the string in question.".format("method calls")
+
+fmt_string2 = "But what about when the string is {} but {}".format("short", "the method call is really really really really really really really really long?")
+
+old_fmt_string1 = "While we are on the topic of %s, we should also note that old-style formatting must also be preserved, since some %s still uses it." % ("formatting", "code")
+
+old_fmt_string2 = "This is a %s %s %s %s" % ("really really really really really", "old", "way to format strings!", "Use f-strings instead!")
+
+old_fmt_string3 = "Whereas only the strings after the percent sign were long in the last example, this example uses a long initial string as well. This is another %s %s %s %s" % ("really really really really really", "old", "way to format strings!", "Use f-strings instead!")
+
+fstring = f"f-strings definitely make things more {difficult} than they need to be for {{black}}. But boy they sure are handy. The problem is that some lines will need to have the 'f' whereas others do not. This {line}, for example, needs one."
+
+fstring_with_no_fexprs = f"Some regular string that needs to get split certainly but is NOT an fstring by any means whatsoever."
+
+comment_string = "Long lines with inline comments should have their comments appended to the reformatted string's enclosing right parentheses."  # This comment gets thrown to the top.
+
+arg_comment_string = print("Long lines with inline comments which are apart of (and not the only member of) an argument list should have their comments appended to the reformatted string's enclosing left parentheses.",  # This comment stays on the bottom.
+    "Arg #2", "Arg #3", "Arg #4", "Arg #5")
+
+pragma_comment_string1 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa: E501
+
+pragma_comment_string2 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa
+
+"""This is a really really really long triple quote string and it should not be touched."""
+
+triple_quote_string = """This is a really really really long triple quote string assignment and it should not be touched."""
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception."
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception, which uses dynamic string {}.".format("formatting")
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception, which uses dynamic string %s." % "formatting"
+
+assert some_type_of_boolean_expression, "Followed by a really really really long string that is used to provide context to the AssertionError exception, which uses dynamic %s %s." % ("string", "formatting")
+
+some_function_call("With a reallly generic name and with a really really long string that is, at some point down the line, " + added + " to a variable and then added to another string.")
+
+some_function_call("With a reallly generic name and with a really really long string that is, at some point down the line, " + added + " to a variable and then added to another string. But then what happens when the final string is also supppppperrrrr long?! Well then that second (realllllllly long) string should be split too.", "and a second argument", and_a_third)
+
+return "A really really really really really really really really really really really really really long {} {}".format("return", "value")
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma which should NOT be there.",
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma which should NOT be there.", # comment after comma
+)
+
+func_with_bad_comma(
+    (
+        "This is a really long string argument to a function that has a trailing comma"
+        " which should NOT be there."
+    ),
+)
+
+func_with_bad_comma(
+    (
+        "This is a really long string argument to a function that has a trailing comma"
+        " which should NOT be there."
+    ), # comment after comma
+)
+
+func_with_bad_parens(
+    ("short string that should have parens stripped"),
+    x,
+    y,
+    z,
+)
+
+func_with_bad_parens(
+    x,
+    y,
+    ("short string that should have parens stripped"),
+    z,
+)
+
+annotated_variable: Final = "This is a large " + STRING + " that has been " + CONCATENATED + "using the '+' operator."
+annotated_variable: Final = "This is a large string that has a type annotation attached to it. A type annotation should NOT stop a long string from being wrapped."
+annotated_variable: Literal["fakse_literal"] = "This is a large string that has a type annotation attached to it. A type annotation should NOT stop a long string from being wrapped."
+
+backslashes = "This is a really long string with \"embedded\" double quotes and 'single' quotes that also handles checking for an even number of backslashes \\"
+backslashes = "This is a really long string with \"embedded\" double quotes and 'single' quotes that also handles checking for an even number of backslashes \\\\"
+backslashes = "This is a really 'long' string with \"embedded double quotes\" and 'single' quotes that also handles checking for an odd number of backslashes \\\", like this...\\\\\\"
+
+short_string = (
+    "Hi"
+    " there."
+)
+
+func_call(
+    short_string=(
+        "Hi"
+        " there."
+    )
+)
+
+raw_strings = r"Don't" " get" r" merged" " unless they are all raw."
+
+def foo():
+    yield "This is a really long string that can't possibly be expected to fit all together on one line. In fact it may even take up three or more lines... like four or five... but probably just three."
+
+x = f"This is a {{really}} long string that needs to be split without a doubt (i.e. most definitely). In short, this {string} that can't possibly be {{expected}} to fit all together on one line. In {fact} it may even take up three or more lines... like four or five... but probably just four."
+
+long_unmergable_string_with_pragma = (
+    "This is a really long string that can't be merged because it has a likely pragma at the end"  # type: ignore
+    " of it."
+)
+
+long_unmergable_string_with_pragma = (
+    "This is a really long string that can't be merged because it has a likely pragma at the end"  # noqa
+    " of it."
+)
+
+long_unmergable_string_with_pragma = (
+    "This is a really long string that can't be merged because it has a likely pragma at the end"  # pylint: disable=some-pylint-check
+    " of it."
+)
+
+
+# output
+
+
+x = (
+    "This is a really long string that can't possibly be expected to fit all together"
+    " on one line. In fact it may even take up three or more lines... like four or"
+    " five... but probably just three."
+)
+
+x += (
+    "This is a really long string that can't possibly be expected to fit all together"
+    " on one line. In fact it may even take up three or more lines... like four or"
+    " five... but probably just three."
+)
+
+y = "Short string"
+
+print(
+    "This is a really long string inside of a print statement with extra arguments"
+    " attached at the end of it.",
+    x,
+    y,
+    z,
+)
+
+print(
+    "This is a really long string inside of a print statement with no extra arguments"
+    " attached at the end of it."
+)
+
+D1 = {
+    "The First": (
+        "This is a really long string that can't possibly be expected to fit all"
+        " together on one line. Also it is inside a dictionary, so formatting is more"
+        " difficult."
+    ),
+    "The Second": (
+        "This is another really really (not really) long string that also can't be"
+        " expected to fit on one line and is, like the other string, inside a"
+        " dictionary."
+    ),
+}
+
+D2 = {
+    1.0: (
+        "This is a really long string that can't possibly be expected to fit all"
+        " together on one line. Also it is inside a dictionary, so formatting is more"
+        " difficult."
+    ),
+    2.0: (
+        "This is another really really (not really) long string that also can't be"
+        " expected to fit on one line and is, like the other string, inside a"
+        " dictionary."
+    ),
+}
+
+D3 = {
+    x: (
+        "This is a really long string that can't possibly be expected to fit all"
+        " together on one line. Also it is inside a dictionary, so formatting is more"
+        " difficult."
+    ),
+    y: (
+        "This is another really really (not really) long string that also can't be"
+        " expected to fit on one line and is, like the other string, inside a"
+        " dictionary."
+    ),
+}
+
+D4 = {
+    "A long and ridiculous {}".format(string_key): (
+        "This is a really really really long string that has to go i,side of a"
+        " dictionary. It is soooo bad."
+    ),
+    some_func("calling", "some", "stuff"): (
+        "This is a really really really long string that has to go inside of a"
+        " dictionary. It is {soooo} bad (#{x}).".format(sooo="soooo", x=2)
+    ),
+    "A %s %s"
+    % ("formatted", "string"): (
+        "This is a really really really long string that has to go inside of a"
+        " dictionary. It is %s bad (#%d)."
+    )
+    % ("soooo", 2),
+}
+
+func_with_keywords(
+    my_arg,
+    my_kwarg=(
+        "Long keyword strings also need to be wrapped, but they will probably need to"
+        " be handled a little bit differently."
+    ),
+)
+
+bad_split1 = (
+    "But what should happen when code has already been formatted but in the wrong way?"
+    " Like with a space at the end instead of the beginning. Or what about when it is"
+    " split too soon?"
+)
+
+bad_split2 = (
+    "But what should happen when code has already "
+    "been formatted but in the wrong way? Like "
+    "with a space at the end instead of the "
+    "beginning. Or what about when it is split too "
+    "soon? In the case of a split that is too "
+    "short, black will try to honer the custom "
+    "split."
+)
+
+bad_split3 = (
+    "What if we have inline comments on "  # First Comment
+    "each line of a bad split? In that "  # Second Comment
+    "case, we should just leave it alone."  # Third Comment
+)
+
+bad_split_func1(
+    "But what should happen when code has already "
+    "been formatted but in the wrong way? Like "
+    "with a space at the end instead of the "
+    "beginning. Or what about when it is split too "
+    "soon? In the case of a split that is too "
+    "short, black will try to honer the custom "
+    "split.",
+    xxx,
+    yyy,
+    zzz,
+)
+
+bad_split_func2(
+    xxx,
+    yyy,
+    zzz,
+    long_string_kwarg=(
+        "But what should happen when code has already been formatted but in the wrong"
+        " way? Like with a space at the end instead of the beginning. Or what about"
+        " when it is split too soon?"
+    ),
+)
+
+bad_split_func3(
+    (
+        "But what should happen when code has already "
+        r"been formatted but in the wrong way? Like "
+        "with a space at the end instead of the "
+        r"beginning. Or what about when it is split too "
+        r"soon? In the case of a split that is too "
+        "short, black will try to honer the custom "
+        "split."
+    ),
+    xxx,
+    yyy,
+    zzz,
+)
+
+raw_string = (
+    r"This is a long raw string. When re-formatting this string, black needs to make"
+    r" sure it prepends the 'r' onto the new string."
+)
+
+fmt_string1 = (
+    "We also need to be sure to preserve any and all {} which may or may not be"
+    " attached to the string in question.".format("method calls")
+)
+
+fmt_string2 = "But what about when the string is {} but {}".format(
+    "short",
+    "the method call is really really really really really really really really long?",
+)
+
+old_fmt_string1 = (
+    "While we are on the topic of %s, we should also note that old-style formatting"
+    " must also be preserved, since some %s still uses it."
+    % ("formatting", "code")
+)
+
+old_fmt_string2 = "This is a %s %s %s %s" % (
+    "really really really really really",
+    "old",
+    "way to format strings!",
+    "Use f-strings instead!",
+)
+
+old_fmt_string3 = (
+    "Whereas only the strings after the percent sign were long in the last example,"
+    " this example uses a long initial string as well. This is another %s %s %s %s"
+    % (
+        "really really really really really",
+        "old",
+        "way to format strings!",
+        "Use f-strings instead!",
+    )
+)
+
+fstring = (
+    f"f-strings definitely make things more {difficult} than they need to be for"
+    " {black}. But boy they sure are handy. The problem is that some lines will need"
+    f" to have the 'f' whereas others do not. This {line}, for example, needs one."
+)
+
+fstring_with_no_fexprs = (
+    f"Some regular string that needs to get split certainly but is NOT an fstring by"
+    f" any means whatsoever."
+)
+
+comment_string = (  # This comment gets thrown to the top.
+    "Long lines with inline comments should have their comments appended to the"
+    " reformatted string's enclosing right parentheses."
+)
+
+arg_comment_string = print(
+    "Long lines with inline comments which are apart of (and not the only member of) an"
+    " argument list should have their comments appended to the reformatted string's"
+    " enclosing left parentheses.",  # This comment stays on the bottom.
+    "Arg #2",
+    "Arg #3",
+    "Arg #4",
+    "Arg #5",
+)
+
+pragma_comment_string1 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa: E501
+
+pragma_comment_string2 = "Lines which end with an inline pragma comment of the form `# <pragma>: <...>` should be left alone."  # noqa
+
+"""This is a really really really long triple quote string and it should not be touched."""
+
+triple_quote_string = """This is a really really really long triple quote string assignment and it should not be touched."""
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception."
+)
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception, which uses dynamic string {}.".format("formatting")
+)
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception, which uses dynamic string %s."
+    % "formatting"
+)
+
+assert some_type_of_boolean_expression, (
+    "Followed by a really really really long string that is used to provide context to"
+    " the AssertionError exception, which uses dynamic %s %s."
+    % ("string", "formatting")
+)
+
+some_function_call(
+    "With a reallly generic name and with a really really long string that is, at some"
+    " point down the line, "
+    + added
+    + " to a variable and then added to another string."
+)
+
+some_function_call(
+    "With a reallly generic name and with a really really long string that is, at some"
+    " point down the line, "
+    + added
+    + " to a variable and then added to another string. But then what happens when the"
+    " final string is also supppppperrrrr long?! Well then that second (realllllllly"
+    " long) string should be split too.",
+    "and a second argument",
+    and_a_third,
+)
+
+return (
+    "A really really really really really really really really really really really"
+    " really really long {} {}".format("return", "value")
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there.",
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there.",  # comment after comma
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there.",
+)
+
+func_with_bad_comma(
+    "This is a really long string argument to a function that has a trailing comma"
+    " which should NOT be there.",  # comment after comma
+)
+
+func_with_bad_parens(
+    "short string that should have parens stripped", x, y, z,
+)
+
+func_with_bad_parens(
+    x, y, "short string that should have parens stripped", z,
+)
+
+annotated_variable: Final = (
+    "This is a large "
+    + STRING
+    + " that has been "
+    + CONCATENATED
+    + "using the '+' operator."
+)
+annotated_variable: Final = (
+    "This is a large string that has a type annotation attached to it. A type"
+    " annotation should NOT stop a long string from being wrapped."
+)
+annotated_variable: Literal["fakse_literal"] = (
+    "This is a large string that has a type annotation attached to it. A type"
+    " annotation should NOT stop a long string from being wrapped."
+)
+
+backslashes = (
+    "This is a really long string with \"embedded\" double quotes and 'single' quotes"
+    " that also handles checking for an even number of backslashes \\"
+)
+backslashes = (
+    "This is a really long string with \"embedded\" double quotes and 'single' quotes"
+    " that also handles checking for an even number of backslashes \\\\"
+)
+backslashes = (
+    "This is a really 'long' string with \"embedded double quotes\" and 'single' quotes"
+    ' that also handles checking for an odd number of backslashes \\", like'
+    " this...\\\\\\"
+)
+
+short_string = "Hi there."
+
+func_call(short_string="Hi there.")
+
+raw_strings = r"Don't" " get" r" merged" " unless they are all raw."
+
+
+def foo():
+    yield (
+        "This is a really long string that can't possibly be expected to fit all"
+        " together on one line. In fact it may even take up three or more lines... like"
+        " four or five... but probably just three."
+    )
+
+
+x = (
+    "This is a {really} long string that needs to be split without a doubt (i.e."
+    f" most definitely). In short, this {string} that can't possibly be {{expected}} to"
+    f" fit all together on one line. In {fact} it may even take up three or more"
+    " lines... like four or five... but probably just four."
+)
+
+long_unmergable_string_with_pragma = (
+    "This is a really long string that can't be merged because it has a likely pragma at the end"  # type: ignore
+    " of it."
+)
+
+long_unmergable_string_with_pragma = (
+    "This is a really long string that can't be merged because it has a likely pragma at the end"  # noqa
+    " of it."
+)
+
+long_unmergable_string_with_pragma = (
+    "This is a really long string that can't be merged because it has a likely pragma at the end"  # pylint: disable=some-pylint-check
+    " of it."
+)
diff --git a/tests/data/long_strings__edge_case.py b/tests/data/long_strings__edge_case.py
new file mode 100644
index 0000000..6919db5
--- /dev/null
+++ b/tests/data/long_strings__edge_case.py
@@ -0,0 +1,110 @@
+some_variable = "This string is long but not so long that it needs to be split just yet"
+some_variable = 'This string is long but not so long that it needs to be split just yet'
+some_variable = "This string is long, just long enough that it needs to be split, u get?"
+some_variable = 'This string is long, just long enough that it needs to be split, u get?'
+some_variable = "This string is long, just long enough that it needs to be split, u get? So we stay"
+some_variable = 'This string is long, just long enough that it needs to be split, u get? So we stay'
+some_variable = "This string is long, just long enough that it needs to be split, u get? So we split"
+some_variable = 'This string is long, just long enough that it needs to be split, u get? So we split'
+some_variable = "This string is long but not so long that it needs hahahah toooooo be so greatttt {} that I just can't think of any more good words to say about it at alll".format("ha")
+some_variable = "This string is long but not so long that it needs hahahah toooooo be so greatttt {} that I just can't think of any more good words to say about it at allll".format("ha")
+some_variable = "This string is long but not so long that it needs hahahah toooooo be so greatttt {} that I just can't think of any more good words to say about it at alllllllllll".format("ha")
+some_variable = "This string is long but not so long that it needs hahahah toooooo be so greatttt {} that I just can't think of any more good words to say about it at allllllllllll".format("ha")
+some_variable = "This is a long string that will end with a method that is not calleddd".format
+addition_inside_tuple = (
+    some_string_inside_a_variable
+    + "Some string that is just long enough to cause a split to take place.............",
+    xyz,
+    "Some really long string that needs to get split eventually but I'm running out of things to say" + some_string_inside_a_variable
+)
+addition_inside_tuple = (
+    some_string_inside_a_variable
+    + "Some string that is just long enough to cause a split to take place.............."
+)
+return "Hi there. This is areally really reallllly long string that needs to be split!!!"
+ternary_expression = (
+    "Short String"
+    if some_condition
+    else "This is a really long string that will eventually need to be split right here."
+)
+return f'{x}/b/c/d/d/d/dadfjsadjsaidoaisjdsfjaofjdfijaidfjaodfjaoifjodjafojdoajaaaaaaaaaaa'
+return f'{x}/b/c/d/d/d/dadfjsadjsaidoaisjdsfjaofjdfijaidfjaodfjaoifjodjafojdoajaaaaaaaaaaaa'
+
+
+# output
+
+
+some_variable = "This string is long but not so long that it needs to be split just yet"
+some_variable = "This string is long but not so long that it needs to be split just yet"
+some_variable = (
+    "This string is long, just long enough that it needs to be split, u get?"
+)
+some_variable = (
+    "This string is long, just long enough that it needs to be split, u get?"
+)
+some_variable = (
+    "This string is long, just long enough that it needs to be split, u get? So we stay"
+)
+some_variable = (
+    "This string is long, just long enough that it needs to be split, u get? So we stay"
+)
+some_variable = (
+    "This string is long, just long enough that it needs to be split, u get? So we"
+    " split"
+)
+some_variable = (
+    "This string is long, just long enough that it needs to be split, u get? So we"
+    " split"
+)
+some_variable = (
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"
+    " {} that I just can't think of any more good words to say about it at alll".format(
+        "ha"
+    )
+)
+some_variable = (
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"
+    " {} that I just can't think of any more good words to say about it at allll"
+    .format("ha")
+)
+some_variable = (
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"
+    " {} that I just can't think of any more good words to say about it at alllllllllll"
+    .format("ha")
+)
+some_variable = (
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"
+    " {} that I just can't think of any more good words to say about it at"
+    " allllllllllll".format("ha")
+)
+some_variable = (
+    "This is a long string that will end with a method that is not calleddd".format
+)
+addition_inside_tuple = (
+    some_string_inside_a_variable
+    + "Some string that is just long enough to cause a split to take"
+    " place.............",
+    xyz,
+    "Some really long string that needs to get split eventually but I'm running out of"
+    " things to say"
+    + some_string_inside_a_variable,
+)
+addition_inside_tuple = (
+    some_string_inside_a_variable
+    + "Some string that is just long enough to cause a split to take"
+    " place.............."
+)
+return (
+    "Hi there. This is areally really reallllly long string that needs to be split!!!"
+)
+ternary_expression = (
+    "Short String"
+    if some_condition
+    else (
+        "This is a really long string that will eventually need to be split right here."
+    )
+)
+return (
+    f"{x}/b/c/d/d/d/dadfjsadjsaidoaisjdsfjaofjdfijaidfjaodfjaoifjodjafojdoajaaaaaaaaaaa"
+)
+return f"{x}/b/c/d/d/d/dadfjsadjsaidoaisjdsfjaofjdfijaidfjaodfjaoifjodjafojdoajaaaaaaaaaaaa"
diff --git a/tests/data/long_strings__regression.py b/tests/data/long_strings__regression.py
new file mode 100644
index 0000000..8dbc58a
--- /dev/null
+++ b/tests/data/long_strings__regression.py
@@ -0,0 +1,698 @@
+class A:
+    def foo():
+        result = type(message)("")
+
+
+# Don't merge multiline (e.g. triple-quoted) strings.
+def foo():
+    query = (
+        """SELECT xxxxxxxxxxxxxxxxxxxx(xxx)"""
+        """ FROM xxxxxxxxxxxxxxxx WHERE xxxxxxxxxx AND xxx <> xxxxxxxxxxxxxx()""")
+
+# There was a bug where tuples were being identified as long strings.
+long_tuple = ('Apple', 'Berry', 'Cherry', 'Dill', 'Evergreen', 'Fig',
+           'Grape', 'Harry', 'Iglu', 'Jaguar')
+
+stupid_format_method_bug = "Some really long string that just so happens to be the {} {} to force the 'format' method to hang over the line length boundary. This is pretty annoying.".format("perfect", "length")
+
+class A:
+    def foo():
+        os.system("This is a regression test. xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxxx.".format("xxxxxxxxxx", "xxxxxx", "xxxxxxxxxx"))
+
+
+class A:
+    def foo():
+        XXXXXXXXXXXX.append(
+            (
+                "xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx, xxxx_xxxx_xxxxxxxxxx={})".format(
+                    xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx
+                ),
+                my_var,
+                my_other_var,
+            )
+        )
+
+class A:
+    class B:
+        def foo():
+            bar(
+                (
+                    "[{}]: xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx={}"
+                    " xxxx_xxxx_xxxxxxxxxx={}, xxxx={})"
+                    .format(xxxx._xxxxxxxxxxxxxx, xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx, xxxxxxx)
+                ),
+                varX,
+                varY,
+                varZ,
+            )
+
+def foo(xxxx):
+    for (xxx_xxxx, _xxx_xxx, _xxx_xxxxx, xxx_xxxx) in xxxx:
+        for xxx in xxx_xxxx:
+            assert ("x" in xxx) or (
+                xxx in xxx_xxx_xxxxx
+            ), "{0} xxxxxxx xx {1}, xxx {1} xx xxx xx xxxx xx xxx xxxx: xxx xxxx {2}".format(
+                xxx_xxxx, xxx, xxxxxx.xxxxxxx(xxx_xxx_xxxxx)
+            )
+
+class A:
+    def disappearing_comment():
+        return (
+            (  # xx -x xxxxxxx xx xxx xxxxxxx.
+                '{{xxx_xxxxxxxxxx_xxxxxxxx}} xxx xxxx'
+                ' {} {{xxxx}} >&2'
+                .format(
+                    "{xxxx} {xxxxxx}"
+                    if xxxxx.xx_xxxxxxxxxx
+                    else ( # Disappearing Comment
+                        "--xxxxxxx --xxxxxx=x --xxxxxx-xxxxx=xxxxxx"
+                        " --xxxxxx-xxxx=xxxxxxxxxxx.xxx"
+                    )
+                )
+            ),
+            (x, y, z),
+        )
+
+class A:
+    class B:
+        def foo():
+            xxxxx_xxxx(
+                xx, "\t"
+                "@xxxxxx '{xxxx_xxx}\t' > {xxxxxx_xxxx}.xxxxxxx;"
+                "{xxxx_xxx} >> {xxxxxx_xxxx}.xxxxxxx 2>&1; xx=$$?;"
+                "xxxx $$xx"
+                .format(xxxx_xxx=xxxx_xxxxxxx, xxxxxx_xxxx=xxxxxxx + "/" + xxxx_xxx_xxxx, x=xxx_xxxxx_xxxxx_xxx),
+                x,
+                y,
+                z,
+            )
+
+func_call_where_string_arg_has_method_call_and_bad_parens(
+    (
+        "A long string with {}. This string is so long that it is ridiculous. It can't fit on one line at alllll.".format("formatting")
+    ),
+)
+
+func_call_where_string_arg_has_old_fmt_and_bad_parens(
+    (
+        "A long string with {}. This string is so long that it is ridiculous. It can't fit on one line at alllll." % "formatting"
+    ),
+)
+
+func_call_where_string_arg_has_old_fmt_and_bad_parens(
+    (
+        "A long string with {}. This {} is so long that it is ridiculous. It can't fit on one line at alllll." % ("formatting", "string")
+    ),
+)
+
+class A:
+    def append(self):
+        if True:
+            xxxx.xxxxxxx.xxxxx( ('xxxxxxxxxx xxxx xx xxxxxx(%x) xx %x xxxx xx xxx %x.xx'
+                                 % (len(self) + 1,
+                                    xxxx.xxxxxxxxxx,
+                                    xxxx.xxxxxxxxxx))
+                                + (' %.3f (%s) to %.3f (%s).\n'
+                                   % (xxxx.xxxxxxxxx,
+                                      xxxx.xxxxxxxxxxxxxx(xxxx.xxxxxxxxx),
+                                      x,
+                                      xxxx.xxxxxxxxxxxxxx( xx)
+                                      )))
+
+class A:
+    def foo():
+        some_func_call(
+            'xxxxxxxxxx',
+            (
+                "xx {xxxxxxxxxxx}/xxxxxxxxxxx.xxx xxxx.xxx && xxxxxx -x "
+                "\"xxxx xxxxxxx xxxxxx xxxx; xxxx xxxxxx_xxxxx xxxxxx xxxx; "
+                "xxxx.xxxx_xxxxxx(['xxxx.xxx'], xxxx.xxxxxxx().xxxxxxxxxx)\" "
+            ),
+            None,
+            ('xxxxxxxxxxx',),
+        ),
+
+class A:
+    def foo():
+        some_func_call(
+            (
+                "xx {xxxxxxxxxxx}/xxxxxxxxxxx.xxx xxxx.xxx && xxxxxx -x "
+                "xxxx, ('xxxxxxx xxxxxx xxxx, xxxx') xxxxxx_xxxxx xxxxxx xxxx; "
+                "xxxx.xxxx_xxxxxx(['xxxx.xxx'], xxxx.xxxxxxx().xxxxxxxxxx)\" "
+            ),
+            None,
+            ('xxxxxxxxxxx',),
+        ),
+
+xxxxxxx = { 'xx' : 'xxxx xxxxxxx xxxxxxxxx -x xxx -x /xxx/{0} -x xxx,xxx -xx {1} \
+-xx {1} -xx xxx=xxx_xxxx,xxx_xx,xxx_xxx,xxx_xxxx,xxx_xx,xxx_xxx |\
+ xxxxxx -x xxxxxxxx -x xxxxxxxx -x',
+         'xx' : 'xxxx xxxxxxx xxxxxxxxx -x xxx -x /xxx/{0} -x xxx,xxx -xx {1} \
+-xx {1} -xx xxx=xxx_xxxx_xxx_xxxx,xxx_xx_xxx_xxxx,xxx_xxxx_xxx_xxxx,\
+xxx_xx_xxxx_xxxx,xxx_xxx_xxxx,xxx_xxx_xxxx xxxx=xxx | xxxxxx -x xxxxxxxx -x xxxxxxxx -x'
+}
+
+class A:
+    def foo(self):
+        if True:
+            xxxxx_xxxxxxxxxxxx('xxx xxxxxx xxx xxxxxxxxx.xx xx xxxxxxxx.  xxx xxxxxxxxxxxxx.xx xxxxxxx '
+                               + 'xx xxxxxx xxxxxx xxxxxx xx xxxxxxx xxx xxx ${0} xx x xxxxxxxx xxxxx'.xxxxxx(xxxxxx_xxxxxx_xxx))
+
+class A:
+    class B:
+        def foo():
+            row = {
+                'xxxxxxxxxxxxxxx' : xxxxxx_xxxxx_xxxx,
+                # 'xxxxxxxxxxxxxxxxxxxxxxx'
+                # 'xxxxxxxxxxxxxxxxxxxxxx'
+                # 'xxxxxxxxxxxxxxxxxx'
+                # 'xxxxxxxxxxxxxxxxx'
+                'xxxxxxxxxx' : xxxxx_xxxxx,
+                }
+
+class A:
+    def xxxx_xxx_xx_xxxxxxxxxx_xxxx_xxxxxxxxx(xxxx):
+        xxxxxxxx = [
+            xxxxxxxxxxxxxxxx(
+                'xxxx',
+                xxxxxxxxxxx={
+                    'xxxx' : 1.0,
+                },
+                xxxxxx={'xxxxxx 1' : xxxxxx(xxxx='xxxxxx 1', xxxxxx=600.0)},
+                xxxxxxxx_xxxxxxx=0.0,
+            ),
+            xxxxxxxxxxxxxxxx(
+                'xxxxxxx',
+                xxxxxxxxxxx={
+                    'xxxx' : 1.0,
+                },
+                xxxxxx={'xxxxxx 1' : xxxxxx(xxxx='xxxxxx 1', xxxxxx=200.0)},
+                xxxxxxxx_xxxxxxx=0.0,
+            ),
+            xxxxxxxxxxxxxxxx(
+                'xxxx',
+            ),
+        ]
+
+some_dictionary = {
+    'xxxxx006': ['xxx-xxx xxxxx3xxxx1xx2xxxxxxxxxxxxxx0xx6xxxxxxxxxx2xxxxxx9xxxxxxxxxx0xxxxx1xxx2x/xx9xx6+x+xxxxxxxxxxxxxx4xxxxxxxxxxxxxxxxxxxxx43xxx2xx2x4x++xxx6xxxxxxxxx+xxxxx/xx9x+xxxxxxxxxxxxxx8x15xxxxxxxxxxxxxxxxx82xx/xxxxxxxxxxxxxx/x5xxxxxxxxxxxxxx6xxxxxx74x4/xxx4x+xxxxxxxxx2xxxxxxxx87xxxxx4xxxxxxxx3xx0xxxxx4xxx1xx9xx5xxxxxxx/xxxxx5xx6xx4xxxx1x/x2xxxxxxxxxxxx64xxxxxxx1x0xx5xxxxxxxxxxxxxx== xxxxx000 xxxxxxxxxx\n',
+                 'xxx-xxx xxxxx3xxxx1xx2xxxxxxxxxxxxxx6xxxxxxxxxxxxxx9xxxxxxxxxxxxx3xxx9xxxxxxxxxxxxxxxx0xxxxxxxxxxxxxxxxx2xxxx2xxx6xxxxx/xx54xxxxxxxxx4xxx3xxxxxx9xx3xxxxx39xxxxxxxxx5xx91xxxx7xxxxxx8xxxxxxxxxxxxxxxx9xxx93xxxxxxxxxxxxxxxxx7xxx8xx8xx4/x1xxxxx1x3xxxxxxxxxxxxx3xxxxxx9xx4xx4x7xxxxxxxxxxxxx1xxxxxxxxx7xxxxxxxxxxxxxx4xx6xxxxxxxxx9xxx7xxxx2xxxxxxxxxxxxxxxxxxxxxx8xxxxxxxxxxxxxxxxxxxx6xx== xxxxx010 xxxxxxxxxx\n'],
+    'xxxxx016': ['xxx-xxx xxxxx3xxxx1xx2xxxxxxxxxxxxxx0xx6xxxxxxxxxx2xxxxxx9xxxxxxxxxx0xxxxx1xxx2x/xx9xx6+x+xxxxxxxxxxxxxx4xxxxxxxxxxxxxxxxxxxxx43xxx2xx2x4x++xxx6xxxxxxxxx+xxxxx/xx9x+xxxxxxxxxxxxxx8x15xxxxxxxxxxxxxxxxx82xx/xxxxxxxxxxxxxx/x5xxxxxxxxxxxxxx6xxxxxx74x4/xxx4x+xxxxxxxxx2xxxxxxxx87xxxxx4xxxxxxxx3xx0xxxxx4xxx1xx9xx5xxxxxxx/xxxxx5xx6xx4xxxx1x/x2xxxxxxxxxxxx64xxxxxxx1x0xx5xxxxxxxxxxxxxx== xxxxx000 xxxxxxxxxx\n',
+                 'xxx-xxx xxxxx3xxxx1xx2xxxxxxxxxxxxxx6xxxxxxxxxxxxxx9xxxxxxxxxxxxx3xxx9xxxxxxxxxxxxxxxx0xxxxxxxxxxxxxxxxx2xxxx2xxx6xxxxx/xx54xxxxxxxxx4xxx3xxxxxx9xx3xxxxx39xxxxxxxxx5xx91xxxx7xxxxxx8xxxxxxxxxxxxxxxx9xxx93xxxxxxxxxxxxxxxxx7xxx8xx8xx4/x1xxxxx1x3xxxxxxxxxxxxx3xxxxxx9xx4xx4x7xxxxxxxxxxxxx1xxxxxxxxx7xxxxxxxxxxxxxx4xx6xxxxxxxxx9xxx7xxxx2xxxxxxxxxxxxxxxxxxxxxx8xxxxxxxxxxxxxxxxxxxx6xx== xxxxx010 xxxxxxxxxx\n']
+}
+
+def foo():
+    xxx_xxx = (
+        'xxxx xxx xxxxxxxx_xxxx xx "xxxxxxxxxx".'
+        '\n xxx: xxxxxx xxxxxxxx_xxxx=xxxxxxxxxx'
+    ) # xxxx xxxxxxxxxx xxxx xx xxxx xx xxx xxxxxxxx xxxxxx xxxxx.
+
+some_tuple = ("some string", "some string" " which should be joined")
+
+some_commented_string = (
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"  # This comment gets thrown to the top.
+    " {} that I just can't think of any more good words to say about it at"
+    " allllllllllll".format("ha")  # comments here are fine
+)
+
+some_commented_string = (
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"  # But these
+    " {} that I just can't think of any more good words to say about it at"  # comments will stay
+    " allllllllllll".format("ha")  # comments here are fine
+)
+
+lpar_and_rpar_have_comments = func_call(  # LPAR Comment
+    "Long really ridiculous type of string that shouldn't really even exist at all. I mean commmme onnn!!!",  # Comma Comment
+)  # RPAR Comment
+
+cmd_fstring = (
+    f"sudo -E deluge-console info --detailed --sort-reverse=time_added "
+    f"{'' if ID is None else ID} | perl -nE 'print if /^{field}:/'"
+)
+
+cmd_fstring = f"sudo -E deluge-console info --detailed --sort-reverse=time_added {'' if ID is None else ID} | perl -nE 'print if /^{field}:/'"
+
+cmd_fstring = f"sudo -E deluge-console info --detailed --sort-reverse=time_added {'{{}}' if ID is None else ID} | perl -nE 'print if /^{field}:/'"
+
+cmd_fstring = f"sudo -E deluge-console info --detailed --sort-reverse=time_added {{'' if ID is None else ID}} | perl -nE 'print if /^{field}:/'"
+
+fstring = f"This string really doesn't need to be an {{{{fstring}}}}, but this one most certainly, absolutely {does}."
+
+fstring = (
+    f"We have to remember to escape {braces}."
+    " Like {these}."
+    f" But not {this}."
+)
+
+class A:
+    class B:
+        def foo():
+            st_error = STError(
+                f"This string ({string_leaf.value}) appears to be pointless (i.e. has"
+                " no parent)."
+            )
+
+def foo():
+    user_regex = _lazy_re_compile(
+        r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\Z"  # dot-atom
+        r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"\Z)',  # quoted-string
+        re.IGNORECASE)
+
+def foo():
+    user_regex = _lazy_re_compile(
+        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # dot-atom
+        'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',  # quoted-string
+        xyz
+    )
+
+def foo():
+    user_regex = _lazy_re_compile(
+        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # dot-atom
+        'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',  # quoted-string
+        xyz
+    )
+
+class A:
+    class B:
+        def foo():
+            if not hasattr(module, name):
+                raise ValueError(
+                    "Could not find object %s in %s.\n"
+                    "Please note that you cannot serialize things like inner "
+                    "classes. Please move the object into the main module "
+                    "body to use migrations.\n"
+                    "For more information, see "
+                    "https://docs.djangoproject.com/en/%s/topics/migrations/#serializing-values"
+                    % (name, module_name, get_docs_version()))
+
+class A:
+    class B:
+        def foo():
+            if not hasattr(module, name):
+                raise ValueError(
+                    "Could not find object %s in %s.\nPlease note that you cannot serialize things like inner classes. Please move the object into the main module body to use migrations.\nFor more information, see https://docs.djangoproject.com/en/%s/topics/migrations/#serializing-values"
+                    % (name, module_name, get_docs_version()))
+
+x = (
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+)
+
+class Step(StepBase):
+    def who(self):
+        self.cmd = 'SR AAAA-CORRECT NAME IS {last_name} {first_name}{middle_name} {title}/P{passenger_association}'.format(
+            last_name=last_name,
+            first_name=first_name,
+            middle_name=middle_name,
+            title=title,
+            passenger_association=passenger_association,
+        )
+
+# output
+
+
+class A:
+    def foo():
+        result = type(message)("")
+
+
+# Don't merge multiline (e.g. triple-quoted) strings.
+def foo():
+    query = (
+        """SELECT xxxxxxxxxxxxxxxxxxxx(xxx)"""
+        """ FROM xxxxxxxxxxxxxxxx WHERE xxxxxxxxxx AND xxx <> xxxxxxxxxxxxxx()"""
+    )
+
+
+# There was a bug where tuples were being identified as long strings.
+long_tuple = (
+    "Apple",
+    "Berry",
+    "Cherry",
+    "Dill",
+    "Evergreen",
+    "Fig",
+    "Grape",
+    "Harry",
+    "Iglu",
+    "Jaguar",
+)
+
+stupid_format_method_bug = (
+    "Some really long string that just so happens to be the {} {} to force the 'format'"
+    " method to hang over the line length boundary. This is pretty annoying.".format(
+        "perfect", "length"
+    )
+)
+
+
+class A:
+    def foo():
+        os.system(
+            "This is a regression test. xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx"
+            " xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx xxx"
+            " xxxx.".format("xxxxxxxxxx", "xxxxxx", "xxxxxxxxxx")
+        )
+
+
+class A:
+    def foo():
+        XXXXXXXXXXXX.append(
+            (
+                "xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx, xxxx_xxxx_xxxxxxxxxx={})"
+                .format(xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx),
+                my_var,
+                my_other_var,
+            )
+        )
+
+
+class A:
+    class B:
+        def foo():
+            bar(
+                "[{}]: xxx_xxxxxxxxxx(xxxxx={}, xxxx={}, xxxxx={}"
+                " xxxx_xxxx_xxxxxxxxxx={}, xxxx={})".format(
+                    xxxx._xxxxxxxxxxxxxx, xxxxx, xxxx, xxxx_xxxx_xxxxxxxxxx, xxxxxxx
+                ),
+                varX,
+                varY,
+                varZ,
+            )
+
+
+def foo(xxxx):
+    for (xxx_xxxx, _xxx_xxx, _xxx_xxxxx, xxx_xxxx) in xxxx:
+        for xxx in xxx_xxxx:
+            assert ("x" in xxx) or (xxx in xxx_xxx_xxxxx), (
+                "{0} xxxxxxx xx {1}, xxx {1} xx xxx xx xxxx xx xxx xxxx: xxx xxxx {2}"
+                .format(xxx_xxxx, xxx, xxxxxx.xxxxxxx(xxx_xxx_xxxxx))
+            )
+
+
+class A:
+    def disappearing_comment():
+        return (
+            (  # xx -x xxxxxxx xx xxx xxxxxxx.
+                "{{xxx_xxxxxxxxxx_xxxxxxxx}} xxx xxxx {} {{xxxx}} >&2".format(
+                    "{xxxx} {xxxxxx}"
+                    if xxxxx.xx_xxxxxxxxxx
+                    else (  # Disappearing Comment
+                        "--xxxxxxx --xxxxxx=x --xxxxxx-xxxxx=xxxxxx"
+                        " --xxxxxx-xxxx=xxxxxxxxxxx.xxx"
+                    )
+                )
+            ),
+            (x, y, z),
+        )
+
+
+class A:
+    class B:
+        def foo():
+            xxxxx_xxxx(
+                xx,
+                "\t"
+                "@xxxxxx '{xxxx_xxx}\t' > {xxxxxx_xxxx}.xxxxxxx;"
+                "{xxxx_xxx} >> {xxxxxx_xxxx}.xxxxxxx 2>&1; xx=$$?;"
+                "xxxx $$xx".format(
+                    xxxx_xxx=xxxx_xxxxxxx,
+                    xxxxxx_xxxx=xxxxxxx + "/" + xxxx_xxx_xxxx,
+                    x=xxx_xxxxx_xxxxx_xxx,
+                ),
+                x,
+                y,
+                z,
+            )
+
+
+func_call_where_string_arg_has_method_call_and_bad_parens(
+    "A long string with {}. This string is so long that it is ridiculous. It can't fit"
+    " on one line at alllll.".format("formatting"),
+)
+
+func_call_where_string_arg_has_old_fmt_and_bad_parens(
+    "A long string with {}. This string is so long that it is ridiculous. It can't fit"
+    " on one line at alllll."
+    % "formatting",
+)
+
+func_call_where_string_arg_has_old_fmt_and_bad_parens(
+    "A long string with {}. This {} is so long that it is ridiculous. It can't fit on"
+    " one line at alllll."
+    % ("formatting", "string"),
+)
+
+
+class A:
+    def append(self):
+        if True:
+            xxxx.xxxxxxx.xxxxx(
+                "xxxxxxxxxx xxxx xx xxxxxx(%x) xx %x xxxx xx xxx %x.xx"
+                % (len(self) + 1, xxxx.xxxxxxxxxx, xxxx.xxxxxxxxxx)
+                + " %.3f (%s) to %.3f (%s).\n"
+                % (
+                    xxxx.xxxxxxxxx,
+                    xxxx.xxxxxxxxxxxxxx(xxxx.xxxxxxxxx),
+                    x,
+                    xxxx.xxxxxxxxxxxxxx(xx),
+                )
+            )
+
+
+class A:
+    def foo():
+        some_func_call(
+            "xxxxxxxxxx",
+            "xx {xxxxxxxxxxx}/xxxxxxxxxxx.xxx xxxx.xxx && xxxxxx -x "
+            '"xxxx xxxxxxx xxxxxx xxxx; xxxx xxxxxx_xxxxx xxxxxx xxxx; '
+            "xxxx.xxxx_xxxxxx(['xxxx.xxx'], xxxx.xxxxxxx().xxxxxxxxxx)\" ",
+            None,
+            ("xxxxxxxxxxx",),
+        ),
+
+
+class A:
+    def foo():
+        some_func_call(
+            "xx {xxxxxxxxxxx}/xxxxxxxxxxx.xxx xxxx.xxx && xxxxxx -x "
+            "xxxx, ('xxxxxxx xxxxxx xxxx, xxxx') xxxxxx_xxxxx xxxxxx xxxx; "
+            "xxxx.xxxx_xxxxxx(['xxxx.xxx'], xxxx.xxxxxxx().xxxxxxxxxx)\" ",
+            None,
+            ("xxxxxxxxxxx",),
+        ),
+
+
+xxxxxxx = {
+    "xx": (
+        "xxxx xxxxxxx xxxxxxxxx -x xxx -x /xxx/{0} -x xxx,xxx -xx {1} -xx {1} -xx"
+        " xxx=xxx_xxxx,xxx_xx,xxx_xxx,xxx_xxxx,xxx_xx,xxx_xxx | xxxxxx -x xxxxxxxx -x"
+        " xxxxxxxx -x"
+    ),
+    "xx": (
+        "xxxx xxxxxxx xxxxxxxxx -x xxx -x /xxx/{0} -x xxx,xxx -xx {1} -xx {1} -xx"
+        " xxx=xxx_xxxx_xxx_xxxx,xxx_xx_xxx_xxxx,xxx_xxxx_xxx_xxxx,xxx_xx_xxxx_xxxx,xxx_xxx_xxxx,xxx_xxx_xxxx"
+        " xxxx=xxx | xxxxxx -x xxxxxxxx -x xxxxxxxx -x"
+    ),
+}
+
+
+class A:
+    def foo(self):
+        if True:
+            xxxxx_xxxxxxxxxxxx(
+                "xxx xxxxxx xxx xxxxxxxxx.xx xx xxxxxxxx.  xxx xxxxxxxxxxxxx.xx"
+                " xxxxxxx "
+                + "xx xxxxxx xxxxxx xxxxxx xx xxxxxxx xxx xxx ${0} xx x xxxxxxxx xxxxx"
+                .xxxxxx(xxxxxx_xxxxxx_xxx)
+            )
+
+
+class A:
+    class B:
+        def foo():
+            row = {
+                "xxxxxxxxxxxxxxx": xxxxxx_xxxxx_xxxx,
+                # 'xxxxxxxxxxxxxxxxxxxxxxx'
+                # 'xxxxxxxxxxxxxxxxxxxxxx'
+                # 'xxxxxxxxxxxxxxxxxx'
+                # 'xxxxxxxxxxxxxxxxx'
+                "xxxxxxxxxx": xxxxx_xxxxx,
+            }
+
+
+class A:
+    def xxxx_xxx_xx_xxxxxxxxxx_xxxx_xxxxxxxxx(xxxx):
+        xxxxxxxx = [
+            xxxxxxxxxxxxxxxx(
+                "xxxx",
+                xxxxxxxxxxx={"xxxx": 1.0,},
+                xxxxxx={"xxxxxx 1": xxxxxx(xxxx="xxxxxx 1", xxxxxx=600.0)},
+                xxxxxxxx_xxxxxxx=0.0,
+            ),
+            xxxxxxxxxxxxxxxx(
+                "xxxxxxx",
+                xxxxxxxxxxx={"xxxx": 1.0,},
+                xxxxxx={"xxxxxx 1": xxxxxx(xxxx="xxxxxx 1", xxxxxx=200.0)},
+                xxxxxxxx_xxxxxxx=0.0,
+            ),
+            xxxxxxxxxxxxxxxx("xxxx",),
+        ]
+
+
+some_dictionary = {
+    "xxxxx006": [
+        "xxx-xxx"
+        " xxxxx3xxxx1xx2xxxxxxxxxxxxxx0xx6xxxxxxxxxx2xxxxxx9xxxxxxxxxx0xxxxx1xxx2x/xx9xx6+x+xxxxxxxxxxxxxx4xxxxxxxxxxxxxxxxxxxxx43xxx2xx2x4x++xxx6xxxxxxxxx+xxxxx/xx9x+xxxxxxxxxxxxxx8x15xxxxxxxxxxxxxxxxx82xx/xxxxxxxxxxxxxx/x5xxxxxxxxxxxxxx6xxxxxx74x4/xxx4x+xxxxxxxxx2xxxxxxxx87xxxxx4xxxxxxxx3xx0xxxxx4xxx1xx9xx5xxxxxxx/xxxxx5xx6xx4xxxx1x/x2xxxxxxxxxxxx64xxxxxxx1x0xx5xxxxxxxxxxxxxx=="
+        " xxxxx000 xxxxxxxxxx\n",
+        "xxx-xxx"
+        " xxxxx3xxxx1xx2xxxxxxxxxxxxxx6xxxxxxxxxxxxxx9xxxxxxxxxxxxx3xxx9xxxxxxxxxxxxxxxx0xxxxxxxxxxxxxxxxx2xxxx2xxx6xxxxx/xx54xxxxxxxxx4xxx3xxxxxx9xx3xxxxx39xxxxxxxxx5xx91xxxx7xxxxxx8xxxxxxxxxxxxxxxx9xxx93xxxxxxxxxxxxxxxxx7xxx8xx8xx4/x1xxxxx1x3xxxxxxxxxxxxx3xxxxxx9xx4xx4x7xxxxxxxxxxxxx1xxxxxxxxx7xxxxxxxxxxxxxx4xx6xxxxxxxxx9xxx7xxxx2xxxxxxxxxxxxxxxxxxxxxx8xxxxxxxxxxxxxxxxxxxx6xx=="
+        " xxxxx010 xxxxxxxxxx\n",
+    ],
+    "xxxxx016": [
+        "xxx-xxx"
+        " xxxxx3xxxx1xx2xxxxxxxxxxxxxx0xx6xxxxxxxxxx2xxxxxx9xxxxxxxxxx0xxxxx1xxx2x/xx9xx6+x+xxxxxxxxxxxxxx4xxxxxxxxxxxxxxxxxxxxx43xxx2xx2x4x++xxx6xxxxxxxxx+xxxxx/xx9x+xxxxxxxxxxxxxx8x15xxxxxxxxxxxxxxxxx82xx/xxxxxxxxxxxxxx/x5xxxxxxxxxxxxxx6xxxxxx74x4/xxx4x+xxxxxxxxx2xxxxxxxx87xxxxx4xxxxxxxx3xx0xxxxx4xxx1xx9xx5xxxxxxx/xxxxx5xx6xx4xxxx1x/x2xxxxxxxxxxxx64xxxxxxx1x0xx5xxxxxxxxxxxxxx=="
+        " xxxxx000 xxxxxxxxxx\n",
+        "xxx-xxx"
+        " xxxxx3xxxx1xx2xxxxxxxxxxxxxx6xxxxxxxxxxxxxx9xxxxxxxxxxxxx3xxx9xxxxxxxxxxxxxxxx0xxxxxxxxxxxxxxxxx2xxxx2xxx6xxxxx/xx54xxxxxxxxx4xxx3xxxxxx9xx3xxxxx39xxxxxxxxx5xx91xxxx7xxxxxx8xxxxxxxxxxxxxxxx9xxx93xxxxxxxxxxxxxxxxx7xxx8xx8xx4/x1xxxxx1x3xxxxxxxxxxxxx3xxxxxx9xx4xx4x7xxxxxxxxxxxxx1xxxxxxxxx7xxxxxxxxxxxxxx4xx6xxxxxxxxx9xxx7xxxx2xxxxxxxxxxxxxxxxxxxxxx8xxxxxxxxxxxxxxxxxxxx6xx=="
+        " xxxxx010 xxxxxxxxxx\n",
+    ],
+}
+
+
+def foo():
+    xxx_xxx = (  # xxxx xxxxxxxxxx xxxx xx xxxx xx xxx xxxxxxxx xxxxxx xxxxx.
+        'xxxx xxx xxxxxxxx_xxxx xx "xxxxxxxxxx".\n xxx: xxxxxx xxxxxxxx_xxxx=xxxxxxxxxx'
+    )
+
+
+some_tuple = ("some string", "some string which should be joined")
+
+some_commented_string = (  # This comment gets thrown to the top.
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"
+    " {} that I just can't think of any more good words to say about it at"
+    " allllllllllll".format("ha")  # comments here are fine
+)
+
+some_commented_string = (
+    "This string is long but not so long that it needs hahahah toooooo be so greatttt"  # But these
+    " {} that I just can't think of any more good words to say about it at"  # comments will stay
+    " allllllllllll".format("ha")  # comments here are fine
+)
+
+lpar_and_rpar_have_comments = func_call(  # LPAR Comment
+    "Long really ridiculous type of string that shouldn't really even exist at all. I"
+    " mean commmme onnn!!!",  # Comma Comment
+)  # RPAR Comment
+
+cmd_fstring = (
+    "sudo -E deluge-console info --detailed --sort-reverse=time_added "
+    f"{'' if ID is None else ID} | perl -nE 'print if /^{field}:/'"
+)
+
+cmd_fstring = (
+    "sudo -E deluge-console info --detailed --sort-reverse=time_added"
+    f" {'' if ID is None else ID} | perl -nE 'print if /^{field}:/'"
+)
+
+cmd_fstring = (
+    "sudo -E deluge-console info --detailed --sort-reverse=time_added"
+    f" {'{{}}' if ID is None else ID} | perl -nE 'print if /^{field}:/'"
+)
+
+cmd_fstring = (
+    "sudo -E deluge-console info --detailed --sort-reverse=time_added {'' if ID is"
+    f" None else ID}} | perl -nE 'print if /^{field}:/'"
+)
+
+fstring = (
+    "This string really doesn't need to be an {{fstring}}, but this one most"
+    f" certainly, absolutely {does}."
+)
+
+fstring = f"We have to remember to escape {braces}. Like {{these}}. But not {this}."
+
+
+class A:
+    class B:
+        def foo():
+            st_error = STError(
+                f"This string ({string_leaf.value}) appears to be pointless (i.e. has"
+                " no parent)."
+            )
+
+
+def foo():
+    user_regex = _lazy_re_compile(
+        r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*\Z"  # dot-atom
+        r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"\Z)',  # quoted-string
+        re.IGNORECASE,
+    )
+
+
+def foo():
+    user_regex = _lazy_re_compile(
+        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # dot-atom
+        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",  # quoted-string
+        xyz,
+    )
+
+
+def foo():
+    user_regex = _lazy_re_compile(
+        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"  # dot-atom
+        "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",  # quoted-string
+        xyz,
+    )
+
+
+class A:
+    class B:
+        def foo():
+            if not hasattr(module, name):
+                raise ValueError(
+                    "Could not find object %s in %s.\n"
+                    "Please note that you cannot serialize things like inner "
+                    "classes. Please move the object into the main module "
+                    "body to use migrations.\n"
+                    "For more information, see "
+                    "https://docs.djangoproject.com/en/%s/topics/migrations/#serializing-values"
+                    % (name, module_name, get_docs_version())
+                )
+
+
+class A:
+    class B:
+        def foo():
+            if not hasattr(module, name):
+                raise ValueError(
+                    "Could not find object %s in %s.\nPlease note that you cannot"
+                    " serialize things like inner classes. Please move the object into"
+                    " the main module body to use migrations.\nFor more information,"
+                    " see https://docs.djangoproject.com/en/%s/topics/migrations/#serializing-values"
+                    % (name, module_name, get_docs_version())
+                )
+
+
+x = (
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
+)
+
+
+class Step(StepBase):
+    def who(self):
+        self.cmd = (
+            "SR AAAA-CORRECT NAME IS {last_name} {first_name}{middle_name}"
+            " {title}/P{passenger_association}".format(
+                last_name=last_name,
+                first_name=first_name,
+                middle_name=middle_name,
+                title=title,
+                passenger_association=passenger_association,
+            )
+        )
diff --git a/tests/data/string_quotes.py b/tests/data/string_quotes.py
index 6b68699..5a4bc5d 100644
--- a/tests/data/string_quotes.py
+++ b/tests/data/string_quotes.py
@@ -79,12 +79,7 @@
 r'Tricky "quote'
 r"Not-so-tricky \"quote"
 rf"{yay}"
-"\n\
-The \"quick\"\n\
-brown fox\n\
-jumps over\n\
-the 'lazy' dog.\n\
-"
+"\nThe \"quick\"\nbrown fox\njumps over\nthe 'lazy' dog.\n"
 re.compile(r'[\\"]')
 "x = ''; y = \"\""
 "x = '''; y = \"\""
@@ -104,4 +99,4 @@
 f'\'{z}\' {y * " "}'
 f"{y * x} '{z}'"
 "'{z}' {y * \" \"}"
-"{y * x} '{z}'"
\ No newline at end of file
+"{y * x} '{z}'"
diff --git a/tests/test_black.py b/tests/test_black.py
index 15b6341..0e73eb1 100644
--- a/tests/test_black.py
+++ b/tests/test_black.py
@@ -243,8 +243,8 @@ def test_piping(self) -> None:
 
     def test_piping_diff(self) -> None:
         diff_header = re.compile(
-            rf"(STDIN|STDOUT)\t\d\d\d\d-\d\d-\d\d "
-            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
+            rf"(STDIN|STDOUT)\t\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d\d\d\d "
+            rf"\+\d\d\d\d"
         )
         source, _ = read_data("expression.py")
         expected, _ = read_data("expression.diff")
@@ -333,7 +333,7 @@ def test_expression_diff(self) -> None:
         tmp_file = Path(black.dump_to_file(source))
         diff_header = re.compile(
             rf"{re.escape(str(tmp_file))}\t\d\d\d\d-\d\d-\d\d "
-            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
+            r"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
         )
         try:
             result = BlackRunner().invoke(black.main, ["--diff", str(tmp_file)])
@@ -346,9 +346,9 @@ def test_expression_diff(self) -> None:
         if expected != actual:
             dump = black.dump_to_file(actual)
             msg = (
-                f"Expected diff isn't equal to the actual. If you made changes "
-                f"to expression.py and this is an anticipated difference, "
-                f"overwrite tests/data/expression.diff with {dump}"
+                "Expected diff isn't equal to the actual. If you made changes to"
+                " expression.py and this is an anticipated difference, overwrite"
+                f" tests/data/expression.diff with {dump}"
             )
             self.assertEqual(expected, actual, msg)
 
@@ -386,10 +386,37 @@ def test_string_quotes(self) -> None:
         black.assert_stable(source, actual, black.FileMode())
         mode = black.FileMode(string_normalization=False)
         not_normalized = fs(source, mode=mode)
-        self.assertFormatEqual(source, not_normalized)
+        self.assertFormatEqual(source.replace("\\\n", ""), not_normalized)
         black.assert_equivalent(source, not_normalized)
         black.assert_stable(source, not_normalized, mode=mode)
 
+    @patch("black.dump_to_file", dump_to_stderr)
+    def test_long_strings(self) -> None:
+        """Tests for splitting long strings."""
+        source, expected = read_data("long_strings")
+        actual = fs(source)
+        self.assertFormatEqual(expected, actual)
+        black.assert_equivalent(source, actual)
+        black.assert_stable(source, actual, black.FileMode())
+
+    @patch("black.dump_to_file", dump_to_stderr)
+    def test_long_strings__edge_case(self) -> None:
+        """Edge-case tests for splitting long strings."""
+        source, expected = read_data("long_strings__edge_case")
+        actual = fs(source)
+        self.assertFormatEqual(expected, actual)
+        black.assert_equivalent(source, actual)
+        black.assert_stable(source, actual, black.FileMode())
+
+    @patch("black.dump_to_file", dump_to_stderr)
+    def test_long_strings__regression(self) -> None:
+        """Regression tests for splitting long strings."""
+        source, expected = read_data("long_strings__regression")
+        actual = fs(source)
+        self.assertFormatEqual(expected, actual)
+        black.assert_equivalent(source, actual)
+        black.assert_stable(source, actual, black.FileMode())
+
     @patch("black.dump_to_file", dump_to_stderr)
     def test_slices(self) -> None:
         source, expected = read_data("slices")
@@ -746,8 +773,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "1 file reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                "1 file reformatted, 2 files left unchanged, 1 file failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f3"), black.Changed.YES)
@@ -756,8 +783,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(out_lines[-1], "reformatted f3")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 1 file failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.failed(Path("e2"), "boom")
@@ -766,8 +793,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.path_ignored(Path("wat"), "no match")
@@ -776,8 +803,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(out_lines[-1], "wat ignored: no match")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f4"), black.Changed.NO)
@@ -786,22 +813,22 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(out_lines[-1], "f4 already well formatted, good job.")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 3 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 3 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.check = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                "2 files would be reformatted, 3 files would be left unchanged, 2 files"
+                " would fail to reformat.",
             )
             report.check = False
             report.diff = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                "2 files would be reformatted, 3 files would be left unchanged, 2 files"
+                " would fail to reformat.",
             )
 
     def test_report_quiet(self) -> None:
@@ -843,8 +870,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "1 file reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                "1 file reformatted, 2 files left unchanged, 1 file failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f3"), black.Changed.YES)
@@ -852,8 +879,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(len(err_lines), 1)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 1 file failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.failed(Path("e2"), "boom")
@@ -862,8 +889,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.path_ignored(Path("wat"), "no match")
@@ -871,8 +898,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f4"), black.Changed.NO)
@@ -880,22 +907,22 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 3 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 3 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.check = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                "2 files would be reformatted, 3 files would be left unchanged, 2 files"
+                " would fail to reformat.",
             )
             report.check = False
             report.diff = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                "2 files would be reformatted, 3 files would be left unchanged, 2 files"
+                " would fail to reformat.",
             )
 
     def test_report_normal(self) -> None:
@@ -939,8 +966,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "1 file reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                "1 file reformatted, 2 files left unchanged, 1 file failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f3"), black.Changed.YES)
@@ -949,8 +976,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(out_lines[-1], "reformatted f3")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "1 file failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 1 file failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.failed(Path("e2"), "boom")
@@ -959,8 +986,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.path_ignored(Path("wat"), "no match")
@@ -968,8 +995,8 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 2 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 2 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.done(Path("f4"), black.Changed.NO)
@@ -977,22 +1004,22 @@ def err(msg: str, **kwargs: Any) -> None:
             self.assertEqual(len(err_lines), 2)
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files reformatted, 3 files left unchanged, "
-                "2 files failed to reformat.",
+                "2 files reformatted, 3 files left unchanged, 2 files failed to"
+                " reformat.",
             )
             self.assertEqual(report.return_code, 123)
             report.check = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                "2 files would be reformatted, 3 files would be left unchanged, 2 files"
+                " would fail to reformat.",
             )
             report.check = False
             report.diff = True
             self.assertEqual(
                 unstyle(str(report)),
-                "2 files would be reformatted, 3 files would be left unchanged, "
-                "2 files would fail to reformat.",
+                "2 files would be reformatted, 3 files would be left unchanged, 2 files"
+                " would fail to reformat.",
             )
 
     def test_lib2to3_parse(self) -> None:
@@ -1753,8 +1780,7 @@ async def test_blackd_pyi(self) -> None:
     @unittest_run_loop
     async def test_blackd_diff(self) -> None:
         diff_header = re.compile(
-            rf"(In|Out)\t\d\d\d\d-\d\d-\d\d "
-            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
+            rf"(In|Out)\t\d\d\d\d-\d\d-\d\d \d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
         )
 
         source, _ = read_data("blackd_diff.py")
