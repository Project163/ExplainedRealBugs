diff --git a/black.py b/black.py
index d3e0761..877b632 100644
--- a/black.py
+++ b/black.py
@@ -510,10 +510,16 @@ def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
         ):
             return False
 
-        if closing.type == token.RSQB or closing.type == token.RBRACE:
+        if closing.type == token.RBRACE:
             self.leaves.pop()
             return True
 
+        if closing.type == token.RSQB:
+            comma = self.leaves[-1]
+            if comma.parent and comma.parent.type == syms.listmaker:
+                self.leaves.pop()
+                return True
+
         # For parens let's check if it's safe to remove the comma.  If the
         # trailing one is the only one, we might mistakenly change a tuple
         # into a different type by removing the comma.
diff --git a/tests/expression.py b/tests/expression.py
index 91e5465..79e7c7e 100644
--- a/tests/expression.py
+++ b/tests/expression.py
@@ -53,6 +53,7 @@
 (1, 2, 3)
 []
 [1, 2, 3, 4, 5, 6, 7, 8, 9, (10 or A), (11 or B), (12 or C)]
+[1, 2, 3,]
 {i for i in (1, 2, 3)}
 {(i ** 2) for i in (1, 2, 3)}
 {(i ** 2) for i, _ in ((1, 'a'), (2, 'b'), (3, 'c'))}
@@ -84,7 +85,10 @@
 list[str]
 dict[str, int]
 tuple[str, ...]
-tuple[str, int, float, dict[str, int]]
+tuple[str, int, float, dict[str, int],]
+very_long_variable_name_filters: t.List[
+    t.Tuple[str, t.Union[str, t.List[t.Optional[str]]]],
+]
 slice[0]
 slice[0:1]
 slice[0:1:2]
@@ -207,6 +211,7 @@ async def f():
 (1, 2, 3)
 []
 [1, 2, 3, 4, 5, 6, 7, 8, 9, (10 or A), (11 or B), (12 or C)]
+[1, 2, 3]
 {i for i in (1, 2, 3)}
 {(i ** 2) for i in (1, 2, 3)}
 {(i ** 2) for i, _ in ((1, 'a'), (2, 'b'), (3, 'c'))}
@@ -248,6 +253,9 @@ async def f():
 dict[str, int]
 tuple[str, ...]
 tuple[str, int, float, dict[str, int]]
+very_long_variable_name_filters: t.List[
+    t.Tuple[str, t.Union[str, t.List[t.Optional[str]]]],
+]
 slice[0]
 slice[0:1]
 slice[0:1:2]
