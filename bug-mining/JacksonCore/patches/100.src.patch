diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index ee5c2f30..22665aef 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -19,6 +19,7 @@ JSON library.
 #652: Misleading exception for input source when processing byte buffer
   with start offset
  (reported by Greg W)
+#658: Escape contents of source document snippet for `JsonLocation._appendSourceDesc()`
 #664: Add `StreamWriteException` type to eventually replace `JsonGenerationException`
 #671: Replace `getCurrentLocation()`/`getTokenLocation()` with
   `currentLocation()`/`currentTokenLocation()` in `JsonParser`
diff --git a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java
index 1f1c12e5..fb42b625 100644
--- a/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java
+++ b/src/main/java/com/fasterxml/jackson/core/io/CharTypes.java
@@ -236,6 +236,21 @@ public final class CharTypes
         return sHexValues[ch & 0xFF];
     }
 
+    // @since 2.13
+    public static char hexToChar(int ch)
+    {
+        return HC[ch];
+    }
+
+    /**
+     * Helper method for appending JSON-escaped version of contents
+     * into specific {@link StringBuilder}, using default JSON specification
+     * mandated minimum escaping rules.
+     *
+     * @param sb Buffer to append escaped contents in
+     *
+     * @param content Unescaped String value to append with escaping applied
+     */
     public static void appendQuoted(StringBuilder sb, String content)
     {
         final int[] escCodes = sOutputEscapes128;
@@ -277,7 +292,13 @@ public final class CharTypes
         return (byte[]) HB.clone();
     }
 
-    // @since 2.10
+    /**
+     * Helper used for lazy initialization of alternative escape (quoting)
+     * table, used for escaping content that uses non-standard quote
+     * character (usually apostrophe).
+     *
+     * @since 2.10
+     */
     private static class AltEscapes {
         public final static AltEscapes instance = new AltEscapes();
 
diff --git a/src/main/java/com/fasterxml/jackson/core/io/ContentReference.java b/src/main/java/com/fasterxml/jackson/core/io/ContentReference.java
index a204f7ee..2cf920d6 100644
--- a/src/main/java/com/fasterxml/jackson/core/io/ContentReference.java
+++ b/src/main/java/com/fasterxml/jackson/core/io/ContentReference.java
@@ -16,7 +16,7 @@ import java.nio.charset.Charset;
  * @since 2.13
  */
 public class ContentReference
-    // sort of: we will read back as "UNKNOWN_INPUT"
+    // sort of: we will read back as "UNKNOWN"
     implements java.io.Serializable
 {
     private static final long serialVersionUID = 1L;
@@ -253,31 +253,36 @@ public class ContentReference
                 }
             }
         } else {
-            // What should we do with binary content? Indicate length, if plausible
+            // What should we do with binary content? Indicate length, if possible
             if (srcRef instanceof byte[]) {
+                int length = contentLength();
+                // -1 is marker for "till the end" (should we consider offset then, too?)
+                if (length < 0) {
+                    length = ((byte[]) srcRef).length;
+                }
                 sb.append('[')
-                    .append(((byte[]) srcRef).length)
+                    .append(length)
                     .append(" bytes]");
             }
         }
         return sb;
     }
 
-    private String _truncate(CharSequence cs, int[] offsets, int maxSnippetLen) {
+    protected String _truncate(CharSequence cs, int[] offsets, int maxSnippetLen) {
         _truncateOffsets(offsets, cs.length());
         final int start = offsets[0];
         final int length = Math.min(offsets[1], maxSnippetLen);
         return cs.subSequence(start, start + length).toString();
     }
 
-    private String _truncate(char[] cs, int[] offsets, int maxSnippetLen) {
+    protected String _truncate(char[] cs, int[] offsets, int maxSnippetLen) {
         _truncateOffsets(offsets, cs.length);
         final int start = offsets[0];
         final int length = Math.min(offsets[1], maxSnippetLen);
         return new String(cs, start, length);
     }
 
-    private String _truncate(byte[] b, int[] offsets, int maxSnippetLen) {
+    protected String _truncate(byte[] b, int[] offsets, int maxSnippetLen) {
         _truncateOffsets(offsets, b.length);
         final int start = offsets[0];
         final int length = Math.min(offsets[1], maxSnippetLen);
@@ -286,7 +291,7 @@ public class ContentReference
 
     // Method that is given alleged start/offset pair and needs to adjust
     // these to fit
-    private void _truncateOffsets(int[] offsets, int actualLength) {
+    protected void _truncateOffsets(int[] offsets, int actualLength) {
         int start = offsets[0];
         // first, move start to be within area
         if (start < 0) { // means effectively "start at beginning"
@@ -304,11 +309,36 @@ public class ContentReference
         }
     }
 
-    private int _append(StringBuilder sb, String content) {
-        sb.append('"').append(content).append('"');
+    protected int _append(StringBuilder sb, String content) {
+        sb.append('"');
+        // [core#658]: make sure to escape non-printable
+        for (int i = 0, end = content.length(); i < end; ++i) {
+            // 06-Apr-2021, tatu: Gee... there is no "Character.isPrintable()",
+            //   and from what I can see things get rather complicated trying
+            //   to figure out proper way. Hence, we'll do this
+            char ch = content.charAt(i);
+            if (!Character.isISOControl(ch) || !_appendEscaped(sb, ch)) {
+                sb.append(ch);
+            }
+        }
+        sb.append('"');
         return content.length();
     }
 
+    protected boolean _appendEscaped(StringBuilder sb, int ctrlChar) {
+        // We'll escape most, but NOT regular CR or LF
+        if (ctrlChar == '\r' || ctrlChar == '\n') {
+            return false;
+        }
+        sb.append('\\');
+        sb.append('u');
+        sb.append(CharTypes.hexToChar((ctrlChar >> 12) & 0xF));
+        sb.append(CharTypes.hexToChar((ctrlChar >> 8) & 0xF));
+        sb.append(CharTypes.hexToChar((ctrlChar >> 4) & 0xF));
+        sb.append(CharTypes.hexToChar(ctrlChar & 0xF));
+        return true;
+    }
+    
     /*
     /**********************************************************************
     /* Standard method overrides
diff --git a/src/test/java/com/fasterxml/jackson/core/TestLocation.java b/src/test/java/com/fasterxml/jackson/core/TestLocation.java
index ba3eb463..b5cad2a7 100644
--- a/src/test/java/com/fasterxml/jackson/core/TestLocation.java
+++ b/src/test/java/com/fasterxml/jackson/core/TestLocation.java
@@ -76,6 +76,16 @@ public class TestLocation extends BaseTest
         assertEquals(String.format("(byte[])\"%s\"[truncated 3 bytes]", main), desc);
     }
 
+    // for [jackson-core#658]
+    public void testEscapeNonPrintable() throws Exception
+    {
+        final String DOC = "[ \"tab:[\t]/null:[\0]\" ]";
+        JsonLocation loc = new JsonLocation(_sourceRef(DOC), 0L, 0L, -1, -1);
+        final String sourceDesc = loc.sourceDescription();
+        assertEquals(String.format("(String)\"[ \"tab:[%s]/null:[%s]\" ]\"",
+                "\\u0009", "\\u0000"), sourceDesc);
+    }
+
     // for [jackson-core#356]
     public void testDisableSourceInclusion() throws Exception
     {
