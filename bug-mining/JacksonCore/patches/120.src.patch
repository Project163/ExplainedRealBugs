diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
index 89ae7350..88f59274 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
@@ -555,34 +555,53 @@ public abstract class ParserBase extends ParserMinimalBase
     // // // Life-cycle of number-parsing
     
     protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen)
+        throws JsonParseException
     {
         if (fractLen < 1 && expLen < 1) { // integer
             return resetInt(negative, intLen);
         }
         return resetFloat(negative, intLen, fractLen, expLen);
     }
-        
+
     protected final JsonToken resetInt(boolean negative, int intLen)
+        throws JsonParseException
     {
+        // Inelegant but we know how to create StreamReadExceptions,
+        // constraints object doesn't. May refactor in near future.
+        try {
+            _streamReadConstraints.validateIntegerLength(intLen);
+        } catch (NumberFormatException e) {
+            reportInvalidNumber(e.getMessage());
+        }
         _numberNegative = negative;
         _intLength = intLen;
         _fractLength = 0;
         _expLength = 0;
-        _numTypesValid = NR_UNKNOWN; // to force parsing
+        _numTypesValid = NR_UNKNOWN; // to force decoding
         return JsonToken.VALUE_NUMBER_INT;
     }
     
     protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen)
+        throws JsonParseException
     {
+        // Inelegant but we know how to create StreamReadExceptions,
+        // constraints object doesn't. May refactor in near future.
+        // Length is approximate, good enough for validation
+        try {
+            _streamReadConstraints.validateFPLength(intLen + fractLen + expLen);
+        } catch (NumberFormatException e) {
+            reportInvalidNumber(e.getMessage());
+        }
         _numberNegative = negative;
         _intLength = intLen;
         _fractLength = fractLen;
         _expLength = expLen;
-        _numTypesValid = NR_UNKNOWN; // to force parsing
+        _numTypesValid = NR_UNKNOWN; // to force decoding
         return JsonToken.VALUE_NUMBER_FLOAT;
     }
     
     protected final JsonToken resetAsNaN(String valueStr, double value)
+        throws JsonParseException
     {
         _textBuffer.resetWithString(valueStr);
         _numberDouble = value;
@@ -914,12 +933,10 @@ public abstract class ParserBase extends ParserMinimalBase
                 // 04-Dec-2022, tatu: Let's defer actual decoding until it is certain
                 //    value is actually needed.
                 _numberBigDecimal = null;
-                String numStr = _textBuffer.contentsAsString();
-                streamReadConstraints().validateFPLength(numStr.length());
-                _numberString = numStr;
+                _numberString = _textBuffer.contentsAsString();
                 _numTypesValid = NR_BIGDECIMAL;
             } else if (expType == NR_FLOAT) {
-                _numberFloat = _textBuffer.contentsAsFloat(streamReadConstraints(),
+                _numberFloat = _textBuffer.contentsAsFloat(
                         isEnabled(Feature.USE_FAST_DOUBLE_PARSER));
                 _numTypesValid = NR_FLOAT;
             } else {
@@ -927,7 +944,7 @@ public abstract class ParserBase extends ParserMinimalBase
                 // 04-Dec-2022, tatu: We can get all kinds of values here, NR_DOUBLE
                 //    but also NR_INT or even NR_UNKNOWN. Shouldn't we try further
                 //    deferring some typing?
-                _numberDouble = _textBuffer.contentsAsDouble(streamReadConstraints(),
+                _numberDouble = _textBuffer.contentsAsDouble(
                         isEnabled(Feature.USE_FAST_DOUBLE_PARSER));
                 _numTypesValid = NR_DOUBLE;
             }
@@ -958,11 +975,9 @@ public abstract class ParserBase extends ParserMinimalBase
                     _reportTooLongIntegral(expType, numStr);
                 }
                 if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) {
-                    streamReadConstraints().validateFPLength(numStr.length());
                     _numberDouble = NumberInput.parseDouble(numStr, isEnabled(Feature.USE_FAST_DOUBLE_PARSER));
                     _numTypesValid = NR_DOUBLE;
                 } else {
-                    streamReadConstraints().validateIntegerLength(numStr.length());
                     // nope, need the heavy guns... (rare case) - since Jackson v2.14, BigInteger parsing is lazy
                     _numberBigInt = null;
                     _numberString = numStr;
@@ -1134,7 +1149,6 @@ public abstract class ParserBase extends ParserMinimalBase
             // Let's actually parse from String representation, to avoid
             // rounding errors that non-decimal floating operations could incur
             final String numStr = getText();
-            streamReadConstraints().validateFPLength(numStr.length());
             _numberBigDecimal = NumberInput.parseBigDecimal(numStr);
         } else if ((_numTypesValid & NR_BIGINT) != 0) {
             _numberBigDecimal = new BigDecimal(_getBigInteger());
diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
index 0320bc15..c9da2e64 100644
--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
@@ -1,10 +1,8 @@
 package com.fasterxml.jackson.core.util;
 
 import java.io.*;
-import java.math.BigDecimal;
 import java.util.*;
 
-import com.fasterxml.jackson.core.StreamReadConstraints;
 import com.fasterxml.jackson.core.io.NumberInput;
 
 /**
@@ -480,47 +478,6 @@ public final class TextBuffer
         return result;
     }
 
-    /**
-     * Convenience method for converting contents of the buffer
-     * into a {@link BigDecimal}.
-     *
-     * @param constraints constraints for stream reading
-     * @param useFastParser whether to use {@code FastDoubleParser}
-     * @return Buffered text value parsed as a {@link BigDecimal}, if possible
-     *
-     * @throws NumberFormatException if contents are not a valid Java number
-     *
-     * @since 2.15
-     */
-    public BigDecimal contentsAsDecimal(final StreamReadConstraints constraints,
-                                        final boolean useFastParser) throws NumberFormatException
-    {
-        // Already got a pre-cut array?
-        if (_resultArray != null) {
-            constraints.validateFPLength(_resultArray.length);
-            return NumberInput.parseBigDecimal(_resultArray, useFastParser);
-        }
-        // Or a shared buffer?
-        if ((_inputStart >= 0) && (_inputBuffer != null)) {
-            constraints.validateFPLength(_inputLen);
-            return NumberInput.parseBigDecimal(_inputBuffer, _inputStart, _inputLen, useFastParser);
-        }
-        // Or if not, just a single buffer (the usual case)
-        if ((_segmentSize == 0) && (_currentSegment != null)) {
-            constraints.validateFPLength(_currentSize);
-            return NumberInput.parseBigDecimal(_currentSegment, 0, _currentSize, useFastParser);
-        }
-        // If not, let's just get it aggregated...
-        final char[] numArray = contentsAsArray();
-        constraints.validateFPLength(numArray.length);
-        return NumberInput.parseBigDecimal(numArray, useFastParser);
-    }
-
-    @Deprecated // @since 2.15
-    public BigDecimal contentsAsDecimal() throws NumberFormatException {
-        return contentsAsDecimal(StreamReadConstraints.defaults(), false);
-    }
-
     /**
      * Convenience method for converting contents of the buffer
      * into a Double value.
@@ -532,11 +489,8 @@ public final class TextBuffer
      *
      * @since 2.15
      */
-    public double contentsAsDouble(final StreamReadConstraints constraints,
-            final boolean useFastParser) throws NumberFormatException {
-        final String numStr = contentsAsString();
-        constraints.validateFPLength(numStr.length());
-        return NumberInput.parseDouble(numStr, useFastParser);
+    public double contentsAsDouble(final boolean useFastParser) throws NumberFormatException {
+        return NumberInput.parseDouble(contentsAsString(), useFastParser);
     }
 
     @Deprecated // @since 2.14
@@ -544,21 +498,11 @@ public final class TextBuffer
         return contentsAsDouble(false);
     }
 
-    @Deprecated // @since 2.15
-    public double contentsAsDouble(boolean useFastParser) throws NumberFormatException {
-        return contentsAsDouble(StreamReadConstraints.defaults(), useFastParser);
-    }
-
     @Deprecated // @since 2.14
     public float contentsAsFloat() throws NumberFormatException {
         return contentsAsFloat(false);
     }
 
-    @Deprecated // @since 2.15
-    public float contentsAsFloat(boolean useFastParser) throws NumberFormatException {
-        return contentsAsFloat(StreamReadConstraints.defaults(), useFastParser);
-    }
-
     /**
      * Convenience method for converting contents of the buffer
      * into a Float value.
@@ -569,10 +513,8 @@ public final class TextBuffer
      * @throws NumberFormatException if contents are not a valid Java number
      * @since 2.15
      */
-    public float contentsAsFloat(final StreamReadConstraints constraints,
-            final boolean useFastParser) throws NumberFormatException {
+    public float contentsAsFloat(boolean useFastParser) throws NumberFormatException {
         final String numStr = contentsAsString();
-        constraints.validateFPLength(numStr.length());
         return NumberInput.parseFloat(numStr, useFastParser);
     }
 
diff --git a/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java b/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java
index 38388af1..288af553 100644
--- a/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java
@@ -13,6 +13,7 @@ public class NumberOverflowTest
             .build();
 
     // NOTE: this should be long enough to trigger perf problems
+    // 19-
     private final static int BIG_NUM_LEN = 199999;
     private final static String BIG_POS_INTEGER;
     static {
@@ -67,7 +68,7 @@ public class NumberOverflowTest
     {
         for (int mode : ALL_STREAMING_MODES) {
             for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
-                JsonParser p = createParser(mode, doc);
+                JsonParser p = createParser(FACTORY, mode, doc);
                 assertToken(JsonToken.START_ARRAY, p.nextToken());
                 assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
                 try {
@@ -87,7 +88,7 @@ public class NumberOverflowTest
     {
         for (int mode : ALL_STREAMING_MODES) {
             for (String doc : new String[] { BIG_POS_DOC, BIG_NEG_DOC }) {
-                JsonParser p = createParser(mode, doc);
+                JsonParser p = createParser(FACTORY, mode, doc);
                 assertToken(JsonToken.START_ARRAY, p.nextToken());
                 assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
                 try {
diff --git a/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java b/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
index b038eb10..04f06ecf 100644
--- a/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
@@ -9,6 +9,7 @@ import java.math.BigInteger;
 
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.core.exc.InputCoercionException;
+import com.fasterxml.jackson.core.exc.StreamReadException;
 import com.fasterxml.jackson.core.io.NumberInput;
 import com.fasterxml.jackson.core.json.JsonReadFeature;
 
@@ -500,15 +501,15 @@ public class NumberParsingTest
     {
         try {
             _testBigBigDecimals(MODE_INPUT_STREAM, false);
-        } catch (JsonParseException jpe) {
-            assertTrue("unexpected exception message: " + jpe.getMessage(),
-                    jpe.getMessage().startsWith("Malformed numeric value ([number with 1824 characters])"));
+            fail("Should not pass");
+        } catch (StreamReadException e) {
+            verifyException(e, "Invalid numeric value ", "exceeds the maximum length");
         }
         try {
             _testBigBigDecimals(MODE_INPUT_STREAM_THROTTLED, false);
-        } catch (JsonParseException jpe) {
-            assertTrue("unexpected exception message: " + jpe.getMessage(),
-                    jpe.getMessage().startsWith("Malformed numeric value ([number with 1824 characters])"));
+            fail("Should not pass");
+        } catch (StreamReadException jpe) {
+            verifyException(jpe, "Invalid numeric value ", "exceeds the maximum length");
         }
     }
 
@@ -516,9 +517,9 @@ public class NumberParsingTest
     {
         try {
             _testBigBigDecimals(MODE_READER, false);
-        } catch (JsonParseException jpe) {
-            assertTrue("unexpected exception message: " + jpe.getMessage(),
-                    jpe.getMessage().startsWith("Malformed numeric value ([number with 1824 characters])"));
+            fail("Should not pass");
+        } catch (StreamReadException jpe) {
+            verifyException(jpe, "Invalid numeric value ", "exceeds the maximum length");
         }
     }
 
@@ -531,9 +532,9 @@ public class NumberParsingTest
     {
         try {
             _testBigBigDecimals(MODE_DATA_INPUT, false);
-        } catch (JsonParseException jpe) {
-            assertTrue("unexpected exception message: " + jpe.getMessage(),
-                    jpe.getMessage().startsWith("Malformed numeric value ([number with 1824 characters])"));
+            fail("Should not pass");
+        } catch (StreamReadException jpe) {
+            verifyException(jpe, "Invalid numeric value ", "exceeds the maximum length");
         }
     }
 
@@ -719,10 +720,11 @@ public class NumberParsingTest
     }
 
     // [jackson-core#157]
+    // 19-Dec-2022, tatu: Reduce length so as not to hit too-long-number limit
     public void testLongNumbers() throws Exception
     {
-        StringBuilder sb = new StringBuilder(9000);
-        for (int i = 0; i < 9000; ++i) {
+        StringBuilder sb = new StringBuilder(900);
+        for (int i = 0; i < 900; ++i) {
             sb.append('9');
         }
         String NUM = sb.toString();
@@ -941,9 +943,9 @@ public class NumberParsingTest
     public void testNegativeMaxNumberLength() {
         try {
             StreamReadConstraints src = StreamReadConstraints.builder().maxNumberLength(-1).build();
-            fail("expected IllegalArgumentException");
+            fail("expected IllegalArgumentException; instead built: "+src);
         } catch (IllegalArgumentException iae) {
-            // expected
+            verifyException(iae, "Cannot set maxNumberLength to a negative value");
         }
     }
 
