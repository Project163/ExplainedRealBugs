diff --git a/release-notes/VERSION b/release-notes/VERSION
index d5bdb592..c17d7fa9 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -19,6 +19,7 @@ JSON library.
 #17: Add 'JsonGenerator.writeString(Reader r, int charLength)'
  (constributed by Logan W)
 #304: Optimize `NumberOutput.outputLong()` method
+#306: Add new method in `JsonStreamContext` to construct `JsonPointer`
 #312: Add `JsonProcessingException.clearLocation()` to allow clearing
   possibly security-sensitive information
  (contributed by Alex Y)
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java
index 66819923..ad79515c 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java
@@ -11,7 +11,7 @@ import com.fasterxml.jackson.core.io.NumberInput;
  * It may be used in future for filtering of streaming JSON content
  * as well (not implemented yet for 2.3).
  *<p>
- * Instances are fully immutable and can be shared, cached.
+ * Instances are fully immutable and can be cached, shared between threads.
  * 
  * @author Tatu Saloranta
  *
@@ -137,6 +137,86 @@ public class JsonPointer
      */
     public static JsonPointer valueOf(String input) { return compile(input); }
 
+    /**
+     * Factory method that will construct a pointer instance that describes
+     * path to location given {@link JsonStreamContext} points to.
+     *
+     * @param context Context to build pointer expression fot
+     * @param includeRoot Whether to include number offset for virtual "root context"
+     *    or not.
+     *
+     * @since 2.9
+     */
+    public static JsonPointer forPath(JsonStreamContext context,
+            boolean includeRoot)
+    {
+        // First things first: last segment may be for START_ARRAY/START_OBJECT,
+        // in which case it does not yet point to anything, and should be skipped
+        if (context == null) {
+            return EMPTY;
+        }
+        if (!context.hasPathSegment()) {
+            // one special case; do not prune root if we need it
+            if (!(includeRoot && context.inRoot() && context.hasCurrentIndex())) {
+                context = context.getParent();
+            }
+        }
+        JsonPointer tail = null;
+
+        for (; context != null; context = context.getParent()) {
+            if (context.inObject()) {
+                String seg = context.getCurrentName();
+                if (seg == null) { // is this legal?
+                    seg = "";
+                }
+                tail = new JsonPointer(_fullPath(tail, seg), seg, tail);
+            } else if (context.inArray() || includeRoot) {
+                int ix = context.getCurrentIndex();
+                String ixStr = String.valueOf(ix);
+                tail = new JsonPointer(_fullPath(tail, ixStr), ixStr, ix, tail);
+            }
+            // NOTE: this effectively drops ROOT node(s); should have 1 such node,
+            // as the last one, but we don't have to care (probably some paths have
+            // no root, for example)
+        }
+        if (tail == null) {
+            return EMPTY;
+        }
+        return tail;
+    }
+
+    private static String _fullPath(JsonPointer tail, String segment)
+    {
+        if (tail == null) {
+            StringBuilder sb = new StringBuilder(segment.length()+1);
+            sb.append('/');
+            _appendEscaped(sb, segment);
+            return sb.toString();
+        }
+        String tailDesc = tail._asString;
+        StringBuilder sb = new StringBuilder(segment.length() + 1 + tailDesc.length());
+        sb.append('/');
+        _appendEscaped(sb, segment);
+        sb.append(tailDesc);
+        return sb.toString();
+    }
+
+    private static void _appendEscaped(StringBuilder sb, String segment)
+    {
+        for (int i = 0, end = segment.length(); i < end; ++i) {
+            char c = segment.charAt(i);
+           if (c == '/') {
+               sb.append("~1");
+               continue;
+           }
+           if (c == '~') {
+               sb.append("~0");
+               continue;
+           }
+           sb.append(c);
+        }
+    }
+    
     /* Factory method that composes a pointer instance, given a set
      * of 'raw' segments: raw meaning that no processing will be done,
      * no escaping may is present.
@@ -189,6 +269,22 @@ public class JsonPointer
         return current;
     }
 
+    /**
+     * Mutant factory method that will return
+     *<ul>
+     * <li>`tail` if `this` instance is "empty" pointer, OR
+     *  </li>
+     * <li>`this` instance if `tail` is "empty" pointer, OR
+     *  </li>
+     * <li>Newly constructed {@link JsonPointer} instance that starts with all segments
+     *    of `this`, followed by all segments of `tail`.
+     *  </li>
+     *</ul>
+     * 
+     * @param tail {@link JsonPointer} instance to append to this one, to create a new pointer instance
+     *
+     * @return Either `this` instance, `tail`, or a newly created combination, as per description above.
+     */
     public JsonPointer append(JsonPointer tail) {
         if (this == EMPTY) {
             return tail;
@@ -196,6 +292,9 @@ public class JsonPointer
         if (tail == EMPTY) {
             return this;
         }
+        // 21-Mar-2017, tatu: Not superbly efficient; could probably improve by not concatenating,
+        //    re-decoding -- by stitching together segments -- but for now should be fine.
+
         String currentJsonPointer = _asString;
         if (currentJsonPointer.endsWith("/")) {
             //removes final slash
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java b/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java
index ddadc92d..cfe075d0 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonStreamContext.java
@@ -101,7 +101,7 @@ public abstract class JsonStreamContext
         }
         return "?";
     }
-    
+
     /**
      * @return Number of entries that are complete and started.
      */
@@ -112,6 +112,41 @@ public abstract class JsonStreamContext
      */
     public final int getCurrentIndex() { return (_index < 0) ? 0 : _index; }
 
+    /**
+     * Method that may be called to verify whether this context has valid index:
+     * will return `false` before the first entry of Object context or before
+     * first element of Array context; otherwise returns `true`.
+     *
+     * @since 2.9
+     */
+    public boolean hasCurrentIndex() { return _index >= 0; }
+
+    /**
+     * Method that may be called to check if this context is either:
+     *<ul>
+     * <li>Object, with at least one entry written (partially or completely)
+     *  </li>
+     * <li>Array, with at least one entry written (partially or completely)
+     *  </li>
+     *</ul>
+     * and if so, return `true`; otherwise return `false`. Latter case includes
+     * Root context (always), and Object/Array contexts before any entries/elements
+     * have been read or written.
+     *<p>
+     * Method is mostly used to determine whether this context should be used for
+     * constructing {@link JsonPointer}
+     *
+     * @since 2.9
+     */
+    public boolean hasPathSegment() {
+        if (_type == TYPE_OBJECT) {
+            return hasCurrentName();
+        } else if (_type == TYPE_ARRAY) {
+            return hasCurrentIndex();
+        }
+        return false;
+    }
+    
     /**
      * Method for accessing name associated with the current location.
      * Non-null for <code>FIELD_NAME</code> and value events that directly
@@ -119,6 +154,11 @@ public abstract class JsonStreamContext
      */
     public abstract String getCurrentName();
 
+    /**
+     * @since 2.9
+     */
+    public boolean hasCurrentName() { return getCurrentName() != null; }
+
     /**
      * Method for accessing currently active value being used by data-binding
      * (as the source of streaming data to write, or destination of data being
@@ -145,4 +185,29 @@ public abstract class JsonStreamContext
      * @since 2.5
      */
     public void setCurrentValue(Object v) { }
+
+    /**
+     * Factory method for constructing a {@link JsonPointer} that points to the current
+     * location within the stream that this context is for, excluding information about
+     * "root context" (only relevant for multi-root-value cases)
+     *
+     * @since 2.9
+     */
+    public JsonPointer pathAsPointer() {
+        return JsonPointer.forPath(this, false);
+    }
+
+    /**
+     * Factory method for constructing a {@link JsonPointer} that points to the current
+     * location within the stream that this context is for, optionally including
+     * "root value index"
+     *
+     * @param includeRoot Whether root-value offset is included as the first segment or not;
+     *    
+     *
+     * @since 2.9
+     */
+    public JsonPointer pathAsPointer(boolean includeRoot) {
+        return JsonPointer.forPath(this, includeRoot);
+    }
 }
diff --git a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java
index 14848bbc..c414633e 100644
--- a/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java
+++ b/src/main/java/com/fasterxml/jackson/core/filter/TokenFilterContext.java
@@ -275,6 +275,8 @@ public class TokenFilterContext extends JsonStreamContext
 
     @Override public final TokenFilterContext getParent() { return _parent; }
     @Override public final String getCurrentName() { return _currentName; }
+    // @since 2.9
+    @Override public boolean hasCurrentName() { return _currentName != null; }
 
     public TokenFilter getFilter() { return _filter; }
     public boolean isStartHandled() { return _startHandled; }
diff --git a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java
index e1b0479e..37c5b15c 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonReadContext.java
@@ -77,8 +77,8 @@ public final class JsonReadContext extends JsonStreamContext
     }
 
     /*
-    public void trackDups(JsonParser jp) {
-        _dups = DupDetector.rootDetector(jp);
+    public void trackDups(JsonParser p) {
+        _dups = DupDetector.rootDetector(p);
     }
     */
 
@@ -140,6 +140,10 @@ public final class JsonReadContext extends JsonStreamContext
      */
 
     @Override public String getCurrentName() { return _currentName; }
+
+    // @since 2.9
+    @Override public boolean hasCurrentName() { return _currentName != null; }
+
     @Override public JsonReadContext getParent() { return _parent; }
 
     /**
diff --git a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java
index c350e224..0b0e114d 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java
@@ -135,6 +135,8 @@ public class JsonWriteContext extends JsonStreamContext
 
     @Override public final JsonWriteContext getParent() { return _parent; }
     @Override public final String getCurrentName() { return _currentName; }
+    // @since 2.9
+    @Override public boolean hasCurrentName() { return _currentName != null; }
 
     /**
      * Method that can be used to both clear the accumulated references
diff --git a/src/test/java/com/fasterxml/jackson/core/PointerFromContextTest.java b/src/test/java/com/fasterxml/jackson/core/PointerFromContextTest.java
new file mode 100644
index 00000000..8e32cebd
--- /dev/null
+++ b/src/test/java/com/fasterxml/jackson/core/PointerFromContextTest.java
@@ -0,0 +1,246 @@
+package com.fasterxml.jackson.core;
+
+import java.io.StringWriter;
+
+public class PointerFromContextTest extends BaseTest
+{
+    /*
+    /**********************************************************
+    /* Test methods, basic
+    /**********************************************************
+     */
+
+    private final JsonFactory JSON_F = new JsonFactory();
+
+    public void testViaParser() throws Exception
+    {
+        final String SIMPLE = aposToQuotes("{'a':123,'array':[1,2,[3],5,{'obInArray':4}],"
+                +"'ob':{'first':[false,true],'second':{'sub':37}},'b':true}");
+        JsonParser p = JSON_F.createParser(SIMPLE);
+
+        // by default should just get "empty"
+        assertSame(JsonPointer.EMPTY, p.getParsingContext().pathAsPointer());
+
+        // let's just traverse, then:
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertSame(JsonPointer.EMPTY, p.getParsingContext().pathAsPointer());
+
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // a
+        assertEquals("/a", p.getParsingContext().pathAsPointer().toString());
+
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals("/a", p.getParsingContext().pathAsPointer().toString());
+
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // array
+        assertEquals("/array", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.START_ARRAY, p.nextToken());
+        assertEquals("/array", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // 1
+        assertEquals("/array/0", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // 2
+        assertEquals("/array/1", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.START_ARRAY, p.nextToken());
+        assertEquals("/array/2", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // 3
+        assertEquals("/array/2/0", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.END_ARRAY, p.nextToken());
+        assertEquals("/array/2", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // 5
+        assertEquals("/array/3", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertEquals("/array/4", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // obInArray
+        assertEquals("/array/4/obInArray", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // 4
+        assertEquals("/array/4/obInArray", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.END_OBJECT, p.nextToken());
+        assertEquals("/array/4", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.END_ARRAY, p.nextToken()); // /array
+        assertEquals("/array", p.getParsingContext().pathAsPointer().toString());
+
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // ob
+        assertEquals("/ob", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertEquals("/ob", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // first
+        assertEquals("/ob/first", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.START_ARRAY, p.nextToken());
+        assertEquals("/ob/first", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_FALSE, p.nextToken());
+        assertEquals("/ob/first/0", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_TRUE, p.nextToken());
+        assertEquals("/ob/first/1", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.END_ARRAY, p.nextToken());
+        assertEquals("/ob/first", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // second
+        assertEquals("/ob/second", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertEquals("/ob/second", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // sub
+        assertEquals("/ob/second/sub", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // 37
+        assertEquals("/ob/second/sub", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.END_OBJECT, p.nextToken());
+        assertEquals("/ob/second", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // /ob
+        assertEquals("/ob", p.getParsingContext().pathAsPointer().toString());
+
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // b
+        assertEquals("/b", p.getParsingContext().pathAsPointer().toString());
+        assertToken(JsonToken.VALUE_TRUE, p.nextToken());
+        assertEquals("/b", p.getParsingContext().pathAsPointer().toString());
+
+        assertToken(JsonToken.END_OBJECT, p.nextToken());
+        assertSame(JsonPointer.EMPTY, p.getParsingContext().pathAsPointer());
+
+        assertNull(p.nextToken());
+        p.close();
+    }
+
+    public void testViaGenerator() throws Exception
+    {
+        StringWriter w = new StringWriter();
+        JsonGenerator g = JSON_F.createGenerator(w);
+        assertSame(JsonPointer.EMPTY, g.getOutputContext().pathAsPointer());
+
+        g.writeStartArray();
+        // no path yet
+        assertSame(JsonPointer.EMPTY, g.getOutputContext().pathAsPointer());
+        g.writeBoolean(true);
+        assertEquals("/0", g.getOutputContext().pathAsPointer().toString());
+
+        g.writeStartObject();
+        assertEquals("/1", g.getOutputContext().pathAsPointer().toString());
+        g.writeFieldName("x");
+        assertEquals("/1/x", g.getOutputContext().pathAsPointer().toString());
+        g.writeString("foo");
+        assertEquals("/1/x", g.getOutputContext().pathAsPointer().toString());
+        g.writeFieldName("stats");
+        assertEquals("/1/stats", g.getOutputContext().pathAsPointer().toString());
+        g.writeStartObject();
+        assertEquals("/1/stats", g.getOutputContext().pathAsPointer().toString());
+        g.writeFieldName("rate");
+        assertEquals("/1/stats/rate", g.getOutputContext().pathAsPointer().toString());
+        g.writeNumber(13);
+        assertEquals("/1/stats/rate", g.getOutputContext().pathAsPointer().toString());
+        g.writeEndObject();
+        assertEquals("/1/stats", g.getOutputContext().pathAsPointer().toString());
+
+        g.writeEndObject();
+        assertEquals("/1", g.getOutputContext().pathAsPointer().toString());
+
+        g.writeEndArray();
+        assertSame(JsonPointer.EMPTY, g.getOutputContext().pathAsPointer());
+        g.close();
+        w.close();
+    }
+
+    /*
+    /**********************************************************
+    /* Test methods, root-offset
+    /**********************************************************
+     */
+
+    public void testParserWithRoot() throws Exception
+    {
+        final String JSON = aposToQuotes("{'a':1,'b':3}\n"
+                +"{'a':5,'c':[1,2]}\n[1,2]\n");
+        JsonParser p = JSON_F.createParser(JSON);
+        // before pointing to anything, we have no path to point to
+        assertSame(JsonPointer.EMPTY, p.getParsingContext().pathAsPointer(true));
+
+        // but immediately after advancing we do
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertEquals("/0", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // a
+        assertEquals("/0/a", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // a:1
+        assertEquals("/0/a", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // b
+        assertEquals("/0/b", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // a:1
+        assertEquals("/0/b", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.END_OBJECT, p.nextToken());
+        assertEquals("/0", p.getParsingContext().pathAsPointer(true).toString());
+
+        assertToken(JsonToken.START_OBJECT, p.nextToken());
+        assertEquals("/1", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // a
+        assertEquals("/1/a", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken()); // a:1
+        assertEquals("/1/a", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // c
+        assertEquals("/1/c", p.getParsingContext().pathAsPointer(true).toString());
+
+        assertToken(JsonToken.START_ARRAY, p.nextToken());
+        assertEquals("/1/c", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals("/1/c/0", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals("/1/c/1", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.END_ARRAY, p.nextToken());
+        assertEquals("/1/c", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.END_OBJECT, p.nextToken());
+        assertEquals("/1", p.getParsingContext().pathAsPointer(true).toString());
+
+        assertToken(JsonToken.START_ARRAY, p.nextToken());
+        assertEquals("/2", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals("/2/0", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
+        assertEquals("/2/1", p.getParsingContext().pathAsPointer(true).toString());
+        assertToken(JsonToken.END_ARRAY, p.nextToken());
+        assertEquals("/2", p.getParsingContext().pathAsPointer(true).toString());
+
+        assertNull(p.nextToken());
+
+        // 21-Mar-2017, tatu: This is not entirely satisfactory: ideally should get
+        //   EMPTY here as well. But context doesn't really get reset at the end
+        //   and it's not 100% clear what is the best path forward. So, for now...
+        //   just verify current sub-optimal behavior
+
+        assertEquals("/2", p.getParsingContext().pathAsPointer(true).toString());
+
+        p.close();
+    }
+
+    public void testGeneratorWithRoot() throws Exception
+    {
+        StringWriter w = new StringWriter();
+        JsonGenerator g = JSON_F.createGenerator(w);
+        assertSame(JsonPointer.EMPTY, g.getOutputContext().pathAsPointer(true));
+
+        g.writeStartArray();
+        assertEquals("/0", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeBoolean(true);
+        assertEquals("/0/0", g.getOutputContext().pathAsPointer(true).toString());
+
+        g.writeStartObject();
+        assertEquals("/0/1", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeFieldName("x");
+        assertEquals("/0/1/x", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeString("foo");
+        assertEquals("/0/1/x", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeEndObject();
+        assertEquals("/0/1", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeEndArray();
+        assertEquals("/0", g.getOutputContext().pathAsPointer(true).toString());
+
+        g.writeBoolean(true);
+        assertEquals("/1", g.getOutputContext().pathAsPointer(true).toString());
+
+        g.writeStartArray();
+        assertEquals("/2", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeString("foo");
+        assertEquals("/2/0", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeString("bar");
+        assertEquals("/2/1", g.getOutputContext().pathAsPointer(true).toString());
+        g.writeEndArray();
+        assertEquals("/2", g.getOutputContext().pathAsPointer(true).toString());
+
+        // as earlier, not optimal result, but verify it's stable:
+        assertEquals("/2", g.getOutputContext().pathAsPointer(true).toString());
+        
+        g.close();
+    }
+}
diff --git a/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java b/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java
index 9a2de460..8f7d7ad9 100644
--- a/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java
+++ b/src/test/java/com/fasterxml/jackson/core/TestJsonPointer.java
@@ -1,6 +1,5 @@
 package com.fasterxml.jackson.core;
 
-
 public class TestJsonPointer extends BaseTest
 {
     public void testSimplePath() throws Exception
@@ -150,7 +149,7 @@ public class TestJsonPointer extends BaseTest
         assertNull(ptr.tail());
     }
 
-    // [Issue#133]
+    // [core#133]
     public void testLongNumbers() throws Exception
     {
         final long LONG_ID = ((long) Integer.MAX_VALUE) + 1L;
