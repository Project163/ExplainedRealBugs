diff --git a/release-notes/VERSION b/release-notes/VERSION
index 7d4f4472..d5bdb592 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -22,6 +22,7 @@ JSON library.
 #312: Add `JsonProcessingException.clearLocation()` to allow clearing
   possibly security-sensitive information
  (contributed by Alex Y)
+#314: Add a method in `JsonParser` to allow checking for "NaN" values
 #323: Add `JsonParser.ALLOW_TRAILING_COMMA` to work for Arrays and Objects
  (contributed by Brad H)
 #325: `DataInput` backed parser should handle `EOFException` at end of doc
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java
index 92109e35..dbda832e 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java
@@ -939,7 +939,7 @@ public abstract class JsonGenerator
      * surrounded in double quotes, and contents will be properly
      * escaped as required by JSON specification.
      * If the reader is null, then write a null.
-     * If len is < 0, then write all contents of the reader.
+     * If len is &lt; 0, then write all contents of the reader.
      * Otherwise, write only len characters.
      *
      * @since 2.9
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonParser.java b/src/main/java/com/fasterxml/jackson/core/JsonParser.java
index 05171fc7..f4fee758 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java
@@ -537,6 +537,47 @@ public abstract class JsonParser
     @Override
     public abstract void close() throws IOException;
 
+    /**
+     * Method that can be called to determine whether this parser
+     * is closed or not. If it is closed, no new tokens can be
+     * retrieved by calling {@link #nextToken} (and the underlying
+     * stream may be closed). Closing may be due to an explicit
+     * call to {@link #close} or because parser has encountered
+     * end of input.
+     */
+    public abstract boolean isClosed();
+
+    /*
+    /**********************************************************
+    /* Public API, simple location, context accessors
+    /**********************************************************
+     */
+
+    /**
+     * Method that can be used to access current parsing context reader
+     * is in. There are 3 different types: root, array and object contexts,
+     * with slightly different available information. Contexts are
+     * hierarchically nested, and can be used for example for figuring
+     * out part of the input document that correspond to specific
+     * array or object (for highlighting purposes, or error reporting).
+     * Contexts can also be used for simple xpath-like matching of
+     * input, if so desired.
+     */
+    public abstract JsonStreamContext getParsingContext();
+
+    /**
+     * Method that return the <b>starting</b> location of the current
+     * token; that is, position of the first character from input
+     * that starts the current token.
+     */
+    public abstract JsonLocation getTokenLocation();
+
+    /**
+     * Method that returns location of the last processed character;
+     * usually for error reporting purposes.
+     */
+    public abstract JsonLocation getCurrentLocation();
+
     /*
     /**********************************************************
     /* Buffer handling
@@ -857,19 +898,9 @@ public abstract class JsonParser
         ; // nothing
     }
 
-    /**
-     * Method that can be called to determine whether this parser
-     * is closed or not. If it is closed, no new tokens can be
-     * retrieved by calling {@link #nextToken} (and the underlying
-     * stream may be closed). Closing may be due to an explicit
-     * call to {@link #close} or because parser has encountered
-     * end of input.
-     */
-    public abstract boolean isClosed();
-    
     /*
     /**********************************************************
-    /* Public API, token accessors
+    /* Public API, simple token id/type access
     /**********************************************************
      */
 
@@ -959,40 +990,6 @@ public abstract class JsonParser
      * @since 2.6
      */
     public abstract boolean hasToken(JsonToken t);
-    
-    /**
-     * Method that can be called to get the name associated with
-     * the current token: for {@link JsonToken#FIELD_NAME}s it will
-     * be the same as what {@link #getText} returns;
-     * for field values it will be preceding field name;
-     * and for others (array values, root-level values) null.
-     */
-    public abstract String getCurrentName() throws IOException;
-
-    /**
-     * Method that can be used to access current parsing context reader
-     * is in. There are 3 different types: root, array and object contexts,
-     * with slightly different available information. Contexts are
-     * hierarchically nested, and can be used for example for figuring
-     * out part of the input document that correspond to specific
-     * array or object (for highlighting purposes, or error reporting).
-     * Contexts can also be used for simple xpath-like matching of
-     * input, if so desired.
-     */
-    public abstract JsonStreamContext getParsingContext();
-
-    /**
-     * Method that return the <b>starting</b> location of the current
-     * token; that is, position of the first character from input
-     * that starts the current token.
-     */
-    public abstract JsonLocation getTokenLocation();
-
-    /**
-     * Method that returns location of the last processed character;
-     * usually for error reporting purposes.
-     */
-    public abstract JsonLocation getCurrentLocation();
 
     /**
      * Specialized accessor that can be used to verify that the current
@@ -1022,7 +1019,18 @@ public abstract class JsonParser
      * @since 2.5
      */
     public boolean isExpectedStartObjectToken() { return currentToken() == JsonToken.START_OBJECT; }
-    
+
+    /**
+     * Access for checking whether current token is a numeric value token, but
+     * one that is of "not-a-number" (NaN) variety: not supported by all formats,
+     * but often supported for {@link JsonToken#VALUE_NUMBER_FLOAT}.
+     *
+     * @since 2.9
+     */
+    public boolean isNaN() {
+        return false;
+    }
+
     /*
     /**********************************************************
     /* Public API, token state overrides
@@ -1071,6 +1079,15 @@ public abstract class JsonParser
     /**********************************************************
      */
 
+    /**
+     * Method that can be called to get the name associated with
+     * the current token: for {@link JsonToken#FIELD_NAME}s it will
+     * be the same as what {@link #getText} returns;
+     * for field values it will be preceding field name;
+     * and for others (array values, root-level values) null.
+     */
+    public abstract String getCurrentName() throws IOException;
+    
     /**
      * Method for accessing textual representation of the current token;
      * if no current token (before first call to {@link #nextToken}, or
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
index 83fb51ae..712013f7 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
@@ -615,7 +615,17 @@ public abstract class ParserBase extends ParserMinimalBase
         _numTypesValid = NR_DOUBLE;
         return JsonToken.VALUE_NUMBER_FLOAT;
     }
-    
+
+    @Override
+    public boolean isNaN() {
+        if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {
+            if ((_numTypesValid & NR_DOUBLE) != 0) {
+                return Double.isNaN(_numberDouble);
+            }
+        }
+        return false;
+    }
+
     /*
     /**********************************************************
     /* Numeric accessors of public API
@@ -1046,33 +1056,13 @@ public abstract class ParserBase extends ParserMinimalBase
     /* Internal/package methods: Error reporting
     /**********************************************************
      */
-    
-    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {
-        String startDesc = ""+_parsingContext.getStartLocation(_getSourceReference());
-        _reportError("Unexpected close marker '"+((char) actCh)+"': expected '"+expCh+"' (for "+_parsingContext.typeDesc()+" starting at "+startDesc+")");
-    }
 
-    protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {
-        String msg = "Unexpected character ("+_getCharDesc(ch)+") in numeric value";
-        if (comment != null) {
-            msg += ": "+comment;
-        }
-        _reportError(msg);
-    }
-    
-    protected void reportInvalidNumber(String msg) throws JsonParseException {
-        _reportError("Invalid numeric value: "+msg);
-    }
-
-    protected void reportOverflowInt() throws IOException {
-        _reportError(String.format("Numeric value (%s) out of range of int (%d - %s)",
-                getText(), Integer.MIN_VALUE, Integer.MAX_VALUE));
+    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {
+        JsonReadContext ctxt = getParsingContext();
+        _reportError(String.format(
+                "Unexpected close marker '%s': expected '%c' (for %s starting at %s)",
+                (char) actCh, expCh, ctxt.typeDesc(), ctxt.getStartLocation(_getSourceReference())));
     }
-    
-    protected void reportOverflowLong() throws IOException {
-        _reportError(String.format("Numeric value (%s) out of range of long (%d - %s)",
-                getText(), Long.MIN_VALUE, Long.MAX_VALUE));
-    }    
 
     /*
     /**********************************************************
@@ -1141,7 +1131,8 @@ public abstract class ParserBase extends ParserMinimalBase
     protected IllegalArgumentException reportInvalidBase64Char(Base64Variant b64variant, int ch, int bindex, String msg) throws IllegalArgumentException {
         String base;
         if (ch <= INT_SPACE) {
-            base = "Illegal white space character (code 0x"+Integer.toHexString(ch)+") as character #"+(bindex+1)+" of 4-char base64 unit: can only used between units";
+            base = String.format("Illegal white space character (code 0x%s) as character #%d of 4-char base64 unit: can only used between units",
+                    Integer.toHexString(ch), (bindex+1));
         } else if (b64variant.usesPaddingChar(ch)) {
             base = "Unexpected padding character ('"+b64variant.getPaddingChar()+"') as character #"+(bindex+1)+" of 4-char base64 unit: padding only legal as 3rd or 4th character";
         } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
index c3da66cd..ca13bf3a 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
@@ -425,7 +425,7 @@ public abstract class ParserMinimalBase extends JsonParser
     /* Coercion helper methods (overridable)
     /**********************************************************
      */
-    
+
     /**
      * Helper method used to determine whether we are currently pointing to
      * a String value of "null" (NOT a null token); and, if so, that parser
@@ -434,19 +434,41 @@ public abstract class ParserMinimalBase extends JsonParser
      * @since 2.3
      */
     protected boolean _hasTextualNull(String value) { return "null".equals(value); }
-    
+
     /*
     /**********************************************************
     /* Error reporting
     /**********************************************************
      */
+
+    protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {
+        String msg = String.format("Unexpected character (%s) in numeric value", _getCharDesc(ch));
+        if (comment != null) {
+            msg += ": "+comment;
+        }
+        _reportError(msg);
+    }
+
+    protected void reportInvalidNumber(String msg) throws JsonParseException {
+        _reportError("Invalid numeric value: "+msg);
+    }
+
+    protected void reportOverflowInt() throws IOException {
+        _reportError(String.format("Numeric value (%s) out of range of int (%d - %s)",
+                getText(), Integer.MIN_VALUE, Integer.MAX_VALUE));
+    }
     
+    protected void reportOverflowLong() throws IOException {
+        _reportError(String.format("Numeric value (%s) out of range of long (%d - %s)",
+                getText(), Long.MIN_VALUE, Long.MAX_VALUE));
+    }
+
     protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException
     {
         if (ch < 0) { // sanity check
             _reportInvalidEOF();
         }
-        String msg = "Unexpected character ("+_getCharDesc(ch)+")";
+        String msg = String.format("Unexpected character (%s)", _getCharDesc(ch));
         if (comment != null) {
             msg += ": "+comment;
         }
@@ -532,7 +554,7 @@ public abstract class ParserMinimalBase extends JsonParser
         _reportError("Unrecognized character escape "+_getCharDesc(ch));
         return ch;
     }
-    
+
     /*
     /**********************************************************
     /* Error reporting, generic
diff --git a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java
index 9ec93fb3..54223c89 100644
--- a/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java
+++ b/src/main/java/com/fasterxml/jackson/core/util/JsonParserDelegate.java
@@ -122,6 +122,7 @@ public class JsonParserDelegate extends JsonParser
     @Override public JsonStreamContext getParsingContext() { return delegate.getParsingContext(); }
     @Override public boolean isExpectedStartArrayToken() { return delegate.isExpectedStartArrayToken(); }
     @Override public boolean isExpectedStartObjectToken() { return delegate.isExpectedStartObjectToken(); }
+    @Override public boolean isNaN() { return delegate.isNaN(); }
 
     /*
     /**********************************************************
diff --git a/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java b/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
index dab984b5..633cd86f 100644
--- a/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
@@ -461,8 +461,16 @@ public class NumberParsingTest
      */
     public void testParsingOfLongerSequencesWithNonNumeric() throws Exception
     {
-        JsonFactory factory = new JsonFactory();
-        factory.enable(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS);
+        JsonFactory f = new JsonFactory();
+        f.enable(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS);
+        _testParsingOfLongerSequencesWithNonNumeric(f, MODE_INPUT_STREAM);
+        _testParsingOfLongerSequencesWithNonNumeric(f, MODE_INPUT_STREAM_THROTTLED);
+        _testParsingOfLongerSequencesWithNonNumeric(f, MODE_READER);
+        _testParsingOfLongerSequencesWithNonNumeric(f, MODE_DATA_INPUT);
+    }
+
+    private void _testParsingOfLongerSequencesWithNonNumeric(JsonFactory f, int mode) throws Exception
+    {
         double[] values = new double[] {
                 0.01, -10.5, 2.1e9, 4.0e-8,
                 Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY
@@ -479,16 +487,20 @@ public class NumberParsingTest
             sb.append(arrayJson);
             String DOC = sb.toString();
             for (int input = 0; input < 2; ++input) {
-                JsonParser p;
-                if (input == 0) {
-                    p = createParserUsingStream(factory, DOC, "UTF-8");
-                } else {
-                    p = factory.createParser(DOC);
-                }
+                JsonParser p = createParser(f, mode, DOC);
                 assertToken(JsonToken.START_ARRAY, p.nextToken());
                 for (int j = 0; j < VCOUNT; ++j) {
                     assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());
-                    assertEquals(values[i], p.getDoubleValue());
+                    double exp = values[i];
+                    double act = p.getDoubleValue();
+                    if (Double.compare(exp, act) != 0) {
+                        fail("Expected at #"+j+" value "+exp+", instead got "+act);
+                    }
+                    if (Double.isNaN(exp)) {
+                        assertTrue(p.isNaN());
+                    } else {
+                        assertFalse(p.isNaN());
+                    }
                 }
                 assertToken(JsonToken.END_ARRAY, p.nextToken());
                 p.close();
@@ -496,7 +508,6 @@ public class NumberParsingTest
         }
     }
 
-
     /*
     /**********************************************************
     /* Tests for invalid access
