diff --git a/release-notes/VERSION b/release-notes/VERSION
index ac1a1818..7f4febed 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -23,6 +23,9 @@ JSON library.
   uses new class `com.fasterxml.jackson.core.filter.FilteringGeneratorDelegate`
   (and related, `TokenFilter`)
 #188: `JsonParser.getValueAsString()` should return field name for `JsonToken.FIELD_NAME`, not `null`
+#189: Add `JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING` (default: true), which may
+  be disabled to prevent use of ThreadLocal-based buffer recyling.
+ (suggested by soldierkam@github)
 - Minor improvement to construction of "default PrettyPrinter": now overridable by data format
   modules
 - Implement a new yet more optimized symbol table for byte-backed parsers
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java
index 3c72b3e5..6f0c235d 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java
@@ -101,6 +101,21 @@ public class JsonFactory
          */
         FAIL_ON_SYMBOL_HASH_OVERFLOW(true),
 
+        /**
+         * Feature that determines whether we will use {@link BufferRecycler} with
+         * {@link ThreadLocal} and {@link SoftReference}, for efficient reuse of
+         * underlying input/output buffers.
+         * This usually makes sense on normal J2SE/J2EE server-side processing;
+         * but may not make sense on platforms where {@link SoftReference} handling
+         * is broken (like Android), or if there are retention issues due to
+         * {@link ThreadLocal} (see
+         * <a href="https://github.com/FasterXML/jackson-core/issues/189">Issue #189</a>
+         * for a possible case)
+         *
+         * @since 2.6
+         */
+        USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(true)
+        
         ;
 
         /**
@@ -1384,12 +1399,22 @@ public class JsonFactory
      */
     public BufferRecycler _getBufferRecycler()
     {
-        SoftReference<BufferRecycler> ref = _recyclerRef.get();
-        BufferRecycler br = (ref == null) ? null : ref.get();
+        BufferRecycler br;
 
-        if (br == null) {
+        /* 23-Apr-2015, tatu: Let's allow disabling of buffer recycling
+         *   scheme, for cases where it is considered harmful (possibly
+         *   on Android, for example)
+         */
+        if (isEnabled(Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING)) {
+            SoftReference<BufferRecycler> ref = _recyclerRef.get();
+            br = (ref == null) ? null : ref.get();
+    
+            if (br == null) {
+                br = new BufferRecycler();
+                _recyclerRef.set(new SoftReference<BufferRecycler>(br));
+            }
+        } else {
             br = new BufferRecycler();
-            _recyclerRef.set(new SoftReference<BufferRecycler>(br));
         }
         return br;
     }
diff --git a/src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java b/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java
similarity index 59%
rename from src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java
rename to src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java
index d29651f5..ede5ec1c 100644
--- a/src/test/java/com/fasterxml/jackson/core/json/TestJsonFactory.java
+++ b/src/test/java/com/fasterxml/jackson/core/json/JsonFactoryTest.java
@@ -4,7 +4,7 @@ import java.io.*;
 
 import com.fasterxml.jackson.core.*;
 
-public class TestJsonFactory
+public class JsonFactoryTest
     extends com.fasterxml.jackson.core.BaseTest
 {
     public void testGeneratorFeatures() throws Exception
@@ -18,15 +18,64 @@ public class TestJsonFactory
         assertFalse(f.isEnabled(JsonGenerator.Feature.QUOTE_FIELD_NAMES));
     }
 
-    public void testParserFeatures() throws Exception
+    public void testFactoryFeatures() throws Exception
     {
         JsonFactory f = new JsonFactory();
-        assertNull(f.getCodec());
 
         f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, true);
         assertTrue(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));
         f.configure(JsonFactory.Feature.INTERN_FIELD_NAMES, false);
         assertFalse(f.isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES));
+
+        // by default, should be enabled
+        assertTrue(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));
+        f.configure(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING, false);
+        assertFalse(f.isEnabled(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING));
+    }
+
+    // for [core#189]: verify that it's ok to disable recycling
+    // Basically simply exercises basic functionality, to ensure
+    // there are no obvious problems; needed since testing never
+    // disables this handling otherwise
+    public void testDisablingBufferRecycling() throws Exception
+    {
+        JsonFactory f = new JsonFactory();
+
+        f.disable(JsonFactory.Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING);
+
+        // First, generation
+        for (int i = 0; i < 3; ++i) {
+            StringWriter w = new StringWriter();
+            JsonGenerator gen = f.createGenerator(w);
+            gen.writeStartObject();
+            gen.writeEndObject();
+            gen.close();
+            assertEquals("{}", w.toString());
+        }
+    
+        for (int i = 0; i < 3; ++i) {
+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();
+            JsonGenerator gen = f.createGenerator(bytes);
+            gen.writeStartArray();
+            gen.writeEndArray();
+            gen.close();
+            assertEquals("[]", bytes.toString("UTF-8"));
+        }
+
+        // Then parsing:
+        for (int i = 0; i < 3; ++i) {
+            JsonParser p = f.createParser("{}");
+            assertToken(JsonToken.START_OBJECT, p.nextToken());
+            assertToken(JsonToken.END_OBJECT, p.nextToken());
+            assertNull(p.nextToken());
+            p.close();
+
+            p = f.createParser("{}".getBytes("UTF-8"));
+            assertToken(JsonToken.START_OBJECT, p.nextToken());
+            assertToken(JsonToken.END_OBJECT, p.nextToken());
+            assertNull(p.nextToken());
+            p.close();
+        }
     }
     
     public void testJsonWithFiles() throws Exception
