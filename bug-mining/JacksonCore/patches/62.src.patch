diff --git a/release-notes/CREDITS-2.x b/release-notes/CREDITS-2.x
index e1ae184c..d4173492 100644
--- a/release-notes/CREDITS-2.x
+++ b/release-notes/CREDITS-2.x
@@ -150,3 +150,9 @@ Jeroen Borgers (jborgers@github)
   * Reported, contributed impl for #400: Add mechanism for forcing `BufferRecycler` released
    (to call on shutdown)
   (2.9.6)
+
+Doug Roper (htmldoug@github)
+  * Suggested #463: Ensure that `skipChildren()` of non-blocking `JsonParser` will throw
+    exception if not enough input
+  (2.9.6)
+ 
diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 58d5f01f..41193a66 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -19,6 +19,9 @@ JSON library.
 #400: Add mechanism for forcing `BufferRecycler` released (to call on shutdown)
  (contributed by Jeroen B)
 #460: Failing to link `ObjectCodec` with `JsonFactory` copy constructor
+#463: Ensure that `skipChildren()` of non-blocking `JsonParser` will throw
+   exception if not enough input
+  (requested by Doug R)
 
 2.9.5 (26-Mar-2018)
 
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
index 7b8d41e9..6f01c1a3 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
@@ -249,6 +249,12 @@ public abstract class ParserMinimalBase extends JsonParser
                 if (--open == 0) {
                     return this;
                 }
+                // 23-May-2018, tatu: [core#463] Need to consider non-blocking case...
+            } else if (t == JsonToken.NOT_AVAILABLE) {
+                // Nothing much we can do except to either return `null` (which seems wrong),
+                // or, what we actually do, signal error
+                _reportError("Not enough content available for `skipChildren()`: non-blocking parser? (%s)",
+                            getClass().getName());
             }
         }
     }
diff --git a/src/test/java/com/fasterxml/jackson/core/BaseTest.java b/src/test/java/com/fasterxml/jackson/core/BaseTest.java
index 053869a6..488380cc 100644
--- a/src/test/java/com/fasterxml/jackson/core/BaseTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/BaseTest.java
@@ -505,6 +505,14 @@ public abstract class BaseTest
     /**********************************************************
      */
 
+    protected static String quote(String str) {
+        return '"'+str+'"';
+    }
+
+    protected static String aposToQuotes(String json) {
+        return json.replace("'", "\"");
+    }
+
     protected byte[] encodeInUTF32BE(String input)
     {
         int len = input.length();
@@ -519,12 +527,13 @@ public abstract class BaseTest
         return result;
     }
 
-    protected String quote(String str) {
-        return '"'+str+'"';
-    }
-
-    protected String aposToQuotes(String json) {
-        return json.replace("'", "\"");
+    // @since 2.9.7
+    protected static byte[] utf8Bytes(String str) {
+        try {
+            return str.getBytes("UTF-8");
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
     }
 
     protected void fieldNameFor(StringBuilder sb, int index)
diff --git a/src/test/java/com/fasterxml/jackson/core/json/async/AsyncTokenFilterTest.java b/src/test/java/com/fasterxml/jackson/core/json/async/AsyncTokenFilterTest.java
index da30ba6d..a63b9bba 100644
--- a/src/test/java/com/fasterxml/jackson/core/json/async/AsyncTokenFilterTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/json/async/AsyncTokenFilterTest.java
@@ -1,29 +1,25 @@
 package com.fasterxml.jackson.core.json.async;
 
+import java.io.IOException;
+
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.core.async.AsyncTestBase;
-import com.fasterxml.jackson.core.async.NonBlockingInputFeeder;
 import com.fasterxml.jackson.core.filter.FilteringParserDelegate;
 import com.fasterxml.jackson.core.filter.TokenFilter;
-import com.fasterxml.jackson.core.testsupport.AsyncReaderWrapper;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.util.Arrays;
-
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.assertNotEquals;
 
-public class AsyncTokenFilterTest extends AsyncTestBase {
+// [core#462], [core#463]
+public class AsyncTokenFilterTest extends AsyncTestBase
+{
     private final JsonFactory JSON_F = new JsonFactory();
 
-    private final static String INPUT_STRING = "{'a': 1, 'b': [2, {'c': 3}]}".replace('\'', '"');
-    private final static byte[] INPUT_BYTES = INPUT_STRING.getBytes();
+    private final static String INPUT_STRING = aposToQuotes("{'a': 1, 'b': [2, {'c': 3}]}");
+    private final static byte[] INPUT_BYTES = utf8Bytes(INPUT_STRING);
     private final static TokenFilter TOKEN_FILTER = new TokenFilter() {
         public TokenFilter includeProperty(String name) {
             return name == "a" ? TokenFilter.INCLUDE_ALL : null;
         }
     };
+
     private final static JsonToken[] EXPECTED_TOKENS = new JsonToken[]{
         JsonToken.START_OBJECT,
         JsonToken.FIELD_NAME,
@@ -31,34 +27,41 @@ public class AsyncTokenFilterTest extends AsyncTestBase {
         JsonToken.END_OBJECT
     };
 
-    public void testFilteredNonBlockingParser() throws IOException {
-        // Start by feeding all the bytes at once, since that works fine, and gradually reduce the chunk size.
-        for (int chunkSize = INPUT_BYTES.length; chunkSize > 0; chunkSize--) {
-            System.out.println("Starting chunkSize " + chunkSize);
-            // Create the parsers
-            NonBlockingJsonParser nonBlockingParser = (NonBlockingJsonParser) JSON_F.createNonBlockingByteArrayParser();
-            FilteringParserDelegate filteredParser = new FilteringParserDelegate(nonBlockingParser, TOKEN_FILTER, true, true);
+    // Passes if (but only if) all content is actually available
+    public void testFilteredNonBlockingParserAllContent() throws IOException
+    {
+        NonBlockingJsonParser nonBlockingParser = (NonBlockingJsonParser) JSON_F.createNonBlockingByteArrayParser();
+        FilteringParserDelegate filteredParser = new FilteringParserDelegate(nonBlockingParser,
+                TOKEN_FILTER, true, true);
+        nonBlockingParser.feedInput(INPUT_BYTES, 0, INPUT_BYTES.length);
+        int expectedIdx = 0;
+        while (expectedIdx < EXPECTED_TOKENS.length) {
+            // grab next token
+            JsonToken actual = filteredParser.nextToken();
+
+            // make sure it's the right one and mark it as seen.
+            assertToken(EXPECTED_TOKENS[expectedIdx], actual);
+            expectedIdx++;
+        }
 
-            int expectedIdx = 0; // tracks EXPECTED_TOKENS seen
-            int inputIdx = 0; // tracks INPUT_BYTES fed to the parser
+        filteredParser.close();
+    }
 
-            while (expectedIdx < EXPECTED_TOKENS.length) {
-                // grab next token
-                JsonToken actual = filteredParser.nextToken();
+    public void testSkipChildrenFailOnSplit() throws IOException
+    {
+        NonBlockingJsonParser nbParser = (NonBlockingJsonParser) JSON_F.createNonBlockingByteArrayParser();
+        FilteringParserDelegate filteredParser = new FilteringParserDelegate(nbParser,
+                TOKEN_FILTER, true, true);
+        nbParser.feedInput(INPUT_BYTES, 0, 5);
 
-                if (actual == JsonToken.NOT_AVAILABLE) {
-                    // feed it.
-                    int chunkLen = Math.min(inputIdx + chunkSize, INPUT_BYTES.length - inputIdx);
-                    assertNotEquals(0, chunkLen); // sanity check.
-                    nonBlockingParser.feedInput(INPUT_BYTES, inputIdx, inputIdx + chunkLen);
-                    inputIdx += chunkLen;
-                } else {
-                    // make sure it's the right one and mark it as seen.
-                    JsonToken expected = EXPECTED_TOKENS[expectedIdx];
-                    assertEquals(expected, actual);
-                    expectedIdx++;
-                }
-            }
+        assertToken(JsonToken.START_OBJECT, nbParser.nextToken());
+        try {
+            nbParser.skipChildren();
+            fail("Should not pass!");
+        } catch (JsonParseException e) {
+            verifyException(e, "not enough content available");
+            verifyException(e, "skipChildren()");
         }
+        nbParser.close();
     }
 }
