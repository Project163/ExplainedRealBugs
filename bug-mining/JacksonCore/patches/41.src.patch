diff --git a/release-notes/VERSION b/release-notes/VERSION
index c933f881..1b8cf6bf 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -28,6 +28,7 @@ JSON library.
  (reported by Brad H)
 #340: Making `WriterBasedJsonGenerator` non-final
  (requested by rfoltyns@github)
+#356: Improve indication of "source reference" in `JsonLocation` wrt `byte[]`,`char[]`
 
 2.8.7 (not yet released)
 
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonLocation.java b/src/main/java/com/fasterxml/jackson/core/JsonLocation.java
index 264f7394..7d29e11e 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonLocation.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonLocation.java
@@ -5,6 +5,8 @@
 
 package com.fasterxml.jackson.core;
 
+import java.nio.charset.Charset;
+
 /**
  * Object that encapsulates Location information used for reporting
  * parsing (or potentially generation) errors, as well as current location
@@ -15,17 +17,29 @@ public class JsonLocation
 {
     private static final long serialVersionUID = 1L;
 
+    /**
+     * Include at most first 500 characters/bytes from contents; should be enough
+     * to give context, but not cause unfortunate side effects in things like
+     * logs.
+     *
+     * @since 2.9
+     */
+    public static final int MAX_CONTENT_SNIPPET = 500;
+    
     /**
      * Shared immutable "N/A location" that can be returned to indicate
-     * that no location information is available
+     * that no location information is available.
+     *<p>
+     * NOTE: before 2.9, Location was given as String "N/A"; with 2.9 it was
+     * removed so that source should be indicated as "UNKNOWN".
      */
-    public final static JsonLocation NA = new JsonLocation("N/A", -1L, -1L, -1, -1);
+    public final static JsonLocation NA = new JsonLocation(null, -1L, -1L, -1, -1);
 
-    final long _totalBytes;
-    final long _totalChars;
+    protected final long _totalBytes;
+    protected final long _totalChars;
 
-    final int _lineNr;
-    final int _columnNr;
+    protected final int _lineNr;
+    protected final int _columnNr;
 
     /**
      * Displayable description for input source: file path, URL.
@@ -64,6 +78,17 @@ public class JsonLocation
      */
     public Object getSourceRef() { return _sourceRef; }
 
+    /**
+     * Accessor for getting a textual description of source reference
+     * (Object returned by {@link #getSourceRef()}), as included in
+     * description returned by {@link #toString()}.
+     *
+     * @since 2.9
+     */
+    public String getSourceDescription() {
+        return _appendSourceDesc(new StringBuilder(100)).toString();
+    }
+
     /**
      * @return Line number of the location (1-based)
      */
@@ -94,11 +119,7 @@ public class JsonLocation
     {
         StringBuilder sb = new StringBuilder(80);
         sb.append("[Source: ");
-        if (_sourceRef == null) {
-            sb.append("UNKNOWN");
-        } else {
-            sb.append(_sourceRef.toString());
-        }
+        _appendSourceDesc(sb);
         sb.append("; line: ");
         sb.append(_lineNr);
         sb.append(", column: ");
@@ -107,6 +128,59 @@ public class JsonLocation
         return sb.toString();
     }
 
+    protected StringBuilder _appendSourceDesc(StringBuilder sb)
+    {
+        final Object srcRef = _sourceRef;
+
+        if (srcRef == null) {
+            sb.append("UNKNOWN");
+            return sb;
+        }
+        // First, figure out what name to use as source type
+        Class<?> srcType = (srcRef instanceof Class<?>) ?
+                ((Class<?>) srcRef) : srcRef.getClass();
+        String tn = srcType.getName();
+        // standard JDK types without package
+        if (tn.startsWith("java.")) {
+            tn = srcType.getSimpleName();
+        } else if (srcRef instanceof byte[]) { // then some other special cases
+            tn = "byte[]";
+        } else if (srcRef instanceof char[]) {
+            tn = "char[]";
+        }
+        sb.append('(').append(tn).append(')');
+        // and then, include (part of) contents for selected types:
+        int len;
+        String charStr = " chars";
+
+        if (srcRef instanceof CharSequence) {
+            CharSequence cs = (CharSequence) srcRef;
+            len = cs.length();
+            len -= _append(sb, cs.subSequence(0, Math.min(len, MAX_CONTENT_SNIPPET)).toString());
+        } else if (srcRef instanceof char[]) {
+            char[] ch = (char[]) srcRef;
+            len = ch.length;
+            len -= _append(sb, new String(ch, 0, Math.min(len, MAX_CONTENT_SNIPPET)));
+        } else if (srcRef instanceof byte[]) {
+            byte[] b = (byte[]) srcRef;
+            int maxLen = Math.min(b.length, MAX_CONTENT_SNIPPET);
+            _append(sb, new String(b, 0, maxLen, Charset.forName("UTF-8")));
+            len = b.length - maxLen;
+            charStr = " bytes";
+        } else {
+            len = 0;
+        }
+        if (len > 0) {
+            sb.append("[truncated ").append(len).append(charStr).append(']');
+        }
+        return sb;
+    }
+
+    private int _append(StringBuilder sb, String content) {
+        sb.append('"').append(content).append('"');
+        return content.length();
+    }
+
     @Override
     public int hashCode()
     {
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonParser.java b/src/main/java/com/fasterxml/jackson/core/JsonParser.java
index 36c7df5d..05171fc7 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java
@@ -58,7 +58,7 @@ public abstract class JsonParser
          * Feature is enabled by default.
          */
         AUTO_CLOSE_SOURCE(true),
-            
+
         // // // Support for non-standard data format constructs
 
         /**
@@ -169,6 +169,49 @@ public abstract class JsonParser
          */
          ALLOW_NON_NUMERIC_NUMBERS(false),
 
+         /**
+          * Feature allows the support for "missing" values in a JSON array: missing
+          * value meaning sequence of two commas, without value in-between but only
+          * optional white space.
+          * Enabling this feature will expose "missing" values as {@link JsonToken#VALUE_NULL}
+          * tokens, which typically become Java nulls in arrays and {@link java.util.Collection}
+          * in data-binding.
+          * <p>
+          * For example, enabling this feature will represent a JSON array <code>["value1",,"value3",]</code>
+          * as <code>["value1", null, "value3", null]</code> 
+          * <p>
+          * Since the JSON specification does not allow missing values this is a non-compliant JSON
+          * feature and is disabled by default.
+          * 
+          * @since 2.8
+          */
+         ALLOW_MISSING_VALUES(false),
+
+         /**
+          * Feature that determines whether {@link JsonParser} will allow for a single trailing
+          * comma following the final value (in an Array) or member (in an Object). These commas
+          * will simply be ignored.
+          * <p>
+          * For example, when this feature is enabled, <code>[true,true,]</code> is equivalent to
+          * <code>[true, true]</code> and <code>{"a": true,}</code> is equivalent to
+          * <code>{"a": true}</code>.
+          * <p>
+          * When combined with <code>ALLOW_MISSING_VALUES</code>, this feature takes priority, and
+          * the final trailing comma in an array declaration does not imply a missing
+          * (<code>null</code>) value. For example, when both <code>ALLOW_MISSING_VALUES</code>
+          * and <code>ALLOW_TRAILING_COMMA</code> are enabled, <code>[true,true,]</code> is
+          * equivalent to <code>[true, true]</code>, and <code>[true,true,,]</code> is equivalent to
+          * <code>[true, true, null]</code>.
+          * <p>
+          * Since the JSON specification does not permit trailing commas, this is a non-standard
+          * feature, and as such disabled by default.
+          *
+          * @since 2.9
+          */
+         ALLOW_TRAILING_COMMA(false),
+
+         // // // Validity checks
+         
          /**
           * Feature that determines whether {@link JsonParser} will explicitly
           * check that no duplicate JSON Object field names are encountered.
@@ -211,46 +254,29 @@ public abstract class JsonParser
           */
          IGNORE_UNDEFINED(false),
 
-         /**
-          * Feature allows the support for "missing" values in a JSON array: missing
-          * value meaning sequence of two commas, without value in-between but only
-          * optional white space.
-          * Enabling this feature will expose "missing" values as {@link JsonToken#VALUE_NULL}
-          * tokens, which typically become Java nulls in arrays and {@link java.util.Collection}
-          * in data-binding.
-          * <p>
-          * For example, enabling this feature will represent a JSON array <code>["value1",,"value3",]</code>
-          * as <code>["value1", null, "value3", null]</code> 
-          * <p>
-          * Since the JSON specification does not allow missing values this is a non-compliant JSON
-          * feature and is disabled by default.
-          * 
-          * @since 2.8
-          */
-         ALLOW_MISSING_VALUES(false),
+         // // // Other
 
          /**
-          * Feature that determines whether {@link JsonParser} will allow for a single trailing
-          * comma following the final value (in an Array) or member (in an Object). These commas
-          * will simply be ignored.
-          * <p>
-          * For example, when this feature is enabled, <code>[true,true,]</code> is equivalent to
-          * <code>[true, true]</code> and <code>{"a": true,}</code> is equivalent to
-          * <code>{"a": true}</code>.
-          * <p>
-          * When combined with <code>ALLOW_MISSING_VALUES</code>, this feature takes priority, and
-          * the final trailing comma in an array declaration does not imply a missing
-          * (<code>null</code>) value. For example, when both <code>ALLOW_MISSING_VALUES</code>
-          * and <code>ALLOW_TRAILING_COMMA</code> are enabled, <code>[true,true,]</code> is
-          * equivalent to <code>[true, true]</code>, and <code>[true,true,,]</code> is equivalent to
-          * <code>[true, true, null]</code>.
-          * <p>
-          * Since the JSON specification does not permit trailing commas, this is a non-standard
-          * feature, and as such disabled by default.
+          * Feature that determines whether {@link JsonLocation} instances should be constructed
+          * with reference to source or not. If source reference is included, its type and contents
+          * are included when `toString()` method is called (most notably when printing out parse
+          * exception with that location information). If feature is disabled, no source reference
+          * is passed and source is only indicated as "UNKNOWN".
+          *<p>
+          * Most common reason for disabling this feature is to avoid leaking information about
+          * internal information; this may be done for security reasons.
+          * Note that even if source reference is included, only parts of contents are usually
+          * printed, and not the whole contents. Further, many source reference types can not
+          * necessarily access contents (like streams), so only type is indicated, not contents.
+          *<p>
+          * Feature is enabled by default, meaning that "source reference" information is passed
+          * and some or all of the source content may be included in {@link JsonLocation} information
+          * constructed either when requested explicitly, or when needed for an exception.
           *
           * @since 2.9
           */
-         ALLOW_TRAILING_COMMA(false)
+         INCLUDE_SOURCE_IN_LOCATION(true),
+         
          ;
 
         /**
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
index 92c1b8f8..83fb51ae 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
@@ -442,7 +442,7 @@ public abstract class ParserBase extends ParserMinimalBase
      */
     @Override
     public JsonLocation getTokenLocation() {
-        return new JsonLocation(_ioContext.getSourceReference(),
+        return new JsonLocation(_getSourceReference(),
                 -1L, getTokenCharacterOffset(), // bytes, chars
                 getTokenLineNr(),
                 getTokenColumnNr());
@@ -455,7 +455,7 @@ public abstract class ParserBase extends ParserMinimalBase
     @Override
     public JsonLocation getCurrentLocation() {
         int col = _inputPtr - _currInputRowStart + 1; // 1-based
-        return new JsonLocation(_ioContext.getSourceReference(),
+        return new JsonLocation(_getSourceReference(),
                 -1L, _currInputProcessed + _inputPtr, // bytes, chars
                 _currInputRow, col);
     }
@@ -504,7 +504,7 @@ public abstract class ParserBase extends ParserMinimalBase
 
     /*
     /**********************************************************
-    /* Abstract methods needed from sub-classes
+    /* Abstract methods for sub-classes to implement
     /**********************************************************
      */
 
@@ -543,7 +543,7 @@ public abstract class ParserBase extends ParserMinimalBase
             _reportInvalidEOF(String.format(
                     ": expected close marker for %s (start marker at %s)",
                     marker,
-                    _parsingContext.getStartLocation(_ioContext.getSourceReference())),
+                    _parsingContext.getStartLocation(_getSourceReference())),
                     null);
         }
     }
@@ -555,17 +555,6 @@ public abstract class ParserBase extends ParserMinimalBase
         _handleEOF();
         return -1;
     }
-    
-    /*
-    /**********************************************************
-    /* Internal/package methods: Error reporting
-    /**********************************************************
-     */
-    
-    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {
-        String startDesc = ""+_parsingContext.getStartLocation(_ioContext.getSourceReference());
-        _reportError("Unexpected close marker '"+((char) actCh)+"': expected '"+expCh+"' (for "+_parsingContext.typeDesc()+" starting at "+startDesc+")");
-    }
 
     /*
     /**********************************************************
@@ -1051,13 +1040,18 @@ public abstract class ParserBase extends ParserMinimalBase
         }
         _numTypesValid |= NR_BIGDECIMAL;
     }
-    
+
     /*
     /**********************************************************
-    /* Number handling exceptions
+    /* Internal/package methods: Error reporting
     /**********************************************************
-     */    
+     */
     
+    protected void _reportMismatchedEndMarker(int actCh, char expCh) throws JsonParseException {
+        String startDesc = ""+_parsingContext.getStartLocation(_getSourceReference());
+        _reportError("Unexpected close marker '"+((char) actCh)+"': expected '"+expCh+"' (for "+_parsingContext.typeDesc()+" starting at "+startDesc+")");
+    }
+
     protected void reportUnexpectedNumberChar(int ch, String comment) throws JsonParseException {
         String msg = "Unexpected character ("+_getCharDesc(ch)+") in numeric value";
         if (comment != null) {
@@ -1162,6 +1156,25 @@ public abstract class ParserBase extends ParserMinimalBase
         return new IllegalArgumentException(base);
     }
 
+    /*
+    /**********************************************************
+    /* Internal/package methods: other
+    /**********************************************************
+     */
+
+    /**
+     * Helper method used to encapsulate logic of including (or not) of
+     * "source reference" when constructing {@link JsonLocation} instances.
+     *
+     * @since 2.9
+     */
+    protected Object _getSourceReference() {
+        if (JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION.enabledIn(_features)) {
+            return _ioContext.getSourceReference();
+        }
+        return null;
+    }
+    
     /*
     /**********************************************************
     /* Stuff that was abstract and required before 2.8, but that
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
index 6ec93122..c3da66cd 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
@@ -127,10 +127,8 @@ public abstract class ParserMinimalBase extends JsonParser
     
     @Override
     public JsonToken nextValue() throws IOException {
-        /* Implementation should be as trivial as follows; only
-         * needs to change if we are to skip other tokens (for
-         * example, if comments were exposed as tokens)
-         */
+        // Implementation should be as trivial as follows; only needs to change if
+        // we are to skip other tokens (for example, if comments were exposed as tokens)
         JsonToken t = nextToken();
         if (t == JsonToken.FIELD_NAME) {
             t = nextToken();
@@ -147,9 +145,8 @@ public abstract class ParserMinimalBase extends JsonParser
         }
         int open = 1;
 
-        /* Since proper matching of start/end markers is handled
-         * by nextToken(), we'll just count nesting levels here
-         */
+        // Since proper matching of start/end markers is handled
+        // by nextToken(), we'll just count nesting levels here
         while (true) {
             JsonToken t = nextToken();
             if (t == null) {
diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
index 118d79b8..a0014052 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
@@ -2760,20 +2760,19 @@ public class ReaderBasedJsonParser // final in 2.3, earlier
     @Override
     public JsonLocation getTokenLocation()
     {
-        final Object src = _ioContext.getSourceReference();
         if (_currToken == JsonToken.FIELD_NAME) {
             long total = _currInputProcessed + (_nameStartOffset-1);
-            return new JsonLocation(src,
+            return new JsonLocation(_getSourceReference(),
                     -1L, total, _nameStartRow, _nameStartCol);
         }
-        return new JsonLocation(src,
+        return new JsonLocation(_getSourceReference(),
                 -1L, _tokenInputTotal-1, _tokenInputRow, _tokenInputCol);
     }
 
     @Override
     public JsonLocation getCurrentLocation() {
         int col = _inputPtr - _currInputRowStart + 1; // 1-based
-        return new JsonLocation(_ioContext.getSourceReference(),
+        return new JsonLocation(_getSourceReference(),
                 -1L, _currInputProcessed + _inputPtr,
                 _currInputRow, col);
     }
diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java
index 66f96e5d..7881b48c 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java
@@ -2812,16 +2812,12 @@ public class UTF8DataInputJsonParser
 
     @Override
     public JsonLocation getTokenLocation() {
-        final Object src = _ioContext.getSourceReference();
-        return new JsonLocation(src,
-                -1L, -1L, _tokenInputRow, -1);
+        return new JsonLocation(_getSourceReference(), -1L, -1L, _tokenInputRow, -1);
     }
 
     @Override
     public JsonLocation getCurrentLocation() {
-        final Object src = _ioContext.getSourceReference();
-        return new JsonLocation(src,
-                -1L, -1L, _currInputRow, -1);
+        return new JsonLocation(_getSourceReference(), -1L, -1L, _currInputRow, -1);
     }
 
     /*
diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
index 28e985f5..1471ce2a 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
@@ -3681,13 +3681,12 @@ public class UTF8StreamJsonParser
     @Override
     public JsonLocation getTokenLocation()
     {
-        final Object src = _ioContext.getSourceReference();
         if (_currToken == JsonToken.FIELD_NAME) {
             long total = _currInputProcessed + (_nameStartOffset-1);
-            return new JsonLocation(src,
+            return new JsonLocation(_getSourceReference(),
                     total, -1L, _nameStartRow, _nameStartCol);
         }
-        return new JsonLocation(src,
+        return new JsonLocation(_getSourceReference(),
                 _tokenInputTotal-1, -1L, _tokenInputRow, _tokenInputCol);
     }
 
@@ -3696,7 +3695,7 @@ public class UTF8StreamJsonParser
     public JsonLocation getCurrentLocation()
     {
         int col = _inputPtr - _currInputRowStart + 1; // 1-based
-        return new JsonLocation(_ioContext.getSourceReference(),
+        return new JsonLocation(_getSourceReference(),
                 _currInputProcessed + _inputPtr, -1L, // bytes, chars
                 _currInputRow, col);
     }
diff --git a/src/test/java/com/fasterxml/jackson/core/TestLocation.java b/src/test/java/com/fasterxml/jackson/core/TestLocation.java
index d9931297..5a198ca8 100644
--- a/src/test/java/com/fasterxml/jackson/core/TestLocation.java
+++ b/src/test/java/com/fasterxml/jackson/core/TestLocation.java
@@ -1,7 +1,12 @@
 package com.fasterxml.jackson.core;
 
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+
 public class TestLocation extends BaseTest
 {
+    static class Foobar { }
+
     public void testBasics()
     {
         JsonLocation loc1 = new JsonLocation("src", 10L, 10L, 1, 2);
@@ -14,8 +19,89 @@ public class TestLocation extends BaseTest
         // don't care about what it is; should not compute to 0 with data above
         assertTrue(loc1.hashCode() != 0);
         assertTrue(loc2.hashCode() != 0);
+    }
+
+    public void testBasicToString() throws Exception
+    {
+        // no location:
+        assertEquals("[Source: UNKNOWN; line: 3, column: 2]",
+                new JsonLocation(null, 10L, 10L, 3, 2).toString());
+
+        // Short String
+        assertEquals("[Source: (String)\"string-source\"; line: 1, column: 2]",
+                new JsonLocation("string-source", 10L, 10L, 1, 2).toString());
+
+        // Short char[]
+        assertEquals("[Source: (char[])\"chars-source\"; line: 1, column: 2]",
+                new JsonLocation("chars-source".toCharArray(), 10L, 10L, 1, 2).toString());
+
+        // Short byte[]
+        assertEquals("[Source: (byte[])\"bytes-source\"; line: 1, column: 2]",
+                new JsonLocation("bytes-source".getBytes("UTF-8"), 10L, 10L, 1, 2).toString());
+
+        // InputStream
+        assertEquals("[Source: (ByteArrayInputStream); line: 1, column: 2]",
+                new JsonLocation(new ByteArrayInputStream(new byte[0]), 10L, 10L, 1, 2).toString());
+
+        // Class<?> that specifies source type
+        assertEquals("[Source: (InputStream); line: 1, column: 2]",
+                new JsonLocation(InputStream.class, 10L, 10L, 1, 2).toString());
+
+        // misc other
+        Foobar srcRef = new Foobar();
+        assertEquals("[Source: ("+srcRef.getClass().getName()+"); line: 1, column: 2]",
+                new JsonLocation(srcRef, 10L, 10L, 1, 2).toString());
+    }
+
+    public void testTruncatedSource() throws Exception
+    {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < JsonLocation.MAX_CONTENT_SNIPPET; ++i) {
+            sb.append("x");
+        }
+        String main = sb.toString();
+        String json = main + "yyy";
+        JsonLocation loc = new JsonLocation(json, 0L, 0L, 1, 1);
+        String desc = loc.getSourceDescription();
+        assertEquals(String.format("(String)\"%s\"[truncated 3 chars]", main), desc);
+
+        // and same with bytes
+        loc = new JsonLocation(json.getBytes("UTF-8"), 0L, 0L, 1, 1);
+        desc = loc.getSourceDescription();
+        assertEquals(String.format("(byte[])\"%s\"[truncated 3 bytes]", main), desc);
+    }
+
+    // for [jackson-core#356]
+    public void testDisableSourceInclusion() throws Exception
+    {
+        JsonFactory f = new JsonFactory();
+        f.disable(JsonParser.Feature.INCLUDE_SOURCE_IN_LOCATION);
+
+        JsonParser p = f.createParser("[ foobar ]");
+        assertToken(JsonToken.START_ARRAY, p.nextToken());
+        try {
+            p.nextToken();
+            fail("Shouldn't have passed");
+        } catch (JsonParseException e) {
+            verifyException(e, "unrecognized token");
+            JsonLocation loc = e.getLocation();
+            assertNull(loc.getSourceRef());
+            assertEquals("UNKNOWN", loc.getSourceDescription());            
+        }
+        p.close();
 
-        assertEquals("[Source: src; line: 1, column: 2]", loc1.toString());
-        assertEquals("[Source: UNKNOWN; line: 3, column: 2]", loc2.toString());
+        // and verify same works for byte-based too
+        p = f.createParser("[ foobar ]".getBytes("UTF-8"));
+        assertToken(JsonToken.START_ARRAY, p.nextToken());
+        try {
+            p.nextToken();
+            fail("Shouldn't have passed");
+        } catch (JsonParseException e) {
+            verifyException(e, "unrecognized token");
+            JsonLocation loc = e.getLocation();
+            assertNull(loc.getSourceRef());
+            assertEquals("UNKNOWN", loc.getSourceDescription());            
+        }
+        p.close();
     }
 }
diff --git a/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java b/src/test/java/com/fasterxml/jackson/core/json/LocationOffsetsTest.java
similarity index 96%
rename from src/test/java/com/fasterxml/jackson/core/json/TestLocation.java
rename to src/test/java/com/fasterxml/jackson/core/json/LocationOffsetsTest.java
index f3192e6d..a8e7d259 100644
--- a/src/test/java/com/fasterxml/jackson/core/json/TestLocation.java
+++ b/src/test/java/com/fasterxml/jackson/core/json/LocationOffsetsTest.java
@@ -3,7 +3,7 @@ package com.fasterxml.jackson.core.json;
 import com.fasterxml.jackson.core.*;
 
 // NOTE: just a stub so for, fill me!
-public class TestLocation extends com.fasterxml.jackson.core.BaseTest
+public class LocationOffsetsTest extends com.fasterxml.jackson.core.BaseTest
 {
     final JsonFactory JSON_F = new JsonFactory();
 
