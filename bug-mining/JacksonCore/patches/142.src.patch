diff --git a/src/main/java/tools/jackson/core/base/ParserBase.java b/src/main/java/tools/jackson/core/base/ParserBase.java
index 489d1462..0b77b6d8 100644
--- a/src/main/java/tools/jackson/core/base/ParserBase.java
+++ b/src/main/java/tools/jackson/core/base/ParserBase.java
@@ -1,7 +1,5 @@
 package tools.jackson.core.base;
 
-import java.io.IOException;
-//import java.io.*;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.Arrays;
@@ -26,20 +24,7 @@ public abstract class ParserBase extends ParserMinimalBase
 {
     /*
     /**********************************************************************
-    /* Generic I/O state
-    /**********************************************************************
-     */
-
-    /**
-     * Flag that indicates whether parser is closed or not. Gets
-     * set when parser is either closed by explicit call
-     * ({@link #close}) or when end-of-input is reached.
-     */
-    protected boolean _closed;
-
-    /*
-    /**********************************************************************
-    /* Current input data
+    /* Current input data offsets
     /**********************************************************************
      */
 
@@ -277,25 +262,11 @@ public abstract class ParserBase extends ParserMinimalBase
     @Override
     public void close() throws JacksonException
     {
-        if (!_closed) {
-            super.close(); // will close IOContext (bit early but still)
-            // 19-Jan-2018, tatu: as per [core#440] need to ensure no more data assumed available
-            _inputPtr = Math.max(_inputPtr, _inputEnd);
-            _closed = true;
-            try {
-                _closeInput();
-            } catch (IOException e) {
-                throw _wrapIOFailure(e);
-            } finally {
-                // as per [JACKSON-324], do in finally block
-                // Also, internal buffer(s) can now be released as well
-                _releaseBuffers();
-            }
-        }
+        super.close();
+        // 19-Jan-2018, tatu: as per [core#440] need to ensure no more data assumed available
+        _inputPtr = Math.max(_inputPtr, _inputEnd);
     }
 
-    @Override public boolean isClosed() { return _closed; }
-
 //    public JsonLocation getTokenLocation()
 //   public JsonLocation getCurrentLocation()
 
diff --git a/src/main/java/tools/jackson/core/base/ParserMinimalBase.java b/src/main/java/tools/jackson/core/base/ParserMinimalBase.java
index 3658b77b..553dc12b 100644
--- a/src/main/java/tools/jackson/core/base/ParserMinimalBase.java
+++ b/src/main/java/tools/jackson/core/base/ParserMinimalBase.java
@@ -174,6 +174,13 @@ public abstract class ParserMinimalBase extends JsonParser
      */
     protected final IOContext _ioContext;
 
+    /**
+     * Flag that indicates whether parser is closed or not. Gets
+     * set when parser is either closed by explicit call
+     * ({@link #close}) or when end-of-input is reached.
+     */
+    protected boolean _closed;
+    
     /**
      * Last token retrieved via {@link #nextToken}, if any.
      * Null before the first call to <code>nextToken()</code>,
@@ -280,16 +287,35 @@ public abstract class ParserMinimalBase extends JsonParser
     // public JsonToken getCurrentToken()
     // public boolean hasCurrentToken()
 
+    @Override
+    public boolean isClosed() { return _closed; }
+    
     @Override
     public void close() throws JacksonException
     {
-        // !!! TODO: calls to closeInput(), releaseBuffers()
-        if (_ioContext != null) { // is case for some "virtual" parsers
-            _ioContext.close();
+        if (_closed) {
+            return;
         }
-    }
+        _closed = true;
 
-    // public abstract boolean isClosed();
+        // Ordering is important: needs to be done in following order:
+        //
+        // 1. Close actual input source that may use buffering
+        // 2. Close (release) underlying buffers (to/via IOContext)
+        // 3. Close IOContext which will then release recycler (if any)
+        try {
+            _closeInput();
+        } catch (IOException e) {
+            throw _wrapIOFailure(e);
+        } finally {
+            // Do in finally block so occurs even if stream closing fails
+            // with exception
+            _releaseBuffers();
+            if (_ioContext != null) { // is case for some "virtual" parsers
+                _ioContext.close();
+            }
+        }
+    }
 
     /**
      * Abstract method for sub-classes to implement; to be called by
