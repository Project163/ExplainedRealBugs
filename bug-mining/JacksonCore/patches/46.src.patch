diff --git a/release-notes/VERSION b/release-notes/VERSION
index 43b2b889..32a65b69 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -28,6 +28,7 @@ JSON library.
  (contributed by Brad H)
 #325: `DataInput` backed parser should handle `EOFException` at end of doc
  (reported by Brad H)
+#330: `FilteringParserDelegate` seems to miss last closing `END_OBJECT`
 #340: Making `WriterBasedJsonGenerator` non-final
  (requested by rfoltyns@github)
 #356: Improve indication of "source reference" in `JsonLocation` wrt `byte[]`,`char[]`
diff --git a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
index 8c236876..5274f33e 100644
--- a/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
+++ b/src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
@@ -226,21 +226,29 @@ public class FilteringParserDelegate extends JsonParserDelegate
     @Override
     public JsonToken nextToken() throws IOException
     {
-    	//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken
-    	// check for no buffered context _exposedContext - null
-    	//If all the conditions matches then check for scalar / non-scalar property
-    	if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){
-    		//if not scalar and ended successfully, then return null
-    		if((_currToken.isStructEnd()  && _headContext.isStartHandled()) ){
-    			return (_currToken = null);
-    		}
-    		//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once
-    		// then return null 
-    		else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath 
-    				&& _itemFilter == TokenFilter.INCLUDE_ALL) {
-    			return (_currToken = null);
-    		}
-    	}
+        // 23-May-2017, tatu: To be honest, code here is rather hairy and I don't like all
+        //    conditionals; and it seems odd to return `null` but NOT considering input
+        //    as closed... would love a rewrite to simplify/clear up logic here.
+        
+        // Check for _allowMultipleMatches - false and at least there is one token - which is _currToken
+        // check for no buffered context _exposedContext - null
+        // If all the conditions matches then check for scalar / non-scalar property
+        if (!_allowMultipleMatches && (_currToken != null) && (_exposedContext == null)) {
+            //if not scalar and ended successfully, and !includePath, then return null
+            if (!_includePath) {
+                if (_currToken.isStructEnd()) {
+                    if (_headContext.isStartHandled()) {
+                        return (_currToken = null);
+                    }
+                } else if (_currToken.isScalarValue()) {
+                    //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once
+                    // then return null 
+                    if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) {
+                        return (_currToken = null);
+                    }
+                }
+            }
+        }
         // Anything buffered?
         TokenFilterContext ctxt = _exposedContext;
 
diff --git a/src/test/java/com/fasterxml/jackson/failing/TokenVerifyingParserFiltering330Test.java b/src/test/java/com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
similarity index 99%
rename from src/test/java/com/fasterxml/jackson/failing/TokenVerifyingParserFiltering330Test.java
rename to src/test/java/com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
index 88cf4de0..f3a93bb7 100644
--- a/src/test/java/com/fasterxml/jackson/failing/TokenVerifyingParserFiltering330Test.java
+++ b/src/test/java/com/fasterxml/jackson/core/filter/TokenVerifyingParserFiltering330Test.java
@@ -1,4 +1,4 @@
-package com.fasterxml.jackson.failing;
+package com.fasterxml.jackson.core.filter;
 
 import java.util.Arrays;
 import java.util.HashSet;
