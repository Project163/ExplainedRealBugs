diff --git a/release-notes/VERSION b/release-notes/VERSION
index 49267d19..639a52c6 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -21,4 +21,5 @@ JSON library.
 #432: Add new `TreeNode` subtypes: `ArrayTreeNode`, `ObjectTreeNode`
 #433: Add Builder pattern for creating configured Stream factories
 #456: Add `JsonParser.readAsValue(ResolvedType)`
+#492: Ensure primitive type names in error message enclosed in backticks
 - Rename `JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT` as `AUTO_CLOSE_CONTENT`
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonParser.java b/src/main/java/com/fasterxml/jackson/core/JsonParser.java
index 7b63904f..98d359fa 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonParser.java
@@ -1014,10 +1014,10 @@ public abstract class JsonParser
     public byte getByteValue() throws IOException {
         int value = getIntValue();
         // So far so good: but does it fit?
-        // [JACKSON-804]: Let's actually allow range of [-128, 255], as those are uniquely mapped
-        //  (instead of just signed range of [-128, 127])
+        // Let's actually allow range of [-128, 255] instead of just signed range of [-128, 127]
+        // since "unsigned" usage quite common for bytes (but Java may use signed range, too)
         if (value < MIN_BYTE_I || value > MAX_BYTE_I) {
-            throw _constructError("Numeric value ("+getText()+") out of range of Java byte");
+            throw _constructError("Numeric value (%s) out of range of `byte`", getText());
         }
         return (byte) value;
     }
@@ -1039,7 +1039,7 @@ public abstract class JsonParser
     {
         int value = getIntValue();
         if (value < MIN_SHORT_I || value > MAX_SHORT_I) {
-            throw _constructError("Numeric value ("+getText()+") out of range of Java short");
+            throw _constructError("Numeric value (%s) out of range of `short`", getText());
         }
         return (short) value;
     }
@@ -1523,6 +1523,16 @@ public abstract class JsonParser
             .withRequestPayload(_requestPayload);
     }
 
+    protected JsonParseException _constructError(String msg, Object arg) {
+        return new JsonParseException(this, String.format(msg, arg))
+            .withRequestPayload(_requestPayload);
+    }
+
+    protected JsonParseException _constructError(String msg, Object arg1, Object arg2) {
+        return new JsonParseException(this, String.format(msg, arg1, arg2))
+            .withRequestPayload(_requestPayload);
+    }
+    
     /**
      * Helper method to call for operations that are not supported by
      * parser implementation.
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
index db81fc74..36f5555e 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
@@ -633,9 +633,8 @@ public abstract class ParserBase extends ParserMinimalBase
     public float getFloatValue() throws IOException
     {
         double value = getDoubleValue();
-        /* 22-Jan-2009, tatu: Bounds/range checks would be tricky
-         *   here, so let's not bother even trying...
-         */
+        // 22-Jan-2009, tatu: Bounds/range checks would be tricky
+        //   here, so let's not bother even trying...
         /*
         if (value < -Float.MAX_VALUE || value > MAX_FLOAT_D) {
             _reportError("Numeric value ("+getText()+") out of range of Java float");
@@ -816,7 +815,7 @@ public abstract class ParserBase extends ParserMinimalBase
     protected void _reportTooLongInt(int expType, String rawNum) throws IOException
     {
         final String numDesc = _longIntegerDesc(rawNum);
-        _reportError("Numeric value (%s) out of range of %s", numDesc,
+        _reportError("Numeric value (%s) out of range of `%s`", numDesc,
                 (expType == NR_LONG) ? "long" : "int");
     }
 
@@ -833,7 +832,7 @@ public abstract class ParserBase extends ParserMinimalBase
             // Let's verify it's lossless conversion by simple roundtrip
             int result = (int) _numberLong;
             if (((long) result) != _numberLong) {
-                _reportError("Numeric value ("+getText()+") out of range of int");
+                _reportError("Numeric value ("+getText()+") out of range of `int`");
             }
             _numberInt = result;
         } else if ((_numTypesValid & NR_BIGINT) != 0) {
diff --git a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
index b8ec9296..4e73b0a4 100644
--- a/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
+++ b/src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
@@ -667,16 +667,15 @@ public abstract class ParserMinimalBase extends JsonParser
     }
 
     protected void reportOverflowInt() throws IOException {
-        _reportError(String.format("Numeric value (%s) out of range of int (%d - %s)",
-                _longIntegerDesc(getText()), Integer.MIN_VALUE, Integer.MAX_VALUE));
+        _reportError("Numeric value (%s) out of range of `int` (%d - %s)",
+                _longIntegerDesc(getText()), Integer.MIN_VALUE, Integer.MAX_VALUE);
     }
 
     protected void reportOverflowLong() throws IOException {
-        _reportError(String.format("Numeric value (%s) out of range of long (%d - %s)",
-                _longIntegerDesc(getText()), Long.MIN_VALUE, Long.MAX_VALUE));
+        _reportError("Numeric value (%s) out of range of `long` (%d - %s)",
+                _longIntegerDesc(getText()), Long.MIN_VALUE, Long.MAX_VALUE);
     }
 
-    // @since 2.9.8
     protected String _longIntegerDesc(String rawNum) {
         int rawLen = rawNum.length();
         if (rawLen < 1000) {
@@ -688,7 +687,6 @@ public abstract class ParserMinimalBase extends JsonParser
         return String.format("[Integer with %d digits]", rawLen);
     }
 
-    // @since 2.9.8
     protected String _longNumberDesc(String rawNum) {
         int rawLen = rawNum.length();
         if (rawLen < 1000) {
@@ -773,6 +771,10 @@ public abstract class ParserMinimalBase extends JsonParser
         throw _constructError(String.format(msg, arg1, arg2));
     }
 
+    protected final void _reportError(String msg, Object arg1, Object arg2, Object arg3) throws JsonParseException {
+        throw _constructError(String.format(msg, arg1, arg2, arg3));
+    }
+
     protected final void _wrapError(String msg, Throwable t) throws JsonParseException {
         throw _constructError(msg, t);
     }
diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
index e6611082..ccccbf05 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
@@ -20,12 +20,7 @@ public class ReaderBasedJsonParser
     extends JsonParserBase
 {
     private final static int FEAT_MASK_TRAILING_COMMA = JsonReadFeature.ALLOW_TRAILING_COMMA.getMask();
-
     private final static int FEAT_MASK_ALLOW_MISSING = JsonReadFeature.ALLOW_MISSING_VALUES.getMask();
-    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = JsonReadFeature.ALLOW_SINGLE_QUOTES.getMask();
-
-    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = JsonReadFeature.ALLOW_JAVA_COMMENTS.getMask();
-    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = JsonReadFeature.ALLOW_YAML_COMMENTS.getMask();
 
     // Latin1 encoding is not supported, but we do use 8-bit subset for
     // pre-processing task, to simplify first pass, keep it fast.
@@ -450,9 +445,8 @@ public class ReaderBasedJsonParser
             } catch (IllegalArgumentException iae) {
                 throw _constructError("Failed to decode VALUE_STRING as base64 ("+b64variant+"): "+iae.getMessage());
             }
-            /* let's clear incomplete only now; allows for accessing other
-             * textual content in error cases
-             */
+            // let's clear incomplete only now; allows for accessing other
+            // textual content in error cases
             _tokenIncomplete = false;
         } else { // may actually require conversion...
             if (_binaryValue == null) {
@@ -540,7 +534,7 @@ public class ReaderBasedJsonParser
             // First branch: can get padding (-> 1 byte)
             if (bits < 0) {
                 if (bits != Base64Variant.BASE64_VALUE_PADDING) {
-                    // as per [JACKSON-631], could also just be 'missing'  padding
+                    // could also just be missing padding
                     if (ch == '"' && !b64variant.usesPadding()) {
                         decodedData >>= 4;
                         buffer[outputPtr++] = (byte) decodedData;
@@ -575,7 +569,7 @@ public class ReaderBasedJsonParser
             bits = b64variant.decodeBase64Char(ch);
             if (bits < 0) {
                 if (bits != Base64Variant.BASE64_VALUE_PADDING) {
-                    // as per [JACKSON-631], could also just be 'missing'  padding
+                    // as per could also just be missing padding
                     if (ch == '"' && !b64variant.usesPadding()) {
                         decodedData >>= 2;
                         buffer[outputPtr++] = (byte) (decodedData >> 8);
@@ -1742,7 +1736,7 @@ public class ReaderBasedJsonParser
     protected String _handleOddName(int i) throws IOException
     {
         // Allow single quotes?
-        if (i == '\'' && (_formatReadFeatures & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {
+        if (i == '\'' && isEnabled(JsonReadFeature.ALLOW_SINGLE_QUOTES)) {
             return _parseAposName();
         }
         // Allow unquoted names if feature enabled:
@@ -1755,7 +1749,7 @@ public class ReaderBasedJsonParser
         // Also: first char must be a valid name char, but NOT be number
         boolean firstOk;
 
-        if (i < maxCode) { // identifier, or a number ([Issue#102])
+        if (i < maxCode) { // identifier, or a number ([jackson-core#102])
             firstOk = (codes[i] == 0);
         } else {
             firstOk = Character.isJavaIdentifierPart((char) i);
@@ -1836,15 +1830,14 @@ public class ReaderBasedJsonParser
              * Also, no separation to fast/slow parsing; we'll just do
              * one regular (~= slowish) parsing, to keep code simple
              */
-            if ((_formatReadFeatures & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {
+            if (isEnabled(JsonReadFeature.ALLOW_SINGLE_QUOTES)) {
                 return _handleApos();
             }
             break;
         case ']':
-            /* 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled
-             *   we may allow "missing values", that is, encountering a trailing
-             *   comma or closing marker where value would be expected
-             */
+            // 28-Mar-2016: [core#116]: If Feature.ALLOW_MISSING_VALUES is enabled
+            //   we may allow "missing values", that is, encountering a trailing
+            //   comma or closing marker where value would be expected
             if (!_parsingContext.inArray()) {
                 break;
             }
@@ -2401,7 +2394,7 @@ public class ReaderBasedJsonParser
 
     private void _skipComment() throws IOException
     {
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_JAVA_COMMENTS)) {
             _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)");
         }
         // First: check which comment (if either) it is:
@@ -2451,7 +2444,7 @@ public class ReaderBasedJsonParser
 
     private boolean _skipYAMLComment() throws IOException
     {
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_YAML_COMMENTS)) {
             return false;
         }
         _skipLine();
diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java
index 4585e8b4..df14233c 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8DataInputJsonParser.java
@@ -35,10 +35,6 @@ public class UTF8DataInputJsonParser
 {
     final static byte BYTE_LF = (byte) '\n';
 
-    private final static int FEAT_MASK_TRAILING_COMMA = JsonReadFeature.ALLOW_TRAILING_COMMA.getMask();
-    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = JsonReadFeature.ALLOW_JAVA_COMMENTS.getMask();
-    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = JsonReadFeature.ALLOW_YAML_COMMENTS.getMask();
-
     // This is the main input-code lookup table, fetched eagerly
     private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();
 
@@ -584,7 +580,7 @@ public class UTF8DataInputJsonParser
             i = _skipWS();
 
             // Was that a trailing comma?
-            if ((_formatReadFeatures & FEAT_MASK_TRAILING_COMMA) != 0) {
+            if (isEnabled(JsonReadFeature.ALLOW_TRAILING_COMMA)) {
                 if (i == INT_RBRACKET || i == INT_RCURLY) {
                     _closeScope(i);
                     return _currToken;
@@ -766,7 +762,7 @@ public class UTF8DataInputJsonParser
             i = _skipWS();
 
             // Was that a trailing comma?
-            if ((_formatReadFeatures & FEAT_MASK_TRAILING_COMMA) != 0) {
+            if (isEnabled(JsonReadFeature.ALLOW_TRAILING_COMMA)) {
                 if (i == INT_RBRACKET || i == INT_RCURLY) {
                     _closeScope(i);
                     return null;
@@ -2339,7 +2335,7 @@ public class UTF8DataInputJsonParser
 
     private final void _skipComment() throws IOException
     {
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_JAVA_COMMENTS)) {
             _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)");
         }
         int c = _inputData.readUnsignedByte();
@@ -2394,7 +2390,7 @@ public class UTF8DataInputJsonParser
 
     private final boolean _skipYAMLComment() throws IOException
     {
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_YAML_COMMENTS)) {
             return false;
         }
         _skipLine();
diff --git a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
index 22ebf332..ee915e7f 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
@@ -23,8 +23,6 @@ public class UTF8StreamJsonParser
 
     private final static int FEAT_MASK_TRAILING_COMMA = JsonReadFeature.ALLOW_TRAILING_COMMA.getMask();
     private final static int FEAT_MASK_ALLOW_MISSING = JsonReadFeature.ALLOW_MISSING_VALUES.getMask();
-    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = JsonReadFeature.ALLOW_JAVA_COMMENTS.getMask();
-    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = JsonReadFeature.ALLOW_YAML_COMMENTS.getMask();
 
     // This is the main input-code lookup table, fetched eagerly
     private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();
@@ -3424,7 +3422,7 @@ public class UTF8StreamJsonParser
 
     private final void _skipComment() throws IOException
     {
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_JAVA_COMMENTS)) {
             _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)");
         }
         // First: check which comment (if either) it is:
@@ -3489,7 +3487,7 @@ public class UTF8StreamJsonParser
 
     private final boolean _skipYAMLComment() throws IOException
     {
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_YAML_COMMENTS)) {
             return false;
         }
         _skipLine();
diff --git a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java
index d78017c2..7d386c08 100644
--- a/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java
+++ b/src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java
@@ -18,10 +18,6 @@ public class NonBlockingJsonParser
 {
     private final static int FEAT_MASK_TRAILING_COMMA = JsonReadFeature.ALLOW_TRAILING_COMMA.getMask();
     private final static int FEAT_MASK_ALLOW_MISSING = JsonReadFeature.ALLOW_MISSING_VALUES.getMask();
-    private final static int FEAT_MASK_ALLOW_SINGLE_QUOTES = JsonReadFeature.ALLOW_SINGLE_QUOTES.getMask();
-    private final static int FEAT_MASK_ALLOW_UNQUOTED_NAMES = JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES.getMask();
-    private final static int FEAT_MASK_ALLOW_JAVA_COMMENTS = JsonReadFeature.ALLOW_JAVA_COMMENTS.getMask();
-    private final static int FEAT_MASK_ALLOW_YAML_COMMENTS = JsonReadFeature.ALLOW_YAML_COMMENTS.getMask();
 
     // This is the main input-code lookup table, fetched eagerly
     private final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();
@@ -909,7 +905,7 @@ public class NonBlockingJsonParser
             // been handled earlier
             break;
         case '\'':
-            if ((_formatReadFeatures & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {
+            if (isEnabled(JsonReadFeature.ALLOW_SINGLE_QUOTES)) {
                 return _startAposString();
             }
             break;
@@ -956,7 +952,7 @@ public class NonBlockingJsonParser
 
     private final JsonToken _startSlashComment(int fromMinorState) throws IOException
     {
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_JAVA_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_JAVA_COMMENTS)) {
             _reportUnexpectedChar('/', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)");
         }
 
@@ -980,7 +976,7 @@ public class NonBlockingJsonParser
     private final JsonToken _finishHashComment(int fromMinorState) throws IOException
     {
         // Could by-pass this check by refactoring, but for now simplest way...
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_YAML_COMMENTS) == 0) {
+        if (!isEnabled(JsonReadFeature.ALLOW_YAML_COMMENTS)) {
             _reportUnexpectedChar('#', "maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_YAML_COMMENTS' not enabled for parser)");
         }
         while (true) {
@@ -2060,16 +2056,15 @@ public class NonBlockingJsonParser
         // First: may allow single quotes
         switch (ch) {
         case '#':
-            // Careful, since this may alternatively be leading char of
-            // unquoted name...
-            if ((_formatReadFeatures & FEAT_MASK_ALLOW_YAML_COMMENTS) != 0) {
+            // Careful, since this may alternatively be leading char of unquoted name...
+            if (isEnabled(JsonReadFeature.ALLOW_YAML_COMMENTS)) {
                 return _finishHashComment(MINOR_FIELD_LEADING_WS);
             }
             break;
         case '/':
             return _startSlashComment(MINOR_FIELD_LEADING_WS);
         case '\'':
-            if ((_formatReadFeatures & FEAT_MASK_ALLOW_SINGLE_QUOTES) != 0) {
+            if (isEnabled(JsonReadFeature.ALLOW_SINGLE_QUOTES)) {
                 return _finishAposName(0, 0, 0);
             }
             break;
@@ -2077,8 +2072,8 @@ public class NonBlockingJsonParser
             return _closeArrayScope();
         }
         // allow unquoted names if feature enabled:
-        if ((_formatReadFeatures & FEAT_MASK_ALLOW_UNQUOTED_NAMES) == 0) {
-         // !!! TODO: Decode UTF-8 characters properly...
+        if (!isEnabled(JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES)) {
+            // !!! TODO: Decode UTF-8 characters properly...
 //            char c = (char) _decodeCharForError(ch);
             char c = (char) ch;
             _reportUnexpectedChar(c, "was expecting double-quote to start field name");
diff --git a/src/test/java/com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java b/src/test/java/com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java
index 50a4520f..4db29608 100644
--- a/src/test/java/com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/json/async/AsyncNumberCoercionTest.java
@@ -73,7 +73,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getIntValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of int");
+            verifyException(e, "out of range of `int`");
         }
         long small = -1L + Integer.MIN_VALUE;
         p = createParser(String.valueOf(small));
@@ -84,7 +84,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getIntValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of int");
+            verifyException(e, "out of range of `int`");
         }
 
         // double -> error
@@ -95,7 +95,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getIntValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of int");
+            verifyException(e, "out of range of `int`");
         }
         p = createParser(String.valueOf(small)+".0");
         assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());
@@ -104,7 +104,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getIntValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of int");
+            verifyException(e, "out of range of `int`");
         }
 
         // BigInteger -> error
@@ -115,7 +115,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getIntValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of int");
+            verifyException(e, "out of range of `int`");
         }
         p = createParser(String.valueOf(small));
         assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
@@ -124,7 +124,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getIntValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of int");
+            verifyException(e, "out of range of `int`");
         }
     }
 
@@ -177,7 +177,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getLongValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of long");
+            verifyException(e, "out of range of `long`");
         }
         BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
         p = createParser(String.valueOf(small));
@@ -187,7 +187,7 @@ public class AsyncNumberCoercionTest extends AsyncTestBase
             p.getLongValue();
             fail("Should not pass");
         } catch (JsonParseException e) {
-            verifyException(e, "out of range of long");
+            verifyException(e, "out of range of `long`");
         }
     }
     
diff --git a/src/test/java/com/fasterxml/jackson/core/read/NumberCoercionTest.java b/src/test/java/com/fasterxml/jackson/core/read/NumberCoercionTest.java
index 8b83f098..1186acf5 100644
--- a/src/test/java/com/fasterxml/jackson/core/read/NumberCoercionTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/read/NumberCoercionTest.java
@@ -67,7 +67,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getIntValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of int");
+                verifyException(e, "out of range of `int`");
             }
             long small = -1L + Integer.MIN_VALUE;
             p = createParser(mode, String.valueOf(small));
@@ -78,7 +78,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getIntValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of int");
+                verifyException(e, "out of range of `int`");
             }
 
             // double -> error
@@ -89,7 +89,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getIntValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of int");
+                verifyException(e, "out of range of `int`");
             }
             p = createParser(mode, String.valueOf(small)+".0");
             assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());
@@ -98,7 +98,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getIntValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of int");
+                verifyException(e, "out of range of `int`");
             }
 
             // BigInteger -> error
@@ -109,7 +109,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getIntValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of int");
+                verifyException(e, "out of range of `int`");
             }
             p = createParser(mode, String.valueOf(small));
             assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());
@@ -118,7 +118,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getIntValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of int");
+                verifyException(e, "out of range of `int`");
             }
         }
     }
@@ -176,7 +176,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getLongValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of long");
+                verifyException(e, "out of range of `long`");
             }
             BigInteger small = BigInteger.valueOf(Long.MIN_VALUE).subtract(BigInteger.TEN);
             p = createParser(mode, String.valueOf(small));
@@ -186,7 +186,7 @@ public class NumberCoercionTest extends BaseTest
                 p.getLongValue();
                 fail("Should not pass");
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of long");
+                verifyException(e, "out of range of `long`");
             }
         }
     }
diff --git a/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java b/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java
index ce835727..8c93f411 100644
--- a/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/read/NumberOverflowTest.java
@@ -41,7 +41,7 @@ public class NumberOverflowTest
                 long x = p.getLongValue();
                 fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of long");
+                verifyException(e, "out of range of `long`");
             }
             p.close();
 
@@ -51,7 +51,7 @@ public class NumberOverflowTest
                 long x = p.getLongValue();
                 fail("Expected an exception for underflow (input "+p.getText()+"): instead, got long value: "+x);
             } catch (JsonParseException e) {
-                verifyException(e, "out of range of long");
+                verifyException(e, "out of range of `long`");
             }
             p.close();
         }
@@ -72,7 +72,7 @@ public class NumberOverflowTest
                     p.getLongValue();
                     fail("Should not pass");
                 } catch (JsonParseException e) {
-                    verifyException(e, "out of range of long");
+                    verifyException(e, "out of range of `long`");
                     verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");
                 }
                 p.close();
@@ -92,7 +92,7 @@ public class NumberOverflowTest
                     p.getIntValue();
                     fail("Should not pass");
                 } catch (JsonParseException e) {
-                    verifyException(e, "out of range of int");
+                    verifyException(e, "out of range of `int`");
                     verifyException(e, "Integer with "+BIG_NUM_LEN+" digits");
                 }
                 p.close();
diff --git a/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java b/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
index 10b49978..edd92135 100644
--- a/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
+++ b/src/test/java/com/fasterxml/jackson/core/read/NumberParsingTest.java
@@ -283,7 +283,7 @@ public class NumberParsingTest
             /*int x =*/ p.getIntValue();
             fail("Expected an exception for overflow");
         } catch (Exception e) {
-            verifyException(e, "out of range of int");
+            verifyException(e, "out of range of `int`");
         }
         assertEquals(8100200300.0, p.getDoubleValue());
         assertEquals("8100200300", p.getText());
