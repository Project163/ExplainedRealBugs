diff --git a/release-notes/VERSION b/release-notes/VERSION
index d1d888c3..a8feea54 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -26,6 +26,7 @@ JSON library.
 #257: Add `writeStartObject(Object pojo)` to streamline assignment of current value
 #265: `JsonStringEncoder` should allow passing `CharSequence`
  (contributed by Mikael S)
+#276: Add support for serializing using `java.io.DataOutput`
 #280: Add `JsonParser.finishToken()` to force full, non-lazy reading of current token
 
 2.7.4 (29-Apr-2016)
diff --git a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java
index b0525079..9a9082e2 100644
--- a/src/main/java/com/fasterxml/jackson/core/JsonFactory.java
+++ b/src/main/java/com/fasterxml/jackson/core/JsonFactory.java
@@ -1148,6 +1148,28 @@ public class JsonFactory
         return _createGenerator(_decorate(w, ctxt), ctxt);
     }    
 
+    /**
+     * Method for constructing generator for writing content using specified
+     * {@link DataOutput} instance.
+     * 
+     * @since 2.8
+     */
+    public JsonGenerator createGenerator(DataOutput out, JsonEncoding enc) throws IOException {
+        return createGenerator(_createDataOutputWrapper(out), enc);
+    }
+
+    /**
+     * Convenience method for constructing generator that uses default
+     * encoding of the format (UTF-8 for JSON and most other data formats).
+     *<p>
+     * Note: there are formats that use fixed encoding (like most binary data formats).
+     * 
+     * @since 2.8
+     */
+    public JsonGenerator createGenerator(DataOutput out) throws IOException {
+        return createGenerator(_createDataOutputWrapper(out), JsonEncoding.UTF8);
+    }
+
     /*
     /**********************************************************
     /* Generator factories, old (pre-2.2)
@@ -1450,6 +1472,13 @@ public class JsonFactory
         return new IOContext(_getBufferRecycler(), srcRef, resourceManaged);
     }
 
+    /**
+     * @since 2.8
+     */
+    protected OutputStream _createDataOutputWrapper(DataOutput out) {
+        return new DataOutputAsStream(out);
+    }
+
     /**
      * Helper methods used for constructing an optimal stream for
      * parsers to use, when input is to be read from an URL.
@@ -1465,7 +1494,7 @@ public class JsonFactory
              */
             String host = url.getHost();
             if (host == null || host.length() == 0) {
-                // [Issue#48]: Let's try to avoid probs with URL encoded stuff
+                // [core#48]: Let's try to avoid probs with URL encoded stuff
                 String path = url.getPath();
                 if (path.indexOf('%') < 0) {
                     return new FileInputStream(url.getPath());
diff --git a/src/main/java/com/fasterxml/jackson/core/io/DataOutputAsStream.java b/src/main/java/com/fasterxml/jackson/core/io/DataOutputAsStream.java
new file mode 100644
index 00000000..5fa8cada
--- /dev/null
+++ b/src/main/java/com/fasterxml/jackson/core/io/DataOutputAsStream.java
@@ -0,0 +1,44 @@
+package com.fasterxml.jackson.core.io;
+
+import java.io.*;
+
+/**
+ * Helper class to support use of {@link DataOutput} for output, directly,
+ * without caller having to provide for implementation.
+ *
+ * @since 2.8
+ */
+public class DataOutputAsStream extends OutputStream
+{
+    protected final DataOutput _output;
+
+    public DataOutputAsStream(DataOutput out) {
+        super();
+        _output = out;
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        _output.write(b);
+    }
+
+    @Override
+    public void write(byte b[]) throws IOException {
+        _output.write(b, 0, b.length);
+    }
+
+    @Override
+    public void write(byte b[], int offset, int length) throws IOException {
+        _output.write(b, offset, length);
+    }
+
+    // These are no-ops, base class impl works fine
+
+    /*
+    @Override
+    public void flush() throws IOException { }
+
+    @Override
+    public void close() throws IOException { }
+    */
+}
diff --git a/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java
index 30a26222..cfbe77a3 100644
--- a/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java
+++ b/src/main/java/com/fasterxml/jackson/core/util/ByteArrayBuilder.java
@@ -42,7 +42,7 @@ public final class ByteArrayBuilder extends OutputStream
     private int _pastLen;
     private byte[] _currBlock;
     private int _currBlockPtr;
-    
+
     public ByteArrayBuilder() { this(null); }
     public ByteArrayBuilder(BufferRecycler br) { this(br, INITIAL_BLOCK_SIZE); }
     public ByteArrayBuilder(int firstBlockSize) { this(null, firstBlockSize); }
diff --git a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java
index 08771c85..f47d0051 100644
--- a/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java
+++ b/src/test/java/com/fasterxml/jackson/core/main/TestGeneratorMisc.java
@@ -240,46 +240,41 @@ public class TestGeneratorMisc
      */
     public void testLongerObjects() throws Exception
     {
-        JsonFactory jf = new JsonFactory();
-        for (int i = 0; i < 2; ++i) {
-            boolean useChars = (i == 0);
-            JsonGenerator jgen;
-            ByteArrayOutputStream bout = new ByteArrayOutputStream(200);
-            if (useChars) {
-                jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8"));
-            } else {
-                jgen = jf.createGenerator(bout, JsonEncoding.UTF8);
-            }
+        final JsonFactory jf = new JsonFactory();
+        _testLongerObjects(jf, 0);
+        _testLongerObjects(jf, 1);
+        _testLongerObjects(jf, 2);
+    }
 
-            jgen.writeStartObject();
+    public void _testLongerObjects(JsonFactory jf, int mode) throws Exception
+    {
+        JsonGenerator jgen;
+        ByteArrayOutputStream bout = new ByteArrayOutputStream(200);
 
-            for (int rounds = 0; rounds < 1500; ++rounds) {
-                for (int letter = 'a'; letter <= 'z'; ++letter) {
-                    for (int index = 0; index < 20; ++index) {
-                        String name;
-                        if (letter > 'f') {
-                            name = "X"+letter+index;
-                        } else if (letter > 'p') {
-                            name = ""+letter+index;
-                        } else {
-                            name = "__"+index+letter;
-                        }
-                        jgen.writeFieldName(name);
-                        jgen.writeNumber(index-1);
-                    }
-                    jgen.writeRaw('\n');
-                }
+        switch (mode) {
+        case 0:
+            jgen = jf.createGenerator(new OutputStreamWriter(bout, "UTF-8"));
+            break;
+        case 1:
+            jgen = jf.createGenerator(bout, JsonEncoding.UTF8);
+            break;
+        case 2:
+            {
+                DataOutputStream dout = new DataOutputStream(bout);
+                jgen = jf.createGenerator((DataOutput) dout);
             }
-            jgen.writeEndObject();
-            jgen.close();
+        
+            break;
+        default:
+            fail("Unknown mode "+mode);
+            jgen = null;
+        }
+
+        jgen.writeStartObject();
 
-            byte[] json = bout.toByteArray();
-            JsonParser jp = jf.createParser(json);
-            assertToken(JsonToken.START_OBJECT, jp.nextToken());
-            for (int rounds = 0; rounds < 1500; ++rounds) {
+        for (int rounds = 0; rounds < 1500; ++rounds) {
             for (int letter = 'a'; letter <= 'z'; ++letter) {
                 for (int index = 0; index < 20; ++index) {
-                    assertToken(JsonToken.FIELD_NAME, jp.nextToken());
                     String name;
                     if (letter > 'f') {
                         name = "X"+letter+index;
@@ -288,14 +283,37 @@ public class TestGeneratorMisc
                     } else {
                         name = "__"+index+letter;
                     }
-                    assertEquals(name, jp.getCurrentName());
-                    assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());
-                    assertEquals(index-1, jp.getIntValue());
+                    jgen.writeFieldName(name);
+                    jgen.writeNumber(index-1);
                 }
+                jgen.writeRaw('\n');
             }
+        }
+        jgen.writeEndObject();
+        jgen.close();
+
+        byte[] json = bout.toByteArray();
+        JsonParser jp = jf.createParser(json);
+        assertToken(JsonToken.START_OBJECT, jp.nextToken());
+        for (int rounds = 0; rounds < 1500; ++rounds) {
+        for (int letter = 'a'; letter <= 'z'; ++letter) {
+            for (int index = 0; index < 20; ++index) {
+                assertToken(JsonToken.FIELD_NAME, jp.nextToken());
+                String name;
+                if (letter > 'f') {
+                    name = "X"+letter+index;
+                } else if (letter > 'p') {
+                    name = ""+letter+index;
+                } else {
+                    name = "__"+index+letter;
+                }
+                assertEquals(name, jp.getCurrentName());
+                assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());
+                assertEquals(index-1, jp.getIntValue());
             }
-            assertToken(JsonToken.END_OBJECT, jp.nextToken());
-            jp.close();
         }
+        }
+        assertToken(JsonToken.END_OBJECT, jp.nextToken());
+        jp.close();
     }
 }
