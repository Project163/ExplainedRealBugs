diff --git a/release-notes/VERSION b/release-notes/VERSION
index c3c4ff02..bfa15536 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -38,6 +38,8 @@ JSON library.
 #689: Remove existing "request payload" functionality
 #785: Make `JsonGenerator.writeXxx()` methods chainable
 #793: Rename "com.fasterxml.jackson" -> "tools.jackson"
+#1090: Remove `BufferRecyclers.SYSTEM_PROPERTY_TRACK_REUSABLE_BUFFERS`
+  functionality from 3.0
 - Rename `JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT` as `AUTO_CLOSE_CONTENT`
 - Add `TreeCodec.nullNode()`, `TreeNode.isNull()` methods
 - Change the way `JsonLocation.NA` is included in exception messages
diff --git a/src/main/java/tools/jackson/core/util/BufferRecyclers.java b/src/main/java/tools/jackson/core/util/BufferRecyclers.java
index 6379c21b..0d1c11a1 100644
--- a/src/main/java/tools/jackson/core/util/BufferRecyclers.java
+++ b/src/main/java/tools/jackson/core/util/BufferRecyclers.java
@@ -12,96 +12,9 @@ import tools.jackson.core.TokenStreamFactory;
  */
 public class BufferRecyclers
 {
-    /**
-     * System property that is checked to see if recycled buffers (see {@link BufferRecycler})
-     * should be tracked, for purpose of forcing release of all such buffers, typically
-     * during major classloading.
-     */
-    public final static String SYSTEM_PROPERTY_TRACK_REUSABLE_BUFFERS
-        = "tools.jackson.core.util.BufferRecyclers.trackReusableBuffers";
-
-    /*
-    /**********************************************************
-    /* Life-cycle
-    /**********************************************************
-     */
-
-    /**
-     * Flag that indicates whether {@link BufferRecycler} instances should be tracked.
-     */
-    private final static ThreadLocalBufferManager _bufferRecyclerTracker;
-    static {
-        boolean trackReusableBuffers = false;
-        try {
-            trackReusableBuffers = "true".equals(System.getProperty(SYSTEM_PROPERTY_TRACK_REUSABLE_BUFFERS));
-        } catch (SecurityException e) { }
-
-        _bufferRecyclerTracker = trackReusableBuffers ? ThreadLocalBufferManager.instance() : null;
-    }
-
-    /*
-    /**********************************************************
-    /* BufferRecyclers for parsers, generators
-    /**********************************************************
-     */
-
-    /**
-     * This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftReference}
-     * to a {@link BufferRecycler} used to provide a low-cost
-     * buffer recycling between reader and writer instances.
-     */
-    final protected static ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef
-        = new ThreadLocal<SoftReference<BufferRecycler>>();
-
-    /**
-     * Main accessor to call for accessing possibly recycled {@link BufferRecycler} instance.
-     *
-     * @return {@link BufferRecycler} to use
-     *
-     * @deprecated Since 2.16 should use {@link BufferRecyclerPool} abstraction instead
-     *   of calling static methods of this class
-     */
-    @Deprecated // since 2.16
-    public static BufferRecycler getBufferRecycler()
-    {
-        SoftReference<BufferRecycler> ref = _recyclerRef.get();
-        BufferRecycler br = (ref == null) ? null : ref.get();
-
-        if (br == null) {
-            br = new BufferRecycler();
-            if (_bufferRecyclerTracker != null) {
-                ref = _bufferRecyclerTracker.wrapAndTrack(br);
-            } else {
-                ref = new SoftReference<BufferRecycler>(br);
-            }
-            _recyclerRef.set(ref);
-        }
-        return br;
-    }
-
-    /**
-     * Specialized method that will release all recycled {@link BufferRecycler} if
-     * (and only if) recycler tracking has been enabled
-     * (see {@link #SYSTEM_PROPERTY_TRACK_REUSABLE_BUFFERS}).
-     * This method is usually called on shutdown of the container like Application Server
-     * to ensure that no references are reachable via {@link ThreadLocal}s as this may cause
-     * unintentional retention of sizable amounts of memory. It may also be called regularly
-     * if GC for some reason does not clear up {@link SoftReference}s aggressively enough.
-     *
-     * @return Number of buffers released, if tracking enabled (zero or more); -1 if tracking not enabled.
-     *
-     * @since 2.9.6
-     */
-    public static int releaseBuffers() {
-        if (_bufferRecyclerTracker != null) {
-            return _bufferRecyclerTracker.releaseBuffers();
-        }
-        return -1;
-    }
-
     /*
     /**********************************************************************
-    /* Default BufferRecyclerPool implementations
+    /* Accessor for default BufferRecyclerPool implementations
     /**********************************************************************
      */
 
@@ -113,6 +26,12 @@ public class BufferRecyclers
         return NonRecyclingRecyclerPool.INSTANCE;
     }
 
+    /*
+    /**********************************************************************
+    /* Standard BufferRecyclerPool implementations
+    /**********************************************************************
+     */
+    
     /**
      * Default {@link BufferRecyclerPool} implementation that uses
      * {@link ThreadLocal} for recycling instances.
@@ -121,8 +40,34 @@ public class BufferRecyclers
         implements BufferRecyclerPool
     {
         private static final long serialVersionUID = 1L;
+
+        /**
+         * This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftReference}
+         * to a {@link BufferRecycler} used to provide a low-cost
+         * buffer recycling between reader and writer instances.
+         */
+        protected final static ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef
+            = new ThreadLocal<SoftReference<BufferRecycler>>();
+
         public final static ThreadLocalRecyclerPool INSTANCE = new ThreadLocalRecyclerPool();
 
+        /**
+         * Main accessor to call for accessing possibly recycled {@link BufferRecycler} instance.
+         *
+         * @return {@link BufferRecycler} to use
+         */
+        private  BufferRecycler getBufferRecycler()
+        {
+            SoftReference<BufferRecycler> ref = _recyclerRef.get();
+            BufferRecycler br = (ref == null) ? null : ref.get();
+
+            if (br == null) {
+                br = new BufferRecycler();
+                _recyclerRef.set(ref);
+            }
+            return br;
+        }
+
         @Override
         public BufferRecycler acquireBufferRecycler(TokenStreamFactory forFactory) {
             return getBufferRecycler();
