diff --git a/turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs b/turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs
index 94aa656807..22ca9d63c0 100644
--- a/turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs
+++ b/turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs
@@ -765,7 +765,8 @@ struct Analyzer<'a> {
 
     var_decl_kind: Option<VarDeclKind>,
 
-    /// Used for patterns
+    /// The RHS (or some part of it) of a pattern assignment, read by the individual parts of the
+    /// pattern assignment.
     current_value: Option<JsValue>,
 
     /// Return values of the current function.
@@ -1740,6 +1741,34 @@ impl VisitAstPath for Analyzer<'_> {
         n.visit_children_with_ast_path(self, ast_path);
     }
 
+    fn visit_assign_target_pat<'ast: 'r, 'r>(
+        &mut self,
+        pat: &'ast AssignTargetPat,
+        ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,
+    ) {
+        let value = self
+            .current_value
+            .take()
+            .unwrap_or_else(|| JsValue::unknown_empty(false, "pattern without value"));
+        match pat {
+            AssignTargetPat::Array(arr) => {
+                let mut ast_path = ast_path.with_guard(AstParentNodeRef::AssignTargetPat(
+                    pat,
+                    AssignTargetPatField::Array,
+                ));
+                self.handle_array_pat_with_value(arr, value, &mut ast_path);
+            }
+            AssignTargetPat::Object(obj) => {
+                let mut ast_path = ast_path.with_guard(AstParentNodeRef::AssignTargetPat(
+                    pat,
+                    AssignTargetPatField::Object,
+                ));
+                self.handle_object_pat_with_value(obj, value, &mut ast_path);
+            }
+            AssignTargetPat::Invalid(_) => {}
+        }
+    }
+
     fn visit_pat<'ast: 'r, 'r>(
         &mut self,
         pat: &'ast Pat,
@@ -1761,60 +1790,22 @@ impl VisitAstPath for Analyzer<'_> {
             }
 
             Pat::Array(arr) => {
-                match &value {
-                    Some(JsValue::Array { items, .. }) => {
-                        let mut ast_path =
-                            ast_path.with_guard(AstParentNodeRef::Pat(pat, PatField::Array));
-                        for (idx, elem) in arr.elems.iter().enumerate() {
-                            self.current_value = items.get(idx).cloned();
-                            let mut ast_path = ast_path.with_guard(AstParentNodeRef::ArrayPat(
-                                arr,
-                                ArrayPatField::Elems(idx),
-                            ));
-                            elem.visit_with_ast_path(self, &mut ast_path);
-                        }
-
-                        // We should not call visit_children_with
-                        return;
-                    }
-
-                    Some(value) => {
-                        let mut ast_path =
-                            ast_path.with_guard(AstParentNodeRef::Pat(pat, PatField::Array));
-                        for (idx, elem) in arr.elems.iter().enumerate() {
-                            self.current_value = Some(JsValue::member(
-                                Box::new(value.clone()),
-                                Box::new(JsValue::Constant(ConstantValue::Num(ConstantNumber(
-                                    idx as f64,
-                                )))),
-                            ));
-                            let mut ast_path = ast_path.with_guard(AstParentNodeRef::ArrayPat(
-                                arr,
-                                ArrayPatField::Elems(idx),
-                            ));
-                            elem.visit_with_ast_path(self, &mut ast_path);
-                        }
-                        // We should not call visit_children_with
-                        return;
-                    }
-
-                    None => {}
-                }
+                let mut ast_path = ast_path.with_guard(AstParentNodeRef::Pat(pat, PatField::Array));
+                let value =
+                    value.unwrap_or_else(|| JsValue::unknown_empty(false, "pattern without value"));
+                self.handle_array_pat_with_value(arr, value, &mut ast_path);
             }
 
             Pat::Object(obj) => {
+                let mut ast_path =
+                    ast_path.with_guard(AstParentNodeRef::Pat(pat, PatField::Object));
                 let value =
                     value.unwrap_or_else(|| JsValue::unknown_empty(false, "pattern without value"));
-
-                self.visit_pat_with_value(pat, obj, value, ast_path);
-
-                // We should not call visit_children_with
-                return;
+                self.handle_object_pat_with_value(obj, value, &mut ast_path);
             }
 
-            _ => {}
+            _ => pat.visit_children_with_ast_path(self, ast_path),
         }
-        pat.visit_children_with_ast_path(self, ast_path);
     }
 
     fn visit_return_stmt<'ast: 'r, 'r>(
@@ -2368,14 +2359,50 @@ impl Analyzer<'_> {
         }
     }
 
-    fn visit_pat_with_value<'ast: 'r, 'r>(
+    fn handle_array_pat_with_value<'ast: 'r, 'r>(
+        &mut self,
+        arr: &'ast ArrayPat,
+        current_value: JsValue,
+        ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,
+    ) {
+        match current_value {
+            JsValue::Array { items, .. } => {
+                for (idx, (elem_pat, value_item)) in arr
+                    .elems
+                    .iter()
+                    // TODO: This does not handle inline spreads correctly
+                    // e.g. `let [a,..b,c] = [1,2,3]`
+                    .zip(items.into_iter().map(Some).chain(iter::repeat(None)))
+                    .enumerate()
+                {
+                    self.current_value = value_item;
+                    let mut ast_path = ast_path
+                        .with_guard(AstParentNodeRef::ArrayPat(arr, ArrayPatField::Elems(idx)));
+                    elem_pat.visit_with_ast_path(self, &mut ast_path);
+                }
+            }
+            value => {
+                for (idx, elem) in arr.elems.iter().enumerate() {
+                    self.current_value = Some(JsValue::member(
+                        Box::new(value.clone()),
+                        Box::new(JsValue::Constant(ConstantValue::Num(ConstantNumber(
+                            idx as f64,
+                        )))),
+                    ));
+                    let mut ast_path = ast_path
+                        .with_guard(AstParentNodeRef::ArrayPat(arr, ArrayPatField::Elems(idx)));
+                    elem.visit_with_ast_path(self, &mut ast_path);
+                }
+            }
+        }
+    }
+
+    fn handle_object_pat_with_value<'ast: 'r, 'r>(
         &mut self,
-        pat: &'ast Pat,
         obj: &'ast ObjectPat,
         current_value: JsValue,
         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,
     ) {
-        let mut ast_path = ast_path.with_guard(AstParentNodeRef::Pat(pat, PatField::Object));
         for (i, prop) in obj.props.iter().enumerate() {
             let mut ast_path =
                 ast_path.with_guard(AstParentNodeRef::ObjectPat(obj, ObjectPatField::Props(i)));
diff --git a/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph-effects.snapshot b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph-effects.snapshot
new file mode 100644
index 0000000000..fe51488c70
--- /dev/null
+++ b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph-effects.snapshot
@@ -0,0 +1 @@
+[]
diff --git a/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph-explained.snapshot b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph-explained.snapshot
new file mode 100644
index 0000000000..3844257b7f
--- /dev/null
+++ b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph-explained.snapshot
@@ -0,0 +1,7 @@
+arrPatternBool = (true | false)
+
+nestedPatternBool = ({"inner": [true]}["inner"][0] | {"inner": [false]}["inner"][0])
+
+objPatternBool = ({"objPatternBool": true}["objPatternBool"] | {"objPatternBool": false}["objPatternBool"])
+
+singleAssignBool = {"singleAssignBool": true}["singleAssignBool"]
diff --git a/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph.snapshot b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph.snapshot
new file mode 100644
index 0000000000..c31b8183bc
--- /dev/null
+++ b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/graph.snapshot
@@ -0,0 +1,210 @@
+[
+    (
+        "arrPatternBool",
+        Alternatives {
+            total_nodes: 3,
+            values: [
+                Constant(
+                    True,
+                ),
+                Constant(
+                    False,
+                ),
+            ],
+            logical_property: None,
+        },
+    ),
+    (
+        "nestedPatternBool",
+        Alternatives {
+            total_nodes: 17,
+            values: [
+                Member(
+                    8,
+                    Member(
+                        6,
+                        Object {
+                            total_nodes: 4,
+                            parts: [
+                                KeyValue(
+                                    Constant(
+                                        Str(
+                                            Atom(
+                                                "inner",
+                                            ),
+                                        ),
+                                    ),
+                                    Array {
+                                        total_nodes: 2,
+                                        items: [
+                                            Constant(
+                                                True,
+                                            ),
+                                        ],
+                                        mutable: true,
+                                    },
+                                ),
+                            ],
+                            mutable: true,
+                        },
+                        Constant(
+                            Str(
+                                Atom(
+                                    "inner",
+                                ),
+                            ),
+                        ),
+                    ),
+                    Constant(
+                        Num(
+                            ConstantNumber(
+                                0.0,
+                            ),
+                        ),
+                    ),
+                ),
+                Member(
+                    8,
+                    Member(
+                        6,
+                        Object {
+                            total_nodes: 4,
+                            parts: [
+                                KeyValue(
+                                    Constant(
+                                        Str(
+                                            Atom(
+                                                "inner",
+                                            ),
+                                        ),
+                                    ),
+                                    Array {
+                                        total_nodes: 2,
+                                        items: [
+                                            Constant(
+                                                False,
+                                            ),
+                                        ],
+                                        mutable: true,
+                                    },
+                                ),
+                            ],
+                            mutable: true,
+                        },
+                        Constant(
+                            Str(
+                                Atom(
+                                    "inner",
+                                ),
+                            ),
+                        ),
+                    ),
+                    Constant(
+                        Num(
+                            ConstantNumber(
+                                0.0,
+                            ),
+                        ),
+                    ),
+                ),
+            ],
+            logical_property: None,
+        },
+    ),
+    (
+        "objPatternBool",
+        Alternatives {
+            total_nodes: 11,
+            values: [
+                Member(
+                    5,
+                    Object {
+                        total_nodes: 3,
+                        parts: [
+                            KeyValue(
+                                Constant(
+                                    Str(
+                                        Atom(
+                                            "objPatternBool",
+                                        ),
+                                    ),
+                                ),
+                                Constant(
+                                    True,
+                                ),
+                            ),
+                        ],
+                        mutable: true,
+                    },
+                    Constant(
+                        Str(
+                            Atom(
+                                "objPatternBool",
+                            ),
+                        ),
+                    ),
+                ),
+                Member(
+                    5,
+                    Object {
+                        total_nodes: 3,
+                        parts: [
+                            KeyValue(
+                                Constant(
+                                    Str(
+                                        Atom(
+                                            "objPatternBool",
+                                        ),
+                                    ),
+                                ),
+                                Constant(
+                                    False,
+                                ),
+                            ),
+                        ],
+                        mutable: true,
+                    },
+                    Constant(
+                        Str(
+                            Atom(
+                                "objPatternBool",
+                            ),
+                        ),
+                    ),
+                ),
+            ],
+            logical_property: None,
+        },
+    ),
+    (
+        "singleAssignBool",
+        Member(
+            5,
+            Object {
+                total_nodes: 3,
+                parts: [
+                    KeyValue(
+                        Constant(
+                            Str(
+                                Atom(
+                                    "singleAssignBool",
+                                ),
+                            ),
+                        ),
+                        Constant(
+                            True,
+                        ),
+                    ),
+                ],
+                mutable: true,
+            },
+            Constant(
+                Str(
+                    Atom(
+                        "singleAssignBool",
+                    ),
+                ),
+            ),
+        ),
+    ),
+]
diff --git a/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/input.js b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/input.js
new file mode 100644
index 0000000000..2de4e84c2c
--- /dev/null
+++ b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/input.js
@@ -0,0 +1,10 @@
+const { singleAssignBool } = { singleAssignBool: true };
+
+let { objPatternBool } = { objPatternBool: true };
+({ objPatternBool } = { objPatternBool: false });
+
+let [ arrPatternBool ] = [ true ];
+[arrPatternBool] = [false];
+
+let [{inner: [ nestedPatternBool ]}] = [{inner: [ true ]}];
+[{inner: [ nestedPatternBool ]}] = [{inner: [ false ]}];
diff --git a/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/resolved-explained.snapshot b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/resolved-explained.snapshot
new file mode 100644
index 0000000000..c520d461fa
--- /dev/null
+++ b/turbopack/crates/turbopack-ecmascript/tests/analyzer/graph/pattern-assignment/resolved-explained.snapshot
@@ -0,0 +1,18 @@
+arrPatternBool = (true | false)
+
+nestedPatternBool = (true | ???*0* | ???*1* | false)
+- *0* unknown mutation
+  ⚠️  This value might have side effects
+- *1* ???*2*[0]
+  ⚠️  unknown object
+  ⚠️  This value might have side effects
+- *2* unknown mutation
+  ⚠️  This value might have side effects
+
+objPatternBool = (true | ???*0* | false)
+- *0* unknown mutation
+  ⚠️  This value might have side effects
+
+singleAssignBool = (true | ???*0*)
+- *0* unknown mutation
+  ⚠️  This value might have side effects
diff --git a/turbopack/crates/turbopack-tests/tests/execution/turbopack/side-effects-optimization/assignment/input/index.js b/turbopack/crates/turbopack-tests/tests/execution/turbopack/side-effects-optimization/assignment/input/index.js
new file mode 100644
index 0000000000..e9499cfb85
--- /dev/null
+++ b/turbopack/crates/turbopack-tests/tests/execution/turbopack/side-effects-optimization/assignment/input/index.js
@@ -0,0 +1,213 @@
+let count = 0
+
+describe('Simple Assignment', () => {
+  it('handles static declaration', () => {
+    const bool = true
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles static expression', () => {
+    let bool = false
+    bool = true
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic declaration', () => {
+    function dynamic() {
+      return true
+    }
+    const bool = dynamic()
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic expression', () => {
+    function dynamic() {
+      return true
+    }
+    let bool = false
+    bool = dynamic()
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+})
+
+describe('Object Patterns', () => {
+  it('handles static declaration', () => {
+    const { bool } = {
+      bool: true,
+    }
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles static expression', () => {
+    let bool = false
+    ;({ bool } = {
+      bool: true,
+    })
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic declaration', () => {
+    function dynamic() {
+      return {
+        bool: true,
+      }
+    }
+    const { bool } = dynamic()
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic expression', () => {
+    function dynamic() {
+      return {
+        bool: true,
+      }
+    }
+    let bool = false
+    ;({ bool } = dynamic())
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+})
+
+describe('Array Patterns', () => {
+  it('handles static declaration', () => {
+    const [bool] = [true]
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles static expression', () => {
+    let bool = false
+    ;[bool] = [true]
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic declaration', () => {
+    function dynamic() {
+      return [true]
+    }
+    const [bool] = dynamic()
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic expression', () => {
+    function dynamic() {
+      return [true]
+    }
+    let bool = false
+    ;[bool] = dynamic()
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+})
+
+describe('Nested Patterns', () => {
+  it('handles static declaration', () => {
+    const {
+      inner: [bool],
+    } = {
+      inner: [true],
+    }
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles static expression', () => {
+    let bool = false
+    ;({
+      inner: [bool],
+    } = {
+      inner: [true],
+    })
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic declaration', () => {
+    function dynamic() {
+      return {
+        inner: [true],
+      }
+    }
+    const {
+      inner: [bool],
+    } = dynamic()
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+
+  it('handles dynamic expression', () => {
+    function dynamic() {
+      return {
+        inner: [true],
+      }
+    }
+    let bool = false
+    ;({
+      inner: [bool],
+    } = dynamic())
+    if (bool) {
+      count++
+    } else {
+      throw Error('this branch is not taken')
+    }
+  })
+})
+
+it('took the right number of branches', () => {
+  expect(count).toEqual(16)
+})
